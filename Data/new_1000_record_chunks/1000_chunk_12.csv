record_number,buggy_code,fixed_code
11001,"private Expression promoteListExpression(Expression expression,Conversion conversion){
  if (conversion.getConversion() != null) {
    expression=convertExpression(expression,conversion.getConversion());
  }
  if (expression.getResultType().equals(resolveTypeName(""String_Node_Str"",""String_Node_Str""))) {
    reportWarning(""String_Node_Str"",expression);
  }
  ToList toList=of.createToList().withOperand(expression);
  toList.setResultType(new ListType(expression.getResultType()));
  return toList;
}","private Expression promoteListExpression(Expression expression,Conversion conversion){
  if (conversion.getConversion() != null) {
    expression=convertExpression(expression,conversion.getConversion());
  }
  if (expression.getResultType().equals(resolveTypeName(""String_Node_Str"",""String_Node_Str""))) {
    reportWarning(""String_Node_Str"",expression);
  }
  return resolveToList(expression);
}"
11002,"@Override public void syntaxError(Recognizer<?,?> recognizer,Object offendingSymbol,int line,int charPositionInLine,String msg,RecognitionException e){
  if (!((Token)offendingSymbol).getText().trim().isEmpty()) {
    result.addError(new Exception(String.format(""String_Node_Str"",line,charPositionInLine,msg)));
  }
}","@Override public void syntaxError(Recognizer<?,?> recognizer,Object offendingSymbol,int line,int charPositionInLine,String msg,RecognitionException e){
  if (!((Token)offendingSymbol).getText().trim().isEmpty()) {
    errors.add(new Exception(String.format(""String_Node_Str"",line,charPositionInLine,msg)));
  }
}"
11003,"public static String getInputStreamAsString(InputStream is){
  input=new BufferedReader(new InputStreamReader(is)).lines().collect(Collectors.joining(""String_Node_Str""));
  return input;
}","public static String getInputStreamAsString(InputStream is){
  return new BufferedReader(new InputStreamReader(is)).lines().collect(Collectors.joining(""String_Node_Str""));
}"
11004,"@Override public Object visitTerminal(TerminalNode node){
  appendTerminal(node.getText());
  return super.visitTerminal(node);
}","@Override public Object visitTerminal(TerminalNode node){
  checkForComment(node);
  appendTerminal(node.getText());
  return super.visitTerminal(node);
}"
11005,"public static String getFormattedOutput(InputStream is) throws IOException {
  ANTLRInputStream in=new ANTLRInputStream(is);
  cqlLexer lexer=new cqlLexer(in);
  CommonTokenStream tokens=new CommonTokenStream(lexer);
  tokens.fill();
  CommentListener listener=new CommentListener(tokens);
  listener.rewriteTokens();
  cqlParser parser=new cqlParser(listener.tokens);
  parser.addErrorListener(new SyntaxErrorListener());
  parser.setBuildParseTree(true);
  ParserRuleContext tree=parser.library();
  CqlFormatterVisitor formatter=new CqlFormatterVisitor();
  String output=(String)formatter.visit(tree);
  if (!((SyntaxErrorListener)parser.getErrorListeners().get(1)).result.errors.isEmpty()) {
    CqlFormatterVisitor.endResult.setCql(input);
    CqlFormatterVisitor.endResult.setErrors(((SyntaxErrorListener)parser.getErrorListeners().get(1)).result.errors);
    return CqlFormatterVisitor.endResult.inputInError();
  }
  return listener.refineOutput(output);
}","public static String getFormattedOutput(InputStream is) throws IOException {
  ANTLRInputStream in=new ANTLRInputStream(is);
  cqlLexer lexer=new cqlLexer(in);
  CommonTokenStream tokens=new CommonTokenStream(lexer);
  tokens.fill();
  populateComments(tokens);
  cqlParser parser=new cqlParser(tokens);
  parser.addErrorListener(new SyntaxErrorListener());
  parser.setBuildParseTree(true);
  ParserRuleContext tree=parser.library();
  if (((SyntaxErrorListener)parser.getErrorListeners().get(1)).errors.size() > 0) {
    return ((SyntaxErrorListener)parser.getErrorListeners().get(1)).errors.toString() + ""String_Node_Str"" + in.toString();
  }
  CqlFormatterVisitor formatter=new CqlFormatterVisitor();
  String output=(String)formatter.visit(tree);
  if (comments.size() > 0) {
    StringBuilder eofComments=new StringBuilder().append(""String_Node_Str"");
    for (    Token comment : comments) {
      eofComments.append(comment.getText()).append(""String_Node_Str"");
    }
    comments.clear();
    output+=eofComments.toString();
  }
  return output;
}"
11006,"@Override public Object visitChildren(RuleNode node){
  Object result=defaultResult();
  int n=node.getChildCount();
  for (int i=0; i < n; i++) {
    if (!shouldVisitNextChild(node,result)) {
      break;
    }
    ParseTree c=node.getChild(i);
    if (c instanceof ErrorNodeImpl) {
      c=new TerminalNodeImpl(((ErrorNodeImpl)c).getSymbol());
    }
    if ((node instanceof cqlParser.TupleSelectorContext || node instanceof cqlParser.TupleTypeSpecifierContext) && c instanceof TerminalNodeImpl) {
      if (((TerminalNodeImpl)c).getSymbol().getText().equals(""String_Node_Str"")) {
        decreaseIndentLevel();
        newLine();
      }
    }
    Object childResult=c.accept(this);
    result=aggregateResult(result,childResult);
  }
  return result;
}","@Override public Object visitChildren(RuleNode node){
  Object result=defaultResult();
  int n=node.getChildCount();
  for (int i=0; i < n; i++) {
    if (!shouldVisitNextChild(node,result)) {
      break;
    }
    ParseTree c=node.getChild(i);
    if ((node instanceof cqlParser.TupleSelectorContext || node instanceof cqlParser.TupleTypeSpecifierContext) && c instanceof TerminalNodeImpl) {
      if (((TerminalNodeImpl)c).getSymbol().getText().equals(""String_Node_Str"")) {
        decreaseIndentLevel();
        newLine();
      }
    }
    Object childResult=c.accept(this);
    result=aggregateResult(result,childResult);
  }
  return result;
}"
11007,"@Test public void TestFormatterSpecific() throws IOException {
  runTest(""String_Node_Str"");
  try {
    runTest(""String_Node_Str"");
  }
 catch (  AssertionError ae) {
  }
}","@Test public void TestFormatterSpecific() throws IOException {
  try {
    runTest(""String_Node_Str"");
  }
 catch (  AssertionError ae) {
  }
  try {
    runTest(""String_Node_Str"");
  }
 catch (  AssertionError ae) {
  }
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  runTest(""String_Node_Str"");
  try {
    runTest(""String_Node_Str"");
  }
 catch (  AssertionError ae) {
  }
}"
11008,"@Override public Object visitOverlapsIntervalOperatorPhrase(@NotNull cqlParser.OverlapsIntervalOperatorPhraseContext ctx){
  String operatorName=null;
  BinaryExpression operator;
  String dateTimePrecision=ctx.dateTimePrecisionSpecifier() != null ? ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText() : null;
  if (ctx.getChildCount() == (1 + dateTimePrecision == null ? 0 : 1)) {
    operator=dateTimePrecision != null ? of.createOverlaps().withPrecision(parseDateTimePrecision(dateTimePrecision)) : of.createOverlaps();
    operatorName=""String_Node_Str"";
  }
 else {
    if (""String_Node_Str"".equals(ctx.getChild(1).getText())) {
      operator=dateTimePrecision != null ? of.createOverlapsBefore().withPrecision(parseDateTimePrecision(dateTimePrecision)) : of.createOverlapsBefore();
      operatorName=""String_Node_Str"";
    }
 else {
      operator=dateTimePrecision != null ? of.createOverlapsAfter().withPrecision(parseDateTimePrecision(dateTimePrecision)) : of.createOverlapsAfter();
      operatorName=""String_Node_Str"";
    }
  }
  operator.withOperand(timingOperators.peek().getLeft(),timingOperators.peek().getRight());
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",operatorName,operator);
  return operator;
}","@Override public Object visitOverlapsIntervalOperatorPhrase(@NotNull cqlParser.OverlapsIntervalOperatorPhraseContext ctx){
  String operatorName=null;
  BinaryExpression operator;
  String dateTimePrecision=ctx.dateTimePrecisionSpecifier() != null ? ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText() : null;
  if (ctx.getChildCount() == (1 + (dateTimePrecision == null ? 0 : 1))) {
    operator=dateTimePrecision != null ? of.createOverlaps().withPrecision(parseDateTimePrecision(dateTimePrecision)) : of.createOverlaps();
    operatorName=""String_Node_Str"";
  }
 else {
    if (""String_Node_Str"".equals(ctx.getChild(1).getText())) {
      operator=dateTimePrecision != null ? of.createOverlapsBefore().withPrecision(parseDateTimePrecision(dateTimePrecision)) : of.createOverlapsBefore();
      operatorName=""String_Node_Str"";
    }
 else {
      operator=dateTimePrecision != null ? of.createOverlapsAfter().withPrecision(parseDateTimePrecision(dateTimePrecision)) : of.createOverlapsAfter();
      operatorName=""String_Node_Str"";
    }
  }
  operator.withOperand(timingOperators.peek().getLeft(),timingOperators.peek().getRight());
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",operatorName,operator);
  return operator;
}"
11009,"@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  libraryBuilder.pushQueryContext(queryContext);
  try {
    List<AliasedQuerySource> sources;
    queryContext.enterSourceClause();
    try {
      sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
    }
  finally {
      queryContext.exitSourceClause();
    }
    queryContext.addQuerySources(sources);
    boolean expressionContextPushed=false;
    if (libraryBuilder.inPopulationContext() && queryContext.referencesPatientContext()) {
      libraryBuilder.pushExpressionContext(""String_Node_Str"");
      expressionContextPushed=true;
    }
    try {
      List<LetClause> dfcx=ctx.letClause() != null ? (List<LetClause>)visit(ctx.letClause()) : null;
      List<RelationshipClause> qicx=new ArrayList<>();
      if (ctx.queryInclusionClause() != null) {
        for (        cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
          qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
        }
      }
      Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
      if (dateRangeOptimization && where != null) {
        for (        AliasedQuerySource aqs : sources) {
          where=optimizeDateRangeInQuery(where,aqs);
        }
      }
      ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
      if ((ret == null) && (sources.size() > 1)) {
        ret=of.createReturnClause().withDistinct(true);
        Tuple returnExpression=of.createTuple();
        TupleType returnType=new TupleType();
        for (        AliasedQuerySource aqs : sources) {
          TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
          element.getValue().setResultType(aqs.getResultType());
          element.setResultType(element.getValue().getResultType());
          returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
          returnExpression.getElement().add(element);
        }
        returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
        ret.setExpression(returnExpression);
        ret.setResultType(returnExpression.getResultType());
      }
      queryContext.removeQuerySources(sources);
      if (dfcx != null) {
        queryContext.removeLetClauses(dfcx);
      }
      DataType queryResultType=ret == null ? sources.get(0).getResultType() : ret.getResultType();
      queryContext.setResultElementType(queryContext.isSingular() ? null : ((ListType)queryResultType).getElementType());
      SortClause sort=null;
      if (ctx.sortClause() != null) {
        if (queryContext.isSingular()) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        queryContext.enterSortClause();
        try {
          sort=(SortClause)visit(ctx.sortClause());
          for (          SortByItem sortByItem : sort.getBy()) {
            if (sortByItem instanceof ByDirection) {
              libraryBuilder.verifyComparable(queryContext.getResultElementType());
            }
 else {
              libraryBuilder.verifyComparable(sortByItem.getResultType());
            }
          }
        }
  finally {
          queryContext.exitSortClause();
        }
      }
      Query query=of.createQuery().withSource(sources).withLet(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
      query.setResultType(queryResultType);
      return query;
    }
  finally {
      if (expressionContextPushed) {
        libraryBuilder.popExpressionContext();
      }
    }
  }
  finally {
    libraryBuilder.popQueryContext();
  }
}","@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  libraryBuilder.pushQueryContext(queryContext);
  try {
    List<AliasedQuerySource> sources;
    queryContext.enterSourceClause();
    try {
      sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
    }
  finally {
      queryContext.exitSourceClause();
    }
    queryContext.addQuerySources(sources);
    boolean expressionContextPushed=false;
    if (libraryBuilder.inPopulationContext() && queryContext.referencesPatientContext()) {
      libraryBuilder.pushExpressionContext(""String_Node_Str"");
      expressionContextPushed=true;
    }
    try {
      List<LetClause> dfcx=ctx.letClause() != null ? (List<LetClause>)visit(ctx.letClause()) : null;
      List<RelationshipClause> qicx=new ArrayList<>();
      if (ctx.queryInclusionClause() != null) {
        for (        cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
          qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
        }
      }
      Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
      if (dateRangeOptimization && where != null) {
        for (        AliasedQuerySource aqs : sources) {
          where=optimizeDateRangeInQuery(where,aqs);
        }
      }
      ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
      if ((ret == null) && (sources.size() > 1)) {
        ret=of.createReturnClause().withDistinct(true);
        Tuple returnExpression=of.createTuple();
        TupleType returnType=new TupleType();
        for (        AliasedQuerySource aqs : sources) {
          TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
          DataType sourceType=aqs.getResultType() instanceof ListType ? ((ListType)aqs.getResultType()).getElementType() : aqs.getResultType();
          element.getValue().setResultType(sourceType);
          element.setResultType(element.getValue().getResultType());
          returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
          returnExpression.getElement().add(element);
        }
        returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
        ret.setExpression(returnExpression);
        ret.setResultType(returnExpression.getResultType());
      }
      queryContext.removeQuerySources(sources);
      if (dfcx != null) {
        queryContext.removeLetClauses(dfcx);
      }
      DataType queryResultType=ret == null ? sources.get(0).getResultType() : ret.getResultType();
      queryContext.setResultElementType(queryContext.isSingular() ? null : ((ListType)queryResultType).getElementType());
      SortClause sort=null;
      if (ctx.sortClause() != null) {
        if (queryContext.isSingular()) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        queryContext.enterSortClause();
        try {
          sort=(SortClause)visit(ctx.sortClause());
          for (          SortByItem sortByItem : sort.getBy()) {
            if (sortByItem instanceof ByDirection) {
              libraryBuilder.verifyComparable(queryContext.getResultElementType());
            }
 else {
              libraryBuilder.verifyComparable(sortByItem.getResultType());
            }
          }
        }
  finally {
          queryContext.exitSortClause();
        }
      }
      Query query=of.createQuery().withSource(sources).withLet(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
      query.setResultType(queryResultType);
      return query;
    }
  finally {
      if (expressionContextPushed) {
        libraryBuilder.popExpressionContext();
      }
    }
  }
  finally {
    libraryBuilder.popQueryContext();
  }
}"
11010,"@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  libraryBuilder.pushQueryContext(queryContext);
  try {
    List<AliasedQuerySource> sources;
    queryContext.enterSourceClause();
    try {
      sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
    }
  finally {
      queryContext.exitSourceClause();
    }
    queryContext.addQuerySources(sources);
    boolean expressionContextPushed=false;
    if (libraryBuilder.inPopulationContext() && queryContext.referencesPatientContext()) {
      libraryBuilder.pushExpressionContext(""String_Node_Str"");
      expressionContextPushed=true;
    }
    try {
      List<LetClause> dfcx=ctx.letClause() != null ? (List<LetClause>)visit(ctx.letClause()) : null;
      List<RelationshipClause> qicx=new ArrayList<>();
      if (ctx.queryInclusionClause() != null) {
        for (        cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
          qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
        }
      }
      Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
      if (dateRangeOptimization && where != null) {
        for (        AliasedQuerySource aqs : sources) {
          where=optimizeDateRangeInQuery(where,aqs);
        }
      }
      ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
      if ((ret == null) && (sources.size() > 1)) {
        ret=of.createReturnClause().withDistinct(true);
        Tuple returnExpression=of.createTuple();
        TupleType returnType=new TupleType();
        for (        AliasedQuerySource aqs : sources) {
          TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
          element.getValue().setResultType(aqs.getResultType());
          element.setResultType(element.getValue().getResultType());
          returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
          returnExpression.getElement().add(element);
        }
        returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
        ret.setExpression(returnExpression);
        ret.setResultType(returnExpression.getResultType());
      }
      queryContext.removeQuerySources(sources);
      if (dfcx != null) {
        queryContext.removeLetClauses(dfcx);
      }
      DataType queryResultType=ret == null ? sources.get(0).getResultType() : ret.getResultType();
      queryContext.setResultElementType(queryContext.isSingular() ? null : ((ListType)queryResultType).getElementType());
      SortClause sort=null;
      if (ctx.sortClause() != null) {
        if (queryContext.isSingular()) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        queryContext.enterSortClause();
        try {
          sort=(SortClause)visit(ctx.sortClause());
          for (          SortByItem sortByItem : sort.getBy()) {
            if (sortByItem instanceof ByDirection) {
              libraryBuilder.verifyComparable(queryContext.getResultElementType());
            }
 else {
              libraryBuilder.verifyComparable(sortByItem.getResultType());
            }
          }
        }
  finally {
          queryContext.exitSortClause();
        }
      }
      Query query=of.createQuery().withSource(sources).withLet(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
      query.setResultType(queryResultType);
      return query;
    }
  finally {
      if (expressionContextPushed) {
        libraryBuilder.popExpressionContext();
      }
    }
  }
  finally {
    libraryBuilder.popQueryContext();
  }
}","@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  libraryBuilder.pushQueryContext(queryContext);
  try {
    List<AliasedQuerySource> sources;
    queryContext.enterSourceClause();
    try {
      sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
    }
  finally {
      queryContext.exitSourceClause();
    }
    queryContext.addQuerySources(sources);
    boolean expressionContextPushed=false;
    if (libraryBuilder.inPopulationContext() && queryContext.referencesPatientContext()) {
      libraryBuilder.pushExpressionContext(""String_Node_Str"");
      expressionContextPushed=true;
    }
    try {
      List<LetClause> dfcx=ctx.letClause() != null ? (List<LetClause>)visit(ctx.letClause()) : null;
      List<RelationshipClause> qicx=new ArrayList<>();
      if (ctx.queryInclusionClause() != null) {
        for (        cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
          qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
        }
      }
      Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
      if (dateRangeOptimization && where != null) {
        for (        AliasedQuerySource aqs : sources) {
          where=optimizeDateRangeInQuery(where,aqs);
        }
      }
      ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
      if ((ret == null) && (sources.size() > 1)) {
        ret=of.createReturnClause().withDistinct(true);
        Tuple returnExpression=of.createTuple();
        TupleType returnType=new TupleType();
        for (        AliasedQuerySource aqs : sources) {
          TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
          DataType sourceType=aqs.getResultType() instanceof ListType ? ((ListType)aqs.getResultType()).getElementType() : aqs.getResultType();
          element.getValue().setResultType(sourceType);
          element.setResultType(element.getValue().getResultType());
          returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
          returnExpression.getElement().add(element);
        }
        returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
        ret.setExpression(returnExpression);
        ret.setResultType(returnExpression.getResultType());
      }
      queryContext.removeQuerySources(sources);
      if (dfcx != null) {
        queryContext.removeLetClauses(dfcx);
      }
      DataType queryResultType=ret == null ? sources.get(0).getResultType() : ret.getResultType();
      queryContext.setResultElementType(queryContext.isSingular() ? null : ((ListType)queryResultType).getElementType());
      SortClause sort=null;
      if (ctx.sortClause() != null) {
        if (queryContext.isSingular()) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        queryContext.enterSortClause();
        try {
          sort=(SortClause)visit(ctx.sortClause());
          for (          SortByItem sortByItem : sort.getBy()) {
            if (sortByItem instanceof ByDirection) {
              libraryBuilder.verifyComparable(queryContext.getResultElementType());
            }
 else {
              libraryBuilder.verifyComparable(sortByItem.getResultType());
            }
          }
        }
  finally {
          queryContext.exitSortClause();
        }
      }
      Query query=of.createQuery().withSource(sources).withLet(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
      query.setResultType(queryResultType);
      return query;
    }
  finally {
      if (expressionContextPushed) {
        libraryBuilder.popExpressionContext();
      }
    }
  }
  finally {
    libraryBuilder.popQueryContext();
  }
}"
11011,"private Expression resolveFunction(String libraryName,String functionName,cqlParser.ParamListContext paramList){
  List<Expression> expressions=new ArrayList<Expression>();
  if (paramList != null && paramList.expression() != null) {
    for (    cqlParser.ExpressionContext expressionContext : paramList.expression()) {
      expressions.add((Expression)visit(expressionContext));
    }
  }
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,!checkForward);
  if (result == null) {
    libraryBuilder.pushExpressionDefinition(functionName);
    try {
      Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(functionName);
      if (functionInfos != null) {
        Stack<Chunk> saveChunks=chunks;
        chunks=new Stack<Chunk>();
        try {
          for (          FunctionDefinitionInfo functionInfo : functionInfos) {
            String saveContext=currentContext;
            currentContext=functionInfo.getContext();
            try {
              internalVisitFunctionDefinition(functionInfo.getDefinition());
            }
  finally {
              currentContext=saveContext;
            }
          }
        }
  finally {
          chunks=saveChunks;
        }
      }
      result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,true);
    }
  finally {
      libraryBuilder.popExpressionDefinition();
    }
  }
  return result;
}","private Expression resolveFunction(String libraryName,String functionName,cqlParser.ParamListContext paramList){
  List<Expression> expressions=new ArrayList<Expression>();
  if (paramList != null && paramList.expression() != null) {
    for (    cqlParser.ExpressionContext expressionContext : paramList.expression()) {
      expressions.add((Expression)visit(expressionContext));
    }
  }
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,!checkForward);
  if (result == null) {
    Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(functionName);
    if (functionInfos != null) {
      Stack<Chunk> saveChunks=chunks;
      chunks=new Stack<Chunk>();
      try {
        for (        FunctionDefinitionInfo functionInfo : functionInfos) {
          String saveContext=currentContext;
          currentContext=functionInfo.getContext();
          try {
            internalVisitFunctionDefinition(functionInfo.getDefinition());
          }
  finally {
            currentContext=saveContext;
          }
        }
      }
  finally {
        chunks=saveChunks;
      }
    }
    result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,true);
  }
  return result;
}"
11012,"public ExpressionDef internalVisitExpressionDefinition(@NotNull cqlParser.ExpressionDefinitionContext ctx){
  String identifier=parseString(ctx.identifier());
  ExpressionDef def=libraryBuilder.resolveExpressionRef(identifier);
  if (def == null) {
    libraryBuilder.pushExpressionDefinition(identifier);
    libraryBuilder.pushExpressionContext(currentContext);
    try {
      def=of.createExpressionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(identifier).withContext(currentContext).withExpression((Expression)visit(ctx.expression()));
      def.setResultType(def.getExpression().getResultType());
      libraryBuilder.addExpression(def);
    }
  finally {
      libraryBuilder.popExpressionDefinition();
      libraryBuilder.popExpressionContext();
    }
  }
  return def;
}","public ExpressionDef internalVisitExpressionDefinition(@NotNull cqlParser.ExpressionDefinitionContext ctx){
  String identifier=parseString(ctx.identifier());
  ExpressionDef def=libraryBuilder.resolveExpressionRef(identifier);
  if (def == null) {
    libraryBuilder.pushExpressionContext(currentContext);
    try {
      libraryBuilder.pushExpressionDefinition(identifier);
      try {
        def=of.createExpressionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(identifier).withContext(currentContext).withExpression((Expression)visit(ctx.expression()));
        def.setResultType(def.getExpression().getResultType());
        libraryBuilder.addExpression(def);
      }
  finally {
        libraryBuilder.popExpressionDefinition();
      }
    }
  finally {
      libraryBuilder.popExpressionContext();
    }
  }
  return def;
}"
11013,"public Object internalVisitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  TypeSpecifier resultType=null;
  if (ctx.typeSpecifier() != null) {
    resultType=parseTypeSpecifier(ctx.typeSpecifier());
  }
  if (!libraryBuilder.getTranslatedLibrary().contains(fun)) {
    if (ctx.functionBody() != null) {
      libraryBuilder.beginFunctionDef(fun);
      try {
        libraryBuilder.pushExpressionContext(currentContext);
        try {
          fun.setExpression(parseExpression(ctx.functionBody()));
        }
  finally {
          libraryBuilder.popExpressionContext();
        }
      }
  finally {
        libraryBuilder.endFunctionDef();
      }
      if (resultType != null && fun.getExpression() != null && fun.getExpression().getResultType() != null) {
        if (!DataTypes.subTypeOf(fun.getExpression().getResultType(),resultType.getResultType())) {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",fun.getName(),resultType.getResultType(),fun.getExpression().getResultType()));
        }
      }
      fun.setResultType(fun.getExpression().getResultType());
    }
 else {
      fun.setExternal(true);
      if (resultType == null) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",fun.getName()));
      }
      fun.setResultType(resultType.getResultType());
    }
    fun.setContext(currentContext);
    if (fun.getResultType() != null) {
      libraryBuilder.addExpression(fun);
    }
  }
  return fun;
}","public Object internalVisitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  TypeSpecifier resultType=null;
  if (ctx.typeSpecifier() != null) {
    resultType=parseTypeSpecifier(ctx.typeSpecifier());
  }
  if (!libraryBuilder.getTranslatedLibrary().contains(fun)) {
    if (ctx.functionBody() != null) {
      libraryBuilder.beginFunctionDef(fun);
      try {
        libraryBuilder.pushExpressionContext(currentContext);
        try {
          libraryBuilder.pushExpressionDefinition(String.format(""String_Node_Str"",fun.getName()));
          try {
            fun.setExpression(parseExpression(ctx.functionBody()));
          }
  finally {
            libraryBuilder.popExpressionDefinition();
          }
        }
  finally {
          libraryBuilder.popExpressionContext();
        }
      }
  finally {
        libraryBuilder.endFunctionDef();
      }
      if (resultType != null && fun.getExpression() != null && fun.getExpression().getResultType() != null) {
        if (!DataTypes.subTypeOf(fun.getExpression().getResultType(),resultType.getResultType())) {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",fun.getName(),resultType.getResultType(),fun.getExpression().getResultType()));
        }
      }
      fun.setResultType(fun.getExpression().getResultType());
    }
 else {
      fun.setExternal(true);
      if (resultType == null) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",fun.getName()));
      }
      fun.setResultType(resultType.getResultType());
    }
    fun.setContext(currentContext);
    if (fun.getResultType() != null) {
      libraryBuilder.addExpression(fun);
    }
  }
  return fun;
}"
11014,"private OperandRef resolveOperandRef(String identifier){
  if (currentFunctionDef != null) {
    for (    OperandDef operand : currentFunctionDef.getOperand()) {
      if (operand.getName().equals(identifier)) {
        return (OperandRef)of.createOperandRef().withName(identifier).withResultType(operand.getResultType());
      }
    }
  }
  return null;
}","private OperandRef resolveOperandRef(String identifier){
  if (!functionDefs.empty()) {
    for (    OperandDef operand : functionDefs.peek().getOperand()) {
      if (operand.getName().equals(identifier)) {
        return (OperandRef)of.createOperandRef().withName(identifier).withResultType(operand.getResultType());
      }
    }
  }
  return null;
}"
11015,"public Expression popExpressionTarget(){
  return targets.pop();
}","public Expression popExpressionTarget(){
  return getScope().getTargets().pop();
}"
11016,"public boolean inQueryContext(){
  return queries.size() > 0;
}","public boolean inQueryContext(){
  return hasScope() && getScope().getQueries().size() > 0;
}"
11017,"private LetClause resolveQueryLet(String identifier){
  for (  QueryContext query : queries) {
    LetClause let=query.resolveLet(identifier);
    if (let != null) {
      return let;
    }
  }
  return null;
}","private LetClause resolveQueryLet(String identifier){
  if (inQueryContext()) {
    for (int i=getScope().getQueries().size() - 1; i >= 0; i--) {
      LetClause let=getScope().getQueries().get(i).resolveLet(identifier);
      if (let != null) {
        return let;
      }
    }
  }
  return null;
}"
11018,"public void pushQueryContext(QueryContext context){
  queries.push(context);
}","public void pushQueryContext(QueryContext context){
  getScope().getQueries().push(context);
}"
11019,"public void pushExpressionTarget(Expression target){
  targets.push(target);
}","public void pushExpressionTarget(Expression target){
  getScope().getTargets().push(target);
}"
11020,"public void endFunctionDef(){
  currentFunctionDef=null;
}","public void endFunctionDef(){
  functionDefs.pop();
}"
11021,"public boolean hasExpressionTarget(){
  return !targets.isEmpty();
}","public boolean hasExpressionTarget(){
  return hasScope() && !getScope().getTargets().isEmpty();
}"
11022,"private IdentifierRef resolveQueryResultElement(String identifier){
  if (queries.size() > 0) {
    QueryContext query=queries.peek();
    if (query.inSortClause() && !query.isSingular()) {
      DataType sortColumnType=resolveProperty(query.getResultElementType(),identifier,false);
      if (sortColumnType != null) {
        IdentifierRef result=new IdentifierRef().withName(identifier);
        result.setResultType(sortColumnType);
        return result;
      }
    }
  }
  return null;
}","private IdentifierRef resolveQueryResultElement(String identifier){
  if (inQueryContext()) {
    QueryContext query=peekQueryContext();
    if (query.inSortClause() && !query.isSingular()) {
      DataType sortColumnType=resolveProperty(query.getResultElementType(),identifier,false);
      if (sortColumnType != null) {
        IdentifierRef result=new IdentifierRef().withName(identifier);
        result.setResultType(sortColumnType);
        return result;
      }
    }
  }
  return null;
}"
11023,"private DataType getExpressionDefResultType(ExpressionDef expressionDef){
  if (currentExpressionContext().equals(expressionDef.getContext())) {
    return expressionDef.getResultType();
  }
  if (inPatientContext()) {
    return expressionDef.getResultType();
  }
  if (inPopulationContext()) {
    if (!queries.empty() && queries.peek().inSourceClause()) {
      queries.peek().referencePatientContext();
    }
    DataType resultType=expressionDef.getResultType();
    if (!(resultType instanceof ListType)) {
      return new ListType(resultType);
    }
 else {
      return resultType;
    }
  }
  throw new IllegalArgumentException(String.format(""String_Node_Str"",currentExpressionContext(),expressionDef.getContext()));
}","private DataType getExpressionDefResultType(ExpressionDef expressionDef){
  if (currentExpressionContext().equals(expressionDef.getContext())) {
    return expressionDef.getResultType();
  }
  if (inPatientContext()) {
    return expressionDef.getResultType();
  }
  if (inPopulationContext()) {
    if (inQueryContext() && getScope().getQueries().peek().inSourceClause()) {
      getScope().getQueries().peek().referencePatientContext();
    }
    DataType resultType=expressionDef.getResultType();
    if (!(resultType instanceof ListType)) {
      return new ListType(resultType);
    }
 else {
      return resultType;
    }
  }
  throw new IllegalArgumentException(String.format(""String_Node_Str"",currentExpressionContext(),expressionDef.getContext()));
}"
11024,"public QueryContext popQueryContext(){
  return queries.pop();
}","public QueryContext popQueryContext(){
  return getScope().getQueries().pop();
}"
11025,"public void beginFunctionDef(FunctionDef functionDef){
  currentFunctionDef=functionDef;
}","public void beginFunctionDef(FunctionDef functionDef){
  functionDefs.push(functionDef);
}"
11026,"public QueryContext peekQueryContext(){
  return queries.peek();
}","public QueryContext peekQueryContext(){
  return getScope().getQueries().peek();
}"
11027,"private Expression resolveQueryThisElement(String identifier){
  if (queries.size() > 0) {
    QueryContext query=queries.peek();
    if (query.isImplicit()) {
      AliasedQuerySource source=resolveAlias(""String_Node_Str"");
      if (source != null) {
        AliasRef aliasRef=of.createAliasRef().withName(""String_Node_Str"");
        if (source.getResultType() instanceof ListType) {
          aliasRef.setResultType(((ListType)source.getResultType()).getElementType());
        }
 else {
          aliasRef.setResultType(source.getResultType());
        }
        DataType resultType=resolveProperty(aliasRef.getResultType(),identifier,false);
        if (resultType != null) {
          return resolveAccessor(aliasRef,identifier);
        }
      }
    }
  }
  return null;
}","private Expression resolveQueryThisElement(String identifier){
  if (inQueryContext()) {
    QueryContext query=peekQueryContext();
    if (query.isImplicit()) {
      AliasedQuerySource source=resolveAlias(""String_Node_Str"");
      if (source != null) {
        AliasRef aliasRef=of.createAliasRef().withName(""String_Node_Str"");
        if (source.getResultType() instanceof ListType) {
          aliasRef.setResultType(((ListType)source.getResultType()).getElementType());
        }
 else {
          aliasRef.setResultType(source.getResultType());
        }
        DataType resultType=resolveProperty(aliasRef.getResultType(),identifier,false);
        if (resultType != null) {
          return resolveAccessor(aliasRef,identifier);
        }
      }
    }
  }
  return null;
}"
11028,"private AliasedQuerySource resolveAlias(String identifier){
  for (  QueryContext query : queries) {
    AliasedQuerySource source=query.resolveAlias(identifier);
    if (source != null) {
      return source;
    }
  }
  return null;
}","private AliasedQuerySource resolveAlias(String identifier){
  if (inQueryContext()) {
    for (int i=getScope().getQueries().size() - 1; i >= 0; i--) {
      AliasedQuerySource source=getScope().getQueries().get(i).resolveAlias(identifier);
      if (source != null) {
        return source;
      }
    }
  }
  return null;
}"
11029,"@Test public void testRecursiveFunctions() throws IOException {
  runSemanticTest(""String_Node_Str"",3);
}","@Test public void testRecursiveFunctions() throws IOException {
  runSemanticTest(""String_Node_Str"",1);
}"
11030,"@Override public Object visitConversionExpressionTerm(@NotNull cqlParser.ConversionExpressionTermContext ctx){
  TypeSpecifier targetType=parseTypeSpecifier(ctx.typeSpecifier());
  Expression operand=parseExpression(ctx.expression());
  Conversion conversion=libraryBuilder.findConversion(operand.getResultType(),targetType.getResultType(),false);
  if (conversion == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",operand.getResultType(),targetType.getResultType()));
  }
  return libraryBuilder.convertExpression(operand,conversion);
}","@Override public Object visitConversionExpressionTerm(@NotNull cqlParser.ConversionExpressionTermContext ctx){
  TypeSpecifier targetType=parseTypeSpecifier(ctx.typeSpecifier());
  Expression operand=parseExpression(ctx.expression());
  if (!DataTypes.equal(operand.getResultType(),targetType.getResultType())) {
    Conversion conversion=libraryBuilder.findConversion(operand.getResultType(),targetType.getResultType(),false);
    if (conversion == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",operand.getResultType(),targetType.getResultType()));
    }
    return libraryBuilder.convertExpression(operand,conversion);
  }
  return operand;
}"
11031,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11032,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11033,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11034,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11035,"private Expression resolveFunction(String libraryName,String functionName,cqlParser.ParamListContext paramList){
  List<Expression> expressions=new ArrayList<Expression>();
  if (paramList != null && paramList.expression() != null) {
    for (    cqlParser.ExpressionContext expressionContext : paramList.expression()) {
      expressions.add((Expression)visit(expressionContext));
    }
  }
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,!checkForward);
  if (result == null) {
    Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(functionName);
    if (functionInfos != null) {
      for (      FunctionDefinitionInfo functionInfo : functionInfos) {
        internalVisitFunctionDefinition(functionInfo.getDefinition());
      }
    }
    result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,true);
  }
  return result;
}","private Expression resolveFunction(String libraryName,String functionName,cqlParser.ParamListContext paramList){
  List<Expression> expressions=new ArrayList<Expression>();
  if (paramList != null && paramList.expression() != null) {
    for (    cqlParser.ExpressionContext expressionContext : paramList.expression()) {
      expressions.add((Expression)visit(expressionContext));
    }
  }
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,!checkForward);
  if (result == null) {
    libraryBuilder.pushExpressionDefinition(functionName);
    try {
      Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(functionName);
      if (functionInfos != null) {
        for (        FunctionDefinitionInfo functionInfo : functionInfos) {
          internalVisitFunctionDefinition(functionInfo.getDefinition());
        }
      }
      result=libraryBuilder.resolveFunction(libraryName,functionName,expressions,true);
    }
  finally {
      libraryBuilder.popExpressionDefinition();
    }
  }
  return result;
}"
11036,"public Object internalVisitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  if (!libraryBuilder.getTranslatedLibrary().contains(fun)) {
    libraryBuilder.beginFunctionDef(fun);
    try {
      libraryBuilder.pushExpressionContext(currentContext);
      try {
        fun.setExpression(parseExpression(ctx.functionBody()));
      }
  finally {
        libraryBuilder.popExpressionContext();
      }
    }
  finally {
      libraryBuilder.endFunctionDef();
    }
    fun.setContext(currentContext);
    fun.setResultType(fun.getExpression().getResultType());
    libraryBuilder.addExpression(fun);
  }
  return fun;
}","public Object internalVisitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  if (!libraryBuilder.getTranslatedLibrary().contains(fun)) {
    libraryBuilder.beginFunctionDef(fun);
    try {
      libraryBuilder.pushExpressionContext(currentContext);
      try {
        fun.setExpression(parseExpression(ctx.functionBody()));
      }
  finally {
        libraryBuilder.popExpressionContext();
      }
    }
  finally {
      libraryBuilder.endFunctionDef();
    }
    fun.setContext(currentContext);
    fun.setResultType(fun.getExpression().getResultType());
    if (fun.getResultType() != null) {
      libraryBuilder.addExpression(fun);
    }
  }
  return fun;
}"
11037,"public DataType ensureCompatibleTypes(DataType first,DataType second){
  if (first.equals(DataType.ANY)) {
    return second;
  }
  if (second.equals(DataType.ANY)) {
    return first;
  }
  if (first.isSuperTypeOf(second) || second.isCompatibleWith(first)) {
    return first;
  }
  if (second.isSuperTypeOf(first) || first.isCompatibleWith(second)) {
    return second;
  }
  Conversion conversion=findConversion(second,first,true);
  if (conversion != null) {
    return first;
  }
  conversion=findConversion(first,second,true);
  if (conversion != null) {
    return second;
  }
  DataTypes.verifyType(second,first);
  return first;
}","public DataType ensureCompatibleTypes(DataType first,DataType second){
  if (first == null || second == null) {
    return null;
  }
  if (first.equals(DataType.ANY)) {
    return second;
  }
  if (second.equals(DataType.ANY)) {
    return first;
  }
  if (first.isSuperTypeOf(second) || second.isCompatibleWith(first)) {
    return first;
  }
  if (second.isSuperTypeOf(first) || first.isCompatibleWith(second)) {
    return second;
  }
  Conversion conversion=findConversion(second,first,true);
  if (conversion != null) {
    return first;
  }
  conversion=findConversion(first,second,true);
  if (conversion != null) {
    return second;
  }
  DataTypes.verifyType(second,first);
  return first;
}"
11038,"public Expression ensureCompatible(Expression expression,DataType targetType){
  if (!targetType.isSuperTypeOf(expression.getResultType())) {
    return convertExpression(expression,targetType);
  }
  return expression;
}","public Expression ensureCompatible(Expression expression,DataType targetType){
  if (targetType == null) {
    return of.createNull();
  }
  if (!targetType.isSuperTypeOf(expression.getResultType())) {
    return convertExpression(expression,targetType);
  }
  return expression;
}"
11039,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11040,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11041,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11042,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11043,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11044,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11045,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11046,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11047,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11048,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11049,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11050,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11051,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11052,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11053,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11054,"private TranslatedLibrary translateLibrary(VersionedIdentifier libraryIdentifier,List<CqlTranslatorException> errors){
  InputStream librarySource=librarySourceLoader.getLibrarySource(libraryIdentifier);
  if (librarySource == null) {
    throw new CqlTranslatorIncludeException(String.format(""String_Node_Str"",libraryIdentifier.getId(),libraryIdentifier.getVersion()),libraryIdentifier.getId(),libraryIdentifier.getVersion());
  }
  try {
    CqlTranslator translator=CqlTranslator.fromStream(librarySource,this);
    if (errors != null) {
      errors.addAll(translator.getErrors());
    }
    TranslatedLibrary result=translator.getTranslatedLibrary();
    if (libraryIdentifier.getVersion() != null && !libraryIdentifier.getVersion().equals(result.getIdentifier().getVersion())) {
      throw new CqlTranslatorIncludeException(String.format(""String_Node_Str"",libraryIdentifier.getId(),libraryIdentifier.getVersion(),result.getIdentifier().getVersion()),libraryIdentifier.getId(),libraryIdentifier.getVersion());
    }
    return result;
  }
 catch (  IOException e) {
    throw new CqlTranslatorIncludeException(String.format(""String_Node_Str"",libraryIdentifier.getId(),libraryIdentifier.getVersion()),libraryIdentifier.getId(),libraryIdentifier.getVersion(),e);
  }
}","private TranslatedLibrary translateLibrary(VersionedIdentifier libraryIdentifier,List<CqlTranslatorException> errors){
  InputStream librarySource=null;
  try {
    librarySource=librarySourceLoader.getLibrarySource(libraryIdentifier);
  }
 catch (  Exception e) {
    throw new CqlTranslatorIncludeException(e.getMessage(),libraryIdentifier.getId(),libraryIdentifier.getVersion(),e);
  }
  if (librarySource == null) {
    throw new CqlTranslatorIncludeException(String.format(""String_Node_Str"",libraryIdentifier.getId(),libraryIdentifier.getVersion()),libraryIdentifier.getId(),libraryIdentifier.getVersion());
  }
  try {
    CqlTranslator translator=CqlTranslator.fromStream(librarySource,this);
    if (errors != null) {
      errors.addAll(translator.getErrors());
    }
    TranslatedLibrary result=translator.getTranslatedLibrary();
    if (libraryIdentifier.getVersion() != null && !libraryIdentifier.getVersion().equals(result.getIdentifier().getVersion())) {
      throw new CqlTranslatorIncludeException(String.format(""String_Node_Str"",libraryIdentifier.getId(),libraryIdentifier.getVersion(),result.getIdentifier().getVersion()),libraryIdentifier.getId(),libraryIdentifier.getVersion());
    }
    return result;
  }
 catch (  IOException e) {
    throw new CqlTranslatorIncludeException(String.format(""String_Node_Str"",libraryIdentifier.getId(),libraryIdentifier.getVersion()),libraryIdentifier.getId(),libraryIdentifier.getVersion(),e);
  }
}"
11055,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11056,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11057,"public Expression resolveIdentifier(String identifier){
  IdentifierRef resultElement=resolveQueryResultElement(identifier);
  if (resultElement != null) {
    return resultElement;
  }
  AliasedQuerySource alias=resolveAlias(identifier);
  if (alias != null) {
    AliasRef result=of.createAliasRef().withName(identifier);
    if (alias.getResultType() instanceof ListType) {
      result.setResultType(((ListType)alias.getResultType()).getElementType());
    }
 else {
      result.setResultType(alias.getResultType());
    }
    return result;
  }
  LetClause let=resolveQueryLet(identifier);
  if (let != null) {
    QueryLetRef result=of.createQueryLetRef().withName(identifier);
    result.setResultType(let.getResultType());
    return result;
  }
  OperandRef operandRef=resolveOperandRef(identifier);
  if (operandRef != null) {
    return operandRef;
  }
  Element element=translatedLibrary.resolve(identifier);
  if (element == null) {
    ExpressionDefinitionInfo expressionInfo=libraryInfo.resolveExpressionReference(identifier);
    if (expressionInfo != null) {
      String saveContext=currentContext;
      currentContext=expressionInfo.getContext();
      try {
        ExpressionDef expressionDef=internalVisitExpressionDefinition(expressionInfo.getDefinition());
        element=expressionDef;
      }
  finally {
        currentContext=saveContext;
      }
    }
    ParameterDefinitionInfo parameterInfo=libraryInfo.resolveParameterReference(identifier);
    if (parameterInfo != null) {
      ParameterDef parameterDef=visitParameterDefinition(parameterInfo.getDefinition());
      element=parameterDef;
    }
  }
  if (element instanceof ExpressionDef) {
    ExpressionRef expressionRef=of.createExpressionRef().withName(((ExpressionDef)element).getName());
    expressionRef.setResultType(getExpressionDefResultType((ExpressionDef)element));
    return expressionRef;
  }
  if (element instanceof ParameterDef) {
    ParameterRef parameterRef=of.createParameterRef().withName(((ParameterDef)element).getName());
    parameterRef.setResultType(element.getResultType());
    return parameterRef;
  }
  if (element instanceof ValueSetDef) {
    ValueSetRef valuesetRef=of.createValueSetRef().withName(((ValueSetDef)element).getName());
    valuesetRef.setResultType(element.getResultType());
    return valuesetRef;
  }
  if (element instanceof CodeSystemDef) {
    CodeSystemRef codesystemRef=of.createCodeSystemRef().withName(((CodeSystemDef)element).getName());
    codesystemRef.setResultType(element.getResultType());
    return codesystemRef;
  }
  if (element instanceof CodeDef) {
    CodeRef codeRef=of.createCodeRef().withName(((CodeDef)element).getName());
    codeRef.setResultType(element.getResultType());
    return codeRef;
  }
  if (element instanceof ConceptDef) {
    ConceptRef conceptRef=of.createConceptRef().withName(((ConceptDef)element).getName());
    conceptRef.setResultType(element.getResultType());
    return conceptRef;
  }
  if (element instanceof IncludeDef) {
    LibraryRef libraryRef=new LibraryRef();
    libraryRef.setLibraryName(((IncludeDef)element).getLocalIdentifier());
    return libraryRef;
  }
  throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
}","public Expression resolveIdentifier(String identifier){
  IdentifierRef resultElement=resolveQueryResultElement(identifier);
  if (resultElement != null) {
    return resultElement;
  }
  AliasedQuerySource alias=resolveAlias(identifier);
  if (alias != null) {
    AliasRef result=of.createAliasRef().withName(identifier);
    if (alias.getResultType() instanceof ListType) {
      result.setResultType(((ListType)alias.getResultType()).getElementType());
    }
 else {
      result.setResultType(alias.getResultType());
    }
    return result;
  }
  LetClause let=resolveQueryLet(identifier);
  if (let != null) {
    QueryLetRef result=of.createQueryLetRef().withName(identifier);
    result.setResultType(let.getResultType());
    return result;
  }
  OperandRef operandRef=resolveOperandRef(identifier);
  if (operandRef != null) {
    return operandRef;
  }
  Element element=translatedLibrary.resolve(identifier);
  if (element == null) {
    ExpressionDefinitionInfo expressionInfo=libraryInfo.resolveExpressionReference(identifier);
    if (expressionInfo != null) {
      String saveContext=currentContext;
      currentContext=expressionInfo.getContext();
      try {
        ExpressionDef expressionDef=internalVisitExpressionDefinition(expressionInfo.getDefinition());
        element=expressionDef;
      }
  finally {
        currentContext=saveContext;
      }
    }
    ParameterDefinitionInfo parameterInfo=libraryInfo.resolveParameterReference(identifier);
    if (parameterInfo != null) {
      ParameterDef parameterDef=visitParameterDefinition(parameterInfo.getDefinition());
      element=parameterDef;
    }
  }
  if (element instanceof ExpressionDef) {
    ExpressionRef expressionRef=of.createExpressionRef().withName(((ExpressionDef)element).getName());
    expressionRef.setResultType(getExpressionDefResultType((ExpressionDef)element));
    if (expressionRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",expressionRef.getName()));
    }
    return expressionRef;
  }
  if (element instanceof ParameterDef) {
    ParameterRef parameterRef=of.createParameterRef().withName(((ParameterDef)element).getName());
    parameterRef.setResultType(element.getResultType());
    if (parameterRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",parameterRef.getName()));
    }
    return parameterRef;
  }
  if (element instanceof ValueSetDef) {
    ValueSetRef valuesetRef=of.createValueSetRef().withName(((ValueSetDef)element).getName());
    valuesetRef.setResultType(element.getResultType());
    if (valuesetRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",valuesetRef.getName()));
    }
    return valuesetRef;
  }
  if (element instanceof CodeSystemDef) {
    CodeSystemRef codesystemRef=of.createCodeSystemRef().withName(((CodeSystemDef)element).getName());
    codesystemRef.setResultType(element.getResultType());
    if (codesystemRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",codesystemRef.getName()));
    }
    return codesystemRef;
  }
  if (element instanceof CodeDef) {
    CodeRef codeRef=of.createCodeRef().withName(((CodeDef)element).getName());
    codeRef.setResultType(element.getResultType());
    if (codeRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",codeRef.getName()));
    }
    return codeRef;
  }
  if (element instanceof ConceptDef) {
    ConceptRef conceptRef=of.createConceptRef().withName(((ConceptDef)element).getName());
    conceptRef.setResultType(element.getResultType());
    if (conceptRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",conceptRef.getName()));
    }
    return conceptRef;
  }
  if (element instanceof IncludeDef) {
    LibraryRef libraryRef=new LibraryRef();
    libraryRef.setLibraryName(((IncludeDef)element).getLocalIdentifier());
    return libraryRef;
  }
  throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
}"
11058,"/** 
 * Record any errors while parsing in both the list of errors but also in the library itself so they can be processed easily by a remote client
 * @param e the exception to record
 */
public void recordParsingException(CqlTranslatorException e){
  errors.add(e);
  CqlToElmError err=af.createCqlToElmError();
  err.setMessage(e.getMessage());
  err.setErrorType(ErrorType.SYNTAX);
  if (e.getLocator() != null) {
    err.setStartLine(e.getLocator().getStartLine());
    err.setEndLine(e.getLocator().getEndLine());
    err.setStartChar(e.getLocator().getStartChar());
    err.setEndChar(e.getLocator().getEndChar());
  }
  if (e.getCause() != null && e.getCause() instanceof CqlTranslatorIncludeException) {
    CqlTranslatorIncludeException incEx=(CqlTranslatorIncludeException)e.getCause();
    err.setTargetIncludeLibraryId(incEx.getLibraryId());
    err.setTargetIncludeLibraryVersionId(incEx.getVersionId());
    err.setErrorType(ErrorType.INCLUDE);
  }
  getOrInitializeLibrary().getAnnotation().add(err);
}","/** 
 * Record any errors while parsing in both the list of errors but also in the library itself so they can be processed easily by a remote client
 * @param e the exception to record
 */
public void recordParsingException(CqlTranslatorException e){
  errors.add(e);
  CqlToElmError err=af.createCqlToElmError();
  err.setMessage(e.getMessage());
  err.setErrorType(e instanceof CqlSyntaxException ? ErrorType.SYNTAX : ErrorType.SEMANTIC);
  if (e.getLocator() != null) {
    err.setStartLine(e.getLocator().getStartLine());
    err.setEndLine(e.getLocator().getEndLine());
    err.setStartChar(e.getLocator().getStartChar());
    err.setEndChar(e.getLocator().getEndChar());
  }
  if (e.getCause() != null && e.getCause() instanceof CqlTranslatorIncludeException) {
    CqlTranslatorIncludeException incEx=(CqlTranslatorIncludeException)e.getCause();
    err.setTargetIncludeLibraryId(incEx.getLibraryId());
    err.setTargetIncludeLibraryVersionId(incEx.getVersionId());
    err.setErrorType(ErrorType.INCLUDE);
  }
  getOrInitializeLibrary().getAnnotation().add(err);
}"
11059,"private ClassType resolveLabel(String modelName,String label){
  ClassType result=null;
  if (modelName == null || modelName.equals(""String_Node_Str"")) {
    for (    Model model : models.values()) {
      ClassType modelResult=model.resolveLabel(label);
      if (modelResult != null) {
        if (result != null) {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",label,result.getName(),modelResult.getName()));
        }
        result=modelResult;
      }
    }
  }
 else {
    result=getModel(modelName).resolveLabel(label);
  }
  return result;
}","private ClassType resolveLabel(String modelName,String label){
  ClassType result=null;
  if (modelName == null || modelName.equals(""String_Node_Str"")) {
    for (    Model model : models.values()) {
      ClassType modelResult=model.resolveLabel(label);
      if (modelResult != null) {
        if (result != null) {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",label,result.getLabel(),modelResult.getLabel()));
        }
        result=modelResult;
      }
    }
  }
 else {
    result=getModel(modelName).resolveLabel(label);
  }
  return result;
}"
11060,"private void pushExpressionDefinition(String identifier){
  if (expressionDefinitions.contains(identifier)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
  }
  expressionDefinitions.push(identifier);
}","private void pushExpressionDefinition(String identifier){
  if (expressionDefinitions.contains(identifier)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
  }
  expressionDefinitions.push(new ExpressionDefinitionContext(identifier));
}"
11061,"protected DataType resolveProperty(DataType sourceType,String identifier,boolean mustResolve){
  DataType currentType=sourceType;
  while (currentType != null) {
    if (currentType instanceof ClassType) {
      ClassType classType=(ClassType)currentType;
      for (      ClassTypeElement e : classType.getElements()) {
        if (e.getName().equals(identifier)) {
          if (e.isProhibited()) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",e.getName(),((ClassType)currentType).getName()));
          }
          return e.getType();
        }
      }
    }
 else     if (currentType instanceof TupleType) {
      TupleType tupleType=(TupleType)currentType;
      for (      TupleTypeElement e : tupleType.getElements()) {
        if (e.getName().equals(identifier)) {
          return e.getType();
        }
      }
    }
 else     if (currentType instanceof IntervalType) {
      IntervalType intervalType=(IntervalType)currentType;
switch (identifier) {
case ""String_Node_Str"":
case ""String_Node_Str"":
        return intervalType.getPointType();
case ""String_Node_Str"":
case ""String_Node_Str"":
      return resolveTypeName(""String_Node_Str"",""String_Node_Str"");
default :
    throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
}
}
if (currentType.getBaseType() != null) {
currentType=currentType.getBaseType();
}
 else {
break;
}
}
if (mustResolve) {
throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier,sourceType));
}
return null;
}","protected DataType resolveProperty(DataType sourceType,String identifier,boolean mustResolve){
  DataType currentType=sourceType;
  while (currentType != null) {
    if (currentType instanceof ClassType) {
      ClassType classType=(ClassType)currentType;
      for (      ClassTypeElement e : classType.getElements()) {
        if (e.getName().equals(identifier)) {
          if (e.isProhibited()) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",e.getName(),((ClassType)currentType).getName()));
          }
          return e.getType();
        }
      }
    }
 else     if (currentType instanceof TupleType) {
      TupleType tupleType=(TupleType)currentType;
      for (      TupleTypeElement e : tupleType.getElements()) {
        if (e.getName().equals(identifier)) {
          return e.getType();
        }
      }
    }
 else     if (currentType instanceof IntervalType) {
      IntervalType intervalType=(IntervalType)currentType;
switch (identifier) {
case ""String_Node_Str"":
case ""String_Node_Str"":
        return intervalType.getPointType();
case ""String_Node_Str"":
case ""String_Node_Str"":
      return resolveTypeName(""String_Node_Str"",""String_Node_Str"");
default :
    throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
}
}
if (currentType.getBaseType() != null) {
currentType=currentType.getBaseType();
}
 else {
break;
}
}
if (mustResolve) {
throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier,sourceType != null ? sourceType.toLabel() : null));
}
return null;
}"
11062,"@Override public Object visit(@NotNull ParseTree tree){
  if (annotate) {
    pushNarrative(tree);
  }
  Object o=null;
  try {
    try {
      o=super.visit(tree);
    }
 catch (    CqlTranslatorIncludeException e) {
      recordParsingException(new CqlTranslatorException(e.getMessage(),getTrackBack((ParserRuleContext)tree),e));
    }
catch (    CqlTranslatorException e) {
      recordParsingException(e);
    }
catch (    Exception e) {
      recordParsingException(new CqlTranslatorException(e.getMessage() == null ? ""String_Node_Str"" : e.getMessage(),tree instanceof ParserRuleContext ? getTrackBack((ParserRuleContext)tree) : null,e));
      o=of.createNull();
    }
  }
  finally {
    if (annotate) {
      popNarrative(tree,o);
    }
  }
  if (o instanceof Trackable && tree instanceof ParserRuleContext && !(tree instanceof cqlParser.LogicContext)) {
    this.track((Trackable)o,(ParserRuleContext)tree);
  }
  if (o instanceof Expression) {
    addExpression((Expression)o);
  }
  return o;
}","@Override public Object visit(@NotNull ParseTree tree){
  if (annotate) {
    pushNarrative(tree);
  }
  Object o=null;
  try {
    try {
      o=super.visit(tree);
    }
 catch (    CqlTranslatorIncludeException e) {
      recordParsingException(new CqlTranslatorException(e.getMessage(),getTrackBack((ParserRuleContext)tree),e));
    }
catch (    CqlTranslatorException e) {
      recordParsingException(e);
    }
catch (    Exception e) {
      CqlTranslatorException ex=new CqlSemanticException(e.getMessage() == null ? ""String_Node_Str"" : e.getMessage(),tree instanceof ParserRuleContext ? getTrackBack((ParserRuleContext)tree) : null,e);
      Exception rootCause=determineRootCause();
      if (rootCause == null) {
        rootCause=ex;
        recordParsingException(ex);
        setRootCause(rootCause);
      }
 else {
        if (detailedErrors) {
          recordParsingException(ex);
        }
      }
      o=of.createNull();
    }
  }
  finally {
    if (annotate) {
      popNarrative(tree,o);
    }
  }
  if (o instanceof Trackable && tree instanceof ParserRuleContext && !(tree instanceof cqlParser.LogicContext)) {
    this.track((Trackable)o,(ParserRuleContext)tree);
  }
  if (o instanceof Expression) {
    addExpression((Expression)o);
  }
  return o;
}"
11063,"@Override public void syntaxError(@NotNull Recognizer<?,?> recognizer,@Nullable Object offendingSymbol,int line,int charPositionInLine,@NotNull String msg,@Nullable RecognitionException e){
  TrackBack trackback=new TrackBack(new VersionedIdentifier().withId(""String_Node_Str""),line,charPositionInLine,line,charPositionInLine);
  visitor.recordParsingException(new CqlTranslatorException(msg,trackback,e));
}","@Override public void syntaxError(@NotNull Recognizer<?,?> recognizer,@Nullable Object offendingSymbol,int line,int charPositionInLine,@NotNull String msg,@Nullable RecognitionException e){
  TrackBack trackback=new TrackBack(new VersionedIdentifier().withId(""String_Node_Str""),line,charPositionInLine,line,charPositionInLine);
  if (visitor.isDetailedErrorsEnabled()) {
    visitor.recordParsingException(new CqlSyntaxException(msg,trackback,e));
  }
 else {
    if (offendingSymbol instanceof CommonToken) {
      CommonToken token=(CommonToken)offendingSymbol;
      visitor.recordParsingException(new CqlSyntaxException(String.format(""String_Node_Str"",token.getText()),trackback,e));
    }
 else {
      visitor.recordParsingException(new CqlSyntaxException(""String_Node_Str"",trackback,e));
    }
  }
}"
11064,"private void translateToELM(ANTLRInputStream is,Options... options){
  cqlLexer lexer=new cqlLexer(is);
  CommonTokenStream tokens=new CommonTokenStream(lexer);
  cqlParser parser=new cqlParser(tokens);
  parser.setBuildParseTree(true);
  errors=new ArrayList<>();
  Cql2ElmVisitor visitor=new Cql2ElmVisitor(libraryManager);
  parser.addErrorListener(new CqlErrorListener(visitor));
  ParseTree tree=parser.logic();
  CqlPreprocessorVisitor preprocessor=new CqlPreprocessorVisitor();
  preprocessor.visit(tree);
  visitor.setLibraryInfo(preprocessor.getLibraryInfo());
  visitor.setTokenStream(tokens);
  List<Options> optionList=Arrays.asList(options);
  if (optionList.contains(Options.EnableDateRangeOptimization)) {
    visitor.enableDateRangeOptimization();
  }
  if (optionList.contains(Options.EnableAnnotations)) {
    visitor.enableAnnotations();
  }
  visitResult=visitor.visit(tree);
  library=visitor.getLibrary();
  translatedLibrary=visitor.getTranslatedLibrary();
  retrieves=visitor.getRetrieves();
  errors.addAll(visitor.getErrors());
}","private void translateToELM(ANTLRInputStream is,Options... options){
  cqlLexer lexer=new cqlLexer(is);
  CommonTokenStream tokens=new CommonTokenStream(lexer);
  cqlParser parser=new cqlParser(tokens);
  parser.setBuildParseTree(true);
  errors=new ArrayList<>();
  Cql2ElmVisitor visitor=new Cql2ElmVisitor(libraryManager);
  List<Options> optionList=Arrays.asList(options);
  if (optionList.contains(Options.EnableDateRangeOptimization)) {
    visitor.enableDateRangeOptimization();
  }
  if (optionList.contains(Options.EnableAnnotations)) {
    visitor.enableAnnotations();
  }
  if (optionList.contains(Options.EnableDetailedErrors)) {
    visitor.enableDetailedErrors();
  }
  parser.removeErrorListeners();
  parser.addErrorListener(new CqlErrorListener(visitor));
  ParseTree tree=parser.logic();
  CqlPreprocessorVisitor preprocessor=new CqlPreprocessorVisitor();
  preprocessor.visit(tree);
  visitor.setLibraryInfo(preprocessor.getLibraryInfo());
  visitor.setTokenStream(tokens);
  visitResult=visitor.visit(tree);
  library=visitor.getLibrary();
  translatedLibrary=visitor.getTranslatedLibrary();
  retrieves=visitor.getRetrieves();
  errors.addAll(visitor.getErrors());
}"
11065,"public static void main(String[] args) throws IOException, InterruptedException {
  OptionParser parser=new OptionParser();
  OptionSpec<File> input=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(File.class).required();
  OptionSpec<File> model=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(File.class);
  OptionSpec<File> output=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(File.class);
  OptionSpec<Format> format=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Format.class).defaultsTo(Format.XML);
  OptionSpec verify=parser.accepts(""String_Node_Str"");
  OptionSpec optimization=parser.accepts(""String_Node_Str"");
  OptionSpec annotations=parser.accepts(""String_Node_Str"");
  OptionSet options=parser.parse(args);
  final Path source=input.value(options).toPath();
  final Path destination=output.value(options) != null ? output.value(options).toPath() : source.toFile().isDirectory() ? source : source.getParent();
  final Format outputFormat=format.value(options);
  Map<Path,Path> inOutMap=new HashMap<>();
  if (source.toFile().isDirectory()) {
    if (destination.toFile().exists() && !destination.toFile().isDirectory()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    Files.walkFileTree(source,new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.toFile().getName().endsWith(""String_Node_Str"") || file.toFile().getName().endsWith(""String_Node_Str"")) {
          Path destinationFolder=destination.resolve(source.relativize(file.getParent()));
          if (!destinationFolder.toFile().exists() && !destinationFolder.toFile().mkdirs()) {
            System.err.printf(""String_Node_Str"",destinationFolder);
          }
          inOutMap.put(file,destinationFolder);
        }
        return CONTINUE;
      }
    }
);
  }
 else {
    inOutMap.put(source,destination);
  }
  for (  Map.Entry<Path,Path> inOut : inOutMap.entrySet()) {
    Path in=inOut.getKey();
    Path out=inOut.getValue();
    if (out.toFile().isDirectory()) {
      String name=in.toFile().getName();
      if (name.lastIndexOf('.') != -1) {
        name=name.substring(0,name.lastIndexOf('.'));
      }
switch (outputFormat) {
case JSON:
        name+=""String_Node_Str"";
      break;
case COFFEE:
    name+=""String_Node_Str"";
  break;
case XML:
default :
name+=""String_Node_Str"";
break;
}
out=out.resolve(name);
}
if (out.equals(in)) {
throw new IllegalArgumentException(""String_Node_Str"");
}
if (options.has(model)) {
final File modelFile=options.valueOf(model);
if (!modelFile.exists() || modelFile.isDirectory()) {
throw new IllegalArgumentException(""String_Node_Str"");
}
loadModelInfo(modelFile);
}
writeELM(in,out,outputFormat,options.has(optimization),options.has(annotations),options.has(verify));
}
}","public static void main(String[] args) throws IOException, InterruptedException {
  OptionParser parser=new OptionParser();
  OptionSpec<File> input=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(File.class).required();
  OptionSpec<File> model=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(File.class);
  OptionSpec<File> output=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(File.class);
  OptionSpec<Format> format=parser.accepts(""String_Node_Str"").withRequiredArg().ofType(Format.class).defaultsTo(Format.XML);
  OptionSpec verify=parser.accepts(""String_Node_Str"");
  OptionSpec optimization=parser.accepts(""String_Node_Str"");
  OptionSpec annotations=parser.accepts(""String_Node_Str"");
  OptionSpec detailedErrors=parser.accepts(""String_Node_Str"");
  OptionSet options=parser.parse(args);
  final Path source=input.value(options).toPath();
  final Path destination=output.value(options) != null ? output.value(options).toPath() : source.toFile().isDirectory() ? source : source.getParent();
  final Format outputFormat=format.value(options);
  Map<Path,Path> inOutMap=new HashMap<>();
  if (source.toFile().isDirectory()) {
    if (destination.toFile().exists() && !destination.toFile().isDirectory()) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    Files.walkFileTree(source,new SimpleFileVisitor<Path>(){
      @Override public FileVisitResult visitFile(      Path file,      BasicFileAttributes attrs) throws IOException {
        if (file.toFile().getName().endsWith(""String_Node_Str"") || file.toFile().getName().endsWith(""String_Node_Str"")) {
          Path destinationFolder=destination.resolve(source.relativize(file.getParent()));
          if (!destinationFolder.toFile().exists() && !destinationFolder.toFile().mkdirs()) {
            System.err.printf(""String_Node_Str"",destinationFolder);
          }
          inOutMap.put(file,destinationFolder);
        }
        return CONTINUE;
      }
    }
);
  }
 else {
    inOutMap.put(source,destination);
  }
  for (  Map.Entry<Path,Path> inOut : inOutMap.entrySet()) {
    Path in=inOut.getKey();
    Path out=inOut.getValue();
    if (out.toFile().isDirectory()) {
      String name=in.toFile().getName();
      if (name.lastIndexOf('.') != -1) {
        name=name.substring(0,name.lastIndexOf('.'));
      }
switch (outputFormat) {
case JSON:
        name+=""String_Node_Str"";
      break;
case COFFEE:
    name+=""String_Node_Str"";
  break;
case XML:
default :
name+=""String_Node_Str"";
break;
}
out=out.resolve(name);
}
if (out.equals(in)) {
throw new IllegalArgumentException(""String_Node_Str"");
}
if (options.has(model)) {
final File modelFile=options.valueOf(model);
if (!modelFile.exists() || modelFile.isDirectory()) {
throw new IllegalArgumentException(""String_Node_Str"");
}
loadModelInfo(modelFile);
}
writeELM(in,out,outputFormat,options.has(optimization),options.has(annotations),options.has(verify),options.has(detailedErrors));
}
}"
11066,"private static void writeELM(Path inPath,Path outPath,Format format,boolean dateRangeOptimizations,boolean annotations,boolean verifyOnly) throws IOException {
  ArrayList<Options> options=new ArrayList<>();
  if (dateRangeOptimizations) {
    options.add(Options.EnableDateRangeOptimization);
  }
  if (annotations) {
    options.add(Options.EnableAnnotations);
  }
  System.err.println(""String_Node_Str"");
  System.err.printf(""String_Node_Str"",inPath);
  LibraryManager libraryManager=new LibraryManager();
  libraryManager.getLibrarySourceLoader().registerProvider(new DefaultLibrarySourceProvider(inPath.getParent()));
  CqlTranslator translator=fromFile(inPath.toFile(),libraryManager,options.toArray(new Options[options.size()]));
  libraryManager.getLibrarySourceLoader().clearProviders();
  if (translator.getErrors().size() > 0) {
    System.err.println(""String_Node_Str"");
    for (    CqlTranslatorException error : translator.getErrors()) {
      TrackBack tb=error.getLocator();
      String lines=tb == null ? ""String_Node_Str"" : String.format(""String_Node_Str"",tb.getStartLine(),tb.getStartChar(),tb.getEndLine(),tb.getEndChar());
      System.err.printf(""String_Node_Str"",lines,error.getMessage());
    }
  }
 else   if (!verifyOnly) {
    try (PrintWriter pw=new PrintWriter(outPath.toFile(),""String_Node_Str"")){
switch (format) {
case COFFEE:
        pw.print(""String_Node_Str"");
      pw.println(translator.toJson());
    break;
case JSON:
  pw.println(translator.toJson());
break;
case XML:
default :
pw.println(translator.toXml());
}
pw.println();
}
 }
System.err.println();
}","private static void writeELM(Path inPath,Path outPath,Format format,boolean dateRangeOptimizations,boolean annotations,boolean verifyOnly,boolean detailedErrors) throws IOException {
  ArrayList<Options> options=new ArrayList<>();
  if (dateRangeOptimizations) {
    options.add(Options.EnableDateRangeOptimization);
  }
  if (annotations) {
    options.add(Options.EnableAnnotations);
  }
  if (detailedErrors) {
    options.add(Options.EnableDetailedErrors);
  }
  System.err.println(""String_Node_Str"");
  System.err.printf(""String_Node_Str"",inPath);
  LibraryManager libraryManager=new LibraryManager();
  libraryManager.getLibrarySourceLoader().registerProvider(new DefaultLibrarySourceProvider(inPath.getParent()));
  CqlTranslator translator=fromFile(inPath.toFile(),libraryManager,options.toArray(new Options[options.size()]));
  libraryManager.getLibrarySourceLoader().clearProviders();
  if (translator.getErrors().size() > 0) {
    System.err.println(""String_Node_Str"");
    for (    CqlTranslatorException error : translator.getErrors()) {
      TrackBack tb=error.getLocator();
      String lines=tb == null ? ""String_Node_Str"" : String.format(""String_Node_Str"",tb.getStartLine(),tb.getStartChar(),tb.getEndLine(),tb.getEndChar());
      System.err.printf(""String_Node_Str"",lines,error.getMessage());
    }
  }
 else   if (!verifyOnly) {
    try (PrintWriter pw=new PrintWriter(outPath.toFile(),""String_Node_Str"")){
switch (format) {
case COFFEE:
        pw.print(""String_Node_Str"");
      pw.println(translator.toJson());
    break;
case JSON:
  pw.println(translator.toJson());
break;
case XML:
default :
pw.println(translator.toXml());
}
pw.println();
}
 }
System.err.println();
}"
11067,"public static void verifyCast(DataType targetType,DataType sourceType){
  if (!subTypeOf(targetType,sourceType)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",sourceType != null ? sourceType.toString() : ""String_Node_Str"",targetType != null ? targetType.toString() : ""String_Node_Str""));
  }
}","public static void verifyCast(DataType targetType,DataType sourceType){
  if (!subTypeOf(targetType,sourceType)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",sourceType != null ? sourceType.toLabel() : ""String_Node_Str"",targetType != null ? targetType.toLabel() : ""String_Node_Str""));
  }
}"
11068,"public static void verifyType(DataType actualType,DataType expectedType){
  if (!subTypeOf(actualType,expectedType)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",expectedType != null ? expectedType.toString() : ""String_Node_Str"",actualType != null ? actualType.toString() : ""String_Node_Str""));
  }
}","public static void verifyType(DataType actualType,DataType expectedType){
  if (!subTypeOf(actualType,expectedType)) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",expectedType != null ? expectedType.toLabel() : ""String_Node_Str"",actualType != null ? actualType.toLabel() : ""String_Node_Str""));
  }
}"
11069,"@Override public Object visitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  currentFunctionDef=fun;
  pushExpressionContext(currentContext);
  try {
    fun.setExpression(parseExpression(ctx.functionBody()));
  }
  finally {
    currentFunctionDef=null;
    popExpressionContext();
  }
  fun.setContext(currentContext);
  fun.setResultType(fun.getExpression().getResultType());
  addToLibrary(fun);
  return fun;
}","@Override public Object visitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef result=(FunctionDef)internalVisitFunctionDefinition(ctx);
  Operator operator=Operator.fromFunctionDef(result);
  Set<Signature> definedSignatures=definedFunctionDefinitions.get(operator.getName());
  if (definedSignatures == null) {
    definedSignatures=new HashSet<>();
    definedFunctionDefinitions.put(operator.getName(),definedSignatures);
  }
  if (definedSignatures.contains(operator.getSignature())) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",operator.getName()));
  }
  definedSignatures.add(operator.getSignature());
  return result;
}"
11070,"@Override public SortByItem visitSortByItem(@NotNull cqlParser.SortByItemContext ctx){
  Expression sortExpression=parseExpression(ctx.expressionTerm());
  if (sortExpression instanceof IdentifierRef) {
    return of.createByColumn().withPath(((IdentifierRef)sortExpression).getName()).withDirection(parseSortDirection(ctx.sortDirection()));
  }
  return of.createByExpression().withExpression(sortExpression).withDirection(parseSortDirection(ctx.sortDirection()));
}","@Override public SortByItem visitSortByItem(@NotNull cqlParser.SortByItemContext ctx){
  Expression sortExpression=parseExpression(ctx.expressionTerm());
  if (sortExpression instanceof IdentifierRef) {
    return (SortByItem)of.createByColumn().withPath(((IdentifierRef)sortExpression).getName()).withDirection(parseSortDirection(ctx.sortDirection())).withResultType(sortExpression.getResultType());
  }
  return (SortByItem)of.createByExpression().withExpression(sortExpression).withDirection(parseSortDirection(ctx.sortDirection())).withResultType(sortExpression.getResultType());
}"
11071,"public Expression resolveIdentifier(String identifier){
  IdentifierRef resultElement=resolveQueryResultElement(identifier);
  if (resultElement != null) {
    return resultElement;
  }
  AliasedQuerySource alias=resolveAlias(identifier);
  if (alias != null) {
    AliasRef result=of.createAliasRef().withName(identifier);
    if (alias.getResultType() instanceof ListType) {
      result.setResultType(((ListType)alias.getResultType()).getElementType());
    }
 else {
      result.setResultType(alias.getResultType());
    }
    return result;
  }
  LetClause let=resolveQueryLet(identifier);
  if (let != null) {
    QueryLetRef result=of.createQueryLetRef().withName(identifier);
    result.setResultType(let.getResultType());
    return result;
  }
  OperandRef operandRef=resolveOperandRef(identifier);
  if (operandRef != null) {
    return operandRef;
  }
  Element element=translatedLibrary.resolve(identifier);
  if (element == null) {
    ExpressionDefinitionInfo expressionInfo=libraryInfo.resolveExpressionReference(identifier);
    if (expressionInfo != null) {
      String saveContext=currentContext;
      currentContext=expressionInfo.getContext();
      try {
        ExpressionDef expressionDef=visitExpressionDefinition(expressionInfo.getDefinition());
        element=expressionDef;
      }
  finally {
        currentContext=saveContext;
      }
    }
    ParameterDefinitionInfo parameterInfo=libraryInfo.resolveParameterReference(identifier);
    if (parameterInfo != null) {
      ParameterDef parameterDef=visitParameterDefinition(parameterInfo.getDefinition());
      element=parameterDef;
    }
  }
  if (element instanceof ExpressionDef) {
    ExpressionRef expressionRef=of.createExpressionRef().withName(((ExpressionDef)element).getName());
    expressionRef.setResultType(getExpressionDefResultType((ExpressionDef)element));
    if (expressionRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",expressionRef.getName()));
    }
    return expressionRef;
  }
  if (element instanceof ParameterDef) {
    ParameterRef parameterRef=of.createParameterRef().withName(((ParameterDef)element).getName());
    parameterRef.setResultType(element.getResultType());
    if (parameterRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",parameterRef.getName()));
    }
    return parameterRef;
  }
  if (element instanceof ValueSetDef) {
    ValueSetRef valuesetRef=of.createValueSetRef().withName(((ValueSetDef)element).getName());
    valuesetRef.setResultType(element.getResultType());
    if (valuesetRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",valuesetRef.getName()));
    }
    return valuesetRef;
  }
  if (element instanceof CodeSystemDef) {
    CodeSystemRef codesystemRef=of.createCodeSystemRef().withName(((CodeSystemDef)element).getName());
    codesystemRef.setResultType(element.getResultType());
    if (codesystemRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",codesystemRef.getName()));
    }
    return codesystemRef;
  }
  if (element instanceof CodeDef) {
    CodeRef codeRef=of.createCodeRef().withName(((CodeDef)element).getName());
    codeRef.setResultType(element.getResultType());
    if (codeRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",codeRef.getName()));
    }
    return codeRef;
  }
  if (element instanceof ConceptDef) {
    ConceptRef conceptRef=of.createConceptRef().withName(((ConceptDef)element).getName());
    conceptRef.setResultType(element.getResultType());
    if (conceptRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",conceptRef.getName()));
    }
    return conceptRef;
  }
  if (element instanceof IncludeDef) {
    LibraryRef libraryRef=new LibraryRef();
    libraryRef.setLibraryName(((IncludeDef)element).getLocalIdentifier());
    return libraryRef;
  }
  throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
}","public Expression resolveIdentifier(String identifier){
  IdentifierRef resultElement=resolveQueryResultElement(identifier);
  if (resultElement != null) {
    return resultElement;
  }
  AliasedQuerySource alias=resolveAlias(identifier);
  if (alias != null) {
    AliasRef result=of.createAliasRef().withName(identifier);
    if (alias.getResultType() instanceof ListType) {
      result.setResultType(((ListType)alias.getResultType()).getElementType());
    }
 else {
      result.setResultType(alias.getResultType());
    }
    return result;
  }
  LetClause let=resolveQueryLet(identifier);
  if (let != null) {
    QueryLetRef result=of.createQueryLetRef().withName(identifier);
    result.setResultType(let.getResultType());
    return result;
  }
  OperandRef operandRef=resolveOperandRef(identifier);
  if (operandRef != null) {
    return operandRef;
  }
  Element element=translatedLibrary.resolve(identifier);
  if (element == null) {
    ExpressionDefinitionInfo expressionInfo=libraryInfo.resolveExpressionReference(identifier);
    if (expressionInfo != null) {
      String saveContext=currentContext;
      currentContext=expressionInfo.getContext();
      try {
        ExpressionDef expressionDef=internalVisitExpressionDefinition(expressionInfo.getDefinition());
        element=expressionDef;
      }
  finally {
        currentContext=saveContext;
      }
    }
    ParameterDefinitionInfo parameterInfo=libraryInfo.resolveParameterReference(identifier);
    if (parameterInfo != null) {
      ParameterDef parameterDef=visitParameterDefinition(parameterInfo.getDefinition());
      element=parameterDef;
    }
  }
  if (element instanceof ExpressionDef) {
    ExpressionRef expressionRef=of.createExpressionRef().withName(((ExpressionDef)element).getName());
    expressionRef.setResultType(getExpressionDefResultType((ExpressionDef)element));
    if (expressionRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",expressionRef.getName()));
    }
    return expressionRef;
  }
  if (element instanceof ParameterDef) {
    ParameterRef parameterRef=of.createParameterRef().withName(((ParameterDef)element).getName());
    parameterRef.setResultType(element.getResultType());
    if (parameterRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",parameterRef.getName()));
    }
    return parameterRef;
  }
  if (element instanceof ValueSetDef) {
    ValueSetRef valuesetRef=of.createValueSetRef().withName(((ValueSetDef)element).getName());
    valuesetRef.setResultType(element.getResultType());
    if (valuesetRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",valuesetRef.getName()));
    }
    return valuesetRef;
  }
  if (element instanceof CodeSystemDef) {
    CodeSystemRef codesystemRef=of.createCodeSystemRef().withName(((CodeSystemDef)element).getName());
    codesystemRef.setResultType(element.getResultType());
    if (codesystemRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",codesystemRef.getName()));
    }
    return codesystemRef;
  }
  if (element instanceof CodeDef) {
    CodeRef codeRef=of.createCodeRef().withName(((CodeDef)element).getName());
    codeRef.setResultType(element.getResultType());
    if (codeRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",codeRef.getName()));
    }
    return codeRef;
  }
  if (element instanceof ConceptDef) {
    ConceptRef conceptRef=of.createConceptRef().withName(((ConceptDef)element).getName());
    conceptRef.setResultType(element.getResultType());
    if (conceptRef.getResultType() == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",conceptRef.getName()));
    }
    return conceptRef;
  }
  if (element instanceof IncludeDef) {
    LibraryRef libraryRef=new LibraryRef();
    libraryRef.setLibraryName(((IncludeDef)element).getLocalIdentifier());
    return libraryRef;
  }
  throw new IllegalArgumentException(String.format(""String_Node_Str"",identifier));
}"
11072,"@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  queries.push(queryContext);
  try {
    List<AliasedQuerySource> sources;
    queryContext.enterSourceClause();
    try {
      sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
    }
  finally {
      queryContext.exitSourceClause();
    }
    queryContext.addQuerySources(sources);
    boolean expressionContextPushed=false;
    if (inPopulationContext() && queryContext.referencesPatientContext()) {
      pushExpressionContext(""String_Node_Str"");
      expressionContextPushed=true;
    }
    try {
      List<LetClause> dfcx=ctx.letClause() != null ? (List<LetClause>)visit(ctx.letClause()) : null;
      if (dfcx != null) {
        queryContext.addLetClauses(dfcx);
      }
      List<RelationshipClause> qicx=new ArrayList<>();
      if (ctx.queryInclusionClause() != null) {
        for (        cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
          qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
        }
      }
      Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
      if (dateRangeOptimization && where != null) {
        for (        AliasedQuerySource aqs : sources) {
          where=optimizeDateRangeInQuery(where,aqs);
        }
      }
      ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
      if ((ret == null) && (sources.size() > 1)) {
        ret=of.createReturnClause().withDistinct(true);
        Tuple returnExpression=of.createTuple();
        TupleType returnType=new TupleType();
        for (        AliasedQuerySource aqs : sources) {
          TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
          element.getValue().setResultType(aqs.getResultType());
          element.setResultType(element.getValue().getResultType());
          returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
          returnExpression.getElement().add(element);
        }
        returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
        ret.setExpression(returnExpression);
        ret.setResultType(returnExpression.getResultType());
      }
      DataType queryResultType=ret == null ? sources.get(0).getResultType() : ret.getResultType();
      queryContext.setResultElementType(queryContext.isSingular() ? null : ((ListType)queryResultType).getElementType());
      SortClause sort=null;
      if (ctx.sortClause() != null) {
        queryContext.enterSortClause();
        try {
          sort=(SortClause)visit(ctx.sortClause());
        }
  finally {
          queryContext.exitSortClause();
        }
      }
      Query query=of.createQuery().withSource(sources).withLet(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
      if (ret == null) {
        query.setResultType(sources.get(0).getResultType());
      }
 else {
        query.setResultType(ret.getResultType());
      }
      return query;
    }
  finally {
      if (expressionContextPushed) {
        popExpressionContext();
      }
    }
  }
  finally {
    queries.pop();
  }
}","@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  queries.push(queryContext);
  try {
    List<AliasedQuerySource> sources;
    queryContext.enterSourceClause();
    try {
      sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
    }
  finally {
      queryContext.exitSourceClause();
    }
    queryContext.addQuerySources(sources);
    boolean expressionContextPushed=false;
    if (inPopulationContext() && queryContext.referencesPatientContext()) {
      pushExpressionContext(""String_Node_Str"");
      expressionContextPushed=true;
    }
    try {
      List<LetClause> dfcx=ctx.letClause() != null ? (List<LetClause>)visit(ctx.letClause()) : null;
      if (dfcx != null) {
        queryContext.addLetClauses(dfcx);
      }
      List<RelationshipClause> qicx=new ArrayList<>();
      if (ctx.queryInclusionClause() != null) {
        for (        cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
          qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
        }
      }
      Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
      if (dateRangeOptimization && where != null) {
        for (        AliasedQuerySource aqs : sources) {
          where=optimizeDateRangeInQuery(where,aqs);
        }
      }
      ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
      if ((ret == null) && (sources.size() > 1)) {
        ret=of.createReturnClause().withDistinct(true);
        Tuple returnExpression=of.createTuple();
        TupleType returnType=new TupleType();
        for (        AliasedQuerySource aqs : sources) {
          TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
          element.getValue().setResultType(aqs.getResultType());
          element.setResultType(element.getValue().getResultType());
          returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
          returnExpression.getElement().add(element);
        }
        returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
        ret.setExpression(returnExpression);
        ret.setResultType(returnExpression.getResultType());
      }
      DataType queryResultType=ret == null ? sources.get(0).getResultType() : ret.getResultType();
      queryContext.setResultElementType(queryContext.isSingular() ? null : ((ListType)queryResultType).getElementType());
      SortClause sort=null;
      if (ctx.sortClause() != null) {
        if (queryContext.isSingular()) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        queryContext.enterSortClause();
        try {
          sort=(SortClause)visit(ctx.sortClause());
          for (          SortByItem sortByItem : sort.getBy()) {
            if (sortByItem instanceof ByDirection) {
              verifyComparable(queryContext.getResultElementType());
            }
 else {
              verifyComparable(sortByItem.getResultType());
            }
          }
        }
  finally {
          queryContext.exitSortClause();
        }
      }
      Query query=of.createQuery().withSource(sources).withLet(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
      query.setResultType(queryResultType);
      return query;
    }
  finally {
      if (expressionContextPushed) {
        popExpressionContext();
      }
    }
  }
  finally {
    queries.pop();
  }
}"
11073,"private String parseString(ParseTree pt){
  return pt == null ? null : (String)visit(pt);
}","private String parseString(ParseTree pt){
  return StringEscapeUtils.unescapeCql(pt == null ? null : (String)visit(pt));
}"
11074,"protected Expression resolveFunction(String libraryName,String operatorName,Invocation invocation){
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=resolveCall(libraryName,operatorName,invocation,!checkForward);
  if (result == null) {
    Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(operatorName);
    for (    FunctionDefinitionInfo functionInfo : functionInfos) {
      visitFunctionDefinition(functionInfo.getDefinition());
    }
    result=resolveCall(libraryName,operatorName,invocation,true);
  }
  return result;
}","protected Expression resolveFunction(String libraryName,String operatorName,Invocation invocation){
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=resolveCall(libraryName,operatorName,invocation,!checkForward);
  if (result == null) {
    Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(operatorName);
    if (functionInfos != null) {
      for (      FunctionDefinitionInfo functionInfo : functionInfos) {
        internalVisitFunctionDefinition(functionInfo.getDefinition());
      }
    }
    result=resolveCall(libraryName,operatorName,invocation,true);
  }
  return result;
}"
11075,"@Override public ExpressionDef visitExpressionDefinition(@NotNull cqlParser.ExpressionDefinitionContext ctx){
  String identifier=parseString(ctx.identifier());
  ExpressionDef def=translatedLibrary.resolveExpressionRef(identifier);
  if (def == null) {
    pushExpressionDefinition(identifier);
    pushExpressionContext(currentContext);
    try {
      def=of.createExpressionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(identifier).withContext(currentContext).withExpression((Expression)visit(ctx.expression()));
      def.setResultType(def.getExpression().getResultType());
      addToLibrary(def);
    }
  finally {
      popExpressionDefinition();
      popExpressionContext();
    }
  }
  return def;
}","@Override public ExpressionDef visitExpressionDefinition(@NotNull cqlParser.ExpressionDefinitionContext ctx){
  ExpressionDef expressionDef=internalVisitExpressionDefinition(ctx);
  if (definedExpressionDefinitions.contains(expressionDef.getName())) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",expressionDef.getName()));
  }
  definedExpressionDefinitions.add(expressionDef.getName());
  return expressionDef;
}"
11076,"public Operator(String name,Signature signature,DataType resultType){
  if (name == null || name.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (resultType == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.name=name;
  this.signature=signature;
  this.resultType=resultType;
}","public Operator(String name,Signature signature,DataType resultType){
  if (name == null || name.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.name=name;
  this.signature=signature;
  this.resultType=resultType;
}"
11077,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11078,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11079,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11080,"@Override public Object visitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  currentFunctionDef=fun;
  pushExpressionContext(currentContext);
  try {
    fun.setExpression(parseExpression(ctx.functionBody()));
  }
  finally {
    currentFunctionDef=null;
    popExpressionContext();
  }
  fun.setContext(currentContext);
  fun.setResultType(fun.getExpression().getResultType());
  addToLibrary(fun);
  return fun;
}","@Override public Object visitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef result=(FunctionDef)internalVisitFunctionDefinition(ctx);
  Operator operator=Operator.fromFunctionDef(result);
  Set<Signature> definedSignatures=definedFunctionDefinitions.get(operator.getName());
  if (definedSignatures == null) {
    definedSignatures=new HashSet<>();
    definedFunctionDefinitions.put(operator.getName(),definedSignatures);
  }
  if (definedSignatures.contains(operator.getSignature())) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",operator.getName()));
  }
  definedSignatures.add(operator.getSignature());
  return result;
}"
11081,"protected Expression resolveFunction(String libraryName,String operatorName,Invocation invocation){
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=resolveCall(libraryName,operatorName,invocation,!checkForward);
  if (result == null) {
    Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(operatorName);
    for (    FunctionDefinitionInfo functionInfo : functionInfos) {
      visitFunctionDefinition(functionInfo.getDefinition());
    }
    result=resolveCall(libraryName,operatorName,invocation,true);
  }
  return result;
}","protected Expression resolveFunction(String libraryName,String operatorName,Invocation invocation){
  boolean checkForward=libraryName == null || libraryName.equals(""String_Node_Str"") || libraryName.equals(this.libraryInfo.getLibraryName());
  Expression result=resolveCall(libraryName,operatorName,invocation,!checkForward);
  if (result == null) {
    Iterable<FunctionDefinitionInfo> functionInfos=libraryInfo.resolveFunctionReference(operatorName);
    if (functionInfos != null) {
      for (      FunctionDefinitionInfo functionInfo : functionInfos) {
        internalVisitFunctionDefinition(functionInfo.getDefinition());
      }
    }
    result=resolveCall(libraryName,operatorName,invocation,true);
  }
  return result;
}"
11082,"public Operator(String name,Signature signature,DataType resultType){
  if (name == null || name.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (resultType == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.name=name;
  this.signature=signature;
  this.resultType=resultType;
}","public Operator(String name,Signature signature,DataType resultType){
  if (name == null || name.equals(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.name=name;
  this.signature=signature;
  this.resultType=resultType;
}"
11083,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11084,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11085,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11086,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11087,"public boolean contains(Operator operator){
  return signatures.containsKey(operator.getSignature());
}","public boolean contains(Operator operator){
  boolean result=signatures.containsKey(operator.getSignature());
  if (!result) {
    for (    SignatureNode n : signatures.values()) {
      result=n.subSignatures.contains(operator);
      if (result) {
        break;
      }
    }
  }
  return result;
}"
11088,"public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}","public DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveLabel(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      if (defaultModel != null) {
        DataType modelResult=defaultModel.resolveTypeName(typeName);
        if (modelResult != null) {
          return modelResult;
        }
      }
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11089,"@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}","@Override public Object visitInFixSetExpression(@NotNull cqlParser.InFixSetExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  if (left.getResultType() instanceof ListType && right.getResultType() instanceof ListType) {
    ListType leftListType=(ListType)left.getResultType();
    ListType rightListType=(ListType)right.getResultType();
    if (!(leftListType.isSuperTypeOf(rightListType) || rightListType.isSuperTypeOf(leftListType)) && !(leftListType.isCompatibleWith(rightListType) || rightListType.isCompatibleWith(leftListType))) {
      Set<DataType> elementTypes=new HashSet<DataType>();
      if (leftListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)leftListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(leftListType.getElementType());
      }
      if (rightListType.getElementType() instanceof ChoiceType) {
        for (        DataType choice : ((ChoiceType)rightListType.getElementType()).getTypes()) {
          elementTypes.add(choice);
        }
      }
 else {
        elementTypes.add(rightListType.getElementType());
      }
      if (elementTypes.size() > 1) {
        ListType targetType=new ListType(new ChoiceType(elementTypes));
        left=of.createAs().withOperand(left).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        left.setResultType(targetType);
        right=of.createAs().withOperand(right).withAsTypeSpecifier(libraryBuilder.dataTypeToTypeSpecifier(targetType));
        right.setResultType(targetType);
      }
    }
  }
switch (operator) {
case ""String_Node_Str"":
case ""String_Node_Str"":
    Union union=of.createUnion().withOperand(left,right);
  libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",union);
return union;
case ""String_Node_Str"":
Intersect intersect=of.createIntersect().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",intersect);
return intersect;
case ""String_Node_Str"":
Except except=of.createExcept().withOperand(left,right);
libraryBuilder.resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",except);
return except;
}
return of.createNull();
}"
11090,"private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}","private Operator instantiate(Signature signature,OperatorMap operatorMap,ConversionMap conversionMap){
  List<Operator> instantiations=new ArrayList<Operator>();
  int lowestConversionScore=Integer.MAX_VALUE;
  Operator instantiation=null;
  for (  GenericOperator genericOperator : genericOperators.values()) {
    InstantiationResult instantiationResult=genericOperator.instantiate(signature,operatorMap,conversionMap);
    if (instantiationResult.getOperator() != null) {
      if (instantiationResult.getConversionScore() <= lowestConversionScore) {
        if (instantiation == null || instantiationResult.getConversionScore() < lowestConversionScore) {
          instantiation=instantiationResult.getOperator();
          lowestConversionScore=instantiationResult.getConversionScore();
        }
 else {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,instantiation.getSignature().toString(),instantiationResult.getOperator().getSignature().toString()));
        }
      }
    }
  }
  return instantiation;
}"
11091,"@Override public Expression visitFunction(@NotNull cqlParser.FunctionContext ctx){
  if (!targets.empty()) {
    Expression target=targets.peek();
    if (target instanceof LibraryRef) {
      return resolveFunction(((LibraryRef)target).getLibraryName(),ctx);
    }
    if (target instanceof Expression) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    throw new IllegalArgumentException(String.format(""String_Node_Str"",target.getClass().getName()));
  }
  return resolveFunction(null,ctx);
}","@Override public Expression visitFunction(@NotNull cqlParser.FunctionContext ctx){
  if (!targets.empty()) {
    Expression target=targets.pop();
    try {
      if (target instanceof LibraryRef) {
        return resolveFunction(((LibraryRef)target).getLibraryName(),ctx);
      }
      if (target instanceof Expression) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      throw new IllegalArgumentException(String.format(""String_Node_Str"",target.getClass().getName()));
    }
  finally {
      targets.push(target);
    }
  }
  return resolveFunction(null,ctx);
}"
11092,"@Override public Expression visitMemberInvocation(@NotNull cqlParser.MemberInvocationContext ctx){
  String identifier=parseString(ctx.identifier());
  if (!targets.empty()) {
    return resolveAccessor(targets.peek(),identifier);
  }
  return resolveIdentifier(identifier);
}","@Override public Expression visitMemberInvocation(@NotNull cqlParser.MemberInvocationContext ctx){
  String identifier=parseString(ctx.identifier());
  if (!targets.empty()) {
    Expression target=targets.pop();
    try {
      return resolveAccessor(target,identifier);
    }
  finally {
      targets.push(target);
    }
  }
  return resolveIdentifier(identifier);
}"
11093,"private String convertToJSON(Library library) throws JAXBException {
  JAXBContext jc=JAXBContext.newInstance(Library.class);
  Marshaller marshaller=jc.createMarshaller();
  marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
  marshaller.setProperty(""String_Node_Str"",""String_Node_Str"");
  StringWriter writer=new StringWriter();
  marshaller.marshal(new ObjectFactory().createLibrary(library),writer);
  return writer.getBuffer().toString();
}","private String convertToJSON(Library library) throws JAXBException {
  JAXBContext jc=JAXBContext.newInstance(Library.class,Annotation.class);
  Marshaller marshaller=jc.createMarshaller();
  marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
  marshaller.setProperty(""String_Node_Str"",""String_Node_Str"");
  StringWriter writer=new StringWriter();
  marshaller.marshal(new ObjectFactory().createLibrary(library),writer);
  return writer.getBuffer().toString();
}"
11094,"private String convertToJSON(Library library) throws JAXBException {
  JAXBContext jc=JAXBContext.newInstance(Library.class);
  Marshaller marshaller=jc.createMarshaller();
  marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
  marshaller.setProperty(""String_Node_Str"",""String_Node_Str"");
  StringWriter writer=new StringWriter();
  marshaller.marshal(new ObjectFactory().createLibrary(library),writer);
  return writer.getBuffer().toString();
}","private String convertToJSON(Library library) throws JAXBException {
  JAXBContext jc=JAXBContext.newInstance(Library.class,Annotation.class);
  Marshaller marshaller=jc.createMarshaller();
  marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,true);
  marshaller.setProperty(""String_Node_Str"",""String_Node_Str"");
  StringWriter writer=new StringWriter();
  marshaller.marshal(new ObjectFactory().createLibrary(library),writer);
  return writer.getBuffer().toString();
}"
11095,"@Override public Object visitCastExpression(@NotNull cqlParser.CastExpressionContext ctx){
  As as=of.createAs().withOperand(parseExpression(ctx.expression())).withAsTypeSpecifier(parseTypeSpecifier(ctx.typeSpecifier())).withStrict(true);
  as.setResultType(as.getAsTypeSpecifier().getResultType());
  return as;
}","@Override public Object visitCastExpression(@NotNull cqlParser.CastExpressionContext ctx){
  As as=of.createAs().withOperand(parseExpression(ctx.expression())).withAsTypeSpecifier(parseTypeSpecifier(ctx.typeSpecifier())).withStrict(true);
  DataType targetType=as.getAsTypeSpecifier().getResultType();
  DataTypes.verifyCast(targetType,as.getOperand().getResultType());
  as.setResultType(targetType);
  return as;
}"
11096,"@Override public Object visitTypeExpression(@NotNull cqlParser.TypeExpressionContext ctx){
  if (ctx.getChild(1).getText().equals(""String_Node_Str"")) {
    Is is=of.createIs().withOperand(parseExpression(ctx.expression())).withIsTypeSpecifier(parseTypeSpecifier(ctx.typeSpecifier()));
    is.setResultType(resolveTypeName(""String_Node_Str""));
    return is;
  }
  As as=of.createAs().withOperand(parseExpression(ctx.expression())).withAsTypeSpecifier(parseTypeSpecifier(ctx.typeSpecifier())).withStrict(false);
  as.setResultType(as.getAsTypeSpecifier().getResultType());
  return as;
}","@Override public Object visitTypeExpression(@NotNull cqlParser.TypeExpressionContext ctx){
  if (ctx.getChild(1).getText().equals(""String_Node_Str"")) {
    Is is=of.createIs().withOperand(parseExpression(ctx.expression())).withIsTypeSpecifier(parseTypeSpecifier(ctx.typeSpecifier()));
    is.setResultType(resolveTypeName(""String_Node_Str""));
    return is;
  }
  As as=of.createAs().withOperand(parseExpression(ctx.expression())).withAsTypeSpecifier(parseTypeSpecifier(ctx.typeSpecifier())).withStrict(false);
  DataType targetType=as.getAsTypeSpecifier().getResultType();
  DataTypes.verifyCast(targetType,as.getOperand().getResultType());
  as.setResultType(targetType);
  return as;
}"
11097,"private void runSemanticTest(String testFileName) throws IOException {
  File translationTestFile=new File(Cql2ElmVisitorTest.class.getResource(testFileName).getFile());
  CqlTranslator translator=CqlTranslator.fromFile(translationTestFile);
  for (  CqlTranslatorException error : translator.getErrors()) {
    System.err.println(String.format(""String_Node_Str"",error.getLocator().getStartLine(),error.getLocator().getStartChar(),error.getMessage()));
  }
  assertThat(translator.getErrors().size(),is(0));
}","private void runSemanticTest(String testFileName,int expectedErrors) throws IOException {
  File translationTestFile=new File(Cql2ElmVisitorTest.class.getResource(testFileName).getFile());
  CqlTranslator translator=CqlTranslator.fromFile(translationTestFile);
  for (  CqlTranslatorException error : translator.getErrors()) {
    System.err.println(String.format(""String_Node_Str"",error.getLocator().getStartLine(),error.getLocator().getStartChar(),error.getMessage()));
  }
  assertThat(translator.getErrors().size(),is(expectedErrors));
}"
11098,"@Override public Object visitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  currentFunctionDef=fun;
  try {
    fun.setExpression(parseExpression(ctx.functionBody()));
  }
  finally {
    currentFunctionDef=null;
  }
  fun.setContext(currentContext);
  fun.setResultType(fun.getExpression().getResultType());
  addToLibrary(fun);
  return fun;
}","@Override public Object visitFunctionDefinition(@NotNull cqlParser.FunctionDefinitionContext ctx){
  FunctionDef fun=of.createFunctionDef().withAccessLevel(parseAccessModifier(ctx.accessModifier())).withName(parseString(ctx.identifier()));
  if (ctx.operandDefinition() != null) {
    for (    cqlParser.OperandDefinitionContext opdef : ctx.operandDefinition()) {
      TypeSpecifier typeSpecifier=parseTypeSpecifier(opdef.typeSpecifier());
      fun.getOperand().add((OperandDef)of.createOperandDef().withName(parseString(opdef.identifier())).withOperandTypeSpecifier(typeSpecifier).withResultType(typeSpecifier.getResultType()));
    }
  }
  currentFunctionDef=fun;
  pushExpressionContext(currentContext);
  try {
    fun.setExpression(parseExpression(ctx.functionBody()));
  }
  finally {
    currentFunctionDef=null;
    popExpressionContext();
  }
  fun.setContext(currentContext);
  fun.setResultType(fun.getExpression().getResultType());
  addToLibrary(fun);
  return fun;
}"
11099,"private DataType ensureCompatibleTypes(DataType first,DataType second){
  if (first.isSuperTypeOf(second) || second.isCompatibleWith(first)) {
    return first;
  }
  if (second.isSuperTypeOf(first) || first.isCompatibleWith(second)) {
    return second;
  }
  Conversion conversion=conversionMap.findConversion(second,first,true);
  if (conversion != null) {
    return first;
  }
  conversion=conversionMap.findConversion(first,second,true);
  if (conversion != null) {
    return second;
  }
  DataTypes.verifyType(second,first);
  return first;
}","private DataType ensureCompatibleTypes(DataType first,DataType second){
  if (first.equals(DataType.any)) {
    return second;
  }
  if (second.equals(DataType.any)) {
    return first;
  }
  if (first.isSuperTypeOf(second) || second.isCompatibleWith(first)) {
    return first;
  }
  if (second.isSuperTypeOf(first) || first.isCompatibleWith(second)) {
    return second;
  }
  Conversion conversion=conversionMap.findConversion(second,first,true);
  if (conversion != null) {
    return first;
  }
  conversion=conversionMap.findConversion(first,second,true);
  if (conversion != null) {
    return second;
  }
  DataTypes.verifyType(second,first);
  return first;
}"
11100,"public static TranslatedLibrary load(SystemModel systemModel){
  TranslatedLibrary system=new TranslatedLibrary();
  system.setIdentifier(new VersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str""));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean(),systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean(),systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean(),systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getAny()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  Operator booleanToString=new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getString());
  system.add(booleanToString);
  system.add(new Conversion(booleanToString,false));
  Operator integerToString=new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getString());
  system.add(integerToString);
  system.add(new Conversion(integerToString,false));
  Operator decimalToString=new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getString());
  system.add(decimalToString);
  system.add(new Conversion(decimalToString,false));
  Operator dateTimeToString=new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getString());
  system.add(dateTimeToString);
  system.add(new Conversion(dateTimeToString,false));
  Operator stringToBoolean=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getBoolean());
  system.add(stringToBoolean);
  system.add(new Conversion(stringToBoolean,false));
  Operator stringToInteger=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getInteger());
  system.add(stringToInteger);
  system.add(new Conversion(stringToInteger,false));
  Operator stringToDecimal=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getDecimal());
  system.add(stringToDecimal);
  system.add(new Conversion(stringToDecimal,false));
  Operator integerToDecimal=new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getDecimal());
  system.add(integerToDecimal);
  system.add(new Conversion(integerToDecimal,true));
  Operator stringToDateTime=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getDateTime());
  system.add(stringToDateTime);
  system.add(new Conversion(stringToDateTime,false));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getInteger()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getInteger()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getInteger()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getString()),systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getInteger()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),new ListType(systemModel.getString())));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getInteger()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getQuantity()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getDecimal()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getQuantity()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(),systemModel.getDateTime()));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new IntervalType(new TypeParameter(""String_Node_Str"")))),new ListType(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new ListType(new TypeParameter(""String_Node_Str"")))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),systemModel.getInteger()),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")),systemModel.getInteger(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getInteger(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getBoolean())),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getBoolean())),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getInteger())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getInteger(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getInteger())),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getQuantity())),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getCode()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getConcept()),systemModel.getBoolean()));
  return system;
}","public static TranslatedLibrary load(SystemModel systemModel){
  TranslatedLibrary system=new TranslatedLibrary();
  system.setIdentifier(new VersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str""));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean(),systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean(),systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean(),systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getAny()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getBoolean()));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  Operator booleanToString=new Operator(""String_Node_Str"",new Signature(systemModel.getBoolean()),systemModel.getString());
  system.add(booleanToString);
  system.add(new Conversion(booleanToString,false));
  Operator integerToString=new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getString());
  system.add(integerToString);
  system.add(new Conversion(integerToString,false));
  Operator decimalToString=new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getString());
  system.add(decimalToString);
  system.add(new Conversion(decimalToString,false));
  Operator dateTimeToString=new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getString());
  system.add(dateTimeToString);
  system.add(new Conversion(dateTimeToString,false));
  Operator stringToBoolean=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getBoolean());
  system.add(stringToBoolean);
  system.add(new Conversion(stringToBoolean,false));
  Operator stringToInteger=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getInteger());
  system.add(stringToInteger);
  system.add(new Conversion(stringToInteger,false));
  Operator stringToDecimal=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getDecimal());
  system.add(stringToDecimal);
  system.add(new Conversion(stringToDecimal,false));
  Operator integerToDecimal=new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getDecimal());
  system.add(integerToDecimal);
  system.add(new Conversion(integerToDecimal,true));
  Operator stringToDateTime=new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getDateTime());
  system.add(stringToDateTime);
  system.add(new Conversion(stringToDateTime,false));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getInteger()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getInteger()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDecimal(),systemModel.getDecimal()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getInteger()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getQuantity(),systemModel.getDecimal()),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getString())),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getString()),systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getInteger()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getString()),new ListType(systemModel.getString())));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getInteger()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getString()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getQuantity()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getInteger(),systemModel.getDecimal()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getQuantity()),systemModel.getDateTime()));
  system.add(new Operator(""String_Node_Str"",new Signature(),systemModel.getDateTime()));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new IntervalType(new TypeParameter(""String_Node_Str"")))),new ListType(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str"")),new IntervalType(new TypeParameter(""String_Node_Str""))),new IntervalType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new IntervalType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new ListType(new TypeParameter(""String_Node_Str"")))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new TypeParameter(""String_Node_Str""),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),systemModel.getInteger()),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")),systemModel.getInteger(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getInteger(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getBoolean(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str"")),new ListType(new TypeParameter(""String_Node_Str""))),new ListType(new TypeParameter(""String_Node_Str"")),new TypeParameter(""String_Node_Str"")));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getBoolean())),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getBoolean())),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getInteger())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),systemModel.getInteger(),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new GenericOperator(""String_Node_Str"",new Signature(new ListType(new TypeParameter(""String_Node_Str""))),new TypeParameter(""String_Node_Str""),new TypeParameter(""String_Node_Str"")));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getInteger())),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getQuantity())),systemModel.getQuantity()));
  system.add(new Operator(""String_Node_Str"",new Signature(new ListType(systemModel.getDecimal())),systemModel.getDecimal()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getDateTime(),systemModel.getDateTime()),systemModel.getInteger()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getString()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getCode()),systemModel.getBoolean()));
  system.add(new Operator(""String_Node_Str"",new Signature(systemModel.getConcept()),systemModel.getBoolean()));
  return system;
}"
11101,"@Override public Retrieve visitRetrieve(@NotNull cqlParser.RetrieveContext ctx){
  String model=parseString(ctx.topic().namedTypeSpecifier().modelIdentifier());
  String topic=parseString(ctx.topic().namedTypeSpecifier().identifier());
  ClassType classType=resolveTopic(model,topic);
  NamedType namedType=classType;
  if (namedType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",topic));
  }
  Retrieve retrieve=of.createRetrieve().withDataType(dataTypeToQName((DataType)namedType)).withTemplateId(classType != null ? classType.getIdentifier() : topic);
  if (ctx.valueset() != null) {
    if (ctx.valuesetPathIdentifier() != null) {
      retrieve.setCodeProperty(parseString(ctx.valuesetPathIdentifier()));
    }
 else     if (classType != null && classType.getPrimaryCodePath() != null) {
      retrieve.setCodeProperty(classType.getPrimaryCodePath());
    }
    List<String> identifiers=(List<String>)visit(ctx.valueset());
    retrieve.setCodes(resolveQualifiedIdentifier(identifiers));
  }
  retrieves.add(retrieve);
  retrieve.setResultType(new ListType((DataType)namedType));
  return retrieve;
}","@Override public Retrieve visitRetrieve(@NotNull cqlParser.RetrieveContext ctx){
  String model=parseString(ctx.topic().namedTypeSpecifier().modelIdentifier());
  String topic=parseString(ctx.topic().namedTypeSpecifier().identifier());
  ClassType classType=resolveTopic(model,topic);
  NamedType namedType=classType;
  if (namedType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",topic));
  }
  Retrieve retrieve=of.createRetrieve().withDataType(dataTypeToQName((DataType)namedType)).withTemplateId(classType.getIdentifier());
  if (ctx.valueset() != null) {
    if (ctx.valuesetPathIdentifier() != null) {
      retrieve.setCodeProperty(parseString(ctx.valuesetPathIdentifier()));
    }
 else     if (classType.getPrimaryCodePath() != null) {
      retrieve.setCodeProperty(classType.getPrimaryCodePath());
    }
    List<String> identifiers=(List<String>)visit(ctx.valueset());
    retrieve.setCodes(resolveQualifiedIdentifier(identifiers));
  }
  retrieves.add(retrieve);
  retrieve.setResultType(new ListType((DataType)namedType));
  return retrieve;
}"
11102,"public List<OperatorResolution> resolve(CallContext callContext,ConversionMap conversionMap){
  if (callContext == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<OperatorResolution> results=signatures.resolve(callContext,conversionMap);
  if (results == null) {
    Operator result=instantiate(callContext.getSignature(),conversionMap);
    if (result != null) {
      signatures.add(new SignatureNode(result));
      results=signatures.resolve(callContext,conversionMap);
    }
  }
  return results;
}","public List<OperatorResolution> resolve(CallContext callContext,ConversionMap conversionMap){
  if (callContext == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<OperatorResolution> results=signatures.resolve(callContext,conversionMap);
  if (results == null || allResultsUseConversion(results)) {
    Operator result=instantiate(callContext.getSignature(),conversionMap);
    if (result != null && !signatures.contains(result)) {
      signatures.add(new SignatureNode(result));
    }
    results=signatures.resolve(callContext,conversionMap);
  }
  return results;
}"
11103,"@Override public Object visitMembershipExpression(@NotNull cqlParser.MembershipExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
switch (operator) {
case ""String_Node_Str"":
    if (ctx.dateTimePrecisionSpecifier() != null) {
      In in=of.createIn().withPrecision(parseDateTimePrecision(ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText())).withOperand(parseExpression(ctx.expression(0)),parseExpression(ctx.expression(1)));
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
      return in;
    }
 else {
      Expression left=parseExpression(ctx.expression(0));
      Expression right=parseExpression(ctx.expression(1));
      if (right instanceof ValueSetRef) {
        InValueSet in=of.createInValueSet().withCode(left).withValueset((ValueSetRef)right);
        resolveCall(""String_Node_Str"",""String_Node_Str"",in,in.getCode().getResultType());
        return in;
      }
      In in=of.createIn().withOperand(left,right);
      return in;
    }
case ""String_Node_Str"":
  if (ctx.dateTimePrecisionSpecifier() != null) {
    Contains contains=of.createContains().withPrecision(parseDateTimePrecision(ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText())).withOperand(parseExpression(ctx.expression(0)),parseExpression(ctx.expression(1)));
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
    return contains;
  }
 else {
    Expression left=parseExpression(ctx.expression(0));
    Expression right=parseExpression(ctx.expression(1));
    if (left instanceof ValueSetRef) {
      InValueSet in=of.createInValueSet().withCode(right).withValueset((ValueSetRef)left);
      resolveCall(""String_Node_Str"",""String_Node_Str"",in,in.getCode().getResultType());
      return in;
    }
    Contains contains=of.createContains().withOperand(left,right);
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
    return contains;
  }
}
throw new IllegalArgumentException(String.format(""String_Node_Str"",operator));
}","@Override public Object visitMembershipExpression(@NotNull cqlParser.MembershipExpressionContext ctx){
  String operator=ctx.getChild(1).getText();
switch (operator) {
case ""String_Node_Str"":
    if (ctx.dateTimePrecisionSpecifier() != null) {
      In in=of.createIn().withPrecision(parseDateTimePrecision(ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText())).withOperand(parseExpression(ctx.expression(0)),parseExpression(ctx.expression(1)));
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
      return in;
    }
 else {
      Expression left=parseExpression(ctx.expression(0));
      Expression right=parseExpression(ctx.expression(1));
      if (right instanceof ValueSetRef) {
        InValueSet in=of.createInValueSet().withCode(left).withValueset((ValueSetRef)right);
        resolveCall(""String_Node_Str"",""String_Node_Str"",in,in.getCode().getResultType());
        return in;
      }
      In in=of.createIn().withOperand(left,right);
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
      return in;
    }
case ""String_Node_Str"":
  if (ctx.dateTimePrecisionSpecifier() != null) {
    Contains contains=of.createContains().withPrecision(parseDateTimePrecision(ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText())).withOperand(parseExpression(ctx.expression(0)),parseExpression(ctx.expression(1)));
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
    return contains;
  }
 else {
    Expression left=parseExpression(ctx.expression(0));
    Expression right=parseExpression(ctx.expression(1));
    if (left instanceof ValueSetRef) {
      InValueSet in=of.createInValueSet().withCode(right).withValueset((ValueSetRef)left);
      resolveCall(""String_Node_Str"",""String_Node_Str"",in,in.getCode().getResultType());
      return in;
    }
    Contains contains=of.createContains().withOperand(left,right);
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
    return contains;
  }
}
throw new IllegalArgumentException(String.format(""String_Node_Str"",operator));
}"
11104,"@Override public Retrieve visitRetrieve(@NotNull cqlParser.RetrieveContext ctx){
  String model=parseString(ctx.topic().namedTypeSpecifier().modelIdentifier());
  String topic=parseString(ctx.topic().namedTypeSpecifier().identifier());
  ClassType classType=resolveTopic(model,topic);
  NamedType namedType=classType;
  if (namedType == null) {
    namedType=(NamedType)resolveTypeName(model,topic);
    if (namedType == null) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",topic));
    }
  }
  Retrieve retrieve=of.createRetrieve().withDataType(dataTypeToQName((DataType)namedType)).withTemplateId(classType != null ? classType.getIdentifier() : topic);
  if (ctx.valueset() != null) {
    if (ctx.valuesetPathIdentifier() != null) {
      retrieve.setCodeProperty(parseString(ctx.valuesetPathIdentifier()));
    }
 else     if (classType != null && classType.getPrimaryCodePath() != null) {
      retrieve.setCodeProperty(classType.getPrimaryCodePath());
    }
    List<String> identifiers=(List<String>)visit(ctx.valueset());
    retrieve.setCodes(resolveQualifiedIdentifier(identifiers));
  }
  retrieves.add(retrieve);
  retrieve.setResultType(new ListType((DataType)namedType));
  return retrieve;
}","@Override public Retrieve visitRetrieve(@NotNull cqlParser.RetrieveContext ctx){
  String model=parseString(ctx.topic().namedTypeSpecifier().modelIdentifier());
  String topic=parseString(ctx.topic().namedTypeSpecifier().identifier());
  ClassType classType=resolveTopic(model,topic);
  NamedType namedType=classType;
  if (namedType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",topic));
  }
  Retrieve retrieve=of.createRetrieve().withDataType(dataTypeToQName((DataType)namedType)).withTemplateId(classType != null ? classType.getIdentifier() : topic);
  if (ctx.valueset() != null) {
    if (ctx.valuesetPathIdentifier() != null) {
      retrieve.setCodeProperty(parseString(ctx.valuesetPathIdentifier()));
    }
 else     if (classType != null && classType.getPrimaryCodePath() != null) {
      retrieve.setCodeProperty(classType.getPrimaryCodePath());
    }
    List<String> identifiers=(List<String>)visit(ctx.valueset());
    retrieve.setCodes(resolveQualifiedIdentifier(identifiers));
  }
  retrieves.add(retrieve);
  retrieve.setResultType(new ListType((DataType)namedType));
  return retrieve;
}"
11105,"public OperatorResolution resolveOperator(CallContext callContext,ConversionMap conversionMap){
  OperatorEntry entry=getEntry(callContext.getOperatorName());
  List<OperatorResolution> results=entry.resolve(callContext,conversionMap);
  OperatorResolution result=null;
  if (results != null) {
    int lowestScore=Integer.MAX_VALUE;
    for (    OperatorResolution resolution : results) {
      Iterator<DataType> operands=resolution.getOperator().getSignature().getOperandTypes().iterator();
      Iterator<DataType> callOperands=callContext.getSignature().getOperandTypes().iterator();
      Iterator<Conversion> conversions=resolution.hasConversions() ? resolution.getConversions().iterator() : null;
      int score=0;
      while (operands.hasNext()) {
        DataType operand=operands.next();
        DataType callOperand=callOperands.next();
        Conversion conversion=conversions != null ? conversions.next() : null;
        if (operand.equals(callOperand)) {
          score+=0;
        }
 else         if (operand.isSuperTypeOf(callOperand)) {
          score+=1;
        }
 else         if (conversion != null) {
          score+=2;
        }
      }
      if (score < lowestScore) {
        lowestScore=score;
        result=resolution;
      }
 else       if (score == lowestScore) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",callContext.getOperatorName(),callContext.getSignature(),result.getOperator().getSignature(),resolution.getOperator().getSignature()));
      }
    }
  }
  return result;
}","public OperatorResolution resolveOperator(CallContext callContext,ConversionMap conversionMap){
  OperatorEntry entry=getEntry(callContext.getOperatorName());
  List<OperatorResolution> results=entry.resolve(callContext,conversionMap);
  OperatorResolution result=null;
  if (results != null) {
    int lowestScore=Integer.MAX_VALUE;
    List<OperatorResolution> lowestScoringResults=new ArrayList<>();
    for (    OperatorResolution resolution : results) {
      Iterator<DataType> operands=resolution.getOperator().getSignature().getOperandTypes().iterator();
      Iterator<DataType> callOperands=callContext.getSignature().getOperandTypes().iterator();
      Iterator<Conversion> conversions=resolution.hasConversions() ? resolution.getConversions().iterator() : null;
      int score=0;
      while (operands.hasNext()) {
        DataType operand=operands.next();
        DataType callOperand=callOperands.next();
        Conversion conversion=conversions != null ? conversions.next() : null;
        if (operand.equals(callOperand)) {
          score+=0;
        }
 else         if (operand.isSuperTypeOf(callOperand)) {
          score+=1;
        }
 else         if (conversion != null) {
          score+=2;
        }
      }
      if (score < lowestScore) {
        lowestScore=score;
        lowestScoringResults.clear();
        lowestScoringResults.add(resolution);
      }
 else       if (score == lowestScore) {
        lowestScoringResults.add(resolution);
      }
    }
    if (lowestScoringResults.size() > 1) {
      StringBuilder message=new StringBuilder(""String_Node_Str"").append(callContext.getOperatorName()).append(callContext.getSignature()).append(""String_Node_Str"");
      for (      OperatorResolution resolution : lowestScoringResults) {
        message.append(""String_Node_Str"").append(resolution.getOperator().getName()).append(resolution.getOperator().getSignature());
      }
      throw new IllegalArgumentException(message.toString());
    }
 else {
      result=lowestScoringResults.get(0);
    }
  }
  return result;
}"
11106,"private DataType resolveTypeName(String modelName,String typeName){
  DataType result=null;
  if (modelName == null || modelName.equals(""String_Node_Str"")) {
    for (    Model model : models.values()) {
      DataType modelResult=model.resolveTypeName(typeName);
      if (modelResult != null) {
        if (result != null) {
          throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
        }
        result=modelResult;
      }
    }
  }
 else {
    result=getModel(modelName).resolveTypeName(typeName);
  }
  return result;
}","private DataType resolveTypeName(String modelName,String typeName){
  DataType result=resolveTopic(modelName,typeName);
  if (result == null) {
    if (modelName == null || modelName.equals(""String_Node_Str"")) {
      for (      Model model : models.values()) {
        DataType modelResult=model.resolveTypeName(typeName);
        if (modelResult != null) {
          if (result != null) {
            throw new IllegalArgumentException(String.format(""String_Node_Str"",typeName,((NamedType)result).getName(),((NamedType)modelResult).getName()));
          }
          result=modelResult;
        }
      }
    }
 else {
      result=getModel(modelName).resolveTypeName(typeName);
    }
  }
  return result;
}"
11107,"@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  List<AliasedQuerySource> sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
  queryContext.addQuerySources(sources);
  queries.push(queryContext);
  try {
    List<DefineClause> dfcx=ctx.defineClause() != null ? (List<DefineClause>)visit(ctx.defineClause()) : null;
    if (dfcx != null) {
      queryContext.addDefineClauses(dfcx);
    }
    List<RelationshipClause> qicx=new ArrayList<>();
    if (ctx.queryInclusionClause() != null) {
      for (      cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
        qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
      }
    }
    Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
    if (dateRangeOptimization && where != null) {
      for (      AliasedQuerySource aqs : sources) {
        where=optimizeDateRangeInQuery(where,aqs);
      }
    }
    ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
    if ((ret == null) && (sources.size() > 1)) {
      ret=of.createReturnClause().withDistinct(true);
      Tuple returnExpression=of.createTuple();
      TupleType returnType=new TupleType();
      Boolean anyLists=false;
      for (      AliasedQuerySource aqs : sources) {
        TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
        element.setResultType(element.getValue().getResultType());
        returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
        returnExpression.getElement().add(element);
        if (aqs.getResultType() instanceof ListType) {
          anyLists=true;
        }
      }
      returnExpression.setResultType(anyLists ? new ListType(returnType) : returnType);
      ret.setExpression(returnExpression);
      ret.setResultType(returnExpression.getResultType());
    }
    SortClause sort=ctx.sortClause() != null ? (SortClause)visit(ctx.sortClause()) : null;
    Query query=of.createQuery().withSource(sources).withDefine(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
    if (ret == null) {
      query.setResultType(sources.get(0).getResultType());
    }
 else {
      query.setResultType(ret.getResultType());
    }
    return query;
  }
  finally {
    queries.pop();
  }
}","@Override public Object visitQuery(@NotNull cqlParser.QueryContext ctx){
  QueryContext queryContext=new QueryContext();
  List<AliasedQuerySource> sources=(List<AliasedQuerySource>)visit(ctx.sourceClause());
  queryContext.addQuerySources(sources);
  queries.push(queryContext);
  try {
    List<DefineClause> dfcx=ctx.defineClause() != null ? (List<DefineClause>)visit(ctx.defineClause()) : null;
    if (dfcx != null) {
      queryContext.addDefineClauses(dfcx);
    }
    List<RelationshipClause> qicx=new ArrayList<>();
    if (ctx.queryInclusionClause() != null) {
      for (      cqlParser.QueryInclusionClauseContext queryInclusionClauseContext : ctx.queryInclusionClause()) {
        qicx.add((RelationshipClause)visit(queryInclusionClauseContext));
      }
    }
    Expression where=ctx.whereClause() != null ? (Expression)visit(ctx.whereClause()) : null;
    if (dateRangeOptimization && where != null) {
      for (      AliasedQuerySource aqs : sources) {
        where=optimizeDateRangeInQuery(where,aqs);
      }
    }
    ReturnClause ret=ctx.returnClause() != null ? (ReturnClause)visit(ctx.returnClause()) : null;
    if ((ret == null) && (sources.size() > 1)) {
      ret=of.createReturnClause().withDistinct(true);
      Tuple returnExpression=of.createTuple();
      TupleType returnType=new TupleType();
      for (      AliasedQuerySource aqs : sources) {
        TupleElement element=of.createTupleElement().withName(aqs.getAlias()).withValue(of.createAliasRef().withName(aqs.getAlias()));
        element.setResultType(element.getValue().getResultType());
        returnType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
        returnExpression.getElement().add(element);
      }
      returnExpression.setResultType(queryContext.isSingular() ? returnType : new ListType(returnType));
      ret.setExpression(returnExpression);
      ret.setResultType(returnExpression.getResultType());
    }
    SortClause sort=ctx.sortClause() != null ? (SortClause)visit(ctx.sortClause()) : null;
    Query query=of.createQuery().withSource(sources).withDefine(dfcx).withRelationship(qicx).withWhere(where).withReturn(ret).withSort(sort);
    if (ret == null) {
      query.setResultType(sources.get(0).getResultType());
    }
 else {
      query.setResultType(ret.getResultType());
    }
    return query;
  }
  finally {
    queries.pop();
  }
}"
11108,"@Override public Object visitReturnClause(@NotNull cqlParser.ReturnClauseContext ctx){
  ReturnClause returnClause=of.createReturnClause();
  if (ctx.getChild(1) instanceof TerminalNode) {
switch (ctx.getChild(1).getText()) {
case ""String_Node_Str"":
      returnClause.setDistinct(false);
    break;
case ""String_Node_Str"":
  returnClause.setDistinct(true);
break;
default :
break;
}
}
returnClause.setExpression(parseExpression(ctx.expression()));
returnClause.setResultType(returnClause.getExpression().getResultType());
return returnClause;
}","@Override public Object visitReturnClause(@NotNull cqlParser.ReturnClauseContext ctx){
  ReturnClause returnClause=of.createReturnClause();
  if (ctx.getChild(1) instanceof TerminalNode) {
switch (ctx.getChild(1).getText()) {
case ""String_Node_Str"":
      returnClause.setDistinct(false);
    break;
case ""String_Node_Str"":
  returnClause.setDistinct(true);
break;
default :
break;
}
}
returnClause.setExpression(parseExpression(ctx.expression()));
returnClause.setResultType(queries.peek().isSingular() ? returnClause.getExpression().getResultType() : new ListType(returnClause.getExpression().getResultType()));
return returnClause;
}"
11109,"public void addQuerySource(AliasedQuerySource source){
  sources.put(source.getAlias(),source);
}","public void addQuerySource(AliasedQuerySource source){
  sources.put(source.getAlias(),source);
  if (source.getResultType() instanceof ListType) {
    isSingularValue=false;
  }
}"
11110,"@Override public Object visitTupleTypeSpecifier(@NotNull cqlParser.TupleTypeSpecifierContext ctx){
  TupleType resultType=new TupleType();
  TupleTypeSpecifier typeSpecifier=of.createTupleTypeSpecifier();
  for (  cqlParser.TupleElementDefinitionContext definitionContext : ctx.tupleElementDefinition()) {
    TupleElementDefinition element=(TupleElementDefinition)visit(definitionContext);
    resultType.addElement(new TupleTypeElement(element.getName(),element.getResultType()));
    typeSpecifier.getElement().add(element);
  }
  typeSpecifier.setResultType(resultType);
  return typeSpecifier;
}","@Override public Object visitTupleTypeSpecifier(@NotNull cqlParser.TupleTypeSpecifierContext ctx){
  TupleType resultType=new TupleType();
  TupleTypeSpecifier typeSpecifier=of.createTupleTypeSpecifier();
  for (  cqlParser.TupleElementDefinitionContext definitionContext : ctx.tupleElementDefinition()) {
    TupleElementDefinition element=(TupleElementDefinition)visit(definitionContext);
    resultType.addElement(new TupleTypeElement(element.getName(),element.getType().getResultType()));
    typeSpecifier.getElement().add(element);
  }
  typeSpecifier.setResultType(resultType);
  return typeSpecifier;
}"
11111,"public void addOperator(Operator operator){
  if (operator instanceof GenericOperator) {
    addGenericOperator((GenericOperator)operator);
  }
 else {
    if (operators.containsKey(operator.getSignature())) {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",name,operator.getSignature().toString()));
    }
    operators.put(operator.getSignature(),operator);
  }
}","public void addOperator(Operator operator){
  if (operator instanceof GenericOperator) {
    addGenericOperator((GenericOperator)operator);
  }
 else {
    signatures.add(new SignatureNode(operator));
  }
}"
11112,"public Operator resolve(Signature signature){
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Operator result=null;
  for (  Operator o : operators.values()) {
    if (o.getSignature().isSuperTypeOf(signature)) {
      if (result != null) {
        throw new IllegalArgumentException(String.format(""String_Node_Str"",this.name,signature,result.getSignature(),o.getSignature()));
      }
      result=o;
    }
  }
  if (result == null) {
    result=instantiate(signature);
    if (result != null) {
      operators.put(result.getSignature(),result);
    }
  }
  return result;
}","public Operator resolve(Signature signature){
  if (signature == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Operator result=signatures.resolve(signature);
  if (result == null) {
    result=instantiate(signature);
    if (result != null) {
      signatures.add(new SignatureNode(result));
    }
  }
  return result;
}"
11113,"@Override public Object visitIncludesIntervalOperatorPhrase(@NotNull cqlParser.IncludesIntervalOperatorPhraseContext ctx){
  boolean isProper=false;
  boolean isRightPoint=false;
  TimingOperatorContext timingOperator=timingOperators.peek();
  for (  ParseTree pt : ctx.children) {
    if (""String_Node_Str"".equals(pt.getText())) {
      isProper=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      Start start=of.createStart().withOperand(timingOperator.getRight());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",start);
      timingOperator.setRight(start);
      isRightPoint=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      End end=of.createEnd().withOperand(timingOperator.getRight());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",end);
      timingOperator.setRight(end);
      isRightPoint=true;
      continue;
    }
  }
  String dateTimePrecision=ctx.dateTimePrecisionSpecifier() != null ? ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText() : null;
  if (isRightPoint) {
    if (dateTimePrecision != null) {
      Contains contains=of.createContains().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
      return contains;
    }
    Contains contains=of.createContains().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
    return contains;
  }
  if (isProper) {
    if (dateTimePrecision != null) {
      ProperIncludes properIncludes=of.createProperIncludes().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludes);
      return properIncludes;
    }
    ProperIncludes properIncludes=of.createProperIncludes().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludes);
    return properIncludes;
  }
  if (dateTimePrecision != null) {
    Includes includes=of.createIncludes().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includes);
    return includes;
  }
  Includes includes=of.createIncludes().withOperand(timingOperator.getLeft(),timingOperator.getRight());
  resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includes);
  return includes;
}","@Override public Object visitIncludesIntervalOperatorPhrase(@NotNull cqlParser.IncludesIntervalOperatorPhraseContext ctx){
  boolean isProper=false;
  boolean isRightPoint=false;
  TimingOperatorContext timingOperator=timingOperators.peek();
  for (  ParseTree pt : ctx.children) {
    if (""String_Node_Str"".equals(pt.getText())) {
      isProper=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      Start start=of.createStart().withOperand(timingOperator.getRight());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",start);
      timingOperator.setRight(start);
      isRightPoint=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      End end=of.createEnd().withOperand(timingOperator.getRight());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",end);
      timingOperator.setRight(end);
      isRightPoint=true;
      continue;
    }
  }
  String dateTimePrecision=ctx.dateTimePrecisionSpecifier() != null ? ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText() : null;
  if (!isRightPoint && !(timingOperator.getRight().getResultType() instanceof IntervalType || timingOperator.getRight().getResultType() instanceof ListType)) {
    isRightPoint=true;
  }
  if (isRightPoint) {
    if (dateTimePrecision != null) {
      Contains contains=of.createContains().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
      return contains;
    }
    Contains contains=of.createContains().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",contains);
    return contains;
  }
  if (isProper) {
    if (dateTimePrecision != null) {
      ProperIncludes properIncludes=of.createProperIncludes().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludes);
      return properIncludes;
    }
    ProperIncludes properIncludes=of.createProperIncludes().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludes);
    return properIncludes;
  }
  if (dateTimePrecision != null) {
    Includes includes=of.createIncludes().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includes);
    return includes;
  }
  Includes includes=of.createIncludes().withOperand(timingOperator.getLeft(),timingOperator.getRight());
  resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includes);
  return includes;
}"
11114,"private QName dataTypeToQName(DataType type){
  if (type instanceof NamedType) {
    NamedType namedType=(NamedType)type;
    return new QName(getModelHelper(namedType.getNamespace()).getModelInfo().getUrl(),namedType.getSimpleName());
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}","private QName dataTypeToQName(DataType type){
  if (type instanceof NamedType) {
    NamedType namedType=(NamedType)type;
    org.hl7.elm_modelinfo.r1.ModelInfo modelInfo=getModelHelper(namedType.getNamespace()).getModelInfo();
    return new QName(modelInfo.getUrl(),namedType.getSimpleName());
  }
  throw new IllegalArgumentException(""String_Node_Str"");
}"
11115,"public String loadResourceAsString(String resource){
  StringBuffer template=new StringBuffer();
  try {
    URL address=TestPatientSource.class.getResource(resource);
    File file=new File(address.toURI());
    FileReader reader=new FileReader(file);
    BufferedReader buffer=new BufferedReader(reader);
    String line=null;
    while ((line=buffer.readLine()) != null) {
      template.append(line).append(""String_Node_Str"");
    }
    reader.close();
    buffer.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return template.toString();
}","public String loadResourceAsString(String resource){
  StringBuffer template=new StringBuffer();
  try {
    URL address=TestPatientSource.class.getResource(resource);
    File file=new File(address.toURI());
    FileInputStream fis=new FileInputStream(file);
    InputStreamReader reader=new InputStreamReader(fis,""String_Node_Str"");
    BufferedReader buffer=new BufferedReader(reader);
    String line=null;
    while ((line=buffer.readLine()) != null) {
      template.append(line).append(""String_Node_Str"");
    }
    reader.close();
    buffer.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return template.toString();
}"
11116,"/** 
 * Execute JavaScript representing a CQL measure in the Rhino engine.
 * @param javascript The script to execute.
 * @param isMeasure Whether or not the script should be wrapped in thetemplate-exec function that imports CQL javascripts and execute the javascript as a Clinical Quality Measure. If  {@code false} the javascriptwill be executed as a plain-old javascript.
 * @return The result set of the execution.
 * @throws Exception if the patient source is {@code null}.
 */
private static Results execute(String javascript,boolean isMeasure) throws Exception {
  if (patientSource == null) {
    throw new Exception(""String_Node_Str"");
  }
  reset();
  prepWorkingArea(javascript);
  Main dbg=null;
  Context context=null;
  if (debugJavascript) {
    ContextFactory factory=new ContextFactory();
    if (isMeasure) {
      dbg=new Main(""String_Node_Str"");
    }
 else {
      dbg=new Main(""String_Node_Str"");
    }
    dbg.attachTo(factory);
    dbg.setBreakOnEnter(true);
    dbg.setBreakOnExceptions(true);
    dbg.setBreakOnReturn(false);
    context=factory.enterContext();
    System.setIn(dbg.getIn());
    System.setOut(dbg.getOut());
    System.setErr(dbg.getErr());
  }
 else {
    context=Context.enter();
  }
  ScriptableObject scope=new ImporterTopLevel(context);
  if (debugJavascript) {
    dbg.setScope(scope);
    dbg.setSize(640,400);
    dbg.setVisible(true);
  }
  patientSource.initialize(context,scope);
  Global global=new Global(context);
  boolean sandboxed=false;
  List<String> modulePath=new ArrayList<String>();
  String mainModule=workingArea.toString();
  modulePath.add(mainModule);
  Require require=global.installRequire(context,modulePath,sandboxed);
  require.install(scope);
  Scriptable arguments=context.newArray(scope,new Object[]{});
  scope.defineProperty(""String_Node_Str"",arguments,ScriptableObject.DONTENUM);
  try {
    File lib=new File(mainModule);
    File script=null;
    if (isMeasure) {
      script=new File(lib,""String_Node_Str"");
    }
 else {
      script=new File(lib,""String_Node_Str"");
    }
    String uri=script.toURI().toURL().toExternalForm();
    ScriptableObject.putProperty(scope,""String_Node_Str"",uri);
    if (isMeasure) {
      require.requireMain(context,""String_Node_Str"");
    }
 else {
      require.requireMain(context,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    System.err.println(e.getClass().getName() + ""String_Node_Str"" + e.getLocalizedMessage());
    System.err.println(workingArea.toAbsolutePath().toString());
    e.printStackTrace();
  }
  Context.exit();
  cleanWorkingArea();
  return results.copy();
}","/** 
 * Execute JavaScript representing a CQL measure in the Rhino engine.
 * @param javascript The script to execute.
 * @param isMeasure Whether or not the script should be wrapped in thetemplate-exec function that imports CQL javascripts and execute the javascript as a Clinical Quality Measure. If  {@code false} the javascriptwill be executed as a plain-old javascript.
 * @return The result set of the execution.
 * @throws Exception if the patient source is {@code null}.
 */
private static Results execute(String javascript,boolean isMeasure) throws Exception {
  if (patientSource == null) {
    throw new Exception(""String_Node_Str"");
  }
  reset();
  prepWorkingArea(javascript);
  Main dbg=null;
  Context context=null;
  if (debugJavascript) {
    ContextFactory factory=new ContextFactory();
    if (isMeasure) {
      dbg=new Main(""String_Node_Str"");
    }
 else {
      dbg=new Main(""String_Node_Str"");
    }
    dbg.attachTo(factory);
    dbg.setBreakOnEnter(true);
    dbg.setBreakOnExceptions(true);
    dbg.setBreakOnReturn(false);
    context=factory.enterContext();
    System.setIn(dbg.getIn());
    System.setOut(dbg.getOut());
    System.setErr(dbg.getErr());
  }
 else {
    context=Context.enter();
  }
  ScriptableObject scope=new ImporterTopLevel(context);
  if (debugJavascript) {
    dbg.setScope(scope);
    dbg.setSize(640,400);
    dbg.setVisible(true);
  }
  patientSource.initialize(context,scope);
  Global global=new Global(context);
  boolean sandboxed=false;
  List<String> modulePath=new ArrayList<String>();
  String mainModule=workingArea.toUri().toString();
  modulePath.add(mainModule);
  Require require=global.installRequire(context,modulePath,sandboxed);
  require.install(scope);
  Scriptable arguments=context.newArray(scope,new Object[]{});
  scope.defineProperty(""String_Node_Str"",arguments,ScriptableObject.DONTENUM);
  try {
    File lib=new File(mainModule);
    File script=null;
    if (isMeasure) {
      script=new File(lib,""String_Node_Str"");
    }
 else {
      script=new File(lib,""String_Node_Str"");
    }
    String uri=script.toURI().toURL().toExternalForm();
    ScriptableObject.putProperty(scope,""String_Node_Str"",uri);
    if (isMeasure) {
      require.requireMain(context,""String_Node_Str"");
    }
 else {
      require.requireMain(context,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    System.err.println(e.getClass().getName() + ""String_Node_Str"" + e.getLocalizedMessage());
    System.err.println(workingArea.toAbsolutePath().toString());
    e.printStackTrace();
  }
  Context.exit();
  cleanWorkingArea();
  return results.copy();
}"
11117,"private static void writeSnippetsToCoffeeFile(Map<String,StringBuilder> snippets,Path file) throws IOException {
  File tempFile=new File(file.toFile().getAbsolutePath() + ""String_Node_Str"");
  PrintWriter pw=new PrintWriter(tempFile,""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + file.toFile().getName() + ""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println();
  for (  Map.Entry<String,StringBuilder> entry : snippets.entrySet()) {
    updateSnippet(entry.getValue());
    String name=entry.getKey();
    String snippet=entry.getValue().toString();
    String json=CqlTranslator.fromText(snippet,CqlTranslator.Options.EnableDateRangeOptimization).toJson();
    pw.println(""String_Node_Str"" + name);
    pw.println(snippet);
    pw.println(""String_Node_Str"");
    pw.println();
    pw.println(""String_Node_Str"" + name + ""String_Node_Str""+ json);
    pw.println();
  }
  pw.close();
  Files.move(tempFile.toPath(),file,StandardCopyOption.ATOMIC_MOVE,StandardCopyOption.REPLACE_EXISTING);
  System.out.println(""String_Node_Str"" + file.toAbsolutePath().normalize());
}","private static void writeSnippetsToCoffeeFile(Map<String,StringBuilder> snippets,Path file) throws IOException {
  File tempFile=new File(file.toFile().getAbsolutePath() + ""String_Node_Str"");
  PrintWriter pw=new PrintWriter(tempFile,""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println();
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"" + file.toFile().getName() + ""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println();
  for (  Map.Entry<String,StringBuilder> entry : snippets.entrySet()) {
    updateSnippet(entry.getValue());
    String name=entry.getKey();
    String snippet=entry.getValue().toString();
    pw.println(""String_Node_Str"" + name);
    pw.println(snippet);
    pw.println(""String_Node_Str"");
    pw.println();
    try {
      String json=CqlTranslator.fromText(snippet,CqlTranslator.Options.EnableDateRangeOptimization).toJson();
      pw.println(""String_Node_Str"" + name + ""String_Node_Str""+ json);
    }
 catch (    Exception e) {
      pw.println(""String_Node_Str"" + name + ""String_Node_Str"");
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
      pw.println(""String_Node_Str"");
    }
    pw.println();
  }
  pw.close();
  Files.move(tempFile.toPath(),file,StandardCopyOption.ATOMIC_MOVE,StandardCopyOption.REPLACE_EXISTING);
  System.out.println(""String_Node_Str"" + file.toAbsolutePath().normalize());
}"
11118,"private List<TupleTypeElement> getSortedElements(){
  if (sortedElements == null) {
    sortedElements=new ArrayList<>(elements);
    sortedElements.sort(TupleTypeElementComparator);
  }
  return sortedElements;
}","private List<TupleTypeElement> getSortedElements(){
  if (sortedElements == null) {
    sortedElements=new ArrayList<>(elements);
    Collections.sort(sortedElements,TupleTypeElementComparator);
  }
  return sortedElements;
}"
11119,"@Override public Object visitIncludedInIntervalOperatorPhrase(@NotNull cqlParser.IncludedInIntervalOperatorPhraseContext ctx){
  boolean isProper=false;
  boolean isLeftPoint=false;
  TimingOperatorContext timingOperator=timingOperators.peek();
  for (  ParseTree pt : ctx.children) {
    if (""String_Node_Str"".equals(pt.getText())) {
      Start start=of.createStart().withOperand(timingOperator.getLeft());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",start);
      timingOperator.setLeft(start);
      isLeftPoint=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      End end=of.createEnd().withOperand(timingOperator.getLeft());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",end);
      timingOperator.setLeft(end);
      isLeftPoint=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      isProper=true;
      continue;
    }
  }
  String dateTimePrecision=ctx.dateTimePrecisionSpecifier() != null ? ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText() : null;
  if (!isLeftPoint && !(timingOperator.getLeft().getResultType() instanceof IntervalType)) {
    isLeftPoint=true;
  }
  if (isLeftPoint) {
    if (isProper) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (dateTimePrecision != null) {
      In in=of.createIn().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
      return in;
    }
    In in=of.createIn().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
    return in;
  }
  if (isProper) {
    if (dateTimePrecision != null) {
      ProperIncludedIn properIncludedIn=of.createProperIncludedIn().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludedIn);
      return properIncludedIn;
    }
    ProperIncludedIn properIncludedIn=of.createProperIncludedIn().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludedIn);
    return properIncludedIn;
  }
  if (dateTimePrecision != null) {
    IncludedIn includedIn=of.createIncludedIn().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includedIn);
    return includedIn;
  }
  IncludedIn includedIn=of.createIncludedIn().withOperand(timingOperator.getLeft(),timingOperator.getRight());
  resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includedIn);
  return includedIn;
}","@Override public Object visitIncludedInIntervalOperatorPhrase(@NotNull cqlParser.IncludedInIntervalOperatorPhraseContext ctx){
  boolean isProper=false;
  boolean isLeftPoint=false;
  TimingOperatorContext timingOperator=timingOperators.peek();
  for (  ParseTree pt : ctx.children) {
    if (""String_Node_Str"".equals(pt.getText())) {
      Start start=of.createStart().withOperand(timingOperator.getLeft());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",start);
      timingOperator.setLeft(start);
      isLeftPoint=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      End end=of.createEnd().withOperand(timingOperator.getLeft());
      resolveUnaryCall(""String_Node_Str"",""String_Node_Str"",end);
      timingOperator.setLeft(end);
      isLeftPoint=true;
      continue;
    }
    if (""String_Node_Str"".equals(pt.getText())) {
      isProper=true;
      continue;
    }
  }
  String dateTimePrecision=ctx.dateTimePrecisionSpecifier() != null ? ctx.dateTimePrecisionSpecifier().dateTimePrecision().getText() : null;
  if (!isLeftPoint && !(timingOperator.getLeft().getResultType() instanceof IntervalType || timingOperator.getLeft().getResultType() instanceof ListType)) {
    isLeftPoint=true;
  }
  if (isLeftPoint) {
    if (isProper) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (dateTimePrecision != null) {
      In in=of.createIn().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
      return in;
    }
    In in=of.createIn().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",in);
    return in;
  }
  if (isProper) {
    if (dateTimePrecision != null) {
      ProperIncludedIn properIncludedIn=of.createProperIncludedIn().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
      resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludedIn);
      return properIncludedIn;
    }
    ProperIncludedIn properIncludedIn=of.createProperIncludedIn().withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",properIncludedIn);
    return properIncludedIn;
  }
  if (dateTimePrecision != null) {
    IncludedIn includedIn=of.createIncludedIn().withPrecision(parseDateTimePrecision(dateTimePrecision)).withOperand(timingOperator.getLeft(),timingOperator.getRight());
    resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includedIn);
    return includedIn;
  }
  IncludedIn includedIn=of.createIncludedIn().withOperand(timingOperator.getLeft(),timingOperator.getRight());
  resolveBinaryCall(""String_Node_Str"",""String_Node_Str"",includedIn);
  return includedIn;
}"
11120,"@Override public Object visitIntervalSelector(@NotNull cqlParser.IntervalSelectorContext ctx){
  Interval result=of.createInterval().withLow(parseExpression(ctx.expression(0))).withLowClosed(ctx.getChild(1).getText().equals(""String_Node_Str"")).withHigh(parseExpression(ctx.expression(1))).withHighClosed(ctx.getChild(5).getText().equals(""String_Node_Str""));
  DataType lowType=result.getLow().getResultType();
  DataType highType=result.getHigh().getResultType();
  if (lowType != null) {
    if (highType != null) {
      DataTypes.verifyType(highType,lowType);
    }
  }
  DataType pointType=lowType != null ? lowType : highType;
  if (pointType != null) {
    IntervalType resultType=new IntervalType(pointType);
    result.setResultType(resultType);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return result;
}","@Override public Object visitIntervalSelector(@NotNull cqlParser.IntervalSelectorContext ctx){
  Interval result=of.createInterval().withLow(parseExpression(ctx.expression(0))).withLowClosed(ctx.getChild(1).getText().equals(""String_Node_Str"")).withHigh(parseExpression(ctx.expression(1))).withHighClosed(ctx.getChild(5).getText().equals(""String_Node_Str""));
  DataType lowType=result.getLow().getResultType();
  DataType highType=result.getHigh().getResultType();
  if ((lowType != null) && (highType != null)) {
    DataTypes.verifyType(highType,lowType);
  }
  DataType pointType=lowType != null ? lowType : highType;
  if (pointType != null) {
    IntervalType resultType=new IntervalType(pointType);
    result.setResultType(resultType);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return result;
}"
11121,"@Override public Object visitIfThenElseExpressionTerm(@NotNull cqlParser.IfThenElseExpressionTermContext ctx){
  If _if=of.createIf().withCondition(parseExpression(ctx.expression(0))).withThen(parseExpression(ctx.expression(1))).withElse(parseExpression(ctx.expression(2)));
  DataTypes.verifyType(_if.getCondition().getResultType(),resolveTypeName(""String_Node_Str""));
  DataType thenType=_if.getThen().getResultType();
  DataTypes.verifyType(_if.getElse().getResultType(),thenType);
  _if.setResultType(thenType);
  return _if;
}","@Override public Object visitIfThenElseExpressionTerm(@NotNull cqlParser.IfThenElseExpressionTermContext ctx){
  If ifObject=of.createIf().withCondition(parseExpression(ctx.expression(0))).withThen(parseExpression(ctx.expression(1))).withElse(parseExpression(ctx.expression(2)));
  DataTypes.verifyType(ifObject.getCondition().getResultType(),resolveTypeName(""String_Node_Str""));
  DataType thenType=ifObject.getThen().getResultType();
  DataTypes.verifyType(ifObject.getElse().getResultType(),thenType);
  ifObject.setResultType(thenType);
  return ifObject;
}"
11122,"public static Object visitData(String cqlData,boolean enableAnnotations,boolean enableDateRangeOptimization){
  List<CqlTranslator.Options> options=new ArrayList<>();
  if (enableAnnotations) {
    options.add(CqlTranslator.Options.EnableAnnotations);
  }
  if (enableDateRangeOptimization) {
    options.add(CqlTranslator.Options.EnableDateRangeOptimization);
  }
  CqlTranslator translator=CqlTranslator.fromText(cqlData,options.toArray(new CqlTranslator.Options[options.size()]));
  EnsureValid(translator);
  return translator.toObject();
}","public static Object visitData(String cqlData,boolean enableAnnotations,boolean enableDateRangeOptimization){
  List<CqlTranslator.Options> options=new ArrayList<>();
  if (enableAnnotations) {
    options.add(CqlTranslator.Options.EnableAnnotations);
  }
  if (enableDateRangeOptimization) {
    options.add(CqlTranslator.Options.EnableDateRangeOptimization);
  }
  CqlTranslator translator=CqlTranslator.fromText(cqlData,options.toArray(new CqlTranslator.Options[options.size()]));
  ensureValid(translator);
  return translator.toObject();
}"
11123,"public static Library visitLibrary(String cqlLibrary){
  CqlTranslator translator=CqlTranslator.fromText(cqlLibrary);
  EnsureValid(translator);
  return translator.toELM();
}","public static Library visitLibrary(String cqlLibrary){
  CqlTranslator translator=CqlTranslator.fromText(cqlLibrary);
  ensureValid(translator);
  return translator.toELM();
}"
11124,"@Override public boolean equals(Object object){
  if (!(object instanceof Code))   return false;
  Code that=(Code)object;
  return (this.code.equals(that.code) && this.system.equals(that.system) && this.version.equals(that.version));
}","@Override public boolean equals(Object object){
  if (!(object instanceof Code))   return false;
  Code that=(Code)object;
  return this.code.equals(that.code) && this.system.equals(that.system) && this.version.equals(that.version);
}"
11125,public ValueSet[] findValueSetsByOid(String oid);,"/** 
 * Find ValueSets by OID.
 * @param oid The OID of the ValueSet.
 * @return An array, possibly null or empty, of ValueSets with the given OID(the array may contain multiple versions of the same ValueSet).
 */
public ValueSet[] findValueSetsByOid(String oid);"
11126,"public ValueSet findValueSet(String oid,String version);","/** 
 * Find a particular version of a ValueSet.
 * @param oid The OID of the ValueSet.
 * @param version The version of the ValueSet.
 * @return The version of the ValueSet, if it exists and is available, otherwise null.
 */
public ValueSet findValueSet(String oid,String version);"
11127,"@Override public Object visitMethodExpressionTerm(@NotNull cqlParser.MethodExpressionTermContext ctx){
  FunctionRef fun=of.createFunctionRef();
  Expression left=parseExpression(ctx.expressionTerm());
  if (left instanceof IdentifierRef) {
    fun.setLibraryName(((IdentifierRef)left).getLibraryName());
    fun.setName(((IdentifierRef)left).getName());
  }
  if (ctx.expression() != null) {
    for (    cqlParser.ExpressionContext expressionContext : ctx.expression()) {
      fun.getOperand().add((Expression)visit(expressionContext));
    }
  }
  if (fun.getLibraryName() == null) {
    String ageRelatedFunctionName=resolveAgeRelatedFunction(fun.getName());
    if (ageRelatedFunctionName != null) {
switch (ageRelatedFunctionName) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
          CalculateAge operator=of.createCalculateAge().withPrecision(resolveAgeRelatedFunctionPrecision(fun.getName()));
          if (fun.getOperand().size() > 0) {
            operator.setOperand(fun.getOperand().get(0));
          }
 else {
            operator.setOperand(of.createProperty().withPath(getModelHelper().getModelInfo().getPatientBirthDatePropertyName()).withSource(of.createExpressionRef().withName(""String_Node_Str"")));
          }
          return operator;
        }
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
        CalculateAgeAt operator=of.createCalculateAgeAt().withPrecision(resolveAgeRelatedFunctionPrecision(ageRelatedFunctionName));
        operator.getOperand().addAll(fun.getOperand());
        if (operator.getOperand().size() == 1) {
          operator.getOperand().add(0,of.createProperty().withPath(getModelHelper().getModelInfo().getPatientBirthDatePropertyName()).withSource(of.createExpressionRef().withName(""String_Node_Str"")));
        }
        return operator;
      }
  }
}
}
return fun;
}","@Override public Object visitMethodExpressionTerm(@NotNull cqlParser.MethodExpressionTermContext ctx){
  FunctionRef fun=of.createFunctionRef();
  Expression left=parseExpression(ctx.expressionTerm());
  if (left instanceof IdentifierRef) {
    fun.setLibraryName(((IdentifierRef)left).getLibraryName());
    fun.setName(((IdentifierRef)left).getName());
  }
  if (ctx.expression() != null) {
    for (    cqlParser.ExpressionContext expressionContext : ctx.expression()) {
      fun.getOperand().add((Expression)visit(expressionContext));
    }
  }
  if (fun.getLibraryName() == null) {
    String ageRelatedFunctionName=resolveAgeRelatedFunction(fun.getName());
    if (ageRelatedFunctionName != null) {
switch (ageRelatedFunctionName) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
          CalculateAge operator=of.createCalculateAge().withPrecision(resolveAgeRelatedFunctionPrecision(ageRelatedFunctionName));
          if (fun.getOperand().size() > 0) {
            operator.setOperand(fun.getOperand().get(0));
          }
 else {
            operator.setOperand(of.createProperty().withPath(getModelHelper().getModelInfo().getPatientBirthDatePropertyName()).withSource(of.createExpressionRef().withName(""String_Node_Str"")));
          }
          return operator;
        }
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
        CalculateAgeAt operator=of.createCalculateAgeAt().withPrecision(resolveAgeRelatedFunctionPrecision(ageRelatedFunctionName));
        operator.getOperand().addAll(fun.getOperand());
        if (operator.getOperand().size() == 1) {
          operator.getOperand().add(0,of.createProperty().withPath(getModelHelper().getModelInfo().getPatientBirthDatePropertyName()).withSource(of.createExpressionRef().withName(""String_Node_Str"")));
        }
        return operator;
      }
  }
}
}
return fun;
}"
11128,"@Override public boolean equals(Object object){
  if (!(object instanceof Code))   return false;
  Code that=(Code)object;
  return (this.code.equals(that.code) && this.system.equals(that.system) && this.version.equals(that.version));
}","@Override public boolean equals(Object object){
  if (!(object instanceof Code))   return false;
  Code that=(Code)object;
  return this.code.equals(that.code) && this.system.equals(that.system) && this.version.equals(that.version);
}"
11129,public ValueSet[] findValueSetsByOid(String oid);,"/** 
 * Find ValueSets by OID.
 * @param oid The OID of the ValueSet.
 * @return An array, possibly null or empty, of ValueSets with the given OID(the array may contain multiple versions of the same ValueSet).
 */
public ValueSet[] findValueSetsByOid(String oid);"
11130,"public ValueSet findValueSet(String oid,String version);","/** 
 * Find a particular version of a ValueSet.
 * @param oid The OID of the ValueSet.
 * @param version The version of the ValueSet.
 * @return The version of the ValueSet, if it exists and is available, otherwise null.
 */
public ValueSet findValueSet(String oid,String version);"
11131,"private static void prepWorkingArea(String script) throws IOException {
  workingArea=Files.createTempDirectory(""String_Node_Str"");
  for (  String filename : requiredScripts) {
    File file=new File(Engine.class.getResource(filename).getFile());
    Path source=Paths.get(file.toURI());
    Files.copy(source,workingArea.resolve(source.getFileName()));
  }
  Path engineScript=Files.createFile(workingArea.resolve(""String_Node_Str""));
  Files.write(engineScript,script.getBytes(),StandardOpenOption.WRITE);
}","private static void prepWorkingArea(String script) throws IOException {
  workingArea=Files.createTempDirectory(""String_Node_Str"");
  for (  String filename : requiredScripts) {
    File file=new File(Engine.class.getResource(filename).getFile());
    Path source=Paths.get(file.toURI());
    Files.copy(source,workingArea.resolve(source.getFileName()));
  }
  Path engineScript=Files.createFile(workingArea.resolve(""String_Node_Str""));
  Files.write(engineScript,script.getBytes(""String_Node_Str""),StandardOpenOption.WRITE);
}"
11132,"private static void cleanWorkingArea(){
  String[] files=workingArea.toFile().list();
  for (  String file : files) {
    try {
      Files.delete(workingArea.resolve(file));
    }
 catch (    IOException e) {
    }
  }
  try {
    Files.delete(workingArea);
  }
 catch (  IOException e) {
  }
  workingArea=null;
}","private static void cleanWorkingArea(){
  String[] files=workingArea.toFile().list();
  for (  String file : files) {
    try {
      Files.delete(workingArea.resolve(file));
    }
 catch (    IOException e) {
      e.toString();
    }
  }
  try {
    Files.delete(workingArea);
  }
 catch (  IOException e) {
    e.toString();
  }
  workingArea=null;
}"
11133,"/** 
 * Pad integers to always have two characters. Numbers under 10 will have a leading zero (e.g. ""08"")
 */
private String pad(int value){
  if (value < 10) {
    return (""String_Node_Str"" + value);
  }
 else {
    return (""String_Node_Str"" + value);
  }
}","/** 
 * Pad integers to always have two characters. Numbers under 10 will have a leading zero (e.g. ""08"")
 */
private String pad(int value){
  if (value < 10) {
    return ""String_Node_Str"" + value;
  }
 else {
    return ""String_Node_Str"" + value;
  }
}"
11134,"private String generatePatient(){
  char initial=(char)(random.nextInt(26) + 'A');
  String surname=surnames[random.nextInt(surnames.length)];
  String gender=(random.nextBoolean()) ? ""String_Node_Str"" : ""String_Node_Str"";
  int year=1980 + random.nextInt(30);
  int month=1 + random.nextInt(12);
  int day=1 + random.nextInt(28);
  int hour=random.nextInt(24);
  int minute=random.nextInt(60);
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(id).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(initial).append(""String_Node_Str"").append(surname).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(gender).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(year).append(""String_Node_Str"").append(pad(month)).append(""String_Node_Str"").append(pad(day)).append(""String_Node_Str"");
  sb.append(pad(hour)).append(""String_Node_Str"").append(pad(minute)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","private String generatePatient(){
  char initial=(char)(random.nextInt(26) + 'A');
  String surname=surnames[random.nextInt(surnames.length)];
  String gender=random.nextBoolean() ? ""String_Node_Str"" : ""String_Node_Str"";
  int year=1980 + random.nextInt(30);
  int month=1 + random.nextInt(12);
  int day=1 + random.nextInt(28);
  int hour=random.nextInt(24);
  int minute=random.nextInt(60);
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(id).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(initial).append(""String_Node_Str"").append(surname).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(gender).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(year).append(""String_Node_Str"").append(pad(month)).append(""String_Node_Str"").append(pad(day)).append(""String_Node_Str"");
  sb.append(pad(hour)).append(""String_Node_Str"").append(pad(minute)).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
11135,"public void testTrackBacks(){
  for (  ClinicalRequest dc : visitor.getClinicalRequests()) {
    int expectedNumbers[]={0,0,0,0};
switch (((ValueSetRef)dc.getCodes()).getName()) {
case ""String_Node_Str"":
      expectedNumbers=new int[]{19,6,19,37};
    break;
case ""String_Node_Str"":
  expectedNumbers=new int[]{19,47,19,77};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{22,5,22,58};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{25,5,25,51};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{49,13,49,61};
break;
default :
fail(""String_Node_Str"" + dc);
}
assertThat(dc.getTrackerId(),notNullValue());
TrackBack tb=dc.getTrackbacks().iterator().next();
assertThat(tb.getLibrary(),is(of.createVersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str"")));
assertThat(tb.getStartLine(),is(expectedNumbers[0]));
assertThat(tb.getStartChar(),is(expectedNumbers[1]));
assertThat(tb.getEndLine(),is(expectedNumbers[2]));
assertThat(tb.getEndChar(),is(expectedNumbers[3]));
}
for (ValueSetDef vs : library.getValueSets().getDef()) {
int expectedNumbers[]={0,0,0,0};
switch (((Literal)((FunctionRef)vs.getValueSet()).getOperand().get(0)).getValue()) {
case ""String_Node_Str"":
expectedNumbers=new int[]{7,1,7,83};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{8,1,8,83};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{9,1,9,85};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{10,1,10,88};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{11,1,11,92};
break;
default :
fail(""String_Node_Str"" + vs);
}
assertThat(vs.getTrackerId(),notNullValue());
assertThat(vs.getTrackbacks().size(),is(1));
TrackBack tb=vs.getTrackbacks().iterator().next();
assertThat(tb.getLibrary(),is(of.createVersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str"")));
assertThat(tb.getStartLine(),is(expectedNumbers[0]));
assertThat(tb.getStartChar(),is(expectedNumbers[1]));
assertThat(tb.getEndLine(),is(expectedNumbers[2]));
assertThat(tb.getEndChar(),is(expectedNumbers[3]));
}
for (ExpressionDef ls : library.getStatements().getDef()) {
int expectedNumbers[]={0,0,0,0};
switch (ls.getName()) {
case ""String_Node_Str"":
expectedNumbers=new int[]{15,1,16,85};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{18,1,19,78};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{21,1,22,58};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{24,1,28,56};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{30,1,31,96};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{33,1,34,123};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{36,1,37,29};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{39,1,40,40};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{42,1,43,8};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{45,1,46,23};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{48,1,49,137};
break;
default :
fail(""String_Node_Str"" + ls.getName());
}
assertThat(ls.getTrackerId(),notNullValue());
assertThat(ls.getTrackbacks().size(),is(1));
TrackBack tb=ls.getTrackbacks().iterator().next();
assertThat(tb.getLibrary(),is(of.createVersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str"")));
assertThat(tb.getStartLine(),is(expectedNumbers[0]));
assertThat(tb.getStartChar(),is(expectedNumbers[1]));
assertThat(tb.getEndLine(),is(expectedNumbers[2]));
assertThat(tb.getEndChar(),is(expectedNumbers[3]));
}
}","@Test(enabled=false) public void testTrackBacks(){
  for (  ClinicalRequest dc : visitor.getClinicalRequests()) {
    int expectedNumbers[]={0,0,0,0};
switch (((ValueSetRef)dc.getCodes()).getName()) {
case ""String_Node_Str"":
      expectedNumbers=new int[]{19,6,19,37};
    break;
case ""String_Node_Str"":
  expectedNumbers=new int[]{19,47,19,77};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{22,5,22,58};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{25,5,25,51};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{49,13,49,61};
break;
default :
fail(""String_Node_Str"" + dc);
}
assertThat(dc.getTrackerId(),notNullValue());
TrackBack tb=dc.getTrackbacks().iterator().next();
assertThat(tb.getLibrary(),is(of.createVersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str"")));
assertThat(tb.getStartLine(),is(expectedNumbers[0]));
assertThat(tb.getStartChar(),is(expectedNumbers[1]));
assertThat(tb.getEndLine(),is(expectedNumbers[2]));
assertThat(tb.getEndChar(),is(expectedNumbers[3]));
}
for (ValueSetDef vs : library.getValueSets().getDef()) {
int expectedNumbers[]={0,0,0,0};
switch (((Literal)((FunctionRef)vs.getValueSet()).getOperand().get(0)).getValue()) {
case ""String_Node_Str"":
expectedNumbers=new int[]{7,1,7,83};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{8,1,8,83};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{9,1,9,85};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{10,1,10,88};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{11,1,11,92};
break;
default :
fail(""String_Node_Str"" + vs);
}
assertThat(vs.getTrackerId(),notNullValue());
assertThat(vs.getTrackbacks().size(),is(1));
TrackBack tb=vs.getTrackbacks().iterator().next();
assertThat(tb.getLibrary(),is(of.createVersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str"")));
assertThat(tb.getStartLine(),is(expectedNumbers[0]));
assertThat(tb.getStartChar(),is(expectedNumbers[1]));
assertThat(tb.getEndLine(),is(expectedNumbers[2]));
assertThat(tb.getEndChar(),is(expectedNumbers[3]));
}
for (ExpressionDef ls : library.getStatements().getDef()) {
int expectedNumbers[]={0,0,0,0};
switch (ls.getName()) {
case ""String_Node_Str"":
expectedNumbers=new int[]{15,1,16,85};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{18,1,19,78};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{21,1,22,58};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{24,1,28,56};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{30,1,31,96};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{33,1,34,123};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{36,1,37,29};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{39,1,40,40};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{42,1,43,8};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{45,1,46,23};
break;
case ""String_Node_Str"":
expectedNumbers=new int[]{48,1,49,137};
break;
default :
fail(""String_Node_Str"" + ls.getName());
}
assertThat(ls.getTrackerId(),notNullValue());
assertThat(ls.getTrackbacks().size(),is(1));
TrackBack tb=ls.getTrackbacks().iterator().next();
assertThat(tb.getLibrary(),is(of.createVersionedIdentifier().withId(""String_Node_Str"").withVersion(""String_Node_Str"")));
assertThat(tb.getStartLine(),is(expectedNumbers[0]));
assertThat(tb.getStartChar(),is(expectedNumbers[1]));
assertThat(tb.getEndLine(),is(expectedNumbers[2]));
assertThat(tb.getEndChar(),is(expectedNumbers[3]));
}
}"
11136,"public void testValueSets(){
  Collection<ValueSetDef> actualVS=library.getValueSets().getDef();
  Collection<ValueSetDef> expectedVS=Arrays.asList(of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")));
  assertThat(actualVS,is(expectedVS));
}","@Test(enabled=false) public void testValueSets(){
  Collection<ValueSetDef> actualVS=library.getValueSets().getDef();
  Collection<ValueSetDef> expectedVS=Arrays.asList(of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")),of.createValueSetDef().withName(""String_Node_Str"").withValueSet(createValueSetFunctionRef(""String_Node_Str"")));
  assertThat(actualVS,is(expectedVS));
}"
11137,"private Library resolveLibrary(String identifier){
  return libraries.getOrDefault(identifier,null);
}","private Library resolveLibrary(String identifier){
  return libraries.get(identifier);
}"
11138,"@Override public Object visitTimingExpression(@NotNull cqlParser.TimingExpressionContext ctx){
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  TimingOperatorContext timingOperatorContext=new TimingOperatorContext();
  timingOperators.push(timingOperatorContext);
  try {
    return visit(ctx.intervalOperatorPhrase());
  }
  finally {
    timingOperators.pop();
  }
}","@Override public Object visitTimingExpression(@NotNull cqlParser.TimingExpressionContext ctx){
  Expression left=parseExpression(ctx.expression(0));
  Expression right=parseExpression(ctx.expression(1));
  TimingOperatorContext timingOperatorContext=new TimingOperatorContext(left,right);
  timingOperators.push(timingOperatorContext);
  try {
    return visit(ctx.intervalOperatorPhrase());
  }
  finally {
    timingOperators.pop();
  }
}"
11139,"public AliasedQuerySource resolveAlias(String identifier){
  for (  AliasedQuerySource source : sources) {
    if (""String_Node_Str"".equals(source.getAlias())) {
      return source;
    }
  }
  return null;
}","public AliasedQuerySource resolveAlias(String identifier){
  for (  AliasedQuerySource source : sources) {
    if (identifier.equals(source.getAlias())) {
      return source;
    }
  }
  return null;
}"
11140,"@Test public void testComplexQuery(){
  String cql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExpressionDef let=(ExpressionDef)visitData(cql);
  Query query=(Query)let.getExpression();
  AliasedQuerySource source=query.getSource();
  assertThat(source.getAlias(),is(""String_Node_Str""));
  ClinicalRequest request=(ClinicalRequest)source.getExpression();
  assertThat(request.getDataType(),quickDataType(""String_Node_Str""));
  assertThat(request.getCodeProperty(),is(""String_Node_Str""));
  ValueSetRef code=(ValueSetRef)request.getCodes();
  assertThat(code.getName(),is(""String_Node_Str""));
  assertThat(code.getLibraryName(),is(nullValue()));
  assertThat(code.getDescription(),is(nullValue()));
  assertThat(request.getDateProperty(),is(nullValue()));
  assertThat(request.getDateRange(),is(nullValue()));
  assertThat(request.getDescription(),is(nullValue()));
  assertThat(request.getScope(),is(nullValue()));
  assertThat(request.getSubjectProperty(),is(nullValue()));
  assertThat(request.getSubject(),is(nullValue()));
  assertThat(request.getCardinality(),is(nullValue()));
  assertThat(request.getIdProperty(),is(nullValue()));
  assertThat(request.getTemplateId(),is(nullValue()));
  assertThat(query.getRelationship(),hasSize(1));
  RelationshipClause relationship=query.getRelationship().get(0);
  assertThat(relationship,instanceOf(With.class));
  assertThat(relationship.getAlias(),is(""String_Node_Str""));
  ClinicalRequest withRequest=(ClinicalRequest)relationship.getExpression();
  assertThat(withRequest.getDataType(),quickDataType(""String_Node_Str""));
  assertThat(withRequest.getCodeProperty(),is(""String_Node_Str""));
  ValueSetRef withCode=(ValueSetRef)withRequest.getCodes();
  assertThat(withCode.getName(),is(""String_Node_Str""));
  assertThat(withCode.getLibraryName(),is(nullValue()));
  assertThat(withCode.getDescription(),is(nullValue()));
  assertThat(withRequest.getDateProperty(),is(nullValue()));
  assertThat(withRequest.getDateRange(),is(nullValue()));
  assertThat(withRequest.getDescription(),is(nullValue()));
  assertThat(withRequest.getScope(),is(nullValue()));
  assertThat(withRequest.getSubjectProperty(),is(nullValue()));
  assertThat(withRequest.getSubject(),is(nullValue()));
  assertThat(withRequest.getCardinality(),is(nullValue()));
  assertThat(withRequest.getIdProperty(),is(nullValue()));
  assertThat(withRequest.getTemplateId(),is(nullValue()));
  OverlapsAfter withWhere=(OverlapsAfter)relationship.getWhere();
  assertThat(withWhere.getDescription(),is(nullValue()));
  assertThat(withWhere.getOperand(),hasSize(2));
  GreaterOrEqual where=(GreaterOrEqual)query.getWhere();
  assertThat(where.getDescription(),is(nullValue()));
  assertThat(where.getOperand(),hasSize(2));
  DaysBetween whereLHS=(DaysBetween)where.getOperand().get(0);
  assertThat(whereLHS.getDescription(),is(nullValue()));
  assertThat(whereLHS.getOperand(),hasSize(2));
  Begin whereLHSBegin=(Begin)whereLHS.getOperand().get(0);
  assertThat(whereLHSBegin.getDescription(),is(nullValue()));
  End whereLHSEnd=(End)whereLHS.getOperand().get(1);
  assertThat(whereLHSEnd.getDescription(),is(nullValue()));
  assertThat(where.getOperand().get(1),literalFor(120));
  ObjectExpression rtn=(ObjectExpression)query.getReturn();
  assertThat(rtn.getDescription(),is(nullValue()));
  assertThat(rtn.getProperty(),hasSize(2));
  PropertyExpression rtnP1=rtn.getProperty().get(0);
  assertThat(rtnP1.getName(),is(""String_Node_Str""));
  PropertyExpression rtnP2=rtn.getProperty().get(1);
  assertThat(rtnP2.getName(),is(""String_Node_Str""));
  DaysBetween rtnP2Val=(DaysBetween)rtnP2.getValue();
  assertThat(rtnP2Val.getDescription(),is(nullValue()));
  assertThat(rtnP2Val.getOperand(),hasSize(2));
  Begin rtnP2ValBegin=(Begin)rtnP2Val.getOperand().get(0);
  assertThat(rtnP2ValBegin.getDescription(),is(nullValue()));
  End rtnP2ValEnd=(End)rtnP2Val.getOperand().get(1);
  assertThat(rtnP2ValEnd.getDescription(),is(nullValue()));
  SortClause sort=query.getSort();
  assertThat(sort.getBy(),hasSize(1));
  ByExpression sortBy=(ByExpression)sort.getBy().get(0);
  Identifier id=(Identifier)sortBy.getExpression();
  assertThat(id.getIdentifier(),is(""String_Node_Str""));
  assertThat(id.getLibraryName(),is(nullValue()));
  assertThat(sortBy.getDirection(),is(SortDirection.DESC));
}","@Test public void testComplexQuery(){
  String cql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ExpressionDef let=(ExpressionDef)visitData(cql);
  Query query=(Query)let.getExpression();
  AliasedQuerySource source=query.getSource();
  assertThat(source.getAlias(),is(""String_Node_Str""));
  ClinicalRequest request=(ClinicalRequest)source.getExpression();
  assertThat(request.getDataType(),quickDataType(""String_Node_Str""));
  assertThat(request.getCodeProperty(),is(""String_Node_Str""));
  ValueSetRef code=(ValueSetRef)request.getCodes();
  assertThat(code.getName(),is(""String_Node_Str""));
  assertThat(code.getLibraryName(),is(nullValue()));
  assertThat(code.getDescription(),is(nullValue()));
  assertThat(request.getDateProperty(),is(nullValue()));
  assertThat(request.getDateRange(),is(nullValue()));
  assertThat(request.getDescription(),is(nullValue()));
  assertThat(request.getScope(),is(nullValue()));
  assertThat(request.getSubjectProperty(),is(nullValue()));
  assertThat(request.getSubject(),is(nullValue()));
  assertThat(request.getCardinality(),is(nullValue()));
  assertThat(request.getIdProperty(),is(nullValue()));
  assertThat(request.getTemplateId(),is(nullValue()));
  assertThat(query.getRelationship(),hasSize(1));
  RelationshipClause relationship=query.getRelationship().get(0);
  assertThat(relationship,instanceOf(With.class));
  assertThat(relationship.getAlias(),is(""String_Node_Str""));
  ClinicalRequest withRequest=(ClinicalRequest)relationship.getExpression();
  assertThat(withRequest.getDataType(),quickDataType(""String_Node_Str""));
  assertThat(withRequest.getCodeProperty(),is(""String_Node_Str""));
  ValueSetRef withCode=(ValueSetRef)withRequest.getCodes();
  assertThat(withCode.getName(),is(""String_Node_Str""));
  assertThat(withCode.getLibraryName(),is(nullValue()));
  assertThat(withCode.getDescription(),is(nullValue()));
  assertThat(withRequest.getDateProperty(),is(nullValue()));
  assertThat(withRequest.getDateRange(),is(nullValue()));
  assertThat(withRequest.getDescription(),is(nullValue()));
  assertThat(withRequest.getScope(),is(nullValue()));
  assertThat(withRequest.getSubjectProperty(),is(nullValue()));
  assertThat(withRequest.getSubject(),is(nullValue()));
  assertThat(withRequest.getCardinality(),is(nullValue()));
  assertThat(withRequest.getIdProperty(),is(nullValue()));
  assertThat(withRequest.getTemplateId(),is(nullValue()));
  OverlapsAfter withWhere=(OverlapsAfter)relationship.getWhere();
  assertThat(withWhere.getDescription(),is(nullValue()));
  assertThat(withWhere.getOperand(),hasSize(2));
  Property overlapsLHS=(Property)withWhere.getOperand().get(0);
  assertThat(overlapsLHS.getScope(),is(""String_Node_Str""));
  assertThat(overlapsLHS.getPath(),is(""String_Node_Str""));
  assertThat(overlapsLHS.getSource(),is(nullValue()));
  assertThat(overlapsLHS.getDescription(),is(nullValue()));
  Property overlapsRHS=(Property)withWhere.getOperand().get(1);
  assertThat(overlapsRHS.getScope(),is(""String_Node_Str""));
  assertThat(overlapsRHS.getPath(),is(""String_Node_Str""));
  assertThat(overlapsRHS.getSource(),is(nullValue()));
  assertThat(overlapsRHS.getDescription(),is(nullValue()));
  GreaterOrEqual where=(GreaterOrEqual)query.getWhere();
  assertThat(where.getDescription(),is(nullValue()));
  assertThat(where.getOperand(),hasSize(2));
  DaysBetween whereLHS=(DaysBetween)where.getOperand().get(0);
  assertThat(whereLHS.getDescription(),is(nullValue()));
  assertThat(whereLHS.getOperand(),hasSize(2));
  Begin whereLHSBegin=(Begin)whereLHS.getOperand().get(0);
  assertThat(whereLHSBegin.getDescription(),is(nullValue()));
  Property whereLHSBeginProp=(Property)whereLHSBegin.getOperand();
  assertThat(whereLHSBeginProp.getScope(),is(""String_Node_Str""));
  assertThat(whereLHSBeginProp.getPath(),is(""String_Node_Str""));
  assertThat(whereLHSBeginProp.getSource(),is(nullValue()));
  assertThat(whereLHSBeginProp.getDescription(),is(nullValue()));
  End whereLHSEnd=(End)whereLHS.getOperand().get(1);
  assertThat(whereLHSEnd.getDescription(),is(nullValue()));
  Property whereLHSEndProp=(Property)whereLHSEnd.getOperand();
  assertThat(whereLHSEndProp.getScope(),is(""String_Node_Str""));
  assertThat(whereLHSEndProp.getPath(),is(""String_Node_Str""));
  assertThat(whereLHSEndProp.getSource(),is(nullValue()));
  assertThat(whereLHSEndProp.getDescription(),is(nullValue()));
  assertThat(where.getOperand().get(1),literalFor(120));
  ObjectExpression rtn=(ObjectExpression)query.getReturn();
  assertThat(rtn.getDescription(),is(nullValue()));
  assertThat(rtn.getProperty(),hasSize(2));
  PropertyExpression rtnP1=rtn.getProperty().get(0);
  assertThat(rtnP1.getName(),is(""String_Node_Str""));
  Property rtnP1Val=(Property)rtnP1.getValue();
  assertThat(rtnP1Val.getScope(),is(""String_Node_Str""));
  assertThat(rtnP1Val.getPath(),is(""String_Node_Str""));
  assertThat(rtnP1Val.getSource(),is(nullValue()));
  assertThat(rtnP1Val.getDescription(),is(nullValue()));
  PropertyExpression rtnP2=rtn.getProperty().get(1);
  assertThat(rtnP2.getName(),is(""String_Node_Str""));
  DaysBetween rtnP2Val=(DaysBetween)rtnP2.getValue();
  assertThat(rtnP2Val.getDescription(),is(nullValue()));
  assertThat(rtnP2Val.getOperand(),hasSize(2));
  Begin rtnP2ValBegin=(Begin)rtnP2Val.getOperand().get(0);
  assertThat(rtnP2ValBegin.getDescription(),is(nullValue()));
  Property rtnP2ValBeginProp=(Property)rtnP2ValBegin.getOperand();
  assertThat(rtnP2ValBeginProp.getScope(),is(""String_Node_Str""));
  assertThat(rtnP2ValBeginProp.getPath(),is(""String_Node_Str""));
  assertThat(rtnP2ValBeginProp.getSource(),is(nullValue()));
  assertThat(rtnP2ValBeginProp.getDescription(),is(nullValue()));
  End rtnP2ValEnd=(End)rtnP2Val.getOperand().get(1);
  assertThat(rtnP2ValEnd.getDescription(),is(nullValue()));
  Property rtnP2ValEndProp=(Property)rtnP2ValEnd.getOperand();
  assertThat(rtnP2ValEndProp.getScope(),is(""String_Node_Str""));
  assertThat(rtnP2ValEndProp.getPath(),is(""String_Node_Str""));
  assertThat(rtnP2ValEndProp.getSource(),is(nullValue()));
  assertThat(rtnP2ValEndProp.getDescription(),is(nullValue()));
  SortClause sort=query.getSort();
  assertThat(sort.getBy(),hasSize(1));
  ByExpression sortBy=(ByExpression)sort.getBy().get(0);
  Identifier id=(Identifier)sortBy.getExpression();
  assertThat(id.getIdentifier(),is(""String_Node_Str""));
  assertThat(id.getLibraryName(),is(nullValue()));
  assertThat(sortBy.getDirection(),is(SortDirection.DESC));
}"
11141,"/** 
 * <p> Note: c is known to be a letter (from 'A' to 'Z') at this poit.
 */
private void handleDeclaration(char c) throws XMLStreamException {
  String keyw=null;
  mCurrDepth=1;
  try {
    do {
      if (c == 'A') {
        keyw=checkDTDKeyword(""String_Node_Str"");
        if (keyw == null) {
          mCurrDeclaration=""String_Node_Str"";
          handleAttlistDecl();
          break;
        }
        keyw=""String_Node_Str"" + keyw;
      }
 else       if (c == 'E') {
        c=dtdNextFromCurr();
        if (c == 'N') {
          keyw=checkDTDKeyword(""String_Node_Str"");
          if (keyw == null) {
            mCurrDeclaration=""String_Node_Str"";
            handleEntityDecl(false);
            break;
          }
          keyw=""String_Node_Str"" + keyw;
        }
 else         if (c == 'L') {
          keyw=checkDTDKeyword(""String_Node_Str"");
          if (keyw == null) {
            mCurrDeclaration=""String_Node_Str"";
            handleElementDecl();
            break;
          }
          keyw=""String_Node_Str"" + keyw;
        }
 else {
          keyw=readDTDKeyword(""String_Node_Str"");
        }
      }
 else       if (c == 'N') {
        keyw=checkDTDKeyword(""String_Node_Str"");
        if (keyw == null) {
          mCurrDeclaration=""String_Node_Str"";
          handleNotationDecl();
          break;
        }
        keyw=""String_Node_Str"" + keyw;
      }
 else       if (c == 'T' && mCfgSupportDTDPP) {
        keyw=checkDTDKeyword(""String_Node_Str"");
        if (keyw == null) {
          mCurrDeclaration=""String_Node_Str"";
          handleTargetNsDecl();
          break;
        }
        keyw=""String_Node_Str"" + keyw;
      }
 else {
        keyw=readDTDKeyword(String.valueOf(c));
      }
      _reportBadDirective(keyw);
    }
 while (false);
    if (mInput.getScopeId() > 0) {
      handleGreedyEntityProblem(mInput);
    }
  }
  finally {
    mCurrDepth=0;
    mCurrDeclaration=null;
  }
}","/** 
 * <p> Note: c is known to be a letter (from 'A' to 'Z') at this poit.
 */
private void handleDeclaration(char c) throws XMLStreamException {
  String keyw=null;
  mCurrDepth=1;
  try {
    do {
      if (c == 'A') {
        keyw=checkDTDKeyword(""String_Node_Str"");
        if (keyw == null) {
          mCurrDeclaration=""String_Node_Str"";
          handleAttlistDecl();
          break;
        }
        keyw=""String_Node_Str"" + keyw;
      }
 else       if (c == 'E') {
        c=dtdNextFromCurr();
        if (c == 'N') {
          keyw=checkDTDKeyword(""String_Node_Str"");
          if (keyw == null) {
            mCurrDeclaration=""String_Node_Str"";
            handleEntityDecl(false);
            break;
          }
          keyw=""String_Node_Str"" + keyw;
        }
 else         if (c == 'L') {
          keyw=checkDTDKeyword(""String_Node_Str"");
          if (keyw == null) {
            mCurrDeclaration=""String_Node_Str"";
            handleElementDecl();
            break;
          }
          keyw=""String_Node_Str"" + keyw;
        }
 else {
          keyw=readDTDKeyword(""String_Node_Str"" + c);
        }
      }
 else       if (c == 'N') {
        keyw=checkDTDKeyword(""String_Node_Str"");
        if (keyw == null) {
          mCurrDeclaration=""String_Node_Str"";
          handleNotationDecl();
          break;
        }
        keyw=""String_Node_Str"" + keyw;
      }
 else       if (c == 'T' && mCfgSupportDTDPP) {
        keyw=checkDTDKeyword(""String_Node_Str"");
        if (keyw == null) {
          mCurrDeclaration=""String_Node_Str"";
          handleTargetNsDecl();
          break;
        }
        keyw=""String_Node_Str"" + keyw;
      }
 else {
        keyw=readDTDKeyword(String.valueOf(c));
      }
      _reportBadDirective(keyw);
    }
 while (false);
    if (mInput.getScopeId() > 0) {
      handleGreedyEntityProblem(mInput);
    }
  }
  finally {
    mCurrDepth=0;
    mCurrDeclaration=null;
  }
}"
11142,"@Override public void onClick(View view){
  new FilePickerBuilder(getActivity()).withColor(android.R.color.holo_blue_bright).withRequest(Request.FILE).withScopeType(Scope.ALL).withMimeType(FileType.JPEG).useMaterialActivity(true).launch(REQUEST_FILE);
}","@Override public void onClick(View view){
  new FilePickerBuilder(getActivity()).withColor(android.R.color.holo_blue_bright).withRequest(Request.FILE).withScope(Scope.ALL).withMimeType(MimeType.JPEG).useMaterialActivity(true).launch(REQUEST_FILE);
}"
11143,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_main,container,false);
  MaterialFlatButton filePickerActivity=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_activity);
  filePickerActivity.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePickerActivity=new Intent(getActivity(),FilePickerActivity.class);
      filePickerActivity.putExtra(FilePickerActivity.SCOPE_TYPE,Scope.ALL);
      filePickerActivity.putExtra(FilePickerActivity.REQUEST_CODE,Request.DIRECTORY);
      filePickerActivity.putExtra(FilePickerActivity.INTENT_EXTRA_FAB_COLOR_ID,android.R.color.holo_green_dark);
      startActivityForResult(filePickerActivity,REQUEST_DIRECTORY);
    }
  }
);
  MaterialFlatButton filePickerForFile=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_return_file_path);
  filePickerForFile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePicker=new Intent(getActivity(),FilePickerActivity.class);
      filePicker.putExtra(FilePickerActivity.SCOPE_TYPE,Scope.ALL);
      filePicker.putExtra(FilePickerActivity.REQUEST_CODE,FilePickerActivity.REQUEST_FILE);
      filePicker.putExtra(FilePickerActivity.INTENT_EXTRA_COLOR_ID,android.R.color.holo_orange_dark);
      startActivityForResult(filePicker,FilePickerActivity.REQUEST_FILE);
    }
  }
);
  MaterialFlatButton filePickerDialog=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_dialog);
  filePickerDialog.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePickerDialogIntent=new Intent(getActivity(),FilePickerActivity.class);
      filePickerDialogIntent.putExtra(FilePickerActivity.THEME_TYPE,ThemeType.DIALOG);
      filePickerDialogIntent.putExtra(FilePickerActivity.REQUEST_CODE,FilePickerActivity.REQUEST_FILE);
      startActivityForResult(filePickerDialogIntent,FilePickerActivity.REQUEST_FILE);
    }
  }
);
  MaterialFlatButton filePickerMimePng=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_mime_png);
  filePickerMimePng.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePicker=new Intent(getActivity(),FilePickerActivity.class);
      filePicker.putExtra(FilePickerActivity.SCOPE_TYPE,Scope.ALL);
      filePicker.putExtra(FilePickerActivity.REQUEST_CODE,FilePickerActivity.REQUEST_FILE);
      filePicker.putExtra(FilePickerActivity.INTENT_EXTRA_COLOR_ID,android.R.color.holo_green_dark);
      filePicker.putExtra(FilePickerActivity.MIME_TYPE,FileType.PNG);
      startActivityForResult(filePicker,FilePickerActivity.REQUEST_FILE);
    }
  }
);
  MaterialFlatButton newFilePicker=(MaterialFlatButton)rootView.findViewById(R.id.new_file_picker_activity);
  newFilePicker.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      new FilePickerBuilder(getActivity()).withColor(android.R.color.holo_blue_bright).withRequest(Request.FILE).withScopeType(Scope.ALL).withMimeType(FileType.JPEG).useMaterialActivity(true).launch(REQUEST_FILE);
    }
  }
);
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_main,container,false);
  MaterialFlatButton filePickerActivity=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_activity);
  filePickerActivity.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePickerActivity=new Intent(getActivity(),FilePickerActivity.class);
      filePickerActivity.putExtra(FilePickerActivity.SCOPE,Scope.ALL);
      filePickerActivity.putExtra(FilePickerActivity.REQUEST,Request.DIRECTORY);
      filePickerActivity.putExtra(FilePickerActivity.INTENT_EXTRA_FAB_COLOR_ID,android.R.color.holo_green_dark);
      startActivityForResult(filePickerActivity,REQUEST_DIRECTORY);
    }
  }
);
  MaterialFlatButton filePickerForFile=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_return_file_path);
  filePickerForFile.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePicker=new Intent(getActivity(),FilePickerActivity.class);
      filePicker.putExtra(FilePickerActivity.SCOPE,Scope.ALL);
      filePicker.putExtra(FilePickerActivity.REQUEST,Request.FILE);
      filePicker.putExtra(FilePickerActivity.INTENT_EXTRA_COLOR_ID,android.R.color.holo_orange_dark);
      startActivityForResult(filePicker,REQUEST_FILE);
    }
  }
);
  MaterialFlatButton filePickerDialog=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_dialog);
  filePickerDialog.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePickerDialogIntent=new Intent(getActivity(),FilePickerActivity.class);
      filePickerDialogIntent.putExtra(FilePickerActivity.THEME_TYPE,ThemeType.DIALOG);
      filePickerDialogIntent.putExtra(FilePickerActivity.REQUEST,Request.FILE);
      startActivityForResult(filePickerDialogIntent,REQUEST_FILE);
    }
  }
);
  MaterialFlatButton filePickerMimePng=(MaterialFlatButton)rootView.findViewById(R.id.file_picker_mime_png);
  filePickerMimePng.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent filePicker=new Intent(getActivity(),FilePickerActivity.class);
      filePicker.putExtra(FilePickerActivity.SCOPE,Scope.ALL);
      filePicker.putExtra(FilePickerActivity.REQUEST,Request.FILE);
      filePicker.putExtra(FilePickerActivity.INTENT_EXTRA_COLOR_ID,android.R.color.holo_green_dark);
      filePicker.putExtra(FilePickerActivity.MIME_TYPE,MimeType.PNG);
      startActivityForResult(filePicker,REQUEST_FILE);
    }
  }
);
  MaterialFlatButton newFilePicker=(MaterialFlatButton)rootView.findViewById(R.id.new_file_picker_activity);
  newFilePicker.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      new FilePickerBuilder(getActivity()).withColor(android.R.color.holo_blue_bright).withRequest(Request.FILE).withScope(Scope.ALL).withMimeType(MimeType.JPEG).useMaterialActivity(true).launch(REQUEST_FILE);
    }
  }
);
  return rootView;
}"
11144,"@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQUEST_DIRECTORY && resultCode == RESULT_OK) {
    Toast.makeText(getActivity(),""String_Node_Str"" + data.getStringExtra(FilePickerActivity.FILE_EXTRA_DATA_PATH),Toast.LENGTH_LONG).show();
  }
 else   if (requestCode == REQUEST_FILE && resultCode == RESULT_OK) {
    Toast.makeText(getActivity(),""String_Node_Str"" + data.getStringExtra(FilePickerActivity.FILE_EXTRA_DATA_PATH),Toast.LENGTH_LONG).show();
  }
  super.onActivityResult(requestCode,resultCode,data);
}","@Override public void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if ((requestCode == REQUEST_DIRECTORY) && (resultCode == RESULT_OK)) {
    Toast.makeText(getActivity(),""String_Node_Str"" + data.getStringExtra(FilePickerActivity.FILE_EXTRA_DATA_PATH),Toast.LENGTH_LONG).show();
  }
 else   if ((requestCode == REQUEST_FILE) && (resultCode == RESULT_OK)) {
    Toast.makeText(getActivity(),""String_Node_Str"" + data.getStringExtra(FilePickerActivity.FILE_EXTRA_DATA_PATH),Toast.LENGTH_LONG).show();
  }
}"
11145,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mContext=this;
  setContentView(R.layout.material_file_picker_activity_layout);
  recyclerView=(RecyclerView)findViewById(R.id.file_picker_recycler_view);
  toolbar=(Toolbar)findViewById(R.id.file_picker_base_toolbar);
  fab=(FloatingActionButton)findViewById(R.id.file_picker_floating_action_button);
  fab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  isFabShowing=true;
  areButtonsShowing=false;
  Object rawMimeTypeParameter=getIntent().getExtras().get(MIME_TYPE);
  if (rawMimeTypeParameter instanceof String) {
    mimeType=(String)rawMimeTypeParameter;
  }
 else   if (rawMimeTypeParameter instanceof FileType) {
    mimeType=((FileType)rawMimeTypeParameter).getMimeType();
  }
 else {
    mimeType=null;
  }
  setUpAnimations();
  Intent givenIntent=getIntent();
  scopeType=(Scope)givenIntent.getSerializableExtra(SCOPE_TYPE);
  if (scopeType == null) {
    scopeType=Scope.ALL;
  }
  requestCode=(Request)givenIntent.getSerializableExtra(REQUEST_CODE);
  colorId=givenIntent.getIntExtra(INTENT_EXTRA_COLOR_ID,android.R.color.holo_blue_light);
  drawableId=givenIntent.getIntExtra(INTENT_EXTRA_DRAWABLE_ID,-1);
  fabColorId=givenIntent.getIntExtra(INTENT_EXTRA_FAB_COLOR_ID,-1);
  mLinearLayoutManager=new LinearLayoutManager(this);
  recyclerView.setItemAnimator(new DefaultItemAnimator());
  recyclerView.setLayoutManager(mLinearLayoutManager);
  recyclerView.setHasFixedSize(true);
  adapter=new FileRecyclerViewAdapter(this,new File[0],scopeType,callback);
  recyclerView.setAdapter(adapter);
  recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrollStateChanged(    RecyclerView recyclerView,    int newState){
      super.onScrollStateChanged(recyclerView,newState);
    }
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      int firstVisibleItem=mLinearLayoutManager.findFirstVisibleItemPosition();
      if (Math.abs(dy) >= 5) {
        if (dy > 0) {
          toggleButton(false);
        }
 else         if (dy < 0) {
          toggleButton(true);
        }
        if (areButtonsShowing) {
          hideButtons();
          adapter.setSelectedPosition(-1);
          mLastFirstVisibleItem=firstVisibleItem;
        }
 else         if (firstVisibleItem > adapter.getSelectedPosition()) {
          hideButtons();
          adapter.setSelectedPosition(-1);
        }
      }
 else {
        mLastFirstVisibleItem=firstVisibleItem;
      }
      super.onScrolled(recyclerView,dx,dy);
    }
  }
);
  initializeViews();
  setHeaderBackground(colorId,drawableId);
  if (Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
    int permissionCheck=ContextCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE);
    if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
      if (ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.READ_EXTERNAL_STORAGE)) {
        new MaterialDialog.Builder(this).title(R.string.file_picker_permission_rationale_dialog_title).content(R.string.file_picker_permission_rationale_dialog_content).positiveText(R.string.file_picker_ok).negativeText(R.string.file_picker_cancel).callback(new MaterialDialog.ButtonCallback(){
          @Override public void onPositive(          MaterialDialog dialog){
            ActivityCompat.requestPermissions(FilePicker.this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
          }
          @Override public void onNegative(          MaterialDialog dialog){
            setResult(RESULT_CANCELED);
            finish();
          }
        }
).show();
      }
 else {
        ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
      }
    }
  }
 else {
    init();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mContext=this;
  setContentView(R.layout.material_file_picker_activity_layout);
  recyclerView=(RecyclerView)findViewById(R.id.file_picker_recycler_view);
  toolbar=(Toolbar)findViewById(R.id.file_picker_base_toolbar);
  fab=(FloatingActionButton)findViewById(R.id.file_picker_floating_action_button);
  fab.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  isFabShowing=true;
  areButtonsShowing=false;
  Object rawMimeTypeParameter=getIntent().getExtras().get(MIME_TYPE);
  if (rawMimeTypeParameter instanceof String) {
    mimeType=(String)rawMimeTypeParameter;
  }
 else   if (rawMimeTypeParameter instanceof MimeType) {
    mimeType=((MimeType)rawMimeTypeParameter).getMimeType();
  }
 else {
    mimeType=null;
  }
  setUpAnimations();
  Intent givenIntent=getIntent();
  scopeType=(Scope)givenIntent.getSerializableExtra(SCOPE);
  if (scopeType == null) {
    scopeType=Scope.ALL;
  }
  requestCode=(Request)givenIntent.getSerializableExtra(REQUEST);
  colorId=givenIntent.getIntExtra(INTENT_EXTRA_COLOR_ID,android.R.color.holo_blue_light);
  drawableId=givenIntent.getIntExtra(INTENT_EXTRA_DRAWABLE_ID,-1);
  fabColorId=givenIntent.getIntExtra(INTENT_EXTRA_FAB_COLOR_ID,-1);
  mLinearLayoutManager=new LinearLayoutManager(this);
  recyclerView.setItemAnimator(new DefaultItemAnimator());
  recyclerView.setLayoutManager(mLinearLayoutManager);
  recyclerView.setHasFixedSize(true);
  adapter=new FileRecyclerViewAdapter(this,new File[0],scopeType,callback);
  recyclerView.setAdapter(adapter);
  recyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrollStateChanged(    RecyclerView recyclerView,    int newState){
      super.onScrollStateChanged(recyclerView,newState);
    }
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      int firstVisibleItem=mLinearLayoutManager.findFirstVisibleItemPosition();
      if (Math.abs(dy) >= 5) {
        if (dy > 0) {
          toggleButton(false);
        }
 else         if (dy < 0) {
          toggleButton(true);
        }
        if (areButtonsShowing) {
          hideButtons();
          adapter.setSelectedPosition(-1);
          mLastFirstVisibleItem=firstVisibleItem;
        }
 else         if (firstVisibleItem > adapter.getSelectedPosition()) {
          hideButtons();
          adapter.setSelectedPosition(-1);
        }
      }
 else {
        mLastFirstVisibleItem=firstVisibleItem;
      }
      super.onScrolled(recyclerView,dx,dy);
    }
  }
);
  initializeViews();
  setHeaderBackground(colorId,drawableId);
  if (Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
    int permissionCheck=ContextCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE);
    if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
      if (ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.READ_EXTERNAL_STORAGE)) {
        new MaterialDialog.Builder(this).title(R.string.file_picker_permission_rationale_dialog_title).content(R.string.file_picker_permission_rationale_dialog_content).positiveText(R.string.file_picker_ok).negativeText(R.string.file_picker_cancel).callback(new MaterialDialog.ButtonCallback(){
          @Override public void onPositive(          MaterialDialog dialog){
            ActivityCompat.requestPermissions(FilePicker.this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
          }
          @Override public void onNegative(          MaterialDialog dialog){
            setResult(RESULT_CANCELED);
            finish();
          }
        }
).show();
      }
 else {
        ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
      }
    }
  }
 else {
    init();
  }
}"
11146,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mContext=this;
  themeType=(ThemeType)getIntent().getSerializableExtra(THEME_TYPE);
  if (themeType == null) {
    themeType=ThemeType.ACTIVITY;
  }
  setThemeType(themeType);
  areButtonsShowing=false;
  try {
    getActionBar().setDisplayHomeAsUpEnabled(true);
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
  }
  Object rawMimeTypeParameter=getIntent().getExtras().get(MIME_TYPE);
  if (rawMimeTypeParameter instanceof String) {
    mimeType=(String)rawMimeTypeParameter;
  }
 else   if (rawMimeTypeParameter instanceof FileType) {
    mimeType=((FileType)rawMimeTypeParameter).getMimeType();
  }
 else {
    mimeType=null;
  }
  setUpAnimations();
  Intent givenIntent=getIntent();
  scopeType=(Scope)givenIntent.getSerializableExtra(SCOPE_TYPE);
  if (scopeType == null) {
    scopeType=Scope.ALL;
  }
  requestCode=(Request)givenIntent.getSerializableExtra(REQUEST_CODE);
  colorId=givenIntent.getIntExtra(INTENT_EXTRA_COLOR_ID,android.R.color.holo_blue_light);
  drawableId=givenIntent.getIntExtra(INTENT_EXTRA_DRAWABLE_ID,-1);
  fabColorId=givenIntent.getIntExtra(INTENT_EXTRA_FAB_COLOR_ID,-1);
  setContentView(R.layout.file_picker_activity_layout);
  listView=(ListView)findViewById(android.R.id.list);
  listView.setOnScrollListener(new AbsListView.OnScrollListener(){
    @Override public void onScrollStateChanged(    AbsListView view,    int scrollState){
    }
    @Override public void onScroll(    AbsListView view,    int firstVisibleItem,    int visibleItemCount,    int totalItemCount){
      if (areButtonsShowing) {
        if (Math.abs(firstVisibleItem - mLastFirstVisibleItem) >= 3) {
          hideButtons();
          adapter.setSelectedPosition(-1);
          mLastFirstVisibleItem=firstVisibleItem;
        }
 else         if (firstVisibleItem > adapter.getSelectedPosition()) {
          hideButtons();
          adapter.setSelectedPosition(-1);
        }
      }
 else {
        mLastFirstVisibleItem=firstVisibleItem;
      }
    }
  }
);
  listHeaderView=getLayoutInflater().inflate(R.layout.file_list_header_view,null);
  listHeaderView.setFocusable(false);
  listHeaderView.setClickable(false);
  listHeaderView.setOnClickListener(null);
  listHeaderView.setActivated(false);
  initializeViews();
  setHeaderBackground(colorId,drawableId);
  if (Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
    int permissionCheck=ContextCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE);
    if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
      if (ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.READ_EXTERNAL_STORAGE)) {
        new MaterialDialog.Builder(this).title(R.string.file_picker_permission_rationale_dialog_title).content(R.string.file_picker_permission_rationale_dialog_content).positiveText(R.string.file_picker_ok).negativeText(R.string.file_picker_cancel).onPositive(new MaterialDialog.SingleButtonCallback(){
          @Override public void onClick(          @NonNull MaterialDialog dialog,          @NonNull DialogAction which){
            ActivityCompat.requestPermissions(FilePickerActivity.this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
          }
        }
).onNegative(new MaterialDialog.SingleButtonCallback(){
          @Override public void onClick(          @NonNull MaterialDialog dialog,          @NonNull DialogAction which){
            setResult(RESULT_CANCELED);
            finish();
          }
        }
).show();
      }
 else {
        ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
      }
    }
 else {
      init();
    }
  }
 else {
    init();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mContext=this;
  themeType=(ThemeType)getIntent().getSerializableExtra(THEME_TYPE);
  if (themeType == null) {
    themeType=ThemeType.ACTIVITY;
  }
  setThemeType(themeType);
  areButtonsShowing=false;
  try {
    getActionBar().setDisplayHomeAsUpEnabled(true);
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
  }
  Object rawMimeTypeParameter=getIntent().getExtras().get(MIME_TYPE);
  if (rawMimeTypeParameter instanceof String) {
    mimeType=(String)rawMimeTypeParameter;
  }
 else   if (rawMimeTypeParameter instanceof MimeType) {
    mimeType=((MimeType)rawMimeTypeParameter).getMimeType();
  }
 else {
    mimeType=null;
  }
  setUpAnimations();
  Intent givenIntent=getIntent();
  scopeType=(Scope)givenIntent.getSerializableExtra(SCOPE);
  if (scopeType == null) {
    scopeType=Scope.ALL;
  }
  requestCode=(Request)givenIntent.getSerializableExtra(REQUEST);
  colorId=givenIntent.getIntExtra(INTENT_EXTRA_COLOR_ID,android.R.color.holo_blue_light);
  drawableId=givenIntent.getIntExtra(INTENT_EXTRA_DRAWABLE_ID,-1);
  fabColorId=givenIntent.getIntExtra(INTENT_EXTRA_FAB_COLOR_ID,-1);
  setContentView(R.layout.file_picker_activity_layout);
  listView=(ListView)findViewById(android.R.id.list);
  listView.setOnScrollListener(new AbsListView.OnScrollListener(){
    @Override public void onScrollStateChanged(    AbsListView view,    int scrollState){
    }
    @Override public void onScroll(    AbsListView view,    int firstVisibleItem,    int visibleItemCount,    int totalItemCount){
      if (areButtonsShowing) {
        if (Math.abs(firstVisibleItem - mLastFirstVisibleItem) >= 3) {
          hideButtons();
          adapter.setSelectedPosition(-1);
          mLastFirstVisibleItem=firstVisibleItem;
        }
 else         if (firstVisibleItem > adapter.getSelectedPosition()) {
          hideButtons();
          adapter.setSelectedPosition(-1);
        }
      }
 else {
        mLastFirstVisibleItem=firstVisibleItem;
      }
    }
  }
);
  listHeaderView=getLayoutInflater().inflate(R.layout.file_list_header_view,null);
  listHeaderView.setFocusable(false);
  listHeaderView.setClickable(false);
  listHeaderView.setOnClickListener(null);
  listHeaderView.setActivated(false);
  initializeViews();
  setHeaderBackground(colorId,drawableId);
  if (Build.VERSION.SDK_INT == Build.VERSION_CODES.M) {
    int permissionCheck=ContextCompat.checkSelfPermission(this,Manifest.permission.READ_EXTERNAL_STORAGE);
    if (permissionCheck != PackageManager.PERMISSION_GRANTED) {
      if (ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.READ_EXTERNAL_STORAGE)) {
        new MaterialDialog.Builder(this).title(R.string.file_picker_permission_rationale_dialog_title).content(R.string.file_picker_permission_rationale_dialog_content).positiveText(R.string.file_picker_ok).negativeText(R.string.file_picker_cancel).onPositive(new MaterialDialog.SingleButtonCallback(){
          @Override public void onClick(          @NonNull MaterialDialog dialog,          @NonNull DialogAction which){
            ActivityCompat.requestPermissions(FilePickerActivity.this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
          }
        }
).onNegative(new MaterialDialog.SingleButtonCallback(){
          @Override public void onClick(          @NonNull MaterialDialog dialog,          @NonNull DialogAction which){
            setResult(RESULT_CANCELED);
            finish();
          }
        }
).show();
      }
 else {
        ActivityCompat.requestPermissions(this,new String[]{Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.WRITE_EXTERNAL_STORAGE},REQUEST_FOR_READ_EXTERNAL_STORAGE);
      }
    }
 else {
      init();
    }
  }
 else {
    init();
  }
}"
11147,"/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  directoryTitle=(TextView)findViewById(R.id.file_directory_title);
  addButton=(MaterialFloatingActionButton)findViewById(R.id.file_picker_add_button);
  addButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (fabColorId != -1) {
    addButton.setButtonColor(getResources().getColor(fabColorId));
  }
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == Request.DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_select_directory_message,Snackbar.LENGTH_SHORT).show();
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
        }
 else {
          if (mimeType != null && !mimeType.equalsIgnoreCase(FileType.NONE.getMimeType())) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              Snackbar.make(getWindow().getDecorView(),String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension),Snackbar.LENGTH_SHORT).show();
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        directoryTitle.setText(curDirectory.getName());
        new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          ActivityNotFoundException e) {
            Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_file_type_handler,Snackbar.LENGTH_SHORT).show();
          }
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_read_type,Snackbar.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  buttonContainer.setVisibility(View.INVISIBLE);
  header=(RelativeLayout)findViewById(R.id.header_container);
}","/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  directoryTitle=(TextView)findViewById(R.id.file_directory_title);
  addButton=(MaterialFloatingActionButton)findViewById(R.id.file_picker_add_button);
  addButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (fabColorId != -1) {
    addButton.setButtonColor(getResources().getColor(fabColorId));
  }
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == Request.DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_select_directory_message,Snackbar.LENGTH_SHORT).show();
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
        }
 else {
          if (mimeType != null && !mimeType.equalsIgnoreCase(MimeType.NONE.getMimeType())) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              Snackbar.make(getWindow().getDecorView(),String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension),Snackbar.LENGTH_SHORT).show();
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        directoryTitle.setText(curDirectory.getName());
        new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          ActivityNotFoundException e) {
            Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_file_type_handler,Snackbar.LENGTH_SHORT).show();
          }
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_read_type,Snackbar.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  buttonContainer.setVisibility(View.INVISIBLE);
  header=(RelativeLayout)findViewById(R.id.header_container);
}"
11148,"/** 
 * Set the scopetype of the file picker.
 * @param type scope type. Can be DIRECTORIES or ALL.
 * @return the current builder instance.
 */
public FilePickerBuilder withScopeType(Scope type){
  mScope=type;
  return this;
}","@Deprecated public FilePickerBuilder withScopeType(Scope type){
  mScope=type;
  return this;
}"
11149,"/** 
 * Set the file mime type. The will require the returned file type to match the mime type.
 * @param type the mime type.
 * @return current instance of the builder.
 */
public FilePickerBuilder withMimeType(FileType type){
  mimeType=type;
  return this;
}","/** 
 * Set the file mime type. The will require the returned file type to match the mime type.
 * @param type the mime type.
 * @return current instance of the builder.
 */
public FilePickerBuilder withMimeType(MimeType type){
  mimeType=type;
  return this;
}"
11150,"/** 
 * Build the current intent.
 * @return a filepicker intent.
 */
public Intent build(){
  Intent filePicker=new Intent(mContext,useMaterial ? FilePicker.class : FilePickerActivity.class);
  filePicker.putExtra(FilePicker.SCOPE_TYPE,mScope);
  filePicker.putExtra(FilePicker.REQUEST_CODE,requestCode);
  filePicker.putExtra(FilePicker.INTENT_EXTRA_COLOR_ID,color);
  filePicker.putExtra(FilePicker.MIME_TYPE,mimeType);
  return filePicker;
}","/** 
 * Build the current intent.
 * @return a filepicker intent.
 */
public Intent build(){
  Intent filePicker=new Intent(mContext,useMaterial ? FilePicker.class : FilePickerActivity.class);
  filePicker.putExtra(FilePicker.SCOPE,mScope);
  filePicker.putExtra(FilePicker.REQUEST,requestCode);
  filePicker.putExtra(FilePicker.INTENT_EXTRA_COLOR_ID,color);
  filePicker.putExtra(FilePicker.MIME_TYPE,mimeType);
  return filePicker;
}"
11151,"/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == Request.DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_select_directory_message,Snackbar.LENGTH_SHORT).show();
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePicker.this).execute(curDirectory);
        }
 else {
          if (mimeType != null) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              Snackbar.make(getWindow().getDecorView(),String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension),Snackbar.LENGTH_SHORT).show();
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        toolbar.setTitle(curDirectory.getName());
        new UpdateFilesTask(FilePicker.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          ActivityNotFoundException e) {
            Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_file_type_handler,Snackbar.LENGTH_SHORT).show();
          }
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_read_type,Snackbar.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  buttonContainer.setVisibility(View.INVISIBLE);
}","/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == Request.DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_select_directory_message,Snackbar.LENGTH_SHORT).show();
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePicker.this).execute(curDirectory);
        }
 else {
          if (!TextUtils.isEmpty(mimeType)) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              Snackbar.make(getWindow().getDecorView(),String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension),Snackbar.LENGTH_SHORT).show();
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        toolbar.setTitle(curDirectory.getName());
        new UpdateFilesTask(FilePicker.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          ActivityNotFoundException e) {
            Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_file_type_handler,Snackbar.LENGTH_SHORT).show();
          }
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_read_type,Snackbar.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  buttonContainer.setVisibility(View.INVISIBLE);
}"
11152,"/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  directoryTitle=(TextView)findViewById(R.id.file_directory_title);
  addButton=(MaterialFloatingActionButton)findViewById(R.id.file_picker_add_button);
  addButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (fabColorId != -1) {
    addButton.setButtonColor(getResources().getColor(fabColorId));
  }
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == Request.DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_select_directory_message,Snackbar.LENGTH_SHORT).show();
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
        }
 else {
          if (mimeType != null && !mimeType.equalsIgnoreCase(MimeType.NONE.getMimeType())) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              Snackbar.make(getWindow().getDecorView(),String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension),Snackbar.LENGTH_SHORT).show();
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        directoryTitle.setText(curDirectory.getName());
        new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          ActivityNotFoundException e) {
            Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_file_type_handler,Snackbar.LENGTH_SHORT).show();
          }
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_read_type,Snackbar.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  buttonContainer.setVisibility(View.INVISIBLE);
  header=(RelativeLayout)findViewById(R.id.header_container);
}","/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  directoryTitle=(TextView)findViewById(R.id.file_directory_title);
  addButton=(MaterialFloatingActionButton)findViewById(R.id.file_picker_add_button);
  addButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (fabColorId != -1) {
    addButton.setButtonColor(getResources().getColor(fabColorId));
  }
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == Request.DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_select_directory_message,Snackbar.LENGTH_SHORT).show();
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
        }
 else {
          if (!TextUtils.isEmpty(mimeType)) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              Snackbar.make(getWindow().getDecorView(),String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension),Snackbar.LENGTH_SHORT).show();
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        directoryTitle.setText(curDirectory.getName());
        new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          ActivityNotFoundException e) {
            Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_file_type_handler,Snackbar.LENGTH_SHORT).show();
          }
        }
 else {
          Snackbar.make(getWindow().getDecorView(),R.string.file_picker_snackbar_no_read_type,Snackbar.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  buttonContainer.setVisibility(View.INVISIBLE);
  header=(RelativeLayout)findViewById(R.id.header_container);
}"
11153,"/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  directoryTitle=(TextView)findViewById(R.id.file_directory_title);
  addButton=(MaterialFloatingActionButton)findViewById(R.id.file_picker_add_button);
  addButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (fabColorId != -1) {
    addButton.setButtonColor(getResources().getColor(fabColorId));
  }
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == REQUEST_DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(R.string.file_picker_snackbar_select_directory_message).duration(1500));
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
        }
 else {
          if (mimeType != null) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension)).duration(1500));
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        directoryTitle.setText(curDirectory.getName());
        new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(android.content.Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          android.content.ActivityNotFoundException e) {
            SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(R.string.file_picker_snackbar_no_file_type_handler));
          }
        }
 else {
          SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(R.string.file_picker_snackbar_no_read_type));
        }
      }
    }
  }
);
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  buttonContainer.setVisibility(View.INVISIBLE);
  header=(RelativeLayout)findViewById(R.id.header_container);
}","/** 
 * Initializes all the views in the layout of the activity.
 */
private void initializeViews(){
  directoryTitle=(TextView)findViewById(R.id.file_directory_title);
  addButton=(MaterialFloatingActionButton)findViewById(R.id.file_picker_add_button);
  addButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      NameFileDialog nfd=NameFileDialog.newInstance();
      nfd.show(getFragmentManager(),""String_Node_Str"");
    }
  }
);
  if (fabColorId != -1) {
    addButton.setButtonColor(getResources().getColor(fabColorId));
  }
  selectButton=(Button)findViewById(R.id.select_button);
  selectButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (requestCode == REQUEST_DIRECTORY) {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          data=new Intent();
          data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
          setResult(RESULT_OK,data);
          finish();
        }
 else {
          SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(R.string.file_picker_snackbar_select_directory_message).duration(1500));
        }
      }
 else {
        if (currentFile.isDirectory()) {
          curDirectory=currentFile;
          new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
        }
 else {
          if (mimeType != null && !mimeType.equalsIgnoreCase(FileType.NONE.getMimeType())) {
            MimeTypeMap mimeTypeMap=MimeTypeMap.getSingleton();
            String requiredExtension=""String_Node_Str"" + mimeTypeMap.getExtensionFromMimeType(mimeType);
            if (requiredExtension.equalsIgnoreCase(fileExt(currentFile.toString()))) {
              data=new Intent();
              data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
              setResult(RESULT_OK,data);
              finish();
            }
 else {
              SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(String.format(getString(R.string.file_picker_snackbar_select_file_ext_message),requiredExtension)).duration(1500));
            }
          }
 else {
            data=new Intent();
            data.putExtra(FILE_EXTRA_DATA_PATH,currentFile.getAbsolutePath());
            setResult(RESULT_OK,data);
            finish();
          }
        }
      }
    }
  }
);
  openButton=(Button)findViewById(R.id.open_button);
  openButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (currentFile.isDirectory()) {
        curDirectory=currentFile;
        directoryTitle.setText(curDirectory.getName());
        new UpdateFilesTask(FilePickerActivity.this).execute(curDirectory);
      }
 else {
        Intent newIntent=new Intent(android.content.Intent.ACTION_VIEW);
        String file=currentFile.toString();
        if (file != null) {
          newIntent.setDataAndType(Uri.fromFile(currentFile),mimeType);
          newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivity(newIntent);
          }
 catch (          android.content.ActivityNotFoundException e) {
            SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(R.string.file_picker_snackbar_no_file_type_handler));
          }
        }
 else {
          SnackbarManager.show(Snackbar.with(FilePickerActivity.this).text(R.string.file_picker_snackbar_no_read_type));
        }
      }
    }
  }
);
  buttonContainer=(LinearLayout)findViewById(R.id.button_container);
  buttonContainer.setVisibility(View.INVISIBLE);
  header=(RelativeLayout)findViewById(R.id.header_container);
}"
11154,"/** 
 * Initializes the animations used in this activity.
 */
private void setUpAnimations(){
  slideUp=AnimationUtils.loadAnimation(this,R.anim.slide_up);
  slideDown=AnimationUtils.loadAnimation(this,R.anim.slide_down);
  rotateIn=AnimationUtils.loadAnimation(this,R.anim.rotate_and_fade_in);
  rotateOut=AnimationUtils.loadAnimation(this,R.anim.rotate_and_fade_out);
}","/** 
 * Initializes the animations used in this activity.
 */
private void setUpAnimations(){
  slideUp=AnimationUtils.loadAnimation(this,com.devpaul.filepickerlibrary.R.anim.slide_up);
  slideDown=AnimationUtils.loadAnimation(this,com.devpaul.filepickerlibrary.R.anim.slide_down);
  rotateIn=AnimationUtils.loadAnimation(this,com.devpaul.filepickerlibrary.R.anim.rotate_and_fade_in);
  rotateOut=AnimationUtils.loadAnimation(this,com.devpaul.filepickerlibrary.R.anim.rotate_and_fade_out);
}"
11155,"@Override public Object getItem(int i){
  return files[i];
}","@Override public Object getItem(int i){
  return fileList.get(i);
}"
11156,"public FileListAdapter(Context context,File[] fileArray,FileScopeType type){
  this.mContext=context;
  this.files=fileArray;
  this.inflater=LayoutInflater.from(mContext);
  this.mFileType=type;
  selectedPos=-1;
  folderDrawable=mContext.getResources().getDrawable(R.drawable.ic_folder);
}","public FileListAdapter(Context context,File[] fileArray,FileScopeType type){
  this.mContext=context;
  this.fileList=new ArrayList<File>(Arrays.asList(fileArray));
  this.inflater=LayoutInflater.from(mContext);
  this.mFileType=type;
  selectedPos=-1;
  folderDrawable=mContext.getResources().getDrawable(R.drawable.ic_folder);
  if (mFileType == FileScopeType.DIRECTORIES) {
    for (int i=0; i < fileList.size(); i++) {
      String extension=fileExt(fileList.get(i).getPath());
      if (extension != null) {
        Log.d(""String_Node_Str"",""String_Node_Str"" + extension);
        fileList.remove(i);
      }
    }
  }
}"
11157,"@Override public int getCount(){
  return files.length;
}","@Override public int getCount(){
  return fileList.size();
}"
11158,"@Override public View getView(int i,View view,ViewGroup viewGroup){
  if (view == null) {
    view=inflater.inflate(R.layout.file_list_item,null);
  }
  if (selectedPos == i) {
    view.setBackgroundColor(mContext.getResources().getColor(R.color.card_detailing));
  }
 else {
    view.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.card));
  }
  TextView fileTitle=(TextView)view.findViewById(R.id.file_item_file_name);
  TextView fileInfo=(TextView)view.findViewById(R.id.file_item_file_info);
  ImageView fileImage=(ImageView)view.findViewById(R.id.file_item_image_view);
  if (mFileType == FileScopeType.ALL) {
    fileTitle.setText(files[i].getName());
    fileInfo.setText(""String_Node_Str"" + files[i].length() + ""String_Node_Str"");
    String fileExt=fileExt(files[i].toString());
    if (files[i].isDirectory()) {
      fileImage.setBackgroundDrawable(folderDrawable);
    }
    if (fileExt != null) {
      if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_doc_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_docx_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_xls_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_xlsx_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_xml_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_html_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_pdf_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_txt_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        new BitmapWorkerTask(fileImage,Bitmap.CompressFormat.JPEG).execute(files[i]);
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        new BitmapWorkerTask(fileImage,Bitmap.CompressFormat.JPEG).execute(files[i]);
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        new BitmapWorkerTask(fileImage,Bitmap.CompressFormat.PNG).execute(files[i]);
      }
 else {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_default_file));
      }
    }
  }
 else   if (mFileType == FileScopeType.DIRECTORIES) {
    if (files[i].isDirectory()) {
      fileImage.setBackgroundDrawable(folderDrawable);
      fileTitle.setText(files[i].getName());
      fileInfo.setText(""String_Node_Str"" + files[i].length() + ""String_Node_Str"");
    }
  }
  return view;
}","@Override public View getView(int i,View view,ViewGroup viewGroup){
  if (view == null) {
    view=inflater.inflate(R.layout.file_list_item,null);
  }
  if (selectedPos == i) {
    view.setBackgroundColor(mContext.getResources().getColor(R.color.card_detailing));
  }
 else {
    view.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.card));
  }
  TextView fileTitle=(TextView)view.findViewById(R.id.file_item_file_name);
  TextView fileInfo=(TextView)view.findViewById(R.id.file_item_file_info);
  ImageView fileImage=(ImageView)view.findViewById(R.id.file_item_image_view);
  if (mFileType == FileScopeType.ALL) {
    fileTitle.setText(fileList.get(i).getName());
    fileInfo.setText(""String_Node_Str"" + fileList.get(i).length() + ""String_Node_Str"");
    String fileExt=fileExt(fileList.get(i).toString());
    if (fileList.get(i).isDirectory()) {
      fileImage.setBackgroundDrawable(folderDrawable);
    }
    if (fileExt != null) {
      if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_doc_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_docx_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_xls_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_xlsx_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_xml_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_html_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_pdf_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_txt_file));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        new BitmapWorkerTask(fileImage,Bitmap.CompressFormat.JPEG).execute(fileList.get(i));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        new BitmapWorkerTask(fileImage,Bitmap.CompressFormat.JPEG).execute(fileList.get(i));
      }
 else       if (fileExt.equalsIgnoreCase(""String_Node_Str"")) {
        new BitmapWorkerTask(fileImage,Bitmap.CompressFormat.PNG).execute(fileList.get(i));
      }
 else {
        fileImage.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.ic_default_file));
      }
    }
  }
 else   if (mFileType == FileScopeType.DIRECTORIES) {
    if (fileList.get(i).isDirectory()) {
      fileImage.setBackgroundDrawable(folderDrawable);
      fileTitle.setText(fileList.get(i).getName());
      fileInfo.setText(""String_Node_Str"" + fileList.get(i).length() + ""String_Node_Str"");
    }
  }
  return view;
}"
11159,"/** 
 * Basic Constructor.
 * @param indexMetadata     Index metadata information .
 * @param createIfNotExists Condition of creation of the index.
 * @param session           Session that the Index affect.
 * @throws ExecutionException
 */
public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=indexMetadata.getName().getTableName().getName();
  this.keyspace=indexMetadata.getName().getTableName().getCatalogName().getName();
  if (keyspace != null) {
    this.keyspaceIncluded=true;
  }
  this.name=Utils.toCaseSensitive(indexMetadata.getName().getName());
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    try {
      columnForIndex=indexMetadata.getName().getName();
      String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
      String table=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
      session.execute(""String_Node_Str"" + catalog + '.'+ table+ ""String_Node_Str""+ Utils.toCaseSensitive(columnForIndex)+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}","/** 
 * Basic Constructor.
 * @param indexMetadata     Index metadata information .
 * @param createIfNotExists Condition of creation of the index.
 * @param session           Session that the Index affect.
 * @throws ExecutionException
 */
public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=indexMetadata.getName().getTableName().getName();
  this.keyspace=indexMetadata.getName().getTableName().getCatalogName().getName();
  if (keyspace != null) {
    this.keyspaceIncluded=true;
  }
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    try {
      columnForIndex=indexMetadata.getName().getName();
      String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
      String table=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
      session.execute(""String_Node_Str"" + catalog + '.'+ table+ ""String_Node_Str""+ Utils.toCaseSensitive(columnForIndex)+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}"
11160,"/** 
 * Get the query in a String in CQL language.
 * @return String with the query
 */
@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (type == (IndexType.FULL_TEXT)) {
    options=generateLuceneOptions();
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (createIfNotExists) {
    sb.append(""String_Node_Str"");
  }
  if (name != null) {
    sb.append((getIndexName())).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (keyspaceIncluded) {
    sb.append(Utils.toCaseSensitive(keyspace)).append(""String_Node_Str"");
  }
  sb.append(Utils.toCaseSensitive(tableName));
  sb.append(""String_Node_Str"");
  if (type != IndexType.FULL_TEXT) {
    int i=0;
    for (    Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
      if (i != 0) {
        sb.append(""String_Node_Str"");
      }
      sb.append(Utils.toCaseSensitive(entry.getValue().getName().getName()));
      i=1;
    }
  }
 else {
    sb.append(Utils.toCaseSensitive(columnForIndex));
  }
  sb.append(""String_Node_Str"");
  if (usingClass != null) {
    sb.append(""String_Node_Str"");
    sb.append(usingClass);
  }
  if (!options.isEmpty()) {
    sb.append(getOptionsString());
  }
  return sb.toString();
}","/** 
 * Get the query in a String in CQL language.
 * @return String with the query
 */
@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (type == (IndexType.FULL_TEXT)) {
    options=generateLuceneOptions();
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (createIfNotExists) {
    sb.append(""String_Node_Str"");
  }
  if (name != null) {
    sb.append(Utils.toCaseSensitive(getIndexName())).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (keyspaceIncluded) {
    sb.append(Utils.toCaseSensitive(keyspace)).append(""String_Node_Str"");
  }
  sb.append(Utils.toCaseSensitive(tableName));
  sb.append(""String_Node_Str"");
  if (type != IndexType.FULL_TEXT) {
    int i=0;
    for (    Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
      if (i != 0) {
        sb.append(""String_Node_Str"");
      }
      sb.append(Utils.toCaseSensitive(entry.getValue().getName().getName()));
      i=1;
    }
  }
 else {
    sb.append(Utils.toCaseSensitive(columnForIndex));
  }
  sb.append(""String_Node_Str"");
  if (usingClass != null) {
    sb.append(""String_Node_Str"");
    sb.append(usingClass);
  }
  if (!options.isEmpty()) {
    sb.append(getOptionsString());
  }
  return sb.toString();
}"
11161,"/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config      The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  if (sessions.containsKey(clusterName.getName())) {
    throw new ConnectionException(""String_Node_Str"" + clusterName.getName() + ""String_Node_Str"");
  }
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  Pair<String,String> connectorPropertiesValues;
  List<Pair<String,String>> connectorPropertiesList=new ArrayList<>();
  if (connectorOptions.get(""String_Node_Str"") == null) {
    connectorPropertiesValues=new ImmutablePair<>(""String_Node_Str"",Integer.toString(DEFAULT_LIMIT));
  }
 else {
    connectorPropertiesValues=new ImmutablePair<>(""String_Node_Str"",connectorOptions.get(""String_Node_Str""));
  }
  connectorPropertiesList.add(connectorPropertiesValues);
  connectorOptionsPerCluster.put(clusterName.getName(),connectorPropertiesList);
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config      The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  if (sessions.containsKey(clusterName.getName())) {
    LOG.warn(""String_Node_Str"" + clusterName.getName() + ""String_Node_Str"");
    return;
  }
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  String[] hosts=clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str"");
  String[] trimmedHosts=new String[hosts.length];
  for (int i=0; i < hosts.length; i++) {
    trimmedHosts[i]=hosts[i].trim();
  }
  engineConfig.setCassandraHosts(trimmedHosts);
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  Pair<String,String> connectorPropertiesValues;
  List<Pair<String,String>> connectorPropertiesList=new ArrayList<>();
  if (connectorOptions.get(""String_Node_Str"") == null) {
    connectorPropertiesValues=new ImmutablePair<>(""String_Node_Str"",Integer.toString(DEFAULT_LIMIT));
  }
 else {
    connectorPropertiesValues=new ImmutablePair<>(""String_Node_Str"",connectorOptions.get(""String_Node_Str""));
  }
  connectorPropertiesList.add(connectorPropertiesValues);
  connectorOptionsPerCluster.put(clusterName.getName(),connectorPropertiesList);
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11162,"/** 
 * Get the crossdata table metadata from a cassandra table metadata
 * @param session                The cassandra session.
 * @param cassandraTableMetadata The cassandra table metadata.
 * @return A {@link com.stratio.crossdata.common.metadata.TableMetadata} .
 */
private static TableMetadata getXDTableMetadata(Session session,com.datastax.driver.core.TableMetadata cassandraTableMetadata,String cluster){
  Map<IndexName,IndexMetadata> indexes=new HashMap<>();
  LinkedHashMap<ColumnName,ColumnMetadata> columns=new LinkedHashMap<>();
  List<com.datastax.driver.core.ColumnMetadata> cassandraColumns=cassandraTableMetadata.getColumns();
  for (  com.datastax.driver.core.ColumnMetadata cassandraColumn : cassandraColumns) {
    ColumnName columnName=new ColumnName(cassandraTableMetadata.getKeyspace().getName(),cassandraTableMetadata.getName(),cassandraColumn.getName());
    ColumnType columnType=utils.getCrossdataColumn(cassandraColumn.getType());
    ColumnMetadata columnMetadata=new ColumnMetadata(columnName,null,columnType);
    columns.put(columnName,columnMetadata);
    com.datastax.driver.core.ColumnMetadata.IndexMetadata cassandraIndex=cassandraColumn.getIndex();
    if (cassandraIndex != null) {
      IndexName indexName=new IndexName(cassandraTableMetadata.getKeyspace().getName(),cassandraTableMetadata.getName(),cassandraIndex.getName());
      Map<ColumnName,ColumnMetadata> columnIndex=new HashMap<>();
      columnIndex.put(columnName,columnMetadata);
      IndexMetadata indexMetadata=new IndexMetadata(indexName,columnIndex,cassandraIndex.isCustomIndex() ? IndexType.CUSTOM : IndexType.DEFAULT,null);
      indexes.put(indexName,indexMetadata);
    }
  }
  ClusterName clusterRef=new ClusterName(cluster);
  List<ColumnName> partitionKey=new ArrayList<>();
  List<com.datastax.driver.core.ColumnMetadata> partitionColumns=cassandraTableMetadata.getPartitionKey();
  for (  com.datastax.driver.core.ColumnMetadata cassandraPartition : partitionColumns) {
    ColumnName columnName=new ColumnName(cassandraPartition.getTable().getKeyspace().getName(),cassandraPartition.getTable().getName(),cassandraPartition.getName());
    partitionKey.add(columnName);
  }
  List<ColumnName> clusterKey=new ArrayList<>();
  List<com.datastax.driver.core.ColumnMetadata> clusterColumns=cassandraTableMetadata.getClusteringColumns();
  for (  com.datastax.driver.core.ColumnMetadata cassandraClusterKey : clusterColumns) {
    ColumnName columnName=new ColumnName(cassandraClusterKey.getTable().getKeyspace().getName(),cassandraClusterKey.getTable().getName(),cassandraClusterKey.getName());
    clusterKey.add(columnName);
  }
  TableName tableName=new TableName(cassandraTableMetadata.getKeyspace().getName(),cassandraTableMetadata.getName());
  return new TableMetadata(tableName,null,columns,indexes,clusterRef,partitionKey,clusterKey);
}","/** 
 * Get the crossdata table metadata from a cassandra table metadata
 * @param session                The cassandra session.
 * @param cassandraTableMetadata The cassandra table metadata.
 * @return A {@link com.stratio.crossdata.common.metadata.TableMetadata} .
 */
private static TableMetadata getXDTableMetadata(Session session,com.datastax.driver.core.TableMetadata cassandraTableMetadata,String cluster){
  Map<IndexName,IndexMetadata> indexes=new HashMap<>();
  LinkedHashMap<ColumnName,ColumnMetadata> columns=new LinkedHashMap<>();
  List<com.datastax.driver.core.ColumnMetadata> cassandraColumns=cassandraTableMetadata.getColumns();
  for (  com.datastax.driver.core.ColumnMetadata cassandraColumn : cassandraColumns) {
    ColumnName columnName=new ColumnName(cassandraTableMetadata.getKeyspace().getName(),cassandraTableMetadata.getName(),cassandraColumn.getName());
    ColumnType columnType=utils.getCrossdataColumn(cassandraColumn.getType());
    ColumnMetadata columnMetadata=new ColumnMetadata(columnName,null,columnType);
    if (cassandraColumn.getIndex() == null || !cassandraColumn.getIndex().isCustomIndex()) {
      columns.put(columnName,columnMetadata);
    }
    com.datastax.driver.core.ColumnMetadata.IndexMetadata cassandraIndex=cassandraColumn.getIndex();
    if (cassandraIndex != null) {
      IndexName indexName=new IndexName(cassandraTableMetadata.getKeyspace().getName(),cassandraTableMetadata.getName(),cassandraIndex.getName());
      Map<ColumnName,ColumnMetadata> columnIndex=new HashMap<>();
      IndexMetadata indexMetadata;
      if (cassandraIndex.isCustomIndex()) {
        columnIndex=getLuceneIndex(session,indexName,cassandraIndex);
        indexMetadata=new IndexMetadata(indexName,columnIndex,IndexType.FULL_TEXT,null);
      }
 else {
        columnIndex.put(columnName,columnMetadata);
        indexMetadata=new IndexMetadata(indexName,columnIndex,IndexType.DEFAULT,null);
      }
      indexes.put(indexName,indexMetadata);
    }
  }
  ClusterName clusterRef=new ClusterName(cluster);
  List<ColumnName> partitionKey=new ArrayList<>();
  List<com.datastax.driver.core.ColumnMetadata> partitionColumns=cassandraTableMetadata.getPartitionKey();
  for (  com.datastax.driver.core.ColumnMetadata cassandraPartition : partitionColumns) {
    ColumnName columnName=new ColumnName(cassandraPartition.getTable().getKeyspace().getName(),cassandraPartition.getTable().getName(),cassandraPartition.getName());
    partitionKey.add(columnName);
  }
  List<ColumnName> clusterKey=new ArrayList<>();
  List<com.datastax.driver.core.ColumnMetadata> clusterColumns=cassandraTableMetadata.getClusteringColumns();
  for (  com.datastax.driver.core.ColumnMetadata cassandraClusterKey : clusterColumns) {
    ColumnName columnName=new ColumnName(cassandraClusterKey.getTable().getKeyspace().getName(),cassandraClusterKey.getTable().getName(),cassandraClusterKey.getName());
    clusterKey.add(columnName);
  }
  TableName tableName=new TableName(cassandraTableMetadata.getKeyspace().getName(),cassandraTableMetadata.getName());
  return new TableMetadata(tableName,null,columns,indexes,clusterRef,partitionKey,clusterKey);
}"
11163,"/** 
 * Create Index for Cassandra Connector.
 * @param targetCluster The target cluster.
 * @param indexMetadata The metadata of the index that will be created.
 * @throws ConnectorException
 */
@Override public void createIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  CreateIndexStatement indexStatement=new CreateIndexStatement(indexMetadata,true,session);
  try {
    CassandraExecutor.execute(indexStatement.toString(),session);
  }
 catch (  ConnectorException e) {
    String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
    String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
    String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ indexMetadata.getName().getName();
    CassandraExecutor.execute(remove,session);
    throw e;
  }
}","/** 
 * Create Index for Cassandra Connector.
 * @param targetCluster The target cluster.
 * @param indexMetadata The metadata of the index that will be created.
 * @throws ConnectorException
 */
@Override public void createIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  CreateIndexStatement indexStatement;
  try {
    indexStatement=new CreateIndexStatement(indexMetadata,true,session);
  }
 catch (  Exception e) {
    throw e;
  }
  try {
    CassandraExecutor.execute(indexStatement.toString(),session);
  }
 catch (  ConnectorException e) {
    String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
    String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
    String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ indexMetadata.getName().getName();
    CassandraExecutor.execute(remove,session);
    throw e;
  }
}"
11164,"/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  String remove;
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  if (indexMetadata.getType() == IndexType.FULL_TEXT) {
    remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
  }
 else {
    remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
  }
  CassandraExecutor.execute(remove,session);
}","/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  String remove;
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  if (indexMetadata.getType() == IndexType.FULL_TEXT) {
    remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
    CassandraExecutor.execute(remove,session);
  }
 else {
    remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
    CassandraExecutor.execute(remove,session);
  }
}"
11165,"/** 
 * Basic Constructor.
 * @param indexMetadata     Index metadata information .
 * @param createIfNotExists Condition of creation of the index.
 * @param session           Session that the Index affect.
 * @throws ExecutionException
 */
public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=indexMetadata.getName().getTableName().getName();
  this.keyspace=indexMetadata.getName().getTableName().getCatalogName().getName();
  if (keyspace != null) {
    this.keyspaceIncluded=true;
  }
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    try {
      columnForIndex=getIndexName();
      String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
      String table=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
      session.execute(""String_Node_Str"" + catalog + '.'+ table+ ""String_Node_Str""+ Utils.toCaseSensitive(columnForIndex)+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}","/** 
 * Basic Constructor.
 * @param indexMetadata     Index metadata information .
 * @param createIfNotExists Condition of creation of the index.
 * @param session           Session that the Index affect.
 * @throws ExecutionException
 */
public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=indexMetadata.getName().getTableName().getName();
  this.keyspace=indexMetadata.getName().getTableName().getCatalogName().getName();
  if (keyspace != null) {
    this.keyspaceIncluded=true;
  }
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    try {
      columnForIndex=indexMetadata.getName().getName();
      String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
      String table=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
      session.execute(""String_Node_Str"" + catalog + '.'+ table+ ""String_Node_Str""+ Utils.toCaseSensitive(columnForIndex)+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}"
11166,"/** 
 * Get the name of the index. If a LUCENE index is to be created, the name of the index is prepended with   {@code stratio_lucene_}. If a name for the index is not specified, the index will be named using the concatenation of the target column names.
 * @return The name of the index.
 */
private String getIndexName(){
  String result=null;
  if (name == null) {
    StringBuilder sb=new StringBuilder();
    if (IndexType.FULL_TEXT.equals(type)) {
      sb.append(""String_Node_Str"");
      for (      ColumnMetadata columnMetadata : targetColumns.values()) {
        sb.append(""String_Node_Str"");
        sb.append(columnMetadata.getName().getName());
      }
      sb.append(tableName);
    }
 else {
      sb.append(tableName);
      for (      Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
        sb.append(""String_Node_Str"");
        sb.append(entry.getValue());
      }
      sb.append(""String_Node_Str"");
    }
    result=sb.toString();
  }
 else {
    result=name;
    if (IndexType.FULL_TEXT.equals(type)) {
      result=name;
    }
  }
  return result;
}","/** 
 * Get the name of the index. If a LUCENE index is to be created, the name of the index is prepended with   {@code stratio_lucene_}. If a name for the index is not specified, the index will be named using the concatenation of the target column names.
 * @return The name of the index.
 */
private String getIndexName(){
  String result=null;
  if (name == null) {
    StringBuilder sb=new StringBuilder();
    if (IndexType.FULL_TEXT.equals(type)) {
      sb.append(""String_Node_Str"");
      for (      ColumnMetadata columnMetadata : targetColumns.values()) {
        sb.append(""String_Node_Str"");
        sb.append(columnMetadata.getName().getName());
      }
      sb.append(tableName);
    }
 else {
      sb.append(tableName);
      for (      Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
        sb.append(""String_Node_Str"");
        sb.append(entry.getValue());
      }
      sb.append(""String_Node_Str"");
    }
    result=sb.toString();
  }
 else {
    result=name;
    if (IndexType.FULL_TEXT.equals(type)) {
      result=keyspace + ""String_Node_Str"" + tableName+ ""String_Node_Str""+ name;
    }
  }
  return result;
}"
11167,"/** 
 * Executes an asynchronous query from a String and add the alias in the Result for Selects qith paging .
 * @param query         The query in a String.
 * @param aliasColumns  The Map with the alias
 * @param session       Cassandra datastax java driver session.
 * @param queryId       The id of the query.
 * @param resultHandler The handler of the result.
 * @param pageSize      The number of fetching paging.
 */
public static void asyncExecutePaging(String query,Map<Selector,String> aliasColumns,Session session,String queryId,IResultHandler resultHandler,int pageSize) throws ConnectorException {
  try {
    Statement st=new SimpleStatement(query);
    st.setFetchSize(pageSize);
    ResultSet resultSet=session.execute(st);
    int numPage=0;
    List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
    List<Row> rows=new ArrayList<>();
    int i=0;
    for (    Row row : resultSet) {
      if (i < pageSize) {
        rows.add(row);
        i++;
      }
 else {
        i=0;
        QueryResult queryResult=com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformPagingToMetaResultSet(definitions,rows,aliasColumns),numPage,false);
        queryResult.setQueryId(queryId);
        resultHandler.processResult(queryResult);
        numPage++;
        rows=new ArrayList<>();
        rows.add(row);
      }
    }
    numPage++;
    QueryResult queryResult=com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformPagingToMetaResultSet(definitions,rows,aliasColumns),numPage,true);
    queryResult.setQueryId(queryId);
    resultHandler.processResult(queryResult);
  }
 catch (  UnsupportedOperationException unSupportException) {
    resultHandler.processException(queryId,new ExecutionException(unSupportException.getMessage(),unSupportException));
  }
catch (  DriverException dex) {
    resultHandler.processException(queryId,new ExecutionException(dex.getMessage()));
  }
catch (  Exception ex) {
    resultHandler.processException(queryId,new ExecutionException(ex.getMessage(),ex));
  }
}","/** 
 * Executes an asynchronous query from a String and add the alias in the Result for Selects qith paging .
 * @param query         The query in a String.
 * @param aliasColumns  The Map with the alias
 * @param session       Cassandra datastax java driver session.
 * @param queryId       The id of the query.
 * @param resultHandler The handler of the result.
 * @param pageSize      The number of fetching paging.
 */
public static void asyncExecutePaging(String query,Map<Selector,String> aliasColumns,Session session,String queryId,IResultHandler resultHandler,int pageSize) throws ConnectorException {
  try {
    Statement st=new SimpleStatement(query);
    st.setFetchSize(pageSize);
    ResultSet resultSet=session.execute(st);
    int numPage=0;
    List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
    List<Row> rows=new ArrayList<>();
    int i=0;
    for (    Row row : resultSet) {
      if (i < pageSize) {
        rows.add(row);
        i++;
      }
 else {
        i=0;
        QueryResult queryResult=com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformPagingToMetaResultSet(definitions,rows,aliasColumns),numPage,false);
        queryResult.setQueryId(queryId);
        resultHandler.processResult(queryResult);
        numPage++;
        rows=new ArrayList<>();
        rows.add(row);
      }
    }
    QueryResult queryResult=com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformPagingToMetaResultSet(definitions,rows,aliasColumns),numPage,true);
    queryResult.setQueryId(queryId);
    resultHandler.processResult(queryResult);
  }
 catch (  UnsupportedOperationException unSupportException) {
    resultHandler.processException(queryId,new ExecutionException(unSupportException.getMessage(),unSupportException));
  }
catch (  DriverException dex) {
    resultHandler.processException(queryId,new ExecutionException(dex.getMessage()));
  }
catch (  Exception ex) {
    resultHandler.processException(queryId,new ExecutionException(ex.getMessage(),ex));
  }
}"
11168,"/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata     The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
  CassandraExecutor.execute(remove,session);
}","/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  String remove;
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  if (indexMetadata.getType() == IndexType.FULL_TEXT) {
    remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
  }
 else {
    remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
  }
  CassandraExecutor.execute(remove,session);
}"
11169,"private String getWhereClause(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  int count=0;
  for (  Relation relation : where) {
    if (count > 0) {
      sb.append(""String_Node_Str"");
    }
    count=1;
switch (relation.getOperator()) {
case IN:
case BETWEEN:
      break;
case MATCH:
    if (luceneIndexExist) {
      luceneIndex.append(""String_Node_Str"");
    }
  luceneIndex.append(getLuceneWhereClause(relation));
luceneIndexExist=true;
break;
default :
Selector right=relation.getRightTerm();
if (right instanceof FunctionSelector) {
FunctionSelector function=(FunctionSelector)right;
if (""String_Node_Str"".equals(function.getFunctionName())) {
getStringRangeFunction(function,(ColumnSelector)relation.getLeftTerm());
}
 else {
ColumnSelector left=(ColumnSelector)relation.getLeftTerm();
String column=Utils.toCaseSensitive(left.getColumnName().getName());
sb.append(column).append(""String_Node_Str"").append(relation.getOperator().toString()).append(""String_Node_Str"");
sb.append(function.toString());
}
}
 else {
ColumnSelector left=(ColumnSelector)relation.getLeftTerm();
String column=Utils.toCaseSensitive(left.getColumnName().getName());
sb.append(column).append(""String_Node_Str"").append(relation.getOperator().toString()).append(""String_Node_Str"");
sb.append(right.toString());
}
break;
}
}
if (luceneIndexExist) {
String nameIndex=getLuceneIndex();
StringBuilder sbLucene=new StringBuilder();
sbLucene.append(Utils.toCaseSensitive(nameIndex)).append(""String_Node_Str"");
sbLucene.append(luceneIndex).append(""String_Node_Str"");
sb.append(sbLucene);
}
String whereClause=sb.toString();
while (whereClause.contains(""String_Node_Str"")) {
whereClause=whereClause.replace(""String_Node_Str"",""String_Node_Str"");
}
return whereClause;
}","private String getWhereClause(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  int count=0;
  for (  Relation relation : where) {
    if (count > 0) {
      sb.append(""String_Node_Str"");
    }
    count=1;
switch (relation.getOperator()) {
case IN:
case BETWEEN:
      break;
case MATCH:
    if (luceneIndexExist) {
      luceneIndex.append(""String_Node_Str"");
    }
  luceneIndex.append(getLuceneWhereClause(relation));
luceneIndexExist=true;
break;
default :
Selector right=relation.getRightTerm();
if (right instanceof FunctionSelector) {
FunctionSelector function=(FunctionSelector)right;
if (""String_Node_Str"".equals(function.getFunctionName())) {
getStringRangeFunction(function,(ColumnSelector)relation.getLeftTerm());
}
 else {
ColumnSelector left=(ColumnSelector)relation.getLeftTerm();
String column=Utils.toCaseSensitive(left.getColumnName().getName());
sb.append(column).append(""String_Node_Str"").append(relation.getOperator().toString()).append(""String_Node_Str"");
sb.append(function.toString());
}
}
 else {
ColumnSelector left=(ColumnSelector)relation.getLeftTerm();
String column=Utils.toCaseSensitive(left.getColumnName().getName());
sb.append(column).append(""String_Node_Str"").append(relation.getOperator().toString()).append(""String_Node_Str"");
sb.append(Utils.getFormatType(left,right,session));
}
break;
}
}
if (luceneIndexExist) {
String nameIndex=getLuceneIndex();
StringBuilder sbLucene=new StringBuilder();
sbLucene.append(Utils.toCaseSensitive(nameIndex)).append(""String_Node_Str"");
sbLucene.append(luceneIndex).append(""String_Node_Str"");
sb.append(sbLucene);
}
String whereClause=sb.toString();
while (whereClause.contains(""String_Node_Str"")) {
whereClause=whereClause.replace(""String_Node_Str"",""String_Node_Str"");
}
return whereClause;
}"
11170,"public String getNativeValueColumn(ColumnType type,String value){
switch (type.getDbType().toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
    return ""String_Node_Str"" + value + ""String_Node_Str"";
default :
  return value;
}
}","public String getNativeValueColumn(ColumnType type,String value){
switch (type.getDbType().toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
    return ""String_Node_Str"" + value + ""String_Node_Str"";
default :
  return value;
}
}"
11171,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformPagingToMetaResultSet(List<ColumnDefinitions.Definition> definitions,List<Row> rows,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : rows) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        boolean findIt=false;
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            findIt=true;
            break;
          }
        }
        if (!findIt) {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param alias The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformPagingToMetaResultSet(List<ColumnDefinitions.Definition> definitions,List<Row> rows,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : rows) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        boolean findIt=false;
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            findIt=true;
            break;
          }
        }
        if (!findIt) {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11172,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        boolean findIt=false;
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            findIt=true;
            break;
          }
        }
        if (!findIt) {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias     The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        boolean findIt=false;
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            findIt=true;
            break;
          }
        }
        if (!findIt) {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11173,"/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata     The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ indexMetadata.getName().getName();
  CassandraExecutor.execute(remove,session);
}","/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata     The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ Utils.toCaseSensitive(indexMetadata.getName().getName());
  CassandraExecutor.execute(remove,session);
}"
11174,"/** 
 * Create Index for Cassandra Connector.
 * @param targetCluster The target cluster.
 * @param indexMetadata The metadata of the index that will be created.
 * @throws ConnectorException
 */
@Override public void createIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  CreateIndexStatement indexStatement=new CreateIndexStatement(indexMetadata,true,session);
  CassandraExecutor.execute(indexStatement.toString(),session);
}","/** 
 * Create Index for Cassandra Connector.
 * @param targetCluster The target cluster.
 * @param indexMetadata The metadata of the index that will be created.
 * @throws ConnectorException
 */
@Override public void createIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  CreateIndexStatement indexStatement=new CreateIndexStatement(indexMetadata,true,session);
  try {
    CassandraExecutor.execute(indexStatement.toString(),session);
  }
 catch (  ConnectorException e) {
    String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
    String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
    String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ indexMetadata.getName().getName();
    CassandraExecutor.execute(remove,session);
    throw e;
  }
}"
11175,"/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexName     The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexName) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexName,false);
  CassandraExecutor.execute(indexStatement.toString(),session);
}","/** 
 * Drop Index that was created previously.
 * @param targetCluster The target cluster.
 * @param indexMetadata     The IndexName of the index.
 * @throws ConnectorException
 */
@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws ConnectorException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexMetadata,false);
  String tableName=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getName());
  String catalog=Utils.toCaseSensitive(indexMetadata.getName().getTableName().getCatalogName().getName());
  String remove=""String_Node_Str"" + catalog + ""String_Node_Str""+ tableName+ ""String_Node_Str""+ indexMetadata.getName().getName();
  CassandraExecutor.execute(remove,session);
}"
11176,"/** 
 * Generate the Lucene options schema that corresponds with the selected column.
 * @return The JSON representation of the Lucene schema.
 */
protected String generateLuceneSchema(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
    sb.append(Utils.toCaseSensitive(entry.getValue().getName().getName()));
    sb.append(""String_Node_Str"");
    sb.append(luceneTypes.get(entry.getValue().getColumnType().getDataType()));
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Generate the Lucene options schema that corresponds with the selected column.
 * @return The JSON representation of the Lucene schema.
 */
protected String generateLuceneSchema(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
    sb.append(Utils.toCaseSensitive(entry.getValue().getName().getName()));
    sb.append(""String_Node_Str"");
    if (entry.getValue().getColumnType().getDataType() == com.stratio.crossdata.common.metadata.DataType.NATIVE) {
      if (entry.getValue().getColumnType().getDbType().equals(""String_Node_Str"")) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"").append(entry.getValue().getColumnType().getDbType()).append(""String_Node_Str"");
      }
    }
 else {
      sb.append(luceneTypes.get(entry.getValue().getColumnType().getDataType()));
    }
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"");
}"
11177,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
      columnMetadata=new ColumnMetadata(columnName,null,type);
      columnMetadata.getName().setAlias(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))));
    }
 else {
      columnMetadata=new ColumnMetadata(columnName,null,type);
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
          metaRow.addCell(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))),metaCell);
        }
 else {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            break;
          }
 else {
            metaRow.addCell(def.getName(),metaCell);
          }
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11178,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            break;
          }
 else {
            metaRow.addCell(def.getName(),metaCell);
          }
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        boolean findIt=false;
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            findIt=true;
            break;
          }
        }
        if (!findIt) {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11179,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
      columnMetadata=new ColumnMetadata(columnName,null,type);
      columnMetadata.getName().setAlias(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))));
    }
 else {
      columnMetadata=new ColumnMetadata(columnName,null,type);
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
          metaRow.addCell(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))),metaCell);
        }
 else {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            break;
          }
 else {
            metaRow.addCell(def.getName(),metaCell);
          }
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11180,"/** 
 * Initialize the connection to the underlying database.
 * @param config The {@link com.stratio.connector.cassandra.engine.EngineConfig}.
 * @return A new Session.
 */
private Session initializeDB(EngineConfig config) throws ConnectionException {
  Cluster cluster=Cluster.builder().addContactPoints(config.getCassandraHosts()).withPort(config.getCassandraPort()).build();
  LOG.info(""String_Node_Str"" + Arrays.toString(config.getCassandraHosts()) + ""String_Node_Str""+ config.getCassandraPort());
  Session result;
  try {
    result=cluster.connect();
  }
 catch (  NoHostAvailableException nhae) {
    throw new ConnectionException(nhae);
  }
  return result;
}","/** 
 * Initialize the connection to the underlying database.
 * @param config The {@link com.stratio.connector.cassandra.engine.EngineConfig}.
 * @return A new Session.
 */
private Session initializeDB(EngineConfig config) throws ConnectionException {
  Cluster cluster=Cluster.builder().addContactPoints(config.getCassandraHosts()).withPort(config.getCassandraPort()).build();
  LOG.info(""String_Node_Str"" + Arrays.toString(config.getCassandraHosts()) + ""String_Node_Str""+ config.getCassandraPort());
  Session result;
  try {
    result=cluster.connect();
  }
 catch (  NoHostAvailableException nhae) {
    throw new ConnectionException(nhae.getMessage(),nhae.getCause());
  }
  return result;
}"
11181,"/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    Document d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    XPathFactory xFactory=XPathFactory.newInstance();
    XPath xpath=xFactory.newXPath();
    Object result;
    XPathExpression expr;
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      this.connectorName=((NodeList)result).item(0).getNodeValue();
    }
 catch (    XPathExpressionException e) {
      this.connectorName=""String_Node_Str"";
    }
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      datastoreName=new String[((NodeList)result).getLength()];
      for (int i=0; i < ((NodeList)result).getLength(); i++) {
        this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
      }
    }
 catch (    XPathExpressionException e) {
      datastoreName=new String[1];
      this.datastoreName[0]=""String_Node_Str"";
    }
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
}","/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=null;
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    xFactory=XPathFactory.newInstance();
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}"
11182,"/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (connectorOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(connectorOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config      The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (connectorOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(connectorOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11183,"/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    throw new UnsupportedException(unSupportException);
  }
catch (  DriverException dex) {
    throw new CriticalExecutionException(dex);
  }
catch (  Exception ex) {
    throw new ExecutionException(ex);
  }
}","/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    throw new UnsupportedException(unSupportException.getMessage());
  }
catch (  DriverException dex) {
    throw new CriticalExecutionException(dex.getMessage());
  }
catch (  Exception ex) {
    throw new ExecutionException(ex.getMessage());
  }
}"
11184,"/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    Document d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    XPathFactory xFactory=XPathFactory.newInstance();
    XPath xpath=xFactory.newXPath();
    Object result;
    XPathExpression expr;
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      this.connectorName=((NodeList)result).item(0).getNodeValue();
    }
 catch (    XPathExpressionException e) {
      this.connectorName=""String_Node_Str"";
    }
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      datastoreName=new String[((NodeList)result).getLength()];
      for (int i=0; i < ((NodeList)result).getLength(); i++) {
        this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
      }
    }
 catch (    XPathExpressionException e) {
      datastoreName=new String[1];
      this.datastoreName[0]=""String_Node_Str"";
    }
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
}","/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=null;
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    xFactory=XPathFactory.newInstance();
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}"
11185,"/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (connectorOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(connectorOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config      The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (connectorOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(connectorOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11186,"/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    throw new UnsupportedException(unSupportException);
  }
catch (  DriverException dex) {
    throw new CriticalExecutionException(dex);
  }
catch (  Exception ex) {
    throw new ExecutionException(ex);
  }
}","/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    throw new UnsupportedException(unSupportException.getMessage());
  }
catch (  DriverException dex) {
    throw new CriticalExecutionException(dex.getMessage());
  }
catch (  Exception ex) {
    throw new ExecutionException(ex.getMessage());
  }
}"
11187,"private String getFunctionString(FunctionSelector selectorFunction){
  String result=""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
switch (selectorFunction.getFunctionName().toUpperCase()) {
case ""String_Node_Str"":
    result=""String_Node_Str"";
  break;
case ""String_Node_Str"":
result=""String_Node_Str"";
break;
default :
List<Selector> columns=selectorFunction.getFunctionColumns();
sb.append(selectorFunction.getFunctionName()).append(""String_Node_Str"");
for (Selector s : columns) {
if (s instanceof ColumnSelector) {
ColumnSelector columnSelector=(ColumnSelector)s;
sb.append(columnSelector.getColumnName().getName());
sb.append(""String_Node_Str"");
}
 else if (s instanceof FunctionSelector) {
FunctionSelector functionSelector=(FunctionSelector)s;
String subFunction=getFunctionString(functionSelector);
sb.append(subFunction);
}
}
if (sb.toString().endsWith(""String_Node_Str"")) {
sb.deleteCharAt(sb.lastIndexOf(""String_Node_Str""));
}
sb.append(""String_Node_Str"");
result=sb.toString();
}
return result;
}","private String getFunctionString(FunctionSelector selectorFunction){
  String result=""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
switch (selectorFunction.getFunctionName().toUpperCase()) {
case ""String_Node_Str"":
    result=selectorFunction.getFunctionName() + ""String_Node_Str"";
  break;
case ""String_Node_Str"":
result=selectorFunction.getFunctionName() + ""String_Node_Str"";
break;
default :
List<Selector> columns=selectorFunction.getFunctionColumns();
sb.append(selectorFunction.getFunctionName()).append(""String_Node_Str"");
for (Selector s : columns) {
if (s instanceof ColumnSelector) {
ColumnSelector columnSelector=(ColumnSelector)s;
sb.append(columnSelector.getColumnName().getName());
sb.append(""String_Node_Str"");
}
 else if (s instanceof FunctionSelector) {
FunctionSelector functionSelector=(FunctionSelector)s;
String subFunction=getFunctionString(functionSelector);
sb.append(subFunction);
}
}
if (sb.toString().endsWith(""String_Node_Str"")) {
sb.deleteCharAt(sb.lastIndexOf(""String_Node_Str""));
}
sb.append(""String_Node_Str"");
result=sb.toString();
}
return result;
}"
11188,"/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=null;
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    xFactory=XPathFactory.newInstance();
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}","/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=XPathFactory.newInstance();
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}"
11189,"/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=null;
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    xFactory=XPathFactory.newInstance();
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}","/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=XPathFactory.newInstance();
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}"
11190,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
      columnMetadata=new ColumnMetadata(columnName,null,type);
      columnMetadata.getName().setAlias(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))));
    }
 else {
      columnMetadata=new ColumnMetadata(columnName,null,type);
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
          metaRow.addCell(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))),metaCell);
        }
 else {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    for (    Map.Entry<Selector,String> entry : alias.entrySet()) {
      if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
        columnMetadata=new ColumnMetadata(columnName,null,type);
        columnMetadata.getName().setAlias(entry.getValue());
        break;
      }
 else {
        columnMetadata=new ColumnMetadata(columnName,null,type);
      }
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        ColumnName cassandraColumnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
        for (        Map.Entry<Selector,String> entry : alias.entrySet()) {
          if (entry.getKey().getColumnName().getQualifiedName().equals(cassandraColumnName.getQualifiedName())) {
            metaRow.addCell(entry.getValue(),metaCell);
            break;
          }
 else {
            metaRow.addCell(def.getName(),metaCell);
          }
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11191,"/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    Document d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    XPathFactory xFactory=XPathFactory.newInstance();
    XPath xpath=xFactory.newXPath();
    Object result;
    XPathExpression expr;
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      this.connectorName=((NodeList)result).item(0).getNodeValue();
    }
 catch (    XPathExpressionException e) {
      this.connectorName=""String_Node_Str"";
    }
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      datastoreName=new String[((NodeList)result).getLength()];
      for (int i=0; i < ((NodeList)result).getLength(); i++) {
        this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
      }
    }
 catch (    XPathExpressionException e) {
      datastoreName=new String[1];
      this.datastoreName[0]=""String_Node_Str"";
    }
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
}","/** 
 * Constructor.
 */
public CassandraConnector(){
  sessions=new HashMap<>();
  XPathFactory xFactory=null;
  Document d=null;
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    xFactory=XPathFactory.newInstance();
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
  XPath xpath=xFactory.newXPath();
  Object result;
  XPathExpression expr;
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    this.connectorName=((NodeList)result).item(0).getNodeValue();
  }
 catch (  XPathExpressionException e) {
    this.connectorName=""String_Node_Str"";
  }
  try {
    expr=xpath.compile(""String_Node_Str"");
    result=expr.evaluate(d,XPathConstants.NODESET);
    datastoreName=new String[((NodeList)result).getLength()];
    for (int i=0; i < ((NodeList)result).getLength(); i++) {
      this.datastoreName[i]=((NodeList)result).item(i).getNodeValue();
    }
  }
 catch (  XPathExpressionException e) {
    datastoreName=new String[1];
    this.datastoreName[0]=""String_Node_Str"";
  }
}"
11192,"/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (connectorOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(connectorOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config      The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getClusterOptions();
  Map<String,String> connectorOptions=config.getConnectorOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (connectorOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(connectorOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11193,"/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    throw new UnsupportedException(unSupportException);
  }
catch (  DriverException dex) {
    throw new CriticalExecutionException(dex);
  }
catch (  Exception ex) {
    throw new ExecutionException(ex);
  }
}","/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    throw new UnsupportedException(unSupportException.getMessage());
  }
catch (  DriverException dex) {
    throw new CriticalExecutionException(dex.getMessage());
  }
catch (  Exception ex) {
    throw new ExecutionException(ex.getMessage());
  }
}"
11194,"/** 
 * Basic Constructor.
 * @param indexMetadata  Index metadata information .
 * @param createIfNotExists Condition of creation of the index.
 * @param session Session that the Index affect.
 * @throws ExecutionException
 */
public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=indexMetadata.getName().getTableName().getName();
  this.keyspace=indexMetadata.getName().getTableName().getCatalogName().getName();
  if (keyspace != null) {
    this.keyspaceIncluded=true;
  }
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    try {
      session.execute(""String_Node_Str"" + indexMetadata.getName().getTableName().getQualifiedName() + ""String_Node_Str""+ getIndexName()+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}","/** 
 * Basic Constructor.
 * @param indexMetadata     Index metadata information .
 * @param createIfNotExists Condition of creation of the index.
 * @param session           Session that the Index affect.
 * @throws ExecutionException
 */
public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=indexMetadata.getName().getTableName().getName();
  this.keyspace=indexMetadata.getName().getTableName().getCatalogName().getName();
  if (keyspace != null) {
    this.keyspaceIncluded=true;
  }
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    try {
      columnForIndex=getIndexName();
      session.execute(""String_Node_Str"" + indexMetadata.getName().getTableName().getQualifiedName() + ""String_Node_Str""+ columnForIndex+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage(),e);
    }
  }
}"
11195,"/** 
 * Get the query in a String in CQL language.
 * @return String with the query
 */
public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (type == (IndexType.FULL_TEXT)) {
    options=generateLuceneOptions();
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (createIfNotExists) {
    sb.append(""String_Node_Str"");
  }
  if (name != null) {
    sb.append(getIndexName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (keyspaceIncluded) {
    sb.append(keyspace).append(""String_Node_Str"");
  }
  sb.append(tableName);
  sb.append(""String_Node_Str"");
  int i=0;
  for (  Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
    if (i != 0) {
      sb.append(""String_Node_Str"");
    }
    sb.append(entry.getValue().getName().getName());
    i=1;
  }
  sb.append(""String_Node_Str"");
  if (usingClass != null) {
    sb.append(""String_Node_Str"");
    sb.append(usingClass);
  }
  if (!options.isEmpty()) {
    sb.append(getOptionsString());
  }
  return sb.toString();
}","/** 
 * Get the query in a String in CQL language.
 * @return String with the query
 */
public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (type == (IndexType.FULL_TEXT)) {
    options=generateLuceneOptions();
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (createIfNotExists) {
    sb.append(""String_Node_Str"");
  }
  if (name != null) {
    sb.append(getIndexName()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  if (keyspaceIncluded) {
    sb.append(keyspace).append(""String_Node_Str"");
  }
  sb.append(tableName);
  sb.append(""String_Node_Str"");
  if (type != IndexType.FULL_TEXT) {
    int i=0;
    for (    Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
      if (i != 0) {
        sb.append(""String_Node_Str"");
      }
      sb.append(entry.getValue().getName().getName());
      i=1;
    }
  }
 else {
    sb.append(columnForIndex);
  }
  sb.append(""String_Node_Str"");
  if (usingClass != null) {
    sb.append(""String_Node_Str"");
    sb.append(usingClass);
  }
  if (!options.isEmpty()) {
    sb.append(getOptionsString());
  }
  return sb.toString();
}"
11196,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(tableName.getQualifiedName());
  sb.append(""String_Node_Str"").append(""String_Node_Str"");
  for (  Relation relation : assignations) {
    String leftTerm=relation.getLeftTerm().getStringValue().substring(relation.getLeftTerm().getStringValue().lastIndexOf('.') + 1,relation.getLeftTerm().getStringValue().length());
    sb.append(leftTerm).append(relation.getOperator().toString()).append(relation.getRightTerm().toString()).append(""String_Node_Str"");
  }
  sb.delete(sb.lastIndexOf(""String_Node_Str""),sb.length());
  sb.append(""String_Node_Str"");
  if ((whereClauses != null) && (!whereClauses.isEmpty())) {
    for (    Filter filter : whereClauses) {
      Relation relation=filter.getRelation();
      String leftTerm=relation.getLeftTerm().getStringValue().substring(relation.getLeftTerm().getStringValue().lastIndexOf('.') + 1,relation.getLeftTerm().getStringValue().length());
      sb.append(leftTerm).append(relation.getOperator().toString()).append(relation.getRightTerm().toString()).append(""String_Node_Str"");
    }
    sb.delete(sb.lastIndexOf(""String_Node_Str""),sb.length());
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(tableName.getQualifiedName());
  sb.append(""String_Node_Str"").append(""String_Node_Str"");
  for (  Relation relation : assignations) {
    String leftTerm=getLeftTerm(relation);
    sb.append(leftTerm).append(relation.getOperator().toString()).append(relation.getRightTerm().toString()).append(""String_Node_Str"");
  }
  sb.delete(sb.lastIndexOf(""String_Node_Str""),sb.length());
  sb.append(""String_Node_Str"");
  if ((whereClauses != null) && (!whereClauses.isEmpty())) {
    for (    Filter filter : whereClauses) {
      Relation relation=filter.getRelation();
      String leftTerm=getLeftTerm(relation);
      sb.append(leftTerm).append(relation.getOperator().toString()).append(relation.getRightTerm().toString()).append(""String_Node_Str"");
    }
    sb.delete(sb.lastIndexOf(""String_Node_Str""),sb.length());
  }
  return sb.toString();
}"
11197,"@Test public void basicSelectTest(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.ASSIGN,rightTerm2);
  Filter filter2=new Filter(Operations.SELECT_LIMIT,relation2);
  Relation relation=new Relation(selector,Operator.ASSIGN,rightTerm);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  for (  Row row : qr.getResultSet()) {
    Cell cell=row.getCell(""String_Node_Str"");
    value=cell.getValue().toString();
  }
  assertEquals(value,""String_Node_Str"");
  assertEquals(cqe.parseQuery(),""String_Node_Str"");
}","@Test public void basicSelectTest(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.ASSIGN,rightTerm2);
  Filter filter2=new Filter(Operations.SELECT_LIMIT,relation2);
  Relation relation=new Relation(selector,Operator.ASSIGN,rightTerm);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  for (  Row row : qr.getResultSet()) {
    Cell cell=row.getCell(""String_Node_Str"");
    value=cell.getValue().toString();
  }
  assertEquals(value,""String_Node_Str"",""String_Node_Str"");
  assertEquals(cqe.parseQuery(),""String_Node_Str"",""String_Node_Str"");
}"
11198,"@Test public void basicSelectWithOwnLimitTest(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.ASSIGN,rightTerm2);
  Filter filter2=new Filter(Operations.SELECT_LIMIT,relation2);
  Relation relation=new Relation(selector,Operator.ASSIGN,rightTerm);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  Limit limit=new Limit(Operations.SELECT_LIMIT,50);
  filter2.setNextStep(limit);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  for (  Row row : qr.getResultSet()) {
    Cell cell=row.getCell(""String_Node_Str"");
    value=cell.getValue().toString();
  }
  assertEquals(value,""String_Node_Str"");
  assertEquals(cqe.parseQuery(),""String_Node_Str"");
}","@Test public void basicSelectWithOwnLimitTest(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.ASSIGN,rightTerm2);
  Filter filter2=new Filter(Operations.SELECT_LIMIT,relation2);
  Relation relation=new Relation(selector,Operator.ASSIGN,rightTerm);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  Limit limit=new Limit(Operations.SELECT_LIMIT,50);
  filter2.setNextStep(limit);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  for (  Row row : qr.getResultSet()) {
    Cell cell=row.getCell(""String_Node_Str"");
    value=cell.getValue().toString();
  }
  assertEquals(value,""String_Node_Str"",""String_Node_Str"");
  assertEquals(cqe.parseQuery(),""String_Node_Str"",""String_Node_Str"");
}"
11199,"@Test public void LuceneSelectTest(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Relation relation=new Relation(selector,Operator.MATCH,rightTerm);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  for (  Row row : qr.getResultSet()) {
    Cell cell=row.getCell(""String_Node_Str"");
    value=cell.getValue().toString();
  }
  if (value != null && !value.equals(""String_Node_Str"")) {
    assertEquals(true,true);
  }
}","@Test public void LuceneSelectTest(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Relation relation=new Relation(selector,Operator.MATCH,rightTerm);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  for (  Row row : qr.getResultSet()) {
    Cell cell=row.getCell(""String_Node_Str"");
    value=cell.getValue().toString();
  }
  assertNotEquals(value,null,""String_Node_Str"");
}"
11200,"@Test public void SelectTestWithAlias(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.EQ,rightTerm2);
  Filter filter2=new Filter(Operations.FILTER_INDEXED_EQ,relation2);
  Relation relation=new Relation(selector,Operator.EQ,rightTerm);
  Filter filter=new Filter(Operations.FILTER_NON_INDEXED_EQ,relation);
  Map<ColumnName,String> aliasColumns=new HashMap<>();
  aliasColumns.put(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  Map<String,ColumnType> typeMap=new HashMap<>();
  Map<ColumnName,ColumnType> typeMapFromColumnName=new HashMap<>();
  typeMap.put(""String_Node_Str"",ColumnType.VARCHAR);
  typeMapFromColumnName.put(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),ColumnType.VARCHAR);
  Select aliasSelect=new Select(Operations.SELECT_LIMIT,aliasColumns,typeMap,typeMapFromColumnName);
  filter2.setNextStep(aliasSelect);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  try {
    for (    Row row : qr.getResultSet()) {
      Cell cell=row.getCell(""String_Node_Str"");
      value=cell.getValue().toString();
    }
    assertEquals(value,""String_Node_Str"");
    assertEquals(cqe.parseQuery(),""String_Node_Str"");
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"");
  }
}","@Test public void SelectTestWithAlias(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.EQ,rightTerm2);
  Filter filter2=new Filter(Operations.FILTER_INDEXED_EQ,relation2);
  Relation relation=new Relation(selector,Operator.EQ,rightTerm);
  Filter filter=new Filter(Operations.FILTER_NON_INDEXED_EQ,relation);
  Map<ColumnName,String> aliasColumns=new HashMap<>();
  aliasColumns.put(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  Map<String,ColumnType> typeMap=new HashMap<>();
  Map<ColumnName,ColumnType> typeMapFromColumnName=new HashMap<>();
  typeMap.put(""String_Node_Str"",ColumnType.VARCHAR);
  typeMapFromColumnName.put(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),ColumnType.VARCHAR);
  Select aliasSelect=new Select(Operations.SELECT_LIMIT,aliasColumns,typeMap,typeMapFromColumnName);
  filter2.setNextStep(aliasSelect);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  try {
    for (    Row row : qr.getResultSet()) {
      Cell cell=row.getCell(""String_Node_Str"");
      value=cell.getValue().toString();
    }
    assertEquals(value,""String_Node_Str"",""String_Node_Str"");
    assertEquals(cqe.parseQuery(),""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"");
  }
}"
11201,"/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<ColumnName,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    LOG.error(""String_Node_Str"",unSupportException);
    throw new UnsupportedException(unSupportException.getMessage());
  }
catch (  DriverException dex) {
    LOG.error(""String_Node_Str"",dex);
    throw new CriticalExecutionException(dex.getMessage());
  }
catch (  Exception ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new ExecutionException(ex.getMessage());
  }
}","/** 
 * Executes a query from a String and add the alias in the Result for Selects .
 * @param query        The query in a String.
 * @param aliasColumns The Map with the alias
 * @param session      Cassandra datastax java driver session.
 * @return a {@link com.stratio.crossdata.common.result.Result}.
 */
public static com.stratio.crossdata.common.result.Result execute(String query,Map<Selector,String> aliasColumns,Session session) throws ConnectorException {
  try {
    ResultSet resultSet=session.execute(query);
    return com.stratio.crossdata.common.result.QueryResult.createQueryResult(utils.transformToMetaResultSet(resultSet,aliasColumns));
  }
 catch (  UnsupportedOperationException unSupportException) {
    LOG.error(""String_Node_Str"",unSupportException);
    throw new UnsupportedException(unSupportException.getMessage());
  }
catch (  DriverException dex) {
    LOG.error(""String_Node_Str"",dex);
    throw new CriticalExecutionException(dex.getMessage());
  }
catch (  Exception ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new ExecutionException(ex.getMessage());
  }
}"
11202,"private String getAliasClause(){
  StringBuilder sb=new StringBuilder();
  int i=0;
  for (  Map.Entry<ColumnName,String> entry : aliasColumns.entrySet()) {
    if (i != 0) {
      sb.append(""String_Node_Str"");
    }
    i=1;
    sb.append(entry.getKey().getName());
  }
  return sb.toString();
}","private String getAliasClause(){
  StringBuilder sb=new StringBuilder();
  int i=0;
  for (  Map.Entry<Selector,String> entry : aliasColumns.entrySet()) {
    if (i != 0) {
      sb.append(""String_Node_Str"");
    }
    i=1;
    sb.append(entry.getKey().getColumnName().getName());
  }
  return sb.toString();
}"
11203,"/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<ColumnName,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    if (alias.containsKey(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))) {
      columnMetadata=new ColumnMetadata(columnName,null,type);
      columnMetadata.getName().setAlias(alias.get(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())));
    }
 else {
      columnMetadata=new ColumnMetadata(columnName,null,type);
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        if (alias.containsKey(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))) {
          metaRow.addCell(alias.get(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())),metaCell);
        }
 else {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}","/** 
 * Transforms a Cassandra   {@link com.datastax.driver.core.ResultSet} into a {@link com.stratio.crossdata.common.data.ResultSet}.
 * @param resultSet The input Cassandra result set.
 * @param alias  The map with the relations between ColumnName and Alias.
 * @return An equivalent Meta ResultSet.
 */
public com.stratio.crossdata.common.data.ResultSet transformToMetaResultSet(com.datastax.driver.core.ResultSet resultSet,Map<Selector,String> alias){
  ResultSet crs=new ResultSet();
  CassandraMetadataHelper helper=new CassandraMetadataHelper();
  List<ColumnDefinitions.Definition> definitions=resultSet.getColumnDefinitions().asList();
  List<ColumnMetadata> columnList=new ArrayList<>();
  ColumnMetadata columnMetadata=null;
  for (  ColumnDefinitions.Definition def : definitions) {
    ColumnName columnName=new ColumnName(def.getKeyspace(),def.getTable(),def.getName());
    ColumnType type=helper.toColumnType(def.getType().getName().toString());
    if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
      columnMetadata=new ColumnMetadata(columnName,null,type);
      columnMetadata.getName().setAlias(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))));
    }
 else {
      columnMetadata=new ColumnMetadata(columnName,null,type);
    }
    columnList.add(columnMetadata);
  }
  crs.setColumnMetadata(columnList);
  try {
    for (    Row row : resultSet.all()) {
      com.stratio.crossdata.common.data.Row metaRow=new com.stratio.crossdata.common.data.Row();
      for (      ColumnDefinitions.Definition def : definitions) {
        if (def.getName().toLowerCase().startsWith(""String_Node_Str"")) {
          continue;
        }
        Cell metaCell=getCell(def.getType(),row,def.getName());
        if (alias.containsKey(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName())))) {
          metaRow.addCell(alias.get(new ColumnSelector(new ColumnName(def.getKeyspace(),def.getTable(),def.getName()))),metaCell);
        }
 else {
          metaRow.addCell(def.getName(),metaCell);
        }
      }
      crs.add(metaRow);
    }
  }
 catch (  InvocationTargetException|IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
    crs=new ResultSet();
  }
  return crs;
}"
11204,"@Test public void SelectTestWithAlias(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.EQ,rightTerm2);
  Filter filter2=new Filter(Operations.FILTER_INDEXED_EQ,relation2);
  Relation relation=new Relation(selector,Operator.EQ,rightTerm);
  Filter filter=new Filter(Operations.FILTER_NON_INDEXED_EQ,relation);
  Map<ColumnName,String> aliasColumns=new HashMap<>();
  aliasColumns.put(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  Map<String,ColumnType> typeMap=new HashMap<>();
  Map<ColumnName,ColumnType> typeMapFromColumnName=new HashMap<>();
  typeMap.put(""String_Node_Str"",ColumnType.VARCHAR);
  typeMapFromColumnName.put(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),ColumnType.VARCHAR);
  Select aliasSelect=new Select(Operations.SELECT_LIMIT,aliasColumns,typeMap,typeMapFromColumnName);
  filter2.setNextStep(aliasSelect);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  try {
    for (    Row row : qr.getResultSet()) {
      Cell cell=row.getCell(""String_Node_Str"");
      value=cell.getValue().toString();
    }
    assertEquals(value,""String_Node_Str"",""String_Node_Str"");
    assertEquals(cqe.parseQuery(),""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"");
  }
}","@Test public void SelectTestWithAlias(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(Operations.PROJECT,tableName,targetCluster,columnList);
  Selector selector=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm=new StringSelector(""String_Node_Str"");
  Selector selector2=new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Selector rightTerm2=new StringSelector(""String_Node_Str"");
  Relation relation2=new Relation(selector2,Operator.EQ,rightTerm2);
  Filter filter2=new Filter(Operations.FILTER_INDEXED_EQ,relation2);
  Relation relation=new Relation(selector,Operator.EQ,rightTerm);
  Filter filter=new Filter(Operations.FILTER_NON_INDEXED_EQ,relation);
  Map<Selector,String> aliasColumns=new HashMap<>();
  aliasColumns.put(new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),""String_Node_Str"");
  Map<String,ColumnType> typeMap=new HashMap<>();
  Map<Selector,ColumnType> typeMapFromColumnName=new HashMap<>();
  typeMap.put(""String_Node_Str"",ColumnType.VARCHAR);
  typeMapFromColumnName.put(new ColumnSelector(new ColumnName(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")),ColumnType.VARCHAR);
  Select aliasSelect=new Select(Operations.SELECT_LIMIT,aliasColumns,typeMap,typeMapFromColumnName);
  filter2.setNextStep(aliasSelect);
  filter.setNextStep(filter2);
  project.setNextStep(filter);
  logicalSteps.add(project);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions,100);
  QueryResult qr=null;
  try {
    qr=cqe.execute(workflow);
  }
 catch (  ConnectorException e) {
    Assert.fail(e.getMessage());
  }
  String value=""String_Node_Str"";
  try {
    for (    Row row : qr.getResultSet()) {
      Cell cell=row.getCell(""String_Node_Str"");
      value=cell.getValue().toString();
    }
    assertEquals(value,""String_Node_Str"",""String_Node_Str"");
    assertEquals(cqe.parseQuery(),""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception ex) {
    Assert.fail(""String_Node_Str"");
  }
}"
11205,"/** 
 * Controls if there is a session started for a cluster name.
 * @param name: cluster name.
 * @return if the connector is connected to the cluster.
 */
@Override public boolean isConnected(ClusterName name){
  boolean connected;
  if (sessions.get(name.getName()) != null) {
    if (sessions.get(name.getName()).getCluster() != null) {
      connected=true;
    }
 else {
      connected=false;
    }
  }
 else {
    connected=false;
  }
  return connected;
}","/** 
 * Controls if there is a session started for a cluster name.
 * @param name cluster name.
 * @return if the connector is connected to the cluster.
 */
@Override public boolean isConnected(ClusterName name){
  boolean connected;
  if (sessions.get(name.getName()) != null) {
    if (sessions.get(name.getName()).getCluster() != null) {
      connected=true;
    }
 else {
      connected=false;
    }
  }
 else {
    connected=false;
  }
  return connected;
}"
11206,"/** 
 * Main method that start the connector and controls the unexpected shutdowns
 * @param args
 */
public static void main(String[] args){
  CassandraConnector cassandraConnector=new CassandraConnector();
  ConnectorApp connectorApp=new ConnectorApp();
  connectorApp.startup(cassandraConnector);
  cassandraConnector.attachShutDownHook();
}","/** 
 * Main method that start the connector and controls the unexpected shutdowns.
 * @param args
 */
public static void main(String[] args){
  CassandraConnector cassandraConnector=new CassandraConnector();
  ConnectorApp connectorApp=new ConnectorApp();
  connectorApp.startup(cassandraConnector);
  cassandraConnector.attachShutDownHook();
}"
11207,"/** 
 * Close at the moment all the sessions of the connector
 */
public void uncontrolledShutdown(){
  for (  Session s : sessions.values()) {
    s.close();
  }
  sessions=new HashMap<>();
}","/** 
 * Close at the moment all the sessions of the connector.
 */
public void uncontrolledShutdown(){
  for (  Session s : sessions.values()) {
    s.close();
  }
  sessions=new HashMap<>();
}"
11208,"/** 
 * Close the session of the cluster name specified.
 * @param name: Name of the cluster.
 * @throws ConnectionException
 */
@Override public void close(ClusterName name) throws ConnectionException {
  sessions.get(name.getName()).close();
  sessions.remove(name.getName());
}","/** 
 * Close the session of the cluster name specified.
 * @param name Name of the cluster.
 * @throws ConnectionException
 */
@Override public void close(ClusterName name) throws ConnectionException {
  sessions.get(name.getName()).close();
  sessions.remove(name.getName());
}"
11209,"/** 
 * Connect Method: Enabled the connector with his own configuration
 * @param credentials: The credentials.
 * @param config: The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (clusterOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(clusterOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","/** 
 * Connect Method: Enabled the connector with his own configuration.
 * @param credentials The credentials.
 * @param config The cluster config
 * @throws ConnectionException
 */
@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (clusterOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(clusterOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11210,"/** 
 * Class constructor.
 * @param tableMetadata  The metadata of the table.
 * @param primaryKey     The list of columns that are part of the primary key.
 * @param clusterKey     The list of columns that are part of the clustering key.
 * @param primaryKeyType The type of primary key.
 */
public CreateTableStatement(TableMetadata tableMetadata,List<ColumnName> primaryKey,List<ColumnName> partitionKey,List<ColumnName> clusterKey,int primaryKeyType,String properties,boolean ifNotExists) throws ExecutionException {
  this.tableName=tableMetadata.getName().getName();
  this.catalog=tableMetadata.getName().getCatalogName().getName();
  this.catalogInc=true;
  this.tableColumns=tableMetadata.getColumns();
  this.primaryKey=primaryKey;
  this.clusterKey=clusterKey;
  this.primaryKeyType=primaryKeyType;
  this.ifNotExists=ifNotExists;
  if (properties.length() > 0) {
    this.withProperties=true;
    this.properties=properties;
  }
  if (partitionKey == null || partitionKey.size() == 0) {
    throw new ExecutionException(""String_Node_Str"");
  }
 else   if (clusterKey == null && primaryKeyType == PRIMARY_AND_CLUSTERING_SPECIFIED) {
    throw new ExecutionException(""String_Node_Str"");
  }
}","/** 
 * Class Constructor.
 * @param tableMetadata  The metadata of the table.
 * @param primaryKey The primary key of the table.
 * @param partitionKey The partition key of the table.
 * @param clusterKey The cluster key of the table.
 * @param primaryKeyType The type of the primary key of the table.
 * @param properties The specific properties of the table that will be created.
 * @param ifNotExists the condition of creation of the table.
 * @throws ExecutionException
 */
public CreateTableStatement(TableMetadata tableMetadata,List<ColumnName> primaryKey,List<ColumnName> partitionKey,List<ColumnName> clusterKey,int primaryKeyType,String properties,boolean ifNotExists) throws ExecutionException {
  this.tableName=tableMetadata.getName().getName();
  this.catalog=tableMetadata.getName().getCatalogName().getName();
  this.catalogInc=true;
  this.tableColumns=tableMetadata.getColumns();
  this.primaryKey=primaryKey;
  this.clusterKey=clusterKey;
  this.primaryKeyType=primaryKeyType;
  this.ifNotExists=ifNotExists;
  if (properties.length() > 0) {
    this.withProperties=true;
    this.properties=properties;
  }
  if (partitionKey == null || partitionKey.size() == 0) {
    throw new ExecutionException(""String_Node_Str"");
  }
 else   if (clusterKey == null && primaryKeyType == PRIMARY_AND_CLUSTERING_SPECIFIED) {
    throw new ExecutionException(""String_Node_Str"");
  }
}"
11211,"/** 
 * Get the value
 * @return String with the value of a Column.
 */
public String getValue(){
  return value;
}","/** 
 * Get the value.
 * @return String with the value of a Column.
 */
public String getValue(){
  return value;
}"
11212,"/** 
 * Get the type
 * @return ColumnType
 */
public ColumnType getType(){
  return type;
}","/** 
 * Get the type.
 * @return ColumnType
 */
public ColumnType getType(){
  return type;
}"
11213,"/** 
 * Set the type
 * @param type
 */
public void setType(ColumnType type){
  this.type=type;
}","/** 
 * Set the type.
 * @param type
 */
public void setType(ColumnType type){
  this.type=type;
}"
11214,"/** 
 * Get the name of the index. If a LUCENE index is to be created, the name of the index is prepended with   {@code stratio_lucene_}. If a name for the index is not specified, the index will be named using the concatenation of the target column names.
 * @return The name of the index.
 */
private String getIndexName(){
  String result=null;
  if (name == null) {
    StringBuilder sb=new StringBuilder();
    if (IndexType.FULL_TEXT.equals(type)) {
      sb.append(""String_Node_Str"");
      sb.append(tableName);
    }
 else {
      sb.append(tableName);
      for (      Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
        sb.append(""String_Node_Str"");
        sb.append(entry.getValue());
      }
      sb.append(""String_Node_Str"");
    }
    result=sb.toString();
  }
 else {
    result=name;
    if (IndexType.FULL_TEXT.equals(type)) {
      result=""String_Node_Str"" + name;
    }
  }
  return result;
}","/** 
 * Get the name of the index. If a LUCENE index is to be created, the name of the index is prepended with   {@code stratio_lucene_}. If a name for the index is not specified, the index will be named using the concatenation of the target column names.
 * @return The name of the index.
 */
private String getIndexName(){
  String result=null;
  if (name == null) {
    StringBuilder sb=new StringBuilder();
    if (IndexType.FULL_TEXT.equals(type)) {
      sb.append(""String_Node_Str"");
      for (      ColumnMetadata columnMetadata : targetColumns.values()) {
        sb.append(""String_Node_Str"");
        sb.append(columnMetadata.getName().getName());
      }
      sb.append(tableName);
    }
 else {
      sb.append(tableName);
      for (      Map.Entry<ColumnName,ColumnMetadata> entry : targetColumns.entrySet()) {
        sb.append(""String_Node_Str"");
        sb.append(entry.getValue());
      }
      sb.append(""String_Node_Str"");
    }
    result=sb.toString();
  }
 else {
    result=name;
    if (IndexType.FULL_TEXT.equals(type)) {
      result=name;
    }
  }
  return result;
}"
11215,"/** 
 * Get the name of the connector
 * @return The name.
 */
@Override public String getConnectorName(){
  return connectorName;
}","/** 
 * Get the name of the connector.
 * @return The name.
 */
@Override public String getConnectorName(){
  return connectorName;
}"
11216,"@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (clusterOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULTLIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(clusterOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (clusterOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULT_LIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(clusterOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11217,"@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (clusterOptions.get(""String_Node_Str"") == null) {
    defaultLimit=100;
  }
 else {
    defaultLimit=Integer.parseInt(clusterOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}","@Override public void connect(ICredentials credentials,ConnectorClusterConfig config) throws ConnectionException {
  ClusterName clusterName=config.getName();
  Map<String,String> clusterOptions=config.getOptions();
  EngineConfig engineConfig=new EngineConfig();
  engineConfig.setCassandraHosts(clusterOptions.get(""String_Node_Str"").substring(1,clusterOptions.get(""String_Node_Str"").length() - 1).split(""String_Node_Str""));
  engineConfig.setCassandraPort(Integer.parseInt(clusterOptions.get(""String_Node_Str"")));
  engineConfig.setCredentials(credentials);
  if (clusterOptions.get(""String_Node_Str"") == null) {
    defaultLimit=DEFAULTLIMIT;
  }
 else {
    defaultLimit=Integer.parseInt(clusterOptions.get(""String_Node_Str""));
  }
  Engine engine=new Engine(engineConfig);
  LOG.info(""String_Node_Str"");
  sessions.put(clusterName.getName(),engine.getSession());
}"
11218,"private String getLuceneIndex(){
  String indexName=""String_Node_Str"";
  List<ColumnMetadata> columns=session.getCluster().getMetadata().getKeyspace(catalog).getTable(tableName.getName()).getColumns();
  for (  ColumnMetadata column : columns) {
    if (column.getIndex() != null) {
      if (column.getIndex().isCustomIndex()) {
        indexName=column.getIndex().getName();
      }
    }
  }
  return indexName;
}","private String getLuceneIndex(){
  String indexName=""String_Node_Str"";
  List<ColumnMetadata> columns=session.getCluster().getMetadata().getKeyspace(catalog).getTable(tableName.getName()).getColumns();
  for (  ColumnMetadata column : columns) {
    if (column.getIndex() != null) {
      if (column.getIndex().isCustomIndex()) {
        indexName=column.getName();
      }
    }
  }
  return indexName;
}"
11219,"@Override public void createTable(ClusterName targetCluster,TableMetadata tableMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  String tableName=tableMetadata.getName().getQualifiedName();
  Map<Selector,Selector> tableOptions=tableMetadata.getOptions();
  List<ColumnName> primaryKey=tableMetadata.getPrimaryKey();
  List<ColumnName> partitionKey=tableMetadata.getPartitionKey();
  List<ColumnName> clusterKey=tableMetadata.getClusterKey();
  int primaryKeyType;
  if (primaryKey.size() == 1) {
    primaryKeyType=PRIMARY_SINGLE;
  }
 else {
    if (clusterKey.isEmpty()) {
      primaryKeyType=PRIMARY_AND_CLUSTERING_SPECIFIED;
    }
 else {
      primaryKeyType=PRIMARY_COMPOSED;
    }
  }
  Map<ColumnName,com.stratio.meta2.common.metadata.ColumnMetadata> tableColumns=tableMetadata.getColumns();
  String stringOptions=getStringOptions(tableOptions);
  CreateTableStatement tableStatement=new CreateTableStatement(tableName,tableColumns,primaryKey,partitionKey,clusterKey,primaryKeyType,stringOptions,true);
  Result result=CassandraExecutor.execute(tableStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void createTable(ClusterName targetCluster,TableMetadata tableMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  String tableName=tableMetadata.getName().getQualifiedName();
  Map<Selector,Selector> tableOptions=tableMetadata.getOptions();
  List<ColumnName> primaryKey=tableMetadata.getPrimaryKey();
  List<ColumnName> partitionKey=tableMetadata.getPartitionKey();
  List<ColumnName> clusterKey=tableMetadata.getClusterKey();
  int primaryKeyType;
  if (primaryKey.size() == 1) {
    primaryKeyType=PRIMARY_SINGLE;
  }
 else {
    if (clusterKey.isEmpty()) {
      primaryKeyType=PRIMARY_AND_CLUSTERING_SPECIFIED;
    }
 else {
      primaryKeyType=PRIMARY_COMPOSED;
    }
  }
  Map<ColumnName,com.stratio.meta2.common.metadata.ColumnMetadata> tableColumns=tableMetadata.getColumns();
  String stringOptions=getStringOptions(tableOptions);
  CreateTableStatement tableStatement=new CreateTableStatement(tableName,tableColumns,primaryKey,partitionKey,clusterKey,primaryKeyType,stringOptions,true);
  Result result=CassandraExecutor.execute(tableStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
}"
11220,"private String getStringOptions(Map<Selector,Selector> options){
  StringBuilder stringOptions=new StringBuilder();
  if (options.isEmpty()) {
    int i=0;
    for (    Selector keySelector : options.keySet()) {
      StringSelector stringKeySelector=(StringSelector)keySelector;
      StringSelector optionSelector=(StringSelector)options.get(keySelector);
      if (i != 0) {
        stringOptions.append(""String_Node_Str"");
      }
      i=1;
      String key=stringKeySelector.getValue();
      stringOptions.append(getStyleStringOption(key,optionSelector.getValue()));
    }
  }
  return stringOptions.toString();
}","private String getStringOptions(Map<Selector,Selector> options){
  StringBuilder stringOptions=new StringBuilder();
  if (!options.isEmpty()) {
    int i=0;
    for (    Selector keySelector : options.keySet()) {
      StringSelector stringKeySelector=(StringSelector)keySelector;
      StringSelector optionSelector=(StringSelector)options.get(keySelector);
      if (i != 0) {
        stringOptions.append(""String_Node_Str"");
      }
      i=1;
      String key=stringKeySelector.getValue();
      stringOptions.append(getStyleStringOption(key,optionSelector.getValue()));
    }
  }
  return stringOptions.toString();
}"
11221,"@Override public void createCatalog(ClusterName targetCluster,CatalogMetadata catalogMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  String catalogName=catalogMetadata.getName().getQualifiedName();
  Map<Selector,Selector> catalogOptions=catalogMetadata.getOptions();
  String stringOptions=getStringOptions(catalogOptions);
  CreateCatalogStatement catalogStatement=new CreateCatalogStatement(catalogName,true,stringOptions);
  Result result=CassandraExecutor.execute(catalogStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void createCatalog(ClusterName targetCluster,CatalogMetadata catalogMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  String catalogName=catalogMetadata.getName().getQualifiedName();
  Map<Selector,Selector> catalogOptions=catalogMetadata.getOptions();
  String stringOptions=getStringOptions(catalogOptions);
  CreateCatalogStatement catalogStatement=new CreateCatalogStatement(catalogName,true,stringOptions);
  Result result=CassandraExecutor.execute(catalogStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
}"
11222,"@Override public void dropCatalog(ClusterName targetCluster,CatalogName name) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  DropCatalogStatement catalogStatement=new DropCatalogStatement(name.getName(),true);
  Result result=CassandraExecutor.execute(catalogStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void dropCatalog(ClusterName targetCluster,CatalogName name) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  DropCatalogStatement catalogStatement=new DropCatalogStatement(name.getName(),true);
  Result result=CassandraExecutor.execute(catalogStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
}"
11223,"@Override public void createIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  CreateIndexStatement indexStatement=new CreateIndexStatement(indexMetadata,true,session);
  Result result=CassandraExecutor.execute(indexStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void createIndex(ClusterName targetCluster,IndexMetadata indexMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  CreateIndexStatement indexStatement=new CreateIndexStatement(indexMetadata,true,session);
  Result result=CassandraExecutor.execute(indexStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
}"
11224,"@Override public void dropTable(ClusterName targetCluster,TableName name) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  DropTableStatement tableStatement=new DropTableStatement(name.getQualifiedName(),true);
  Result result=CassandraExecutor.execute(tableStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void dropTable(ClusterName targetCluster,TableName name) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  DropTableStatement tableStatement=new DropTableStatement(name.getQualifiedName(),true);
  Result result=CassandraExecutor.execute(tableStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
}"
11225,"@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexName) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexName,true);
  Result result=CassandraExecutor.execute(indexStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void dropIndex(ClusterName targetCluster,IndexMetadata indexName) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  DropIndexStatement indexStatement=new DropIndexStatement(indexName,true);
  Result result=CassandraExecutor.execute(indexStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
}"
11226,"public String parseQuery(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (selectionClause != null) {
    int i=0;
    for (    ColumnName columnName : selectionClause) {
      if (i != 0) {
        sb.append(""String_Node_Str"");
      }
      i=1;
      sb.append(columnName.getName());
    }
  }
  sb.append(""String_Node_Str"");
  if (catalogInc) {
    sb.append(catalog).append(""String_Node_Str"");
  }
  sb.append(tableName.getName());
  if (whereInc) {
    sb.append(""String_Node_Str"");
    int count=0;
    for (    Relation relation : where) {
      if (count > 0) {
        sb.append(""String_Node_Str"");
      }
      count=1;
switch (relation.getOperator()) {
case IN:
case BETWEEN:
        break;
case MATCH:
      String nameIndex=getLuceneIndex();
    sb.append(nameIndex).append(""String_Node_Str"");
  sb.append(getLuceneWhereClause(relation));
sb.append(""String_Node_Str"");
break;
default :
String whereWithQualification=relation.toString();
String parts[]=whereWithQualification.split(""String_Node_Str"");
String columnName=parts[0].substring(parts[0].lastIndexOf(""String_Node_Str"") + 1);
sb.append(columnName);
for (int i=1; i < parts.length; i++) {
sb.append(""String_Node_Str"").append(parts[i]);
}
break;
}
}
}
if (limitInc) {
sb.append(""String_Node_Str"").append(limit);
}
return sb.toString().replace(""String_Node_Str"",""String_Node_Str"");
}","public String parseQuery(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  if (selectionClause != null) {
    sb.append(getSelectionClause());
  }
  sb.append(getFromClause());
  if (whereInc) {
    sb.append(getWhereClause());
  }
  if (limitInc) {
    sb.append(""String_Node_Str"").append(limit);
  }
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"");
}"
11227,"public String getLuceneWhereClause(Relation relation){
  String result;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  String column=relation.getLeftTerm().toString().substring(relation.getLeftTerm().toString().lastIndexOf(""String_Node_Str"") + 1);
  String value=relation.getRightTerm().toString();
  String[] processedQuery=processLuceneQueryType(value);
  sb.append(""String_Node_Str"");
  sb.append(processedQuery[0]);
  sb.append(""String_Node_Str"");
  sb.append(column);
  sb.append(""String_Node_Str"");
  sb.append(processedQuery[1]);
  sb.append(""String_Node_Str"");
  sb.replace(sb.length() - 1,sb.length(),""String_Node_Str"");
  sb.append(""String_Node_Str"");
  result=sb.toString();
  return result;
}","public String getLuceneWhereClause(Relation relation){
  String result;
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  String column=relation.getLeftTerm().toString().substring(relation.getLeftTerm().toString().lastIndexOf('.') + 1);
  String value=relation.getRightTerm().toString();
  String[] processedQuery=processLuceneQueryType(value);
  sb.append(""String_Node_Str"");
  sb.append(processedQuery[0]);
  sb.append(""String_Node_Str"");
  sb.append(column);
  sb.append(""String_Node_Str"");
  sb.append(processedQuery[1]);
  sb.append(""String_Node_Str"");
  sb.replace(sb.length() - 1,sb.length(),""String_Node_Str"");
  sb.append(""String_Node_Str"");
  result=sb.toString();
  return result;
}"
11228,"@Override public com.stratio.meta.common.result.QueryResult execute(LogicalWorkflow workflow) throws UnsupportedException, ExecutionException {
  if (workflow.getInitialSteps().size() > 1) {
    throw new UnsupportedException(""String_Node_Str"");
  }
 else {
    LogicalStep logicalStep=workflow.getInitialSteps().get(0);
    while (logicalStep != null) {
      if (logicalStep instanceof TransformationStep) {
        TransformationStep transformation=(TransformationStep)logicalStep;
        if (transformation instanceof Project) {
          Project project=(Project)transformation;
          session=sessions.get(project.getClusterName().getName());
          tableName=project.getTableName();
          catalogInc=tableName.isCompletedName();
          if (catalogInc) {
            CatalogName catalogName=tableName.getCatalogName();
            catalog=catalogName.getName();
          }
          selectionClause=project.getColumnList();
        }
 else {
          if (transformation instanceof Filter) {
            Filter filter=(Filter)transformation;
            whereInc=true;
            Relation relation=filter.getRelation();
            where.add(relation);
          }
 else           if (transformation instanceof Limit) {
            Limit limitClause=(Limit)transformation;
            limit=limitClause.getLimit();
          }
 else {
            if (transformation instanceof Select) {
              Select select=(Select)transformation;
              aliasColumns=select.getColumnMap();
            }
          }
        }
      }
      logicalStep=logicalStep.getNextStep();
    }
  }
  String query=parseQuery();
  Result result=null;
  if (session != null) {
    if (aliasColumns.isEmpty()) {
      result=CassandraExecutor.execute(query,session);
    }
 else {
      result=CassandraExecutor.execute(query,aliasColumns,session);
    }
  }
 else {
    throw new ExecutionException(""String_Node_Str"");
  }
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
case CRITICAL:
  throw new CriticalExecutionException(error.getErrorMessage());
default :
throw new UnsupportedException(error.getErrorMessage());
}
}
 else {
return (QueryResult)result;
}
}","@Override public com.stratio.meta.common.result.QueryResult execute(LogicalWorkflow workflow) throws UnsupportedException, ExecutionException {
  LogicalStep logicalStep=workflow.getInitialSteps().get(0);
  while (logicalStep != null) {
    if (logicalStep instanceof TransformationStep) {
      getTransformationStep(logicalStep);
    }
    logicalStep=logicalStep.getNextStep();
  }
  String query=parseQuery();
  Result result;
  if (session != null) {
    if (aliasColumns.isEmpty()) {
      result=CassandraExecutor.execute(query,session);
    }
 else {
      result=CassandraExecutor.execute(query,aliasColumns,session);
    }
  }
 else {
    throw new ExecutionException(""String_Node_Str"");
  }
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
    getTypeErrorException(error);
  }
  return (QueryResult)result;
}"
11229,"public void uncontrolledShutdown(){
  List<CloseFuture> closeFutureList=new ArrayList<>();
  for (  Session s : sessions.values()) {
    s.close();
  }
  sessions=new HashMap<>();
}","public void uncontrolledShutdown(){
  for (  Session s : sessions.values()) {
    s.close();
  }
  sessions=new HashMap<>();
}"
11230,"public CassandraConnector(){
  sessions=new HashMap<>();
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    Document d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    this.connectorName=d.getElementsByTagName(""String_Node_Str"").item(0).getTextContent();
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
}","public CassandraConnector(){
  sessions=new HashMap<>();
  try {
    InputStream inputStream=getClass().getResourceAsStream(""String_Node_Str"");
    Document d=DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(inputStream);
    XPathFactory xFactory=XPathFactory.newInstance();
    XPath xpath=xFactory.newXPath();
    Object result;
    XPathExpression expr=null;
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      this.connectorName=((NodeList)result).item(0).getNodeValue();
    }
 catch (    XPathExpressionException e) {
    }
    try {
      expr=xpath.compile(""String_Node_Str"");
      result=expr.evaluate(d,XPathConstants.NODESET);
      limitDefault=Integer.parseInt(((NodeList)result).item(0).getNodeValue());
    }
 catch (    XPathExpressionException e) {
      limitDefault=100;
    }
  }
 catch (  SAXException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.trace(""String_Node_Str"");
  }
catch (  ParserConfigurationException e) {
    LOG.trace(""String_Node_Str"");
  }
}"
11231,"/** 
 * Get the query com.stratio.connector.cassandra.
 * @return An implementation of {@link com.stratio.meta.common.connector.IQueryEngine}.
 * @throws UnsupportedException If the connector does not provide this functionality.
 */
@Override public IQueryEngine getQueryEngine() throws UnsupportedException {
  IQueryEngine queryEngine=new CassandraQueryEngine(sessions);
  return queryEngine;
}","/** 
 * Get the query com.stratio.connector.cassandra.
 * @return An implementation of {@link com.stratio.meta.common.connector.IQueryEngine}.
 * @throws UnsupportedException If the connector does not provide this functionality.
 */
@Override public IQueryEngine getQueryEngine() throws UnsupportedException {
  IQueryEngine queryEngine=new CassandraQueryEngine(sessions,limitDefault);
  return queryEngine;
}"
11232,"@Override public void createTable(ClusterName targetCluster,TableMetadata tableMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  String tableName=tableMetadata.getName().getQualifiedName();
  Map<Selector,Selector> tableOptions=tableMetadata.getOptions();
  List<ColumnName> primaryKey=tableMetadata.getPrimaryKey();
  List<ColumnName> clusterKey=tableMetadata.getClusterKey();
  int primaryKeyType;
  if (primaryKey.size() <= 1) {
    primaryKeyType=PRIMARY_SINGLE;
  }
 else {
    if (clusterKey.size() > 0) {
      primaryKeyType=PRIMARY_AND_CLUSTERING_SPECIFIED;
    }
 else {
      primaryKeyType=PRIMARY_COMPOSED;
    }
  }
  Map<ColumnName,com.stratio.meta2.common.metadata.ColumnMetadata> tableColumns=tableMetadata.getColumns();
  String stringOptions=getStringOptions(tableOptions);
  CreateTableStatement tableStatement=new CreateTableStatement(tableName,tableColumns,primaryKey,clusterKey,primaryKeyType,stringOptions,true);
  Result result=CassandraExecutor.execute(tableStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
default :
  throw new UnsupportedException(error.getErrorMessage());
}
}
}","@Override public void createTable(ClusterName targetCluster,TableMetadata tableMetadata) throws UnsupportedException, ExecutionException {
  session=sessions.get(targetCluster.getName());
  String tableName=tableMetadata.getName().getQualifiedName();
  Map<Selector,Selector> tableOptions=tableMetadata.getOptions();
  List<ColumnName> primaryKey=tableMetadata.getPrimaryKey();
  List<ColumnName> partitionKey=tableMetadata.getPartitionKey();
  List<ColumnName> clusterKey=tableMetadata.getClusterKey();
  int primaryKeyType;
  if (primaryKey.size() == 1) {
    primaryKeyType=PRIMARY_SINGLE;
  }
 else {
    if (clusterKey.size() > 0) {
      primaryKeyType=PRIMARY_AND_CLUSTERING_SPECIFIED;
    }
 else {
      primaryKeyType=PRIMARY_COMPOSED;
    }
  }
  Map<ColumnName,com.stratio.meta2.common.metadata.ColumnMetadata> tableColumns=tableMetadata.getColumns();
  String stringOptions=getStringOptions(tableOptions);
  CreateTableStatement tableStatement=new CreateTableStatement(tableName,tableColumns,primaryKey,partitionKey,clusterKey,primaryKeyType,stringOptions,true);
  Result result=CassandraExecutor.execute(tableStatement.toString(),session);
  if (result.hasError()) {
    ErrorResult error=(ErrorResult)result;
switch (error.getType()) {
case EXECUTION:
      throw new ExecutionException(error.getErrorMessage());
case NOT_SUPPORTED:
    throw new UnsupportedException(error.getErrorMessage());
default :
  throw new UnsupportedException(error.getErrorMessage());
}
}
}"
11233,"public CassandraQueryEngine(Map<String,Session> sessions){
  this.sessions=sessions;
}","public CassandraQueryEngine(Map<String,Session> sessions,int limitDefault){
  this.sessions=sessions;
  this.limit=limitDefault;
}"
11234,"/** 
 * Class constructor.
 * @param tableName      The name of the table.
 * @param tableColumns   A map with the name of the columns in the table and the associated data type.
 * @param primaryKey     The list of columns that are part of the primary key.
 * @param clusterKey     The list of columns that are part of the clustering key.
 * @param primaryKeyType The type of primary key.
 */
public CreateTableStatement(String tableName,Map<ColumnName,ColumnMetadata> tableColumns,List<ColumnName> primaryKey,List<ColumnName> clusterKey,int primaryKeyType,String properties,boolean ifNotExists) throws ExecutionException {
  if (tableName.contains(""String_Node_Str"")) {
    String[] ksAndTablename=tableName.split(""String_Node_Str"");
    catalog=ksAndTablename[0];
    this.tableName=ksAndTablename[1];
    catalogInc=true;
  }
 else {
    this.tableName=tableName;
  }
  this.tableColumns=tableColumns;
  this.primaryKey=primaryKey;
  this.clusterKey=clusterKey;
  this.primaryKeyType=primaryKeyType;
  this.ifNotExists=ifNotExists;
  if (properties.length() > 0) {
    this.withProperties=true;
    this.properties=properties;
  }
  if (primaryKey == null || primaryKey.size() == 0) {
    throw new ExecutionException(""String_Node_Str"");
  }
 else   if (clusterKey == null && primaryKeyType == PRIMARY_AND_CLUSTERING_SPECIFIED) {
    throw new ExecutionException(""String_Node_Str"");
  }
}","/** 
 * Class constructor.
 * @param tableName      The name of the table.
 * @param tableColumns   A map with the name of the columns in the table and the associated data type.
 * @param primaryKey     The list of columns that are part of the primary key.
 * @param clusterKey     The list of columns that are part of the clustering key.
 * @param primaryKeyType The type of primary key.
 */
public CreateTableStatement(String tableName,Map<ColumnName,ColumnMetadata> tableColumns,List<ColumnName> primaryKey,List<ColumnName> partitionKey,List<ColumnName> clusterKey,int primaryKeyType,String properties,boolean ifNotExists) throws ExecutionException {
  if (tableName.contains(""String_Node_Str"")) {
    String[] ksAndTablename=tableName.split(""String_Node_Str"");
    catalog=ksAndTablename[0];
    this.tableName=ksAndTablename[1];
    catalogInc=true;
  }
 else {
    this.tableName=tableName;
  }
  this.tableColumns=tableColumns;
  this.primaryKey=primaryKey;
  this.clusterKey=clusterKey;
  this.primaryKeyType=primaryKeyType;
  this.ifNotExists=ifNotExists;
  if (properties.length() > 0) {
    this.withProperties=true;
    this.properties=properties;
  }
  if (partitionKey == null || partitionKey.size() == 0) {
    throw new ExecutionException(""String_Node_Str"");
  }
 else   if (clusterKey == null && primaryKeyType == PRIMARY_AND_CLUSTERING_SPECIFIED) {
    throw new ExecutionException(""String_Node_Str"");
  }
}"
11235,"/** 
 * Generate the Lucene options schema that corresponds with the selected column.
 * @return The JSON representation of the Lucene schema.
 */
protected String generateLuceneSchema(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  ColumnMetadata column : targetColumns) {
    sb.append(column.getName().getName());
    sb.append(""String_Node_Str"");
    sb.append(luceneTypes.get(column.getColumnType().getDbType()));
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Generate the Lucene options schema that corresponds with the selected column.
 * @return The JSON representation of the Lucene schema.
 */
protected String generateLuceneSchema(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  ColumnMetadata column : targetColumns) {
    sb.append(column.getName().getName());
    sb.append(""String_Node_Str"");
    sb.append(luceneTypes.get(column.getColumnType().name()));
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"");
}"
11236,"public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session){
  targetColumns=new ArrayList<>();
  this.parameters=indexMetadata.getOptions();
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=targetColumns.get(0).getName().getTableName().getName();
  this.keyspace=targetColumns.get(0).getName().getTableName().getCatalogName().getName();
  if (keyspace != null)   this.keyspaceIncluded=true;
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    options=generateLuceneOptions();
    try {
      session.execute(""String_Node_Str"" + this.tableName + ""String_Node_Str""+ getIndexName()+ ""String_Node_Str"");
    }
 catch (    Exception e) {
    }
  }
}","public CreateIndexStatement(IndexMetadata indexMetadata,boolean createIfNotExists,Session session) throws ExecutionException {
  targetColumns=new ArrayList<>();
  this.parameters=indexMetadata.getOptions();
  this.targetColumns=indexMetadata.getColumns();
  this.createIfNotExists=createIfNotExists;
  this.type=indexMetadata.getType();
  this.tableName=targetColumns.get(0).getName().getTableName().getName();
  this.keyspace=targetColumns.get(0).getName().getTableName().getCatalogName().getName();
  if (keyspace != null)   this.keyspaceIncluded=true;
  this.name=indexMetadata.getName().getName();
  if (type == IndexType.FULL_TEXT) {
    usingClass=""String_Node_Str"";
    options=generateLuceneOptions();
    try {
      session.execute(""String_Node_Str"" + targetColumns.get(0).getName().getTableName() + ""String_Node_Str""+ getIndexName()+ ""String_Node_Str"");
    }
 catch (    Exception e) {
      throw new ExecutionException(""String_Node_Str"" + e.getMessage());
    }
  }
}"
11237,"/** 
 * Get the name of the datastore required by the connector.
 * @return The name.
 */
@Override public String getDatastoreName(){
  return ""String_Node_Str"";
}","/** 
 * Get the name of the datastore required by the connector.
 * @return The name.
 */
@Override public String[] getDatastoreName(){
  return new String[]{""String_Node_Str""};
}"
11238,"@Test public void basicSelect(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  CatalogName catalogName=new CatalogName(""String_Node_Str"");
  TableName tableName=new TableName(""String_Node_Str"",catalogName.getName());
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(""String_Node_Str"",tableName,columnList);
  Selector identifier=new ColumnSelector(columnName);
  Term term=new StringTerm(""String_Node_Str"");
  List<Term<?>> terms=new ArrayList<>();
  terms.add(term);
  Relation relation=new Relation(identifier,Operator.LIKE,terms);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  project.setNextStep(filter);
  logicalSteps.add(project);
  logicalSteps.add(filter);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions);
  try {
    QueryResult qr=cqe.execute(targetCluster,workflow);
    String value=""String_Node_Str"";
    for (    Row row : qr.getResultSet()) {
      Cell cell=row.getCell(""String_Node_Str"");
      value=cell.getValue().toString();
    }
    assertEquals(value,""String_Node_Str"");
  }
 catch (  UnsupportedException e) {
    e.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  assertEquals(cqe.parseQuery(),""String_Node_Str"");
}","@Test public void basicSelect(){
  ClusterName targetCluster=new ClusterName(""String_Node_Str"");
  List<LogicalStep> logicalSteps=new ArrayList<>();
  TableName tableName=new TableName(""String_Node_Str"",""String_Node_Str"");
  List<ColumnName> columnList=new ArrayList<>();
  ColumnName columnName=new ColumnName(tableName,""String_Node_Str"");
  columnList.add(columnName);
  Project project=new Project(tableName,columnList);
  Selector identifier=new ColumnSelector(columnName);
  Term term=new StringTerm(""String_Node_Str"");
  List<Term<?>> terms=new ArrayList<>();
  terms.add(term);
  Relation relation=new Relation(identifier,Operator.LIKE,terms);
  Filter filter=new Filter(Operations.SELECT_LIMIT,relation);
  project.setNextStep(filter);
  logicalSteps.add(project);
  logicalSteps.add(filter);
  LogicalWorkflow workflow=new LogicalWorkflow(logicalSteps);
  Map<String,Session> sessions=new HashMap<>();
  sessions.put(""String_Node_Str"",this._session);
  CassandraQueryEngine cqe=new CassandraQueryEngine(sessions);
  try {
    QueryResult qr=cqe.execute(targetCluster,workflow);
    String value=""String_Node_Str"";
    for (    Row row : qr.getResultSet()) {
      Cell cell=row.getCell(""String_Node_Str"");
      value=cell.getValue().toString();
    }
    assertEquals(value,""String_Node_Str"");
  }
 catch (  UnsupportedException e) {
    e.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  assertEquals(cqe.parseQuery(),""String_Node_Str"");
}"
11239,"public Query parse(String aQuery,String aSearchField) throws IOException {
  QueryTokenizer theTokenizer=new QueryTokenizer(aQuery);
  BooleanQuery theResult=new BooleanQuery();
  if (!theTokenizer.getNotRequiredTerms().isEmpty()) {
    List<SpanQuery> theSpans=new ArrayList<>();
    for (    String theTerm : theTokenizer.getRequiredTerms()) {
      if (QueryUtils.isWildCard(theTerm)) {
        theSpans.add(new SpanMultiTermQueryWrapper<>(new WildcardQuery(new Term(aSearchField,theTerm))));
      }
 else       if (QueryUtils.isFuzzy(theTerm)) {
        theSpans.add(new SpanMultiTermQueryWrapper<>(new FuzzyQuery(new Term(aSearchField,theTerm))));
      }
 else {
        String theTokenizedTerm=toToken(theTerm,aSearchField);
        if (!StringUtils.isEmpty(theTokenizedTerm)) {
          theSpans.add(new SpanTermQuery(new Term(aSearchField,theTokenizedTerm)));
        }
      }
    }
    SpanQuery theExactMatchQuery=new SpanNearQuery(theSpans.toArray(new SpanQuery[theSpans.size()]),0,true);
    theExactMatchQuery.setBoost(61);
    theResult.add(theExactMatchQuery,BooleanClause.Occur.SHOULD);
    int theMaxEditDistance=10;
    for (int theSlop=0; theSlop < theMaxEditDistance; theSlop++) {
      SpanQuery theNearQuery=new SpanNearQuery(theSpans.toArray(new SpanQuery[theSpans.size()]),theSlop,false);
      theNearQuery.setBoost(50 + theMaxEditDistance - theSlop);
      theResult.add(theNearQuery,BooleanClause.Occur.SHOULD);
    }
    for (    String theTerm : theTokenizer.getRequiredTerms()) {
      if (QueryUtils.isWildCard(theTerm)) {
        theResult.add(new WildcardQuery(new Term(aSearchField,toToken(theTerm,aSearchField))),BooleanClause.Occur.MUST);
      }
 else       if (QueryUtils.isFuzzy(theTerm)) {
        theResult.add(new FuzzyQuery(new Term(aSearchField,theTerm)),BooleanClause.Occur.MUST);
      }
 else {
        String theTokenizedTerm=toToken(theTerm,aSearchField);
        if (!StringUtils.isEmpty(theTokenizedTerm)) {
          theResult.add(new TermQuery(new Term(aSearchField,theTokenizedTerm)),BooleanClause.Occur.MUST);
        }
      }
    }
  }
  for (  String theTerm : theTokenizer.getNotRequiredTerms()) {
    if (QueryUtils.isWildCard(theTerm)) {
      theResult.add(new WildcardQuery(new Term(aSearchField,theTerm)),BooleanClause.Occur.MUST_NOT);
    }
 else     if (QueryUtils.isFuzzy(theTerm)) {
      theResult.add(new FuzzyQuery(new Term(aSearchField,theTerm)),BooleanClause.Occur.MUST_NOT);
    }
 else {
      String theTokenizedTerm=toToken(theTerm,aSearchField);
      if (!StringUtils.isEmpty(theTokenizedTerm)) {
        theResult.add(new TermQuery(new Term(aSearchField,theTokenizedTerm)),BooleanClause.Occur.MUST_NOT);
      }
    }
  }
  return theResult;
}","public Query parse(String aQuery,String aSearchField) throws IOException {
  QueryTokenizer theTokenizer=new QueryTokenizer(aQuery);
  BooleanQuery theResult=new BooleanQuery();
  if (!theTokenizer.getRequiredTerms().isEmpty()) {
    List<SpanQuery> theSpans=new ArrayList<>();
    for (    String theTerm : theTokenizer.getRequiredTerms()) {
      if (QueryUtils.isWildCard(theTerm)) {
        theSpans.add(new SpanMultiTermQueryWrapper<>(new WildcardQuery(new Term(aSearchField,theTerm))));
      }
 else       if (QueryUtils.isFuzzy(theTerm)) {
        theSpans.add(new SpanMultiTermQueryWrapper<>(new FuzzyQuery(new Term(aSearchField,theTerm))));
      }
 else {
        String theTokenizedTerm=toToken(theTerm,aSearchField);
        if (!StringUtils.isEmpty(theTokenizedTerm)) {
          theSpans.add(new SpanTermQuery(new Term(aSearchField,theTokenizedTerm)));
        }
      }
    }
    SpanQuery theExactMatchQuery=new SpanNearQuery(theSpans.toArray(new SpanQuery[theSpans.size()]),0,true);
    theExactMatchQuery.setBoost(61);
    theResult.add(theExactMatchQuery,BooleanClause.Occur.SHOULD);
    int theMaxEditDistance=10;
    for (int theSlop=0; theSlop < theMaxEditDistance; theSlop++) {
      SpanQuery theNearQuery=new SpanNearQuery(theSpans.toArray(new SpanQuery[theSpans.size()]),theSlop,false);
      theNearQuery.setBoost(50 + theMaxEditDistance - theSlop);
      theResult.add(theNearQuery,BooleanClause.Occur.SHOULD);
    }
    addToBooleanQuery(theTokenizer.getRequiredTerms(),aSearchField,theResult,BooleanClause.Occur.MUST);
  }
  addToBooleanQuery(theTokenizer.getNotRequiredTerms(),aSearchField,theResult,BooleanClause.Occur.MUST_NOT);
  return theResult;
}"
11240,"DesktopGateway(Stage aStage){
  stage=aStage;
}","DesktopGateway(Application aApplication){
  application=aApplication;
}"
11241,"public void openFile(String aFile){
  if (Desktop.isDesktopSupported()) {
    if (Platform.isFxApplicationThread()) {
      LOGGER.info(""String_Node_Str"");
      new Thread(() -> open(aFile),""String_Node_Str"").start();
    }
 else {
      LOGGER.info(""String_Node_Str"");
      open(aFile);
    }
  }
 else {
    LOGGER.error(""String_Node_Str"");
  }
}","public void openFile(String aFile){
  application.getHostServices().showDocument(aFile);
}"
11242,"public LuceneIndexHandler(Configuration aConfiguration,AnalyzerCache aAnalyzerCache,ExecutorPool aExecutorPool) throws IOException {
  configuration=aConfiguration;
  analyzerCache=aAnalyzerCache;
  executorPool=aExecutorPool;
  contentFieldType=new FieldType();
  contentFieldType.setIndexed(true);
  contentFieldType.setStored(true);
  contentFieldType.setTokenized(true);
  contentFieldType.setStoreTermVectorOffsets(true);
  contentFieldType.setStoreTermVectorPayloads(true);
  contentFieldType.setStoreTermVectorPositions(true);
  contentFieldType.setStoreTermVectors(true);
  contentFieldType.setIndexOptions(FieldInfo.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
  analyzer=analyzerCache.getAnalyzer();
  File theIndexDirectory=new File(aConfiguration.getConfigDirectory(),""String_Node_Str"");
  theIndexDirectory.mkdirs();
  Directory theIndexFSDirectory=new NRTCachingDirectory(FSDirectory.open(theIndexDirectory),100,100);
  try {
    theIndexFSDirectory.clearLock(IndexWriter.WRITE_LOCK_NAME);
  }
 catch (  IOException e) {
  }
  File theSuggestDirectory=new File(aConfiguration.getConfigDirectory(),""String_Node_Str"");
  theSuggestDirectory.mkdirs();
  Directory theSuggestFSDirectory=FSDirectory.open(theSuggestDirectory);
  try {
    theSuggestFSDirectory.clearLock(IndexWriter.WRITE_LOCK_NAME);
  }
 catch (  IOException e) {
  }
  IndexWriterConfig theConfig=new IndexWriterConfig(IndexFields.LUCENE_VERSION,analyzer);
  theConfig.setSimilarity(new CustomSimilarity());
  indexWriter=new IndexWriter(theIndexFSDirectory,theConfig);
  searcherManager=new SearcherManager(indexWriter,true,new SearcherFactory());
  commitThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      while (!isInterrupted()) {
        if (indexWriter.hasUncommittedChanges()) {
          try {
            indexWriter.commit();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
;
  commitThread.start();
  facetsConfig=new FacetsConfig();
}","public LuceneIndexHandler(Configuration aConfiguration,AnalyzerCache aAnalyzerCache,ExecutorPool aExecutorPool) throws IOException {
  configuration=aConfiguration;
  analyzerCache=aAnalyzerCache;
  executorPool=aExecutorPool;
  contentFieldType=new FieldType();
  contentFieldType.setIndexed(true);
  contentFieldType.setStored(true);
  contentFieldType.setTokenized(true);
  contentFieldType.setStoreTermVectorOffsets(true);
  contentFieldType.setStoreTermVectorPayloads(true);
  contentFieldType.setStoreTermVectorPositions(true);
  contentFieldType.setStoreTermVectors(true);
  contentFieldType.setIndexOptions(FieldInfo.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
  analyzer=analyzerCache.getAnalyzer();
  File theIndexDirectory=new File(aConfiguration.getConfigDirectory(),""String_Node_Str"");
  theIndexDirectory.mkdirs();
  Directory theIndexFSDirectory=new NRTCachingDirectory(FSDirectory.open(theIndexDirectory),100,100);
  try {
    theIndexFSDirectory.clearLock(IndexWriter.WRITE_LOCK_NAME);
  }
 catch (  IOException e) {
  }
  IndexWriterConfig theConfig=new IndexWriterConfig(IndexFields.LUCENE_VERSION,analyzer);
  theConfig.setSimilarity(new CustomSimilarity());
  indexWriter=new IndexWriter(theIndexFSDirectory,theConfig);
  searcherManager=new SearcherManager(indexWriter,true,new SearcherFactory());
  commitThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      while (!isInterrupted()) {
        if (indexWriter.hasUncommittedChanges()) {
          try {
            indexWriter.commit();
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
;
  commitThread.start();
  facetsConfig=new FacetsConfig();
}"
11243,"public static boolean isWildCard(String aTerm){
  return aTerm.contains(""String_Node_Str"") || aTerm.contains(""String_Node_Str"");
}","public static boolean isWildCard(String aTerm){
  return aTerm.contains(ASTERISK) || aTerm.contains(""String_Node_Str"");
}"
11244,"private List<String> toTokens(String aFieldName,String aPhrase) throws IOException {
  List<String> theTokens=new ArrayList<>();
  TokenStream theTokenStream=analyzer.tokenStream(aFieldName,aPhrase);
  theTokenStream.reset();
  CharTermAttribute theCharTerms=theTokenStream.getAttribute(CharTermAttribute.class);
  while (theTokenStream.incrementToken()) {
    theTokens.add(theCharTerms.toString());
  }
  theTokenStream.end();
  theTokenStream.close();
  return theTokens;
}","private List<String> toTokens(String aFieldName,String aPhrase) throws IOException {
  List<String> theTokens=new ArrayList<>();
  String[] theSplitTokens=StringUtils.split(aPhrase,""String_Node_Str"");
  for (int i=0; i < theSplitTokens.length; i++) {
    String theToken=theSplitTokens[i];
    if (theToken.length() > 2 && i == theSplitTokens.length - 1 && !QueryUtils.isWildCard(theToken)) {
      theToken=theToken + QueryUtils.ASTERISK;
    }
    if (!theToken.startsWith(""String_Node_Str"")) {
      if (QueryUtils.isWildCard(theToken)) {
        theTokens.add(theToken);
      }
 else {
        String theAnalyzed=analyze(aFieldName,theToken);
        if (theAnalyzed != null) {
          theTokens.add(theAnalyzed);
        }
      }
    }
  }
  return theTokens;
}"
11245,"public List<Suggestion> suggestSearchPhrase(String aFieldName,String aPhrase) throws IOException {
  List<String> theTokens=toTokens(aFieldName,aPhrase);
  List<SpanQuery> theSpanQueries=theTokens.stream().map(s -> {
    if (QueryUtils.isWildCard(s)) {
      WildcardQuery theWildcardQuery=new WildcardQuery(new Term(aFieldName,s));
      SpanMultiTermQueryWrapper theWrapper=new SpanMultiTermQueryWrapper(theWildcardQuery);
      try {
        return theWrapper.getRewriteMethod().rewrite(indexReader,theWildcardQuery);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
    return new SpanTermQuery(new Term(aFieldName,s));
  }
).collect(Collectors.toList());
  SpanQuery theSpanQuery=new SpanNearQuery(theSpanQueries.toArray(new SpanQuery[theSpanQueries.size()]),configuration.getSuggestionSlop(),configuration.isSuggestionInOrder());
  AtomicReader theAtomicReader=SlowCompositeReaderWrapper.wrap(indexReader);
  Map<Term,TermContext> theTermContexts=new HashMap<>();
  Map<String,Long> theSpanFrequencies=new HashMap<>();
  Spans theMatchingSpans=theSpanQuery.getSpans(theAtomicReader.getContext(),new Bits.MatchAllBits(indexReader.numDocs()),theTermContexts);
  while (theMatchingSpans.next()) {
    Map<Integer,String> theEntries=new TreeMap<>();
    Terms theAllTermsFromDocument=indexReader.getTermVector(theMatchingSpans.doc(),IndexFields.CONTENT_NOT_STEMMED);
    int theSpanStart=theMatchingSpans.start() - configuration.getSuggestionWindowBefore();
    int theSpanEnd=theMatchingSpans.end() + configuration.getSuggestionWindowAfter();
    TermsEnum theTermsEnum=theAllTermsFromDocument.iterator(null);
    BytesRef theTerm;
    while ((theTerm=theTermsEnum.next()) != null) {
      DocsAndPositionsEnum thePositionEnum=theTermsEnum.docsAndPositions(null,null);
      if (thePositionEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
        int i=0;
        int position;
        while (i < thePositionEnum.freq() && (position=thePositionEnum.nextPosition()) != -1) {
          if (position >= theSpanStart && position <= theSpanEnd) {
            theEntries.put(position,theTerm.utf8ToString());
          }
          i++;
        }
      }
    }
    StringBuilder theResultString=new StringBuilder();
    theEntries.entrySet().forEach(e -> {
      if (theResultString.length() > 0) {
        theResultString.append(""String_Node_Str"");
      }
      theResultString.append(e.getValue());
    }
);
    String theTotalSpan=theResultString.toString().trim();
    Long theFrequency=theSpanFrequencies.get(theTotalSpan);
    if (theFrequency == null) {
      theSpanFrequencies.put(theTotalSpan,1L);
    }
 else {
      theSpanFrequencies.put(theTotalSpan,theFrequency + 1);
    }
  }
  return theSpanFrequencies.entrySet().stream().filter(t -> t.getValue() > 1).sorted((o1,o2) -> o2.getValue().compareTo(o1.getValue())).limit(configuration.getNumberOfSuggestions()).map(T -> new Suggestion(highlight(T.getKey(),theTokens),T.getKey())).collect(Collectors.toList());
}","public List<Suggestion> suggestSearchPhrase(String aFieldName,String aPhrase) throws IOException {
  LOGGER.info(""String_Node_Str"" + aPhrase);
  long theStartTime=System.currentTimeMillis();
  try {
    List<String> theTokens=toTokens(aFieldName,aPhrase);
    List<SpanQuery> theSpanQueries=theTokens.stream().map(s -> {
      if (QueryUtils.isWildCard(s)) {
        WildcardQuery theWildcardQuery=new WildcardQuery(new Term(aFieldName,s));
        SpanMultiTermQueryWrapper theWrapper=new SpanMultiTermQueryWrapper(theWildcardQuery);
        try {
          return theWrapper.getRewriteMethod().rewrite(indexReader,theWildcardQuery);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
      return new SpanTermQuery(new Term(aFieldName,s));
    }
).collect(Collectors.toList());
    SpanQuery theSpanQuery=new SpanNearQuery(theSpanQueries.toArray(new SpanQuery[theSpanQueries.size()]),configuration.getSuggestionSlop(),configuration.isSuggestionInOrder());
    LOGGER.info(""String_Node_Str"" + theSpanQuery);
    AtomicReader theAtomicReader=SlowCompositeReaderWrapper.wrap(indexReader);
    Map<Term,TermContext> theTermContexts=new HashMap<>();
    Map<String,Long> theSpanFrequencies=new HashMap<>();
    Spans theMatchingSpans=theSpanQuery.getSpans(theAtomicReader.getContext(),new Bits.MatchAllBits(indexReader.numDocs()),theTermContexts);
    while (theMatchingSpans.next()) {
      Map<Integer,String> theEntries=new TreeMap<>();
      Terms theAllTermsFromDocument=indexReader.getTermVector(theMatchingSpans.doc(),IndexFields.CONTENT_NOT_STEMMED);
      int theSpanStart=theMatchingSpans.start() - configuration.getSuggestionWindowBefore();
      int theSpanEnd=theMatchingSpans.end() + configuration.getSuggestionWindowAfter();
      TermsEnum theTermsEnum=theAllTermsFromDocument.iterator(null);
      BytesRef theTerm;
      while ((theTerm=theTermsEnum.next()) != null) {
        DocsAndPositionsEnum thePositionEnum=theTermsEnum.docsAndPositions(null,null);
        if (thePositionEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
          int i=0;
          int position;
          while (i < thePositionEnum.freq() && (position=thePositionEnum.nextPosition()) != -1) {
            if (position >= theSpanStart && position <= theSpanEnd) {
              theEntries.put(position,theTerm.utf8ToString());
            }
            i++;
          }
        }
      }
      StringBuilder theResultString=new StringBuilder();
      theEntries.entrySet().forEach(e -> {
        if (theResultString.length() > 0) {
          theResultString.append(""String_Node_Str"");
        }
        theResultString.append(e.getValue());
      }
);
      String theTotalSpan=theResultString.toString().trim();
      Long theFrequency=theSpanFrequencies.get(theTotalSpan);
      if (theFrequency == null) {
        theSpanFrequencies.put(theTotalSpan,1L);
      }
 else {
        theSpanFrequencies.put(theTotalSpan,theFrequency + 1);
      }
    }
    return theSpanFrequencies.entrySet().stream().filter(t -> t.getValue() > 1).sorted((o1,o2) -> o2.getValue().compareTo(o1.getValue())).limit(configuration.getNumberOfSuggestions()).map(T -> new Suggestion(highlight(T.getKey(),theTokens),T.getKey())).collect(Collectors.toList());
  }
  finally {
    long theDuration=System.currentTimeMillis() - theStartTime;
    LOGGER.info(""String_Node_Str"" + theDuration + ""String_Node_Str"");
  }
}"
11246,"private void fileCreatedOrModified(FilesystemLocation aFileSystemLocation,Path aFile,boolean aShowInformation){
  String theFileName=aFile.toString();
  if (contentExtractor.supportsFile(theFileName)) {
    try {
      progressMonitor.addNewFileFound(theFileName);
      BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
      UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
      if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
        if (aShowInformation) {
          notifier.showInformation(""String_Node_Str"" + aFile);
        }
        Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
        if (theContent != null) {
          luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
          progressMonitor.addFilesIndexed();
        }
      }
    }
 catch (    Exception e) {
      aNotifier.showError(""String_Node_Str"" + aFile,e);
    }
  }
}","private void fileCreatedOrModified(FilesystemLocation aFileSystemLocation,Path aFile,boolean aShowInformation){
  String theFileName=aFile.toString();
  if (contentExtractor.supportsFile(theFileName)) {
    try {
      progressListener.newFileFound(theFileName);
      BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
      UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
      if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
        if (aShowInformation) {
          notifier.showInformation(""String_Node_Str"" + aFile.getFileName());
        }
        Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
        if (theContent != null) {
          luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
        }
      }
 else {
        LOGGER.info(""String_Node_Str"" + aFile + ""String_Node_Str""+ theUpdateCheckResult);
      }
    }
 catch (    Exception e) {
      aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
    }
  }
}"
11247,"@Override public void run(){
  locations.values().stream().forEach(theWatcher -> {
    try {
      theWatcher.crawl();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
);
  progressMonitor.crawlingFinished();
}","@Override public void run(){
  locations.values().stream().forEach(theWatcher -> {
    try {
      theWatcher.crawl();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
);
  progressListener.crawlingFinished();
}"
11248,"@Override public void fileDeleted(FilesystemLocation aFileSystemLocation,Path aFile){
  try {
    luceneIndexHandler.removeFromIndex(aFile.toString());
    aNotifier.showInformation(""String_Node_Str"" + aFile);
  }
 catch (  Exception e) {
    aNotifier.showError(""String_Node_Str"" + aFile,e);
  }
}","@Override public void fileDeleted(FilesystemLocation aFileSystemLocation,Path aFile){
  try {
    String theFilename=aFile.toString();
    if (luceneIndexHandler.checkIfExists(theFilename)) {
      luceneIndexHandler.removeFromIndex(theFilename);
      aNotifier.showInformation(""String_Node_Str"" + aFile.getFileName());
    }
  }
 catch (  Exception e) {
    aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
  }
}"
11249,"public Backend(Notifier aNotifier){
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor();
  progressMonitor=new ProgressMonitor(new ProgressListener(){
    public void newFileFound(    String aFilename,    long aNumNewFiles,    long aNumIndexedFiles){
      if (progressListener != null) {
        progressListener.newFileFound(aFilename,aNumNewFiles,aNumIndexedFiles);
      }
    }
    public void indexingProgress(    long aNumNewFiles,    long aNumIndexedFiles){
      if (progressListener != null) {
        progressListener.indexingProgress(aNumNewFiles,aNumIndexedFiles);
      }
    }
    public void crawlingFinished(){
      if (progressListener != null) {
        progressListener.crawlingFinished();
      }
    }
  }
);
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    FilesystemLocation aFileSystemLocation,    Path aFile){
      try {
        luceneIndexHandler.removeFromIndex(aFile.toString());
        aNotifier.showInformation(""String_Node_Str"" + aFile);
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile,e);
      }
    }
    @Override public void fileFoundByCrawler(    FilesystemLocation aFileSystemLocation,    Path aFile){
      fileCreatedOrModified(aFileSystemLocation,aFile,false);
    }
    @Override public void fileCreatedOrModified(    FilesystemLocation aFileSystemLocation,    Path aFile){
      fileCreatedOrModified(aFileSystemLocation,aFile,true);
    }
    private void fileCreatedOrModified(    FilesystemLocation aFileSystemLocation,    Path aFile,    boolean aShowInformation){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressMonitor.addNewFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            if (aShowInformation) {
              notifier.showInformation(""String_Node_Str"" + aFile);
            }
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
              progressMonitor.addFilesIndexed();
            }
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile,e);
        }
      }
    }
    @Override public void newWatchablePathDetected(    Path aDirectory){
      aNotifier.showInformation(""String_Node_Str"" + aDirectory);
    }
  }
;
}","public Backend(Notifier aNotifier){
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor();
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    FilesystemLocation aFileSystemLocation,    Path aFile){
      try {
        String theFilename=aFile.toString();
        if (luceneIndexHandler.checkIfExists(theFilename)) {
          luceneIndexHandler.removeFromIndex(theFilename);
          aNotifier.showInformation(""String_Node_Str"" + aFile.getFileName());
        }
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
      }
    }
    @Override public void fileFoundByCrawler(    FilesystemLocation aFileSystemLocation,    Path aFile){
      fileCreatedOrModified(aFileSystemLocation,aFile,false);
    }
    @Override public void fileCreatedOrModified(    FilesystemLocation aFileSystemLocation,    Path aFile){
      fileCreatedOrModified(aFileSystemLocation,aFile,true);
    }
    private void fileCreatedOrModified(    FilesystemLocation aFileSystemLocation,    Path aFile,    boolean aShowInformation){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressListener.newFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            if (aShowInformation) {
              notifier.showInformation(""String_Node_Str"" + aFile.getFileName());
            }
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
            }
          }
 else {
            LOGGER.info(""String_Node_Str"" + aFile + ""String_Node_Str""+ theUpdateCheckResult);
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
        }
      }
    }
  }
;
}"
11250,"public void crawlLocations() throws IOException {
  luceneIndexHandler.crawlingStarts();
  progressMonitor.resetStats();
  Thread theRunner=new Thread(){
    @Override public void run(){
      locations.values().stream().forEach(theWatcher -> {
        try {
          theWatcher.crawl();
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
);
      progressMonitor.crawlingFinished();
    }
  }
;
  theRunner.start();
}","public void crawlLocations() throws IOException {
  luceneIndexHandler.crawlingStarts();
  Thread theRunner=new Thread(){
    @Override public void run(){
      locations.values().stream().forEach(theWatcher -> {
        try {
          theWatcher.crawl();
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
);
      progressListener.crawlingFinished();
    }
  }
;
  theRunner.start();
}"
11251,"@Override public void start(Stage aStage) throws Exception {
  Notifier theNotifier=new Notifier();
  stage=aStage;
  searchPreferences=new SearchPreferences();
  backend=new Backend(theNotifier);
  try {
    searchPreferences.initialize(backend);
    embeddedWebServer=new FrontendEmbeddedWebServer(aStage,backend);
    embeddedWebServer.start();
  }
 catch (  BindException|LockReleaseFailedException e) {
    URL theURL=new URL(FrontendEmbeddedWebServer.getBringToFrontUrl());
    Object theContent=theURL.getContent();
    System.exit(0);
  }
  aStage.setTitle(""String_Node_Str"");
  aStage.setWidth(800);
  aStage.setHeight(600);
  aStage.initStyle(StageStyle.TRANSPARENT);
  FXMLLoader theLoader=new FXMLLoader(getClass().getResource(""String_Node_Str""));
  AnchorPane theMainScene=theLoader.load();
  final DesktopSearchController theController=theLoader.getController();
  theController.configure(this,backend,FrontendEmbeddedWebServer.getSearchUrl(),stage.getOwner());
  Undecorator theUndecorator=new Undecorator(stage,theMainScene);
  theUndecorator.getStylesheets().add(""String_Node_Str"");
  Scene theScene=new Scene(theUndecorator);
  theUndecorator.setStyle(""String_Node_Str"");
  theScene.setFill(Color.TRANSPARENT);
  aStage.setScene(theScene);
  aStage.getIcons().add(new Image(getClass().getResourceAsStream(""String_Node_Str"")));
  if (SystemTray.isSupported()) {
    Platform.setImplicitExit(false);
    SystemTray theTray=SystemTray.getSystemTray();
    PopupMenu theMenu=new PopupMenu();
    MenuItem theCloseItem=new MenuItem(""String_Node_Str"");
    theCloseItem.addActionListener(e -> Platform.runLater(this::shutdown));
    theMenu.add(theCloseItem);
    MenuItem theShowItem=new MenuItem(""String_Node_Str"");
    theShowItem.addActionListener(e -> Platform.runLater(() -> {
      stage.show();
      stage.toFront();
    }
));
    theMenu.add(theShowItem);
    java.awt.Image theSystrayIcon=Toolkit.getDefaultToolkit().getImage(getClass().getResource(""String_Node_Str""));
    TrayIcon theTrayIcon=new TrayIcon(theSystrayIcon,""String_Node_Str"",theMenu);
    theTray.add(theTrayIcon);
    aStage.setOnCloseRequest(aEvent -> stage.hide());
  }
 else {
    aStage.setOnCloseRequest(aEvent -> shutdown());
  }
  aStage.show();
}","@Override public void start(Stage aStage) throws Exception {
  Notifier theNotifier=new Notifier();
  stage=aStage;
  searchPreferences=new SearchPreferences();
  backend=new Backend(theNotifier);
  try {
    searchPreferences.initialize(backend);
    embeddedWebServer=new FrontendEmbeddedWebServer(aStage,backend);
    embeddedWebServer.start();
  }
 catch (  BindException|LockReleaseFailedException|LockObtainFailedException e) {
    URL theURL=new URL(FrontendEmbeddedWebServer.getBringToFrontUrl());
    Object theContent=theURL.getContent();
    System.exit(0);
  }
  aStage.setTitle(""String_Node_Str"");
  aStage.setWidth(800);
  aStage.setHeight(600);
  aStage.initStyle(StageStyle.TRANSPARENT);
  FXMLLoader theLoader=new FXMLLoader(getClass().getResource(""String_Node_Str""));
  AnchorPane theMainScene=theLoader.load();
  final DesktopSearchController theController=theLoader.getController();
  theController.configure(this,backend,FrontendEmbeddedWebServer.getSearchUrl(),stage.getOwner());
  Undecorator theUndecorator=new Undecorator(stage,theMainScene);
  theUndecorator.getStylesheets().add(""String_Node_Str"");
  Scene theScene=new Scene(theUndecorator);
  theUndecorator.setStyle(""String_Node_Str"");
  theScene.setFill(Color.TRANSPARENT);
  aStage.setScene(theScene);
  aStage.getIcons().add(new Image(getClass().getResourceAsStream(""String_Node_Str"")));
  if (SystemTray.isSupported()) {
    Platform.setImplicitExit(false);
    SystemTray theTray=SystemTray.getSystemTray();
    PopupMenu theMenu=new PopupMenu();
    MenuItem theCloseItem=new MenuItem(""String_Node_Str"");
    theCloseItem.addActionListener(e -> Platform.runLater(this::shutdown));
    theMenu.add(theCloseItem);
    MenuItem theShowItem=new MenuItem(""String_Node_Str"");
    theShowItem.addActionListener(e -> Platform.runLater(() -> {
      stage.show();
      stage.toFront();
    }
));
    theMenu.add(theShowItem);
    java.awt.Image theTrayIconImage=Toolkit.getDefaultToolkit().getImage(getClass().getResource(""String_Node_Str""));
    int trayIconWidth=new TrayIcon(theTrayIconImage).getSize().width;
    TrayIcon theTrayIcon=new TrayIcon(theTrayIconImage.getScaledInstance(trayIconWidth,-1,java.awt.Image.SCALE_SMOOTH),""String_Node_Str"",theMenu);
    theTrayIcon.setImageAutoSize(true);
    theTrayIcon.setToolTip(""String_Node_Str"");
    theTrayIcon.addMouseListener(new MouseAdapter(){
      @Override public void mouseClicked(      MouseEvent e){
        if (e.getClickCount() == 1) {
          Platform.runLater(() -> {
            stage.show();
            stage.toFront();
          }
);
        }
      }
    }
);
    theTray.add(theTrayIcon);
    aStage.setOnCloseRequest(aEvent -> stage.hide());
  }
 else {
    aStage.setOnCloseRequest(aEvent -> shutdown());
  }
  aStage.setMaximized(true);
  aStage.show();
}"
11252,"public void newFileFound(final String aFilename,final long aNumNewFiles,final long aNumIndexedFiles){
  wakeupThread();
  watcherThread.notifyProgress();
  Platform.runLater(() -> {
    double theProgress=(double)aNumIndexedFiles / aNumNewFiles;
    progessIndicator.setProgress(theProgress);
    statusText.setText(aFilename);
  }
);
}","public void newFileFound(final String aFilename){
  wakeupThread();
  watcherThread.notifyProgress();
  Platform.runLater(() -> {
    statusText.setText(aFilename);
  }
);
}"
11253,"@Override public void run(){
  Platform.runLater(() -> {
    statusBar.setVisible(true);
    statusBar.setManaged(true);
    menuItemRecrawl.setDisable(true);
  }
);
  while (!isInterrupted()) {
    if (lastActivity.get() < System.currentTimeMillis() - 5000) {
      interrupt();
    }
 else {
      try {
        sleep(5000);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Platform.runLater(() -> {
    statusBar.setVisible(false);
    statusBar.setManaged(false);
    menuItemRecrawl.setDisable(false);
  }
);
}","@Override public void run(){
  Platform.runLater(() -> {
    statusBar.setVisible(true);
    menuItemRecrawl.setDisable(true);
  }
);
  while (!isInterrupted()) {
    if (lastActivity.get() < System.currentTimeMillis() - 5000) {
      interrupt();
    }
 else {
      try {
        sleep(5000);
      }
 catch (      InterruptedException e) {
      }
    }
  }
  Platform.runLater(() -> {
    statusBar.setVisible(false);
    statusBar.setManaged(false);
    menuItemRecrawl.setDisable(false);
  }
);
}"
11254,"void recrawl(){
  statusBar.setVisible(true);
  statusBar.setManaged(true);
  progessIndicator.setProgress(0);
  menuItemRecrawl.setDisable(true);
  statusText.setText(""String_Node_Str"");
  try {
    backend.crawlLocations();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","void recrawl(){
  statusBar.setVisible(true);
  statusBar.setManaged(true);
  menuItemRecrawl.setDisable(true);
  statusText.setText(""String_Node_Str"");
  try {
    backend.crawlLocations();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
11255,"private void registerWatcher(Path aDirectory) throws IOException {
  directoryListener.newWatchablePathDetected(aDirectory);
  aDirectory.register(watchService,StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE,StandardWatchEventKinds.ENTRY_MODIFY);
}","private void registerWatcher(Path aDirectory) throws IOException {
  LOGGER.info(""String_Node_Str"" + aDirectory);
  aDirectory.register(watchService,StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE,StandardWatchEventKinds.ENTRY_MODIFY);
}"
11256,"public DirectoryWatcher startWatching(){
  Thread theRegisterWatchers=new Thread(""String_Node_Str""){
    @Override public void run(){
      try {
        Files.walk(filesystemLocation.getDirectory().toPath()).forEach(path -> {
          if (Files.isDirectory(path)) {
            LOGGER.info(""String_Node_Str"" + path);
            try {
              registerWatcher(path);
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
;
  theRegisterWatchers.start();
  watcherThread.start();
  actionTimer.scheduleAtFixedRate(new TimerTask(){
    @Override public void run(){
      actionCountDown();
    }
  }
,1000,1000);
  return this;
}","public DirectoryWatcher startWatching(){
  Thread theRegisterWatchers=new Thread(""String_Node_Str""){
    @Override public void run(){
      try {
        Files.walk(filesystemLocation.getDirectory().toPath()).forEach(path -> {
          if (Files.isDirectory(path)) {
            LOGGER.info(""String_Node_Str"" + path);
            try {
              registerWatcher(path);
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
);
      }
 catch (      IOException e) {
        LOGGER.error(""String_Node_Str"",e);
      }
    }
  }
;
  theRegisterWatchers.start();
  watcherThread.start();
  actionTimer.scheduleAtFixedRate(new TimerTask(){
    @Override public void run(){
      actionCountDown();
    }
  }
,1000,1000);
  return this;
}"
11257,"public void showInformation(String aMessage){
}","public void showInformation(String aMessage){
  LOGGER.info(aMessage);
  Platform.runLater(() -> notifier.notifyInfo(""String_Node_Str"",aMessage));
}"
11258,"public void showError(String aMessage,Exception aException){
}","public void showError(String aMessage,Exception aException){
  LOGGER.error(aMessage,aException);
  Platform.runLater(() -> notifier.notifyError(""String_Node_Str"",aMessage));
}"
11259,"void newFileFound(String aFilename,long aNumNewFiles,long aNumIndexedFiles);",void newFileFound(String aFilename);
11260,"private void add(Configuration.CrawlLocation aLocation) throws IOException {
  locations.put(aLocation,new DirectoryWatcher(aLocation,DirectoryWatcher.DEFAULT_WAIT_FOR_ACTION,directoryListener,executorPool).startWatching());
}","private void add(Configuration.CrawlLocation aLocation) throws IOException {
  locations.put(aLocation,new DirectoryWatcher(watchServiceCache,aLocation,DirectoryWatcher.DEFAULT_WAIT_FOR_ACTION,directoryListener,executorPool).startWatching());
}"
11261,"public Backend(Notifier aNotifier,Configuration aConfiguration) throws IOException {
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor(aConfiguration);
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    Configuration.CrawlLocation aFileSystemLocation,    Path aFile){
      try {
        String theFilename=aFile.toString();
        if (luceneIndexHandler.checkIfExists(theFilename)) {
          luceneIndexHandler.removeFromIndex(theFilename);
          aNotifier.showInformation(""String_Node_Str"" + aFile.getFileName());
        }
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
      }
    }
    @Override public void fileFoundByCrawler(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,false);
    }
    @Override public void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,true);
    }
    private void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile,    boolean aShowInformation){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressListener.newFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            if (aShowInformation) {
              notifier.showInformation(""String_Node_Str"" + aFile.getFileName());
            }
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aLocation.getId(),theContent);
            }
          }
 else {
            LOGGER.info(""String_Node_Str"" + aFile + ""String_Node_Str""+ theUpdateCheckResult);
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
        }
      }
    }
  }
;
  configurationUpdated(aConfiguration);
}","public Backend(Notifier aNotifier,Configuration aConfiguration) throws IOException {
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  watchServiceCache=new WatchServiceCache();
  contentExtractor=new ContentExtractor(aConfiguration);
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    Configuration.CrawlLocation aFileSystemLocation,    Path aFile){
      try {
        String theFilename=aFile.toString();
        if (luceneIndexHandler.checkIfExists(theFilename)) {
          luceneIndexHandler.removeFromIndex(theFilename);
          aNotifier.showInformation(""String_Node_Str"" + aFile.getFileName());
        }
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
      }
    }
    @Override public void fileFoundByCrawler(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,false);
    }
    @Override public void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,true);
    }
    private void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile,    boolean aShowInformation){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressListener.newFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            if (aShowInformation) {
              notifier.showInformation(""String_Node_Str"" + aFile.getFileName());
            }
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aLocation.getId(),theContent);
            }
          }
 else {
            LOGGER.info(""String_Node_Str"" + aFile + ""String_Node_Str""+ theUpdateCheckResult);
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
        }
      }
    }
  }
;
  configurationUpdated(aConfiguration);
}"
11262,"void configure(){
  try {
    Stage stage=new Stage();
    stage.setResizable(false);
    stage.initStyle(StageStyle.UTILITY);
    FXMLLoader theLoader=new FXMLLoader(getClass().getResource(""String_Node_Str""));
    AnchorPane theConfigurationRoot=theLoader.load();
    stage.setScene(new Scene(theConfigurationRoot));
    stage.setTitle(""String_Node_Str"");
    stage.initModality(Modality.APPLICATION_MODAL);
    ConfigurationController theConfigController=theLoader.getController();
    theConfigController.initialize(application.getConfigurationManager(),stage);
    stage.initOwner(window);
    stage.show();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","void configure(){
  try {
    Stage stage=new Stage();
    stage.setResizable(false);
    stage.initStyle(StageStyle.UTILITY);
    FXMLLoader theLoader=new FXMLLoader(getClass().getResource(""String_Node_Str""));
    AnchorPane theConfigurationRoot=theLoader.load();
    stage.setScene(new Scene(theConfigurationRoot));
    stage.setTitle(""String_Node_Str"");
    stage.initModality(Modality.APPLICATION_MODAL);
    ConfigurationController theConfigController=theLoader.getController();
    theConfigController.initialize(application.getConfigurationManager(),stage);
    stage.initOwner(window);
    stage.show();
  }
 catch (  IOException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
11263,"void recrawl(){
  statusBar.setVisible(true);
  statusBar.setManaged(true);
  menuItemRecrawl.setDisable(true);
  statusText.setText(""String_Node_Str"");
  try {
    backend.crawlLocations();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","void recrawl(){
  statusBar.setVisible(true);
  statusBar.setManaged(true);
  menuItemRecrawl.setDisable(true);
  statusText.setText(""String_Node_Str"");
  try {
    backend.crawlLocations();
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
11264,"public DirectoryWatcher(Configuration.CrawlLocation aFileSystemLocation,int aWaitForAction,DirectoryListener aDirectoryListener,ExecutorPool aExecutorPool) throws IOException {
  executorPool=aExecutorPool;
  fileTimers=new HashMap<>();
  waitForAction=aWaitForAction;
  directoryListener=aDirectoryListener;
  filesystemLocation=aFileSystemLocation;
  Path thePath=aFileSystemLocation.getDirectory().toPath();
  watchService=thePath.getFileSystem().newWatchService();
  watcherThread=new Thread(""String_Node_Str"" + thePath){
    @Override public void run(){
      while (!isInterrupted()) {
        try {
          WatchKey theKey=watchService.take();
          Path theParent=(Path)theKey.watchable();
          theKey.pollEvents().stream().forEach(theEvent -> {
            if (theEvent.kind() == StandardWatchEventKinds.OVERFLOW) {
              LOGGER.warn(""String_Node_Str"" + theEvent.context() + ""String_Node_Str""+ theEvent.count());
            }
 else {
              Path thePath=theParent.resolve((Path)theEvent.context());
              LOGGER.debug(theEvent.kind() + ""String_Node_Str"" + theEvent.context()+ ""String_Node_Str""+ theEvent.count());
              publishActionFor(thePath,theEvent.kind());
            }
          }
);
          theKey.reset();
          Thread.sleep(10000);
        }
 catch (        InterruptedException e) {
          LOGGER.debug(""String_Node_Str"");
        }
      }
    }
  }
;
  actionTimer=new Timer();
}","public DirectoryWatcher(WatchServiceCache aWatchServiceCache,Configuration.CrawlLocation aFileSystemLocation,int aWaitForAction,DirectoryListener aDirectoryListener,ExecutorPool aExecutorPool) throws IOException {
  executorPool=aExecutorPool;
  fileTimers=new HashMap<>();
  waitForAction=aWaitForAction;
  directoryListener=aDirectoryListener;
  filesystemLocation=aFileSystemLocation;
  Path thePath=aFileSystemLocation.getDirectory().toPath();
  watchService=aWatchServiceCache.getWatchServiceFor(thePath);
  watcherThread=new Thread(""String_Node_Str"" + thePath){
    @Override public void run(){
      while (!isInterrupted()) {
        try {
          WatchKey theKey=watchService.take();
          Path theParent=(Path)theKey.watchable();
          theKey.pollEvents().stream().forEach(theEvent -> {
            if (theEvent.kind() == StandardWatchEventKinds.OVERFLOW) {
              LOGGER.warn(""String_Node_Str"" + theEvent.context() + ""String_Node_Str""+ theEvent.count());
            }
 else {
              Path thePath=theParent.resolve((Path)theEvent.context());
              LOGGER.debug(theEvent.kind() + ""String_Node_Str"" + theEvent.context()+ ""String_Node_Str""+ theEvent.count());
              publishActionFor(thePath,theEvent.kind());
            }
          }
);
          theKey.reset();
          Thread.sleep(10000);
        }
 catch (        InterruptedException e) {
          LOGGER.debug(""String_Node_Str"");
        }
      }
    }
  }
;
  actionTimer=new Timer();
}"
11265,"private void fillinSearchResult(HttpServletRequest aRequest,HttpServletResponse aResponse) throws ServletException, IOException {
  URLCodec theURLCodec=new URLCodec();
  String theQueryString=aRequest.getParameter(""String_Node_Str"");
  String theBasePath=basePath;
  String theBackLink=basePath;
  if (!StringUtils.isEmpty(theQueryString)) {
    try {
      theBasePath=theBasePath + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
      theBackLink=theBackLink + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
    }
 catch (    EncoderException e) {
      e.printStackTrace();
    }
  }
  Map<String,String> theDrilldownDimensions=new HashMap<>();
  String thePathInfo=aRequest.getPathInfo();
  if (!StringUtils.isEmpty(thePathInfo)) {
    String theWorkingPathInfo=thePathInfo;
    if (theWorkingPathInfo.startsWith(""String_Node_Str"")) {
      theWorkingPathInfo=theWorkingPathInfo.substring(1);
    }
    String[] thePaths=StringUtils.split(theWorkingPathInfo,""String_Node_Str"");
    for (int i=0; i < thePaths.length; i++) {
      try {
        String theDecodedValue=thePaths[i].replace('+',' ');
        String theEncodedValue=theURLCodec.encode(theDecodedValue);
        theBasePath=theBasePath + ""String_Node_Str"" + theEncodedValue;
        if (i < thePaths.length - 1) {
          theBackLink=theBackLink + ""String_Node_Str"" + theEncodedValue;
        }
        if (i == 0) {
          theQueryString=theDecodedValue;
        }
 else {
          FacetSearchUtils.addToMap(theDecodedValue,theDrilldownDimensions);
        }
      }
 catch (      EncoderException e) {
        LOGGER.error(""String_Node_Str"" + aRequest.getPathInfo(),e);
      }
    }
    if (basePath.equals(theBackLink)) {
      theBackLink=null;
    }
  }
 else {
    theBackLink=null;
  }
  if (!StringUtils.isEmpty(theQueryString)) {
    aRequest.setAttribute(""String_Node_Str"",theQueryString);
    try {
      aRequest.setAttribute(""String_Node_Str"",backend.performQuery(theQueryString,theBackLink,theBasePath,theDrilldownDimensions));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    aRequest.setAttribute(""String_Node_Str"",""String_Node_Str"");
  }
  aRequest.setAttribute(""String_Node_Str"",serverBase);
  aRequest.getRequestDispatcher(""String_Node_Str"").forward(aRequest,aResponse);
}","private void fillinSearchResult(HttpServletRequest aRequest,HttpServletResponse aResponse) throws ServletException, IOException {
  URLCodec theURLCodec=new URLCodec();
  String theQueryString=aRequest.getParameter(""String_Node_Str"");
  String theBasePath=basePath;
  String theBackLink=basePath;
  if (!StringUtils.isEmpty(theQueryString)) {
    try {
      theBasePath=theBasePath + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
      theBackLink=theBackLink + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
    }
 catch (    EncoderException e) {
      LOGGER.error(""String_Node_Str"" + theQueryString,e);
    }
  }
  Map<String,String> theDrilldownDimensions=new HashMap<>();
  String thePathInfo=aRequest.getPathInfo();
  if (!StringUtils.isEmpty(thePathInfo)) {
    String theWorkingPathInfo=thePathInfo;
    if (theWorkingPathInfo.startsWith(""String_Node_Str"")) {
      theWorkingPathInfo=theWorkingPathInfo.substring(1);
    }
    String[] thePaths=StringUtils.split(theWorkingPathInfo,""String_Node_Str"");
    for (int i=0; i < thePaths.length; i++) {
      try {
        String theDecodedValue=thePaths[i].replace('+',' ');
        String theEncodedValue=theURLCodec.encode(theDecodedValue);
        theBasePath=theBasePath + ""String_Node_Str"" + theEncodedValue;
        if (i < thePaths.length - 1) {
          theBackLink=theBackLink + ""String_Node_Str"" + theEncodedValue;
        }
        if (i == 0) {
          theQueryString=theDecodedValue;
        }
 else {
          FacetSearchUtils.addToMap(theDecodedValue,theDrilldownDimensions);
        }
      }
 catch (      EncoderException e) {
        LOGGER.error(""String_Node_Str"" + aRequest.getPathInfo(),e);
      }
    }
    if (basePath.equals(theBackLink)) {
      theBackLink=null;
    }
  }
 else {
    theBackLink=null;
  }
  if (!StringUtils.isEmpty(theQueryString)) {
    aRequest.setAttribute(""String_Node_Str"",theQueryString);
    try {
      aRequest.setAttribute(""String_Node_Str"",backend.performQuery(theQueryString,theBackLink,theBasePath,theDrilldownDimensions));
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"" + theQueryString,e);
    }
  }
 else {
    aRequest.setAttribute(""String_Node_Str"",""String_Node_Str"");
  }
  aRequest.setAttribute(""String_Node_Str"",serverBase);
  aRequest.getRequestDispatcher(""String_Node_Str"").forward(aRequest,aResponse);
}"
11266,"@Override public void fileCreatedOrModified(FilesystemLocation aFileSystemLocation,Path aFile){
  String theFileName=aFile.toString();
  if (contentExtractor.supportsFile(theFileName)) {
    try {
      progressMonitor.addNewFileFound(theFileName);
      BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
      UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
      if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
        Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
        if (theContent != null) {
          luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
          progressMonitor.addFilesIndexed();
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","@Override public void fileCreatedOrModified(FilesystemLocation aFileSystemLocation,Path aFile){
  String theFileName=aFile.toString();
  if (contentExtractor.supportsFile(theFileName)) {
    try {
      progressMonitor.addNewFileFound(theFileName);
      BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
      UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
      if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
        notifier.showInformation(""String_Node_Str"" + aFile);
        Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
        if (theContent != null) {
          luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
          progressMonitor.addFilesIndexed();
        }
      }
    }
 catch (    Exception e) {
      aNotifier.showError(""String_Node_Str"" + aFile,e);
    }
  }
}"
11267,"@Override public void fileDeleted(FilesystemLocation aFileSystemLocation,Path aFile){
  try {
    luceneIndexHandler.removeFromIndex(aFile.toString());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public void fileDeleted(FilesystemLocation aFileSystemLocation,Path aFile){
  try {
    luceneIndexHandler.removeFromIndex(aFile.toString());
    aNotifier.showInformation(""String_Node_Str"" + aFile);
  }
 catch (  Exception e) {
    aNotifier.showError(""String_Node_Str"" + aFile,e);
  }
}"
11268,"public Backend(){
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor();
  progressMonitor=new ProgressMonitor(new ProgressListener(){
    public void newFileFound(    String aFilename,    long aNumNewFiles,    long aNumIndexedFiles){
      if (progressListener != null) {
        progressListener.newFileFound(aFilename,aNumNewFiles,aNumIndexedFiles);
      }
    }
    public void indexingProgress(    long aNumNewFiles,    long aNumIndexedFiles){
      if (progressListener != null) {
        progressListener.indexingProgress(aNumNewFiles,aNumIndexedFiles);
      }
    }
    public void crawlingFinished(){
      if (progressListener != null) {
        progressListener.crawlingFinished();
      }
    }
  }
);
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    FilesystemLocation aFileSystemLocation,    Path aFile){
      try {
        luceneIndexHandler.removeFromIndex(aFile.toString());
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    @Override public void fileCreatedOrModified(    FilesystemLocation aFileSystemLocation,    Path aFile){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressMonitor.addNewFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
              progressMonitor.addFilesIndexed();
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
;
}","public Backend(Notifier aNotifier){
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor();
  progressMonitor=new ProgressMonitor(new ProgressListener(){
    public void newFileFound(    String aFilename,    long aNumNewFiles,    long aNumIndexedFiles){
      if (progressListener != null) {
        progressListener.newFileFound(aFilename,aNumNewFiles,aNumIndexedFiles);
      }
    }
    public void indexingProgress(    long aNumNewFiles,    long aNumIndexedFiles){
      if (progressListener != null) {
        progressListener.indexingProgress(aNumNewFiles,aNumIndexedFiles);
      }
    }
    public void crawlingFinished(){
      if (progressListener != null) {
        progressListener.crawlingFinished();
      }
    }
  }
);
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    FilesystemLocation aFileSystemLocation,    Path aFile){
      try {
        luceneIndexHandler.removeFromIndex(aFile.toString());
        aNotifier.showInformation(""String_Node_Str"" + aFile);
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile,e);
      }
    }
    @Override public void fileCreatedOrModified(    FilesystemLocation aFileSystemLocation,    Path aFile){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressMonitor.addNewFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            notifier.showInformation(""String_Node_Str"" + aFile);
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aFileSystemLocation.getId(),theContent);
              progressMonitor.addFilesIndexed();
            }
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile,e);
        }
      }
    }
    @Override public void newWatchablePathDetected(    Path aDirectory){
      aNotifier.showInformation(""String_Node_Str"" + aDirectory);
    }
  }
;
}"
11269,"public void openFile(String aFile){
  try {
    Desktop.getDesktop().open(new File(aFile));
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void openFile(String aFile){
  if (Desktop.isDesktopSupported()) {
    if (Platform.isFxApplicationThread()) {
      new Thread(() -> {
        open(aFile);
      }
).start();
    }
 else {
      open(aFile);
    }
  }
 else {
    LOGGER.error(""String_Node_Str"");
  }
}"
11270,"@Override public void start(Stage aStage) throws Exception {
  stage=aStage;
  searchPreferences=new SearchPreferences();
  backend=new Backend();
  try {
    searchPreferences.initialize(backend);
    embeddedWebServer=new FrontendEmbeddedWebServer(aStage,backend);
    embeddedWebServer.start();
  }
 catch (  BindException|LockReleaseFailedException e) {
    URL theURL=new URL(FrontendEmbeddedWebServer.getBringToFrontUrl());
    Object theContent=theURL.getContent();
    System.exit(0);
  }
  aStage.setTitle(""String_Node_Str"");
  aStage.setWidth(800);
  aStage.setHeight(600);
  aStage.initStyle(StageStyle.TRANSPARENT);
  FXMLLoader theLoader=new FXMLLoader(getClass().getResource(""String_Node_Str""));
  AnchorPane theMainScene=theLoader.load();
  final DesktopSearchController theController=theLoader.getController();
  theController.configure(this,backend,FrontendEmbeddedWebServer.getSearchUrl(),FrontendEmbeddedWebServer.getSunburstUrl(),stage.getOwner());
  Undecorator theUndecorator=new Undecorator(stage,theMainScene);
  theUndecorator.getStylesheets().add(""String_Node_Str"");
  Scene theScene=new Scene(theUndecorator);
  theUndecorator.setStyle(""String_Node_Str"");
  theScene.setFill(Color.TRANSPARENT);
  aStage.setScene(theScene);
  aStage.getIcons().add(new Image(getClass().getResourceAsStream(""String_Node_Str"")));
  if (SystemTray.isSupported()) {
    Platform.setImplicitExit(false);
    SystemTray theTray=SystemTray.getSystemTray();
    PopupMenu theMenu=new PopupMenu();
    MenuItem theCloseItem=new MenuItem(""String_Node_Str"");
    theCloseItem.addActionListener(e -> Platform.runLater(this::shutdown));
    theMenu.add(theCloseItem);
    MenuItem theShowItem=new MenuItem(""String_Node_Str"");
    theShowItem.addActionListener(e -> Platform.runLater(() -> {
      stage.show();
      stage.toFront();
    }
));
    theMenu.add(theShowItem);
    java.awt.Image theSystrayIcon=Toolkit.getDefaultToolkit().getImage(getClass().getResource(""String_Node_Str""));
    TrayIcon theTrayIcon=new TrayIcon(theSystrayIcon,""String_Node_Str"",theMenu);
    theTray.add(theTrayIcon);
    aStage.setOnCloseRequest(aEvent -> stage.hide());
  }
 else {
    aStage.setOnCloseRequest(aEvent -> shutdown());
  }
  aStage.show();
}","@Override public void start(Stage aStage) throws Exception {
  Notifier theNotifier=new Notifier();
  stage=aStage;
  searchPreferences=new SearchPreferences();
  backend=new Backend(theNotifier);
  try {
    searchPreferences.initialize(backend);
    embeddedWebServer=new FrontendEmbeddedWebServer(aStage,backend);
    embeddedWebServer.start();
  }
 catch (  BindException|LockReleaseFailedException e) {
    URL theURL=new URL(FrontendEmbeddedWebServer.getBringToFrontUrl());
    Object theContent=theURL.getContent();
    System.exit(0);
  }
  aStage.setTitle(""String_Node_Str"");
  aStage.setWidth(800);
  aStage.setHeight(600);
  aStage.initStyle(StageStyle.TRANSPARENT);
  FXMLLoader theLoader=new FXMLLoader(getClass().getResource(""String_Node_Str""));
  AnchorPane theMainScene=theLoader.load();
  final DesktopSearchController theController=theLoader.getController();
  theController.configure(this,backend,FrontendEmbeddedWebServer.getSearchUrl(),FrontendEmbeddedWebServer.getSunburstUrl(),stage.getOwner());
  Undecorator theUndecorator=new Undecorator(stage,theMainScene);
  theUndecorator.getStylesheets().add(""String_Node_Str"");
  Scene theScene=new Scene(theUndecorator);
  theUndecorator.setStyle(""String_Node_Str"");
  theScene.setFill(Color.TRANSPARENT);
  aStage.setScene(theScene);
  aStage.getIcons().add(new Image(getClass().getResourceAsStream(""String_Node_Str"")));
  if (SystemTray.isSupported()) {
    Platform.setImplicitExit(false);
    SystemTray theTray=SystemTray.getSystemTray();
    PopupMenu theMenu=new PopupMenu();
    MenuItem theCloseItem=new MenuItem(""String_Node_Str"");
    theCloseItem.addActionListener(e -> Platform.runLater(this::shutdown));
    theMenu.add(theCloseItem);
    MenuItem theShowItem=new MenuItem(""String_Node_Str"");
    theShowItem.addActionListener(e -> Platform.runLater(() -> {
      stage.show();
      stage.toFront();
    }
));
    theMenu.add(theShowItem);
    java.awt.Image theSystrayIcon=Toolkit.getDefaultToolkit().getImage(getClass().getResource(""String_Node_Str""));
    TrayIcon theTrayIcon=new TrayIcon(theSystrayIcon,""String_Node_Str"",theMenu);
    theTray.add(theTrayIcon);
    aStage.setOnCloseRequest(aEvent -> stage.hide());
  }
 else {
    aStage.setOnCloseRequest(aEvent -> shutdown());
  }
  aStage.show();
}"
11271,"private void registerWatcher(Path aDirectory) throws IOException {
  aDirectory.register(watchService,StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE,StandardWatchEventKinds.ENTRY_MODIFY);
}","private void registerWatcher(Path aDirectory) throws IOException {
  directoryListener.newWatchablePathDetected(aDirectory);
  aDirectory.register(watchService,StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE,StandardWatchEventKinds.ENTRY_MODIFY);
}"
11272,"public DirectoryWatcher(FilesystemLocation aFileSystemLocation,int aWaitForAction,DirectoryListener aDirectoryListener,ExecutorPool aExecutorPool) throws IOException {
  executorPool=aExecutorPool;
  fileTimers=new HashMap<>();
  waitForAction=aWaitForAction;
  directoryListener=aDirectoryListener;
  filesystemLocation=aFileSystemLocation;
  Path thePath=aFileSystemLocation.getDirectory().toPath();
  watchService=thePath.getFileSystem().newWatchService();
  watcherThread=new Thread(""String_Node_Str"" + thePath){
    @Override public void run(){
      while (!isInterrupted()) {
        try {
          WatchKey theKey=watchService.take();
          Path theParent=(Path)theKey.watchable();
          theKey.pollEvents().stream().forEach(theEvent -> {
            if (theEvent.kind() == StandardWatchEventKinds.OVERFLOW) {
              LOGGER.warn(""String_Node_Str"" + theEvent.context() + ""String_Node_Str""+ theEvent.count());
            }
 else {
              Path thePath=theParent.resolve((Path)theEvent.context());
              LOGGER.debug(theEvent.kind() + ""String_Node_Str"" + theEvent.context()+ ""String_Node_Str""+ theEvent.count());
              publishActionFor(thePath,theEvent.kind());
            }
          }
);
          theKey.reset();
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          LOGGER.debug(""String_Node_Str"");
        }
      }
    }
  }
;
  actionTimer=new Timer();
}","public DirectoryWatcher(FilesystemLocation aFileSystemLocation,int aWaitForAction,DirectoryListener aDirectoryListener,ExecutorPool aExecutorPool) throws IOException {
  executorPool=aExecutorPool;
  fileTimers=new HashMap<>();
  waitForAction=aWaitForAction;
  directoryListener=aDirectoryListener;
  filesystemLocation=aFileSystemLocation;
  Path thePath=aFileSystemLocation.getDirectory().toPath();
  watchService=thePath.getFileSystem().newWatchService();
  watcherThread=new Thread(""String_Node_Str"" + thePath){
    @Override public void run(){
      while (!isInterrupted()) {
        try {
          WatchKey theKey=watchService.take();
          Path theParent=(Path)theKey.watchable();
          theKey.pollEvents().stream().forEach(theEvent -> {
            if (theEvent.kind() == StandardWatchEventKinds.OVERFLOW) {
              LOGGER.warn(""String_Node_Str"" + theEvent.context() + ""String_Node_Str""+ theEvent.count());
            }
 else {
              Path thePath=theParent.resolve((Path)theEvent.context());
              LOGGER.debug(theEvent.kind() + ""String_Node_Str"" + theEvent.context()+ ""String_Node_Str""+ theEvent.count());
              publishActionFor(thePath,theEvent.kind());
            }
          }
);
          theKey.reset();
          Thread.sleep(10000);
        }
 catch (        InterruptedException e) {
          LOGGER.debug(""String_Node_Str"");
        }
      }
    }
  }
;
  actionTimer=new Timer();
}"
11273,"private void fillinSearchResult(HttpServletRequest aRequest,HttpServletResponse aResponse) throws ServletException, IOException {
  URLCodec theURLCodec=new URLCodec();
  String theQueryString=aRequest.getParameter(""String_Node_Str"");
  String theBasePath=basePath;
  String theBackLink=basePath;
  if (!StringUtils.isEmpty(theQueryString)) {
    try {
      theBasePath=theBasePath + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
      theBackLink=theBackLink + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
    }
 catch (    EncoderException e) {
      e.printStackTrace();
    }
  }
  Map<String,String> theDrilldownDimensions=new HashMap<>();
  String thePathInfo=aRequest.getPathInfo();
  if (!StringUtils.isEmpty(thePathInfo)) {
    String theWorkingPathInfo=thePathInfo;
    if (theWorkingPathInfo.startsWith(""String_Node_Str"")) {
      theWorkingPathInfo=theWorkingPathInfo.substring(1);
    }
    String[] thePaths=StringUtils.split(theWorkingPathInfo,""String_Node_Str"");
    for (int i=0; i < thePaths.length; i++) {
      try {
        theBasePath=theBasePath + ""String_Node_Str"" + thePaths[i];
        if (i < thePaths.length - 1) {
          theBackLink=theBackLink + ""String_Node_Str"" + thePaths[i];
        }
        String theDecodedValue=theURLCodec.decode(thePaths[i]);
        if (i == 0) {
          theQueryString=theDecodedValue;
        }
 else {
          FacetSearchUtils.addToMap(theDecodedValue,theDrilldownDimensions);
        }
      }
 catch (      DecoderException e) {
        LOGGER.error(""String_Node_Str"" + aRequest.getPathInfo(),e);
      }
    }
    if (basePath.equals(theBackLink)) {
      theBackLink=null;
    }
  }
 else {
    theBackLink=null;
  }
  if (!StringUtils.isEmpty(theQueryString)) {
    aRequest.setAttribute(""String_Node_Str"",theQueryString);
    try {
      aRequest.setAttribute(""String_Node_Str"",backend.performQuery(theQueryString,theBackLink,theBasePath,theDrilldownDimensions));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    aRequest.setAttribute(""String_Node_Str"",""String_Node_Str"");
  }
  aRequest.setAttribute(""String_Node_Str"",serverBase);
  aRequest.getRequestDispatcher(""String_Node_Str"").forward(aRequest,aResponse);
}","private void fillinSearchResult(HttpServletRequest aRequest,HttpServletResponse aResponse) throws ServletException, IOException {
  URLCodec theURLCodec=new URLCodec();
  String theQueryString=aRequest.getParameter(""String_Node_Str"");
  String theBasePath=basePath;
  String theBackLink=basePath;
  if (!StringUtils.isEmpty(theQueryString)) {
    try {
      theBasePath=theBasePath + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
      theBackLink=theBackLink + ""String_Node_Str"" + theURLCodec.encode(theQueryString);
    }
 catch (    EncoderException e) {
      e.printStackTrace();
    }
  }
  Map<String,String> theDrilldownDimensions=new HashMap<>();
  String thePathInfo=aRequest.getPathInfo();
  if (!StringUtils.isEmpty(thePathInfo)) {
    String theWorkingPathInfo=thePathInfo;
    if (theWorkingPathInfo.startsWith(""String_Node_Str"")) {
      theWorkingPathInfo=theWorkingPathInfo.substring(1);
    }
    String[] thePaths=StringUtils.split(theWorkingPathInfo,""String_Node_Str"");
    for (int i=0; i < thePaths.length; i++) {
      try {
        String theDecodedValue=theURLCodec.decode(thePaths[i]);
        String theEncodedValue=theURLCodec.encode(theDecodedValue);
        theBasePath=theBasePath + ""String_Node_Str"" + theEncodedValue;
        if (i < thePaths.length - 1) {
          theBackLink=theBackLink + ""String_Node_Str"" + theEncodedValue;
        }
        if (i == 0) {
          theQueryString=theDecodedValue;
        }
 else {
          FacetSearchUtils.addToMap(theDecodedValue,theDrilldownDimensions);
        }
      }
 catch (      EncoderException|DecoderException e) {
        LOGGER.error(""String_Node_Str"" + aRequest.getPathInfo(),e);
      }
    }
    if (basePath.equals(theBackLink)) {
      theBackLink=null;
    }
  }
 else {
    theBackLink=null;
  }
  if (!StringUtils.isEmpty(theQueryString)) {
    aRequest.setAttribute(""String_Node_Str"",theQueryString);
    try {
      aRequest.setAttribute(""String_Node_Str"",backend.performQuery(theQueryString,theBackLink,theBasePath,theDrilldownDimensions));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    aRequest.setAttribute(""String_Node_Str"",""String_Node_Str"");
  }
  aRequest.setAttribute(""String_Node_Str"",serverBase);
  aRequest.getRequestDispatcher(""String_Node_Str"").forward(aRequest,aResponse);
}"
11274,"private String harmonizeMetaDataName(String aName){
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  return aName;
}","private String harmonizeMetaDataName(String aName){
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (aName.startsWith(""String_Node_Str"")) {
    aName=aName.substring(""String_Node_Str"".length());
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  if (""String_Node_Str"".equals(aName)) {
    return ""String_Node_Str"";
  }
  return aName;
}"
11275,"public boolean supportsLanguage(String aLanguage){
  return analyzerByLanguage.containsKey(aLanguage);
}","public boolean supportsLanguage(SupportedLanguage aLanguage){
  return analyzerByLanguage.containsKey(aLanguage);
}"
11276,"public String getFieldNameFor(String aLanguage){
  return IndexFields.CONTENT + ""String_Node_Str"" + aLanguage;
}","public String getFieldNameFor(SupportedLanguage aLanguage){
  return FIELD_PREFIX + aLanguage.name();
}"
11277,"public AnalyzerCache(Version aLuceneVersion){
  standardAnalyzer=new StandardAnalyzer(aLuceneVersion);
  analyzerByLanguage=new HashMap<>();
  analyzerByLanguage.put(""String_Node_Str"",new ArabicAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new BulgarianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new BrazilianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new CatalanAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new SoraniAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new CzechAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new DanishAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new GermanAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new GreekAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new EnglishAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new SpanishAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new BasqueAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new PersianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new FinnishAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new FrenchAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new IrishAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new GalicianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new HindiAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new HungarianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new ArmenianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new IndonesianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new ItalianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new LatvianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new DutchAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new NorwegianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new PortugueseAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new RomanianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new RussianAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new SwedishAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new ThaiAnalyzer(aLuceneVersion));
  analyzerByLanguage.put(""String_Node_Str"",new TurkishAnalyzer(aLuceneVersion));
}","public AnalyzerCache(Configuration aConfiguration){
  standardAnalyzer=new StandardAnalyzer(IndexFields.LUCENE_VERSION);
  analyzerByLanguage=new HashMap<>();
  registerIfEnabled(SupportedLanguage.ar,aConfiguration,new ArabicAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.bg,aConfiguration,new BulgarianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.br,aConfiguration,new BrazilianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.ca,aConfiguration,new CatalanAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.ckb,aConfiguration,new SoraniAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.cz,aConfiguration,new CzechAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.da,aConfiguration,new DanishAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.de,aConfiguration,new GermanAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.el,aConfiguration,new GreekAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.en,aConfiguration,new EnglishAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.es,aConfiguration,new SpanishAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.eu,aConfiguration,new BasqueAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.fa,aConfiguration,new PersianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.fi,aConfiguration,new FinnishAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.fr,aConfiguration,new FrenchAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.ga,aConfiguration,new IrishAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.gl,aConfiguration,new GalicianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.hi,aConfiguration,new HindiAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.hu,aConfiguration,new HungarianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.hy,aConfiguration,new ArmenianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.id,aConfiguration,new IndonesianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.it,aConfiguration,new ItalianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.lv,aConfiguration,new LatvianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.nl,aConfiguration,new DutchAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.no,aConfiguration,new NorwegianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.pt,aConfiguration,new PortugueseAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.ro,aConfiguration,new RomanianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.ru,aConfiguration,new RussianAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.sv,aConfiguration,new SwedishAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.th,aConfiguration,new ThaiAnalyzer(IndexFields.LUCENE_VERSION));
  registerIfEnabled(SupportedLanguage.tr,aConfiguration,new TurkishAnalyzer(IndexFields.LUCENE_VERSION));
}"
11278,"public Backend(Notifier aNotifier,Configuration aConfiguration) throws IOException {
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor();
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    Configuration.CrawlLocation aFileSystemLocation,    Path aFile){
      try {
        String theFilename=aFile.toString();
        if (luceneIndexHandler.checkIfExists(theFilename)) {
          luceneIndexHandler.removeFromIndex(theFilename);
          aNotifier.showInformation(""String_Node_Str"" + aFile.getFileName());
        }
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
      }
    }
    @Override public void fileFoundByCrawler(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,false);
    }
    @Override public void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,true);
    }
    private void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile,    boolean aShowInformation){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressListener.newFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            if (aShowInformation) {
              notifier.showInformation(""String_Node_Str"" + aFile.getFileName());
            }
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aLocation.getId(),theContent);
            }
          }
 else {
            LOGGER.info(""String_Node_Str"" + aFile + ""String_Node_Str""+ theUpdateCheckResult);
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
        }
      }
    }
  }
;
  configurationUpdated(aConfiguration);
}","public Backend(Notifier aNotifier,Configuration aConfiguration) throws IOException {
  notifier=aNotifier;
  locations=new HashMap<>();
  executorPool=new ExecutorPool();
  contentExtractor=new ContentExtractor(aConfiguration);
  directoryListener=new DirectoryListener(){
    @Override public void fileDeleted(    Configuration.CrawlLocation aFileSystemLocation,    Path aFile){
      try {
        String theFilename=aFile.toString();
        if (luceneIndexHandler.checkIfExists(theFilename)) {
          luceneIndexHandler.removeFromIndex(theFilename);
          aNotifier.showInformation(""String_Node_Str"" + aFile.getFileName());
        }
      }
 catch (      Exception e) {
        aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
      }
    }
    @Override public void fileFoundByCrawler(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,false);
    }
    @Override public void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile){
      fileCreatedOrModified(aLocation,aFile,true);
    }
    private void fileCreatedOrModified(    Configuration.CrawlLocation aLocation,    Path aFile,    boolean aShowInformation){
      String theFileName=aFile.toString();
      if (contentExtractor.supportsFile(theFileName)) {
        try {
          progressListener.newFileFound(theFileName);
          BasicFileAttributes theAttributes=Files.readAttributes(aFile,BasicFileAttributes.class);
          UpdateCheckResult theUpdateCheckResult=luceneIndexHandler.checkIfModified(theFileName,theAttributes.size());
          if (theUpdateCheckResult == UpdateCheckResult.UPDATED) {
            if (aShowInformation) {
              notifier.showInformation(""String_Node_Str"" + aFile.getFileName());
            }
            Content theContent=contentExtractor.extractContentFrom(aFile,theAttributes);
            if (theContent != null) {
              luceneIndexHandler.addToIndex(aLocation.getId(),theContent);
            }
          }
 else {
            LOGGER.info(""String_Node_Str"" + aFile + ""String_Node_Str""+ theUpdateCheckResult);
          }
        }
 catch (        Exception e) {
          aNotifier.showError(""String_Node_Str"" + aFile.getFileName(),e);
        }
      }
    }
  }
;
  configurationUpdated(aConfiguration);
}"
11279,"private void setIndexLocation(File aFile) throws IOException {
  if (luceneIndexHandler != null) {
    shutdown();
  }
  luceneIndexHandler=new LuceneIndexHandler(aFile);
}","private void setIndexLocation(Configuration aConfiguration) throws IOException {
  if (luceneIndexHandler != null) {
    shutdown();
  }
  AnalyzerCache theCache=new AnalyzerCache(aConfiguration);
  luceneIndexHandler=new LuceneIndexHandler(aConfiguration.getIndexDirectory(),theCache);
}"
11280,"@Override public void configurationUpdated(Configuration aConfiguration) throws IOException {
  setIndexLocation(aConfiguration.getIndexDirectory());
  configuration=aConfiguration;
  locations.values().stream().forEach(DirectoryWatcher::stopWatching);
  locations.clear();
  aConfiguration.getCrawlLocations().stream().forEach(e -> {
    File theDirectory=e.getDirectory();
    if (theDirectory.exists() && theDirectory.isDirectory()) {
      try {
        add(e);
      }
 catch (      IOException e1) {
        LOGGER.error(""String_Node_Str"" + theDirectory,e1);
      }
    }
  }
);
}","@Override public void configurationUpdated(Configuration aConfiguration) throws IOException {
  setIndexLocation(aConfiguration);
  configuration=aConfiguration;
  locations.values().stream().forEach(DirectoryWatcher::stopWatching);
  locations.clear();
  aConfiguration.getCrawlLocations().stream().forEach(e -> {
    File theDirectory=e.getDirectory();
    if (theDirectory.exists() && theDirectory.isDirectory()) {
      try {
        add(e);
      }
 catch (      IOException e1) {
        LOGGER.error(""String_Node_Str"" + theDirectory,e1);
      }
    }
  }
);
}"
11281,"public Configuration(File aConfigDirectory){
  numberOfSearchResults=50;
  showSimilarDocuments=false;
  crawlLocations=new ArrayList<>();
  indexDirectory=new File(aConfigDirectory,""String_Node_Str"");
}","public Configuration(File aConfigDirectory){
  this();
  indexDirectory=new File(aConfigDirectory,""String_Node_Str"");
}"
11282,"private void initializeWithDefault(File aConfigDirectory){
  try (InputStream theDefaultConfiguration=getClass().getResourceAsStream(""String_Node_Str"")){
    loadConfigurationFrom(theDefaultConfiguration);
  }
 catch (  IOException e) {
    LOGGER.error(""String_Node_Str"",e);
    configuration=new Configuration(aConfigDirectory);
  }
  writeConfiguration();
}","private void initializeWithDefault(File aConfigDirectory){
  try (InputStream theDefaultConfiguration=getClass().getResourceAsStream(""String_Node_Str"")){
    if (theDefaultConfiguration != null) {
      loadConfigurationFrom(theDefaultConfiguration);
    }
 else {
      LOGGER.error(""String_Node_Str"");
      configuration=new Configuration(aConfigDirectory);
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
    configuration=new Configuration(aConfigDirectory);
  }
  writeConfiguration();
}"
11283,"public String getLanguage(){
  return language;
}","public SupportedLanguage getLanguage(){
  return language;
}"
11284,"public Content(String aFileName,String aFileContent,long aFileSize,long aLastModified,String aLanguage){
  fileName=aFileName;
  fileSize=aFileSize;
  lastModified=aLastModified;
  metadata=new ArrayList<>();
  fileContent=aFileContent;
  language=aLanguage;
}","public Content(String aFileName,String aFileContent,long aFileSize,long aLastModified,SupportedLanguage aLanguage){
  fileName=aFileName;
  fileSize=aFileSize;
  lastModified=aLastModified;
  metadata=new ArrayList<>();
  fileContent=aFileContent;
  language=aLanguage;
}"
11285,"private List<String> getUserOrganisations(final User user){
  final CompanyCollection companyCollection=user.getCompanyCollection();
  final List<String> companies=new ArrayList<>();
  while (companyCollection.hasNext()) {
    companies.add(companyCollection.next().getId());
  }
  return companies;
}","private List<String> getUserOrganisations(final User user){
  final CompanyCollection companyCollection=user.getCompanyCollection();
  final List<String> companies=new ArrayList<>();
  while (companyCollection.hasNext()) {
    companies.add(companyCollection.next().getCompanyID());
  }
  return companies;
}"
11286,"@Test public void shouldReturnUser_withUserId(){
  final String userId=randomId();
  final Map<String,String> params=new HashMap<>();
  params.put(""String_Node_Str"",userId);
  final User mockUser=randomIntercomUser();
  when(User.find(params)).thenReturn(mockUser);
  final Map<String,Object> mockCustomAttributes=mock(Map.class);
  when(intercomToMetricMapper.apply(mockUser.getCustomAttributes())).thenReturn(mockCustomAttributes);
  final MetricUser result=intercomMetricCollector.getUser(userId);
  assertNotNull(result);
  assertThat(result.id(),is(mockUser.getUserId()));
  mockUser.getCompanyCollection().forEachRemaining(company -> {
    assertTrue(result.organisationIds().contains(company.getId()));
  }
);
  assertThat(result.name(),is(mockUser.getName()));
  assertThat(result.emailAddress(),is(mockUser.getEmail()));
  assertThat(result.customAttributes(),is(mockCustomAttributes));
}","@Test public void shouldReturnUser_withUserId(){
  final String userId=randomId();
  final Map<String,String> params=new HashMap<>();
  params.put(""String_Node_Str"",userId);
  final User user=randomIntercomUser();
  when(User.find(params)).thenReturn(user);
  final Map<String,CustomAttribute> mockCustomAttributes=mock(Map.class);
  user.setCustomAttributes(mockCustomAttributes);
  final MetricUser result=intercomMetricCollector.getUser(userId);
  assertNotNull(result);
  assertThat(result.id(),is(user.getUserId()));
  user.getCompanyCollection().getPage().forEach(company -> {
    assertTrue(result.organisationIds().contains(company.getCompanyID()));
  }
);
  assertThat(result.name(),is(user.getName()));
  assertThat(result.emailAddress(),is(user.getEmail()));
  assertThat(result.customAttributes(),is(mockCustomAttributes));
}"
11287,"public static CompanyCollection randomCompanyCollection(){
  final List<Company> companies=new ArrayList<>();
  final CompanyCollection companyCollection=mock(CompanyCollection.class);
  final int numberOfCompanies=randomIntInRange(1,10);
  for (int i=0; i < numberOfCompanies; i++) {
    final Company mockCompany=mock(Company.class);
    final String companyId=randomId();
    when(mockCompany.getCompanyID()).thenReturn(companyId);
    companies.add(mockCompany);
  }
  when(companyCollection.getPage()).thenReturn(companies);
  return companyCollection;
}","public static CompanyCollection randomCompanyCollection(){
  final List<Company> companies=new ArrayList<>();
  final int numberOfCompanies=randomIntInRange(1,10);
  for (int i=0; i < numberOfCompanies; i++) {
    final Company mockCompany=mock(Company.class);
    final String id=randomId();
    when(mockCompany.getId()).thenReturn(id);
    final String companyId=randomId();
    when(mockCompany.getCompanyID()).thenReturn(companyId);
    companies.add(mockCompany);
  }
  return new CompanyCollection(companies);
}"
11288,"@Test public void shouldNotFetch_withAmazonServiceException() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenThrow(AmazonServiceException.class);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  PersistenceResourceFailureException actualException=null;
  try {
    dynamoDbTemplate.fetch(query,StubItem.class);
  }
 catch (  final PersistenceResourceFailureException e) {
    actualException=e;
  }
  assertNotNull(actualException);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
}","@Test public void shouldNotFetch_withAmazonServiceException() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenThrow(AmazonServiceException.class);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  PersistenceResourceFailureException actualException=null;
  try {
    dynamoDbTemplate.fetch(query,StubItem.class);
  }
 catch (  final PersistenceResourceFailureException e) {
    actualException=e;
  }
  assertNotNull(actualException);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
}"
11289,"@Test public void shouldFetch_withACompoundAttributeQueryOnACompoundGSIWithAHashValueTheSameAsThePrimaryKeyDefinition(){
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName,new PrimaryKeyDefinition(""String_Node_Str""));
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withACompoundAttributeQueryOnACompoundGSIWithAHashValueTheSameAsThePrimaryKeyDefinition(){
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName,new PrimaryKeyDefinition(""String_Node_Str""));
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11290,"@Test public void shouldFetchEmptyList_withAttributeQueryWithEmptyAttributeList() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(false);
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  verify(mockAmazonDynamoDbClient,never()).query(any(QueryRequest.class));
  assertTrue(returnedItems.isEmpty());
}","@Test public void shouldFetchEmptyList_withAttributeQueryWithEmptyAttributeList() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(true);
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  verify(mockAmazonDynamoDbClient,never()).query(any(QueryRequest.class));
  assertTrue(returnedItems.isEmpty());
}"
11291,"@Test public void shouldFetch_withVariantItemAttributeQueryOnParentIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  parentItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withVariantItemAttributeQueryOnParentIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  parentItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11292,"@Test public void shouldFetch_withAttributeQueryOnHashKeyPartOfCompoundIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withAttributeQueryOnHashKeyPartOfCompoundIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11293,"@Test public void shouldFetch_withCompoundAttributeQueryOnIndex() throws Exception {
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withCompoundAttributeQueryOnIndex() throws Exception {
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11294,"@Test public void shouldFetch_withAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11295,"@Test public void shouldFetch_withAttributeQueryOnPrimaryKey() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withAttributeQueryOnPrimaryKey() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11296,"@Test public void shouldFetch_withVariantItemAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  variantItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withVariantItemAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.hasMissingComparisonValues()).thenReturn(false);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  variantItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11297,"@Test public void shouldNotFetch_withAmazonServiceException() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenThrow(AmazonServiceException.class);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  PersistenceResourceFailureException actualException=null;
  try {
    dynamoDbTemplate.fetch(query,StubItem.class);
  }
 catch (  final PersistenceResourceFailureException e) {
    actualException=e;
  }
  assertNotNull(actualException);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
}","@Test public void shouldNotFetch_withAmazonServiceException() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenThrow(AmazonServiceException.class);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  PersistenceResourceFailureException actualException=null;
  try {
    dynamoDbTemplate.fetch(query,StubItem.class);
  }
 catch (  final PersistenceResourceFailureException e) {
    actualException=e;
  }
  assertNotNull(actualException);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
}"
11298,"@Test public void shouldFetch_withACompoundAttributeQueryOnACompoundGSIWithAHashValueTheSameAsThePrimaryKeyDefinition(){
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName,new PrimaryKeyDefinition(""String_Node_Str""));
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withACompoundAttributeQueryOnACompoundGSIWithAHashValueTheSameAsThePrimaryKeyDefinition(){
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName,new PrimaryKeyDefinition(""String_Node_Str""));
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11299,"@Test public void shouldFetchEmptyList_withAttributeQueryWithEmptyAttributeList() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(false);
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  verify(mockAmazonDynamoDbClient,never()).query(any(QueryRequest.class));
  assertTrue(returnedItems.isEmpty());
}","@Test public void shouldFetchEmptyList_withAttributeQueryWithEmptyAttributeList() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(false);
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  verify(mockAmazonDynamoDbClient,never()).query(any(QueryRequest.class));
  assertTrue(returnedItems.isEmpty());
}"
11300,"@Test public void shouldFetch_withVariantItemAttributeQueryOnParentIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  parentItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withVariantItemAttributeQueryOnParentIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  parentItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11301,"@Test public void shouldFetch_withAttributeQueryOnHashKeyPartOfCompoundIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withAttributeQueryOnHashKeyPartOfCompoundIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11302,"@Test public void shouldFetch_withCompoundAttributeQueryOnIndex() throws Exception {
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withCompoundAttributeQueryOnIndex() throws Exception {
  final String itemId=randomId();
  final String gsiProperty=randomString(10);
  final Integer gsiSupportingProperty=randomInt(20);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(gsiProperty));
  final Set<String> stringSupportingPropertyValues=new HashSet<>(Arrays.asList(String.valueOf(gsiSupportingProperty)));
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,tableName);
  itemConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  final Condition mockSupportingCondition=mock(Condition.class);
  when(mockSupportingCondition.getComparisonOperator()).thenReturn(Operators.LESS_THAN_OR_EQUALS);
  when(mockSupportingCondition.getValues()).thenReturn(stringSupportingPropertyValues);
  final CompoundAttributeQuery query=mock(CompoundAttributeQuery.class);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  when(query.getSupportingAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getSupportingCondition()).thenReturn(mockSupportingCondition);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(gsiProperty));
  final AttributeValue gsiSupportingPropertyAttributeValue=new AttributeValue();
  gsiSupportingPropertyAttributeValue.withN(String.valueOf(gsiSupportingProperty));
  mockItem.put(""String_Node_Str"",gsiSupportingPropertyAttributeValue);
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubWithGlobalSecondaryIndexItem> returnedItems=dynamoDbTemplate.fetch(query,StubWithGlobalSecondaryIndexItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(2,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(gsiProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(gsiSupportingPropertyAttributeValue,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11303,"@Test public void shouldFetch_withAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  itemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11304,"@Test public void shouldFetch_withAttributeQueryOnPrimaryKey() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withAttributeQueryOnPrimaryKey() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ItemConfiguration itemConfiguration=new ItemConfiguration(StubItem.class,tableName);
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(itemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubItem> returnedItems=dynamoDbTemplate.fetch(query,StubItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertNull(queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11305,"@Test public void shouldFetch_withVariantItemAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsNonNullOrEmptyValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  variantItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}","@Test public void shouldFetch_withVariantItemAttributeQueryOnIndex() throws Exception {
  final AttributeQuery query=mock(AttributeQuery.class);
  final Condition mockCondition=mock(Condition.class);
  when(mockCondition.getComparisonOperator()).thenReturn(Operators.EQUALS);
  final String itemId=randomId();
  final String stringProperty=randomString(10);
  final Set<String> stringPropertyValues=new HashSet<>(Arrays.asList(stringProperty));
  when(mockCondition.getValues()).thenReturn(stringPropertyValues);
  when(mockCondition.containsRequiredComparisonValues()).thenReturn(true);
  when(query.getAttributeName()).thenReturn(""String_Node_Str"");
  when(query.getCondition()).thenReturn(mockCondition);
  final ParentItemConfiguration parentItemConfiguration=new ParentItemConfiguration(StubItem.class,tableName);
  final VariantItemConfiguration variantItemConfiguration=new VariantItemConfiguration(parentItemConfiguration,StubVariantItem.class,""String_Node_Str"");
  variantItemConfiguration.registerIndexes(Arrays.asList(new IndexDefinition(""String_Node_Str"")));
  final Collection<ItemConfiguration> itemConfigurations=Arrays.asList(parentItemConfiguration,variantItemConfiguration);
  when(mockDatabaseSchemaHolder.itemConfigurations()).thenReturn(itemConfigurations);
  final DynamoDbTemplate dynamoDbTemplate=new DynamoDbTemplate(mockDatabaseSchemaHolder);
  final QueryResult mockQueryResult=mock(QueryResult.class);
  final Map<String,AttributeValue> mockItem=new HashMap<>();
  mockItem.put(""String_Node_Str"",new AttributeValue(itemId));
  mockItem.put(""String_Node_Str"",new AttributeValue(stringProperty));
  mockItem.put(""String_Node_Str"",new AttributeValue(""String_Node_Str""));
  final List<Map<String,AttributeValue>> mockItems=Arrays.asList(mockItem);
  when(mockQueryResult.getItems()).thenReturn(mockItems);
  when(mockQueryResult.getLastEvaluatedKey()).thenReturn(null);
  when(mockAmazonDynamoDbClient.query(any(QueryRequest.class))).thenReturn(mockQueryResult);
  dynamoDbTemplate.initialize(mockAmazonDynamoDbClient);
  final Collection<StubVariantItem> returnedItems=dynamoDbTemplate.fetch(query,StubVariantItem.class);
  final ArgumentCaptor<QueryRequest> queryRequestArgumentCaptor=ArgumentCaptor.forClass(QueryRequest.class);
  verify(mockAmazonDynamoDbClient).query(queryRequestArgumentCaptor.capture());
  final QueryRequest queryRequest=queryRequestArgumentCaptor.getValue();
  assertEquals(schemaName + ""String_Node_Str"" + tableName,queryRequest.getTableName());
  assertEquals(""String_Node_Str"",queryRequest.getIndexName());
  assertEquals(1,queryRequest.getKeyConditions().size());
  assertEquals(""String_Node_Str"",queryRequest.getKeyConditions().get(""String_Node_Str"").getComparisonOperator());
  assertEquals(1,queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().size());
  assertEquals(new AttributeValue(stringProperty),queryRequest.getKeyConditions().get(""String_Node_Str"").getAttributeValueList().get(0));
  assertNotNull(returnedItems);
  assertEquals(1,returnedItems.size());
}"
11306,"@Autowired public RestResourceConfig(final ApplicationContext applicationContext){
  property(""String_Node_Str"",applicationContext);
  scanner=new ClassPathScanningCandidateComponentProvider(true);
  scanner.resetFilters(false);
  scanner.addIncludeFilter(new AnnotationTypeFilter(Path.class));
  scanner.addIncludeFilter(new AnnotationTypeFilter(Provider.class));
  register(RequestContextFilter.class);
  register(MultiPartFeature.class);
  register(ObjectMapperProvider.class);
  register(JacksonFeature.class);
  registerResources(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  property(ServerProperties.LOCATION_HEADER_RELATIVE_URI_RESOLUTION_DISABLED,true);
}","@Autowired public RestResourceConfig(final ApplicationContext applicationContext){
  property(""String_Node_Str"",applicationContext);
  scanner=new ClassPathScanningCandidateComponentProvider(true);
  scanner.resetFilters(false);
  scanner.addIncludeFilter(new AnnotationTypeFilter(Path.class));
  scanner.addIncludeFilter(new AnnotationTypeFilter(Provider.class));
  register(RequestContextFilter.class);
  register(MultiPartFeature.class);
  register(ObjectMapperProvider.class);
  register(JacksonFeature.class);
  registerResources(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  property(ServerProperties.LOCATION_HEADER_RELATIVE_URI_RESOLUTION_DISABLED,true);
}"
11307,"private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final ItemConfiguration itemConfiguration=getItemConfiguration(itemClass);
  final String tableName=databaseSchemaHolder.schemaName() + ""String_Node_Str"" + itemConfiguration.tableName();
  final Table table=dynamoDBClient.getTable(tableName);
  final List<T> totalItems=new ArrayList<>();
  if (itemConfiguration.hasIndexForQuery(query) && query.getCondition().getComparisonOperator() == Operators.EQUALS) {
    final QuerySpec querySpec=QuerySpecBuilder.build(query,itemClass);
    final ItemCollection<QueryOutcome> queryOutcome;
    if (itemConfiguration.primaryKeyDefinition().propertyName().equals(query.getAttributeName())) {
      queryOutcome=table.query(querySpec);
    }
 else {
      final String indexName=IndexNameBuilder.build(query);
      final Index index=table.getIndex(indexName);
      queryOutcome=index.query(querySpec);
    }
    final Iterator<com.amazonaws.services.dynamodbv2.document.Item> iterator=queryOutcome.iterator();
    while (iterator != null && iterator.hasNext()) {
      final com.amazonaws.services.dynamodbv2.document.Item item=iterator.next();
      totalItems.add(stringToItem(item.toJSON(),itemClass));
    }
  }
 else {
    logger.debug(""String_Node_Str"" + query);
    ScanSpec scanSpec=null;
    try {
      scanSpec=generateScanSpec(query,itemClass);
    }
 catch (    InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException e) {
      throw new PersistenceResourceFailureException(""String_Node_Str"" + tableName + ""String_Node_Str""+ query,e);
    }
    final ItemCollection<ScanOutcome> scanOutcome=table.scan(scanSpec);
    final Iterator<com.amazonaws.services.dynamodbv2.document.Item> iterator=scanOutcome.iterator();
    while (iterator.hasNext()) {
      final com.amazonaws.services.dynamodbv2.document.Item item=iterator.next();
      totalItems.add(stringToItem(item.toJSON(),itemClass));
    }
  }
  return totalItems;
}","private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final ItemConfiguration itemConfiguration=getItemConfiguration(itemClass);
  final String tableName=databaseSchemaHolder.schemaName() + ""String_Node_Str"" + itemConfiguration.tableName();
  final Table table=dynamoDBClient.getTable(tableName);
  final List<T> totalItems=new ArrayList<>();
  if (itemConfiguration.hasIndexForQuery(query) && query.getCondition().getComparisonOperator() == Operators.EQUALS) {
    final QuerySpec querySpec=QuerySpecBuilder.build(query,itemClass);
    final ItemCollection<QueryOutcome> queryOutcome;
    if (itemConfiguration.primaryKeyDefinition().propertyName().equals(query.getAttributeName()) && !(query instanceof CompoundAttributeQuery)) {
      queryOutcome=table.query(querySpec);
    }
 else {
      final String indexName=IndexNameBuilder.build(query);
      final Index index=table.getIndex(indexName);
      queryOutcome=index.query(querySpec);
    }
    final Iterator<com.amazonaws.services.dynamodbv2.document.Item> iterator=queryOutcome.iterator();
    while (iterator != null && iterator.hasNext()) {
      final com.amazonaws.services.dynamodbv2.document.Item item=iterator.next();
      totalItems.add(stringToItem(item.toJSON(),itemClass));
    }
  }
 else {
    logger.debug(""String_Node_Str"" + query);
    ScanSpec scanSpec=null;
    try {
      scanSpec=generateScanSpec(query,itemClass);
    }
 catch (    InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException|NoSuchMethodException|SecurityException e) {
      throw new PersistenceResourceFailureException(""String_Node_Str"" + tableName + ""String_Node_Str""+ query,e);
    }
    final ItemCollection<ScanOutcome> scanOutcome=table.scan(scanSpec);
    final Iterator<com.amazonaws.services.dynamodbv2.document.Item> iterator=scanOutcome.iterator();
    while (iterator.hasNext()) {
      final com.amazonaws.services.dynamodbv2.document.Item item=iterator.next();
      totalItems.add(stringToItem(item.toJSON(),itemClass));
    }
  }
  return totalItems;
}"
11308,"public void createStubItemWithGlobalSecondaryIndexTable() throws Exception {
  final String tableName=unitTestSchemaName + ""String_Node_Str"" + stubItemWithGsiTableName;
  boolean tableCreated=false;
  try {
    final DescribeTableResult result=amazonDynamoDbClient.describeTable(tableName);
    if (isTableCreated(tableName,result)) {
      tableCreated=true;
    }
  }
 catch (  final ResourceNotFoundException e) {
    tableCreated=false;
  }
  if (!tableCreated) {
    final Collection<AttributeDefinition> attributeDefinitions=new ArrayList<>();
    attributeDefinitions.add(new AttributeDefinition(""String_Node_Str"",ScalarAttributeType.S));
    attributeDefinitions.add(new AttributeDefinition(""String_Node_Str"",ScalarAttributeType.S));
    attributeDefinitions.add(new AttributeDefinition(""String_Node_Str"",ScalarAttributeType.N));
    final Collection<KeySchemaElement> keySchema=new ArrayList<>();
    keySchema.add(new KeySchemaElement(""String_Node_Str"",""String_Node_Str"").withKeyType(KeyType.HASH));
    final GlobalSecondaryIndex globalSecondaryIndex=new GlobalSecondaryIndex();
    final Collection<KeySchemaElement> globalSecondaryIndexKeySchema=new ArrayList<>();
    globalSecondaryIndexKeySchema.add(new KeySchemaElement(""String_Node_Str"",""String_Node_Str"").withKeyType(KeyType.HASH));
    globalSecondaryIndexKeySchema.add(new KeySchemaElement(""String_Node_Str"",""String_Node_Str"").withKeyType(KeyType.RANGE));
    globalSecondaryIndex.setIndexName(""String_Node_Str"");
    globalSecondaryIndex.setKeySchema(globalSecondaryIndexKeySchema);
    globalSecondaryIndex.setProvisionedThroughput(new ProvisionedThroughput(10L,10L));
    final Projection projection=new Projection();
    projection.setProjectionType(ProjectionType.ALL);
    globalSecondaryIndex.setProjection(projection);
    final CreateTableRequest createTableRequest=new CreateTableRequest().withTableName(tableName).withAttributeDefinitions(attributeDefinitions).withKeySchema(keySchema).withGlobalSecondaryIndexes(globalSecondaryIndex).withProvisionedThroughput(new ProvisionedThroughput(10L,10L));
    amazonDynamoDbClient.createTable(createTableRequest);
    final long startTime=System.currentTimeMillis();
    do {
      Thread.sleep(1000);
      final DescribeTableResult describeTableResult=amazonDynamoDbClient.describeTable(tableName);
      tableCreated=isTableCreated(tableName,describeTableResult);
    }
 while (!tableCreated && System.currentTimeMillis() - startTime < 60000);
  }
}","public void createStubItemWithGlobalSecondaryIndexTable() throws Exception {
  final String tableName=unitTestSchemaName + ""String_Node_Str"" + stubItemWithGsiTableName;
  boolean tableCreated=false;
  try {
    final DescribeTableResult result=amazonDynamoDbClient.describeTable(tableName);
    if (isTableCreated(tableName,result)) {
      tableCreated=true;
    }
  }
 catch (  final ResourceNotFoundException e) {
    tableCreated=false;
  }
  if (!tableCreated) {
    final Collection<AttributeDefinition> attributeDefinitions=new ArrayList<>();
    attributeDefinitions.add(new AttributeDefinition(""String_Node_Str"",ScalarAttributeType.S));
    attributeDefinitions.add(new AttributeDefinition(""String_Node_Str"",ScalarAttributeType.S));
    attributeDefinitions.add(new AttributeDefinition(""String_Node_Str"",ScalarAttributeType.N));
    final Collection<KeySchemaElement> keySchema=new ArrayList<>();
    keySchema.add(new KeySchemaElement(""String_Node_Str"",""String_Node_Str"").withKeyType(KeyType.HASH));
    final GlobalSecondaryIndex globalSecondaryIndex=buildSimpleCompoundGlobalSecondaryIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final CreateTableRequest createTableRequest=new CreateTableRequest().withTableName(tableName).withAttributeDefinitions(attributeDefinitions).withKeySchema(keySchema).withGlobalSecondaryIndexes(globalSecondaryIndex).withProvisionedThroughput(new ProvisionedThroughput(10L,10L));
    amazonDynamoDbClient.createTable(createTableRequest);
    final long startTime=System.currentTimeMillis();
    do {
      Thread.sleep(1000);
      final DescribeTableResult describeTableResult=amazonDynamoDbClient.describeTable(tableName);
      tableCreated=isTableCreated(tableName,describeTableResult);
    }
 while (!tableCreated && System.currentTimeMillis() - startTime < 60000);
  }
}"
11309,"@Before public void init() throws Exception {
  createdItemIds.clear();
  dataGenerator.getCreatedItemIds().clear();
  final Collection<ItemConfiguration> itemConfigurations=new ArrayList<>();
  final ItemConfiguration stubItemConfiguration=new ItemConfiguration(StubItem.class,dataGenerator.getStubItemTableName());
  final ItemConfiguration stubItemWithRangeConfiguration=new ItemConfiguration(StubWithRangeItem.class,dataGenerator.getStubItemWithRangeTableName(),new CompoundPrimaryKeyDefinition(""String_Node_Str"",""String_Node_Str""));
  final ParentItemConfiguration stubParentItemConfiguration=new ParentItemConfiguration(StubParentItem.class,dataGenerator.getStubItemTableName());
  final ItemConfiguration stubItemwithGsiConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,dataGenerator.getStubItemWithGsiTableName());
  stubItemwithGsiConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  itemConfigurations.add(stubItemConfiguration);
  itemConfigurations.add(stubItemWithRangeConfiguration);
  itemConfigurations.add(stubParentItemConfiguration);
  itemConfigurations.add(new VariantItemConfiguration(stubParentItemConfiguration,StubVariantItem.class,""String_Node_Str""));
  itemConfigurations.add(stubItemwithGsiConfiguration);
  databaseSchemaHolder=new DatabaseSchemaHolder(dataGenerator.getUnitTestSchemaName(),itemConfigurations);
}","@Before public void init() throws Exception {
  createdItemIds.clear();
  dataGenerator.getCreatedItemIds().clear();
  final Collection<ItemConfiguration> itemConfigurations=new ArrayList<>();
  final ItemConfiguration stubItemConfiguration=new ItemConfiguration(StubItem.class,dataGenerator.getStubItemTableName());
  final ItemConfiguration stubItemWithRangeConfiguration=new ItemConfiguration(StubWithRangeItem.class,dataGenerator.getStubItemWithRangeTableName(),new CompoundPrimaryKeyDefinition(""String_Node_Str"",""String_Node_Str""));
  final ParentItemConfiguration stubParentItemConfiguration=new ParentItemConfiguration(StubParentItem.class,dataGenerator.getStubItemTableName());
  final ItemConfiguration stubItemwithGsiConfiguration=new ItemConfiguration(StubWithGlobalSecondaryIndexItem.class,dataGenerator.getStubItemWithGsiTableName());
  stubItemwithGsiConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  final ItemConfiguration stubItemWithHashAndRangeAndGsiConfiguration=new ItemConfiguration(StubWithHashAndRangeAndGlobalSecondaryIndexItem.class,dataGenerator.getStubItemWithHashAndRangeAndGsiTableName(),new CompoundPrimaryKeyDefinition(""String_Node_Str"",""String_Node_Str""));
  stubItemWithHashAndRangeAndGsiConfiguration.registerIndexes((Arrays.asList(new CompoundIndexDefinition(""String_Node_Str"",""String_Node_Str""))));
  itemConfigurations.add(stubItemConfiguration);
  itemConfigurations.add(stubItemWithRangeConfiguration);
  itemConfigurations.add(stubParentItemConfiguration);
  itemConfigurations.add(new VariantItemConfiguration(stubParentItemConfiguration,StubVariantItem.class,""String_Node_Str""));
  itemConfigurations.add(stubItemwithGsiConfiguration);
  itemConfigurations.add(stubItemWithHashAndRangeAndGsiConfiguration);
  databaseSchemaHolder=new DatabaseSchemaHolder(dataGenerator.getUnitTestSchemaName(),itemConfigurations);
}"
11310,"@BeforeClass public static void createTables() throws Exception {
  amazonDynamoDbClient=new AmazonDynamoDBClient(new BasicAWSCredentials(AwsIntegration.getAccessKeyId(),AwsIntegration.getSecretKeyId()));
  amazonDynamoDbClient.setEndpoint(AwsIntegration.getDynamoDbEndpoint());
  dataGenerator=new DynamoDbDataGenerator(amazonDynamoDbClient);
  dataGenerator.createStubItemTable();
  dataGenerator.createStubItemWithRangeTable();
  dataGenerator.createStubItemWithGlobalSecondaryIndexTable();
}","@BeforeClass public static void createTables() throws Exception {
  amazonDynamoDbClient=new AmazonDynamoDBClient(new BasicAWSCredentials(AwsIntegration.getAccessKeyId(),AwsIntegration.getSecretKeyId()));
  amazonDynamoDbClient.setEndpoint(AwsIntegration.getDynamoDbEndpoint());
  dataGenerator=new DynamoDbDataGenerator(amazonDynamoDbClient);
  dataGenerator.createStubItemTable();
  dataGenerator.createStubItemWithRangeTable();
  dataGenerator.createStubItemWithGlobalSecondaryIndexTable();
  dataGenerator.createStubItemWithHashAndRangePrimaryKeyAndCompoundGlobalSecondaryIndexTable();
}"
11311,"protected void handlePersistenceException(final PersistenceException persistenceException) throws Throwable {
  if (persistenceExceptionHandlers.isEmpty()) {
    throw persistenceException;
  }
  for (  final PersistenceExceptionHandler<?> persistenceExceptionHandler : persistenceExceptionHandlers) {
    Method method;
    try {
      method=getPersistenceHandlerMethod(persistenceExceptionHandler,persistenceException);
    }
 catch (    final NoSuchMethodException e) {
      continue;
    }
    try {
      method.setAccessible(true);
      method.invoke(persistenceExceptionHandler,persistenceException);
    }
 catch (    IllegalAccessException|IllegalArgumentException e) {
      continue;
    }
catch (    final InvocationTargetException handlerException) {
      throw handlerException.getCause();
    }
  }
}","protected void handlePersistenceException(final PersistenceException persistenceException) throws Throwable {
  if (persistenceExceptionHandlers.isEmpty()) {
    throw persistenceException;
  }
  boolean foundPersistenceExceptionHandlerMethod=false;
  for (  final PersistenceExceptionHandler<?> persistenceExceptionHandler : persistenceExceptionHandlers) {
    Method method;
    try {
      method=getPersistenceHandlerMethod(persistenceExceptionHandler,persistenceException);
    }
 catch (    final NoSuchMethodException e) {
      continue;
    }
    try {
      foundPersistenceExceptionHandlerMethod=true;
      method.setAccessible(true);
      method.invoke(persistenceExceptionHandler,persistenceException);
    }
 catch (    IllegalAccessException|IllegalArgumentException e) {
      continue;
    }
catch (    final InvocationTargetException handlerException) {
      throw handlerException.getCause();
    }
  }
  if (!foundPersistenceExceptionHandlerMethod) {
    throw persistenceException;
  }
}"
11312,"public boolean isEnabled(final Feature feature){
  return enabledFeatures(FeaturesContextHolder.get().featureSetId()).contains(feature);
}","public boolean isEnabled(final Feature feature){
  final FeaturesContext featuresContext=FeaturesContextHolder.get();
  return featuresContext != null && enabledFeatures(featuresContext.featureSetId()).contains(feature);
}"
11313,"private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      String singleValue=null;
      if (values != null && !values.isEmpty()) {
        singleValue=values.iterator().next();
      }
      final boolean isSingleItemProperty=!Collection.class.isAssignableFrom(itemPropertyType);
      String singleItemPropertyValue=null;
      if (isSingleItemProperty) {
        singleItemPropertyValue=String.valueOf(itemPropertyValue);
      }
switch (query.getCondition().getComparisonOperator()) {
case NULL:
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      break;
case NOT_NULL:
    if (itemPropertyValue != null) {
      matches.add(item);
    }
  break;
case LESS_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) <= 0) {
  matches.add(item);
}
break;
case GREATER_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) >= 0) {
matches.add(item);
}
break;
case EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.equals(singleValue)) {
matches.add(item);
}
 else if (values.equals(itemPropertyValue)) {
matches.add(item);
}
break;
default :
break;
}
}
 catch (final Exception e) {
e.printStackTrace();
throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
}
}
return matches;
}","private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      String singleValue=null;
      if (values != null && !values.isEmpty()) {
        singleValue=values.iterator().next();
      }
      final boolean isSingleItemProperty=!Collection.class.isAssignableFrom(itemPropertyType);
      String singleItemPropertyValue=null;
      if (isSingleItemProperty) {
        singleItemPropertyValue=String.valueOf(itemPropertyValue);
      }
switch (query.getCondition().getComparisonOperator()) {
case NULL:
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      break;
case NOT_NULL:
    if (itemPropertyValue != null) {
      matches.add(item);
    }
  break;
case LESS_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) <= 0) {
  matches.add(item);
}
break;
case GREATER_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) >= 0) {
matches.add(item);
}
break;
case EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.equals(singleValue)) {
matches.add(item);
}
 else if (values.equals(itemPropertyValue)) {
matches.add(item);
}
break;
default :
break;
}
}
 catch (final Exception e) {
throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
}
}
return matches;
}"
11314,"@Test public void shouldCreateDefaultSearchOptionsWithNewSortOrder(){
  final SortOrder order=new SortOrder();
  final SearchOptions options=new SearchOptions().withSortOrder(order);
  assertEquals(order,options.getSortOrder());
  assertNotEquals(SortOrder.DEFAULT,options.getSortOrder());
}","@Test public void shouldCreateDefaultSearchOptionsWithNewSortOrder(){
  final SortOrder order=new SortOrder();
  final SearchOptions options=new SearchOptions().withSortOrder(order);
  assertEquals(order,options.getSortOrder());
  assertTrue(SortOrder.DEFAULT != options.getSortOrder());
}"
11315,"@Test(expected=IllegalArgumentException.class) public void shouldFailSetDefaultSearchOptionsWithNullSortOrder(){
  final SearchOptions options=new SearchOptions();
  options.setExpressions(null);
}","@Test(expected=IllegalArgumentException.class) public void shouldFailSetDefaultSearchOptionsWithNullSortOrder(){
  final SearchOptions options=new SearchOptions();
  options.setSortOrder(null);
}"
11316,"@SuppressWarnings(""String_Node_Str"") @Override public <T extends Item>T update(final T item,final PersistenceExceptionHandler<?>... persistenceExceptionHandlers){
  final ItemId itemId=getItemId(item);
  final Class<? extends Item> itemType=item.getClass();
  final String tableName=getItemTableName(itemType);
  final SerializedItem oldSerializedItem=getItemMap(tableName).get(itemId);
  if (oldSerializedItem == null) {
    return create(item);
  }
  final T oldItem=(T)oldSerializedItem.getEntity(item.getClass());
  if (!item.getVersion().equals(oldItem.getVersion())) {
    throw new IllegalAccessError(""String_Node_Str"" + item.getVersion() + ""String_Node_Str""+ oldItem.getVersion()+ ""String_Node_Str"");
  }
  deleteUniqueConstraints(oldItem);
  createUniqueConstraints(item);
  item.setVersion(item.getVersion() + 1);
  getItemMap(tableName).put(itemId,getSerializedItem(itemId.value(),item));
  return item;
}","@SuppressWarnings(""String_Node_Str"") @Override public <T extends Item>T update(final T item,final PersistenceExceptionHandler<?>... persistenceExceptionHandlers){
  final ItemId itemId=getItemId(item);
  final Class<? extends Item> itemType=item.getClass();
  final String tableName=getItemTableName(itemType);
  final SerializedItem oldSerializedItem=getItemMap(tableName).get(itemId);
  if (oldSerializedItem == null) {
    return create(item);
  }
  final T oldItem=(T)oldSerializedItem.getEntity(item.getClass());
  if (!item.getVersion().equals(oldItem.getVersion())) {
    throw new IllegalAccessError(""String_Node_Str"" + item.getVersion() + ""String_Node_Str""+ oldItem.getVersion()+ ""String_Node_Str"");
  }
  deleteUniqueConstraints(oldItem);
  try {
    createUniqueConstraints(item);
  }
 catch (  final ItemConstraintViolationException e) {
    createUniqueConstraints(oldItem);
    throw e;
  }
  item.setVersion(item.getVersion() + 1);
  getItemMap(tableName).put(itemId,getSerializedItem(itemId.value(),item));
  return item;
}"
11317,"private void createUniqueConstraints(final Item item){
  final Class<? extends Item> itemClass=item.getClass();
  final String tableName=getItemTableName(itemClass);
  final Collection<PropertyDescriptor> uniqueConstraintProperties=getUniqueConstraintProperties(itemClass);
  for (  final PropertyDescriptor propertyDescriptor : uniqueConstraintProperties) {
    final String propertyName=propertyDescriptor.getName();
    final String uniqueConstraintKey=newUniqueConstraintKey(tableName,propertyName);
    final Map<String,ItemId> uniqueValues=uniqueConstraints.get(uniqueConstraintKey);
    Object propertyValue=null;
    try {
      propertyValue=propertyDescriptor.getReadMethod().invoke(item);
    }
 catch (    final Exception e) {
      throw new IllegalStateException(""String_Node_Str"",e);
    }
    if (propertyValue != null) {
      final String uniqueConstraintPropertyValue=uniqueConstraintPropertyValue(propertyValue);
      final ItemId existingItemId=uniqueValues.get(uniqueConstraintPropertyValue);
      if (existingItemId != null) {
        throw new ItemConstraintViolationException(propertyName,""String_Node_Str"");
      }
      uniqueConstraints.get(uniqueConstraintKey).put(uniqueConstraintPropertyValue,getItemId(item));
    }
  }
}","private void createUniqueConstraints(final Item item){
  final Class<? extends Item> itemClass=item.getClass();
  final String tableName=getItemTableName(itemClass);
  final Collection<PropertyDescriptor> uniqueConstraintProperties=getUniqueConstraintProperties(itemClass);
  final Map<String,String> newConstraints=new HashMap<>();
  final ItemId itemId=getItemId(item);
  for (  final PropertyDescriptor propertyDescriptor : uniqueConstraintProperties) {
    final String propertyName=propertyDescriptor.getName();
    final String uniqueConstraintKey=newUniqueConstraintKey(tableName,propertyName);
    final Map<String,ItemId> uniqueValues=uniqueConstraints.get(uniqueConstraintKey);
    Object propertyValue=null;
    try {
      propertyValue=propertyDescriptor.getReadMethod().invoke(item);
    }
 catch (    final Exception e) {
      throw new IllegalStateException(""String_Node_Str"",e);
    }
    if (propertyValue != null) {
      final String uniqueConstraintPropertyValue=uniqueConstraintPropertyValue(propertyValue);
      final ItemId existingItemId=uniqueValues.get(uniqueConstraintPropertyValue);
      if (existingItemId != null) {
        throw new ItemConstraintViolationException(propertyName,""String_Node_Str"");
      }
      newConstraints.put(uniqueConstraintKey,uniqueConstraintPropertyValue);
    }
  }
  for (  final Entry<String,String> entry : newConstraints.entrySet()) {
    final String uniqueConstraintKey=entry.getKey();
    final String uniqueConstraintPropertyValue=entry.getValue();
    uniqueConstraints.get(uniqueConstraintKey).put(uniqueConstraintPropertyValue,itemId);
  }
}"
11318,"@Test public void shouldNotUpdateItemAndUniqueConstraint_withItemExistingUpdatedUniqueConstraintValue(){
  final StubItem stubItem=dataGenerator.randomStubItem();
  final StubItem existingStubItem=dataGenerator.randomStubItem();
  final String alreadyExistingUniqueConstraint=existingStubItem.getStringProperty();
  final String uniqueConstraintAttributeName=""String_Node_Str"";
  final ItemConfiguration stubItemConfigurationWithUniqueConstraints=new ItemConfiguration(stubItem.getClass(),""String_Node_Str"");
  stubItemConfigurationWithUniqueConstraints.registerUniqueConstraints(Arrays.asList(new UniqueConstraint(uniqueConstraintAttributeName)));
  final DatabaseSchemaHolder databaseSchemaHolderWithUniqueConstraints=databaseSchemaHolderWithItemConfiguration(stubItemConfigurationWithUniqueConstraints);
  final InMemoryDatabaseTemplate databaseTemplate=new InMemoryDatabaseTemplate(databaseSchemaHolderWithUniqueConstraints);
  databaseTemplate.create(existingStubItem);
  databaseTemplate.create(stubItem);
  stubItem.setStringProperty(alreadyExistingUniqueConstraint);
  ItemConstraintViolationException actualException=null;
  try {
    databaseTemplate.update(stubItem);
  }
 catch (  final ItemConstraintViolationException e) {
    actualException=e;
  }
  assertNotNull(actualException);
  assertTrue(databaseTemplate.hasUniqueConstraint(existingStubItem,uniqueConstraintAttributeName,alreadyExistingUniqueConstraint));
}","@Test public void shouldNotUpdateItemAndUniqueConstraint_withItemExistingUpdatedUniqueConstraintValue(){
  final StubItem stubItem=dataGenerator.randomStubItem();
  final String originalStubItemContstraintValue=stubItem.getStringProperty();
  final StubItem existingStubItem=dataGenerator.randomStubItem();
  final String alreadyExistingUniqueConstraint=existingStubItem.getStringProperty();
  final String uniqueConstraintAttributeName=""String_Node_Str"";
  final ItemConfiguration stubItemConfigurationWithUniqueConstraints=new ItemConfiguration(stubItem.getClass(),""String_Node_Str"");
  stubItemConfigurationWithUniqueConstraints.registerUniqueConstraints(Arrays.asList(new UniqueConstraint(uniqueConstraintAttributeName)));
  final DatabaseSchemaHolder databaseSchemaHolderWithUniqueConstraints=databaseSchemaHolderWithItemConfiguration(stubItemConfigurationWithUniqueConstraints);
  final InMemoryDatabaseTemplate databaseTemplate=new InMemoryDatabaseTemplate(databaseSchemaHolderWithUniqueConstraints);
  databaseTemplate.create(existingStubItem);
  databaseTemplate.create(stubItem);
  stubItem.setStringProperty(alreadyExistingUniqueConstraint);
  ItemConstraintViolationException actualException=null;
  try {
    databaseTemplate.update(stubItem);
  }
 catch (  final ItemConstraintViolationException e) {
    actualException=e;
  }
  assertNotNull(actualException);
  assertTrue(databaseTemplate.hasUniqueConstraint(existingStubItem,uniqueConstraintAttributeName,alreadyExistingUniqueConstraint));
  assertTrue(databaseTemplate.hasUniqueConstraint(stubItem,uniqueConstraintAttributeName,originalStubItemContstraintValue));
}"
11319,"private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      String singleValue=null;
      if (values != null && !values.isEmpty()) {
        singleValue=values.iterator().next();
      }
      final boolean isSingleItemProperty=!Collection.class.isAssignableFrom(itemPropertyType);
      String singleItemPropertyValue=null;
      if (isSingleItemProperty) {
        singleItemPropertyValue=String.valueOf(itemPropertyValue);
      }
switch (query.getCondition().getComparisonOperator()) {
case NULL:
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      break;
case NOT_NULL:
    if (itemPropertyValue != null) {
      matches.add(item);
    }
  break;
case LESS_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) >= 0) {
  matches.add(item);
}
break;
case GREATER_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) <= 0) {
matches.add(item);
}
break;
case EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.equals(singleValue)) {
matches.add(item);
}
 else if (itemPropertyValue.equals(values)) {
matches.add(item);
}
break;
default :
break;
}
}
 catch (final Exception e) {
throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
}
}
return matches;
}","private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      String singleValue=null;
      if (values != null && !values.isEmpty()) {
        singleValue=values.iterator().next();
      }
      final boolean isSingleItemProperty=!Collection.class.isAssignableFrom(itemPropertyType);
      String singleItemPropertyValue=null;
      if (isSingleItemProperty) {
        singleItemPropertyValue=String.valueOf(itemPropertyValue);
      }
switch (query.getCondition().getComparisonOperator()) {
case NULL:
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      break;
case NOT_NULL:
    if (itemPropertyValue != null) {
      matches.add(item);
    }
  break;
case LESS_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) <= 0) {
  matches.add(item);
}
break;
case GREATER_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) >= 0) {
matches.add(item);
}
break;
case EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.equals(singleValue)) {
matches.add(item);
}
 else if (values.equals(itemPropertyValue)) {
matches.add(item);
}
break;
default :
break;
}
}
 catch (final Exception e) {
e.printStackTrace();
throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
}
}
return matches;
}"
11320,"private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      String singleValue=null;
      if (values != null && !values.isEmpty()) {
        singleValue=values.iterator().next();
      }
      final boolean isSingleItemProperty=Collection.class.isAssignableFrom(itemPropertyType);
      String singleItemPropertyValue=null;
      if (isSingleItemProperty) {
        singleItemPropertyValue=(String)itemPropertyValue;
      }
switch (query.getCondition().getComparisonOperator()) {
case NULL:
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      break;
case NOT_NULL:
    if (itemPropertyValue != null) {
      matches.add(item);
    }
  break;
case LESS_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) >= 0) {
  matches.add(item);
}
break;
case GREATER_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) <= 0) {
matches.add(item);
}
break;
case EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.equals(singleValue)) {
matches.add(item);
}
 else if (itemPropertyValue.equals(values)) {
matches.add(item);
}
break;
default :
break;
}
}
 catch (final Exception e) {
throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
}
}
return matches;
}","private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      String singleValue=null;
      if (values != null && !values.isEmpty()) {
        singleValue=values.iterator().next();
      }
      final boolean isSingleItemProperty=!Collection.class.isAssignableFrom(itemPropertyType);
      String singleItemPropertyValue=null;
      if (isSingleItemProperty) {
        singleItemPropertyValue=String.valueOf(itemPropertyValue);
      }
switch (query.getCondition().getComparisonOperator()) {
case NULL:
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      break;
case NOT_NULL:
    if (itemPropertyValue != null) {
      matches.add(item);
    }
  break;
case LESS_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) >= 0) {
  matches.add(item);
}
break;
case GREATER_THAN_OR_EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.compareTo(singleValue) <= 0) {
matches.add(item);
}
break;
case EQUALS:
if (isSingleItemProperty && singleItemPropertyValue.equals(singleValue)) {
matches.add(item);
}
 else if (itemPropertyValue.equals(values)) {
matches.add(item);
}
break;
default :
break;
}
}
 catch (final Exception e) {
throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
}
}
return matches;
}"
11321,"protected final <T extends Item>void deleteUniqueConstraintIndexes(final T item,final ItemConfiguration itemConfiguration,final Collection<PropertyDescriptor> constraintPropertyDescriptors){
  if (constraintPropertyDescriptors.isEmpty()) {
    return;
  }
  for (  final UniqueConstraint uniqueConstraint : itemConfiguration.uniqueConstraints()) {
    final String uniqueConstraintPropertyName=uniqueConstraint.propertyName();
    final PropertyDescriptor uniqueConstraintPropertyDescriptor=uniqueConstraint.propertyDescriptor();
    if (constraintPropertyDescriptors.contains(uniqueConstraintPropertyDescriptor)) {
      final AttributeValue uniqueConstraintAttributeValue=DynamoDbPropertyMarshaller.getValue(item,uniqueConstraintPropertyDescriptor);
      if (uniqueConstraintAttributeValue.getS() != null) {
        uniqueConstraintAttributeValue.setS(uniqueConstraintAttributeValue.getS().toUpperCase());
      }
      final Map<String,AttributeValue> key=new HashMap<>();
      key.put(""String_Node_Str"",new AttributeValue(uniqueConstraintPropertyName));
      key.put(""String_Node_Str"",uniqueConstraintAttributeValue);
      final String indexTableName=databaseSchemaHolder.schemaName() + ""String_Node_Str"" + itemConfiguration.tableName();
      final DeleteItemRequest itemRequest=new DeleteItemRequest().withTableName(indexTableName).withKey(key);
      try {
        amazonDynamoDbClient.deleteItem(itemRequest);
      }
 catch (      final AmazonServiceException e) {
        throw new PersistenceResourceFailureException(""String_Node_Str"",e);
      }
    }
  }
}","protected final <T extends Item>void deleteUniqueConstraintIndexes(final T item,final ItemConfiguration itemConfiguration,final Collection<PropertyDescriptor> constraintPropertyDescriptors){
  if (constraintPropertyDescriptors.isEmpty()) {
    return;
  }
  for (  final UniqueConstraint uniqueConstraint : itemConfiguration.uniqueConstraints()) {
    final String uniqueConstraintPropertyName=uniqueConstraint.propertyName();
    final PropertyDescriptor uniqueConstraintPropertyDescriptor=uniqueConstraint.propertyDescriptor();
    if (constraintPropertyDescriptors.contains(uniqueConstraintPropertyDescriptor)) {
      final AttributeValue uniqueConstraintAttributeValue=DynamoDbPropertyMarshaller.getValue(item,uniqueConstraintPropertyDescriptor);
      if (uniqueConstraintAttributeValue != null) {
        if (uniqueConstraintAttributeValue.getS() != null) {
          uniqueConstraintAttributeValue.setS(uniqueConstraintAttributeValue.getS().toUpperCase());
        }
        final Map<String,AttributeValue> key=new HashMap<>();
        key.put(""String_Node_Str"",new AttributeValue(uniqueConstraintPropertyName));
        key.put(""String_Node_Str"",uniqueConstraintAttributeValue);
        final String indexTableName=databaseSchemaHolder.schemaName() + ""String_Node_Str"" + itemConfiguration.tableName();
        final DeleteItemRequest itemRequest=new DeleteItemRequest().withTableName(indexTableName).withKey(key);
        try {
          amazonDynamoDbClient.deleteItem(itemRequest);
        }
 catch (        final AmazonServiceException e) {
          throw new PersistenceResourceFailureException(""String_Node_Str"",e);
        }
      }
    }
  }
}"
11322,"public <T extends Item>Collection<UniqueConstraint> getUpdatedUniqueConstraints(final T item,final T previousItem,final ItemConfiguration itemConfiguration){
  final Map<String,AttributeValue> previousItemAttributeMap=getAttributeMap(previousItem,itemConfiguration,item.getVersion());
  if (!previousItemAttributeMap.get(VERSION_ATTRIBUTE).getN().equals(String.valueOf(item.getVersion()))) {
    throw new ConditionalCheckFailedException(""String_Node_Str"");
  }
  final Collection<String> updatedProperties=getUpdateProperties(previousItemAttributeMap,getAttributeMap(item,itemConfiguration,item.getVersion()));
  final Collection<UniqueConstraint> updatedUniqueConstraints=new HashSet<>();
  for (  final UniqueConstraint uniqueConstraint : itemConfiguration.uniqueConstraints()) {
    if (updatedProperties.contains(uniqueConstraint.propertyDescriptor().getName())) {
      updatedUniqueConstraints.add(uniqueConstraint);
    }
  }
  return updatedUniqueConstraints;
}","public <T extends Item>Collection<UniqueConstraint> getUpdatedUniqueConstraints(final T item,final T previousItem,final ItemConfiguration itemConfiguration){
  final Map<String,AttributeValue> previousItemAttributeMap=getAttributeMap(previousItem,itemConfiguration,item.getVersion());
  if (!previousItemAttributeMap.get(VERSION_ATTRIBUTE).getN().equals(String.valueOf(item.getVersion()))) {
    throw new ConditionalCheckFailedException(""String_Node_Str"");
  }
  final Map<String,AttributeValue> updateItemAttributeMap=getAttributeMap(item,itemConfiguration,item.getVersion());
  final Collection<String> updatedProperties=getUpdateProperties(previousItemAttributeMap,updateItemAttributeMap);
  final Collection<UniqueConstraint> updatedUniqueConstraints=new HashSet<>();
  for (  final UniqueConstraint uniqueConstraint : itemConfiguration.uniqueConstraints()) {
    final String propertyName=uniqueConstraint.propertyDescriptor().getName();
    if (updatedProperties.contains(propertyName)) {
      final AttributeValue previousAttributeValue=previousItemAttributeMap.get(propertyName);
      final AttributeValue updatedAttributeValue=updateItemAttributeMap.get(propertyName);
      if (previousAttributeValue == null || updatedAttributeValue == null || !previousAttributeValue.getS().equalsIgnoreCase(updatedAttributeValue.getS())) {
        updatedUniqueConstraints.add(uniqueConstraint);
      }
    }
  }
  return updatedUniqueConstraints;
}"
11323,"private UploadDocumentsRequest uploadDocumentsRequest(final BatchDocumentUpdateRequest batchDocumentUpdateRequest){
  final UploadDocumentsRequest uploadDocumentsRequest=new UploadDocumentsRequest();
  final byte[] documentUpdatesJsonBytes;
  documentUpdatesJsonBytes=JsonDocumentUpdateMarshaller.marshall(batchDocumentUpdateRequest.getDocumentUpdates()).getBytes(Charset.forName(""String_Node_Str""));
  final InputStream documents=new ByteArrayInputStream(documentUpdatesJsonBytes);
  uploadDocumentsRequest.setDocuments(documents);
  uploadDocumentsRequest.setContentLength((long)documentUpdatesJsonBytes.length);
  uploadDocumentsRequest.setContentType(MediaType.APPLICATION_JSON);
  return uploadDocumentsRequest;
}","private UploadDocumentsRequest uploadDocumentsRequest(final BatchDocumentUpdateRequest batchDocumentUpdateRequest){
  final UploadDocumentsRequest uploadDocumentsRequest=new UploadDocumentsRequest();
  final byte[] documentUpdatesJsonBytes;
  final String documentUpdatesJson=JsonDocumentUpdateMarshaller.marshall(batchDocumentUpdateRequest.getDocumentUpdates());
  documentUpdatesJsonBytes=documentUpdatesJson.getBytes(Charset.forName(""String_Node_Str""));
  final InputStream documents=new ByteArrayInputStream(documentUpdatesJsonBytes);
  uploadDocumentsRequest.setDocuments(documents);
  uploadDocumentsRequest.setContentLength((long)documentUpdatesJsonBytes.length);
  uploadDocumentsRequest.setContentType(MediaType.APPLICATION_JSON);
  return uploadDocumentsRequest;
}"
11324,"private JsonDocumentUpdateMarshaller(){
  mapper=new ObjectMapper();
  final SimpleModule jodaDateTimeModule=new SimpleModule();
  jodaDateTimeModule.addSerializer(DateTime.class,new JodaDateTimeSerializer());
  mapper.registerModule(jodaDateTimeModule);
  mapper.setPropertyNamingStrategy(new LowerCasePropertyNamingStrategy());
}","private JsonDocumentUpdateMarshaller(){
  mapper=new ObjectMapper();
  final SimpleModule module=new SimpleModule();
  module.addSerializer(DateTime.class,new JodaDateTimeSerializer());
  module.addSerializer(Boolean.class,new BooleanLiteralSerializer());
  mapper.registerModule(module);
  mapper.setPropertyNamingStrategy(new LowerCasePropertyNamingStrategy());
}"
11325,"@Test public void shouldMarshallDocumentUpdateCollection_withDocumentUpdateCollection() throws Exception {
  final String documentId1=randomString(10);
  final DocumentUpdate documentUpdate1=new DocumentUpdate(Type.ADD,documentId1);
  final String fieldName1a=randomString(10);
  final String fieldValue1a=randomString();
  final Field field1a=new Field(fieldName1a,fieldValue1a);
  final String fieldName1b=randomString(10);
  final String fieldValue1b=randomString();
  final Field field1b=new Field(fieldName1b,fieldValue1b);
  final Collection<Field> fields1=Arrays.asList(field1a,field1b);
  documentUpdate1.withFields(fields1);
  final String documentId2=randomString(10);
  final DocumentUpdate documentUpdate2=new DocumentUpdate(Type.ADD,documentId2);
  final String fieldName2a=randomString(10);
  final DateTime fieldValue2a=randomDateTime();
  final Field field2a=new Field(fieldName2a,fieldValue2a);
  final String fieldName2b=randomString(10);
  final String fieldValue2b=randomString();
  final Field field2b=new Field(fieldName2b,fieldValue2b);
  final Collection<Field> fields2=Arrays.asList(field2a,field2b);
  documentUpdate2.withFields(fields2);
  final String documentId3=randomString(10);
  final DocumentUpdate documentUpdate3=new DocumentUpdate(Type.DELETE,documentId3);
  final Collection<DocumentUpdate> documentUpdates=Arrays.asList(documentUpdate1,documentUpdate2,documentUpdate3);
  final String expectedJsonString=""String_Node_Str"" + documentId1 + ""String_Node_Str""+ fieldName1a.toLowerCase()+ ""String_Node_Str""+ fieldValue1a+ ""String_Node_Str""+ fieldName1b.toLowerCase()+ ""String_Node_Str""+ fieldValue1b+ ""String_Node_Str""+ documentId2+ ""String_Node_Str""+ fieldName2a.toLowerCase()+ ""String_Node_Str""+ ISODateTimeFormat.dateTime().withZoneUTC().print(fieldValue2a)+ ""String_Node_Str""+ fieldName2b.toLowerCase()+ ""String_Node_Str""+ fieldValue2b+ ""String_Node_Str""+ documentId3+ ""String_Node_Str"";
  final String jsonString=JsonDocumentUpdateMarshaller.marshall(documentUpdates);
  assertEquals(expectedJsonString,jsonString);
}","@Test public void shouldMarshallDocumentUpdateCollection_withDocumentUpdateCollection() throws Exception {
  final String documentId1=randomString(10);
  final DocumentUpdate documentUpdate1=new DocumentUpdate(Type.ADD,documentId1);
  final String fieldName1a=randomString(10);
  final String fieldValue1a=randomString();
  final Field field1a=new Field(fieldName1a,fieldValue1a);
  final String fieldName1b=randomString(10);
  final String fieldValue1b=randomString();
  final Field field1b=new Field(fieldName1b,fieldValue1b);
  final Collection<Field> fields1=Arrays.asList(field1a,field1b);
  documentUpdate1.withFields(fields1);
  final String documentId2=randomString(10);
  final DocumentUpdate documentUpdate2=new DocumentUpdate(Type.ADD,documentId2);
  final String fieldName2a=randomString(10);
  final DateTime fieldValue2a=randomDateTime();
  final Field field2a=new Field(fieldName2a,fieldValue2a);
  final String fieldName2b=randomString(10);
  final String fieldValue2b=randomString();
  final Field field2b=new Field(fieldName2b,fieldValue2b);
  final String fieldName2c=randomString(10);
  final boolean fieldValue2c=randomBoolean();
  final Field field2c=new Field(fieldName2c,fieldValue2c);
  final Collection<Field> fields2=Arrays.asList(field2a,field2b,field2c);
  documentUpdate2.withFields(fields2);
  final String documentId3=randomString(10);
  final DocumentUpdate documentUpdate3=new DocumentUpdate(Type.DELETE,documentId3);
  final Collection<DocumentUpdate> documentUpdates=Arrays.asList(documentUpdate1,documentUpdate2,documentUpdate3);
  final String expectedJsonString=""String_Node_Str"" + documentId1 + ""String_Node_Str""+ fieldName1a.toLowerCase()+ ""String_Node_Str""+ fieldValue1a+ ""String_Node_Str""+ fieldName1b.toLowerCase()+ ""String_Node_Str""+ fieldValue1b+ ""String_Node_Str""+ documentId2+ ""String_Node_Str""+ fieldName2a.toLowerCase()+ ""String_Node_Str""+ ISODateTimeFormat.dateTime().withZoneUTC().print(fieldValue2a)+ ""String_Node_Str""+ fieldName2b.toLowerCase()+ ""String_Node_Str""+ fieldValue2b+ ""String_Node_Str""+ fieldName2c.toLowerCase()+ ""String_Node_Str""+ fieldValue2c+ ""String_Node_Str""+ documentId3+ ""String_Node_Str"";
  final String jsonString=JsonDocumentUpdateMarshaller.marshall(documentUpdates);
  assertEquals(expectedJsonString,jsonString);
}"
11326,"@Override public void filter(final ContainerRequestContext requestContext) throws IOException {
  final MultivaluedMap<String,String> headersMap=requestContext.getHeaders();
  String principal=null;
  String agent=null;
  if (headersMap.containsKey(HttpHeaders.AUTHORIZATION)) {
    for (    final String headerValue : headersMap.get(HttpHeaders.AUTHORIZATION)) {
      final String[] headerValueParts=headerValue.split(""String_Node_Str"");
      if (headerValueParts.length == 2) {
        if (PRINCIPAL_HEADER_VALUE_PREFIX.equals(headerValueParts[0])) {
          principal=headerValueParts[1];
        }
      }
    }
  }
  if (headersMap.containsKey(PROXY_AUTHORIZATION)) {
    for (    final String headerValue : headersMap.get(PROXY_AUTHORIZATION)) {
      final String[] headerValueParts=headerValue.split(""String_Node_Str"");
      if (headerValueParts.length == 2) {
        if (AGENT_HEADER_VALUE_PREFIX.equals(headerValueParts[0])) {
          agent=headerValueParts[1];
        }
      }
    }
  }
  if (principal != null && agent != null) {
    SecurityContextHolder.set(new AgentSecurityContext(principal,agent));
  }
 else   if (principal != null) {
    SecurityContextHolder.set(new BasicSecurityContext(principal));
  }
 else {
    SecurityContextHolder.clear();
  }
}","@Override public void filter(final ContainerRequestContext requestContext) throws IOException {
  final MultivaluedMap<String,String> headersMap=requestContext.getHeaders();
  String principal=null;
  String agent=null;
  if (headersMap.containsKey(HttpHeaders.AUTHORIZATION)) {
    for (    final String headerValue : headersMap.get(HttpHeaders.AUTHORIZATION)) {
      final String[] headerValueParts=headerValue.split(""String_Node_Str"");
      if (headerValueParts.length == 2) {
        if (CLICK_PLATFORM_HEADER_VALUE_PREFIX.equals(headerValueParts[0])) {
          principal=headerValueParts[1];
        }
      }
    }
  }
  if (headersMap.containsKey(PROXY_AUTHORIZATION)) {
    for (    final String headerValue : headersMap.get(PROXY_AUTHORIZATION)) {
      final String[] headerValueParts=headerValue.split(""String_Node_Str"");
      if (headerValueParts.length == 2) {
        if (CLICK_PLATFORM_HEADER_VALUE_PREFIX.equals(headerValueParts[0])) {
          agent=headerValueParts[1];
        }
      }
    }
  }
  if (principal != null && agent != null) {
    SecurityContextHolder.set(new AgentSecurityContext(principal,agent));
  }
 else   if (principal != null) {
    SecurityContextHolder.set(new BasicSecurityContext(principal));
  }
 else {
    SecurityContextHolder.clear();
  }
}"
11327,"@Test public void shouldSetPrincipal_withPrincipalHeader() throws Exception {
  mockStatic(SecurityContextHolder.class);
  final String principal=Randoms.randomString();
  final ContainerRequestContext mockContainerRequestContext=mock(ContainerRequestContext.class);
  final MultivaluedMap<String,String> headersMap=new MultivaluedHashMap<>();
  headersMap.add(HttpHeaders.AUTHORIZATION,PRINCIPAL_HEADER_VALUE_PREFIX + ""String_Node_Str"" + principal);
  when(mockContainerRequestContext.getHeaders()).thenReturn(headersMap);
  final ContainerSecurityRequestFilter containerSecurityRequestFilter=new ContainerSecurityRequestFilter();
  containerSecurityRequestFilter.filter(mockContainerRequestContext);
  final ArgumentCaptor<BasicSecurityContext> securityContextCaptor=ArgumentCaptor.forClass(BasicSecurityContext.class);
  verifyStatic();
  SecurityContextHolder.set(securityContextCaptor.capture());
  assertThat(securityContextCaptor.getValue().principal(),is(principal));
}","@Test public void shouldSetPrincipal_withPrincipalHeader() throws Exception {
  mockStatic(SecurityContextHolder.class);
  final String principal=Randoms.randomString();
  final ContainerRequestContext mockContainerRequestContext=mock(ContainerRequestContext.class);
  final MultivaluedMap<String,String> headersMap=new MultivaluedHashMap<>();
  headersMap.add(HttpHeaders.AUTHORIZATION,CLICK_PLATFORM_HEADER_VALUE_PREFIX + ""String_Node_Str"" + principal);
  when(mockContainerRequestContext.getHeaders()).thenReturn(headersMap);
  final ContainerSecurityRequestFilter containerSecurityRequestFilter=new ContainerSecurityRequestFilter();
  containerSecurityRequestFilter.filter(mockContainerRequestContext);
  final ArgumentCaptor<BasicSecurityContext> securityContextCaptor=ArgumentCaptor.forClass(BasicSecurityContext.class);
  verifyStatic();
  SecurityContextHolder.set(securityContextCaptor.capture());
  assertThat(securityContextCaptor.getValue().principal(),is(principal));
}"
11328,"@Test public void shouldSetPrincipal_withPrincipalHeaderAndAgentHeader() throws Exception {
  mockStatic(SecurityContextHolder.class);
  final String principal=Randoms.randomString();
  final String agent=Randoms.randomString();
  final ContainerRequestContext mockContainerRequestContext=mock(ContainerRequestContext.class);
  final MultivaluedMap<String,String> headersMap=new MultivaluedHashMap<>();
  headersMap.add(HttpHeaders.AUTHORIZATION,PRINCIPAL_HEADER_VALUE_PREFIX + ""String_Node_Str"" + principal);
  headersMap.add(""String_Node_Str"",AGENT_HEADER_VALUE_PREFIX + ""String_Node_Str"" + agent);
  when(mockContainerRequestContext.getHeaders()).thenReturn(headersMap);
  final ContainerSecurityRequestFilter containerSecurityRequestFilter=new ContainerSecurityRequestFilter();
  containerSecurityRequestFilter.filter(mockContainerRequestContext);
  final ArgumentCaptor<AgentSecurityContext> securityContextCaptor=ArgumentCaptor.forClass(AgentSecurityContext.class);
  verifyStatic();
  SecurityContextHolder.set(securityContextCaptor.capture());
  assertThat(securityContextCaptor.getValue().principal(),is(principal));
  assertThat(securityContextCaptor.getValue().agent(),is(agent));
}","@Test public void shouldSetPrincipal_withPrincipalHeaderAndAgentHeader() throws Exception {
  mockStatic(SecurityContextHolder.class);
  final String principal=Randoms.randomString();
  final String agent=Randoms.randomString();
  final ContainerRequestContext mockContainerRequestContext=mock(ContainerRequestContext.class);
  final MultivaluedMap<String,String> headersMap=new MultivaluedHashMap<>();
  headersMap.add(HttpHeaders.AUTHORIZATION,CLICK_PLATFORM_HEADER_VALUE_PREFIX + ""String_Node_Str"" + principal);
  headersMap.add(""String_Node_Str"",CLICK_PLATFORM_HEADER_VALUE_PREFIX + ""String_Node_Str"" + agent);
  when(mockContainerRequestContext.getHeaders()).thenReturn(headersMap);
  final ContainerSecurityRequestFilter containerSecurityRequestFilter=new ContainerSecurityRequestFilter();
  containerSecurityRequestFilter.filter(mockContainerRequestContext);
  final ArgumentCaptor<AgentSecurityContext> securityContextCaptor=ArgumentCaptor.forClass(AgentSecurityContext.class);
  verifyStatic();
  SecurityContextHolder.set(securityContextCaptor.capture());
  assertThat(securityContextCaptor.getValue().principal(),is(principal));
  assertThat(securityContextCaptor.getValue().agent(),is(agent));
}"
11329,"private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      if (Operators.NULL.equals(query.getCondition().getComparisonOperator())) {
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      }
 else       if (Operators.NOT_NULL.equals(query.getCondition().getComparisonOperator())) {
        if (itemPropertyValue != null) {
          matches.add(item);
        }
      }
 else       if (String.class.isAssignableFrom(itemPropertyType) && values.size() == 1) {
        final String itemPropertyValueString=itemPropertyValue == null ? null : (String)itemPropertyValue;
        if (condition.getComparisonOperator().compare(itemPropertyValueString,values.iterator().next())) {
          matches.add(item);
        }
      }
 else       if (Collection.class.isAssignableFrom(itemPropertyType)) {
        @SuppressWarnings(""String_Node_Str"") final Collection<String> itemPropertyValueStringCollection=itemPropertyValue == null ? null : (Collection<String>)itemPropertyValue;
        if (condition.getComparisonOperator().compare(itemPropertyValueStringCollection,values)) {
          matches.add(item);
        }
      }
    }
 catch (    final Exception e) {
      throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
    }
  }
  return matches;
}","private <T extends Item>Collection<T> executeQuery(final AttributeQuery query,final Class<T> itemClass){
  final Map<ItemId,T> allItems=getAllItems(itemClass);
  final Collection<T> matches=new ArrayList<>();
  for (  final T item : allItems.values()) {
    final String attribute=query.getAttributeName();
    try {
      final Method getter=new PropertyDescriptor(attribute,item.getClass()).getReadMethod();
      final Object itemPropertyValue=getter.invoke(item);
      final Class<?> itemPropertyType=getter.getReturnType();
      final Condition condition=query.getCondition();
      final Set<String> values=condition.getValues();
      if (Operators.NULL.equals(query.getCondition().getComparisonOperator())) {
        if (itemPropertyValue == null) {
          matches.add(item);
        }
      }
 else       if (Operators.NOT_NULL.equals(query.getCondition().getComparisonOperator())) {
        if (itemPropertyValue != null) {
          matches.add(item);
        }
      }
 else       if (Collection.class.isAssignableFrom(itemPropertyType)) {
        @SuppressWarnings(""String_Node_Str"") final Collection<String> itemPropertyValueStringCollection=itemPropertyValue == null ? null : (Collection<String>)itemPropertyValue;
        if (condition.getComparisonOperator().compare(itemPropertyValueStringCollection,values)) {
          matches.add(item);
        }
      }
 else       if (values.size() == 1) {
        final String itemPropertyValueString=itemPropertyValue == null ? null : String.valueOf(itemPropertyValue);
        if (condition.getComparisonOperator().compare(itemPropertyValueString,values.iterator().next())) {
          matches.add(item);
        }
      }
    }
 catch (    final Exception e) {
      throw new IllegalStateException(""String_Node_Str"" + attribute + ""String_Node_Str""+ item.getClass()+ ""String_Node_Str"");
    }
  }
  return matches;
}"
11330,"private String createAwsSnsTopic(final String name){
  logger.debug(""String_Node_Str"" + name);
  return amazonSnsClient.createTopic(new CreateTopicRequest(name)).getTopicArn();
}","private String createAwsSnsTopic(final String name){
  logger.info(""String_Node_Str"" + name);
  return amazonSnsClient.createTopic(new CreateTopicRequest(name)).getTopicArn();
}"
11331,"@Override public SnsTopic createSnsTopicForExistingAwsSnsTopic(final String name){
  final String topicArn=pollAndRetryForTopicArnForName(name);
  return new SnsTopic(name,topicArn,amazonSnsClient);
}","@Override public SnsTopicResource createSnsTopicForExistingAwsSnsTopic(final String name){
  final String topicArn=pollAndRetryForTopicArnForName(name);
  logger.info(""String_Node_Str"" + name);
  return new SnsTopicResource(name,topicArn,amazonSnsClient);
}"
11332,"@Override public SnsTopic createSnsTopicAndAwsSnsTopicIfAbsent(final String name){
  String topicArn=pollForTopicArnForName(name);
  if (topicArn == null) {
    topicArn=createAwsSnsTopic(name);
    final SnsTopic snsTopic=new SnsTopic(name,topicArn,amazonSnsClient);
    snsTopic.setPolicy(defaultPolicy(snsTopic));
    return snsTopic;
  }
 else {
    return new SnsTopic(name,topicArn,amazonSnsClient);
  }
}","@Override public SnsTopicResource createSnsTopicAndAwsSnsTopicIfAbsent(final String name){
  String topicArn=pollForTopicArnForName(name);
  if (topicArn == null) {
    topicArn=createAwsSnsTopic(name);
    final SnsTopicResource snsTopicResource=new SnsTopicResource(name,topicArn,amazonSnsClient);
    snsTopicResource.setPolicy(allowAllQueuesPolicy(snsTopicResource));
    return snsTopicResource;
  }
 else {
    logger.info(""String_Node_Str"" + name);
    return new SnsTopicResource(name,topicArn,amazonSnsClient);
  }
}"
11333,"private Policy acceptMessagesFromTopicsPolicy(final SqsQueue sqsQueue,final SnsTopic... snsTopics){
  final Collection<Statement> statements=new ArrayList<>();
  for (  final SnsTopic snsTopic : snsTopics) {
    statements.add(acceptMessagesFromTopicStatement(sqsQueue,snsTopic));
  }
  final Policy policy=new Policy();
  policy.setStatements(statements);
  return policy;
}","private Policy acceptMessagesFromTopicsPolicy(final SqsQueueResource sqsQueueResource,final SnsTopicResource... snsTopics){
  final Collection<Statement> statements=new ArrayList<>();
  for (  final SnsTopicResource snsTopicResource : snsTopics) {
    statements.add(acceptMessagesFromTopicStatement(sqsQueueResource,snsTopicResource));
  }
  final Policy policy=new Policy();
  policy.setStatements(statements);
  return policy;
}"
11334,"@Override public SqsQueue createSqsQueue(final String name,final SnsTopic... snsTopics){
  String queueUrl;
  try {
    queueUrl=amazonSqsClient.getQueueUrl(new GetQueueUrlRequest(name)).getQueueUrl();
  }
 catch (  final QueueDoesNotExistException e) {
    queueUrl=createAwsSqsQueue(name);
  }
  final SqsQueue sqsQueue=new SqsQueue(name,queueUrl,amazonSqsClient);
  if (snsTopics.length != 0) {
    sqsQueue.setPolicy(acceptMessagesFromTopicsPolicy(sqsQueue,snsTopics));
    for (    final SnsTopic snsTopic : snsTopics) {
      snsTopic.subscribe(sqsQueue);
    }
  }
  return sqsQueue;
}","@Override public SqsQueueResource createSqsQueue(final String name,final SnsTopicResource... snsTopics){
  String queueUrl;
  try {
    queueUrl=amazonSqsClient.getQueueUrl(new GetQueueUrlRequest(name)).getQueueUrl();
    logger.info(""String_Node_Str"" + name);
  }
 catch (  final QueueDoesNotExistException e) {
    queueUrl=createAwsSqsQueue(name);
  }
  final SqsQueueResource sqsQueueResource=new SqsQueueResource(name,queueUrl,amazonSqsClient);
  if (snsTopics.length != 0) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str""+ snsTopicNames(snsTopics)+ ""String_Node_Str"");
    sqsQueueResource.setPolicy(acceptMessagesFromTopicsPolicy(sqsQueueResource,snsTopics));
    for (    final SnsTopicResource snsTopicResource : snsTopics) {
      snsTopicResource.subscribe(sqsQueueResource);
    }
  }
  return sqsQueueResource;
}"
11335,"private Statement acceptMessagesFromTopicStatement(final SqsQueue sqsQueue,final SnsTopic snsTopic){
  return new Statement(Effect.Allow).withPrincipals(Principal.AllUsers).withActions(SQSActions.SendMessage).withResources(new Resource(sqsQueue.queueArn())).withConditions(new ArnCondition(ArnComparisonType.ArnEquals,ConditionFactory.SOURCE_ARN_CONDITION_KEY,snsTopic.getTopicArn()));
}","private Statement acceptMessagesFromTopicStatement(final SqsQueueResource sqsQueueResource,final SnsTopicResource snsTopicResource){
  return new Statement(Effect.Allow).withPrincipals(Principal.AllUsers).withActions(SQSActions.SendMessage).withResources(new Resource(sqsQueueResource.queueArn())).withConditions(new ArnCondition(ArnComparisonType.ArnEquals,ConditionFactory.SOURCE_ARN_CONDITION_KEY,snsTopicResource.getTopicArn()));
}"
11336,"private String createAwsSqsQueue(final String name){
  logger.debug(""String_Node_Str"" + name);
  final Map<String,String> attributes=new HashMap<>();
  attributes.put(SQS_VISIBILITY_TIMEOUT_ATTRIBUTE,SQS_VISIBILITY_TIMEOUT_VALUE);
  final CreateQueueRequest createQueueRequest=new CreateQueueRequest(name).withAttributes(attributes);
  return amazonSqsClient.createQueue(createQueueRequest).getQueueUrl();
}","private String createAwsSqsQueue(final String name){
  logger.info(""String_Node_Str"" + name);
  final Map<String,String> attributes=new HashMap<>();
  attributes.put(SQS_VISIBILITY_TIMEOUT_ATTRIBUTE,SQS_VISIBILITY_TIMEOUT_VALUE);
  final CreateQueueRequest createQueueRequest=new CreateQueueRequest(name).withAttributes(attributes);
  return amazonSqsClient.createQueue(createQueueRequest).getQueueUrl();
}"
11337,"public PooledBasicMessageListener(final MessageQueue<BasicMessage> basicMessageQueue,final RateLimiter rateLimiter,final ThreadPoolExecutor threadPoolExecutor,final Semaphore semaphore,final MessageHandler<BasicMessage> messageHandler,final int maxReceivedMessages){
  super(basicMessageQueue,rateLimiter,threadPoolExecutor,semaphore,maxReceivedMessages);
  this.messageHandler=messageHandler;
}","/** 
 * Most general constructor, allows for greatest flexibility
 * @param basicMessageQueue The basic message queue to listen to
 * @param messageHandler The handler used for all messages that are received
 * @param rateLimiter An optional {@link RateLimiter} used to limit the message throughput
 * @param threadPoolExecutor {@link ThreadPoolExecutor} for a fixed-size thread pool for message handler tasks
 * @param semaphore {@link Semaphore} used to regulate number of in-flight messages to keep all worker threads busy
 * @param maxReceivedMessages Maximum number of messages to receive from the queue at a time
 */
public PooledBasicMessageListener(final MessageQueue<BasicMessage> basicMessageQueue,final MessageHandler<BasicMessage> messageHandler,final RateLimiter rateLimiter,final ThreadPoolExecutor threadPoolExecutor,final Semaphore semaphore,final int maxReceivedMessages){
  super(basicMessageQueue,rateLimiter,threadPoolExecutor,semaphore,maxReceivedMessages);
  this.messageHandler=messageHandler;
}"
11338,"@Override public void run(){
  logger.debug(""String_Node_Str"" + queueName() + ""String_Node_Str"");
  try {
    processMessagesUntilShutdownRequested();
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  final Throwable e) {
    logger.error(e.getMessage(),e);
    throw e;
  }
 finally {
    logger.debug(""String_Node_Str"" + queueName() + ""String_Node_Str"");
    threadPoolExecutor.shutdown();
  }
}","@Override public void run(){
  try {
    listenerStarted();
    final String limiterSummary=rateLimiter != null ? (""String_Node_Str"" + rateLimiter.toString()) : ""String_Node_Str"";
    logger.debug(""String_Node_Str"" + queueName() + ""String_Node_Str""+ threadPoolExecutor.getMaximumPoolSize()+ ""String_Node_Str""+ limiterSummary);
    processMessagesUntilShutdownRequested();
  }
 catch (  final InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  final Throwable e) {
    logger.error(e.getMessage(),e);
    throw e;
  }
 finally {
    logger.debug(""String_Node_Str"" + queueName() + ""String_Node_Str"");
    threadPoolExecutor.shutdown();
  }
}"
11339,"@Override public void publishMessage(final T message){
  final SnsSubjectAndMessage snsSubjectAndMessage=snsMessageAdapter.toSnsSubjectAndMessage(message);
  final String subject=snsSubjectAndMessage.getSubject();
  final String snsMessage=snsSubjectAndMessage.getMessage();
  snsTopic.publish(subject,snsMessage);
}","@Override public void publishMessage(final T message){
  final SnsSubjectAndMessage snsSubjectAndMessage=snsMessageAdapter.toSnsSubjectAndMessage(message);
  final String subject=snsSubjectAndMessage.getSubject();
  final String snsMessage=snsSubjectAndMessage.getMessage();
  snsTopicResource.publish(subject,snsMessage);
}"
11340,"@Override public String exchangeName(){
  return snsTopic.getTopicName();
}","@Override public String exchangeName(){
  return snsTopicResource.getTopicName();
}"
11341,"public SnsExchange(final SnsTopic snsTopic,final SnsMessageAdapter<T> snsMessageAdapter){
  this.snsTopic=snsTopic;
  this.snsMessageAdapter=snsMessageAdapter;
}","public SnsExchange(final SnsTopicResource snsTopicResource,final SnsMessageAdapter<T> snsMessageAdapter){
  this.snsTopicResource=snsTopicResource;
  this.snsMessageAdapter=snsMessageAdapter;
}"
11342,"/** 
 * Creates a   {@link SnsTopic} representing an existing actual AWS SNS topic.
 * @param name Topic name
 * @return {@link SnsTopic} with the given name
 */
SnsTopic createSnsTopicForExistingAwsSnsTopic(String name);","/** 
 * Creates a   {@link SnsTopicResource} representing an existing actual AWS SNS topic.
 * @param name Topic name
 * @return {@link SnsTopicResource} with the given name
 */
SnsTopicResource createSnsTopicForExistingAwsSnsTopic(String name);"
11343,"/** 
 * Creates a   {@link SnsTopic} and the actual AWS SNS topic if it does not already exist with the given name.
 * @param name Topic name
 * @return {@link SnsTopic} with the given name
 */
SnsTopic createSnsTopicAndAwsSnsTopicIfAbsent(String name);","/** 
 * Creates a   {@link SnsTopicResource} and the actual AWS SNS topic if it does not already exist with the given name.
 * @param name Topic name
 * @return {@link SnsTopicResource} with the given name
 */
SnsTopicResource createSnsTopicAndAwsSnsTopicIfAbsent(String name);"
11344,"@Autowired public DeferrableProcessingStatusHolder(final Collection<MessageListener> messageListeners,final MessageListener eventMessageListener,final MessageListener highPriorityEventMessageListener,final MessageListener systemEventMessageListener){
  messageListenersForDeferrableProcessing=new HashSet<>(messageListeners);
  messageListeners.remove(eventMessageListener);
  messageListeners.remove(highPriorityEventMessageListener);
  messageListeners.remove(systemEventMessageListener);
}","@Autowired public DeferrableProcessingStatusHolder(final Collection<MessageListener> messageListeners,final MessageListener eventMessageListener,final MessageListener highPriorityEventMessageListener,final MessageListener systemEventMessageListener){
  messageListenersForDeferrableProcessing=new HashSet<>(messageListeners);
  messageListenersForDeferrableProcessing.remove(eventMessageListener);
  messageListenersForDeferrableProcessing.remove(highPriorityEventMessageListener);
  messageListenersForDeferrableProcessing.remove(systemEventMessageListener);
}"
11345,"@Override public void update(final Document document){
  final DocumentConfiguration documentConfiguration=getDocumentConfiguration(document.getClass());
  final String searchDomain=documentConfigurationHolder.schemaName() + ""String_Node_Str"" + documentConfiguration.namespace();
  final BatchDocumentUpdateRequest batchDocumentUpdateRequest=new BatchDocumentUpdateRequest(searchDomain);
  final DocumentUpdate csDocument=new DocumentUpdate(Type.ADD,document.getId());
  final Collection<Field> fields=new ArrayList<>();
  for (  final IndexDefinition indexDefinition : documentConfiguration.indexDefinitions()) {
    final String indexName=indexDefinition.getName();
    final PropertyDescriptor propertyDescriptor=documentConfiguration.properties().get(indexName);
    final Field field=new Field(indexName,getPropertyValue(document,propertyDescriptor));
    fields.add(field);
  }
  csDocument.withFields(fields);
  batchDocumentUpdateRequest.withDocument(csDocument);
  getDocumentServiceClient(searchDomain).uploadDocuments(uploadDocumentsRequest(batchDocumentUpdateRequest));
}","@Override public void update(final Document document){
  final DocumentConfiguration documentConfiguration=getDocumentConfiguration(document.getClass());
  final String searchDomain=documentConfigurationHolder.schemaName() + ""String_Node_Str"" + documentConfiguration.namespace();
  final BatchDocumentUpdateRequest batchDocumentUpdateRequest=new BatchDocumentUpdateRequest(searchDomain);
  final DocumentUpdate csDocument=new DocumentUpdate(Type.ADD,document.getId());
  final Collection<Field> fields=new ArrayList<>();
  for (  final IndexDefinition indexDefinition : documentConfiguration.indexDefinitions()) {
    final String indexName=indexDefinition.getName();
    final PropertyDescriptor propertyDescriptor=documentConfiguration.properties().get(indexName);
    if (propertyDescriptor == null) {
      throw new IllegalStateException(""String_Node_Str"" + indexName);
    }
    final Field field=new Field(indexName,getPropertyValue(document,propertyDescriptor));
    fields.add(field);
  }
  csDocument.withFields(fields);
  batchDocumentUpdateRequest.withDocument(csDocument);
  getDocumentServiceClient(searchDomain).uploadDocuments(uploadDocumentsRequest(batchDocumentUpdateRequest));
}"
11346,"public DatabaseSchemaHolder(final String schemaName,final Collection<ItemConfiguration> itemConfigurations,final Collection<SequenceConfiguration> sequenceConfigurations){
  if (schemaName == null || schemaName.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (itemConfigurations == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.schemaName=schemaName;
  this.itemConfigurations=new HashSet<>(itemConfigurations);
  this.sequenceConfigurations=new HashSet<>(sequenceConfigurations);
}","public DatabaseSchemaHolder(final String schemaName,final Collection<ItemConfiguration> itemConfigurations,final Collection<SequenceConfiguration> sequenceConfigurations){
  if (schemaName == null || schemaName.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (itemConfigurations == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.schemaName=schemaName;
  this.itemConfigurations=Collections.unmodifiableSet(new HashSet<>(itemConfigurations));
  this.sequenceConfigurations=Collections.unmodifiableSet(new HashSet<>(sequenceConfigurations));
}"
11347,"public Collection<IndexDefinition> indexDefinitions(){
  return indexDefinitions.values();
}","public Collection<IndexDefinition> indexDefinitions(){
  return Collections.unmodifiableCollection(indexDefinitions.values());
}"
11348,"public Collection<UniqueConstraint> uniqueConstraints(){
  return uniqueConstraints.values();
}","public Collection<UniqueConstraint> uniqueConstraints(){
  return Collections.unmodifiableCollection(uniqueConstraints.values());
}"
11349,"public Collection<PropertyDescriptor> propertyDescriptors(){
  return properties.values();
}","public Collection<PropertyDescriptor> propertyDescriptors(){
  return Collections.unmodifiableCollection(properties.values());
}"
11350,"public Collection<IndexDefinition> indexDefinitions(){
  return indexDefinitions;
}","public Collection<IndexDefinition> indexDefinitions(){
  return Collections.unmodifiableCollection(indexDefinitions);
}"
11351,"public Map<String,PropertyDescriptor> properties(){
  return properties;
}","public Map<String,PropertyDescriptor> properties(){
  return Collections.unmodifiableMap(properties);
}"
11352,"@Test public void shouldRegisterIndexes_withIndexDefinitions() throws Exception {
  final Collection<IndexDefinition> indexDefinitions=Arrays.asList(new IndexDefinition(""String_Node_Str"",IndexFieldType.LITERAL));
  final String namespace=randomString(10);
  final Class<? extends Document> documentClass=StubDocument.class;
  final DocumentConfiguration documentConfiguration=new DocumentConfiguration(documentClass,namespace);
  documentConfiguration.registerIndexes(indexDefinitions);
  assertEquals(indexDefinitions,documentConfiguration.indexDefinitions());
}","@Test public void shouldRegisterIndexes_withIndexDefinitions() throws Exception {
  final Collection<IndexDefinition> indexDefinitions=Arrays.asList(new IndexDefinition(""String_Node_Str"",IndexFieldType.LITERAL));
  final String namespace=randomString(10);
  final Class<? extends Document> documentClass=StubDocument.class;
  final DocumentConfiguration documentConfiguration=new DocumentConfiguration(documentClass,namespace);
  documentConfiguration.registerIndexes(indexDefinitions);
  assertEquals(new ArrayList<>(indexDefinitions),new ArrayList<>(documentConfiguration.indexDefinitions()));
}"
11353,"@Deprecated public boolean isProcessedRecentDeferrableEvent(){
  return deferrableProcessing;
}","public boolean isProcessedRecentDeferrableEvent(){
  return deferrableProcessing;
}"
11354,"protected void handlePersistenceException(final PersistenceException persistenceException) throws Throwable {
  for (  final PersistenceExceptionHandler<?> persistenceExceptionHandler : persistenceExceptionHandlers) {
    Method method;
    try {
      method=getPersistenceHandlerMethod(persistenceExceptionHandler,persistenceException);
    }
 catch (    final NoSuchMethodException e) {
      continue;
    }
    try {
      method.setAccessible(true);
      method.invoke(persistenceExceptionHandler,persistenceException);
    }
 catch (    IllegalAccessException|IllegalArgumentException e) {
      continue;
    }
catch (    final InvocationTargetException handlerException) {
      throw handlerException.getCause();
    }
  }
}","protected void handlePersistenceException(final PersistenceException persistenceException) throws Throwable {
  if (persistenceExceptionHandlers.isEmpty()) {
    throw persistenceException;
  }
  for (  final PersistenceExceptionHandler<?> persistenceExceptionHandler : persistenceExceptionHandlers) {
    Method method;
    try {
      method=getPersistenceHandlerMethod(persistenceExceptionHandler,persistenceException);
    }
 catch (    final NoSuchMethodException e) {
      continue;
    }
    try {
      method.setAccessible(true);
      method.invoke(persistenceExceptionHandler,persistenceException);
    }
 catch (    IllegalAccessException|IllegalArgumentException e) {
      continue;
    }
catch (    final InvocationTargetException handlerException) {
      throw handlerException.getCause();
    }
  }
}"
11355,"public void updateLocation(Collection<IBeacon> iBeacons){
  if (mLastChanged.plusSeconds(THROTTLE).isAfterNow()) {
    return;
  }
  if (iBeacons.size() == 0) {
    setLocation(null);
    return;
  }
  IBeacon[] iBeaconsArray=iBeacons.toArray(new IBeacon[iBeacons.size()]);
  Arrays.sort(iBeaconsArray,new Comparator<IBeacon>(){
    @Override public int compare(    IBeacon a,    IBeacon b){
      return a.getAccuracy() - b.getAccuracy() < 0 ? 1 : -1;
    }
  }
);
  for (  IBeacon iBeacon : iBeaconsArray) {
    if (iBeacon.getProximity() == IBeacon.PROXIMITY_IMMEDIATE) {
      setLocation(iBeacon);
      return;
    }
  }
  for (  IBeacon iBeacon : iBeaconsArray) {
    if (iBeacon.getProximity() == IBeacon.PROXIMITY_NEAR) {
      setLocation(iBeacon);
      return;
    }
  }
}","public void updateLocation(Collection<IBeacon> iBeacons){
  if (mLastChanged.plusSeconds(THROTTLE).isAfterNow()) {
    return;
  }
  if (iBeacons.size() == 0) {
    setLocation(null);
    return;
  }
  IBeacon[] iBeaconsArray=iBeacons.toArray(new IBeacon[iBeacons.size()]);
  Arrays.sort(iBeaconsArray,new Comparator<IBeacon>(){
    @Override public int compare(    IBeacon a,    IBeacon b){
      return a.getAccuracy() - b.getAccuracy() < 0 ? 1 : -1;
    }
  }
);
  for (  IBeacon iBeacon : iBeaconsArray) {
    if (iBeacon.getProximity() == IBeacon.PROXIMITY_IMMEDIATE) {
      setLocation(iBeacon);
      return;
    }
  }
  for (  IBeacon iBeacon : iBeaconsArray) {
    if (iBeacon.getProximity() == IBeacon.PROXIMITY_NEAR) {
      setLocation(iBeacon);
      return;
    }
  }
  setLocation(null);
}"
11356,"public static byte[] stringNumberToByteArray(String number,int radix,int size){
  byte[] array=new BigInteger(number,radix).toByteArray();
  byte[] sizedArray=new byte[size];
  System.arraycopy(array,0,sizedArray,0,Math.min(size,array.length));
  return sizedArray;
}","public static byte[] stringNumberToByteArray(String number,int radix,int size){
  byte[] array=new BigInteger(number,radix).toByteArray();
  byte[] sizedArray=new byte[size];
  int signOffset=array[0] == 0 ? 1 : 0;
  System.arraycopy(array,signOffset,sizedArray,0,Math.min(size,array.length));
  return sizedArray;
}"
11357,"/** 
 * @param location
 * @param secretKey
 * @param identifier
 */
public MacaroonsBuilder(String location,String secretKey,String identifier){
  this.location=location;
  this.secretKey=secretKey;
  this.identifier=identifier;
}","/** 
 * @param location   location
 * @param secretKey  secretKey
 * @param identifier identifier
 */
public MacaroonsBuilder(String location,String secretKey,String identifier){
  this.location=location;
  this.secretKey=secretKey;
  this.identifier=identifier;
}"
11358,"/** 
 * @param macaroon
 * @param secretKey
 * @return
 */
public static MacaroonsBuilder modify(Macaroon macaroon,String secretKey){
  return new MacaroonsBuilder(macaroon.location,secretKey,macaroon.identifier);
}","/** 
 * @param macaroon  macaroon
 * @param secretKey secretKey
 * @return {@link com.github.nitram509.jmacaroons.MacaroonsBuilder}
 */
public static MacaroonsBuilder modify(Macaroon macaroon,String secretKey){
  return new MacaroonsBuilder(macaroon.location,secretKey,macaroon.identifier);
}"
11359,"/** 
 * throws java.security.InvalidKeyException      (wrapped within a RuntimeException) throws java.security.NoSuchAlgorithmException (wrapped within a RuntimeException)
 * @return
 */
public Macaroon getMacaroon(){
}","/** 
 * throws java.security.InvalidKeyException      (wrapped within a RuntimeException) throws java.security.NoSuchAlgorithmException (wrapped within a RuntimeException)
 * @return {@link com.github.nitram509.jmacaroons.Macaroon}
 */
public Macaroon getMacaroon(){
}"
11360,"/** 
 * @param caveat
 * @return
 */
public MacaroonsBuilder add_first_party_caveat(String caveat){
}","/** 
 * @param caveat caveat
 * @return this {@link com.github.nitram509.jmacaroons.MacaroonsBuilder}
 */
public MacaroonsBuilder add_first_party_caveat(String caveat){
}"
11361,"/** 
 * @param caveat
 * @return
 */
private MacaroonsBuilder add_third_party_caveat(String caveat){
  if (caveat != null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return this;
}","/** 
 * @param caveat caveat
 * @return this {@link com.github.nitram509.jmacaroons.MacaroonsBuilder}
 */
private MacaroonsBuilder add_third_party_caveat(String caveat){
  if (caveat != null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return this;
}"
11362,"/** 
 * @param location
 * @param secretKey
 * @param identifier
 * @return
 */
public static Macaroon create(String location,String secretKey,String identifier){
  return new MacaroonsBuilder(location,secretKey,identifier).getMacaroon();
}","/** 
 * @param location   location
 * @param secretKey  secretKey
 * @param identifier identifier
 * @return {@link com.github.nitram509.jmacaroons.Macaroon}
 */
public static Macaroon create(String location,String secretKey,String identifier){
  return new MacaroonsBuilder(location,secretKey,identifier).getMacaroon();
}"
11363,"/** 
 * @param serializedMacaroon
 * @return
 * @throws com.github.nitram509.jmacaroons.NotDeSerializableException when serialized macaroon is not valid base64, length is to short or contains invalid packet data
 */
public static Macaroon deserialize(String serializedMacaroon) throws IllegalArgumentException {
  return MacaroonsDeSerializer.deserialize(serializedMacaroon);
}","/** 
 * @param serializedMacaroon serializedMacaroon
 * @return {@link com.github.nitram509.jmacaroons.Macaroon}
 * @throws com.github.nitram509.jmacaroons.NotDeSerializableException when serialized macaroon is not valid base64, length is to short or contains invalid packet data
 */
public static Macaroon deserialize(String serializedMacaroon) throws IllegalArgumentException {
  return MacaroonsDeSerializer.deserialize(serializedMacaroon);
}"
11364,"/** 
 * @param secret
 * @return
 * @throws com.github.nitram509.jmacaroons.MacaroonValidationException     when the macaroon isn't valid
 * @throws com.github.nitram509.jmacaroons.GeneralSecurityRuntimeException
 */
public void assertIsValid(String secret) throws MacaroonValidationException, GeneralSecurityRuntimeException {
  if (!isValid(secret)) {
    throw new MacaroonValidationException(""String_Node_Str"",macaroon);
  }
}","/** 
 * @param secret secret
 * @throws com.github.nitram509.jmacaroons.MacaroonValidationException     when the macaroon isn't valid
 * @throws com.github.nitram509.jmacaroons.GeneralSecurityRuntimeException
 */
public void assertIsValid(String secret) throws MacaroonValidationException, GeneralSecurityRuntimeException {
  if (!isValid(secret)) {
    throw new MacaroonValidationException(""String_Node_Str"",macaroon);
  }
}"
11365,"/** 
 * @param secret
 * @return
 * @throws com.github.nitram509.jmacaroons.GeneralSecurityRuntimeException
 */
public boolean isValid(String secret) throws GeneralSecurityRuntimeException {
  try {
    byte[] key=generate_derived_key(secret);
    byte[] hmac=macaroon_hmac(key,macaroon.identifier);
    for (    String caveat : exactCaveats) {
      if (containsElement(macaroon.caveats,caveat)) {
        hmac=macaroon_hmac(hmac,caveat);
      }
    }
    return Arrays.equals(hmac,macaroon.signatureBytes);
  }
 catch (  InvalidKeyException|NoSuchAlgorithmException e) {
    throw new GeneralSecurityRuntimeException(e);
  }
}","/** 
 * @param secret secret
 * @return true/false if the macaroon is valid
 * @throws com.github.nitram509.jmacaroons.GeneralSecurityRuntimeException
 */
public boolean isValid(String secret) throws GeneralSecurityRuntimeException {
  try {
    byte[] key=generate_derived_key(secret);
    byte[] hmac=macaroon_hmac(key,macaroon.identifier);
    for (    String caveat : exactCaveats) {
      if (containsElement(macaroon.caveats,caveat)) {
        hmac=macaroon_hmac(hmac,caveat);
      }
    }
    return Arrays.equals(hmac,macaroon.signatureBytes);
  }
 catch (  InvalidKeyException|NoSuchAlgorithmException e) {
    throw new GeneralSecurityRuntimeException(e);
  }
}"
11366,"/** 
 * Caveats like these are called ""exact caveats"" because there is exactly one way to satisfy them.  Either the given caveat matches, or it doesn't.  At verification time, the verifier will check each caveat in the macaroon against the list of satisfied caveats provided to   {@link #satisfyExcact(String)}. When it finds a match, it knows that the caveat holds and it can move onto the next caveat in the macaroon.
 * @param caveat
 * @return
 */
public MacaroonsVerifier satisfyExcact(String caveat){
  if (caveat != null) {
    this.exactCaveats=appendToArray(this.exactCaveats,caveat);
  }
  return this;
}","/** 
 * Caveats like these are called ""exact caveats"" because there is exactly one way to satisfy them.  Either the given caveat matches, or it doesn't.  At verification time, the verifier will check each caveat in the macaroon against the list of satisfied caveats provided to satisfyExcact(String). When it finds a match, it knows that the caveat holds and it can move onto the next caveat in the macaroon.
 * @param caveat caveat
 * @return this {@link com.github.nitram509.jmacaroons.MacaroonsVerifier}
 */
public MacaroonsVerifier satisfyExcact(String caveat){
  if (caveat != null) {
    this.exactCaveats=appendToArray(this.exactCaveats,caveat);
  }
  return this;
}"
11367,"/** 
 * @return
 * @throws java.security.InvalidKeyException      (wrapped within a RuntimeException)
 * @throws java.security.NoSuchAlgorithmException (wrapped within a RuntimeException)
 */
public Macaroon getMacaroon(){
}","/** 
 * throws java.security.InvalidKeyException      (wrapped within a RuntimeException) throws java.security.NoSuchAlgorithmException (wrapped within a RuntimeException)
 * @return
 */
public Macaroon getMacaroon(){
}"
11368,"/** 
 * @param macaroon
 * @param secret
 * @return
 * @throws java.security.InvalidKeyException (wrapped within a RuntimeException)
 * @throws java.security.NoSuchAlgorithmException (wrapped within a RuntimeException)
 */
public boolean verify(Macaroon macaroon,String secret){
  try {
    byte[] key=generate_derived_key(secret);
    byte[] hmac=macaroon_hmac(key,macaroon.identifier);
    for (    String caveat : macaroon.caveats) {
      hmac=macaroon_hmac(hmac,caveat);
    }
    return Arrays.equals(hmac,macaroon.signatureBytes);
  }
 catch (  InvalidKeyException|NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * throws java.security.InvalidKeyException (wrapped within a RuntimeException) throws java.security.NoSuchAlgorithmException (wrapped within a RuntimeException)
 * @param macaroon
 * @param secret
 * @return
 */
public boolean verify(Macaroon macaroon,String secret){
  try {
    byte[] key=generate_derived_key(secret);
    byte[] hmac=macaroon_hmac(key,macaroon.identifier);
    for (    String caveat : macaroon.caveats) {
      hmac=macaroon_hmac(hmac,caveat);
    }
    return Arrays.equals(hmac,macaroon.signatureBytes);
  }
 catch (  InvalidKeyException|NoSuchAlgorithmException e) {
    throw new RuntimeException(e);
  }
}"
11369,"@Override public void run(){
  while (isRunning) {
    dequeuedEvents.clear();
    long currentTime=System.currentTimeMillis();
synchronized (queuedEventList) {
      for (      MidiEventWithTiming event : queuedEventList) {
        if (event.timing <= currentTime) {
          dequeuedEvents.add(event);
        }
      }
      queuedEventList.removeAll(dequeuedEvents);
    }
    if (dequeuedEvents.size() > 0) {
      Collections.sort(dequeuedEvents,midiTimerTaskComparator);
      if (midiInputEventListener != null) {
        for (        MidiEventWithTiming event : dequeuedEvents) {
          while (event.timing < System.currentTimeMillis()) {
            try {
              Thread.sleep(1);
            }
 catch (            InterruptedException ignored) {
            }
          }
          event.run();
        }
      }
    }
    try {
      Thread.sleep(BUFFER_LENGTH_MILLIS);
    }
 catch (    InterruptedException ignored) {
    }
  }
}","@Override public void run(){
  while (isRunning) {
    dequeuedEvents.clear();
    long currentTime=System.currentTimeMillis();
synchronized (queuedEventList) {
      for (      MidiEventWithTiming event : queuedEventList) {
        if (event.timing <= currentTime) {
          dequeuedEvents.add(event);
        }
      }
      queuedEventList.removeAll(dequeuedEvents);
    }
    if (dequeuedEvents.size() > 0) {
      Collections.sort(dequeuedEvents,midiTimerTaskComparator);
      if (midiInputEventListener != null) {
        for (        MidiEventWithTiming event : dequeuedEvents) {
          while (event.timing > System.currentTimeMillis()) {
            try {
              Thread.sleep(1);
            }
 catch (            InterruptedException ignored) {
            }
          }
          event.run();
        }
      }
    }
    try {
      Thread.sleep(BUFFER_LENGTH_MILLIS);
    }
 catch (    InterruptedException ignored) {
    }
  }
}"
11370,"/** 
 * SysEx
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public final void sendMidiSystemExclusive(@NonNull byte[] systemExclusive){
  byte[] timestampAddedSystemExclusive=new byte[systemExclusive.length + 2];
  System.arraycopy(systemExclusive,0,timestampAddedSystemExclusive,1,systemExclusive.length);
  byte[] writeBuffer=new byte[20];
  long timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  timestampAddedSystemExclusive[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
  for (int i=0; i < timestampAddedSystemExclusive.length; i+=19) {
    writeBuffer[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
    timestampAddedSystemExclusive[systemExclusive.length]=(byte)(0x80 | (timestamp & 0x7f));
    if (i + 20 <= timestampAddedSystemExclusive.length) {
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,19);
    }
 else {
      writeBuffer=new byte[timestampAddedSystemExclusive.length - i + 1];
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,timestampAddedSystemExclusive.length - i);
    }
    transferData(writeBuffer);
    timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  }
}","/** 
 * SysEx
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public final void sendMidiSystemExclusive(@NonNull byte[] systemExclusive){
  byte[] timestampAddedSystemExclusive=new byte[systemExclusive.length + 2];
  System.arraycopy(systemExclusive,0,timestampAddedSystemExclusive,1,systemExclusive.length);
  byte[] writeBuffer=new byte[20];
  long timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  timestampAddedSystemExclusive[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
  for (int i=0; i < timestampAddedSystemExclusive.length; i+=19) {
    writeBuffer[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
    timestampAddedSystemExclusive[systemExclusive.length]=(byte)(0x80 | (timestamp & 0x7e));
    if (i + 20 <= timestampAddedSystemExclusive.length) {
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,19);
    }
 else {
      writeBuffer=new byte[timestampAddedSystemExclusive.length - i + 1];
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,timestampAddedSystemExclusive.length - i);
    }
    transferData(writeBuffer);
    timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  }
}"
11371,"/** 
 * Parses MIDI events
 * @param header the header bits
 * @param event the event byte
 */
private void parseMidiEvent(int header,byte event){
  int midiEvent=event & 0xff;
  int timeToWait;
  if (midiState == MIDI_STATE_TIMESTAMP) {
    if ((midiEvent & 0x80) == 0) {
      midiState=MIDI_STATE_WAIT;
    }
  }
  if (midiState == MIDI_STATE_TIMESTAMP) {
    timestamp=((header & 0x3f) << 7) | (midiEvent & 0x7f);
    midiState=MIDI_STATE_WAIT;
  }
 else   if (midiState == MIDI_STATE_WAIT) {
switch (midiEvent & 0xf0) {
case 0xf0:
{
switch (midiEvent) {
case 0xf0:
synchronized (systemExclusiveStream) {
            systemExclusiveStream.reset();
            systemExclusiveStream.write(midiEvent);
            midiState=MIDI_STATE_SIGNAL_SYSEX;
          }
        break;
case 0xf1:
case 0xf3:
      midiEventKind=midiEvent;
    midiState=MIDI_STATE_SIGNAL_2BYTES_2;
  break;
case 0xf2:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xf6:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf8:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfa:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfb:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfc:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfe:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xff:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
break;
}
}
break;
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xc0:
case 0xd0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_2BYTES_2;
break;
default :
if ((midiEventKind & 0xf0) != 0xf0) {
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
}
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_2BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0xc0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xd0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
{
switch (midiEventKind) {
case 0xf1:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf3:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
case 0xf0:
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_3) {
switch (midiEventKind & 0xf0) {
case 0x80:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0x90:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,arg1 & 0xf,arg2,arg3);
}
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xa0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xb0:
midiEventVelocity=midiEvent;
switch (midiEventNote & 0x7f) {
case 98:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 99:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 100:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_RPN;
break;
case 101:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_RPN;
break;
case 38:
parameterValue&=0x3f80;
parameterValue|=midiEventVelocity & 0x7f;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
case 6:
parameterValue&=0x007f;
parameterValue|=(midiEventVelocity & 0x7f) << 7;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
default :
break;
}
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xe0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,arg1 & 0xf,(arg2 & 0x7f) | ((arg3 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,midiEventKind & 0xf,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(arg1 & 0x7f) | ((arg2 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_SYSEX) {
if (midiEvent == 0xf7) {
synchronized (systemExclusiveStream) {
systemExclusiveStream.write(midiEvent);
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(systemExclusiveStream.toByteArray()){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,array);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,systemExclusiveStream.toByteArray());
}
}
}
midiState=MIDI_STATE_TIMESTAMP;
}
 else {
synchronized (systemExclusiveStream) {
systemExclusiveStream.write(midiEvent);
}
}
}
}","/** 
 * Parses MIDI events
 * @param header the header bits
 * @param event the event byte
 */
private void parseMidiEvent(int header,byte event){
  int midiEvent=event & 0xff;
  int timeToWait;
  if (midiState == MIDI_STATE_TIMESTAMP) {
    if ((midiEvent & 0x80) == 0) {
      midiState=MIDI_STATE_WAIT;
    }
    if (midiEvent == 0xf7) {
synchronized (systemExclusiveRecoveryStream) {
        if (systemExclusiveRecoveryStream.size() > 0) {
          int removed=systemExclusiveRecoveryStream.replaceLastByte(midiEvent);
          if (removed >= 0) {
            timestamp=((header & 0x3f) << 7) | (removed & 0x7f);
            timeToWait=calculateTimeToWait(timestamp);
            if (useTimestamp && timeToWait > 0) {
              timer.schedule(new MidiTimerTask(systemExclusiveRecoveryStream.toByteArray()){
                @Override public void run(){
                  if (midiInputEventListener != null) {
                    midiInputEventListener.onMidiSystemExclusive(sender,array);
                  }
                }
              }
,timeToWait);
            }
 else {
              if (midiInputEventListener != null) {
                midiInputEventListener.onMidiSystemExclusive(sender,systemExclusiveRecoveryStream.toByteArray());
              }
            }
          }
          systemExclusiveRecoveryStream.reset();
        }
        midiState=MIDI_STATE_TIMESTAMP;
        return;
      }
    }
 else {
synchronized (systemExclusiveRecoveryStream) {
        if (systemExclusiveRecoveryStream.size() > 0) {
          systemExclusiveRecoveryStream.reset();
        }
      }
    }
  }
  if (midiState == MIDI_STATE_TIMESTAMP) {
    timestamp=((header & 0x3f) << 7) | (midiEvent & 0x7f);
    midiState=MIDI_STATE_WAIT;
  }
 else   if (midiState == MIDI_STATE_WAIT) {
switch (midiEvent & 0xf0) {
case 0xf0:
{
switch (midiEvent) {
case 0xf0:
synchronized (systemExclusiveStream) {
            systemExclusiveStream.reset();
            systemExclusiveStream.write(midiEvent);
            systemExclusiveRecoveryStream.reset();
            midiState=MIDI_STATE_SIGNAL_SYSEX;
          }
        break;
case 0xf1:
case 0xf3:
      midiEventKind=midiEvent;
    midiState=MIDI_STATE_SIGNAL_2BYTES_2;
  break;
case 0xf2:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xf6:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf8:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfa:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfb:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfc:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfe:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xff:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
break;
}
}
break;
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xc0:
case 0xd0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_2BYTES_2;
break;
default :
if ((midiEventKind & 0xf0) != 0xf0) {
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
}
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_2BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0xc0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xd0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
{
switch (midiEventKind) {
case 0xf1:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf3:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
case 0xf0:
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_3) {
switch (midiEventKind & 0xf0) {
case 0x80:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0x90:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,arg1 & 0xf,arg2,arg3);
}
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xa0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xb0:
midiEventVelocity=midiEvent;
switch (midiEventNote & 0x7f) {
case 98:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 99:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 100:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_RPN;
break;
case 101:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_RPN;
break;
case 38:
parameterValue&=0x3f80;
parameterValue|=midiEventVelocity & 0x7f;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
case 6:
parameterValue&=0x007f;
parameterValue|=(midiEventVelocity & 0x7f) << 7;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
default :
break;
}
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xe0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,arg1 & 0xf,(arg2 & 0x7f) | ((arg3 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,midiEventKind & 0xf,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(arg1 & 0x7f) | ((arg2 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_SYSEX) {
if (midiEvent == 0xf7) {
synchronized (systemExclusiveStream) {
int removed=systemExclusiveStream.replaceLastByte(midiEvent);
if (removed >= 0) {
timestamp=((header & 0x3f) << 7) | (removed & 0x7f);
}
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(systemExclusiveStream.toByteArray()){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,array);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,systemExclusiveStream.toByteArray());
}
}
systemExclusiveStream.replaceLastByte(removed);
systemExclusiveStream.write(midiEvent);
systemExclusiveRecoveryStream.reset();
try {
systemExclusiveRecoveryStream.write(systemExclusiveStream.toByteArray());
}
 catch (IOException ignored) {
}
}
midiState=MIDI_STATE_TIMESTAMP;
}
 else {
synchronized (systemExclusiveStream) {
systemExclusiveStream.write(midiEvent);
}
}
}
}"
11372,"/** 
 * SysEx
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public final void sendMidiSystemExclusive(@NonNull byte[] systemExclusive){
  byte[] timestampAddedSystemExclusive=new byte[systemExclusive.length + 2];
  System.arraycopy(systemExclusive,0,timestampAddedSystemExclusive,1,systemExclusive.length);
  byte[] writeBuffer=new byte[20];
  long timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  timestampAddedSystemExclusive[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
  for (int i=0; i < timestampAddedSystemExclusive.length; i+=19) {
    writeBuffer[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
    timestampAddedSystemExclusive[systemExclusive.length]=(byte)(0x80 | (timestamp & 0x7f));
    if (i + 20 <= timestampAddedSystemExclusive.length) {
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,19);
    }
 else {
      writeBuffer=new byte[timestampAddedSystemExclusive.length - i + 1];
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,timestampAddedSystemExclusive.length - i);
    }
    transferData(writeBuffer);
    timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  }
}","/** 
 * SysEx
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public final void sendMidiSystemExclusive(@NonNull byte[] systemExclusive){
  byte[] timestampAddedSystemExclusive=new byte[systemExclusive.length + 2];
  System.arraycopy(systemExclusive,0,timestampAddedSystemExclusive,1,systemExclusive.length);
  long timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  timestampAddedSystemExclusive[systemExclusive.length + 1]=systemExclusive[systemExclusive.length - 1];
  timestampAddedSystemExclusive[0]=(byte)(0x80 | (timestamp & 0x7f));
  byte[] writeBuffer=new byte[20];
  for (int i=0; i < timestampAddedSystemExclusive.length; i+=19) {
    timestampAddedSystemExclusive[systemExclusive.length]=(byte)(0x80 | (timestamp & 0x7e));
    if (i + 19 <= timestampAddedSystemExclusive.length) {
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,19);
    }
 else {
      writeBuffer=new byte[timestampAddedSystemExclusive.length - i + 1];
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,timestampAddedSystemExclusive.length - i);
    }
    writeBuffer[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
    transferData(writeBuffer);
    timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  }
}"
11373,"/** 
 * Parses MIDI events
 * @param header the header bits
 * @param event the event byte
 */
private void parseMidiEvent(int header,byte event){
  int midiEvent=event & 0xff;
  int timeToWait;
  if (midiState == MIDI_STATE_TIMESTAMP) {
    if ((midiEvent & 0x80) == 0) {
      midiState=MIDI_STATE_WAIT;
    }
  }
  if (midiState == MIDI_STATE_TIMESTAMP) {
    timestamp=((header & 0x3f) << 7) | (midiEvent & 0x7f);
    midiState=MIDI_STATE_WAIT;
  }
 else   if (midiState == MIDI_STATE_WAIT) {
switch (midiEvent & 0xf0) {
case 0xf0:
{
switch (midiEvent) {
case 0xf0:
synchronized (systemExclusiveStream) {
            systemExclusiveStream.reset();
            systemExclusiveStream.write(midiEvent);
            midiState=MIDI_STATE_SIGNAL_SYSEX;
          }
        break;
case 0xf1:
case 0xf3:
      midiEventKind=midiEvent;
    midiState=MIDI_STATE_SIGNAL_2BYTES_2;
  break;
case 0xf2:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xf6:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf8:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfa:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfb:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfc:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfe:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xff:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
break;
}
}
break;
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xc0:
case 0xd0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_2BYTES_2;
break;
default :
if ((midiEventKind & 0xf0) != 0xf0) {
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
}
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_2BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0xc0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xd0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
{
switch (midiEventKind) {
case 0xf1:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf3:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
case 0xf0:
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_3) {
switch (midiEventKind & 0xf0) {
case 0x80:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0x90:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,arg1 & 0xf,arg2,arg3);
}
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xa0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xb0:
midiEventVelocity=midiEvent;
switch (midiEventNote & 0x7f) {
case 98:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 99:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 100:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_RPN;
break;
case 101:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_RPN;
break;
case 38:
parameterValue&=0x3f80;
parameterValue|=midiEventVelocity & 0x7f;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
case 6:
parameterValue&=0x007f;
parameterValue|=(midiEventVelocity & 0x7f) << 7;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
default :
break;
}
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xe0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,arg1 & 0xf,(arg2 & 0x7f) | ((arg3 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,midiEventKind & 0xf,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(arg1 & 0x7f) | ((arg2 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_SYSEX) {
if (midiEvent == 0xf7) {
synchronized (systemExclusiveStream) {
systemExclusiveStream.write(midiEvent);
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(systemExclusiveStream.toByteArray()){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,array);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,systemExclusiveStream.toByteArray());
}
}
}
midiState=MIDI_STATE_TIMESTAMP;
}
 else {
synchronized (systemExclusiveStream) {
systemExclusiveStream.write(midiEvent);
}
}
}
}","/** 
 * Parses MIDI events
 * @param header the header bits
 * @param event the event byte
 */
private void parseMidiEvent(int header,byte event){
  int midiEvent=event & 0xff;
  int timeToWait;
  if (midiState == MIDI_STATE_TIMESTAMP) {
    if ((midiEvent & 0x80) == 0) {
      midiState=MIDI_STATE_WAIT;
    }
    if (midiEvent == 0xf7) {
synchronized (systemExclusiveLock) {
        if (systemExclusiveRecoveryStream.size() > 0) {
          int removed=systemExclusiveRecoveryStream.replaceLastByte(midiEvent);
          if (removed >= 0) {
            timestamp=((header & 0x3f) << 7) | (removed & 0x7f);
            timeToWait=calculateTimeToWait(timestamp);
            if (useTimestamp && timeToWait > 0) {
              timer.schedule(new MidiTimerTask(systemExclusiveRecoveryStream.toByteArray()){
                @Override public void run(){
                  if (midiInputEventListener != null) {
                    midiInputEventListener.onMidiSystemExclusive(sender,array);
                  }
                }
              }
,timeToWait);
            }
 else {
              if (midiInputEventListener != null) {
                midiInputEventListener.onMidiSystemExclusive(sender,systemExclusiveRecoveryStream.toByteArray());
              }
            }
          }
          systemExclusiveRecoveryStream.reset();
        }
        midiState=MIDI_STATE_TIMESTAMP;
        return;
      }
    }
 else {
synchronized (systemExclusiveLock) {
        if (systemExclusiveRecoveryStream.size() > 0) {
          systemExclusiveRecoveryStream.reset();
        }
      }
    }
  }
  if (midiState == MIDI_STATE_TIMESTAMP) {
    timestamp=((header & 0x3f) << 7) | (midiEvent & 0x7f);
    midiState=MIDI_STATE_WAIT;
  }
 else   if (midiState == MIDI_STATE_WAIT) {
switch (midiEvent & 0xf0) {
case 0xf0:
{
switch (midiEvent) {
case 0xf0:
synchronized (systemExclusiveLock) {
            systemExclusiveStream.reset();
            systemExclusiveStream.write(midiEvent);
            systemExclusiveRecoveryStream.reset();
            midiState=MIDI_STATE_SIGNAL_SYSEX;
          }
        break;
case 0xf1:
case 0xf3:
      midiEventKind=midiEvent;
    midiState=MIDI_STATE_SIGNAL_2BYTES_2;
  break;
case 0xf2:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xf6:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTuneRequest(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf8:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimingClock(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfa:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStart(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfb:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiContinue(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfc:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiStop(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xfe:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiActiveSensing(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xff:
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiReset(sender);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
break;
}
}
break;
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_2;
break;
case 0xc0:
case 0xd0:
midiEventKind=midiEvent;
midiState=MIDI_STATE_SIGNAL_2BYTES_2;
break;
default :
if ((midiEventKind & 0xf0) != 0xf0) {
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
}
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_2BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0xc0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiProgramChange(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xd0:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,arg1 & 0xf,arg2);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiChannelAftertouch(sender,midiEventKind & 0xf,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
{
switch (midiEventKind) {
case 0xf1:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiTimeCodeQuarterFrame(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf3:
midiEventNote=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,arg1);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongSelect(sender,midiEventNote);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_2) {
switch (midiEventKind & 0xf0) {
case 0x80:
case 0x90:
case 0xa0:
case 0xb0:
case 0xe0:
case 0xf0:
midiEventNote=midiEvent;
midiState=MIDI_STATE_SIGNAL_3BYTES_3;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_3BYTES_3) {
switch (midiEventKind & 0xf0) {
case 0x80:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0x90:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,arg1 & 0xf,arg2,arg3);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,arg1 & 0xf,arg2,arg3);
}
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
if (midiEventVelocity == 0) {
midiInputEventListener.onMidiNoteOff(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
 else {
midiInputEventListener.onMidiNoteOn(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xa0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPolyphonicAftertouch(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xb0:
midiEventVelocity=midiEvent;
switch (midiEventNote & 0x7f) {
case 98:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 99:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_NRPN;
break;
case 100:
parameterNumber&=0x3f80;
parameterNumber|=midiEventVelocity & 0x7f;
parameterMode=PARAMETER_MODE_RPN;
break;
case 101:
parameterNumber&=0x007f;
parameterNumber|=(midiEventVelocity & 0x7f) << 7;
parameterMode=PARAMETER_MODE_RPN;
break;
case 38:
parameterValue&=0x3f80;
parameterValue|=midiEventVelocity & 0x7f;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
case 6:
parameterValue&=0x007f;
parameterValue|=(midiEventVelocity & 0x7f) << 7;
if (parameterNumber != 0x3fff) {
if (parameterMode == PARAMETER_MODE_RPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
 else if (parameterMode == PARAMETER_MODE_NRPN) {
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,parameterNumber,parameterValue){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,arg1 & 0xf,arg2 & 0x3fff,arg3 & 0x3fff);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onNRPNMessage(sender,midiEventKind & 0xf,parameterNumber & 0x3fff,parameterValue & 0x3fff);
}
}
}
}
break;
default :
break;
}
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,arg1 & 0xf,arg2,arg3);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiControlChange(sender,midiEventKind & 0xf,midiEventNote,midiEventVelocity);
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xe0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventKind,midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,arg1 & 0xf,(arg2 & 0x7f) | ((arg3 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiPitchWheel(sender,midiEventKind & 0xf,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
case 0xf0:
midiEventVelocity=midiEvent;
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(midiEventNote,midiEventVelocity){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(arg1 & 0x7f) | ((arg2 & 0x7f) << 7));
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSongPositionPointer(sender,(midiEventNote & 0x7f) | ((midiEventVelocity & 0x7f) << 7));
}
}
midiState=MIDI_STATE_TIMESTAMP;
break;
default :
midiState=MIDI_STATE_TIMESTAMP;
break;
}
}
 else if (midiState == MIDI_STATE_SIGNAL_SYSEX) {
if (midiEvent == 0xf7) {
synchronized (systemExclusiveLock) {
int replacedEvent=systemExclusiveStream.replaceLastByte(midiEvent);
if (replacedEvent >= 0) {
timestamp=((header & 0x3f) << 7) | (replacedEvent & 0x7f);
}
timeToWait=calculateTimeToWait(timestamp);
if (useTimestamp && timeToWait > 0) {
timer.schedule(new MidiTimerTask(systemExclusiveStream.toByteArray()){
@Override public void run(){
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,array);
}
}
}
,timeToWait);
}
 else {
if (midiInputEventListener != null) {
midiInputEventListener.onMidiSystemExclusive(sender,systemExclusiveStream.toByteArray());
}
}
systemExclusiveRecoveryStream.reset();
try {
systemExclusiveStream.writeTo(systemExclusiveRecoveryStream);
}
 catch (IOException ignored) {
}
systemExclusiveRecoveryStream.replaceLastByte(replacedEvent);
systemExclusiveRecoveryStream.write(midiEvent);
}
midiState=MIDI_STATE_TIMESTAMP;
}
 else {
synchronized (systemExclusiveLock) {
systemExclusiveStream.write(midiEvent);
}
}
}
}"
11374,"/** 
 * Disconnects the device by its address
 * @param deviceAddress the device address from {@link android.bluetooth.BluetoothGatt}
 */
private void disconnectByDeviceAddress(@NonNull String deviceAddress){
synchronized (deviceAddressGattMap) {
    BluetoothGatt bluetoothGatt=deviceAddressGattMap.get(deviceAddress);
    if (bluetoothGatt != null) {
      bluetoothGatt.disconnect();
      bluetoothGatt.close();
      deviceAddressGattMap.remove(deviceAddress);
    }
  }
synchronized (midiInputDevicesMap) {
    Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(deviceAddress);
    if (midiInputDevices != null) {
      midiInputDevicesMap.remove(deviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.setOnMidiInputEventListener(null);
        if (midiDeviceDetachedListener != null) {
          midiDeviceDetachedListener.onMidiInputDeviceDetached(midiInputDevice);
        }
      }
      midiInputDevices.clear();
    }
  }
synchronized (midiOutputDevicesMap) {
    Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(deviceAddress);
    if (midiOutputDevices != null) {
      midiOutputDevicesMap.remove(deviceAddress);
      for (      MidiOutputDevice midiOutputDevice : midiOutputDevices) {
        if (midiDeviceDetachedListener != null) {
          midiDeviceDetachedListener.onMidiOutputDeviceDetached(midiOutputDevice);
        }
      }
      midiOutputDevices.clear();
    }
  }
}","/** 
 * Disconnects the device by its address
 * @param deviceAddress the device address from {@link android.bluetooth.BluetoothGatt}
 */
private void disconnectByDeviceAddress(@NonNull String deviceAddress){
synchronized (deviceAddressGattMap) {
    BluetoothGatt bluetoothGatt=deviceAddressGattMap.get(deviceAddress);
    if (bluetoothGatt != null) {
      bluetoothGatt.disconnect();
      bluetoothGatt.close();
      deviceAddressGattMap.remove(deviceAddress);
    }
  }
synchronized (midiInputDevicesMap) {
    Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(deviceAddress);
    if (midiInputDevices != null) {
      midiInputDevicesMap.remove(deviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        ((InternalMidiInputDevice)midiInputDevice).stop();
        midiInputDevice.setOnMidiInputEventListener(null);
        if (midiDeviceDetachedListener != null) {
          midiDeviceDetachedListener.onMidiInputDeviceDetached(midiInputDevice);
        }
      }
      midiInputDevices.clear();
    }
  }
synchronized (midiOutputDevicesMap) {
    Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(deviceAddress);
    if (midiOutputDevices != null) {
      midiOutputDevicesMap.remove(deviceAddress);
      for (      MidiOutputDevice midiOutputDevice : midiOutputDevices) {
        if (midiDeviceDetachedListener != null) {
          midiDeviceDetachedListener.onMidiOutputDeviceDetached(midiOutputDevice);
        }
      }
      midiOutputDevices.clear();
    }
  }
}"
11375,"@SuppressLint(""String_Node_Str"") @Override public void onServicesDiscovered(final BluetoothGatt gatt,int status){
  super.onServicesDiscovered(gatt,status);
  if (status != BluetoothGatt.GATT_SUCCESS) {
    return;
  }
  final String gattDeviceAddress=gatt.getDevice().getAddress();
  if (midiInputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.setOnMidiInputEventListener(null);
      }
      midiInputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiInputDevice midiInputDevice=null;
  try {
    midiInputDevice=new InternalMidiInputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.d(Constants.TAG,iae.getMessage());
  }
  if (midiInputDevice != null) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      if (midiInputDevices == null) {
        midiInputDevices=new HashSet<>();
        midiInputDevicesMap.put(gattDeviceAddress,midiInputDevices);
      }
      midiInputDevices.add(midiInputDevice);
    }
    if (!deviceAddressGattMap.containsKey(gattDeviceAddress)) {
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
      }
    }
  }
  if (midiOutputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiOutputDevicesMap) {
      midiOutputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiOutputDevice midiOutputDevice=null;
  try {
    midiOutputDevice=new InternalMidiOutputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.d(Constants.TAG,iae.getMessage());
  }
  if (midiOutputDevice != null) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      if (midiOutputDevices == null) {
        midiOutputDevices=new HashSet<>();
        midiOutputDevicesMap.put(gattDeviceAddress,midiOutputDevices);
      }
      midiOutputDevices.add(midiOutputDevice);
    }
    if (!deviceAddressGattMap.containsKey(gattDeviceAddress)) {
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
      }
    }
  }
  if (midiInputDevice != null || midiOutputDevice != null) {
synchronized (deviceAddressGattMap) {
      deviceAddressGattMap.put(gattDeviceAddress,gatt);
    }
    if (needsBonding && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      BluetoothDevice bluetoothDevice=gatt.getDevice();
      if (bluetoothDevice.getBondState() != BluetoothDevice.BOND_BONDED) {
        bluetoothDevice.createBond();
        bluetoothDevice.setPairingConfirmation(true);
        if (bondingBroadcastReceiver != null) {
          context.unregisterReceiver(bondingBroadcastReceiver);
        }
        bondingBroadcastReceiver=new BondingBroadcastReceiver(midiInputDevice,midiOutputDevice);
        IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
        context.registerReceiver(bondingBroadcastReceiver,filter);
      }
    }
 else {
      if (midiInputDevice != null) {
        ((InternalMidiInputDevice)midiInputDevice).configureAsCentralDevice();
      }
      if (midiOutputDevice != null) {
        ((InternalMidiOutputDevice)midiOutputDevice).configureAsCentralDevice();
      }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      gatt.requestMtu(23);
      gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
    }
  }
}","@SuppressLint(""String_Node_Str"") @Override public void onServicesDiscovered(final BluetoothGatt gatt,int status){
  super.onServicesDiscovered(gatt,status);
  if (status != BluetoothGatt.GATT_SUCCESS) {
    return;
  }
  final String gattDeviceAddress=gatt.getDevice().getAddress();
  if (midiInputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        ((InternalMidiInputDevice)midiInputDevice).stop();
        midiInputDevice.setOnMidiInputEventListener(null);
      }
      midiInputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiInputDevice midiInputDevice=null;
  try {
    midiInputDevice=new InternalMidiInputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.d(Constants.TAG,iae.getMessage());
  }
  if (midiInputDevice != null) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      if (midiInputDevices == null) {
        midiInputDevices=new HashSet<>();
        midiInputDevicesMap.put(gattDeviceAddress,midiInputDevices);
      }
      midiInputDevices.add(midiInputDevice);
    }
    if (!deviceAddressGattMap.containsKey(gattDeviceAddress)) {
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
      }
    }
  }
  if (midiOutputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiOutputDevicesMap) {
      midiOutputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiOutputDevice midiOutputDevice=null;
  try {
    midiOutputDevice=new InternalMidiOutputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.d(Constants.TAG,iae.getMessage());
  }
  if (midiOutputDevice != null) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      if (midiOutputDevices == null) {
        midiOutputDevices=new HashSet<>();
        midiOutputDevicesMap.put(gattDeviceAddress,midiOutputDevices);
      }
      midiOutputDevices.add(midiOutputDevice);
    }
    if (!deviceAddressGattMap.containsKey(gattDeviceAddress)) {
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
      }
    }
  }
  if (midiInputDevice != null || midiOutputDevice != null) {
synchronized (deviceAddressGattMap) {
      deviceAddressGattMap.put(gattDeviceAddress,gatt);
    }
    if (needsBonding && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      BluetoothDevice bluetoothDevice=gatt.getDevice();
      if (bluetoothDevice.getBondState() != BluetoothDevice.BOND_BONDED) {
        bluetoothDevice.createBond();
        bluetoothDevice.setPairingConfirmation(true);
        if (bondingBroadcastReceiver != null) {
          context.unregisterReceiver(bondingBroadcastReceiver);
        }
        bondingBroadcastReceiver=new BondingBroadcastReceiver(midiInputDevice,midiOutputDevice);
        IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
        context.registerReceiver(bondingBroadcastReceiver,filter);
      }
    }
 else {
      if (midiInputDevice != null) {
        ((InternalMidiInputDevice)midiInputDevice).configureAsCentralDevice();
      }
      if (midiOutputDevice != null) {
        ((InternalMidiOutputDevice)midiOutputDevice).configureAsCentralDevice();
      }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      gatt.requestMtu(23);
      gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
    }
  }
}"
11376,"/** 
 * Terminates callback
 */
public void terminate(){
synchronized (deviceAddressGattMap) {
    for (    BluetoothGatt bluetoothGatt : deviceAddressGattMap.values()) {
      bluetoothGatt.disconnect();
      bluetoothGatt.close();
    }
    deviceAddressGattMap.clear();
  }
synchronized (midiInputDevicesMap) {
    for (    Set<MidiInputDevice> midiInputDevices : midiInputDevicesMap.values()) {
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.setOnMidiInputEventListener(null);
      }
      midiInputDevices.clear();
    }
    midiInputDevicesMap.clear();
  }
synchronized (midiOutputDevicesMap) {
    midiOutputDevicesMap.clear();
  }
  if (bondingBroadcastReceiver != null) {
    context.unregisterReceiver(bondingBroadcastReceiver);
    bondingBroadcastReceiver=null;
  }
}","/** 
 * Terminates callback
 */
public void terminate(){
synchronized (deviceAddressGattMap) {
    for (    BluetoothGatt bluetoothGatt : deviceAddressGattMap.values()) {
      bluetoothGatt.disconnect();
      bluetoothGatt.close();
    }
    deviceAddressGattMap.clear();
  }
synchronized (midiInputDevicesMap) {
    for (    Set<MidiInputDevice> midiInputDevices : midiInputDevicesMap.values()) {
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        ((InternalMidiInputDevice)midiInputDevice).stop();
        midiInputDevice.setOnMidiInputEventListener(null);
      }
      midiInputDevices.clear();
    }
    midiInputDevicesMap.clear();
  }
synchronized (midiOutputDevicesMap) {
    midiOutputDevicesMap.clear();
  }
  if (bondingBroadcastReceiver != null) {
    context.unregisterReceiver(bondingBroadcastReceiver);
    bondingBroadcastReceiver=null;
  }
}"
11377,"/** 
 * Disconnects the device by its address
 * @param deviceAddress the device address from {@link android.bluetooth.BluetoothGatt}
 */
private void disconnectByDeviceAddress(@NonNull String deviceAddress){
synchronized (bluetoothDevicesMap) {
    BluetoothDevice bluetoothDevice=bluetoothDevicesMap.get(deviceAddress);
    if (bluetoothDevice != null) {
      gattServer.cancelConnection(bluetoothDevice);
    }
    bluetoothDevicesMap.remove(deviceAddress);
  }
synchronized (midiInputDevicesMap) {
    MidiInputDevice midiInputDevice=midiInputDevicesMap.get(deviceAddress);
    if (midiInputDevice != null) {
      midiInputDevicesMap.remove(deviceAddress);
      midiInputDevice.setOnMidiInputEventListener(null);
      if (midiDeviceDetachedListener != null) {
        midiDeviceDetachedListener.onMidiInputDeviceDetached(midiInputDevice);
      }
    }
  }
synchronized (midiOutputDevicesMap) {
    MidiOutputDevice midiOutputDevice=midiOutputDevicesMap.get(deviceAddress);
    if (midiOutputDevice != null) {
      midiOutputDevicesMap.remove(deviceAddress);
      if (midiDeviceDetachedListener != null) {
        midiDeviceDetachedListener.onMidiOutputDeviceDetached(midiOutputDevice);
      }
    }
  }
}","/** 
 * Disconnects the device by its address
 * @param deviceAddress the device address from {@link android.bluetooth.BluetoothGatt}
 */
private void disconnectByDeviceAddress(@NonNull String deviceAddress){
synchronized (bluetoothDevicesMap) {
    BluetoothDevice bluetoothDevice=bluetoothDevicesMap.get(deviceAddress);
    if (bluetoothDevice != null) {
      gattServer.cancelConnection(bluetoothDevice);
    }
    bluetoothDevicesMap.remove(deviceAddress);
  }
synchronized (midiInputDevicesMap) {
    MidiInputDevice midiInputDevice=midiInputDevicesMap.get(deviceAddress);
    if (midiInputDevice != null) {
      midiInputDevicesMap.remove(deviceAddress);
      ((InternalMidiInputDevice)midiInputDevice).stop();
      midiInputDevice.setOnMidiInputEventListener(null);
      if (midiDeviceDetachedListener != null) {
        midiDeviceDetachedListener.onMidiInputDeviceDetached(midiInputDevice);
      }
    }
  }
synchronized (midiOutputDevicesMap) {
    MidiOutputDevice midiOutputDevice=midiOutputDevicesMap.get(deviceAddress);
    if (midiOutputDevice != null) {
      midiOutputDevicesMap.remove(deviceAddress);
      if (midiDeviceDetachedListener != null) {
        midiDeviceDetachedListener.onMidiOutputDeviceDetached(midiOutputDevice);
      }
    }
  }
}"
11378,"@Override public void onConnectionStateChange(BluetoothDevice device,int status,int newState){
  super.onConnectionStateChange(device,status,newState);
switch (newState) {
case BluetoothProfile.STATE_CONNECTED:
    if (requireBonding && device.getBondState() == BluetoothDevice.BOND_NONE) {
      device.createBond();
      device.setPairingConfirmation(true);
      IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
      context.registerReceiver(new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          final String action=intent.getAction();
          if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
            final int state=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
            if (state == BluetoothDevice.BOND_BONDED) {
              BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
              context.unregisterReceiver(this);
              connectMidiDevice(device);
            }
          }
        }
      }
,filter);
    }
 else {
      connectMidiDevice(device);
    }
  break;
case BluetoothProfile.STATE_DISCONNECTED:
String deviceAddress=device.getAddress();
synchronized (midiInputDevicesMap) {
MidiInputDevice midiInputDevice=midiInputDevicesMap.get(deviceAddress);
if (midiInputDevice != null) {
  midiInputDevicesMap.remove(deviceAddress);
  midiInputDevice.setOnMidiInputEventListener(null);
  if (midiDeviceDetachedListener != null) {
    midiDeviceDetachedListener.onMidiInputDeviceDetached(midiInputDevice);
  }
}
}
synchronized (midiOutputDevicesMap) {
MidiOutputDevice midiOutputDevice=midiOutputDevicesMap.get(deviceAddress);
if (midiOutputDevice != null) {
midiOutputDevicesMap.remove(deviceAddress);
if (midiDeviceDetachedListener != null) {
  midiDeviceDetachedListener.onMidiOutputDeviceDetached(midiOutputDevice);
}
}
}
synchronized (bluetoothDevicesMap) {
bluetoothDevicesMap.remove(deviceAddress);
}
break;
}
}","@Override public void onConnectionStateChange(BluetoothDevice device,int status,int newState){
  super.onConnectionStateChange(device,status,newState);
switch (newState) {
case BluetoothProfile.STATE_CONNECTED:
    if (requireBonding && device.getBondState() == BluetoothDevice.BOND_NONE) {
      device.createBond();
      device.setPairingConfirmation(true);
      IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
      context.registerReceiver(new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          final String action=intent.getAction();
          if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
            final int state=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
            if (state == BluetoothDevice.BOND_BONDED) {
              BluetoothDevice device=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
              context.unregisterReceiver(this);
              connectMidiDevice(device);
            }
          }
        }
      }
,filter);
    }
 else {
      connectMidiDevice(device);
    }
  break;
case BluetoothProfile.STATE_DISCONNECTED:
String deviceAddress=device.getAddress();
synchronized (midiInputDevicesMap) {
MidiInputDevice midiInputDevice=midiInputDevicesMap.get(deviceAddress);
if (midiInputDevice != null) {
  midiInputDevicesMap.remove(deviceAddress);
  ((InternalMidiInputDevice)midiInputDevice).stop();
  midiInputDevice.setOnMidiInputEventListener(null);
  if (midiDeviceDetachedListener != null) {
    midiDeviceDetachedListener.onMidiInputDeviceDetached(midiInputDevice);
  }
}
}
synchronized (midiOutputDevicesMap) {
MidiOutputDevice midiOutputDevice=midiOutputDevicesMap.get(deviceAddress);
if (midiOutputDevice != null) {
midiOutputDevicesMap.remove(deviceAddress);
if (midiDeviceDetachedListener != null) {
  midiDeviceDetachedListener.onMidiOutputDeviceDetached(midiOutputDevice);
}
}
}
synchronized (bluetoothDevicesMap) {
bluetoothDevicesMap.remove(deviceAddress);
}
break;
}
}"
11379,"/** 
 * Terminates provider
 */
public void terminate(){
  stopAdvertising();
synchronized (bluetoothDevicesMap) {
    for (    BluetoothDevice bluetoothDevice : bluetoothDevicesMap.values()) {
      if (gattServer != null) {
        gattServer.cancelConnection(bluetoothDevice);
      }
    }
    bluetoothDevicesMap.clear();
  }
  if (gattServer != null) {
    gattServer.close();
    gattServer=null;
  }
synchronized (midiInputDevicesMap) {
    for (    MidiInputDevice midiInputDevice : midiInputDevicesMap.values()) {
      midiInputDevice.setOnMidiInputEventListener(null);
    }
    midiInputDevicesMap.clear();
  }
synchronized (midiOutputDevicesMap) {
    midiOutputDevicesMap.clear();
  }
}","/** 
 * Terminates provider
 */
public void terminate(){
  stopAdvertising();
synchronized (bluetoothDevicesMap) {
    for (    BluetoothDevice bluetoothDevice : bluetoothDevicesMap.values()) {
      if (gattServer != null) {
        gattServer.cancelConnection(bluetoothDevice);
      }
    }
    bluetoothDevicesMap.clear();
  }
  if (gattServer != null) {
    gattServer.close();
    gattServer=null;
  }
synchronized (midiInputDevicesMap) {
    for (    MidiInputDevice midiInputDevice : midiInputDevicesMap.values()) {
      ((InternalMidiInputDevice)midiInputDevice).stop();
      midiInputDevice.setOnMidiInputEventListener(null);
    }
    midiInputDevicesMap.clear();
  }
synchronized (midiOutputDevicesMap) {
    midiOutputDevicesMap.clear();
  }
}"
11380,"/** 
 * Constructor
 * @param context
 */
public BleMidiCentralProvider(final Context context){
  if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE) == false) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  bluetoothAdapter=((BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter();
  if (bluetoothAdapter == null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  this.context=context;
  this.midiCallback=new BleMidiCallback(context);
  this.handler=new Handler(context.getMainLooper());
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    scanCallback=new ScanCallback(){
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onScanResult(      int callbackType,      ScanResult result){
        super.onScanResult(callbackType,result);
        if (callbackType == ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
          final BluetoothDevice bluetoothDevice=result.getDevice();
          if (bluetoothDevice.getType() != BluetoothDevice.DEVICE_TYPE_LE && bluetoothDevice.getType() != BluetoothDevice.DEVICE_TYPE_DUAL) {
            return;
          }
          BluetoothGatt bluetoothGatt=bluetoothDevice.connectGatt(BleMidiCentralProvider.this.context,true,midiCallback);
          Log.i(Constants.TAG,""String_Node_Str"" + bluetoothGatt.getDevice().getName());
        }
      }
    }
;
  }
 else {
    scanCallback=null;
  }
}","/** 
 * Constructor
 * @param context
 */
@SuppressLint(""String_Node_Str"") public BleMidiCentralProvider(final Context context){
  if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE) == false) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  bluetoothAdapter=((BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter();
  if (bluetoothAdapter == null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  this.context=context;
  this.midiCallback=new BleMidiCallback(context);
  this.handler=new Handler(context.getMainLooper());
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    scanCallback=new ScanCallback(){
      @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override public void onScanResult(      int callbackType,      ScanResult result){
        super.onScanResult(callbackType,result);
        if (callbackType == ScanSettings.CALLBACK_TYPE_ALL_MATCHES) {
          final BluetoothDevice bluetoothDevice=result.getDevice();
          if (bluetoothDevice.getType() != BluetoothDevice.DEVICE_TYPE_LE && bluetoothDevice.getType() != BluetoothDevice.DEVICE_TYPE_DUAL) {
            return;
          }
          BluetoothGatt bluetoothGatt=bluetoothDevice.connectGatt(BleMidiCentralProvider.this.context,true,midiCallback);
          Log.i(Constants.TAG,""String_Node_Str"" + bluetoothGatt.getDevice().getName());
        }
      }
    }
;
  }
 else {
    scanCallback=null;
  }
}"
11381,"/** 
 * Starts to scan devices
 * @param timeoutInMilliSeconds 0 or negative value : no timeout
 */
public void startScanDevice(int timeoutInMilliSeconds){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    bluetoothAdapter.getBluetoothLeScanner().startScan(scanCallback);
  }
 else {
    bluetoothAdapter.startLeScan(leScanCallback);
  }
  isScanning=true;
  if (onMidiScanStatusListener != null) {
    onMidiScanStatusListener.onMidiScanStatusChanged(isScanning);
  }
  if (timeoutInMilliSeconds > 0) {
    handler.postDelayed(new Runnable(){
      @Override public void run(){
        stopScanDevice();
        isScanning=false;
        if (onMidiScanStatusListener != null) {
          onMidiScanStatusListener.onMidiScanStatusChanged(isScanning);
        }
      }
    }
,timeoutInMilliSeconds);
  }
}","/** 
 * Starts to scan devices
 * @param timeoutInMilliSeconds 0 or negative value : no timeout
 */
@SuppressLint({""String_Node_Str"",""String_Node_Str""}) public void startScanDevice(int timeoutInMilliSeconds){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    bluetoothAdapter.getBluetoothLeScanner().startScan(scanCallback);
  }
 else {
    bluetoothAdapter.startLeScan(leScanCallback);
  }
  isScanning=true;
  if (onMidiScanStatusListener != null) {
    onMidiScanStatusListener.onMidiScanStatusChanged(isScanning);
  }
  if (timeoutInMilliSeconds > 0) {
    handler.postDelayed(new Runnable(){
      @Override public void run(){
        stopScanDevice();
        isScanning=false;
        if (onMidiScanStatusListener != null) {
          onMidiScanStatusListener.onMidiScanStatusChanged(isScanning);
        }
      }
    }
,timeoutInMilliSeconds);
  }
}"
11382,"/** 
 * Stops to scan devices
 */
public void stopScanDevice(){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    bluetoothAdapter.getBluetoothLeScanner().stopScan(scanCallback);
  }
 else {
    bluetoothAdapter.stopLeScan(leScanCallback);
  }
  isScanning=false;
  if (onMidiScanStatusListener != null) {
    onMidiScanStatusListener.onMidiScanStatusChanged(isScanning);
  }
}","/** 
 * Stops to scan devices
 */
@SuppressLint({""String_Node_Str"",""String_Node_Str""}) public void stopScanDevice(){
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    bluetoothAdapter.getBluetoothLeScanner().stopScan(scanCallback);
  }
 else {
    bluetoothAdapter.stopLeScan(leScanCallback);
  }
  isScanning=false;
  if (onMidiScanStatusListener != null) {
    onMidiScanStatusListener.onMidiScanStatusChanged(isScanning);
  }
}"
11383,"@Override public void onServicesDiscovered(final BluetoothGatt gatt,int status){
  super.onServicesDiscovered(gatt,status);
  Log.i(Constants.TAG,""String_Node_Str"" + status);
  if (status != BluetoothGatt.GATT_SUCCESS) {
    return;
  }
  final String gattDeviceAddress=gatt.getDevice().getAddress();
  if (midiInputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.close();
      }
      midiInputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiInputDevice midiInputDevice=MidiInputDevice.getInstance(context,gatt);
  if (midiInputDevice != null) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      if (midiInputDevices == null) {
        midiInputDevices=new HashSet<MidiInputDevice>();
        midiInputDevicesMap.put(gattDeviceAddress,midiInputDevices);
      }
      midiInputDevices.add(midiInputDevice);
    }
    Log.d(Constants.TAG,""String_Node_Str"" + midiInputDevice.getDeviceName());
    if (midiDeviceAttachedListener != null) {
      midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
    }
  }
  if (midiOutputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      for (      MidiOutputDevice midiOutputDevice : midiOutputDevices) {
        midiOutputDevice.close();
      }
      midiOutputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiOutputDevice midiOutputDevice=MidiOutputDevice.getInstance(context,gatt);
  if (midiOutputDevice != null) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      if (midiOutputDevices == null) {
        midiOutputDevices=new HashSet<MidiOutputDevice>();
        midiOutputDevicesMap.put(gattDeviceAddress,midiOutputDevices);
      }
      midiOutputDevices.add(midiOutputDevice);
    }
    Log.d(Constants.TAG,""String_Node_Str"" + midiOutputDevice.getDeviceName());
    if (midiDeviceAttachedListener != null) {
      midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
    }
  }
  if (midiInputDevice != null || midiOutputDevice != null) {
    BluetoothDevice bluetoothDevice=gatt.getDevice();
    if (bluetoothDevice.getBondState() == BluetoothDevice.BOND_NONE) {
      Log.i(Constants.TAG,""String_Node_Str"" + bluetoothDevice.getName());
      bluetoothDevice.createBond();
      bluetoothDevice.setPairingConfirmation(true);
      IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
      bondingBroadcastReceiver=new BondingBroadcastReceiver(midiInputDevice,midiOutputDevice);
      context.registerReceiver(bondingBroadcastReceiver,filter);
    }
 else {
      if (midiInputDevice != null) {
        midiInputDevice.open();
      }
      if (midiOutputDevice != null) {
        midiOutputDevice.open();
      }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      gatt.requestMtu(23);
      gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
    }
  }
}","@SuppressLint(""String_Node_Str"") @Override public void onServicesDiscovered(final BluetoothGatt gatt,int status){
  super.onServicesDiscovered(gatt,status);
  Log.i(Constants.TAG,""String_Node_Str"" + status);
  if (status != BluetoothGatt.GATT_SUCCESS) {
    return;
  }
  final String gattDeviceAddress=gatt.getDevice().getAddress();
  if (midiInputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.close();
      }
      midiInputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiInputDevice midiInputDevice=MidiInputDevice.getInstance(context,gatt);
  if (midiInputDevice != null) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      if (midiInputDevices == null) {
        midiInputDevices=new HashSet<MidiInputDevice>();
        midiInputDevicesMap.put(gattDeviceAddress,midiInputDevices);
      }
      midiInputDevices.add(midiInputDevice);
    }
    Log.d(Constants.TAG,""String_Node_Str"" + midiInputDevice.getDeviceName());
    if (midiDeviceAttachedListener != null) {
      midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
    }
  }
  if (midiOutputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      for (      MidiOutputDevice midiOutputDevice : midiOutputDevices) {
        midiOutputDevice.close();
      }
      midiOutputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiOutputDevice midiOutputDevice=MidiOutputDevice.getInstance(context,gatt);
  if (midiOutputDevice != null) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      if (midiOutputDevices == null) {
        midiOutputDevices=new HashSet<MidiOutputDevice>();
        midiOutputDevicesMap.put(gattDeviceAddress,midiOutputDevices);
      }
      midiOutputDevices.add(midiOutputDevice);
    }
    Log.d(Constants.TAG,""String_Node_Str"" + midiOutputDevice.getDeviceName());
    if (midiDeviceAttachedListener != null) {
      midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
    }
  }
  if (midiInputDevice != null || midiOutputDevice != null) {
    BluetoothDevice bluetoothDevice=gatt.getDevice();
    if (bluetoothDevice.getBondState() == BluetoothDevice.BOND_NONE) {
      Log.i(Constants.TAG,""String_Node_Str"" + bluetoothDevice.getName());
      bluetoothDevice.createBond();
      bluetoothDevice.setPairingConfirmation(true);
      IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
      bondingBroadcastReceiver=new BondingBroadcastReceiver(midiInputDevice,midiOutputDevice);
      context.registerReceiver(bondingBroadcastReceiver,filter);
    }
 else {
      if (midiInputDevice != null) {
        midiInputDevice.open();
      }
      if (midiOutputDevice != null) {
        midiOutputDevice.open();
      }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      gatt.requestMtu(23);
      gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
    }
  }
}"
11384,"/** 
 * SysEx
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public final void sendMidiSystemExclusive(byte[] systemExclusive){
  byte[] timestampAddedSystemExclusive=new byte[systemExclusive.length + 2];
  System.arraycopy(systemExclusive,0,timestampAddedSystemExclusive,1,systemExclusive.length);
  timestampAddedSystemExclusive[0]=(byte)0x80;
  timestampAddedSystemExclusive[systemExclusive.length]=(byte)0x80;
  byte[] writeBuffer=new byte[20];
  writeBuffer[0]=(byte)0x80;
  for (int i=0; i < timestampAddedSystemExclusive.length; i+=19) {
    if (i + 20 <= timestampAddedSystemExclusive.length) {
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,19);
    }
 else {
      writeBuffer=new byte[timestampAddedSystemExclusive.length - i + 1];
      writeBuffer[0]=(byte)0x80;
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,timestampAddedSystemExclusive.length - i);
    }
    transferData(writeBuffer);
  }
}","/** 
 * SysEx
 * @param systemExclusive : start with 'F0', and end with 'F7'
 */
public final void sendMidiSystemExclusive(byte[] systemExclusive){
  byte[] timestampAddedSystemExclusive=new byte[systemExclusive.length + 2];
  System.arraycopy(systemExclusive,0,timestampAddedSystemExclusive,1,systemExclusive.length);
  byte[] writeBuffer=new byte[20];
  long timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  timestampAddedSystemExclusive[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
  for (int i=0; i < timestampAddedSystemExclusive.length; i+=19) {
    writeBuffer[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
    timestampAddedSystemExclusive[systemExclusive.length]=(byte)(0x80 | (timestamp & 0x7f));
    if (i + 20 <= timestampAddedSystemExclusive.length) {
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,19);
    }
 else {
      writeBuffer=new byte[timestampAddedSystemExclusive.length - i + 1];
      System.arraycopy(timestampAddedSystemExclusive,i,writeBuffer,1,timestampAddedSystemExclusive.length - i);
    }
    transferData(writeBuffer);
    timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  }
}"
11385,"/** 
 * Sends MIDI message to output device.
 * @param byte1 the first byte
 * @param byte2 the second byte
 * @param byte3 the third byte
 */
private void sendMidiMessage(int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[5];
  writeBuffer[0]=(byte)0x80;
  writeBuffer[1]=(byte)0x80;
  writeBuffer[2]=(byte)byte1;
  writeBuffer[3]=(byte)byte2;
  writeBuffer[4]=(byte)byte3;
  transferData(writeBuffer);
}","/** 
 * Sends MIDI message to output device.
 * @param byte1 the first byte
 * @param byte2 the second byte
 * @param byte3 the third byte
 */
private void sendMidiMessage(int byte1,int byte2,int byte3){
  byte[] writeBuffer=new byte[5];
  long timestamp=System.currentTimeMillis() % MAX_TIMESTAMP;
  writeBuffer[0]=(byte)(0x80 | ((timestamp >> 7) & 0x3f));
  writeBuffer[1]=(byte)(0x80 | (timestamp & 0x7f));
  writeBuffer[2]=(byte)byte1;
  writeBuffer[3]=(byte)byte2;
  writeBuffer[4]=(byte)byte3;
  transferData(writeBuffer);
}"
11386,"/** 
 * Disconnect the specified device
 * @param midiOutputDevice the device
 */
void disconnectDevice(MidiOutputDevice midiOutputDevice){
synchronized (deviceAddressGattMap) {
    String deviceAddress=((jp.kshoji.blemidi.central.MidiOutputDevice)midiOutputDevice).getDeviceAddress();
    BluetoothGatt bluetoothGatt=deviceAddressGattMap.get(deviceAddress);
    if (bluetoothGatt != null) {
      bluetoothGatt.close();
      deviceAddressGattMap.remove(deviceAddress);
    }
  }
}","/** 
 * Disconnect the specified device
 * @param midiOutputDevice the device
 */
void disconnectDevice(MidiOutputDevice midiOutputDevice){
  if (!(midiOutputDevice instanceof jp.kshoji.blemidi.central.MidiOutputDevice)) {
    return;
  }
  disconnectByDeviceAddress(((jp.kshoji.blemidi.central.MidiOutputDevice)midiOutputDevice).getDeviceAddress());
}"
11387,"/** 
 * Constructor
 * @param context
 */
public BleMidiCallback(final Context context){
  super();
  this.context=context;
  this.handler=new Handler(context.getMainLooper());
}","/** 
 * Constructor
 * @param context the context
 */
public BleMidiCallback(final Context context){
  super();
  this.context=context;
  this.handler=new Handler(context.getMainLooper());
}"
11388,"@SuppressLint(""String_Node_Str"") @Override public void onServicesDiscovered(final BluetoothGatt gatt,int status){
  super.onServicesDiscovered(gatt,status);
  if (status != BluetoothGatt.GATT_SUCCESS) {
    return;
  }
  final String gattDeviceAddress=gatt.getDevice().getAddress();
  if (midiInputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.close();
      }
      midiInputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiInputDevice midiInputDevice=null;
  try {
    midiInputDevice=new jp.kshoji.blemidi.central.MidiInputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.i(Constants.TAG,iae.getMessage());
  }
  if (midiInputDevice != null) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      if (midiInputDevices == null) {
        midiInputDevices=new HashSet<>();
        midiInputDevicesMap.put(gattDeviceAddress,midiInputDevices);
      }
      midiInputDevices.add(midiInputDevice);
    }
    if (midiDeviceAttachedListener != null) {
      midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
    }
  }
  if (midiOutputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiOutputDevicesMap) {
      midiOutputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiOutputDevice midiOutputDevice=null;
  try {
    midiOutputDevice=new jp.kshoji.blemidi.central.MidiOutputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.i(Constants.TAG,iae.getMessage());
  }
  if (midiOutputDevice != null) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      if (midiOutputDevices == null) {
        midiOutputDevices=new HashSet<MidiOutputDevice>();
        midiOutputDevicesMap.put(gattDeviceAddress,midiOutputDevices);
      }
      midiOutputDevices.add(midiOutputDevice);
    }
    if (midiDeviceAttachedListener != null) {
      midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
    }
  }
  if (midiInputDevice != null || midiOutputDevice != null) {
synchronized (deviceAddressGattMap) {
      deviceAddressGattMap.put(gattDeviceAddress,gatt);
    }
    BluetoothDevice bluetoothDevice=gatt.getDevice();
    if (bluetoothDevice.getBondState() == BluetoothDevice.BOND_NONE) {
      bluetoothDevice.createBond();
      bluetoothDevice.setPairingConfirmation(true);
      IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
      context.registerReceiver(new BondingBroadcastReceiver(midiInputDevice,midiOutputDevice),filter);
    }
 else {
      if (midiInputDevice != null) {
        ((jp.kshoji.blemidi.central.MidiInputDevice)midiInputDevice).configureAsCentralDevice();
      }
      if (midiOutputDevice != null) {
        ((jp.kshoji.blemidi.central.MidiOutputDevice)midiOutputDevice).configureAsCentralDevice();
      }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      gatt.requestMtu(23);
      gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
    }
  }
}","@SuppressLint(""String_Node_Str"") @Override public void onServicesDiscovered(final BluetoothGatt gatt,int status){
  super.onServicesDiscovered(gatt,status);
  if (status != BluetoothGatt.GATT_SUCCESS) {
    return;
  }
  final String gattDeviceAddress=gatt.getDevice().getAddress();
  if (midiInputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      for (      MidiInputDevice midiInputDevice : midiInputDevices) {
        midiInputDevice.close();
      }
      midiInputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiInputDevice midiInputDevice=null;
  try {
    midiInputDevice=new jp.kshoji.blemidi.central.MidiInputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.i(Constants.TAG,iae.getMessage());
  }
  if (midiInputDevice != null) {
synchronized (midiInputDevicesMap) {
      Set<MidiInputDevice> midiInputDevices=midiInputDevicesMap.get(gattDeviceAddress);
      if (midiInputDevices == null) {
        midiInputDevices=new HashSet<>();
        midiInputDevicesMap.put(gattDeviceAddress,midiInputDevices);
      }
      midiInputDevices.add(midiInputDevice);
    }
    if (!deviceAddressGattMap.containsKey(gattDeviceAddress)) {
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
      }
    }
  }
  if (midiOutputDevicesMap.containsKey(gattDeviceAddress)) {
synchronized (midiOutputDevicesMap) {
      midiOutputDevicesMap.remove(gattDeviceAddress);
    }
  }
  MidiOutputDevice midiOutputDevice=null;
  try {
    midiOutputDevice=new jp.kshoji.blemidi.central.MidiOutputDevice(context,gatt);
  }
 catch (  IllegalArgumentException iae) {
    Log.i(Constants.TAG,iae.getMessage());
  }
  if (midiOutputDevice != null) {
synchronized (midiOutputDevicesMap) {
      Set<MidiOutputDevice> midiOutputDevices=midiOutputDevicesMap.get(gattDeviceAddress);
      if (midiOutputDevices == null) {
        midiOutputDevices=new HashSet<>();
        midiOutputDevicesMap.put(gattDeviceAddress,midiOutputDevices);
      }
      midiOutputDevices.add(midiOutputDevice);
    }
    if (!deviceAddressGattMap.containsKey(gattDeviceAddress)) {
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
      }
    }
  }
  if (midiInputDevice != null || midiOutputDevice != null) {
synchronized (deviceAddressGattMap) {
      deviceAddressGattMap.put(gattDeviceAddress,gatt);
    }
    BluetoothDevice bluetoothDevice=gatt.getDevice();
    if (bluetoothDevice.getBondState() == BluetoothDevice.BOND_NONE) {
      bluetoothDevice.createBond();
      bluetoothDevice.setPairingConfirmation(true);
      IntentFilter filter=new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
      context.registerReceiver(new BondingBroadcastReceiver(midiInputDevice,midiOutputDevice),filter);
    }
 else {
      if (midiInputDevice != null) {
        ((jp.kshoji.blemidi.central.MidiInputDevice)midiInputDevice).configureAsCentralDevice();
      }
      if (midiOutputDevice != null) {
        ((jp.kshoji.blemidi.central.MidiOutputDevice)midiOutputDevice).configureAsCentralDevice();
      }
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      gatt.requestMtu(23);
      gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
    }
  }
}"
11389,"/** 
 * Obtains connected input devices
 * @return Set of {@link jp.kshoji.blemidi.device.MidiInputDevice}
 */
public Set<MidiInputDevice> getMidiInputDevices(){
  Collection<Set<MidiInputDevice>> values=midiInputDevicesMap.values();
  Set<MidiInputDevice> result=new HashSet<MidiInputDevice>();
  for (  Set<MidiInputDevice> value : values) {
    result.addAll(value);
  }
  return Collections.unmodifiableSet(result);
}","/** 
 * Obtains connected input devices
 * @return Set of {@link jp.kshoji.blemidi.device.MidiInputDevice}
 */
public Set<MidiInputDevice> getMidiInputDevices(){
  Collection<Set<MidiInputDevice>> values=midiInputDevicesMap.values();
  Set<MidiInputDevice> result=new HashSet<>();
  for (  Set<MidiInputDevice> value : values) {
    result.addAll(value);
  }
  return Collections.unmodifiableSet(result);
}"
11390,"@Override public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
    final int state=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    Log.i(Constants.TAG,""String_Node_Str"" + state);
    if (state == BluetoothDevice.BOND_BONDED) {
      context.unregisterReceiver(this);
      gattServer.connect(device,true);
      MidiInputDevice midiInputDevice=new jp.kshoji.blemidi.peripheral.MidiInputDevice(device);
      MidiOutputDevice midiOutputDevice=new jp.kshoji.blemidi.peripheral.MidiOutputDevice(device,gattServer,midiCharacteristic);
      String deviceAddress=device.getAddress();
synchronized (midiInputDevicesMap) {
        midiInputDevicesMap.put(deviceAddress,midiInputDevice);
      }
synchronized (midiOutputDevicesMap) {
        midiOutputDevicesMap.put(deviceAddress,midiOutputDevice);
      }
      if (midiDeviceAttachedListener != null) {
        midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
        midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
      }
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  final String action=intent.getAction();
  if (BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(action)) {
    final int state=intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE,BluetoothDevice.ERROR);
    if (state == BluetoothDevice.BOND_BONDED) {
      context.unregisterReceiver(this);
      gattServer.connect(device,true);
      MidiInputDevice midiInputDevice=new jp.kshoji.blemidi.peripheral.MidiInputDevice(device);
      MidiOutputDevice midiOutputDevice=new jp.kshoji.blemidi.peripheral.MidiOutputDevice(device,gattServer,midiCharacteristic);
      String deviceAddress=device.getAddress();
synchronized (midiInputDevicesMap) {
        boolean isNewDevice=midiInputDevicesMap.get(deviceAddress) == null;
        midiInputDevicesMap.put(deviceAddress,midiInputDevice);
        if (isNewDevice) {
          if (midiDeviceAttachedListener != null) {
            midiDeviceAttachedListener.onMidiInputDeviceAttached(midiInputDevice);
          }
        }
      }
synchronized (midiOutputDevicesMap) {
        boolean isNewDevice=midiOutputDevicesMap.get(deviceAddress) == null;
        midiOutputDevicesMap.put(deviceAddress,midiOutputDevice);
        if (isNewDevice) {
          if (midiDeviceAttachedListener != null) {
            midiDeviceAttachedListener.onMidiOutputDeviceAttached(midiOutputDevice);
          }
        }
      }
    }
  }
}"
11391,"private void startAdvertising(){
  AdvertiseSettings advertiseSettings=new AdvertiseSettings.Builder().setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_BALANCED).setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM).setType(AdvertiseSettings.ADVERTISE_TYPE_CONNECTABLE).build();
  List<ParcelUuid> serviceUuids=new ArrayList<ParcelUuid>();
  serviceUuids.add(new ParcelUuid(BleUuidUtils.fromString(""String_Node_Str"")));
  AdvertisementData advertiseData=new AdvertisementData.Builder().setIncludeTxPowerLevel(false).setServiceUuids(serviceUuids).setServiceData(new ParcelUuid(BleUuidUtils.fromString(""String_Node_Str"")),""String_Node_Str"".getBytes()).build();
  bluetoothLeAdvertiser.startAdvertising(advertiseSettings,advertiseData,advertiseCallback);
}","private void startAdvertising(){
  AdvertiseSettings advertiseSettings=new AdvertiseSettings.Builder().setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_BALANCED).setTxPowerLevel(AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM).setConnectable(true).build();
  List<ParcelUuid> serviceUuids=new ArrayList<ParcelUuid>();
  AdvertiseData advertiseData=new AdvertiseData.Builder().setIncludeTxPowerLevel(false).addServiceUuid(new ParcelUuid(BleUuidUtils.fromString(""String_Node_Str""))).build();
  bluetoothLeAdvertiser.startAdvertising(advertiseSettings,advertiseData,advertiseCallback);
}"
11392,"/** 
 * Use this function when your drawing point X touched right end. Copies right rect area to left end and recalculates drawing point X
 * @return	New drawing point X
 */
private int moveTimeLine(){
  int howManyPointInScreen=mViewW / POINT_WIDTH;
  int cutPoint=howManyPointInScreen / GRID_UNIT_SIZE / 3;
  int cutPointX=mCurrentDrawingX - POINT_WIDTH - cutPoint * GRID_UNIT_SIZE * POINT_WIDTH;
  int cutWidth=mBitmap.getWidth() - cutPointX;
  if (cutPointX <= 0 || cutPointX >= cutWidth) {
    mPaint.setColor(0xFFb1b1b1);
    mCanvas.drawLine(0,mViewH / 2,mViewW,mViewH / 2,mPaint);
    mCurrentDrawingX=0;
    return 0;
  }
  Bitmap bCut=Bitmap.createBitmap(mBitmap,cutPointX,0,cutWidth,mViewH);
  mCanvas.drawColor(Color.WHITE);
  mCanvas.drawBitmap(bCut,0,0,null);
  mPaint.setColor(0xFFb1b1b1);
  mCanvas.drawLine(cutPoint * GRID_UNIT_SIZE * POINT_WIDTH,mViewH / 2,mViewW,mViewH / 2,mPaint);
  mCurrentDrawingX=1 + cutPoint * GRID_UNIT_SIZE * POINT_WIDTH;
  bCut=null;
  return cutPoint * GRID_UNIT_SIZE * POINT_WIDTH;
}","/** 
 * Use this function when your drawing point X touched right end. Copies right rect area to left end and recalculates drawing point X
 * @return	New drawing point X
 */
private int moveTimeLine(){
  int howManyPointInScreen=mViewW / POINT_WIDTH;
  int cutPoint=howManyPointInScreen / GRID_UNIT_SIZE / 3;
  int cutPointX=mCurrentDrawingX - POINT_WIDTH - cutPoint * GRID_UNIT_SIZE * POINT_WIDTH;
  int cutWidth=mBitmap.getWidth() - cutPointX;
  if (cutPointX <= 0 || cutPointX + cutWidth >= mBitmap.getWidth()) {
    mCanvas.drawColor(Color.WHITE);
    mPaint.setColor(0xFFb1b1b1);
    mCanvas.drawLine(0,mViewH / 2,mViewW,mViewH / 2,mPaint);
    mCurrentDrawingX=0;
    return 0;
  }
  Bitmap bCut=Bitmap.createBitmap(mBitmap,cutPointX,0,cutWidth,mViewH);
  mCanvas.drawColor(Color.WHITE);
  mCanvas.drawBitmap(bCut,0,0,null);
  mPaint.setColor(0xFFb1b1b1);
  mCanvas.drawLine(cutPoint * GRID_UNIT_SIZE * POINT_WIDTH,mViewH / 2,mViewW,mViewH / 2,mPaint);
  mCurrentDrawingX=1 + cutPoint * GRID_UNIT_SIZE * POINT_WIDTH;
  bCut=null;
  return cutPoint * GRID_UNIT_SIZE * POINT_WIDTH;
}"
11393,"/** 
 * Decorates projects by using   {@link #updateByXml(P,Source)} and saving the configuration,rather than only updating the project in memory.
 * @param project the project to decorate
 * @return the project that was just decorated
 */
@Override public P decorate(P project){
  if (!isProject(project)) {
    return project;
  }
  if (!(getOwner() instanceof TemplateDrivenMultiBranchProject)) {
    throw new IllegalStateException(String.format(""String_Node_Str"",TemplateDrivenBranchProjectFactory.class.getSimpleName(),TemplateDrivenMultiBranchProject.class.getSimpleName()));
  }
  TemplateDrivenMultiBranchProject<P,B> owner=(TemplateDrivenMultiBranchProject<P,B>)getOwner();
  Branch branch=getBranch(project);
  String displayName=project.getDisplayNameOrNull();
  boolean wasDisabled=project.isDisabled();
  BulkChange bc=new BulkChange(project);
  try {
    updateByXml(project,new StreamSource(owner.getTemplate().getConfigFile().readRaw()));
    setBranch(project,branch);
    project.setDisplayName(displayName);
    project.setScm(branch.getScm());
    project.setBuildDiscarder(owner.getTemplate().getBuildDiscarder());
    project.setCustomWorkspace(owner.getTemplate().getCustomWorkspace());
    if (!wasDisabled) {
      project.enable();
    }
    project=super.decorate(project);
    bc.commit();
  }
 catch (  IOException e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"" + project.getName(),e);
  }
 finally {
    bc.abort();
  }
  return project;
}","/** 
 * Decorates projects by using   {@link #updateByXml(AbstractProject,Source)} and saving the configuration,rather than only updating the project in memory.
 * @param project the project to decorate
 * @return the project that was just decorated
 */
@Override public P decorate(P project){
  if (!isProject(project)) {
    return project;
  }
  if (!(getOwner() instanceof TemplateDrivenMultiBranchProject)) {
    throw new IllegalStateException(String.format(""String_Node_Str"",TemplateDrivenBranchProjectFactory.class.getSimpleName(),TemplateDrivenMultiBranchProject.class.getSimpleName()));
  }
  TemplateDrivenMultiBranchProject<P,B> owner=(TemplateDrivenMultiBranchProject<P,B>)getOwner();
  Branch branch=getBranch(project);
  String displayName=project.getDisplayNameOrNull();
  boolean wasDisabled=project.isDisabled();
  BulkChange bc=new BulkChange(project);
  try {
    updateByXml(project,new StreamSource(owner.getTemplate().getConfigFile().readRaw()));
    setBranch(project,branch);
    project.setDisplayName(displayName);
    project.setScm(branch.getScm());
    project.setBuildDiscarder(owner.getTemplate().getBuildDiscarder());
    project.setCustomWorkspace(owner.getTemplate().getCustomWorkspace());
    if (!wasDisabled) {
      project.enable();
    }
    project=super.decorate(project);
    bc.commit();
  }
 catch (  IOException e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"" + project.getName(),e);
  }
 finally {
    bc.abort();
  }
  return project;
}"
11394,"/** 
 * {@inheritDoc}
 */
@Override public void doConfigSubmit(StaplerRequest req,StaplerResponse rsp) throws ServletException, Descriptor.FormException, IOException {
  checkPermission(CONFIGURE);
  description=req.getParameter(""String_Node_Str"");
  boolean keepDependencies=req.getParameter(""String_Node_Str"") != null;
  try {
    Field f=Job.class.getDeclaredField(""String_Node_Str"");
    f.setAccessible(true);
    f.set(templateProject,keepDependencies);
  }
 catch (  Throwable e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",e);
  }
  try {
    JSONObject json=req.getSubmittedForm();
    setDisplayName(json.optString(""String_Node_Str""));
    if (json.optBoolean(""String_Node_Str"")) {
      templateProject.setBuildDiscarder(req.bindJSON(BuildDiscarder.class,json.optJSONObject(""String_Node_Str"")));
    }
 else {
      templateProject.setBuildDiscarder(null);
    }
    DescribableList<JobProperty<?>,JobPropertyDescriptor> t=new DescribableList<JobProperty<?>,JobPropertyDescriptor>(NOOP,getAllProperties());
    t.rebuild(req,json.optJSONObject(""String_Node_Str""),JobPropertyDescriptor.getPropertyDescriptors(this.getClass()));
    templateProject.getPropertiesList().clear();
    for (    JobProperty p : t) {
      try {
        Field f=JobProperty.class.getDeclaredField(""String_Node_Str"");
        f.setAccessible(true);
        f.set(p,templateProject);
      }
 catch (      Throwable e) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",e);
      }
      templateProject.addProperty(p);
    }
    submit(req,rsp);
    templateProject.save();
    save();
    ItemListener.fireOnUpdated(templateProject);
    ItemListener.fireOnUpdated(this);
    String newName=req.getParameter(""String_Node_Str"");
    final ProjectNamingStrategy namingStrategy=Jenkins.getInstance().getProjectNamingStrategy();
    if (newName != null && !newName.equals(name)) {
      Jenkins.checkGoodName(newName);
      namingStrategy.checkName(newName);
      rsp.sendRedirect(""String_Node_Str"" + URLEncoder.encode(newName,""String_Node_Str""));
    }
 else {
      if (namingStrategy.isForceExistingJobs()) {
        namingStrategy.checkName(name);
      }
      FormApply.success(""String_Node_Str"").generateResponse(req,rsp,null);
    }
  }
 catch (  JSONException e) {
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + req.getSubmittedForm());
    pw.println();
    e.printStackTrace(pw);
    rsp.setStatus(SC_BAD_REQUEST);
    sendError(sw.toString(),req,rsp,true);
  }
  updateTransientActions();
  Set<AbstractProject> upstream=Collections.emptySet();
  if (req.getParameter(""String_Node_Str"") != null) {
    upstream=new HashSet<AbstractProject>(Items.fromNameList(getParent(),req.getParameter(""String_Node_Str""),AbstractProject.class));
  }
  try {
    Method m=AbstractProject.class.getDeclaredMethod(""String_Node_Str"",Set.class);
    m.setAccessible(true);
    m.invoke(templateProject,upstream);
  }
 catch (  Throwable e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",e);
  }
  Jenkins.getInstance().getQueue().scheduleMaintenance();
  Jenkins.getInstance().rebuildDependencyGraphAsync();
  getSyncBranchesTrigger().run();
}","/** 
 * {@inheritDoc}
 */
@Override public void doConfigSubmit(StaplerRequest req,StaplerResponse rsp) throws ServletException, Descriptor.FormException, IOException {
  checkPermission(CONFIGURE);
  description=req.getParameter(""String_Node_Str"");
  boolean keepDependencies=req.getParameter(""String_Node_Str"") != null;
  try {
    Field f=Job.class.getDeclaredField(""String_Node_Str"");
    f.setAccessible(true);
    f.set(templateProject,keepDependencies);
  }
 catch (  Throwable e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",e);
  }
  try {
    JSONObject json=req.getSubmittedForm();
    setDisplayName(json.optString(""String_Node_Str""));
    if (json.optBoolean(""String_Node_Str"")) {
      templateProject.setBuildDiscarder(req.bindJSON(BuildDiscarder.class,json.optJSONObject(""String_Node_Str"")));
    }
 else {
      templateProject.setBuildDiscarder(null);
    }
    DescribableList<JobProperty<?>,JobPropertyDescriptor> t=new DescribableList<JobProperty<?>,JobPropertyDescriptor>(NOOP,getAllProperties());
    t.rebuild(req,json.optJSONObject(""String_Node_Str""),JobPropertyDescriptor.getPropertyDescriptors(this.getClass()));
    properties.clear();
    for (    JobProperty p : t) {
      try {
        Field f=JobProperty.class.getDeclaredField(""String_Node_Str"");
        f.setAccessible(true);
        f.set(p,this);
      }
 catch (      Throwable e) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",e);
      }
      properties.add(p);
    }
    DescribableList<JobProperty<?>,JobPropertyDescriptor> t2=new DescribableList<JobProperty<?>,JobPropertyDescriptor>(NOOP,templateProject.getAllProperties());
    t2.rebuild(req,json.optJSONObject(""String_Node_Str""),JobPropertyDescriptor.getPropertyDescriptors(this.getClass()));
    templateProject.getPropertiesList().clear();
    for (    JobProperty p : t2) {
      try {
        Field f=JobProperty.class.getDeclaredField(""String_Node_Str"");
        f.setAccessible(true);
        f.set(p,templateProject);
      }
 catch (      Throwable e) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",e);
      }
      templateProject.addProperty(p);
    }
    submit(req,rsp);
    templateProject.save();
    save();
    ItemListener.fireOnUpdated(templateProject);
    ItemListener.fireOnUpdated(this);
    String newName=req.getParameter(""String_Node_Str"");
    final ProjectNamingStrategy namingStrategy=Jenkins.getInstance().getProjectNamingStrategy();
    if (newName != null && !newName.equals(name)) {
      Jenkins.checkGoodName(newName);
      namingStrategy.checkName(newName);
      rsp.sendRedirect(""String_Node_Str"" + URLEncoder.encode(newName,""String_Node_Str""));
    }
 else {
      if (namingStrategy.isForceExistingJobs()) {
        namingStrategy.checkName(name);
      }
      FormApply.success(""String_Node_Str"").generateResponse(req,rsp,null);
    }
  }
 catch (  JSONException e) {
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"" + req.getSubmittedForm());
    pw.println();
    e.printStackTrace(pw);
    rsp.setStatus(SC_BAD_REQUEST);
    sendError(sw.toString(),req,rsp,true);
  }
  updateTransientActions();
  Set<AbstractProject> upstream=Collections.emptySet();
  if (req.getParameter(""String_Node_Str"") != null) {
    upstream=new HashSet<AbstractProject>(Items.fromNameList(getParent(),req.getParameter(""String_Node_Str""),AbstractProject.class));
  }
  try {
    Method m=AbstractProject.class.getDeclaredMethod(""String_Node_Str"",Set.class);
    m.setAccessible(true);
    m.invoke(templateProject,upstream);
  }
 catch (  Throwable e) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",e);
  }
  Jenkins.getInstance().getQueue().scheduleMaintenance();
  Jenkins.getInstance().rebuildDependencyGraphAsync();
  getSyncBranchesTrigger().run();
}"
11395,"DVEng(IDVSession session,IDVSession.CIPHER_NAME_CONVENTION cipher_name_convention,DVBackgroundTask dvtask) throws DVException {
  try {
    this.session=(MutableDVSession)session;
    this.url=session.getURL();
    dvtask=(dvtask == null) ? new DVBackgroundTask() : dvtask;
    servmeta=CipherSuiteUtil.getServerMetadataInstance(url,cipher_name_convention,this.session,dvtask);
    if (servmeta == null) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      throw new DVException(msg);
    }
    InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
    Properties p=new Properties();
    p.load(is);
    String sVersion=p.getProperty(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + sVersion);
    if (sVersion != null && sVersion.length() > 0) {
      int f1=sVersion.indexOf('.');
      int f2=sVersion.lastIndexOf('.');
      int f3=sVersion.lastIndexOf('-');
      f3=(f3 < 0) ? sVersion.length() : f3;
      if (f3 == -1) {
        bSnapShot=true;
      }
      if (f1 > 0 && f2 > 0) {
        try {
          iVersionMajor=Integer.parseInt(sVersion.substring(0,f1));
          iVersionMinor=Integer.parseInt(sVersion.substring(f1 + 1,f2));
          iVersionBuild=Integer.parseInt(sVersion.substring(f2 + 1,f3));
        }
 catch (        Exception e) {
          iVersionMajor=-1;
          iVersionMinor=-1;
          iVersionBuild=-1;
          String msg=""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3;
          logger.debug(msg);
          throw new DVException(msg);
        }
      }
 else {
        logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
      }
    }
  }
 catch (  DVException e) {
    throw e;
  }
catch (  Exception e) {
    String msg=""String_Node_Str"" + e.getMessage();
    logger.error(msg,e);
    throw new DVException(msg,e);
  }
}","DVEng(IDVSession session,IDVSession.CIPHER_NAME_CONVENTION cipher_name_convention,DVBackgroundTask dvtask) throws DVException {
  try {
    this.session=(MutableDVSession)session;
    this.url=session.getURL();
    dvtask=(dvtask == null) ? new DVBackgroundTask() : dvtask;
    servmeta=CipherSuiteUtil.getServerMetadataInstance(url,cipher_name_convention,this.session,dvtask);
    if (servmeta == null) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      throw new DVException(msg);
    }
    InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
    Properties p=new Properties();
    p.load(is);
    String sVersion=p.getProperty(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + sVersion);
    if (sVersion != null && sVersion.length() > 0) {
      int f1=sVersion.indexOf('.');
      int f2=sVersion.lastIndexOf('.');
      int f3=sVersion.lastIndexOf('-');
      if (f3 == -1) {
        f3=sVersion.length();
      }
 else {
        bSnapShot=true;
      }
      if (f1 > 0 && f2 > 0) {
        try {
          iVersionMajor=Integer.parseInt(sVersion.substring(0,f1));
          iVersionMinor=Integer.parseInt(sVersion.substring(f1 + 1,f2));
          iVersionBuild=Integer.parseInt(sVersion.substring(f2 + 1,f3));
        }
 catch (        Exception e) {
          iVersionMajor=-1;
          iVersionMinor=-1;
          iVersionBuild=-1;
          String msg=""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3;
          logger.debug(msg);
          throw new DVException(msg);
        }
      }
 else {
        logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
      }
    }
  }
 catch (  DVException e) {
    throw e;
  }
catch (  Exception e) {
    String msg=""String_Node_Str"" + e.getMessage();
    logger.error(msg,e);
    throw new DVException(msg,e);
  }
}"
11396,"DVEng(IDVSession session,IDVSession.CIPHER_NAME_CONVENTION cipher_name_convention,DVBackgroundTask dvtask) throws DVException {
  try {
    this.session=(MutableDVSession)session;
    this.url=session.getURL();
    dvtask=(dvtask == null) ? new DVBackgroundTask() : dvtask;
    servmeta=CipherSuiteUtil.getServerMetadataInstance(url,cipher_name_convention,this.session,dvtask);
    if (servmeta == null) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      throw new DVException(msg);
    }
    InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
    Properties p=new Properties();
    p.load(is);
    String sVersion=p.getProperty(""String_Node_Str"");
    if (sVersion != null && sVersion.length() > 0) {
      int f1=sVersion.indexOf('.');
      int f2=sVersion.lastIndexOf('.');
      int f3=sVersion.lastIndexOf('-');
      if (f3 > -1) {
        bSnapShot=true;
      }
      if (f1 > 0 && f2 > 0) {
        try {
          iVersionMajor=Integer.parseInt(sVersion.substring(0,f1));
        }
 catch (        NumberFormatException e) {
          logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
          iVersionMajor=-1;
        }
        try {
          iVersionMinor=Integer.parseInt(sVersion.substring(f1 + 1,f2));
        }
 catch (        NumberFormatException e) {
          logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
          iVersionMinor=-1;
        }
        try {
          iVersionBuild=Integer.parseInt(sVersion.substring(f2 + 1,f3));
        }
 catch (        NumberFormatException e) {
          logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
          iVersionBuild=-1;
        }
      }
 else {
        logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
      }
    }
  }
 catch (  DVException e) {
    throw e;
  }
catch (  Exception e) {
    String msg=""String_Node_Str"" + e.getMessage();
    logger.error(msg,e);
    throw new DVException(msg,e);
  }
}","DVEng(IDVSession session,IDVSession.CIPHER_NAME_CONVENTION cipher_name_convention,DVBackgroundTask dvtask) throws DVException {
  try {
    this.session=(MutableDVSession)session;
    this.url=session.getURL();
    dvtask=(dvtask == null) ? new DVBackgroundTask() : dvtask;
    servmeta=CipherSuiteUtil.getServerMetadataInstance(url,cipher_name_convention,this.session,dvtask);
    if (servmeta == null) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      throw new DVException(msg);
    }
    InputStream is=this.getClass().getClassLoader().getResourceAsStream(""String_Node_Str"");
    Properties p=new Properties();
    p.load(is);
    String sVersion=p.getProperty(""String_Node_Str"");
    logger.debug(""String_Node_Str"" + sVersion);
    if (sVersion != null && sVersion.length() > 0) {
      int f1=sVersion.indexOf('.');
      int f2=sVersion.lastIndexOf('.');
      int f3=sVersion.lastIndexOf('-');
      if (f3 > -1) {
        bSnapShot=true;
      }
      if (f1 > 0 && f2 > 0) {
        try {
          iVersionMajor=Integer.parseInt(sVersion.substring(0,f1));
          iVersionMinor=Integer.parseInt(sVersion.substring(f1 + 1,f2));
          iVersionBuild=Integer.parseInt(sVersion.substring(f2 + 1,f3));
        }
 catch (        Exception e) {
          iVersionMajor=-1;
          iVersionMinor=-1;
          iVersionBuild=-1;
          String msg=""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3;
          logger.debug(msg);
          throw new DVException(msg);
        }
      }
 else {
        logger.debug(""String_Node_Str"" + sVersion + ""String_Node_Str""+ f1+ ""String_Node_Str""+ f2+ ""String_Node_Str""+ f3);
      }
    }
  }
 catch (  DVException e) {
    throw e;
  }
catch (  Exception e) {
    String msg=""String_Node_Str"" + e.getMessage();
    logger.error(msg,e);
    throw new DVException(msg,e);
  }
}"
11397,"private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName() + PRODUCT_SUFFIX,sourceProduct.getProductType(),sourceProduct.getSceneRasterWidth(),sourceProduct.getSceneRasterHeight());
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
  for (  String key : targetMap.keySet()) {
    final List<String> targetBandNames=new ArrayList<>();
    final ProductContainer container=targetMap.get(key);
    final CplxContainer master=container.sourceMaster;
    final CplxContainer slave=container.sourceSlave;
    final String subswath=master.subswath.isEmpty() ? ""String_Node_Str"" : '_' + master.subswath.toUpperCase();
    final String pol=getPolarisationTag(master);
    final String tag=subswath + pol + '_'+ master.date+ '_'+ slave.date;
    final String targetBandName_I=""String_Node_Str"" + productTag + tag;
    final Band iBand=targetProduct.addBand(targetBandName_I,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.REAL,iBand.getName());
    iBand.setUnit(Unit.REAL);
    targetBandNames.add(iBand.getName());
    final String targetBandName_Q=""String_Node_Str"" + productTag + tag;
    final Band qBand=targetProduct.addBand(targetBandName_Q,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.IMAGINARY,qBand.getName());
    qBand.setUnit(Unit.IMAGINARY);
    targetBandNames.add(qBand.getName());
    if (CREATE_VIRTUAL_BAND) {
      final String countStr='_' + productTag + tag;
      ReaderUtils.createVirtualIntensityBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      Band phaseBand=ReaderUtils.createVirtualPhaseBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      targetProduct.setQuicklookBandName(phaseBand.getName());
      targetBandNames.add(phaseBand.getName());
    }
    if (includeCoherence) {
      final String targetBandCoh=""String_Node_Str"" + tag;
      final Band coherenceBand=targetProduct.addBand(targetBandCoh,ProductData.TYPE_FLOAT32);
      coherenceBand.setNoDataValueUsed(true);
      coherenceBand.setNoDataValue(master.realBand.getNoDataValue());
      container.addBand(COHERENCE,coherenceBand.getName());
      coherenceBand.setUnit(Unit.COHERENCE);
      targetBandNames.add(coherenceBand.getName());
    }
    if (subtractTopographicPhase && OUTPUT_PHASE) {
      final String targetBandTgp=""String_Node_Str"" + tag;
      final Band tgpBand=targetProduct.addBand(targetBandTgp,ProductData.TYPE_FLOAT32);
      container.addBand(TOPO_PHASE,tgpBand.getName());
      tgpBand.setUnit(Unit.PHASE);
      targetBandNames.add(tgpBand.getName());
    }
    if (subtractFlatEarthPhase && OUTPUT_PHASE) {
      final String targetBandFep=""String_Node_Str"" + tag;
      final Band fepBand=targetProduct.addBand(targetBandFep,ProductData.TYPE_FLOAT32);
      container.addBand(FLAT_EARTH_PHASE,fepBand.getName());
      fepBand.setUnit(Unit.PHASE);
      targetBandNames.add(fepBand.getName());
    }
    outputElevation=outputElevation && sourceProduct.getBand(""String_Node_Str"") == null;
    if (subtractTopographicPhase && outputElevation) {
      final Band elevBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
      elevBand.setNoDataValueUsed(true);
      elevBand.setNoDataValue(demNoDataValue);
      container.addBand(ELEVATION,elevBand.getName());
      elevBand.setUnit(Unit.METERS);
      targetBandNames.add(elevBand.getName());
    }
    String slvProductName=StackUtils.findOriginalSlaveProductName(sourceProduct,container.sourceSlave.realBand);
    StackUtils.saveSlaveProductBandNames(targetProduct,slvProductName,targetBandNames.toArray(new String[targetBandNames.size()]));
  }
  for (  String bandName : sourceProduct.getBandNames()) {
    if (bandName.startsWith(""String_Node_Str"")) {
      ProductUtils.copyBand(bandName,sourceProduct,targetProduct,true);
    }
  }
}","private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName() + PRODUCT_SUFFIX,sourceProduct.getProductType(),sourceProduct.getSceneRasterWidth(),sourceProduct.getSceneRasterHeight());
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
  for (  String key : targetMap.keySet()) {
    final List<String> targetBandNames=new ArrayList<>();
    final ProductContainer container=targetMap.get(key);
    final CplxContainer master=container.sourceMaster;
    final CplxContainer slave=container.sourceSlave;
    final String subswath=master.subswath.isEmpty() ? ""String_Node_Str"" : '_' + master.subswath.toUpperCase();
    final String pol=getPolarisationTag(master);
    final String tag=subswath + pol + '_'+ master.date+ '_'+ slave.date;
    final String targetBandName_I=""String_Node_Str"" + productTag + tag;
    final Band iBand=targetProduct.addBand(targetBandName_I,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.REAL,iBand.getName());
    iBand.setUnit(Unit.REAL);
    targetBandNames.add(iBand.getName());
    final String targetBandName_Q=""String_Node_Str"" + productTag + tag;
    final Band qBand=targetProduct.addBand(targetBandName_Q,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.IMAGINARY,qBand.getName());
    qBand.setUnit(Unit.IMAGINARY);
    targetBandNames.add(qBand.getName());
    if (CREATE_VIRTUAL_BAND) {
      final String countStr='_' + productTag + tag;
      ReaderUtils.createVirtualIntensityBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      Band phaseBand=ReaderUtils.createVirtualPhaseBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      targetProduct.setQuicklookBandName(phaseBand.getName());
      targetBandNames.add(phaseBand.getName());
    }
    if (includeCoherence) {
      final String targetBandCoh=""String_Node_Str"" + tag;
      final Band coherenceBand=targetProduct.addBand(targetBandCoh,ProductData.TYPE_FLOAT32);
      coherenceBand.setNoDataValueUsed(true);
      coherenceBand.setNoDataValue(master.realBand.getNoDataValue());
      container.addBand(COHERENCE,coherenceBand.getName());
      coherenceBand.setUnit(Unit.COHERENCE);
      targetBandNames.add(coherenceBand.getName());
    }
    if (subtractTopographicPhase && OUTPUT_PHASE) {
      final String targetBandTgp=""String_Node_Str"" + tag;
      final Band tgpBand=targetProduct.addBand(targetBandTgp,ProductData.TYPE_FLOAT32);
      container.addBand(TOPO_PHASE,tgpBand.getName());
      tgpBand.setUnit(Unit.PHASE);
      targetBandNames.add(tgpBand.getName());
    }
    if (subtractFlatEarthPhase && OUTPUT_PHASE) {
      final String targetBandFep=""String_Node_Str"" + tag;
      final Band fepBand=targetProduct.addBand(targetBandFep,ProductData.TYPE_FLOAT32);
      container.addBand(FLAT_EARTH_PHASE,fepBand.getName());
      fepBand.setUnit(Unit.PHASE);
      targetBandNames.add(fepBand.getName());
    }
    if (subtractTopographicPhase && outputElevation && targetProduct.getBand(""String_Node_Str"") == null) {
      final Band elevBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
      elevBand.setNoDataValueUsed(true);
      elevBand.setNoDataValue(demNoDataValue);
      container.addBand(ELEVATION,elevBand.getName());
      elevBand.setUnit(Unit.METERS);
      targetBandNames.add(elevBand.getName());
    }
    String slvProductName=StackUtils.findOriginalSlaveProductName(sourceProduct,container.sourceSlave.realBand);
    StackUtils.saveSlaveProductBandNames(targetProduct,slvProductName,targetBandNames.toArray(new String[targetBandNames.size()]));
  }
  for (  String bandName : sourceProduct.getBandNames()) {
    if (bandName.startsWith(""String_Node_Str"")) {
      ProductUtils.copyBand(bandName,sourceProduct,targetProduct,true);
    }
  }
}"
11398,"private void saveElevation(final int x0,final int xN,final int y0,final int yN,final double[][] elevation,final ProductContainer product,final Map<Band,Tile> targetTileMap){
  final Band elevationBand=targetProduct.getBand(product.getBandName(ELEVATION));
  final Tile elevationTile=targetTileMap.get(elevationBand);
  final ProductData elevationData=elevationTile.getDataBuffer();
  final TileIndex tgtIndex=new TileIndex(elevationTile);
  for (int y=y0; y <= yN; y++) {
    tgtIndex.calculateStride(y);
    final int yy=y - y0;
    for (int x=x0; x <= xN; x++) {
      final int tgtIdx=tgtIndex.getIndex(x);
      final int xx=x - x0;
      elevationData.setElemFloatAt(tgtIdx,(float)elevation[yy][xx]);
    }
  }
}","private void saveElevation(final int x0,final int xN,final int y0,final int yN,final double[][] elevation,final ProductContainer product,final Map<Band,Tile> targetTileMap){
  if (product.getBandName(ELEVATION) == null) {
    return;
  }
  final Band elevationBand=targetProduct.getBand(product.getBandName(ELEVATION));
  final Tile elevationTile=targetTileMap.get(elevationBand);
  final ProductData elevationData=elevationTile.getDataBuffer();
  final TileIndex tgtIndex=new TileIndex(elevationTile);
  for (int y=y0; y <= yN; y++) {
    tgtIndex.calculateStride(y);
    final int yy=y - y0;
    for (int x=x0; x <= xN; x++) {
      final int tgtIdx=tgtIndex.getIndex(x);
      final int xx=x - x0;
      elevationData.setElemFloatAt(tgtIdx,(float)elevation[yy][xx]);
    }
  }
}"
11399,"private void createTiePointGrids(final String swath){
  final ArrayList<MetadataElement[]> geoGrids=new ArrayList<>();
  for (int i=0; i < sliceProducts.length; ++i) {
    MetadataElement[] geoGrid=getGeoGridForSwath(sliceProducts[i],swath);
    geoGrids.add(i,geoGrid);
  }
  final int[] gridWidths=new int[sliceProducts.length];
  final int[] gridHeights=new int[sliceProducts.length];
  for (int j=0; j < sliceProducts.length; j++) {
    gridWidths[j]=0;
    gridHeights[j]=0;
  }
  int gridHeight=0;
  int n=0;
  int ptsInPrvSlices=0;
  for (int i=0; i < sliceProducts.length; i++) {
    final MetadataElement[] geoGrid=geoGrids.get(i);
    for (    MetadataElement ggPoint : geoGrid) {
      final int pixel=(int)ggPoint.getAttributeDouble(""String_Node_Str"",0);
      if (pixel == 0) {
        if (gridWidths[i] == 0) {
          gridWidths[i]=n - ptsInPrvSlices;
        }
        ++gridHeights[i];
      }
      ++n;
    }
    ptsInPrvSlices=n;
    gridHeight+=gridHeights[i];
  }
  final int gridWidth=gridWidths[0];
  for (  int w : gridWidths) {
    if (w != gridWidth) {
      throw new OperatorException(""String_Node_Str"");
    }
  }
  final int newGridWidth=gridWidth;
  final int newGridHeight=gridHeight;
  final float[] latList=new float[newGridWidth * newGridHeight];
  final float[] lonList=new float[newGridWidth * newGridHeight];
  final float[] incList=new float[newGridWidth * newGridHeight];
  final float[] elevList=new float[newGridWidth * newGridHeight];
  final float[] slrtList=new float[newGridWidth * newGridHeight];
  final int[] dim=swathAssembledImageDimMap.get(swath);
  final int sceneRasterWidth=dim[1];
  final int sceneRasterHeight=dim[0];
  final double subSamplingX=(double)sceneRasterWidth / (newGridWidth - 1);
  final double subSamplingY=(double)sceneRasterHeight / (newGridHeight - 1);
  final String prefix=isMultiSwath ? swath + '_' : ""String_Node_Str"";
  final TiePointGrid[] latTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] lonTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] incTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] elevTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] slrtTPG=new TiePointGrid[sliceProducts.length];
  for (int i=0; i < sliceProducts.length; ++i) {
    latTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_LATITUDE);
    lonTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_LONGITUDE);
    incTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_INCIDENT_ANGLE);
    elevTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_ELEVATION_ANGLE);
    slrtTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_SLANT_RANGE_TIME);
  }
  int k=0;
  for (int r=0; r < newGridHeight; ++r) {
    final double y=r * subSamplingY;
    double yy=0.0;
    int sliceIdx=0, heightOffset=0;
    for (int i=0; i < sliceProducts.length; ++i) {
      heightOffset+=sliceSwathImageDimMap.get(sliceProducts[i]).get(swath)[0];
      if (y <= heightOffset) {
        yy=y - heightOffset + sliceSwathImageDimMap.get(sliceProducts[i]).get(swath)[0];
        sliceIdx=i;
        break;
      }
    }
    for (int c=0; c < newGridWidth; ++c) {
      final double x=c * subSamplingX;
      latList[k]=(float)latTPG[sliceIdx].getPixelDouble(x,yy);
      lonList[k]=(float)lonTPG[sliceIdx].getPixelDouble(x,yy);
      incList[k]=(float)incTPG[sliceIdx].getPixelDouble(x,yy);
      elevList[k]=(float)elevTPG[sliceIdx].getPixelDouble(x,yy);
      slrtList[k]=(float)slrtTPG[sliceIdx].getPixelDouble(x,yy);
      k++;
    }
  }
  final TiePointGrid latGrid=new TiePointGrid(prefix + OperatorUtils.TPG_LATITUDE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,latList);
  latGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(latGrid);
  final TiePointGrid lonGrid=new TiePointGrid(prefix + OperatorUtils.TPG_LONGITUDE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,lonList,TiePointGrid.DISCONT_AT_180);
  lonGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(lonGrid);
  final TiePointGrid incidentAngleGrid=new TiePointGrid(prefix + OperatorUtils.TPG_INCIDENT_ANGLE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,incList);
  incidentAngleGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(incidentAngleGrid);
  final TiePointGrid elevAngleGrid=new TiePointGrid(prefix + OperatorUtils.TPG_ELEVATION_ANGLE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,elevList);
  elevAngleGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(elevAngleGrid);
  final TiePointGrid slantRangeGrid=new TiePointGrid(prefix + OperatorUtils.TPG_SLANT_RANGE_TIME,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,slrtList);
  slantRangeGrid.setUnit(Unit.NANOSECONDS);
  targetProduct.addTiePointGrid(slantRangeGrid);
  if (isMultiSwath) {
    final TiePointGeoCoding tpGeoCoding=new TiePointGeoCoding(latGrid,lonGrid);
    swathGeocodingMap.put(swath,tpGeoCoding);
  }
}","private void createTiePointGrids(final String swath){
  final ArrayList<MetadataElement[]> geoGrids=new ArrayList<>();
  for (int i=0; i < sliceProducts.length; ++i) {
    MetadataElement[] geoGrid=getGeoGridForSwath(sliceProducts[i],swath);
    geoGrids.add(i,geoGrid);
  }
  final int[] gridWidths=new int[sliceProducts.length];
  final int[] gridHeights=new int[sliceProducts.length];
  for (int j=0; j < sliceProducts.length; j++) {
    gridWidths[j]=0;
    gridHeights[j]=0;
  }
  int gridHeight=0;
  int n=0;
  int ptsInPrvSlices=0;
  for (int i=0; i < sliceProducts.length; i++) {
    final MetadataElement[] geoGrid=geoGrids.get(i);
    for (    MetadataElement ggPoint : geoGrid) {
      final int pixel=(int)ggPoint.getAttributeDouble(""String_Node_Str"",0);
      if (pixel == 0) {
        if (gridWidths[i] == 0) {
          gridWidths[i]=n - ptsInPrvSlices;
        }
        ++gridHeights[i];
      }
      ++n;
    }
    ptsInPrvSlices=n;
    gridHeight+=gridHeights[i];
  }
  final int gridWidth=gridWidths[0];
  for (  int w : gridWidths) {
    if (w != gridWidth) {
      throw new OperatorException(""String_Node_Str"");
    }
  }
  final int newGridWidth=gridWidth;
  final int newGridHeight=gridHeight;
  final float[] latList=new float[newGridWidth * newGridHeight];
  final float[] lonList=new float[newGridWidth * newGridHeight];
  final float[] incList=new float[newGridWidth * newGridHeight];
  final float[] elevList=new float[newGridWidth * newGridHeight];
  final float[] slrtList=new float[newGridWidth * newGridHeight];
  final int[] dim=swathAssembledImageDimMap.get(swath);
  final int sceneRasterWidth=dim[1];
  final int sceneRasterHeight=dim[0];
  final double subSamplingX=(double)sceneRasterWidth / (newGridWidth - 1);
  final double subSamplingY=(double)sceneRasterHeight / (newGridHeight - 1);
  final String prefix=isMultiSwath ? swath + '_' : ""String_Node_Str"";
  final TiePointGrid[] latTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] lonTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] incTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] elevTPG=new TiePointGrid[sliceProducts.length];
  final TiePointGrid[] slrtTPG=new TiePointGrid[sliceProducts.length];
  for (int i=0; i < sliceProducts.length; ++i) {
    latTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_LATITUDE);
    lonTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_LONGITUDE);
    incTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_INCIDENT_ANGLE);
    elevTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_ELEVATION_ANGLE);
    slrtTPG[i]=sliceProducts[i].getTiePointGrid(prefix + OperatorUtils.TPG_SLANT_RANGE_TIME);
  }
  int k=0;
  for (int r=0; r < newGridHeight; ++r) {
    final double y=r * subSamplingY;
    double yy=0.0;
    int sliceIdx=0, heightOffset=0;
    for (int i=0; i < sliceProducts.length; ++i) {
      heightOffset+=sliceSwathImageDimMap.get(sliceProducts[i]).get(swath)[0];
      if (y <= heightOffset || i == sliceProducts.length - 1) {
        yy=y - heightOffset + sliceSwathImageDimMap.get(sliceProducts[i]).get(swath)[0];
        sliceIdx=i;
        break;
      }
    }
    for (int c=0; c < newGridWidth; ++c) {
      final double x=c * subSamplingX;
      latList[k]=(float)latTPG[sliceIdx].getPixelDouble(x,yy);
      lonList[k]=(float)lonTPG[sliceIdx].getPixelDouble(x,yy);
      incList[k]=(float)incTPG[sliceIdx].getPixelDouble(x,yy);
      elevList[k]=(float)elevTPG[sliceIdx].getPixelDouble(x,yy);
      slrtList[k]=(float)slrtTPG[sliceIdx].getPixelDouble(x,yy);
      k++;
    }
  }
  final TiePointGrid latGrid=new TiePointGrid(prefix + OperatorUtils.TPG_LATITUDE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,latList);
  latGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(latGrid);
  final TiePointGrid lonGrid=new TiePointGrid(prefix + OperatorUtils.TPG_LONGITUDE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,lonList,TiePointGrid.DISCONT_AT_180);
  lonGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(lonGrid);
  final TiePointGrid incidentAngleGrid=new TiePointGrid(prefix + OperatorUtils.TPG_INCIDENT_ANGLE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,incList);
  incidentAngleGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(incidentAngleGrid);
  final TiePointGrid elevAngleGrid=new TiePointGrid(prefix + OperatorUtils.TPG_ELEVATION_ANGLE,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,elevList);
  elevAngleGrid.setUnit(Unit.DEGREES);
  targetProduct.addTiePointGrid(elevAngleGrid);
  final TiePointGrid slantRangeGrid=new TiePointGrid(prefix + OperatorUtils.TPG_SLANT_RANGE_TIME,newGridWidth,newGridHeight,0.5f,0.5f,subSamplingX,subSamplingY,slrtList);
  slantRangeGrid.setUnit(Unit.NANOSECONDS);
  targetProduct.addTiePointGrid(slantRangeGrid);
  if (isMultiSwath) {
    final TiePointGeoCoding tpGeoCoding=new TiePointGeoCoding(latGrid,lonGrid);
    swathGeocodingMap.put(swath,tpGeoCoding);
  }
}"
11400,"private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName() + PRODUCT_SUFFIX,sourceProduct.getProductType(),sourceProduct.getSceneRasterWidth(),sourceProduct.getSceneRasterHeight());
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
  for (  String key : targetMap.keySet()) {
    final List<String> targetBandNames=new ArrayList<>();
    final ProductContainer container=targetMap.get(key);
    final CplxContainer master=container.sourceMaster;
    final CplxContainer slave=container.sourceSlave;
    final String pol=master.polarisation.isEmpty() ? ""String_Node_Str"" : '_' + master.polarisation.toUpperCase();
    final String tag=pol + '_' + master.date+ '_'+ slave.date;
    String targetBandName_I=""String_Node_Str"" + tag;
    Band iBand=targetProduct.addBand(targetBandName_I,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.REAL,iBand.getName());
    iBand.setUnit(Unit.REAL);
    targetBandNames.add(iBand.getName());
    String targetBandName_Q=""String_Node_Str"" + tag;
    Band qBand=targetProduct.addBand(targetBandName_Q,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.IMAGINARY,qBand.getName());
    qBand.setUnit(Unit.IMAGINARY);
    targetBandNames.add(qBand.getName());
    if (CREATE_VIRTUAL_BAND) {
      String countStr=productTag + tag;
      Band intensityBand=ReaderUtils.createVirtualIntensityBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      targetBandNames.add(intensityBand.getName());
      Band phaseBand=ReaderUtils.createVirtualPhaseBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      targetBandNames.add(phaseBand.getName());
      targetProduct.setQuicklookBandName(phaseBand.getName());
    }
    if (container.subProductsFlag) {
      if (outputTopoPhaseBand) {
        String topoBandName=""String_Node_Str"" + tag;
        Band topoBand=targetProduct.addBand(topoBandName,ProductData.TYPE_FLOAT32);
        container.addBand(Unit.PHASE,topoBand.getName());
        topoBand.setNoDataValueUsed(true);
        topoBand.setNoDataValue(0);
        topoBand.setUnit(Unit.PHASE);
        topoBand.setDescription(""String_Node_Str"");
        targetBandNames.add(topoBand.getName());
      }
    }
    for (    Band srcBand : sourceProduct.getBands()) {
      if (srcBand instanceof VirtualBand) {
        continue;
      }
      String srcBandName=srcBand.getName();
      if (srcBandName.endsWith(tag)) {
        if (srcBandName.startsWith(""String_Node_Str"") || srcBandName.startsWith(""String_Node_Str"")) {
          Band band=ProductUtils.copyBand(srcBand.getName(),sourceProduct,targetProduct,true);
          targetBandNames.add(band.getName());
        }
      }
    }
    String slvProductName=StackUtils.findOriginalSlaveProductName(sourceProduct,container.sourceSlave.realBand);
    StackUtils.saveSlaveProductBandNames(targetProduct,slvProductName,targetBandNames.toArray(new String[targetBandNames.size()]));
  }
  if (outputElevationBand) {
    Band elevBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
    elevBand.setNoDataValue(demNoDataValue);
    elevBand.setNoDataValueUsed(true);
    elevBand.setUnit(Unit.METERS);
    elevBand.setDescription(""String_Node_Str"");
  }
}","private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName() + PRODUCT_SUFFIX,sourceProduct.getProductType(),sourceProduct.getSceneRasterWidth(),sourceProduct.getSceneRasterHeight());
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
  for (  String key : targetMap.keySet()) {
    final List<String> targetBandNames=new ArrayList<>();
    final ProductContainer container=targetMap.get(key);
    final CplxContainer master=container.sourceMaster;
    final CplxContainer slave=container.sourceSlave;
    final String pol=(master.polarisation == null || master.polarisation.isEmpty()) ? ""String_Node_Str"" : '_' + master.polarisation.toUpperCase();
    final String tag=pol + '_' + master.date+ '_'+ slave.date;
    String targetBandName_I=""String_Node_Str"" + tag;
    Band iBand=targetProduct.addBand(targetBandName_I,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.REAL,iBand.getName());
    iBand.setUnit(Unit.REAL);
    targetBandNames.add(iBand.getName());
    String targetBandName_Q=""String_Node_Str"" + tag;
    Band qBand=targetProduct.addBand(targetBandName_Q,ProductData.TYPE_FLOAT32);
    container.addBand(Unit.IMAGINARY,qBand.getName());
    qBand.setUnit(Unit.IMAGINARY);
    targetBandNames.add(qBand.getName());
    if (CREATE_VIRTUAL_BAND) {
      String countStr=productTag + tag;
      Band intensityBand=ReaderUtils.createVirtualIntensityBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      targetBandNames.add(intensityBand.getName());
      Band phaseBand=ReaderUtils.createVirtualPhaseBand(targetProduct,targetProduct.getBand(targetBandName_I),targetProduct.getBand(targetBandName_Q),countStr);
      targetBandNames.add(phaseBand.getName());
      targetProduct.setQuicklookBandName(phaseBand.getName());
    }
    if (container.subProductsFlag) {
      if (outputTopoPhaseBand) {
        String topoBandName=""String_Node_Str"" + tag;
        Band topoBand=targetProduct.addBand(topoBandName,ProductData.TYPE_FLOAT32);
        container.addBand(Unit.PHASE,topoBand.getName());
        topoBand.setNoDataValueUsed(true);
        topoBand.setNoDataValue(0);
        topoBand.setUnit(Unit.PHASE);
        topoBand.setDescription(""String_Node_Str"");
        targetBandNames.add(topoBand.getName());
      }
    }
    for (    Band srcBand : sourceProduct.getBands()) {
      if (srcBand instanceof VirtualBand) {
        continue;
      }
      String srcBandName=srcBand.getName();
      if (srcBandName.endsWith(tag)) {
        if (srcBandName.startsWith(""String_Node_Str"") || srcBandName.startsWith(""String_Node_Str"")) {
          Band band=ProductUtils.copyBand(srcBand.getName(),sourceProduct,targetProduct,true);
          targetBandNames.add(band.getName());
        }
      }
    }
    String slvProductName=StackUtils.findOriginalSlaveProductName(sourceProduct,container.sourceSlave.realBand);
    StackUtils.saveSlaveProductBandNames(targetProduct,slvProductName,targetBandNames.toArray(new String[targetBandNames.size()]));
  }
  if (outputElevationBand) {
    Band elevBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
    elevBand.setNoDataValue(demNoDataValue);
    elevBand.setNoDataValueUsed(true);
    elevBand.setUnit(Unit.METERS);
    elevBand.setDescription(""String_Node_Str"");
  }
}"
11401,"private void constructTargetMetadata(){
  for (  String keyMaster : masterMap.keySet()) {
    CplxContainer master=masterMap.get(keyMaster);
    for (    String keySlave : slaveMap.keySet()) {
      final CplxContainer slave=slaveMap.get(keySlave);
      if (master.polarisation.equals(slave.polarisation)) {
        String productName=keyMaster + '_' + keySlave;
        final ProductContainer product=new ProductContainer(productName,master,slave,true);
        targetMap.put(productName,product);
      }
    }
  }
}","private void constructTargetMetadata(){
  for (  String keyMaster : masterMap.keySet()) {
    CplxContainer master=masterMap.get(keyMaster);
    for (    String keySlave : slaveMap.keySet()) {
      final CplxContainer slave=slaveMap.get(keySlave);
      if (master.polarisation == null || master.polarisation.equals(slave.polarisation)) {
        String productName=keyMaster + '_' + keySlave;
        final ProductContainer product=new ProductContainer(productName,master,slave,true);
        targetMap.put(productName,product);
      }
    }
  }
}"
11402,"public static void getBaselines(final Product[] sourceProduct,final Product targetProduct){
  try {
    final MetadataElement abstractedMetadata=AbstractMetadata.getAbstractedMetadata(targetProduct);
    final MetadataElement baselinesElem=getBaselinesElem(abstractedMetadata);
    final InSARStackOverview.IfgStack[] stackOverview=InSARStackOverview.calculateInSAROverview(sourceProduct);
    for (    InSARStackOverview.IfgStack stack : stackOverview) {
      final InSARStackOverview.IfgPair[] slaves=stack.getMasterSlave();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + StackUtils.createBandTimeStamp(slaves[0].getMasterMetadata().getAbstractedMetadata().getProduct()).substring(1));
      final MetadataElement masterElem=new MetadataElement(""String_Node_Str"" + StackUtils.createBandTimeStamp(slaves[0].getMasterMetadata().getAbstractedMetadata().getProduct()).substring(1));
      baselinesElem.addElement(masterElem);
      for (      InSARStackOverview.IfgPair slave : slaves) {
        System.out.println(""String_Node_Str"" + StackUtils.createBandTimeStamp(slave.getSlaveMetadata().getAbstractedMetadata().getProduct()).substring(1) + ""String_Node_Str""+ slave.getPerpendicularBaseline()+ ""String_Node_Str""+ slave.getTemporalBaseline());
        final MetadataElement slaveElem=new MetadataElement(""String_Node_Str"" + StackUtils.createBandTimeStamp(slave.getMasterMetadata().getAbstractedMetadata().getProduct()).substring(1));
        masterElem.addElement(slaveElem);
        addAttrib(slaveElem,""String_Node_Str"",slave.getPerpendicularBaseline());
        addAttrib(slaveElem,""String_Node_Str"",slave.getTemporalBaseline());
        addAttrib(slaveElem,""String_Node_Str"",slave.getCoherence());
        addAttrib(slaveElem,""String_Node_Str"",slave.getHeightAmb());
        addAttrib(slaveElem,""String_Node_Str"",slave.getDopplerDifference());
      }
      System.out.println();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void getBaselines(final Product[] sourceProduct,final Product targetProduct){
  try {
    final MetadataElement abstractedMetadata=AbstractMetadata.getAbstractedMetadata(targetProduct);
    final MetadataElement baselinesElem=getBaselinesElem(abstractedMetadata);
    final InSARStackOverview.IfgStack[] stackOverview=InSARStackOverview.calculateInSAROverview(sourceProduct);
    for (    InSARStackOverview.IfgStack stack : stackOverview) {
      final InSARStackOverview.IfgPair[] slaves=stack.getMasterSlave();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + StackUtils.createBandTimeStamp(slaves[0].getMasterMetadata().getAbstractedMetadata().getProduct()).substring(1));
      final MetadataElement masterElem=new MetadataElement(""String_Node_Str"" + StackUtils.createBandTimeStamp(slaves[0].getMasterMetadata().getAbstractedMetadata().getProduct()).substring(1));
      baselinesElem.addElement(masterElem);
      for (      InSARStackOverview.IfgPair slave : slaves) {
        System.out.println(""String_Node_Str"" + StackUtils.createBandTimeStamp(slave.getSlaveMetadata().getAbstractedMetadata().getProduct()).substring(1) + ""String_Node_Str""+ slave.getPerpendicularBaseline()+ ""String_Node_Str""+ slave.getTemporalBaseline());
        final MetadataElement slaveElem=new MetadataElement(""String_Node_Str"" + StackUtils.createBandTimeStamp(slave.getSlaveMetadata().getAbstractedMetadata().getProduct()).substring(1));
        masterElem.addElement(slaveElem);
        addAttrib(slaveElem,""String_Node_Str"",slave.getPerpendicularBaseline());
        addAttrib(slaveElem,""String_Node_Str"",slave.getTemporalBaseline());
        addAttrib(slaveElem,""String_Node_Str"",slave.getCoherence());
        addAttrib(slaveElem,""String_Node_Str"",slave.getHeightAmb());
        addAttrib(slaveElem,""String_Node_Str"",slave.getDopplerDifference());
      }
      System.out.println();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
11403,"/** 
 * Add user selected bands to target product.
 */
private void addSelectedBands(){
  final Band[] sourceBands=OperatorUtils.getSourceBands(sourceProduct,sourceBandNames,true);
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
  String gamma0BandName, sigma0BandName=null;
  String tgtUnit;
  for (  final Band srcBand : sourceBands) {
    final String srcBandName=srcBand.getName();
    boolean valid=false;
    for (    String validPrefix : BAND_PREFIX) {
      if (srcBandName.startsWith(validPrefix)) {
        valid=true;
        break;
      }
    }
    if (!valid) {
      continue;
    }
    if (isPolSar) {
      if (targetProduct.getBand(srcBandName) == null) {
        Band tgtBand=targetProduct.addBand(srcBandName,ProductData.TYPE_FLOAT32);
        tgtBand.setUnit(srcBand.getUnit());
        tgtBand.setNoDataValue(srcBand.getNoDataValue());
        tgtBand.setNoDataValueUsed(srcBand.isNoDataValueUsed());
        tgtBand.setDescription(srcBand.getDescription());
        targetBandToSourceBandMap.put(tgtBand,srcBand);
      }
    }
 else {
      final String unit=srcBand.getUnit();
      if (unit == null) {
        throw new OperatorException(""String_Node_Str"" + srcBandName + ""String_Node_Str"");
      }
      if (unit.contains(Unit.DB)) {
        throw new OperatorException(""String_Node_Str"");
      }
 else       if (unit.contains(Unit.PHASE)) {
        continue;
      }
 else       if (unit.contains(Unit.REAL) || unit.contains(Unit.IMAGINARY)) {
        gamma0BandName=""String_Node_Str"" + srcBandName;
        tgtUnit=unit;
        if (outputSigma0) {
          sigma0BandName=""String_Node_Str"" + srcBandName;
        }
      }
 else {
        final String pol=OperatorUtils.getBandPolarization(srcBandName,absRoot);
        gamma0BandName=""String_Node_Str"";
        sigma0BandName=""String_Node_Str"";
        if (pol != null && !pol.isEmpty()) {
          gamma0BandName=""String_Node_Str"" + pol.toUpperCase();
          sigma0BandName=""String_Node_Str"" + pol.toUpperCase();
        }
        tgtUnit=Unit.INTENSITY;
      }
      if (targetProduct.getBand(gamma0BandName) == null) {
        Band tgtBand=targetProduct.addBand(gamma0BandName,ProductData.TYPE_FLOAT32);
        tgtBand.setUnit(tgtUnit);
        targetBandToSourceBandMap.put(tgtBand,srcBand);
      }
      if (outputSigma0 && targetProduct.getBand(sigma0BandName) == null) {
        Band tgtBand=targetProduct.addBand(sigma0BandName,ProductData.TYPE_FLOAT32);
        tgtBand.setUnit(tgtUnit);
        targetBandToSourceBandMap.put(tgtBand,srcBand);
      }
    }
  }
  if (targetProduct.getNumBands() == 0) {
    throw new OperatorException(""String_Node_Str"");
  }
  if (outputSimulatedImage) {
    Band tgtBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
    tgtBand.setUnit(""String_Node_Str"");
  }
  targetBands=targetProduct.getBands();
  if (!isPolSar) {
    for (int i=0; i < targetBands.length; ++i) {
      if (targetBands[i].getUnit().equals(Unit.REAL)) {
        final String trgBandName=targetBands[i].getName();
        final int idx=trgBandName.indexOf(""String_Node_Str"");
        String suffix=""String_Node_Str"";
        if (idx != -1) {
          suffix=trgBandName.substring(trgBandName.indexOf(""String_Node_Str""));
        }
        ReaderUtils.createVirtualIntensityBand(targetProduct,targetBands[i],targetBands[i + 1],""String_Node_Str"",suffix);
      }
    }
  }
}","/** 
 * Add user selected bands to target product.
 */
private void addSelectedBands(){
  final Band[] sourceBands=OperatorUtils.getSourceBands(sourceProduct,sourceBandNames,true);
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
  String gamma0BandName, sigma0BandName=null;
  String tgtUnit;
  for (  final Band srcBand : sourceBands) {
    final String srcBandName=srcBand.getName();
    boolean valid=false;
    for (    String validPrefix : BAND_PREFIX) {
      if (srcBandName.startsWith(validPrefix)) {
        valid=true;
        break;
      }
    }
    if (!valid) {
      continue;
    }
    if (isPolSar) {
      if (targetProduct.getBand(srcBandName) == null) {
        Band tgtBand=targetProduct.addBand(srcBandName,ProductData.TYPE_FLOAT32);
        tgtBand.setUnit(srcBand.getUnit());
        tgtBand.setNoDataValue(srcBand.getNoDataValue());
        tgtBand.setNoDataValueUsed(srcBand.isNoDataValueUsed());
        tgtBand.setDescription(srcBand.getDescription());
        targetBandToSourceBandMap.put(tgtBand,srcBand);
      }
    }
 else {
      final String unit=srcBand.getUnit();
      if (unit == null) {
        throw new OperatorException(""String_Node_Str"" + srcBandName + ""String_Node_Str"");
      }
      if (unit.contains(Unit.DB)) {
        throw new OperatorException(""String_Node_Str"");
      }
 else       if (unit.contains(Unit.PHASE)) {
        continue;
      }
 else       if (unit.contains(Unit.REAL) || unit.contains(Unit.IMAGINARY)) {
        gamma0BandName=""String_Node_Str"" + srcBandName;
        tgtUnit=unit;
        if (outputSigma0) {
          sigma0BandName=""String_Node_Str"" + srcBandName;
        }
      }
 else {
        gamma0BandName=srcBandName.replaceFirst(""String_Node_Str"",""String_Node_Str"");
        sigma0BandName=srcBandName.replaceFirst(""String_Node_Str"",""String_Node_Str"");
        tgtUnit=Unit.INTENSITY;
      }
      if (targetProduct.getBand(gamma0BandName) == null) {
        Band tgtBand=targetProduct.addBand(gamma0BandName,ProductData.TYPE_FLOAT32);
        tgtBand.setUnit(tgtUnit);
        targetBandToSourceBandMap.put(tgtBand,srcBand);
      }
      if (outputSigma0 && targetProduct.getBand(sigma0BandName) == null) {
        Band tgtBand=targetProduct.addBand(sigma0BandName,ProductData.TYPE_FLOAT32);
        tgtBand.setUnit(tgtUnit);
        targetBandToSourceBandMap.put(tgtBand,srcBand);
      }
    }
  }
  if (targetProduct.getNumBands() == 0) {
    throw new OperatorException(""String_Node_Str"");
  }
  if (outputSimulatedImage) {
    Band tgtBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
    tgtBand.setUnit(""String_Node_Str"");
  }
  targetBands=targetProduct.getBands();
  if (!isPolSar) {
    for (int i=0; i < targetBands.length; ++i) {
      if (targetBands[i].getUnit().equals(Unit.REAL)) {
        final String trgBandName=targetBands[i].getName();
        final int idx=trgBandName.indexOf(""String_Node_Str"");
        String suffix=""String_Node_Str"";
        if (idx != -1) {
          suffix=trgBandName.substring(trgBandName.indexOf(""String_Node_Str""));
        }
        ReaderUtils.createVirtualIntensityBand(targetProduct,targetBands[i],targetBands[i + 1],""String_Node_Str"",suffix);
      }
    }
  }
}"
11404,"/** 
 * Compute final cluster centers for all clusters using K-mean clustering method
 * @param srcBandList    the input bands
 * @param tileRectangles Array of rectangles for all source tiles of the image
 * @param op             the operator
 */
private void computeFinalTerrainClusterCenters(final double[][] fdd,final java.util.List<ClusterInfo> pvCenterList,final java.util.List<ClusterInfo> pdCenterList,final java.util.List<ClusterInfo> psCenterList,final PolBandUtils.PolSourceBand srcBandList,final Rectangle[] tileRectangles,final PolarimetricClassificationOp op){
  boolean endIteration=false;
  final StatusProgressMonitor status=new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
  status.beginTask(""String_Node_Str"",tileRectangles.length * maxIterations);
  final int pvNumClusters=pvCenterList.size();
  final int pdNumClusters=pdCenterList.size();
  final int psNumClusters=psCenterList.size();
  final int maxNumClusters=Math.max(pvNumClusters,Math.max(pdNumClusters,psNumClusters));
  final int[][] clusterCounter=new int[3][maxNumClusters];
  final ThreadManager threadManager=new ThreadManager();
  try {
    for (int it=0; (it < maxIterations && !endIteration); ++it) {
      final double[][][] pvSumRe=new double[pvNumClusters][3][3];
      final double[][][] pvSumIm=new double[pvNumClusters][3][3];
      final double[][][] pdSumRe=new double[pdNumClusters][3][3];
      final double[][][] pdSumIm=new double[pdNumClusters][3][3];
      final double[][][] psSumRe=new double[psNumClusters][3][3];
      final double[][][] psSumIm=new double[psNumClusters][3][3];
      java.util.Arrays.fill(clusterCounter[0],0);
      java.util.Arrays.fill(clusterCounter[1],0);
      java.util.Arrays.fill(clusterCounter[2],0);
      for (      final Rectangle rectangle : tileRectangles) {
        final Thread worker=new Thread(){
          final Tile[] sourceTiles=new Tile[srcBandList.srcBands.length];
          final ProductData[] dataBuffers=new ProductData[srcBandList.srcBands.length];
          final double[][] Tr=new double[3][3];
          final double[][] Ti=new double[3][3];
          @Override public void run(){
            op.checkIfCancelled();
            final int x0=rectangle.x;
            final int y0=rectangle.y;
            final int w=rectangle.width;
            final int h=rectangle.height;
            final int xMax=x0 + w;
            final int yMax=y0 + h;
            final Rectangle sourceRectangle=getSourceRectangle(x0,y0,w,h);
            for (int i=0; i < sourceTiles.length; ++i) {
              sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],sourceRectangle);
              dataBuffers[i]=sourceTiles[i].getDataBuffer();
            }
            final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
            for (int y=y0; y < yMax; ++y) {
              for (int x=x0; x < xMax; ++x) {
                PolOpUtils.getMeanCoherencyMatrix(x,y,halfWindowSizeX,halfWindowSizeY,srcWidth,srcHeight,sourceProductType,srcIndex,dataBuffers,Tr,Ti);
                int clusterIdx;
synchronized (clusterCounter) {
                  if (mask[y][x] < -64) {
                    clusterIdx=findClosestCluster(Tr,Ti,pvCenterList);
                    computeSummationOfT3(clusterIdx + 1,Tr,Ti,pvSumRe,pvSumIm);
                    clusterCounter[0][clusterIdx]+=1;
                    mask[y][x]=(byte)(-128 + clusterIdx);
                  }
 else                   if (mask[y][x] < 0) {
                    clusterIdx=findClosestCluster(Tr,Ti,pdCenterList);
                    computeSummationOfT3(clusterIdx + 1,Tr,Ti,pdSumRe,pdSumIm);
                    clusterCounter[1][clusterIdx]+=1;
                    mask[y][x]=(byte)(-64 + clusterIdx);
                  }
 else                   if (mask[y][x] < 64) {
                    clusterIdx=findClosestCluster(Tr,Ti,psCenterList);
                    computeSummationOfT3(clusterIdx + 1,Tr,Ti,psSumRe,psSumIm);
                    clusterCounter[2][clusterIdx]+=1;
                    mask[y][x]=(byte)clusterIdx;
                  }
 else {
                    java.util.List<ClusterInfo> allCenterList=new ArrayList<>();
                    allCenterList.addAll(pvCenterList);
                    allCenterList.addAll(pdCenterList);
                    allCenterList.addAll(psCenterList);
                    clusterIdx=findClosestCluster(Tr,Ti,allCenterList);
                    if (clusterIdx >= pvNumClusters + pdNumClusters) {
                      clusterIdx-=pvNumClusters + pdNumClusters;
                      computeSummationOfT3(clusterIdx + 1,Tr,Ti,psSumRe,psSumIm);
                      clusterCounter[2][clusterIdx]+=1;
                      mask[y][x]=(byte)clusterIdx;
                    }
 else                     if (clusterIdx >= pvNumClusters) {
                      clusterIdx-=pvNumClusters;
                      computeSummationOfT3(clusterIdx + 1,Tr,Ti,pdSumRe,pdSumIm);
                      clusterCounter[1][clusterIdx]+=1;
                      mask[y][x]=(byte)(-64 + clusterIdx);
                    }
 else {
                      computeSummationOfT3(clusterIdx + 1,Tr,Ti,pvSumRe,pvSumIm);
                      clusterCounter[0][clusterIdx]+=1;
                      mask[y][x]=(byte)(-128 + clusterIdx);
                    }
                  }
                }
              }
            }
          }
        }
;
        threadManager.add(worker);
        status.worked(1);
      }
      threadManager.finish();
      updateClusterCenter(pvCenterList,clusterCounter[0],pvSumRe,pvSumIm);
      updateClusterCenter(pdCenterList,clusterCounter[1],pdSumRe,pdSumIm);
      updateClusterCenter(psCenterList,clusterCounter[2],psSumRe,psSumIm);
    }
    final double[] pvAvgClusterPower=new double[pvNumClusters];
    final double[] pdAvgClusterPower=new double[pdNumClusters];
    final double[] psAvgClusterPower=new double[psNumClusters];
    int clusterIdx=-1;
    for (int y=0; y < srcHeight; y++) {
      for (int x=0; x < srcWidth; x++) {
        if (mask[y][x] < -64) {
          clusterIdx=mask[y][x] + 128;
          pvAvgClusterPower[clusterIdx]+=fdd[y][x];
        }
 else         if (mask[y][x] < 0) {
          clusterIdx=mask[y][x] + 64;
          pdAvgClusterPower[clusterIdx]+=fdd[y][x];
        }
 else {
          clusterIdx=mask[y][x];
          psAvgClusterPower[clusterIdx]+=fdd[y][x];
        }
      }
    }
    for (int c=0; c < pvNumClusters; c++) {
      pvAvgClusterPower[c]/=clusterCounter[0][c];
    }
    for (int c=0; c < pdNumClusters; c++) {
      pdAvgClusterPower[c]/=clusterCounter[1][c];
    }
    for (int c=0; c < psNumClusters; c++) {
      psAvgClusterPower[c]/=clusterCounter[2][c];
    }
    pvColourIndexMap=new int[pvNumClusters];
    pdColourIndexMap=new int[pdNumClusters];
    psColourIndexMap=new int[psNumClusters];
    for (int c=0; c < pvNumClusters; c++) {
      pvColourIndexMap[c]=numInitialClusters + getColourIndex(c,pvAvgClusterPower,numInitialClusters) + 1;
    }
    for (int c=0; c < pdNumClusters; c++) {
      pdColourIndexMap[c]=2 * numInitialClusters + getColourIndex(c,pdAvgClusterPower,numInitialClusters) + 1;
    }
    for (int c=0; c < psNumClusters; c++) {
      psColourIndexMap[c]=getColourIndex(c,psAvgClusterPower,numInitialClusters) + 1;
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(op.getId() + ""String_Node_Str"",e);
  }
 finally {
    status.done();
  }
}","/** 
 * Compute final cluster centers for all clusters using K-mean clustering method
 * @param srcBandList    the input bands
 * @param tileRectangles Array of rectangles for all source tiles of the image
 * @param op             the operator
 */
private void computeFinalTerrainClusterCenters(final double[][] fdd,final java.util.List<ClusterInfo> pvCenterList,final java.util.List<ClusterInfo> pdCenterList,final java.util.List<ClusterInfo> psCenterList,final PolBandUtils.PolSourceBand srcBandList,final Rectangle[] tileRectangles,final PolarimetricClassificationOp op){
  boolean endIteration=false;
  final StatusProgressMonitor status=new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
  status.beginTask(""String_Node_Str"",tileRectangles.length * maxIterations);
  final int pvNumClusters=pvCenterList.size();
  final int pdNumClusters=pdCenterList.size();
  final int psNumClusters=psCenterList.size();
  final int maxNumClusters=Math.max(pvNumClusters,Math.max(pdNumClusters,psNumClusters));
  final int[][] clusterCounter=new int[3][maxNumClusters];
  final ThreadManager threadManager=new ThreadManager();
  try {
    for (int it=0; (it < maxIterations && !endIteration); ++it) {
      final double[][][] pvSumRe=new double[pvNumClusters][3][3];
      final double[][][] pvSumIm=new double[pvNumClusters][3][3];
      final double[][][] pdSumRe=new double[pdNumClusters][3][3];
      final double[][][] pdSumIm=new double[pdNumClusters][3][3];
      final double[][][] psSumRe=new double[psNumClusters][3][3];
      final double[][][] psSumIm=new double[psNumClusters][3][3];
      java.util.Arrays.fill(clusterCounter[0],0);
      java.util.Arrays.fill(clusterCounter[1],0);
      java.util.Arrays.fill(clusterCounter[2],0);
      for (      final Rectangle rectangle : tileRectangles) {
        final Thread worker=new Thread(){
          final Tile[] sourceTiles=new Tile[srcBandList.srcBands.length];
          final ProductData[] dataBuffers=new ProductData[srcBandList.srcBands.length];
          final double[][] Tr=new double[3][3];
          final double[][] Ti=new double[3][3];
          @Override public void run(){
            op.checkIfCancelled();
            final int x0=rectangle.x;
            final int y0=rectangle.y;
            final int w=rectangle.width;
            final int h=rectangle.height;
            final int xMax=x0 + w;
            final int yMax=y0 + h;
            final Rectangle sourceRectangle=getSourceRectangle(x0,y0,w,h);
            for (int i=0; i < sourceTiles.length; ++i) {
              sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],sourceRectangle);
              dataBuffers[i]=sourceTiles[i].getDataBuffer();
            }
            final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
            for (int y=y0; y < yMax; ++y) {
              for (int x=x0; x < xMax; ++x) {
                PolOpUtils.getMeanCoherencyMatrix(x,y,halfWindowSizeX,halfWindowSizeY,srcWidth,srcHeight,sourceProductType,srcIndex,dataBuffers,Tr,Ti);
synchronized (clusterCounter) {
                  if (category[y][x] == Categories.vol) {
                    cluster[y][x]=findClosestCluster(Tr,Ti,pvCenterList);
                    computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pvSumRe,pvSumIm);
                    clusterCounter[0][cluster[y][x]]+=1;
                  }
 else                   if (category[y][x] == Categories.dbl) {
                    cluster[y][x]=findClosestCluster(Tr,Ti,pdCenterList);
                    computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pdSumRe,pdSumIm);
                    clusterCounter[1][cluster[y][x]]+=1;
                  }
 else                   if (category[y][x] == Categories.suf) {
                    cluster[y][x]=findClosestCluster(Tr,Ti,psCenterList);
                    computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,psSumRe,psSumIm);
                    clusterCounter[2][cluster[y][x]]+=1;
                  }
 else {
                    final int nearestPvCluster=findClosestCluster(Tr,Ti,pvCenterList);
                    final int nearestPdCluster=findClosestCluster(Tr,Ti,pdCenterList);
                    final int nearestPsCluster=findClosestCluster(Tr,Ti,psCenterList);
                    final double dPv=HAlphaWishart.computeWishartDistance(Tr,Ti,pvCenterList.get(nearestPvCluster));
                    final double dPd=HAlphaWishart.computeWishartDistance(Tr,Ti,pdCenterList.get(nearestPdCluster));
                    final double dPs=HAlphaWishart.computeWishartDistance(Tr,Ti,psCenterList.get(nearestPsCluster));
                    if (dPv <= dPd && dPv <= dPs) {
                      cluster[y][x]=nearestPvCluster;
                      computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pvSumRe,pvSumIm);
                      clusterCounter[0][cluster[y][x]]+=1;
                      category[y][x]=Categories.vol;
                    }
 else                     if (dPd <= dPv && dPd <= dPs) {
                      cluster[y][x]=nearestPdCluster;
                      computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pdSumRe,pdSumIm);
                      clusterCounter[1][cluster[y][x]]+=1;
                      category[y][x]=Categories.dbl;
                    }
 else {
                      cluster[y][x]=nearestPsCluster;
                      computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,psSumRe,psSumIm);
                      clusterCounter[2][cluster[y][x]]+=1;
                      category[y][x]=Categories.suf;
                    }
                  }
                }
              }
            }
          }
        }
;
        threadManager.add(worker);
        status.worked(1);
      }
      threadManager.finish();
      updateClusterCenter(pvCenterList,clusterCounter[0],pvSumRe,pvSumIm);
      updateClusterCenter(pdCenterList,clusterCounter[1],pdSumRe,pdSumIm);
      updateClusterCenter(psCenterList,clusterCounter[2],psSumRe,psSumIm);
    }
    final double[] pvAvgClusterPower=new double[pvNumClusters];
    final double[] pdAvgClusterPower=new double[pdNumClusters];
    final double[] psAvgClusterPower=new double[psNumClusters];
    for (int y=0; y < srcHeight; y++) {
      for (int x=0; x < srcWidth; x++) {
        if (category[y][x] == Categories.vol) {
          pvAvgClusterPower[cluster[y][x]]+=fdd[y][x];
        }
 else         if (category[y][x] == Categories.dbl) {
          pdAvgClusterPower[cluster[y][x]]+=fdd[y][x];
        }
 else {
          psAvgClusterPower[cluster[y][x]]+=fdd[y][x];
        }
      }
    }
    for (int c=0; c < pvNumClusters; c++) {
      pvAvgClusterPower[c]/=clusterCounter[0][c];
    }
    for (int c=0; c < pdNumClusters; c++) {
      pdAvgClusterPower[c]/=clusterCounter[1][c];
    }
    for (int c=0; c < psNumClusters; c++) {
      psAvgClusterPower[c]/=clusterCounter[2][c];
    }
    pvColourIndexMap=new int[pvNumClusters];
    pdColourIndexMap=new int[pdNumClusters];
    psColourIndexMap=new int[psNumClusters];
    for (int c=0; c < pvNumClusters; c++) {
      pvColourIndexMap[c]=numInitialClusters + getColourIndex(c,pvAvgClusterPower,numInitialClusters) + 1;
    }
    for (int c=0; c < pdNumClusters; c++) {
      pdColourIndexMap[c]=2 * numInitialClusters + getColourIndex(c,pdAvgClusterPower,numInitialClusters) + 1;
    }
    for (int c=0; c < psNumClusters; c++) {
      psColourIndexMap[c]=getColourIndex(c,psAvgClusterPower,numInitialClusters) + 1;
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(op.getId() + ""String_Node_Str"",e);
  }
 finally {
    status.done();
  }
}"
11405,"/** 
 * Compute the centers of the 90 clusters in the 3 categories.
 * @param srcBandList    the input bands
 * @param tileRectangles Array of rectangles for all source tiles of the image
 * @param op             the operator
 */
private void getClusterCenters(final java.util.List<ClusterInfo> pvCenterList,final java.util.List<ClusterInfo> pdCenterList,final java.util.List<ClusterInfo> psCenterList,final PolBandUtils.PolSourceBand srcBandList,final Rectangle[] tileRectangles,final PolarimetricClassificationOp op){
  final StatusProgressMonitor status=new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
  status.beginTask(""String_Node_Str"",tileRectangles.length);
  final ThreadManager threadManager=new ThreadManager();
  final double[][][] pvSumRe=new double[numInitialClusters][3][3];
  final double[][][] pvSumIm=new double[numInitialClusters][3][3];
  final double[][][] pdSumRe=new double[numInitialClusters][3][3];
  final double[][][] pdSumIm=new double[numInitialClusters][3][3];
  final double[][][] psSumRe=new double[numInitialClusters][3][3];
  final double[][][] psSumIm=new double[numInitialClusters][3][3];
  final int[][] clusterCounter=new int[3][numInitialClusters];
  try {
    for (    final Rectangle rectangle : tileRectangles) {
      op.checkIfCancelled();
      final Thread worker=new Thread(){
        final Tile[] sourceTiles=new Tile[srcBandList.srcBands.length];
        final ProductData[] dataBuffers=new ProductData[srcBandList.srcBands.length];
        final double[][] Sr=new double[2][2];
        final double[][] Si=new double[2][2];
        final double[][] Tr=new double[3][3];
        final double[][] Ti=new double[3][3];
        @Override public void run(){
          final int x0=rectangle.x;
          final int y0=rectangle.y;
          final int w=rectangle.width;
          final int h=rectangle.height;
          final int xMax=x0 + w;
          final int yMax=y0 + h;
          for (int i=0; i < sourceTiles.length; ++i) {
            sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],rectangle);
            dataBuffers[i]=sourceTiles[i].getDataBuffer();
          }
          final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
          for (int y=y0; y < yMax; ++y) {
            srcIndex.calculateStride(y);
            for (int x=x0; x < xMax; ++x) {
              PolOpUtils.getCoherencyMatrixT3(srcIndex.getIndex(x),sourceProductType,dataBuffers,Tr,Ti);
synchronized (clusterCounter) {
                int clusterIdx;
                if (mask[y][x] < -64) {
                  clusterIdx=mask[y][x] + 128;
                  computeSummationOfT3(clusterIdx + 1,Tr,Ti,pvSumRe,pvSumIm);
                  clusterCounter[0][clusterIdx]++;
                }
 else                 if (mask[y][x] < 0) {
                  clusterIdx=mask[y][x] + 64;
                  computeSummationOfT3(clusterIdx + 1,Tr,Ti,pdSumRe,pdSumIm);
                  clusterCounter[1][clusterIdx]++;
                }
 else                 if (mask[y][x] < 64) {
                  clusterIdx=mask[y][x];
                  computeSummationOfT3(clusterIdx + 1,Tr,Ti,psSumRe,psSumIm);
                  clusterCounter[2][clusterIdx]++;
                }
              }
            }
          }
        }
      }
;
      threadManager.add(worker);
      status.worked(1);
    }
    threadManager.finish();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(op.getId() + ""String_Node_Str"",e);
  }
 finally {
    status.done();
  }
  for (int c=0; c < numInitialClusters; c++) {
    double[][] centerRe=new double[3][3];
    double[][] centerIm=new double[3][3];
    if (clusterCounter[0][c] > 0) {
      for (int i=0; i < 3; i++) {
        for (int j=0; j < 3; j++) {
          centerRe[i][j]=pvSumRe[c][i][j] / clusterCounter[0][c];
          centerIm[i][j]=pvSumIm[c][i][j] / clusterCounter[0][c];
        }
      }
      ClusterInfo clusterCenter=new ClusterInfo();
      clusterCenter.setClusterCenter(c,centerRe,centerIm,clusterCounter[0][c]);
      pvCenterList.add(clusterCenter);
    }
    if (clusterCounter[1][c] > 0) {
      for (int i=0; i < 3; i++) {
        for (int j=0; j < 3; j++) {
          centerRe[i][j]=pdSumRe[c][i][j] / clusterCounter[1][c];
          centerIm[i][j]=pdSumIm[c][i][j] / clusterCounter[1][c];
        }
      }
      ClusterInfo clusterCenter=new ClusterInfo();
      clusterCenter.setClusterCenter(c,centerRe,centerIm,clusterCounter[1][c]);
      pdCenterList.add(clusterCenter);
    }
    if (clusterCounter[2][c] > 0) {
      for (int i=0; i < 3; i++) {
        for (int j=0; j < 3; j++) {
          centerRe[i][j]=psSumRe[c][i][j] / clusterCounter[2][c];
          centerIm[i][j]=psSumIm[c][i][j] / clusterCounter[2][c];
        }
      }
      ClusterInfo clusterCenter=new ClusterInfo();
      clusterCenter.setClusterCenter(c,centerRe,centerIm,clusterCounter[2][c]);
      psCenterList.add(clusterCenter);
    }
  }
}","/** 
 * Compute the centers of the 90 clusters in the 3 categories.
 * @param srcBandList    the input bands
 * @param tileRectangles Array of rectangles for all source tiles of the image
 * @param op             the operator
 */
private void getClusterCenters(final java.util.List<ClusterInfo> pvCenterList,final java.util.List<ClusterInfo> pdCenterList,final java.util.List<ClusterInfo> psCenterList,final PolBandUtils.PolSourceBand srcBandList,final Rectangle[] tileRectangles,final PolarimetricClassificationOp op){
  final StatusProgressMonitor status=new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
  status.beginTask(""String_Node_Str"",tileRectangles.length);
  final ThreadManager threadManager=new ThreadManager();
  final double[][][] pvSumRe=new double[numInitialClusters][3][3];
  final double[][][] pvSumIm=new double[numInitialClusters][3][3];
  final double[][][] pdSumRe=new double[numInitialClusters][3][3];
  final double[][][] pdSumIm=new double[numInitialClusters][3][3];
  final double[][][] psSumRe=new double[numInitialClusters][3][3];
  final double[][][] psSumIm=new double[numInitialClusters][3][3];
  final int[][] clusterCounter=new int[3][numInitialClusters];
  try {
    for (    final Rectangle rectangle : tileRectangles) {
      op.checkIfCancelled();
      final Thread worker=new Thread(){
        final Tile[] sourceTiles=new Tile[srcBandList.srcBands.length];
        final ProductData[] dataBuffers=new ProductData[srcBandList.srcBands.length];
        final double[][] Tr=new double[3][3];
        final double[][] Ti=new double[3][3];
        @Override public void run(){
          final int x0=rectangle.x;
          final int y0=rectangle.y;
          final int w=rectangle.width;
          final int h=rectangle.height;
          final int xMax=x0 + w;
          final int yMax=y0 + h;
          for (int i=0; i < sourceTiles.length; ++i) {
            sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],rectangle);
            dataBuffers[i]=sourceTiles[i].getDataBuffer();
          }
          final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
          for (int y=y0; y < yMax; ++y) {
            srcIndex.calculateStride(y);
            for (int x=x0; x < xMax; ++x) {
              PolOpUtils.getCoherencyMatrixT3(srcIndex.getIndex(x),sourceProductType,dataBuffers,Tr,Ti);
synchronized (clusterCounter) {
                if (category[y][x] == Categories.vol) {
                  computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pvSumRe,pvSumIm);
                  clusterCounter[0][cluster[y][x]]++;
                }
 else                 if (category[y][x] == Categories.dbl) {
                  computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pdSumRe,pdSumIm);
                  clusterCounter[1][cluster[y][x]]++;
                }
 else                 if (category[y][x] == Categories.suf) {
                  computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,psSumRe,psSumIm);
                  clusterCounter[2][cluster[y][x]]++;
                }
              }
            }
          }
        }
      }
;
      threadManager.add(worker);
      status.worked(1);
    }
    threadManager.finish();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(op.getId() + ""String_Node_Str"",e);
  }
 finally {
    status.done();
  }
  for (int c=0; c < numInitialClusters; c++) {
    double[][] centerRe=new double[3][3];
    double[][] centerIm=new double[3][3];
    if (clusterCounter[0][c] > 0) {
      for (int i=0; i < 3; i++) {
        for (int j=0; j < 3; j++) {
          centerRe[i][j]=pvSumRe[c][i][j] / clusterCounter[0][c];
          centerIm[i][j]=pvSumIm[c][i][j] / clusterCounter[0][c];
        }
      }
      ClusterInfo clusterCenter=new ClusterInfo();
      clusterCenter.setClusterCenter(c,centerRe,centerIm,clusterCounter[0][c]);
      pvCenterList.add(clusterCenter);
    }
    if (clusterCounter[1][c] > 0) {
      for (int i=0; i < 3; i++) {
        for (int j=0; j < 3; j++) {
          centerRe[i][j]=pdSumRe[c][i][j] / clusterCounter[1][c];
          centerIm[i][j]=pdSumIm[c][i][j] / clusterCounter[1][c];
        }
      }
      ClusterInfo clusterCenter=new ClusterInfo();
      clusterCenter.setClusterCenter(c,centerRe,centerIm,clusterCounter[1][c]);
      pdCenterList.add(clusterCenter);
    }
    if (clusterCounter[2][c] > 0) {
      for (int i=0; i < 3; i++) {
        for (int j=0; j < 3; j++) {
          centerRe[i][j]=psSumRe[c][i][j] / clusterCounter[2][c];
          centerIm[i][j]=psSumIm[c][i][j] / clusterCounter[2][c];
        }
      }
      ClusterInfo clusterCenter=new ClusterInfo();
      clusterCenter.setClusterCenter(c,centerRe,centerIm,clusterCounter[2][c]);
      psCenterList.add(clusterCenter);
    }
  }
}"
11406,"@Override public void run(){
  op.checkIfCancelled();
  final int x0=rectangle.x;
  final int y0=rectangle.y;
  final int w=rectangle.width;
  final int h=rectangle.height;
  final int xMax=x0 + w;
  final int yMax=y0 + h;
  final Rectangle sourceRectangle=getSourceRectangle(x0,y0,w,h);
  for (int i=0; i < sourceTiles.length; ++i) {
    sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],sourceRectangle);
    dataBuffers[i]=sourceTiles[i].getDataBuffer();
  }
  final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
  for (int y=y0; y < yMax; ++y) {
    for (int x=x0; x < xMax; ++x) {
      PolOpUtils.getMeanCoherencyMatrix(x,y,halfWindowSizeX,halfWindowSizeY,srcWidth,srcHeight,sourceProductType,srcIndex,dataBuffers,Tr,Ti);
      int clusterIdx;
synchronized (clusterCounter) {
        if (mask[y][x] < -64) {
          clusterIdx=findClosestCluster(Tr,Ti,pvCenterList);
          computeSummationOfT3(clusterIdx + 1,Tr,Ti,pvSumRe,pvSumIm);
          clusterCounter[0][clusterIdx]+=1;
          mask[y][x]=(byte)(-128 + clusterIdx);
        }
 else         if (mask[y][x] < 0) {
          clusterIdx=findClosestCluster(Tr,Ti,pdCenterList);
          computeSummationOfT3(clusterIdx + 1,Tr,Ti,pdSumRe,pdSumIm);
          clusterCounter[1][clusterIdx]+=1;
          mask[y][x]=(byte)(-64 + clusterIdx);
        }
 else         if (mask[y][x] < 64) {
          clusterIdx=findClosestCluster(Tr,Ti,psCenterList);
          computeSummationOfT3(clusterIdx + 1,Tr,Ti,psSumRe,psSumIm);
          clusterCounter[2][clusterIdx]+=1;
          mask[y][x]=(byte)clusterIdx;
        }
 else {
          java.util.List<ClusterInfo> allCenterList=new ArrayList<>();
          allCenterList.addAll(pvCenterList);
          allCenterList.addAll(pdCenterList);
          allCenterList.addAll(psCenterList);
          clusterIdx=findClosestCluster(Tr,Ti,allCenterList);
          if (clusterIdx >= pvNumClusters + pdNumClusters) {
            clusterIdx-=pvNumClusters + pdNumClusters;
            computeSummationOfT3(clusterIdx + 1,Tr,Ti,psSumRe,psSumIm);
            clusterCounter[2][clusterIdx]+=1;
            mask[y][x]=(byte)clusterIdx;
          }
 else           if (clusterIdx >= pvNumClusters) {
            clusterIdx-=pvNumClusters;
            computeSummationOfT3(clusterIdx + 1,Tr,Ti,pdSumRe,pdSumIm);
            clusterCounter[1][clusterIdx]+=1;
            mask[y][x]=(byte)(-64 + clusterIdx);
          }
 else {
            computeSummationOfT3(clusterIdx + 1,Tr,Ti,pvSumRe,pvSumIm);
            clusterCounter[0][clusterIdx]+=1;
            mask[y][x]=(byte)(-128 + clusterIdx);
          }
        }
      }
    }
  }
}","@Override public void run(){
  op.checkIfCancelled();
  final int x0=rectangle.x;
  final int y0=rectangle.y;
  final int w=rectangle.width;
  final int h=rectangle.height;
  final int xMax=x0 + w;
  final int yMax=y0 + h;
  final Rectangle sourceRectangle=getSourceRectangle(x0,y0,w,h);
  for (int i=0; i < sourceTiles.length; ++i) {
    sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],sourceRectangle);
    dataBuffers[i]=sourceTiles[i].getDataBuffer();
  }
  final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
  for (int y=y0; y < yMax; ++y) {
    for (int x=x0; x < xMax; ++x) {
      PolOpUtils.getMeanCoherencyMatrix(x,y,halfWindowSizeX,halfWindowSizeY,srcWidth,srcHeight,sourceProductType,srcIndex,dataBuffers,Tr,Ti);
synchronized (clusterCounter) {
        if (category[y][x] == Categories.vol) {
          cluster[y][x]=findClosestCluster(Tr,Ti,pvCenterList);
          computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pvSumRe,pvSumIm);
          clusterCounter[0][cluster[y][x]]+=1;
        }
 else         if (category[y][x] == Categories.dbl) {
          cluster[y][x]=findClosestCluster(Tr,Ti,pdCenterList);
          computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pdSumRe,pdSumIm);
          clusterCounter[1][cluster[y][x]]+=1;
        }
 else         if (category[y][x] == Categories.suf) {
          cluster[y][x]=findClosestCluster(Tr,Ti,psCenterList);
          computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,psSumRe,psSumIm);
          clusterCounter[2][cluster[y][x]]+=1;
        }
 else {
          final int nearestPvCluster=findClosestCluster(Tr,Ti,pvCenterList);
          final int nearestPdCluster=findClosestCluster(Tr,Ti,pdCenterList);
          final int nearestPsCluster=findClosestCluster(Tr,Ti,psCenterList);
          final double dPv=HAlphaWishart.computeWishartDistance(Tr,Ti,pvCenterList.get(nearestPvCluster));
          final double dPd=HAlphaWishart.computeWishartDistance(Tr,Ti,pdCenterList.get(nearestPdCluster));
          final double dPs=HAlphaWishart.computeWishartDistance(Tr,Ti,psCenterList.get(nearestPsCluster));
          if (dPv <= dPd && dPv <= dPs) {
            cluster[y][x]=nearestPvCluster;
            computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pvSumRe,pvSumIm);
            clusterCounter[0][cluster[y][x]]+=1;
            category[y][x]=Categories.vol;
          }
 else           if (dPd <= dPv && dPd <= dPs) {
            cluster[y][x]=nearestPdCluster;
            computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,pdSumRe,pdSumIm);
            clusterCounter[1][cluster[y][x]]+=1;
            category[y][x]=Categories.dbl;
          }
 else {
            cluster[y][x]=nearestPsCluster;
            computeSummationOfT3(cluster[y][x] + 1,Tr,Ti,psSumRe,psSumIm);
            clusterCounter[2][cluster[y][x]]+=1;
            category[y][x]=Categories.suf;
          }
        }
      }
    }
  }
}"
11407,"private int getOutputClusterIndex(final int x,final int y){
  return mask[y][x] < -64 ? pvColourIndexMap[mask[y][x] + 128] : mask[y][x] < 0 ? pdColourIndexMap[mask[y][x] + 64] : psColourIndexMap[mask[y][x]];
}","private int getOutputClusterIndex(final int x,final int y){
  return category[y][x] == Categories.vol ? pvColourIndexMap[cluster[y][x]] : category[y][x] == Categories.dbl ? pdColourIndexMap[cluster[y][x]] : psColourIndexMap[cluster[y][x]];
}"
11408,"/** 
 * Create 30 initial clusters in each of the 3 categories (vol, dbl and surf). The pixels are first classified into 4 categories (vol, dbl, urf and mixed) based on its Freeman-Durder decomposition result. Then pixels in each category (not include mixed) are grouped into 30 clusters based on their power values.
 * @param srcBandList    the input bands
 * @param tileRectangles Array of rectangles for all source tiles of the image
 * @param op             the operator
 */
private void createInitialClusters(final double[][] fdd,final PolBandUtils.PolSourceBand srcBandList,final Rectangle[] tileRectangles,final PolarimetricClassificationOp op){
  final StatusProgressMonitor status=new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
  status.beginTask(""String_Node_Str"",tileRectangles.length);
  final int[] counter=new int[4];
  final ThreadManager threadManager=new ThreadManager();
  final double[] pv=new double[srcHeight * srcWidth];
  final double[] pd=new double[srcHeight * srcWidth];
  final double[] ps=new double[srcHeight * srcWidth];
  try {
    for (    final Rectangle rectangle : tileRectangles) {
      op.checkIfCancelled();
      final Thread worker=new Thread(){
        final Tile[] sourceTiles=new Tile[srcBandList.srcBands.length];
        final ProductData[] dataBuffers=new ProductData[srcBandList.srcBands.length];
        final double[][] Cr=new double[3][3];
        final double[][] Ci=new double[3][3];
        @Override public void run(){
          final int x0=rectangle.x;
          final int y0=rectangle.y;
          final int w=rectangle.width;
          final int h=rectangle.height;
          final int xMax=x0 + w;
          final int yMax=y0 + h;
          final Rectangle sourceRectangle=getSourceRectangle(x0,y0,w,h);
          for (int i=0; i < sourceTiles.length; ++i) {
            sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],sourceRectangle);
            dataBuffers[i]=sourceTiles[i].getDataBuffer();
          }
          for (int y=y0; y < yMax; ++y) {
            for (int x=x0; x < xMax; ++x) {
              PolOpUtils.getMeanCovarianceMatrix(x,y,halfWindowSizeX,halfWindowSizeY,sourceProductType,sourceTiles,dataBuffers,Cr,Ci);
              final FreemanDurden.FDD data=FreemanDurden.getFreemanDurdenDecomposition(Cr,Ci);
synchronized (counter) {
                if (!Double.isNaN(data.pv) && !Double.isNaN(data.pd) && !Double.isNaN(data.ps)) {
                  Categories cat=getCategory(data.pv,data.pd,data.ps,mixedCategoryThreshold);
                  if (cat == Categories.vol) {
                    mask[y][x]=-128;
                    fdd[y][x]=data.pv;
                    pv[counter[0]]=data.pv;
                    counter[0]+=1;
                  }
 else                   if (cat == Categories.dbl) {
                    mask[y][x]=-64;
                    fdd[y][x]=data.pd;
                    pd[counter[1]]=data.pd;
                    counter[1]+=1;
                  }
 else                   if (cat == Categories.suf) {
                    mask[y][x]=0;
                    fdd[y][x]=data.ps;
                    ps[counter[2]]=data.ps;
                    counter[2]+=1;
                  }
 else {
                    mask[y][x]=64;
                    fdd[y][x]=(data.pv + data.pd + data.ps) / 3.0;
                    counter[3]+=1;
                  }
                }
              }
            }
          }
        }
      }
;
      threadManager.add(worker);
      status.worked(1);
    }
    threadManager.finish();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(op.getId() + ""String_Node_Str"",e);
  }
 finally {
    status.done();
  }
  final int pvClusterSize=counter[0] / numInitialClusters;
  final int pdClusterSize=counter[1] / numInitialClusters;
  final int psClusterSize=counter[2] / numInitialClusters;
  if (pvClusterSize > 0) {
    Arrays.sort(pv,0,counter[0] - 1);
  }
  if (pdClusterSize > 0) {
    Arrays.sort(pd,0,counter[1] - 1);
  }
  if (psClusterSize > 0) {
    Arrays.sort(ps,0,counter[2] - 1);
  }
  final double[] pvThreshold=new double[numInitialClusters - 1];
  final double[] pdThreshold=new double[numInitialClusters - 1];
  final double[] psThreshold=new double[numInitialClusters - 1];
  for (int i=0; i < numInitialClusters - 1; i++) {
    pvThreshold[i]=pv[(i + 1) * pvClusterSize];
    pdThreshold[i]=pd[(i + 1) * pdClusterSize];
    psThreshold[i]=ps[(i + 1) * psClusterSize];
  }
  int clusterIdx=-1;
  for (int y=0; y < srcHeight; y++) {
    for (int x=0; x < srcWidth; x++) {
      if (mask[y][x] == -128) {
        clusterIdx=computePixelClusterIdx(fdd[y][x],pvThreshold,numInitialClusters);
        mask[y][x]+=clusterIdx;
      }
 else       if (mask[y][x] == -64) {
        clusterIdx=computePixelClusterIdx(fdd[y][x],pdThreshold,numInitialClusters);
        mask[y][x]+=clusterIdx;
      }
 else       if (mask[y][x] == 0) {
        clusterIdx=computePixelClusterIdx(fdd[y][x],psThreshold,numInitialClusters);
        mask[y][x]+=clusterIdx;
      }
    }
  }
}","/** 
 * Create 30 initial clusters in each of the 3 categories (vol, dbl and surf). The pixels are first classified into 4 categories (vol, dbl, urf and mixed) based on its Freeman-Durden decomposition result. Then pixels in each category (not include mixed) are grouped into 30 clusters based on their power values.
 * @param srcBandList    the input bands
 * @param tileRectangles Array of rectangles for all source tiles of the image
 * @param op             the operator
 */
private void createInitialClusters(final double[][] fdd,final PolBandUtils.PolSourceBand srcBandList,final Rectangle[] tileRectangles,final PolarimetricClassificationOp op){
  final StatusProgressMonitor status=new StatusProgressMonitor(StatusProgressMonitor.TYPE.SUBTASK);
  status.beginTask(""String_Node_Str"",tileRectangles.length);
  final int[] counter=new int[4];
  final ThreadManager threadManager=new ThreadManager();
  final double[] pv=new double[srcHeight * srcWidth];
  final double[] pd=new double[srcHeight * srcWidth];
  final double[] ps=new double[srcHeight * srcWidth];
  try {
    for (    final Rectangle rectangle : tileRectangles) {
      op.checkIfCancelled();
      final Thread worker=new Thread(){
        final Tile[] sourceTiles=new Tile[srcBandList.srcBands.length];
        final ProductData[] dataBuffers=new ProductData[srcBandList.srcBands.length];
        final double[][] Cr=new double[3][3];
        final double[][] Ci=new double[3][3];
        @Override public void run(){
          final int x0=rectangle.x;
          final int y0=rectangle.y;
          final int w=rectangle.width;
          final int h=rectangle.height;
          final int xMax=x0 + w;
          final int yMax=y0 + h;
          final Rectangle sourceRectangle=getSourceRectangle(x0,y0,w,h);
          for (int i=0; i < sourceTiles.length; ++i) {
            sourceTiles[i]=op.getSourceTile(srcBandList.srcBands[i],sourceRectangle);
            dataBuffers[i]=sourceTiles[i].getDataBuffer();
          }
          for (int y=y0; y < yMax; ++y) {
            for (int x=x0; x < xMax; ++x) {
              PolOpUtils.getMeanCovarianceMatrix(x,y,halfWindowSizeX,halfWindowSizeY,sourceProductType,sourceTiles,dataBuffers,Cr,Ci);
              final FreemanDurden.FDD data=FreemanDurden.getFreemanDurdenDecomposition(Cr,Ci);
synchronized (counter) {
                if (!Double.isNaN(data.pv) && !Double.isNaN(data.pd) && !Double.isNaN(data.ps)) {
                  category[y][x]=getCategory(data.pv,data.pd,data.ps,mixedCategoryThreshold);
                  if (category[y][x] == Categories.vol) {
                    fdd[y][x]=data.pv;
                    pv[counter[0]]=data.pv;
                    counter[0]+=1;
                  }
 else                   if (category[y][x] == Categories.dbl) {
                    fdd[y][x]=data.pd;
                    pd[counter[1]]=data.pd;
                    counter[1]+=1;
                  }
 else                   if (category[y][x] == Categories.suf) {
                    fdd[y][x]=data.ps;
                    ps[counter[2]]=data.ps;
                    counter[2]+=1;
                  }
 else {
                    fdd[y][x]=(data.pv + data.pd + data.ps) / 3.0;
                    counter[3]+=1;
                  }
                }
              }
            }
          }
        }
      }
;
      threadManager.add(worker);
      status.worked(1);
    }
    threadManager.finish();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(op.getId() + ""String_Node_Str"",e);
  }
 finally {
    status.done();
  }
  final int pvClusterSize=counter[0] / numInitialClusters;
  final int pdClusterSize=counter[1] / numInitialClusters;
  final int psClusterSize=counter[2] / numInitialClusters;
  if (pvClusterSize > 0) {
    Arrays.sort(pv,0,counter[0] - 1);
  }
  if (pdClusterSize > 0) {
    Arrays.sort(pd,0,counter[1] - 1);
  }
  if (psClusterSize > 0) {
    Arrays.sort(ps,0,counter[2] - 1);
  }
  final double[] pvThreshold=new double[numInitialClusters - 1];
  final double[] pdThreshold=new double[numInitialClusters - 1];
  final double[] psThreshold=new double[numInitialClusters - 1];
  for (int i=0; i < numInitialClusters - 1; i++) {
    pvThreshold[i]=pv[(i + 1) * pvClusterSize];
    pdThreshold[i]=pd[(i + 1) * pdClusterSize];
    psThreshold[i]=ps[(i + 1) * psClusterSize];
  }
  for (int y=0; y < srcHeight; y++) {
    for (int x=0; x < srcWidth; x++) {
      if (category[y][x] == Categories.vol) {
        cluster[y][x]=computePixelClusterIdx(fdd[y][x],pvThreshold,numInitialClusters);
      }
 else       if (category[y][x] == Categories.dbl) {
        cluster[y][x]=computePixelClusterIdx(fdd[y][x],pdThreshold,numInitialClusters);
      }
 else       if (category[y][x] == Categories.suf) {
        cluster[y][x]=computePixelClusterIdx(fdd[y][x],psThreshold,numInitialClusters);
      }
    }
  }
}"
11409,"/** 
 * Compute centers for all numClasses clusters
 * @param srcBandList the input bands
 * @param op          the operator
 */
private synchronized void computeTerrainClusterCenters(final PolBandUtils.PolSourceBand srcBandList,final PolarimetricClassificationOp op){
  if (clusterCentersComputed) {
    return;
  }
  mask=new byte[srcHeight][srcWidth];
  final double[][] fdd=new double[srcHeight][srcWidth];
  final java.util.List<ClusterInfo> pvCenterList=new ArrayList<>(numInitialClusters);
  final java.util.List<ClusterInfo> pdCenterList=new ArrayList<>(numInitialClusters);
  final java.util.List<ClusterInfo> psCenterList=new ArrayList<>(numInitialClusters);
  maxClusterSize=2 * srcHeight * srcWidth / numFinalClasses;
  final Dimension tileSize=new Dimension(256,256);
  final Rectangle[] tileRectangles=OperatorUtils.getAllTileRectangles(op.getSourceProduct(),tileSize,0);
  computeInitialTerrainClusterCenters(fdd,pvCenterList,pdCenterList,psCenterList,srcBandList,tileRectangles,op);
  computeFinalTerrainClusterCenters(fdd,pvCenterList,pdCenterList,psCenterList,srcBandList,tileRectangles,op);
  clusterCentersComputed=true;
}","/** 
 * Compute centers for all numClasses clusters
 * @param srcBandList the input bands
 * @param op          the operator
 */
private synchronized void computeTerrainClusterCenters(final PolBandUtils.PolSourceBand srcBandList,final PolarimetricClassificationOp op){
  if (clusterCentersComputed) {
    return;
  }
  category=new Categories[srcHeight][srcWidth];
  cluster=new int[srcHeight][srcWidth];
  final double[][] fdd=new double[srcHeight][srcWidth];
  final java.util.List<ClusterInfo> pvCenterList=new ArrayList<>(numInitialClusters);
  final java.util.List<ClusterInfo> pdCenterList=new ArrayList<>(numInitialClusters);
  final java.util.List<ClusterInfo> psCenterList=new ArrayList<>(numInitialClusters);
  maxClusterSize=2 * srcHeight * srcWidth / numFinalClasses;
  final Dimension tileSize=new Dimension(256,256);
  final Rectangle[] tileRectangles=OperatorUtils.getAllTileRectangles(op.getSourceProduct(),tileSize,0);
  computeInitialTerrainClusterCenters(fdd,pvCenterList,pdCenterList,psCenterList,srcBandList,tileRectangles,op);
  computeFinalTerrainClusterCenters(fdd,pvCenterList,pdCenterList,psCenterList,srcBandList,tileRectangles,op);
  clusterCentersComputed=true;
}"
11410,"private void saveInterferogram(final ComplexDoubleMatrix dataMaster,final ProductContainer product,final Map<Band,Tile> targetTileMap,final Rectangle targetRectangle){
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int maxX=x0 + targetRectangle.width;
  final int maxY=y0 + targetRectangle.height;
  final Band targetBand_I=targetProduct.getBand(product.getBandName(Unit.REAL));
  final Tile tileOutReal=targetTileMap.get(targetBand_I);
  final Band targetBand_Q=targetProduct.getBand(product.getBandName(Unit.IMAGINARY));
  final Tile tileOutImag=targetTileMap.get(targetBand_Q);
  final ProductData samplesReal=tileOutReal.getDataBuffer();
  final ProductData samplesImag=tileOutImag.getDataBuffer();
  final DoubleMatrix dataReal=dataMaster.real();
  final DoubleMatrix dataImag=dataMaster.imag();
  final TileIndex tgtIndex=new TileIndex(tileOutReal);
  final double srcNoDataValue=product.sourceMaster.realBand.getNoDataValue();
  final Tile slvTileReal=getSourceTile(product.sourceSlave.realBand,targetRectangle);
  final ProductData srcSlvData=slvTileReal.getDataBuffer();
  final TileIndex srcSlvIndex=new TileIndex(slvTileReal);
  for (int y=y0; y < maxY; y++) {
    tgtIndex.calculateStride(y);
    srcSlvIndex.calculateStride(y);
    final int yy=y - y0;
    for (int x=x0; x < maxX; x++) {
      final int tgtIdx=tgtIndex.getIndex(x);
      final int xx=x - x0;
      if (srcSlvData.getElemDoubleAt(srcSlvIndex.getIndex(x)) == srcNoDataValue) {
        samplesReal.setElemFloatAt(tgtIdx,(float)srcNoDataValue);
        samplesImag.setElemFloatAt(tgtIdx,(float)srcNoDataValue);
      }
 else {
        samplesReal.setElemFloatAt(tgtIdx,(float)dataReal.get(yy,xx));
        samplesImag.setElemFloatAt(tgtIdx,(float)dataImag.get(yy,xx));
      }
    }
  }
}","private void saveInterferogram(final ComplexDoubleMatrix dataMaster,final ProductContainer product,final Map<Band,Tile> targetTileMap,final Rectangle targetRectangle){
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int maxX=x0 + targetRectangle.width;
  final int maxY=y0 + targetRectangle.height;
  final Band targetBand_I=targetProduct.getBand(product.getBandName(Unit.REAL));
  final Tile tileOutReal=targetTileMap.get(targetBand_I);
  final Band targetBand_Q=targetProduct.getBand(product.getBandName(Unit.IMAGINARY));
  final Tile tileOutImag=targetTileMap.get(targetBand_Q);
  final ProductData samplesReal=tileOutReal.getDataBuffer();
  final ProductData samplesImag=tileOutImag.getDataBuffer();
  final DoubleMatrix dataReal=dataMaster.real();
  final DoubleMatrix dataImag=dataMaster.imag();
  final TileIndex tgtIndex=new TileIndex(tileOutReal);
  final double mstNoDataValue=product.sourceMaster.realBand.getNoDataValue();
  final Tile mstRealTile=getSourceTile(product.sourceMaster.realBand,targetRectangle);
  final ProductData mstRealData=mstRealTile.getDataBuffer();
  final double slvNoDataValue=product.sourceSlave.realBand.getNoDataValue();
  final Tile slvRealTile=getSourceTile(product.sourceSlave.realBand,targetRectangle);
  final ProductData slvRealData=slvRealTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(mstRealTile);
  for (int y=y0; y < maxY; y++) {
    tgtIndex.calculateStride(y);
    srcIndex.calculateStride(y);
    final int yy=y - y0;
    for (int x=x0; x < maxX; x++) {
      final int tgtIdx=tgtIndex.getIndex(x);
      final int xx=x - x0;
      final int srcIdx=srcIndex.getIndex(x);
      if (mstRealData.getElemDoubleAt(srcIdx) == mstNoDataValue || slvRealData.getElemDoubleAt(srcIdx) == slvNoDataValue) {
        samplesReal.setElemFloatAt(tgtIdx,(float)mstNoDataValue);
        samplesImag.setElemFloatAt(tgtIdx,(float)mstNoDataValue);
      }
 else {
        samplesReal.setElemFloatAt(tgtIdx,(float)dataReal.get(yy,xx));
        samplesImag.setElemFloatAt(tgtIdx,(float)dataImag.get(yy,xx));
      }
    }
  }
}"
11411,"@Override public void initParameters(){
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractFlatEarthPhase=paramVal;
    subtractFlatEarthPhaseCheckBox.setSelected(subtractFlatEarthPhase);
    enableSubtractFlatEarthPhaseParameters(subtractFlatEarthPhase);
  }
  srpPolynomialDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  srpNumberPointsStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  orbitDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  if (sourceProducts != null && sourceProducts.length > 0) {
    boolean isComplex=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]).getAttributeString(AbstractMetadata.SAMPLE_TYPE).contains(""String_Node_Str"");
    enableControls(isComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractTopographicPhase=paramVal;
    subtractTopographicPhaseCheckBox.setSelected(subtractTopographicPhase);
    enableSubtractTopographicPhaseParameters(subtractTopographicPhase);
  }
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null) {
    ElevationModelDescriptor descriptor=ElevationModelRegistry.getInstance().getDescriptor(demNameParam);
    demName.setSelectedItem(DEMFactory.getDEMDisplayName(descriptor));
  }
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalDEMFile.setText(extFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null && !textAreaKeyListener.isChangedByUser()) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
  tileExtensionPercent.setSelectedItem(paramMap.get(""String_Node_Str""));
  cohWinAz.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  cohWinRg.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  squarePixel=(Boolean)paramMap.get(""String_Node_Str"");
  if (squarePixel != null) {
    squarePixelCheckBox.setSelected(squarePixel);
    independentWindowSizeCheckBox.setSelected(!squarePixel);
    if (squarePixel) {
      cohWinAz.setText(""String_Node_Str"");
      cohWinAz.setEditable(false);
    }
 else {
      cohWinAz.setEditable(true);
    }
  }
  setCohWinAz();
  setCohWinRg();
}","@Override public void initParameters(){
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractFlatEarthPhase=paramVal;
    subtractFlatEarthPhaseCheckBox.setSelected(subtractFlatEarthPhase);
    enableSubtractFlatEarthPhaseParameters(subtractFlatEarthPhase);
  }
  srpPolynomialDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  srpNumberPointsStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  orbitDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  if (sourceProducts != null && sourceProducts.length > 0) {
    boolean isComplex=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]).getAttributeString(AbstractMetadata.SAMPLE_TYPE).contains(""String_Node_Str"");
    enableControls(isComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractTopographicPhase=paramVal;
    subtractTopographicPhaseCheckBox.setSelected(subtractTopographicPhase);
    enableSubtractTopographicPhaseParameters(subtractTopographicPhase);
  }
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null) {
    ElevationModelDescriptor descriptor=ElevationModelRegistry.getInstance().getDescriptor(demNameParam);
    if (descriptor != null) {
      demName.setSelectedItem(DEMFactory.getDEMDisplayName(descriptor));
    }
 else {
      demName.setSelectedItem(demNameParam);
    }
  }
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalDEMFile.setText(extFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null && !textAreaKeyListener.isChangedByUser()) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
  tileExtensionPercent.setSelectedItem(paramMap.get(""String_Node_Str""));
  cohWinAz.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  cohWinRg.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  squarePixel=(Boolean)paramMap.get(""String_Node_Str"");
  if (squarePixel != null) {
    squarePixelCheckBox.setSelected(squarePixel);
    independentWindowSizeCheckBox.setSelected(!squarePixel);
    if (squarePixel) {
      cohWinAz.setText(""String_Node_Str"");
      cohWinAz.setEditable(false);
    }
 else {
      cohWinAz.setEditable(true);
    }
  }
  setCohWinAz();
  setCohWinRg();
}"
11412,"@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames());
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null) {
    ElevationModelDescriptor descriptor=ElevationModelRegistry.getInstance().getDescriptor(demNameParam);
    if (descriptor != null) {
      demName.setSelectedItem(DEMFactory.getDEMDisplayName(descriptor));
    }
 else {
      demName.setSelectedItem(demNameParam);
    }
  }
  demResamplingMethod.setSelectedItem(paramMap.get(""String_Node_Str""));
  imgResamplingMethod.setSelectedItem(paramMap.get(""String_Node_Str""));
  incidenceAngleForGamma0.setSelectedItem(paramMap.get(""String_Node_Str""));
  incidenceAngleForSigma0.setSelectedItem(paramMap.get(""String_Node_Str""));
  final String mapProjection=(String)paramMap.get(""String_Node_Str"");
  mapProjHandler.initParameters(mapProjection,sourceProducts);
  crsButton.setText(mapProjHandler.getCRSName());
  pixMSaved=(Double)paramMap.get(""String_Node_Str"");
  if (pixMSaved != null && pixMSaved != 0.0) {
    pixelSpacingInMeter.setText(String.valueOf(pixMSaved));
  }
  pixDSaved=(Double)paramMap.get(""String_Node_Str"");
  if (pixDSaved != null && pixDSaved != 0.0) {
    pixelSpacingInDegree.setText(String.valueOf(pixDSaved));
  }
  if (sourceProducts != null) {
    try {
      azimuthPixelSpacing=SARGeocoding.getAzimuthPixelSpacing(sourceProducts[0]);
      rangePixelSpacing=SARGeocoding.getRangePixelSpacing(sourceProducts[0]);
      azimuthPixelSpacing=(double)((int)(azimuthPixelSpacing * 100 + 0.5)) / 100.0;
      rangePixelSpacing=(double)((int)(rangePixelSpacing * 100 + 0.5)) / 100.0;
    }
 catch (    Exception e) {
      azimuthPixelSpacing=0.0;
      rangePixelSpacing=0.0;
    }
    final String text=Double.toString(azimuthPixelSpacing) + ""String_Node_Str"" + Double.toString(rangePixelSpacing)+ ""String_Node_Str"";
    sourcePixelSpacingsLabelPart2.setText(text);
    if (savedAzimuthPixelSpacing != 0 && savedRangePixelSpacing != 0) {
      if (savedAzimuthPixelSpacing != azimuthPixelSpacing || savedRangePixelSpacing != rangePixelSpacing) {
        pixDSaved=null;
      }
    }
    if (pixDSaved == null || pixDSaved == 0.0) {
      Double pixM, pixD;
      try {
        pixM=Math.max(azimuthPixelSpacing,rangePixelSpacing);
        pixD=SARGeocoding.getPixelSpacingInDegree(pixM);
      }
 catch (      Exception e) {
        pixM=0.0;
        pixD=0.0;
      }
      pixelSpacingInMeter.setText(String.valueOf(pixM));
      pixelSpacingInDegree.setText(String.valueOf(pixD));
      pixMSaved=pixM;
      pixDSaved=pixD;
      savedAzimuthPixelSpacing=azimuthPixelSpacing;
      savedRangePixelSpacing=rangePixelSpacing;
    }
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    if (absRoot != null) {
      boolean isComplex=absRoot.getAttributeString(AbstractMetadata.sample_type).equals(""String_Node_Str"");
      outputComplexCheckBox.setEnabled(isComplex);
    }
  }
  final File extDEMFile=(File)paramMap.get(""String_Node_Str"");
  if (extDEMFile != null) {
    externalDEMFile.setText(extDEMFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
    Boolean paramVal=(Boolean)paramMap.get(""String_Node_Str"");
    if (paramVal != null) {
      externalDEMApplyEGM=paramVal;
      externalDEMApplyEGMCheckBox.setSelected(externalDEMApplyEGM);
    }
  }
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    nodataValueAtSea=paramVal;
    nodataValueAtSeaCheckBox.setSelected(nodataValueAtSea);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputComplex=paramVal;
    outputComplexCheckBox.setSelected(outputComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveDEM=paramVal;
    saveDEMCheckBox.setSelected(saveDEM);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveLatLon=paramVal;
    saveLatLonCheckBox.setSelected(saveLatLon);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveIncidenceAngleFromEllipsoid=paramVal;
    saveIncidenceAngleFromEllipsoidCheckBox.setSelected(saveIncidenceAngleFromEllipsoid);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveLocalIncidenceAngle=paramVal;
    saveLocalIncidenceAngleCheckBox.setSelected(saveLocalIncidenceAngle);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveProjectedLocalIncidenceAngle=paramVal;
    saveProjectedLocalIncidenceAngleCheckBox.setSelected(saveProjectedLocalIncidenceAngle);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveSelectedSourceBand=paramVal;
    saveSelectedSourceBandCheckBox.setSelected(saveSelectedSourceBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    applyRadiometricNormalization=paramVal;
    applyRadiometricNormalizationCheckBox.setSelected(applyRadiometricNormalization);
    incidenceAngleForGamma0.setEnabled(applyRadiometricNormalization);
    incidenceAngleForSigma0.setEnabled(applyRadiometricNormalization);
    saveSigmaNoughtCheckBox.setEnabled(applyRadiometricNormalization);
    saveGammaNoughtCheckBox.setEnabled(applyRadiometricNormalization);
    saveBetaNoughtCheckBox.setEnabled(applyRadiometricNormalization);
  }
 else {
    enableRadiometricNormalization(false);
    saveSelectedSourceBandCheckBox.setSelected(true);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveBetaNought=paramVal;
    saveBetaNoughtCheckBox.setSelected(saveBetaNought);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveGammaNought=paramVal;
    saveGammaNoughtCheckBox.setSelected(saveGammaNought);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveSigmaNought=paramVal;
    saveSigmaNoughtCheckBox.setSelected(saveSigmaNought);
  }
  if (sourceProducts != null) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    if (absRoot != null) {
      final String sampleType=absRoot.getAttributeString(AbstractMetadata.SAMPLE_TYPE);
      if (sampleType.equals(""String_Node_Str"")) {
        auxFile.removeItem(CalibrationOp.PRODUCT_AUX);
      }
 else       if (auxFile.getItemCount() == 2) {
        auxFile.addItem(CalibrationOp.PRODUCT_AUX);
      }
    }
  }
  final String auxFileStr=(String)paramMap.get(""String_Node_Str"");
  if (auxFileStr != null) {
    auxFile.setSelectedItem(auxFileStr);
  }
  final File extAuxFile=(File)paramMap.get(""String_Node_Str"");
  if (extAuxFile != null) {
    externalAuxFile.setText(extAuxFile.getAbsolutePath());
  }
  if (applyRadiometricNormalization != null) {
    auxFile.setEnabled(applyRadiometricNormalization);
    auxFileLabel.setEnabled(applyRadiometricNormalization);
    externalAuxFile.setEnabled(applyRadiometricNormalization);
    externalAuxFileLabel.setEnabled(applyRadiometricNormalization);
    externalAuxFileBrowseButton.setEnabled(applyRadiometricNormalization);
  }
}","@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames());
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null) {
    ElevationModelDescriptor descriptor=ElevationModelRegistry.getInstance().getDescriptor(demNameParam);
    if (descriptor != null) {
      demName.setSelectedItem(DEMFactory.getDEMDisplayName(descriptor));
    }
 else {
      demName.setSelectedItem(demNameParam);
    }
  }
  demResamplingMethod.setSelectedItem(paramMap.get(""String_Node_Str""));
  imgResamplingMethod.setSelectedItem(paramMap.get(""String_Node_Str""));
  incidenceAngleForGamma0.setSelectedItem(paramMap.get(""String_Node_Str""));
  incidenceAngleForSigma0.setSelectedItem(paramMap.get(""String_Node_Str""));
  final String mapProjection=(String)paramMap.get(""String_Node_Str"");
  mapProjHandler.initParameters(mapProjection,sourceProducts);
  crsButton.setText(mapProjHandler.getCRSName());
  pixMSaved=(Double)paramMap.get(""String_Node_Str"");
  if (pixMSaved != null && pixMSaved != 0.0) {
    pixelSpacingInMeter.setText(String.valueOf(pixMSaved));
  }
  pixDSaved=(Double)paramMap.get(""String_Node_Str"");
  if (pixDSaved != null && pixDSaved != 0.0) {
    pixelSpacingInDegree.setText(String.valueOf(pixDSaved));
  }
  if (sourceProducts != null) {
    try {
      azimuthPixelSpacing=SARGeocoding.getAzimuthPixelSpacing(sourceProducts[0]);
      rangePixelSpacing=SARGeocoding.getRangePixelSpacing(sourceProducts[0]);
      azimuthPixelSpacing=(double)((int)(azimuthPixelSpacing * 100 + 0.5)) / 100.0;
      rangePixelSpacing=(double)((int)(rangePixelSpacing * 100 + 0.5)) / 100.0;
    }
 catch (    Exception e) {
      azimuthPixelSpacing=0.0;
      rangePixelSpacing=0.0;
    }
    final String text=Double.toString(azimuthPixelSpacing) + ""String_Node_Str"" + Double.toString(rangePixelSpacing)+ ""String_Node_Str"";
    sourcePixelSpacingsLabelPart2.setText(text);
    if (savedAzimuthPixelSpacing.compareTo(0.0) != 0 && savedRangePixelSpacing.compareTo(0.0) != 0) {
      if (savedAzimuthPixelSpacing.compareTo(azimuthPixelSpacing) != 0 || savedRangePixelSpacing.compareTo(rangePixelSpacing) != 0) {
        pixDSaved=null;
      }
    }
    if (pixDSaved == null || pixDSaved == 0.0) {
      Double pixM, pixD;
      try {
        pixM=Math.max(azimuthPixelSpacing,rangePixelSpacing);
        pixD=SARGeocoding.getPixelSpacingInDegree(pixM);
      }
 catch (      Exception e) {
        pixM=0.0;
        pixD=0.0;
      }
      pixelSpacingInMeter.setText(String.valueOf(pixM));
      pixelSpacingInDegree.setText(String.valueOf(pixD));
      pixMSaved=pixM;
      pixDSaved=pixD;
      savedAzimuthPixelSpacing=azimuthPixelSpacing;
      savedRangePixelSpacing=rangePixelSpacing;
    }
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    if (absRoot != null) {
      boolean isComplex=absRoot.getAttributeString(AbstractMetadata.sample_type).equals(""String_Node_Str"");
      outputComplexCheckBox.setEnabled(isComplex);
    }
  }
  final File extDEMFile=(File)paramMap.get(""String_Node_Str"");
  if (extDEMFile != null) {
    externalDEMFile.setText(extDEMFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
    Boolean paramVal=(Boolean)paramMap.get(""String_Node_Str"");
    if (paramVal != null) {
      externalDEMApplyEGM=paramVal;
      externalDEMApplyEGMCheckBox.setSelected(externalDEMApplyEGM);
    }
  }
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    nodataValueAtSea=paramVal;
    nodataValueAtSeaCheckBox.setSelected(nodataValueAtSea);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputComplex=paramVal;
    outputComplexCheckBox.setSelected(outputComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveDEM=paramVal;
    saveDEMCheckBox.setSelected(saveDEM);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveLatLon=paramVal;
    saveLatLonCheckBox.setSelected(saveLatLon);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveIncidenceAngleFromEllipsoid=paramVal;
    saveIncidenceAngleFromEllipsoidCheckBox.setSelected(saveIncidenceAngleFromEllipsoid);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveLocalIncidenceAngle=paramVal;
    saveLocalIncidenceAngleCheckBox.setSelected(saveLocalIncidenceAngle);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveProjectedLocalIncidenceAngle=paramVal;
    saveProjectedLocalIncidenceAngleCheckBox.setSelected(saveProjectedLocalIncidenceAngle);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveSelectedSourceBand=paramVal;
    saveSelectedSourceBandCheckBox.setSelected(saveSelectedSourceBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    applyRadiometricNormalization=paramVal;
    applyRadiometricNormalizationCheckBox.setSelected(applyRadiometricNormalization);
    incidenceAngleForGamma0.setEnabled(applyRadiometricNormalization);
    incidenceAngleForSigma0.setEnabled(applyRadiometricNormalization);
    saveSigmaNoughtCheckBox.setEnabled(applyRadiometricNormalization);
    saveGammaNoughtCheckBox.setEnabled(applyRadiometricNormalization);
    saveBetaNoughtCheckBox.setEnabled(applyRadiometricNormalization);
  }
 else {
    enableRadiometricNormalization(false);
    saveSelectedSourceBandCheckBox.setSelected(true);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveBetaNought=paramVal;
    saveBetaNoughtCheckBox.setSelected(saveBetaNought);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveGammaNought=paramVal;
    saveGammaNoughtCheckBox.setSelected(saveGammaNought);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveSigmaNought=paramVal;
    saveSigmaNoughtCheckBox.setSelected(saveSigmaNought);
  }
  if (sourceProducts != null) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    if (absRoot != null) {
      final String sampleType=absRoot.getAttributeString(AbstractMetadata.SAMPLE_TYPE);
      if (sampleType.equals(""String_Node_Str"")) {
        auxFile.removeItem(CalibrationOp.PRODUCT_AUX);
      }
 else       if (auxFile.getItemCount() == 2) {
        auxFile.addItem(CalibrationOp.PRODUCT_AUX);
      }
    }
  }
  final String auxFileStr=(String)paramMap.get(""String_Node_Str"");
  if (auxFileStr != null) {
    auxFile.setSelectedItem(auxFileStr);
  }
  final File extAuxFile=(File)paramMap.get(""String_Node_Str"");
  if (extAuxFile != null) {
    externalAuxFile.setText(extAuxFile.getAbsolutePath());
  }
  if (applyRadiometricNormalization != null) {
    auxFile.setEnabled(applyRadiometricNormalization);
    auxFileLabel.setEnabled(applyRadiometricNormalization);
    externalAuxFile.setEnabled(applyRadiometricNormalization);
    externalAuxFileLabel.setEnabled(applyRadiometricNormalization);
    externalAuxFileBrowseButton.setEnabled(applyRadiometricNormalization);
  }
}"
11413,"@Override public void initParameters(){
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractFlatEarthPhase=paramVal;
    subtractFlatEarthPhaseCheckBox.setSelected(subtractFlatEarthPhase);
  }
  srpPolynomialDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  srpNumberPointsStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  orbitDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  if (sourceProducts != null && sourceProducts.length > 0) {
    boolean isComplex=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]).getAttributeString(AbstractMetadata.SAMPLE_TYPE).contains(""String_Node_Str"");
    enableControls(isComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractTopographicPhase=paramVal;
    subtractTopographicPhaseCheckBox.setSelected(subtractTopographicPhase);
  }
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null) {
    ElevationModelDescriptor descriptor=ElevationModelRegistry.getInstance().getDescriptor(demNameParam);
    demName.setSelectedItem(DEMFactory.getDEMDisplayName(descriptor));
  }
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalDEMFile.setText(extFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null && !textAreaKeyListener.isChangedByUser()) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
  tileExtensionPercent.setSelectedItem(paramMap.get(""String_Node_Str""));
  cohWinAz.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  cohWinRg.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  squarePixel=(Boolean)paramMap.get(""String_Node_Str"");
  if (squarePixel != null) {
    squarePixelCheckBox.setSelected(squarePixel);
    independentWindowSizeCheckBox.setSelected(!squarePixel);
    if (squarePixel) {
      cohWinAz.setText(""String_Node_Str"");
      cohWinAz.setEditable(false);
    }
 else {
      cohWinAz.setEditable(true);
    }
  }
  setCohWinAz();
  setCohWinRg();
}","@Override public void initParameters(){
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractFlatEarthPhase=paramVal;
    subtractFlatEarthPhaseCheckBox.setSelected(subtractFlatEarthPhase);
    enableSubtractFlatEarthPhaseParameters(subtractFlatEarthPhase);
  }
  srpPolynomialDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  srpNumberPointsStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  orbitDegreeStr.setSelectedItem(paramMap.get(""String_Node_Str""));
  if (sourceProducts != null && sourceProducts.length > 0) {
    boolean isComplex=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]).getAttributeString(AbstractMetadata.SAMPLE_TYPE).contains(""String_Node_Str"");
    enableControls(isComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    subtractTopographicPhase=paramVal;
    subtractTopographicPhaseCheckBox.setSelected(subtractTopographicPhase);
    enableSubtractTopographicPhaseParameters(subtractTopographicPhase);
  }
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null) {
    ElevationModelDescriptor descriptor=ElevationModelRegistry.getInstance().getDescriptor(demNameParam);
    demName.setSelectedItem(DEMFactory.getDEMDisplayName(descriptor));
  }
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalDEMFile.setText(extFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null && !textAreaKeyListener.isChangedByUser()) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
  tileExtensionPercent.setSelectedItem(paramMap.get(""String_Node_Str""));
  cohWinAz.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  cohWinRg.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  squarePixel=(Boolean)paramMap.get(""String_Node_Str"");
  if (squarePixel != null) {
    squarePixelCheckBox.setSelected(squarePixel);
    independentWindowSizeCheckBox.setSelected(!squarePixel);
    if (squarePixel) {
      cohWinAz.setText(""String_Node_Str"");
      cohWinAz.setEditable(false);
    }
 else {
      cohWinAz.setEditable(true);
    }
  }
  setCohWinAz();
  setCohWinRg();
}"
11414,"@Override public JComponent CreateOpTab(String operatorName,Map<String,Object> parameterMap,AppContext appContext){
  initializeOperatorUI(operatorName,parameterMap);
  final JComponent panel=new JScrollPane(createPanel());
  initParameters();
  subtractFlatEarthPhaseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      subtractFlatEarthPhase=(e.getStateChange() == ItemEvent.SELECTED);
      if (subtractFlatEarthPhase) {
        srpPolynomialDegreeStr.setEnabled(true);
        srpNumberPointsStr.setEnabled(true);
        orbitDegreeStr.setEnabled(true);
      }
 else {
        srpPolynomialDegreeStr.setEnabled(false);
        srpNumberPointsStr.setEnabled(false);
        orbitDegreeStr.setEnabled(false);
      }
    }
  }
);
  squarePixelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      squarePixel=(e.getStateChange() == ItemEvent.SELECTED);
      independentWindowSizeCheckBox.setSelected(!squarePixel);
      if (squarePixel) {
        cohWinAz.setText(""String_Node_Str"");
        cohWinAz.setEditable(false);
      }
      setCohWinAz();
      setCohWinRg();
    }
  }
);
  independentWindowSizeCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      squarePixel=(e.getStateChange() != ItemEvent.SELECTED);
      squarePixelCheckBox.setSelected(squarePixel);
      if (!squarePixel) {
        cohWinAz.setEditable(true);
      }
      setCohWinAz();
      setCohWinRg();
    }
  }
);
  subtractTopographicPhaseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      subtractTopographicPhase=(e.getStateChange() == ItemEvent.SELECTED);
      if (subtractTopographicPhase) {
        demName.setEnabled(true);
        tileExtensionPercent.setEnabled(true);
      }
 else {
        demName.setEnabled(false);
        tileExtensionPercent.setEnabled(false);
      }
    }
  }
);
  demName.addItem(externalDEMStr);
  demName.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent event){
      final String item=((String)demName.getSelectedItem()).replace(DEMFactory.AUTODEM,""String_Node_Str"");
      if (item.equals(externalDEMStr)) {
        enableExternalDEM(true);
      }
 else {
        externalDEMFile.setText(""String_Node_Str"");
        enableExternalDEM(false);
      }
    }
  }
);
  externalDEMFile.setColumns(30);
  final String demItem=((String)demName.getSelectedItem()).replace(DEMFactory.AUTODEM,""String_Node_Str"");
  enableExternalDEM(demItem.equals(externalDEMStr));
  externalDEMBrowseButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      final File file=Dialogs.requestFileForOpen(""String_Node_Str"",false,null,DEMFactory.LAST_EXTERNAL_DEM_DIR_KEY);
      if (file != null) {
        externalDEMFile.setText(file.getAbsolutePath());
        extNoDataValue=OperatorUIUtils.getNoDataValue(file);
      }
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
);
  externalDEMNoDataValue.addKeyListener(textAreaKeyListener);
  return panel;
}","@Override public JComponent CreateOpTab(String operatorName,Map<String,Object> parameterMap,AppContext appContext){
  initializeOperatorUI(operatorName,parameterMap);
  final JComponent panel=new JScrollPane(createPanel());
  initParameters();
  subtractFlatEarthPhaseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      subtractFlatEarthPhase=(e.getStateChange() == ItemEvent.SELECTED);
      enableSubtractFlatEarthPhaseParameters(subtractFlatEarthPhase);
    }
  }
);
  squarePixelCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      squarePixel=(e.getStateChange() == ItemEvent.SELECTED);
      independentWindowSizeCheckBox.setSelected(!squarePixel);
      if (squarePixel) {
        cohWinAz.setText(""String_Node_Str"");
        cohWinAz.setEditable(false);
      }
      setCohWinAz();
      setCohWinRg();
    }
  }
);
  independentWindowSizeCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      squarePixel=(e.getStateChange() != ItemEvent.SELECTED);
      squarePixelCheckBox.setSelected(squarePixel);
      if (!squarePixel) {
        cohWinAz.setEditable(true);
      }
      setCohWinAz();
      setCohWinRg();
    }
  }
);
  subtractTopographicPhaseCheckBox.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent e){
      subtractTopographicPhase=(e.getStateChange() == ItemEvent.SELECTED);
      enableSubtractTopographicPhaseParameters(subtractTopographicPhase);
    }
  }
);
  demName.addItem(externalDEMStr);
  demName.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent event){
      final String item=((String)demName.getSelectedItem()).replace(DEMFactory.AUTODEM,""String_Node_Str"");
      if (item.equals(externalDEMStr)) {
        enableExternalDEM(true);
      }
 else {
        externalDEMFile.setText(""String_Node_Str"");
        enableExternalDEM(false);
      }
    }
  }
);
  externalDEMFile.setColumns(30);
  final String demItem=((String)demName.getSelectedItem()).replace(DEMFactory.AUTODEM,""String_Node_Str"");
  enableExternalDEM(demItem.equals(externalDEMStr));
  externalDEMBrowseButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      final File file=Dialogs.requestFileForOpen(""String_Node_Str"",false,null,DEMFactory.LAST_EXTERNAL_DEM_DIR_KEY);
      if (file != null) {
        externalDEMFile.setText(file.getAbsolutePath());
        extNoDataValue=OperatorUIUtils.getNoDataValue(file);
      }
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
);
  externalDEMNoDataValue.addKeyListener(textAreaKeyListener);
  return panel;
}"
11415,"private synchronized void defineDEM() throws IOException {
  if (demDefined)   return;
  Resampling resampling=Resampling.BILINEAR_INTERPOLATION;
  final ElevationModelRegistry elevationModelRegistry;
  final ElevationModelDescriptor demDescriptor;
  if (externalDEMFile == null) {
    elevationModelRegistry=ElevationModelRegistry.getInstance();
    demDescriptor=elevationModelRegistry.getDescriptor(demName);
    if (demDescriptor == null) {
      throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
    }
    dem=demDescriptor.createDem(resampling);
    if (dem == null) {
      throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
    }
    demNoDataValue=demDescriptor.getNoDataValue();
    demSamplingLat=demDescriptor.getTileWidthInDegrees() * (1.0f / demDescriptor.getTileWidth()) * Constants.DTOR;
    demSamplingLon=demSamplingLat;
  }
  if (externalDEMFile != null) {
    dem=new FileElevationModel(externalDEMFile,resampling.getName(),externalDEMNoDataValue);
    demName=externalDEMFile.getPath();
    demNoDataValue=externalDEMNoDataValue;
    try {
      demSamplingLat=(dem.getGeoPos(new PixelPos(1,0)).getLat() - dem.getGeoPos(new PixelPos(0,0)).getLat()) * Constants.DTOR;
      demSamplingLon=(dem.getGeoPos(new PixelPos(0,1)).getLat() - dem.getGeoPos(new PixelPos(0,0)).getLat()) * Constants.DTOR;
    }
 catch (    Exception e) {
      throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
    }
  }
  if (outputElevationBand) {
    Band elevBand=targetProduct.getBand(""String_Node_Str"");
    if (elevBand != null) {
      elevBand.setNoDataValue(demNoDataValue);
    }
  }
  demDefined=true;
}","private synchronized void defineDEM() throws IOException {
  if (demDefined)   return;
  Resampling resampling=Resampling.BILINEAR_INTERPOLATION;
  final ElevationModelRegistry elevationModelRegistry;
  final ElevationModelDescriptor demDescriptor;
  if (externalDEMFile == null) {
    elevationModelRegistry=ElevationModelRegistry.getInstance();
    demDescriptor=elevationModelRegistry.getDescriptor(demName);
    if (demDescriptor == null) {
      throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
    }
    dem=demDescriptor.createDem(resampling);
    if (dem == null) {
      throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
    }
    demNoDataValue=demDescriptor.getNoDataValue();
    demSamplingLat=demDescriptor.getTileWidthInDegrees() * (1.0f / demDescriptor.getTileWidth()) * Constants.DTOR;
    demSamplingLon=demSamplingLat;
  }
  if (externalDEMFile != null) {
    dem=new FileElevationModel(externalDEMFile,resampling.getName(),externalDEMNoDataValue);
    demName=externalDEMFile.getPath();
    demNoDataValue=externalDEMNoDataValue;
    try {
      demSamplingLat=(dem.getGeoPos(new PixelPos(0,1)).getLat() - dem.getGeoPos(new PixelPos(0,0)).getLat()) * Constants.DTOR;
      demSamplingLon=(dem.getGeoPos(new PixelPos(1,0)).getLon() - dem.getGeoPos(new PixelPos(0,0)).getLon()) * Constants.DTOR;
    }
 catch (    Exception e) {
      throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
    }
  }
  if (outputElevationBand) {
    Band elevBand=targetProduct.getBand(""String_Node_Str"");
    if (elevBand != null) {
      elevBand.setNoDataValue(demNoDataValue);
    }
  }
  demDefined=true;
}"
11416,"/** 
 * Get elevation model.
 * @throws Exception The exceptions.
 */
private synchronized void getElevationModel() throws Exception {
  if (isElevationModelAvailable)   return;
  try {
    if (externalDEMFile != null) {
      dem=new FileElevationModel(externalDEMFile,demResamplingMethod,externalDEMNoDataValue);
      demNoDataValue=externalDEMNoDataValue;
      demName=externalDEMFile.getPath();
      try {
        demSamplingLat=Math.abs(dem.getGeoPos(new PixelPos(1,0)).getLat() - dem.getGeoPos(new PixelPos(0,0)).getLat());
        demSamplingLon=Math.abs(dem.getGeoPos(new PixelPos(0,1)).getLat() - dem.getGeoPos(new PixelPos(0,0)).getLat());
      }
 catch (      Exception e) {
        throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
      }
    }
 else {
      dem=DEMFactory.createElevationModel(demName,demResamplingMethod);
      demNoDataValue=dem.getDescriptor().getNoDataValue();
      demSamplingLat=(double)dem.getDescriptor().getTileWidthInDegrees() / (double)dem.getDescriptor().getTileWidth();
      demSamplingLon=demSamplingLat;
    }
  }
 catch (  Throwable t) {
    SystemUtils.LOG.severe(""String_Node_Str"" + t.getMessage());
  }
  isElevationModelAvailable=true;
}","/** 
 * Get elevation model.
 * @throws Exception The exceptions.
 */
private synchronized void getElevationModel() throws Exception {
  if (isElevationModelAvailable)   return;
  try {
    if (externalDEMFile != null) {
      dem=new FileElevationModel(externalDEMFile,demResamplingMethod,externalDEMNoDataValue);
      demNoDataValue=externalDEMNoDataValue;
      demName=externalDEMFile.getPath();
      try {
        demSamplingLat=Math.abs(dem.getGeoPos(new PixelPos(0,1)).getLat() - dem.getGeoPos(new PixelPos(0,0)).getLat());
        demSamplingLon=Math.abs(dem.getGeoPos(new PixelPos(1,0)).getLon() - dem.getGeoPos(new PixelPos(0,0)).getLon());
      }
 catch (      Exception e) {
        throw new OperatorException(""String_Node_Str"" + demName + ""String_Node_Str"");
      }
    }
 else {
      dem=DEMFactory.createElevationModel(demName,demResamplingMethod);
      demNoDataValue=dem.getDescriptor().getNoDataValue();
      demSamplingLat=(double)dem.getDescriptor().getTileWidthInDegrees() / (double)dem.getDescriptor().getTileWidth();
      demSamplingLon=demSamplingLat;
    }
  }
 catch (  Throwable t) {
    SystemUtils.LOG.severe(""String_Node_Str"" + t.getMessage());
  }
  isElevationModelAvailable=true;
}"
11417,"private String writeStartTime(){
  double diff=srcProduct.getStartTime().getMJD() - dateDay.getMJD();
  double seconds=diff * daysToSeconds;
  return seconds + sep + ""String_Node_Str"";
}","private String writeStartTime(){
  double diff=srcProduct.getStartTime().getMJD() - dateDay.getMJD();
  double seconds=diff * daysToSeconds;
  return seconds + tab + ""String_Node_Str"";
}"
11418,"private String writeEndTime(){
  double diff=srcProduct.getEndTime().getMJD() - dateDay.getMJD();
  double seconds=diff * daysToSeconds;
  return seconds + sep + ""String_Node_Str"";
}","private String writeEndTime(){
  double diff=srcProduct.getEndTime().getMJD() - dateDay.getMJD();
  double seconds=diff * daysToSeconds;
  return seconds + tab + ""String_Node_Str"";
}"
11419,"private void writeOrbitStateVectors(final PrintStream p){
  final OrbitStateVector[] osvList=AbstractMetadata.getOrbitStateVectors(absRoot);
  if (osvList != null && osvList.length > 0) {
    double seconds=(osvList[0].time_mjd - dateDay.getMJD()) * daysToSeconds;
    double seconds2=(osvList[1].time_mjd - dateDay.getMJD()) * daysToSeconds;
    double interval=seconds2 - seconds;
    p.println(GammaConstants.HEADER_KEY_NUM_STATE_VECTORS + sep + osvList.length);
    p.println(GammaConstants.HEADER_KEY_TIME_FIRST_STATE_VECTORS + sep + seconds+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_STATE_VECTOR_INTERVAL + sep + interval+ sep+ ""String_Node_Str"");
    int num=1;
    for (    OrbitStateVector osv : osvList) {
      p.println(GammaConstants.HEADER_KEY_STATE_VECTOR_POSITION + '_' + num+ sep+ osv.x_pos+ sep+ osv.y_pos+ sep+ osv.z_pos+ sep+ ""String_Node_Str"");
      p.println(GammaConstants.HEADER_KEY_STATE_VECTOR_VELOCITY + '_' + num+ sep+ osv.x_vel+ sep+ osv.y_vel+ sep+ osv.z_vel+ sep+ ""String_Node_Str"");
      ++num;
    }
  }
}","private void writeOrbitStateVectors(final PrintStream p){
  final OrbitStateVector[] osvList=AbstractMetadata.getOrbitStateVectors(absRoot);
  if (osvList != null && osvList.length > 0) {
    double seconds=(osvList[0].time_mjd - dateDay.getMJD()) * daysToSeconds;
    double seconds2=(osvList[1].time_mjd - dateDay.getMJD()) * daysToSeconds;
    double interval=seconds2 - seconds;
    p.println(GammaConstants.HEADER_KEY_NUM_STATE_VECTORS + sep + osvList.length);
    p.println(GammaConstants.HEADER_KEY_TIME_FIRST_STATE_VECTORS + sep + seconds+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_STATE_VECTOR_INTERVAL + sep + interval+ tab+ ""String_Node_Str"");
    int num=1;
    for (    OrbitStateVector osv : osvList) {
      p.println(GammaConstants.HEADER_KEY_STATE_VECTOR_POSITION + '_' + num+ sep+ osv.x_pos+ tab+ osv.y_pos+ tab+ osv.z_pos+ tab+ ""String_Node_Str"");
      p.println(GammaConstants.HEADER_KEY_STATE_VECTOR_VELOCITY + '_' + num+ sep+ osv.x_vel+ tab+ osv.y_vel+ tab+ osv.z_vel+ tab+ ""String_Node_Str"");
      ++num;
    }
  }
}"
11420,"private String writeCenterTime(){
  double center=(srcProduct.getStartTime().getMJD() + (srcProduct.getEndTime().getMJD() - srcProduct.getStartTime().getMJD()) / 2.0);
  double seconds=(center - dateDay.getMJD()) * daysToSeconds;
  return seconds + sep + ""String_Node_Str"";
}","private String writeCenterTime(){
  double center=(srcProduct.getStartTime().getMJD() + (srcProduct.getEndTime().getMJD() - srcProduct.getStartTime().getMJD()) / 2.0);
  double seconds=(center - dateDay.getMJD()) * daysToSeconds;
  return seconds + tab + ""String_Node_Str"";
}"
11421,"void writeParFile() throws IOException {
  final String oldEOL=System.getProperty(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  final FileOutputStream out=new FileOutputStream(outputFile);
  try (final PrintStream p=new PrintStream(out)){
    p.println(GammaConstants.HEADER_KEY_NAME + sep + srcProduct.getName());
    p.println(GammaConstants.HEADER_KEY_SENSOR_TYPE + sep + absRoot.getAttributeString(AbstractMetadata.MISSION));
    p.println(GammaConstants.HEADER_KEY_DATE + sep + writeDate());
    p.println(GammaConstants.HEADER_KEY_START_TIME + sep + writeStartTime());
    p.println(GammaConstants.HEADER_KEY_CENTER_TIME + sep + writeCenterTime());
    p.println(GammaConstants.HEADER_KEY_END_TIME + sep + writeEndTime());
    p.println(GammaConstants.HEADER_KEY_LINE_TIME_INTERVAL + sep + absRoot.getAttributeString(AbstractMetadata.line_time_interval));
    p.println(GammaConstants.HEADER_KEY_SAMPLES + sep + srcProduct.getSceneRasterWidth());
    p.println(GammaConstants.HEADER_KEY_LINES + sep + srcProduct.getSceneRasterHeight());
    p.println(GammaConstants.HEADER_KEY_RANGE_LOOKS + sep + absRoot.getAttributeInt(AbstractMetadata.range_looks));
    p.println(GammaConstants.HEADER_KEY_AZIMUTH_LOOKS + sep + absRoot.getAttributeInt(AbstractMetadata.azimuth_looks));
    p.println(GammaConstants.HEADER_KEY_DATA_TYPE + sep + getDataType());
    p.println(GammaConstants.HEADER_KEY_IMAGE_GEOMETRY + sep + writeImageGeometry());
    writeCenterLatLon(p);
    p.println(GammaConstants.HEADER_KEY_RANGE_PIXEL_SPACING + sep + absRoot.getAttributeInt(AbstractMetadata.range_spacing)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_AZIMUTH_PIXEL_SPACING + sep + absRoot.getAttributeInt(AbstractMetadata.azimuth_spacing)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_RADAR_FREQUENCY + sep + absRoot.getAttributeString(AbstractMetadata.radar_frequency)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_PRF + sep + absRoot.getAttributeString(AbstractMetadata.pulse_repetition_frequency)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_AZIMUTH_PROC_BANDWIDTH + sep + absRoot.getAttributeString(AbstractMetadata.azimuth_bandwidth)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_NEAR_RANGE_SLC + sep + absRoot.getAttributeString(AbstractMetadata.slant_range_to_first_pixel)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_CENTER_RANGE_SLC + sep + absRoot.getAttributeString(AbstractMetadata.slant_range_to_first_pixel)+ sep+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_FAR_RANGE_SLC + sep + absRoot.getAttributeString(AbstractMetadata.slant_range_to_first_pixel)+ sep+ ""String_Node_Str"");
    writeOrbitStateVectors(p);
    p.flush();
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    System.setProperty(""String_Node_Str"",oldEOL);
  }
}","void writeParFile() throws IOException {
  final String oldEOL=System.getProperty(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  final FileOutputStream out=new FileOutputStream(outputFile);
  try (final PrintStream p=new PrintStream(out)){
    p.println(GammaConstants.HEADER_KEY_NAME + sep + srcProduct.getName());
    p.println(GammaConstants.HEADER_KEY_SENSOR_TYPE + sep + absRoot.getAttributeString(AbstractMetadata.MISSION));
    p.println(GammaConstants.HEADER_KEY_DATE + sep + writeDate());
    p.println(GammaConstants.HEADER_KEY_START_TIME + sep + writeStartTime());
    p.println(GammaConstants.HEADER_KEY_CENTER_TIME + sep + writeCenterTime());
    p.println(GammaConstants.HEADER_KEY_END_TIME + sep + writeEndTime());
    p.println(GammaConstants.HEADER_KEY_LINE_TIME_INTERVAL + sep + absRoot.getAttributeString(AbstractMetadata.line_time_interval));
    p.println(GammaConstants.HEADER_KEY_SAMPLES + sep + srcProduct.getSceneRasterWidth());
    p.println(GammaConstants.HEADER_KEY_LINES + sep + srcProduct.getSceneRasterHeight());
    p.println(GammaConstants.HEADER_KEY_RANGE_LOOKS + sep + absRoot.getAttributeInt(AbstractMetadata.range_looks));
    p.println(GammaConstants.HEADER_KEY_AZIMUTH_LOOKS + sep + absRoot.getAttributeInt(AbstractMetadata.azimuth_looks));
    p.println(GammaConstants.HEADER_KEY_DATA_TYPE + sep + getDataType());
    p.println(GammaConstants.HEADER_KEY_IMAGE_GEOMETRY + sep + writeImageGeometry());
    writeCenterLatLon(p);
    p.println(GammaConstants.HEADER_KEY_RANGE_PIXEL_SPACING + sep + absRoot.getAttributeInt(AbstractMetadata.range_spacing)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_AZIMUTH_PIXEL_SPACING + sep + absRoot.getAttributeInt(AbstractMetadata.azimuth_spacing)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_RADAR_FREQUENCY + sep + absRoot.getAttributeString(AbstractMetadata.radar_frequency)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_PRF + sep + absRoot.getAttributeString(AbstractMetadata.pulse_repetition_frequency)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_AZIMUTH_PROC_BANDWIDTH + sep + absRoot.getAttributeString(AbstractMetadata.azimuth_bandwidth)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_NEAR_RANGE_SLC + sep + absRoot.getAttributeString(AbstractMetadata.slant_range_to_first_pixel)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_CENTER_RANGE_SLC + sep + absRoot.getAttributeString(AbstractMetadata.slant_range_to_first_pixel)+ tab+ ""String_Node_Str"");
    p.println(GammaConstants.HEADER_KEY_FAR_RANGE_SLC + sep + absRoot.getAttributeString(AbstractMetadata.slant_range_to_first_pixel)+ tab+ ""String_Node_Str"");
    writeOrbitStateVectors(p);
    p.flush();
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + e.getMessage());
  }
 finally {
    System.setProperty(""String_Node_Str"",oldEOL);
  }
}"
11422,"private void writeCenterLatLon(final PrintStream p){
  GeoPos geoPos=srcProduct.getSceneGeoCoding().getGeoPos(new PixelPos(srcProduct.getSceneRasterWidth() / 2,srcProduct.getSceneRasterHeight() / 2),null);
  p.println(GammaConstants.HEADER_KEY_CENTER_LATITUDE + sep + geoPos.getLat()+ sep+ ""String_Node_Str"");
  p.println(GammaConstants.HEADER_KEY_CENTER_LONGITUDE + sep + geoPos.getLon()+ sep+ ""String_Node_Str"");
  GeoPos geoPos2=srcProduct.getSceneGeoCoding().getGeoPos(new PixelPos(srcProduct.getSceneRasterWidth() / 2,(srcProduct.getSceneRasterHeight() / 2) + 100),null);
  GeoUtils.DistanceHeading heading=GeoUtils.vincenty_inverse(geoPos.lat,geoPos.lon,geoPos2.lat,geoPos2.lon);
  p.println(GammaConstants.HEADER_KEY_HEADING + sep + heading.heading1+ sep+ ""String_Node_Str"");
}","private void writeCenterLatLon(final PrintStream p){
  GeoPos geoPos=srcProduct.getSceneGeoCoding().getGeoPos(new PixelPos(srcProduct.getSceneRasterWidth() / 2,srcProduct.getSceneRasterHeight() / 2),null);
  p.println(GammaConstants.HEADER_KEY_CENTER_LATITUDE + sep + geoPos.getLat()+ tab+ ""String_Node_Str"");
  p.println(GammaConstants.HEADER_KEY_CENTER_LONGITUDE + sep + geoPos.getLon()+ tab+ ""String_Node_Str"");
  GeoPos geoPos2=srcProduct.getSceneGeoCoding().getGeoPos(new PixelPos(srcProduct.getSceneRasterWidth() / 2,(srcProduct.getSceneRasterHeight() / 2) + 100),null);
  GeoUtils.DistanceHeading heading=GeoUtils.vincenty_inverse(geoPos.lat,geoPos.lon,geoPos2.lat,geoPos2.lon);
  p.println(GammaConstants.HEADER_KEY_HEADING + sep + heading.heading1+ tab+ ""String_Node_Str"");
}"
11423,"private Band getComplexSrcBand(final Band iBand){
  String name=iBand.getName();
  if (name.startsWith(""String_Node_Str"")) {
    name.replace(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (name.startsWith(""String_Node_Str"")) {
    name.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return srcProduct.getBand(name);
}","private Band getComplexSrcBand(final Band iBand){
  String name=iBand.getName();
  if (name.startsWith(""String_Node_Str"")) {
    name=name.replace(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (name.startsWith(""String_Node_Str"")) {
    name=name.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return srcProduct.getBand(name);
}"
11424,"private void computeExtendedAmount(final int x0,final int y0,final int w,final int h,final double[] extendedAmount) throws Exception {
  final GeoPos geoPos=new GeoPos();
  final PositionData posData=new PositionData();
  double azExtendedAmountMax=-Double.MAX_VALUE;
  double azExtendedAmountMin=Double.MAX_VALUE;
  double rgExtendedAmountMax=-Double.MAX_VALUE;
  double rgExtendedAmountMin=Double.MAX_VALUE;
  for (int y=y0; y < y0 + h; y+=20) {
    final int burstIndex=getBurstIndex(y);
    for (int x=x0; x < x0 + w; x+=20) {
      final double azTime=getAzimuthTime(y,burstIndex);
      final double rgTime=getSlantRangeTime(x);
      final double lat=mSU.getLatitude(azTime,rgTime,subSwathIndex);
      final double lon=mSU.getLongitude(azTime,rgTime,subSwathIndex);
      geoPos.setLocation(lat,lon);
      final double alt=dem.getElevation(geoPos);
      if (alt == demNoDataValue) {
        continue;
      }
      GeoUtils.geo2xyzWGS84(geoPos.getLat(),geoPos.getLon(),alt,posData.earthPoint);
      if (getPosition(subSwathIndex,burstIndex,mSU,mOrbit,posData)) {
        double azExtendedAmount=posData.azimuthIndex - y;
        double rgExtendedAmount=posData.rangeIndex - x;
        if (azExtendedAmount > azExtendedAmountMax) {
          azExtendedAmountMax=azExtendedAmount;
        }
        if (azExtendedAmount < azExtendedAmountMin) {
          azExtendedAmountMin=azExtendedAmount;
        }
        if (rgExtendedAmount > rgExtendedAmountMax) {
          rgExtendedAmountMax=rgExtendedAmount;
        }
        if (rgExtendedAmount < rgExtendedAmountMin) {
          rgExtendedAmountMin=rgExtendedAmount;
        }
      }
    }
  }
  if (azExtendedAmountMin != Double.MAX_VALUE && azExtendedAmountMin < 0.0) {
    extendedAmount[0]=azExtendedAmountMin;
  }
 else {
    extendedAmount[0]=0.0;
  }
  if (azExtendedAmountMax != -Double.MAX_VALUE && azExtendedAmountMax > 0.0) {
    extendedAmount[1]=azExtendedAmountMax;
  }
 else {
    extendedAmount[1]=0.0;
  }
  if (rgExtendedAmountMin != Double.MAX_VALUE && rgExtendedAmountMin < 0.0) {
    extendedAmount[2]=rgExtendedAmountMin;
  }
 else {
    extendedAmount[2]=0.0;
  }
  if (rgExtendedAmountMax != -Double.MAX_VALUE && rgExtendedAmountMax > 0.0) {
    extendedAmount[3]=rgExtendedAmountMax;
  }
 else {
    extendedAmount[3]=0.0;
  }
}","private void computeExtendedAmount(final int x0,final int y0,final int w,final int h,final double[] extendedAmount) throws Exception {
  final EarthGravitationalModel96 egm=EarthGravitationalModel96.instance();
  final GeoPos geoPos=new GeoPos();
  final PositionData posData=new PositionData();
  double azExtendedAmountMax=-Double.MAX_VALUE;
  double azExtendedAmountMin=Double.MAX_VALUE;
  double rgExtendedAmountMax=-Double.MAX_VALUE;
  double rgExtendedAmountMin=Double.MAX_VALUE;
  for (int y=y0; y < y0 + h; y+=20) {
    final int burstIndex=getBurstIndex(y);
    for (int x=x0; x < x0 + w; x+=20) {
      final double azTime=getAzimuthTime(y,burstIndex);
      final double rgTime=getSlantRangeTime(x);
      final double lat=mSU.getLatitude(azTime,rgTime,subSwathIndex);
      final double lon=mSU.getLongitude(azTime,rgTime,subSwathIndex);
      geoPos.setLocation(lat,lon);
      double alt=dem.getElevation(geoPos);
      if (alt == demNoDataValue) {
        alt=egm.getEGM(lat,lon);
      }
      GeoUtils.geo2xyzWGS84(geoPos.getLat(),geoPos.getLon(),alt,posData.earthPoint);
      if (getPosition(subSwathIndex,burstIndex,mSU,mOrbit,posData)) {
        double azExtendedAmount=posData.azimuthIndex - y;
        double rgExtendedAmount=posData.rangeIndex - x;
        if (azExtendedAmount > azExtendedAmountMax) {
          azExtendedAmountMax=azExtendedAmount;
        }
        if (azExtendedAmount < azExtendedAmountMin) {
          azExtendedAmountMin=azExtendedAmount;
        }
        if (rgExtendedAmount > rgExtendedAmountMax) {
          rgExtendedAmountMax=rgExtendedAmount;
        }
        if (rgExtendedAmount < rgExtendedAmountMin) {
          rgExtendedAmountMin=rgExtendedAmount;
        }
      }
    }
  }
  if (azExtendedAmountMin != Double.MAX_VALUE && azExtendedAmountMin < 0.0) {
    extendedAmount[0]=azExtendedAmountMin;
  }
 else {
    extendedAmount[0]=0.0;
  }
  if (azExtendedAmountMax != -Double.MAX_VALUE && azExtendedAmountMax > 0.0) {
    extendedAmount[1]=azExtendedAmountMax;
  }
 else {
    extendedAmount[1]=0.0;
  }
  if (rgExtendedAmountMin != Double.MAX_VALUE && rgExtendedAmountMin < 0.0) {
    extendedAmount[2]=rgExtendedAmountMin;
  }
 else {
    extendedAmount[2]=0.0;
  }
  if (rgExtendedAmountMax != -Double.MAX_VALUE && rgExtendedAmountMax > 0.0) {
    extendedAmount[3]=rgExtendedAmountMax;
  }
 else {
    extendedAmount[3]=0.0;
  }
}"
11425,"/** 
 * Compute Perform Freeman-Durden decomposition for given covariance matrix C3
 * @param Cr Real part of the covariance matrix
 * @param Ci Imaginary part of the covariance matrix
 * @return The Freeman-Durden decomposition result
 */
public static FDD getFreemanDurdenDecomposition(final double[][] Cr,final double[][] Ci){
  double fd, fv, fs, pd, pv, ps, c11, c13Re, c13Im, c33, alphaRe, alphaIm, betaRe, betaIm;
  fv=4.0 * Cr[1][1];
  c11=Cr[0][0] - fv * 3.0 / 8.0;
  c13Re=Cr[0][2] - fv / 8.0;
  c13Im=Ci[0][2];
  c33=Cr[2][2] - fv * 3.0 / 8.0;
  final double a1=c11 * c33;
  if (Math.abs(c11) <= Constants.EPS || Math.abs(c33) <= Constants.EPS) {
    fs=0.0;
    fd=0.0;
    alphaRe=0.0;
    alphaIm=0.0;
    betaRe=0.0;
    betaIm=0.0;
  }
 else {
    final double a2=c13Re * c13Re + c13Im * c13Im;
    if (a1 < a2) {
      final double c13=Math.sqrt(a2);
      c13Re=Math.sqrt(a1) * c13Re / c13;
      c13Im=Math.sqrt(a1) * c13Im / c13;
    }
    if (c13Re < 0.0) {
      betaRe=1.0;
      betaIm=0.0;
      fs=Math.abs((a1 - c13Re * c13Re - c13Im * c13Im) / (c11 + c33 - 2 * c13Re));
      fd=Math.abs(c33 - fs);
      alphaRe=(c13Re - fs) / fd;
      alphaIm=c13Im / fd;
    }
 else {
      alphaRe=-1.0;
      alphaIm=0.0;
      fd=Math.abs((a1 - c13Re * c13Re - c13Im * c13Im) / (c11 + c33 + 2 * c13Re));
      fs=Math.abs(c33 - fd);
      betaRe=(c13Re + fd) / fs;
      betaIm=c13Im / fs;
    }
  }
  ps=fs * (1 + betaRe * betaRe + betaIm * betaIm);
  pd=fd * (1 + alphaRe * alphaRe + alphaIm * alphaIm);
  pv=fv;
  return new FDD(pv,pd,ps);
}","/** 
 * Compute Perform Freeman-Durden decomposition for given covariance matrix C3
 * @param Cr Real part of the covariance matrix
 * @param Ci Imaginary part of the covariance matrix
 * @return The Freeman-Durden decomposition result
 */
public static FDD getFreemanDurdenDecomposition(final double[][] Cr,final double[][] Ci){
  double fd, fv, fs, pd, pv, ps, c11, c13Re, c13Im, c33, alphaRe, alphaIm, betaRe, betaIm;
  fv=4.0 * Cr[1][1];
  c11=Cr[0][0] - fv * 3.0 / 8.0;
  c13Re=Cr[0][2] - fv / 8.0;
  c13Im=Ci[0][2];
  c33=Cr[2][2] - fv * 3.0 / 8.0;
  final double a1=c11 * c33;
  if (c11 <= Constants.EPS || c33 <= Constants.EPS) {
    fs=0.0;
    fd=0.0;
    alphaRe=0.0;
    alphaIm=0.0;
    betaRe=0.0;
    betaIm=0.0;
  }
 else {
    final double a2=c13Re * c13Re + c13Im * c13Im;
    if (a1 < a2) {
      final double c13=Math.sqrt(a2);
      c13Re=Math.sqrt(a1) * c13Re / c13;
      c13Im=Math.sqrt(a1) * c13Im / c13;
    }
    if (c13Re < 0.0) {
      betaRe=1.0;
      betaIm=0.0;
      fs=Math.abs((a1 - c13Re * c13Re - c13Im * c13Im) / (c11 + c33 - 2 * c13Re));
      fd=Math.abs(c33 - fs);
      alphaRe=(c13Re - fs) / fd;
      alphaIm=c13Im / fd;
    }
 else {
      alphaRe=-1.0;
      alphaIm=0.0;
      fd=Math.abs((a1 - c13Re * c13Re - c13Im * c13Im) / (c11 + c33 + 2 * c13Re));
      fs=Math.abs(c33 - fd);
      betaRe=(c13Re + fd) / fs;
      betaIm=c13Im / fs;
    }
  }
  ps=fs * (1 + betaRe * betaRe + betaIm * betaIm);
  pd=fd * (1 + alphaRe * alphaRe + alphaIm * alphaIm);
  pv=fv;
  return new FDD(pv,pd,ps);
}"
11426,"public static double crossCorrelateFFT(double[] offset,ComplexDoubleMatrix master,ComplexDoubleMatrix mask,int ovsfactor,int AccL,int AccP){
  final int L=master.rows;
  final int P=master.columns;
  final int twoL=2 * L;
  final int twoP=2 * P;
  final int halfL=L / 2;
  final int halfP=P / 2;
  double offsetL;
  double offsetP;
  if (master.rows != mask.rows || master.columns != mask.columns) {
    logger.severe(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(MathUtils.isPower2(L) || MathUtils.isPower2(P))) {
    logger.severe(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!MathUtils.isPower2(ovsfactor)) {
    logger.severe(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"");
  DoubleMatrix magMaster=SarUtils.magnitude(master);
  DoubleMatrix magMask=SarUtils.magnitude(mask);
  magMaster.subi(magMaster.mean());
  magMask.subi(magMask.mean());
  ComplexDoubleMatrix master2=ComplexDoubleMatrix.zeros(twoL,twoP);
  ComplexDoubleMatrix mask2=ComplexDoubleMatrix.zeros(twoL,twoP);
  Window windef=new Window();
  Window win1=new Window(0,L - 1,0,P - 1);
  Window win2=new Window(halfL,halfL + L - 1,halfP,halfP + P - 1);
  LinearAlgebraUtils.setdata(master2,win1,new ComplexDoubleMatrix(magMaster),windef);
  LinearAlgebraUtils.setdata(mask2,win2,new ComplexDoubleMatrix(magMask),windef);
  SpectralUtils.fft2D_inplace(master2);
  SpectralUtils.fft2D_inplace(mask2);
  master2.conji();
  mask2.muli(master2);
  SpectralUtils.invfft2D_inplace(mask2);
  master2=ComplexDoubleMatrix.zeros(twoL,twoP);
  int l, p;
  for (l=L; l < twoL; ++l) {
    for (p=P; p < twoP; ++p) {
      double realPart=magMaster.get(twoL - 1 - l,twoP - 1 - p);
      double imagPart=magMask.get(l - L,p - P);
      ComplexDouble value=new ComplexDouble(FastMath.pow(realPart,2),FastMath.pow(imagPart,2));
      master2.put(l,p,value);
    }
  }
  ComplexDoubleMatrix BLOCK=new ComplexDoubleMatrix(0,0);
  if (BLOCK.rows != twoL || BLOCK.columns != twoP) {
    logger.info(""String_Node_Str"" + twoL + ""String_Node_Str""+ twoP+ ""String_Node_Str"");
    BLOCK.resize(twoL,twoP);
    for (l=halfL; l < halfL + L; ++l)     for (p=halfP; p < halfP + P; ++p)     BLOCK.put(l,p,new ComplexDouble(1,0));
    SpectralUtils.fft2D_inplace(BLOCK);
    BLOCK.conji();
  }
  SpectralUtils.fft2D_inplace(master2);
  master2.muli(BLOCK);
  SpectralUtils.invfft2D_inplace(master2);
  DoubleMatrix Covar=new DoubleMatrix(L + 1,P + 1);
  double maxCorr=-999.0f;
  long maxcorrL=0;
  long maxcorrP=0;
  ComplexDouble maskValueTemp;
  ComplexDouble master2ValueTemp;
  for (l=0; l <= L; ++l) {
    for (p=0; p <= P; ++p) {
      maskValueTemp=mask2.get(l,p);
      master2ValueTemp=master2.get(l,p);
      Covar.put(l,p,maskValueTemp.real() / Math.sqrt(master2ValueTemp.real() * master2ValueTemp.imag()));
      if (Covar.get(l,p) > maxCorr) {
        maxCorr=Covar.get(l,p);
        maxcorrL=l;
        maxcorrP=p;
      }
    }
  }
  offsetL=-halfL + maxcorrL;
  offsetP=-halfP + maxcorrP;
  logger.info(""String_Node_Str"" + offsetL + ""String_Node_Str""+ offsetP+ ""String_Node_Str""+ maxCorr+ ""String_Node_Str"");
  if (ovsfactor > 1) {
    if (maxcorrL < AccL) {
      logger.info(""String_Node_Str"");
      maxcorrL=AccL;
    }
    if (maxcorrP < AccP) {
      logger.info(""String_Node_Str"");
      maxcorrP=AccP;
    }
    if (maxcorrL > (L - AccL)) {
      logger.info(""String_Node_Str"");
      maxcorrL=L - AccL;
    }
    if (maxcorrP > (P - AccP)) {
      logger.info(""String_Node_Str"");
      maxcorrP=P - AccP;
    }
    Window win3=new Window(maxcorrL - AccL,maxcorrL + AccL - 1,maxcorrP - AccP,maxcorrP + AccP - 1);
    final DoubleMatrix chip=new DoubleMatrix((int)win3.lines(),(int)win3.pixels());
    LinearAlgebraUtils.setdata(chip,Covar,win3);
    DoubleMatrix chipOversampled=SarUtils.oversample(new ComplexDoubleMatrix(chip),ovsfactor,ovsfactor).getReal();
    int corrIndex=chipOversampled.argmax();
    if (corrIndex >= 0) {
      int offL=chipOversampled.indexColumns(corrIndex);
      int offP=chipOversampled.indexRows(corrIndex);
      maxCorr=chipOversampled.get(corrIndex);
      offsetL=-halfL + maxcorrL - AccL + (double)offL / (double)ovsfactor;
      offsetP=-halfP + maxcorrP - AccP + (double)offP / (double)ovsfactor;
    }
    logger.info(""String_Node_Str"" + ovsfactor);
    logger.info(""String_Node_Str"" + offsetL + ""String_Node_Str""+ offsetP+ ""String_Node_Str""+ maxCorr+ ""String_Node_Str"");
    logger.info(""String_Node_Str"" + offsetL + ""String_Node_Str""+ offsetP+ ""String_Node_Str""+ maxCorr+ ""String_Node_Str"");
  }
  offset[0]=offsetL;
  offset[1]=offsetP;
  return maxCorr;
}","public static double crossCorrelateFFT(double[] offset,ComplexDoubleMatrix master,ComplexDoubleMatrix mask,int ovsfactor,int AccL,int AccP){
  final int L=master.rows;
  final int P=master.columns;
  final int twoL=2 * L;
  final int twoP=2 * P;
  final int halfL=L / 2;
  final int halfP=P / 2;
  double offsetL;
  double offsetP;
  if (master.rows != mask.rows || master.columns != mask.columns) {
    logger.severe(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!(MathUtils.isPower2(L) || MathUtils.isPower2(P))) {
    logger.severe(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!MathUtils.isPower2(ovsfactor)) {
    logger.severe(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"");
  DoubleMatrix magMaster=SarUtils.magnitude(master);
  DoubleMatrix magMask=SarUtils.magnitude(mask);
  magMaster.subi(magMaster.mean());
  magMask.subi(magMask.mean());
  ComplexDoubleMatrix master2=ComplexDoubleMatrix.zeros(twoL,twoP);
  ComplexDoubleMatrix mask2=ComplexDoubleMatrix.zeros(twoL,twoP);
  Window windef=new Window();
  Window win1=new Window(0,L - 1,0,P - 1);
  Window win2=new Window(halfL,halfL + L - 1,halfP,halfP + P - 1);
  LinearAlgebraUtils.setdata(master2,win1,new ComplexDoubleMatrix(magMaster),windef);
  LinearAlgebraUtils.setdata(mask2,win2,new ComplexDoubleMatrix(magMask),windef);
  SpectralUtils.fft2D_inplace(master2);
  SpectralUtils.fft2D_inplace(mask2);
  master2.conji();
  mask2.muli(master2);
  SpectralUtils.invfft2D_inplace(mask2);
  master2=ComplexDoubleMatrix.zeros(twoL,twoP);
  int l, p;
  for (l=L; l < twoL; ++l) {
    for (p=P; p < twoP; ++p) {
      double realPart=magMaster.get(twoL - 1 - l,twoP - 1 - p);
      double imagPart=magMask.get(l - L,p - P);
      ComplexDouble value=new ComplexDouble(FastMath.pow(realPart,2),FastMath.pow(imagPart,2));
      master2.put(l,p,value);
    }
  }
  ComplexDoubleMatrix BLOCK=new ComplexDoubleMatrix(0,0);
  if (BLOCK.rows != twoL || BLOCK.columns != twoP) {
    logger.info(""String_Node_Str"" + twoL + ""String_Node_Str""+ twoP+ ""String_Node_Str"");
    BLOCK.resize(twoL,twoP);
    for (l=halfL; l < halfL + L; ++l)     for (p=halfP; p < halfP + P; ++p)     BLOCK.put(l,p,new ComplexDouble(1,0));
    SpectralUtils.fft2D_inplace(BLOCK);
    BLOCK.conji();
  }
  SpectralUtils.fft2D_inplace(master2);
  master2.muli(BLOCK);
  SpectralUtils.invfft2D_inplace(master2);
  DoubleMatrix Covar=new DoubleMatrix(L + 1,P + 1);
  double maxCorr=-999.0f;
  long maxcorrL=0;
  long maxcorrP=0;
  ComplexDouble maskValueTemp;
  ComplexDouble master2ValueTemp;
  for (l=0; l <= L; ++l) {
    for (p=0; p <= P; ++p) {
      maskValueTemp=mask2.get(l,p);
      master2ValueTemp=master2.get(l,p);
      Covar.put(l,p,maskValueTemp.real() / Math.sqrt(master2ValueTemp.real() * master2ValueTemp.imag()));
      if (Covar.get(l,p) > maxCorr) {
        maxCorr=Covar.get(l,p);
        maxcorrL=l;
        maxcorrP=p;
      }
    }
  }
  offsetL=-halfL + maxcorrL;
  offsetP=-halfP + maxcorrP;
  logger.info(""String_Node_Str"" + offsetL + ""String_Node_Str""+ offsetP+ ""String_Node_Str""+ maxCorr+ ""String_Node_Str"");
  if (ovsfactor > 1) {
    if (maxcorrL < AccL) {
      logger.info(""String_Node_Str"");
      maxcorrL=AccL;
    }
    if (maxcorrP < AccP) {
      logger.info(""String_Node_Str"");
      maxcorrP=AccP;
    }
    if (maxcorrL > (L - AccL)) {
      logger.info(""String_Node_Str"");
      maxcorrL=L - AccL;
    }
    if (maxcorrP > (P - AccP)) {
      logger.info(""String_Node_Str"");
      maxcorrP=P - AccP;
    }
    Window win3=new Window(maxcorrL - AccL,maxcorrL + AccL - 1,maxcorrP - AccP,maxcorrP + AccP - 1);
    final DoubleMatrix chip=new DoubleMatrix((int)win3.lines(),(int)win3.pixels());
    LinearAlgebraUtils.setdata(chip,Covar,win3);
    DoubleMatrix chipOversampled=SarUtils.oversample(new ComplexDoubleMatrix(chip),ovsfactor,ovsfactor).getReal();
    int corrIndex=chipOversampled.argmax();
    if (corrIndex >= 0) {
      int offP=chipOversampled.indexColumns(corrIndex);
      int offL=chipOversampled.indexRows(corrIndex);
      maxCorr=chipOversampled.get(corrIndex);
      offsetL=-halfL + maxcorrL - AccL + (double)offL / (double)ovsfactor;
      offsetP=-halfP + maxcorrP - AccP + (double)offP / (double)ovsfactor;
    }
    logger.info(""String_Node_Str"" + ovsfactor);
    logger.info(""String_Node_Str"" + offsetL + ""String_Node_Str""+ offsetP+ ""String_Node_Str""+ maxCorr+ ""String_Node_Str"");
    logger.info(""String_Node_Str"" + offsetL + ""String_Node_Str""+ offsetP+ ""String_Node_Str""+ maxCorr+ ""String_Node_Str"");
  }
  offset[0]=offsetL;
  offset[1]=offsetP;
  return maxCorr;
}"
11427,"public void focusLost(final FocusEvent e){
  Double pixM=0.0, pixD=0.0;
  try {
    pixD=Double.parseDouble(pixelSpacingInDegree.getText());
    if (pixD != pixDSaved) {
      pixM=SARGeocoding.getPixelSpacingInMeter(pixD);
      pixelSpacingInMeter.setText(String.valueOf(pixM));
      pixMSaved=pixM;
      pixDSaved=pixD;
    }
  }
 catch (  Exception ec) {
    pixM=0.0;
  }
}","public void focusLost(final FocusEvent e){
  Double pixM=0.0, pixD=0.0;
  try {
    pixD=Double.parseDouble(pixelSpacingInDegree.getText());
    if (Double.compare(pixD,pixDSaved) != 0) {
      pixM=SARGeocoding.getPixelSpacingInMeter(pixD);
      pixelSpacingInMeter.setText(String.valueOf(pixM));
      pixMSaved=pixM;
      pixDSaved=pixD;
    }
  }
 catch (  Exception ec) {
    pixM=0.0;
  }
}"
11428,"/** 
 * Update the abstracted metadata in the target product.
 */
private void updateAbstractedMetadata(){
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(targetProduct);
  absRoot.setAttributeUTC(AbstractMetadata.first_line_time,new ProductData.UTC(subSwathInfo[subSwathIndex - 1].burstFirstLineTime[firstBurstIndex - 1] / Constants.secondsInDay));
  absRoot.setAttributeUTC(AbstractMetadata.last_line_time,new ProductData.UTC(subSwathInfo[subSwathIndex - 1].burstLastLineTime[lastBurstIndex - 1] / Constants.secondsInDay));
  absRoot.setAttributeDouble(AbstractMetadata.line_time_interval,subSwathInfo[subSwathIndex - 1].azimuthTimeInterval);
  absRoot.setAttributeDouble(AbstractMetadata.slant_range_to_first_pixel,subSwathInfo[subSwathIndex - 1].slrTimeToFirstPixel * Constants.lightSpeed);
  absRoot.setAttributeDouble(AbstractMetadata.range_spacing,subSwathInfo[subSwathIndex - 1].rangePixelSpacing);
  absRoot.setAttributeDouble(AbstractMetadata.azimuth_spacing,subSwathInfo[subSwathIndex - 1].azimuthPixelSpacing);
  absRoot.setAttributeInt(AbstractMetadata.num_output_lines,subSwathInfo[subSwathIndex - 1].linesPerBurst * (lastBurstIndex - firstBurstIndex + 1));
  absRoot.setAttributeInt(AbstractMetadata.num_samples_per_line,subSwathInfo[subSwathIndex - 1].numOfSamples);
  final int cols=subSwathInfo[subSwathIndex - 1].latitude[0].length;
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_near_lat,subSwathInfo[subSwathIndex - 1].latitude[firstBurstIndex - 1][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_near_long,subSwathInfo[subSwathIndex - 1].longitude[firstBurstIndex - 1][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_far_lat,subSwathInfo[subSwathIndex - 1].latitude[firstBurstIndex - 1][cols - 1]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_far_long,subSwathInfo[subSwathIndex - 1].longitude[firstBurstIndex - 1][cols - 1]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_near_lat,subSwathInfo[subSwathIndex - 1].latitude[lastBurstIndex - 1][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_near_long,subSwathInfo[subSwathIndex - 1].longitude[lastBurstIndex - 1][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_far_lat,subSwathInfo[subSwathIndex - 1].latitude[lastBurstIndex - 1][cols - 1]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_far_long,subSwathInfo[subSwathIndex - 1].longitude[lastBurstIndex - 1][cols - 1]);
  final double incidenceNear=OperatorUtils.getIncidenceAngle(targetProduct).getPixelDouble(0,targetProduct.getSceneRasterHeight() / 2);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.incidence_near,incidenceNear);
  final double incidenceFar=OperatorUtils.getIncidenceAngle(targetProduct).getPixelDouble(targetProduct.getSceneRasterWidth() - 1,targetProduct.getSceneRasterHeight() / 2);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.incidence_far,incidenceFar);
  absRoot.setAttributeString(AbstractMetadata.swath,subswath);
  for (int i=0; i < selectedPolarisations.length; i++) {
    if (i == 0) {
      absRoot.setAttributeString(AbstractMetadata.mds1_tx_rx_polar,selectedPolarisations[i]);
    }
 else     if (i == 1) {
      absRoot.setAttributeString(AbstractMetadata.mds2_tx_rx_polar,selectedPolarisations[i]);
    }
 else     if (i == 2) {
      absRoot.setAttributeString(AbstractMetadata.mds3_tx_rx_polar,selectedPolarisations[i]);
    }
 else {
      absRoot.setAttributeString(AbstractMetadata.mds4_tx_rx_polar,selectedPolarisations[i]);
    }
  }
  final MetadataElement[] bandMetadataList=AbstractMetadata.getBandAbsMetadataList(absRoot);
  for (  MetadataElement bandMeta : bandMetadataList) {
    boolean include=false;
    if (bandMeta.getName().contains(subswath)) {
      for (      String pol : selectedPolarisations) {
        if (bandMeta.getName().contains(pol)) {
          include=true;
          break;
        }
      }
    }
    if (!include) {
      absRoot.removeElement(bandMeta);
    }
  }
}","/** 
 * Update the abstracted metadata in the target product.
 */
private void updateAbstractedMetadata(){
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(targetProduct);
  absRoot.setAttributeUTC(AbstractMetadata.first_line_time,new ProductData.UTC(subSwathInfo[subSwathIndex - 1].burstFirstLineTime[firstBurstIndex - 1] / Constants.secondsInDay));
  absRoot.setAttributeUTC(AbstractMetadata.last_line_time,new ProductData.UTC(subSwathInfo[subSwathIndex - 1].burstLastLineTime[lastBurstIndex - 1] / Constants.secondsInDay));
  absRoot.setAttributeDouble(AbstractMetadata.line_time_interval,subSwathInfo[subSwathIndex - 1].azimuthTimeInterval);
  absRoot.setAttributeDouble(AbstractMetadata.slant_range_to_first_pixel,subSwathInfo[subSwathIndex - 1].slrTimeToFirstPixel * Constants.lightSpeed);
  absRoot.setAttributeDouble(AbstractMetadata.range_spacing,subSwathInfo[subSwathIndex - 1].rangePixelSpacing);
  absRoot.setAttributeDouble(AbstractMetadata.azimuth_spacing,subSwathInfo[subSwathIndex - 1].azimuthPixelSpacing);
  absRoot.setAttributeInt(AbstractMetadata.num_output_lines,subSwathInfo[subSwathIndex - 1].linesPerBurst * (lastBurstIndex - firstBurstIndex + 1));
  absRoot.setAttributeInt(AbstractMetadata.num_samples_per_line,subSwathInfo[subSwathIndex - 1].numOfSamples);
  final int cols=subSwathInfo[subSwathIndex - 1].latitude[0].length;
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_near_lat,subSwathInfo[subSwathIndex - 1].latitude[firstBurstIndex - 1][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_near_long,subSwathInfo[subSwathIndex - 1].longitude[firstBurstIndex - 1][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_far_lat,subSwathInfo[subSwathIndex - 1].latitude[firstBurstIndex - 1][cols - 1]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_far_long,subSwathInfo[subSwathIndex - 1].longitude[firstBurstIndex - 1][cols - 1]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_near_lat,subSwathInfo[subSwathIndex - 1].latitude[lastBurstIndex][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_near_long,subSwathInfo[subSwathIndex - 1].longitude[lastBurstIndex][0]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_far_lat,subSwathInfo[subSwathIndex - 1].latitude[lastBurstIndex][cols - 1]);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_far_long,subSwathInfo[subSwathIndex - 1].longitude[lastBurstIndex][cols - 1]);
  final double incidenceNear=OperatorUtils.getIncidenceAngle(targetProduct).getPixelDouble(0,targetProduct.getSceneRasterHeight() / 2);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.incidence_near,incidenceNear);
  final double incidenceFar=OperatorUtils.getIncidenceAngle(targetProduct).getPixelDouble(targetProduct.getSceneRasterWidth() - 1,targetProduct.getSceneRasterHeight() / 2);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.incidence_far,incidenceFar);
  absRoot.setAttributeString(AbstractMetadata.swath,subswath);
  for (int i=0; i < selectedPolarisations.length; i++) {
    if (i == 0) {
      absRoot.setAttributeString(AbstractMetadata.mds1_tx_rx_polar,selectedPolarisations[i]);
    }
 else     if (i == 1) {
      absRoot.setAttributeString(AbstractMetadata.mds2_tx_rx_polar,selectedPolarisations[i]);
    }
 else     if (i == 2) {
      absRoot.setAttributeString(AbstractMetadata.mds3_tx_rx_polar,selectedPolarisations[i]);
    }
 else {
      absRoot.setAttributeString(AbstractMetadata.mds4_tx_rx_polar,selectedPolarisations[i]);
    }
  }
  final MetadataElement[] bandMetadataList=AbstractMetadata.getBandAbsMetadataList(absRoot);
  for (  MetadataElement bandMeta : bandMetadataList) {
    boolean include=false;
    if (bandMeta.getName().contains(subswath)) {
      for (      String pol : selectedPolarisations) {
        if (bandMeta.getName().contains(pol)) {
          include=true;
          break;
        }
      }
    }
    if (!include) {
      absRoot.removeElement(bandMeta);
    }
  }
}"
11429,"public ImageIOFile.BandInfo getBandInfo(final Band destBand){
  return bandMap.get(destBand);
}","public ImageIOFile.BandInfo getBandInfo(final Band destBand){
  ImageIOFile.BandInfo bandInfo=bandMap.get(destBand);
  if (bandInfo == null) {
    for (    Band srcBand : bandMap.keySet()) {
      if (srcBand.getName().equals(destBand.getName())) {
        bandInfo=bandMap.get(srcBand);
      }
    }
  }
  return bandInfo;
}"
11430,"private void updateGeolocationGrid(){
  final MetadataElement targetOrigProdRoot=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  MetadataElement[] elements=getElementsToUpdate(targetOrigProdRoot,""String_Node_Str"");
  for (  MetadataElement e : elements) {
    final String imageNum=extractImageNumber(e.getName());
    MetadataElement targetGeolocationGrid=e.getElement(""String_Node_Str"").getElement(""String_Node_Str"");
    MetadataElement targetGeolocationGridPointList=targetGeolocationGrid.getElement(""String_Node_Str"");
    int count=Integer.parseInt(targetGeolocationGridPointList.getAttributeString(""String_Node_Str""));
    int numberOfLines=0;
    for (int i=1; i < sliceProducts.length; i++) {
      MetadataElement sliceImageAnnotation=getAnnotationElement(sliceProducts[i],imageNum,""String_Node_Str"");
      MetadataElement sliceImageInformation=sliceImageAnnotation.getElement(""String_Node_Str"");
      numberOfLines+=Integer.parseInt(sliceImageInformation.getAttributeString(""String_Node_Str""));
      MetadataElement sliceGeolocationGrid=getAnnotationElement(sliceProducts[i],imageNum,""String_Node_Str"");
      MetadataElement sliceGeolocationGridPointList=sliceGeolocationGrid.getElement(""String_Node_Str"");
      final int sliceCount=Integer.parseInt(sliceGeolocationGridPointList.getAttributeString(""String_Node_Str""));
      if (sliceCount < 1) {
        continue;
      }
      MetadataElement[] sliceGeolocationGridPoints=sliceGeolocationGridPointList.getElements();
      for (      MetadataElement p : sliceGeolocationGridPoints) {
        MetadataElement newP=p.createDeepClone();
        final long sliceLine=Long.parseLong(p.getAttributeString(""String_Node_Str""));
        newP.setAttributeString(""String_Node_Str"",Long.toString(sliceLine + numberOfLines));
        targetGeolocationGridPointList.addElementAt(newP,count++);
      }
    }
    targetGeolocationGridPointList.setAttributeString(""String_Node_Str"",Integer.toString(count));
  }
}","private void updateGeolocationGrid(){
  final MetadataElement targetOrigProdRoot=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  MetadataElement[] elements=getElementsToUpdate(targetOrigProdRoot,""String_Node_Str"");
  for (  MetadataElement e : elements) {
    final String imageNum=extractImageNumber(e.getName());
    MetadataElement targetGeolocationGrid=e.getElement(""String_Node_Str"").getElement(""String_Node_Str"");
    MetadataElement targetGeolocationGridPointList=targetGeolocationGrid.getElement(""String_Node_Str"");
    int count=Integer.parseInt(targetGeolocationGridPointList.getAttributeString(""String_Node_Str""));
    MetadataElement sliceImageAnnotation=getAnnotationElement(sliceProducts[0],imageNum,""String_Node_Str"");
    MetadataElement sliceImageInformation=sliceImageAnnotation.getElement(""String_Node_Str"");
    int numberOfLines=Integer.parseInt(sliceImageInformation.getAttributeString(""String_Node_Str""));
    for (int i=1; i < sliceProducts.length; i++) {
      MetadataElement sliceGeolocationGrid=getAnnotationElement(sliceProducts[i],imageNum,""String_Node_Str"");
      MetadataElement sliceGeolocationGridPointList=sliceGeolocationGrid.getElement(""String_Node_Str"");
      final int sliceCount=Integer.parseInt(sliceGeolocationGridPointList.getAttributeString(""String_Node_Str""));
      if (sliceCount < 1) {
        continue;
      }
      MetadataElement[] sliceGeolocationGridPoints=sliceGeolocationGridPointList.getElements();
      for (      MetadataElement p : sliceGeolocationGridPoints) {
        MetadataElement newP=p.createDeepClone();
        final long sliceLine=Long.parseLong(p.getAttributeString(""String_Node_Str""));
        newP.setAttributeString(""String_Node_Str"",Long.toString(sliceLine + numberOfLines));
        targetGeolocationGridPointList.addElementAt(newP,count++);
      }
      sliceImageAnnotation=getAnnotationElement(sliceProducts[i],imageNum,""String_Node_Str"");
      sliceImageInformation=sliceImageAnnotation.getElement(""String_Node_Str"");
      numberOfLines+=Integer.parseInt(sliceImageInformation.getAttributeString(""String_Node_Str""));
    }
    targetGeolocationGridPointList.setAttributeString(""String_Node_Str"",Integer.toString(count));
  }
}"
11431,"@Override public void initialize() throws OperatorException {
  try {
    if (sourceProduct == null) {
      return;
    }
    if (sourceProduct.length < 2) {
      throw new OperatorException(""String_Node_Str"");
    }
    for (    final Product prod : sourceProduct) {
      final InputProductValidator validator=new InputProductValidator(prod);
      if (validator.isTOPSARProduct()) {
        throw new OperatorException(""String_Node_Str"");
      }
      if (prod.getSceneGeoCoding() == null) {
        throw new OperatorException(MessageFormat.format(""String_Node_Str"",prod.getName()));
      }
    }
    if (masterBandNames == null || masterBandNames.length == 0 || getMasterProduct(masterBandNames[0]) == null) {
      final Product defaultProd=sourceProduct[0];
      if (defaultProd != null) {
        final Band defaultBand=defaultProd.getBandAt(0);
        if (defaultBand != null) {
          if (defaultBand.getUnit() != null && defaultBand.getUnit().equals(Unit.REAL))           masterBandNames=new String[]{defaultProd.getBandAt(0).getName(),defaultProd.getBandAt(1).getName()};
 else           masterBandNames=new String[]{defaultBand.getName()};
        }
      }
      if (masterBandNames.length == 0) {
        targetProduct=OperatorUtils.createDummyTargetProduct(sourceProduct);
        return;
      }
    }
    masterProduct=getMasterProduct(masterBandNames[0]);
    if (masterProduct == null) {
      targetProduct=OperatorUtils.createDummyTargetProduct(sourceProduct);
      return;
    }
    appendToMaster=AbstractMetadata.getAbstractedMetadata(masterProduct).getAttributeInt(AbstractMetadata.coregistered_stack,0) == 1;
    final List<String> masterProductBands=new ArrayList<>(masterProduct.getNumBands());
    final Band[] slaveBandList=getSlaveBands();
    if (masterProduct == null || slaveBandList.length == 0 || slaveBandList[0] == null) {
      targetProduct=OperatorUtils.createDummyTargetProduct(sourceProduct);
      return;
    }
    if (resamplingType.contains(""String_Node_Str"") && !extent.equals(MASTER_EXTENT)) {
      throw new OperatorException(""String_Node_Str"");
    }
    if (appendToMaster) {
      extent=MASTER_EXTENT;
    }
switch (extent) {
case MASTER_EXTENT:
      targetProduct=new Product(masterProduct.getName(),masterProduct.getProductType(),masterProduct.getSceneRasterWidth(),masterProduct.getSceneRasterHeight());
    ProductUtils.copyProductNodes(masterProduct,targetProduct);
  break;
case MIN_EXTENT:
determinMinExtents();
break;
default :
determinMaxExtents();
break;
}
if (appendToMaster) {
for (Band b : masterProduct.getBands()) {
if (!(b instanceof VirtualBand)) {
final Band targetBand=new Band(b.getName(),b.getDataType(),targetProduct.getSceneRasterWidth(),targetProduct.getSceneRasterHeight());
ProductUtils.copyRasterDataNodeProperties(b,targetBand);
targetBand.setSourceImage(b.getSourceImage());
masterProductBands.add(b.getName());
sourceRasterMap.put(targetBand,b);
targetProduct.addBand(targetBand);
}
}
}
String suffix=""String_Node_Str"";
if (!appendToMaster) {
for (final Band srcBand : slaveBandList) {
if (srcBand == masterBands[0] || (masterBands.length > 1 && srcBand == masterBands[1])) {
suffix=""String_Node_Str"" + StackUtils.createBandTimeStamp(srcBand.getProduct());
final Band targetBand=new Band(srcBand.getName() + suffix,srcBand.getDataType(),targetProduct.getSceneRasterWidth(),targetProduct.getSceneRasterHeight());
ProductUtils.copyRasterDataNodeProperties(srcBand,targetBand);
if (extent.equals(MASTER_EXTENT)) {
targetBand.setSourceImage(srcBand.getSourceImage());
}
masterProductBands.add(targetBand.getName());
sourceRasterMap.put(targetBand,srcBand);
targetProduct.addBand(targetBand);
}
}
}
int cnt=1;
if (appendToMaster) {
for (Band trgBand : targetProduct.getBands()) {
final String name=trgBand.getName();
if (name.contains(""String_Node_Str"" + cnt)) ++cnt;
}
}
for (final Band srcBand : slaveBandList) {
if (!(srcBand == masterBands[0] || (masterBands.length > 1 && srcBand == masterBands[1]))) {
if (srcBand.getUnit() != null && srcBand.getUnit().equals(Unit.IMAGINARY)) {
}
 else {
suffix=""String_Node_Str"" + cnt++ + StackUtils.createBandTimeStamp(srcBand.getProduct());
}
final String tgtBandName=srcBand.getName() + suffix;
if (targetProduct.getBand(tgtBandName) == null) {
final Product srcProduct=srcBand.getProduct();
final Band targetBand=new Band(tgtBandName,srcBand.getDataType(),targetProduct.getSceneRasterWidth(),targetProduct.getSceneRasterHeight());
ProductUtils.copyRasterDataNodeProperties(srcBand,targetBand);
if (extent.equals(MASTER_EXTENT) && (srcProduct == masterProduct || srcProduct.isCompatibleProduct(targetProduct,1.0e-3f))) {
targetBand.setSourceImage(srcBand.getSourceImage());
}
if (srcBand.getProduct() == masterProduct) {
masterProductBands.add(tgtBandName);
}
sourceRasterMap.put(targetBand,srcBand);
targetProduct.addBand(targetBand);
}
}
}
copySlaveMetadata();
StackUtils.saveMasterProductBandNames(targetProduct,masterProductBands.toArray(new String[masterProductBands.size()]));
saveSlaveProductNames(targetProduct,sourceRasterMap);
updateMetadata();
final ProductNodeGroup<Placemark> masterGCPgroup=masterProduct.getGcpGroup();
if (masterGCPgroup.getNodeCount() > 0) {
OperatorUtils.copyGCPsToTarget(masterGCPgroup,GCPManager.instance().getGcpGroup(targetProduct.getBandAt(0)),targetProduct.getSceneGeoCoding());
}
if (!resamplingType.contains(""String_Node_Str"")) {
selectedResampling=ResamplingFactory.createResampling(resamplingType);
}
 else {
if (initialOffsetMethod.equals(INITIAL_OFFSET_GEOLOCATION)) {
computeTargetSlaveCoordinateOffsets_GCP();
}
if (initialOffsetMethod.equals(INITIAL_OFFSET_ORBIT)) {
computeTargetSlaveCoordinateOffsets_Orbits();
}
}
}
 catch (Throwable e) {
OperatorUtils.catchOperatorException(getId(),e);
}
}","@Override public void initialize() throws OperatorException {
  try {
    if (sourceProduct == null) {
      return;
    }
    if (sourceProduct.length < 2) {
      throw new OperatorException(""String_Node_Str"");
    }
    for (    final Product prod : sourceProduct) {
      final InputProductValidator validator=new InputProductValidator(prod);
      if (validator.isTOPSARProduct() && !validator.isDebursted()) {
        throw new OperatorException(""String_Node_Str"");
      }
      if (prod.getSceneGeoCoding() == null) {
        throw new OperatorException(MessageFormat.format(""String_Node_Str"",prod.getName()));
      }
    }
    if (masterBandNames == null || masterBandNames.length == 0 || getMasterProduct(masterBandNames[0]) == null) {
      final Product defaultProd=sourceProduct[0];
      if (defaultProd != null) {
        final Band defaultBand=defaultProd.getBandAt(0);
        if (defaultBand != null) {
          if (defaultBand.getUnit() != null && defaultBand.getUnit().equals(Unit.REAL))           masterBandNames=new String[]{defaultProd.getBandAt(0).getName(),defaultProd.getBandAt(1).getName()};
 else           masterBandNames=new String[]{defaultBand.getName()};
        }
      }
      if (masterBandNames.length == 0) {
        targetProduct=OperatorUtils.createDummyTargetProduct(sourceProduct);
        return;
      }
    }
    masterProduct=getMasterProduct(masterBandNames[0]);
    if (masterProduct == null) {
      targetProduct=OperatorUtils.createDummyTargetProduct(sourceProduct);
      return;
    }
    appendToMaster=AbstractMetadata.getAbstractedMetadata(masterProduct).getAttributeInt(AbstractMetadata.coregistered_stack,0) == 1;
    final List<String> masterProductBands=new ArrayList<>(masterProduct.getNumBands());
    final Band[] slaveBandList=getSlaveBands();
    if (masterProduct == null || slaveBandList.length == 0 || slaveBandList[0] == null) {
      targetProduct=OperatorUtils.createDummyTargetProduct(sourceProduct);
      return;
    }
    if (resamplingType.contains(""String_Node_Str"") && !extent.equals(MASTER_EXTENT)) {
      throw new OperatorException(""String_Node_Str"");
    }
    if (appendToMaster) {
      extent=MASTER_EXTENT;
    }
switch (extent) {
case MASTER_EXTENT:
      targetProduct=new Product(masterProduct.getName(),masterProduct.getProductType(),masterProduct.getSceneRasterWidth(),masterProduct.getSceneRasterHeight());
    ProductUtils.copyProductNodes(masterProduct,targetProduct);
  break;
case MIN_EXTENT:
determinMinExtents();
break;
default :
determinMaxExtents();
break;
}
if (appendToMaster) {
for (Band b : masterProduct.getBands()) {
if (!(b instanceof VirtualBand)) {
final Band targetBand=new Band(b.getName(),b.getDataType(),targetProduct.getSceneRasterWidth(),targetProduct.getSceneRasterHeight());
ProductUtils.copyRasterDataNodeProperties(b,targetBand);
targetBand.setSourceImage(b.getSourceImage());
masterProductBands.add(b.getName());
sourceRasterMap.put(targetBand,b);
targetProduct.addBand(targetBand);
}
}
}
String suffix=""String_Node_Str"";
if (!appendToMaster) {
for (final Band srcBand : slaveBandList) {
if (srcBand == masterBands[0] || (masterBands.length > 1 && srcBand == masterBands[1])) {
suffix=""String_Node_Str"" + StackUtils.createBandTimeStamp(srcBand.getProduct());
final Band targetBand=new Band(srcBand.getName() + suffix,srcBand.getDataType(),targetProduct.getSceneRasterWidth(),targetProduct.getSceneRasterHeight());
ProductUtils.copyRasterDataNodeProperties(srcBand,targetBand);
if (extent.equals(MASTER_EXTENT)) {
targetBand.setSourceImage(srcBand.getSourceImage());
}
masterProductBands.add(targetBand.getName());
sourceRasterMap.put(targetBand,srcBand);
targetProduct.addBand(targetBand);
}
}
}
int cnt=1;
if (appendToMaster) {
for (Band trgBand : targetProduct.getBands()) {
final String name=trgBand.getName();
if (name.contains(""String_Node_Str"" + cnt)) ++cnt;
}
}
for (final Band srcBand : slaveBandList) {
if (!(srcBand == masterBands[0] || (masterBands.length > 1 && srcBand == masterBands[1]))) {
if (srcBand.getUnit() != null && srcBand.getUnit().equals(Unit.IMAGINARY)) {
}
 else {
suffix=""String_Node_Str"" + cnt++ + StackUtils.createBandTimeStamp(srcBand.getProduct());
}
final String tgtBandName=srcBand.getName() + suffix;
if (targetProduct.getBand(tgtBandName) == null) {
final Product srcProduct=srcBand.getProduct();
final Band targetBand=new Band(tgtBandName,srcBand.getDataType(),targetProduct.getSceneRasterWidth(),targetProduct.getSceneRasterHeight());
ProductUtils.copyRasterDataNodeProperties(srcBand,targetBand);
if (extent.equals(MASTER_EXTENT) && (srcProduct == masterProduct || srcProduct.isCompatibleProduct(targetProduct,1.0e-3f))) {
targetBand.setSourceImage(srcBand.getSourceImage());
}
if (srcBand.getProduct() == masterProduct) {
masterProductBands.add(tgtBandName);
}
sourceRasterMap.put(targetBand,srcBand);
targetProduct.addBand(targetBand);
}
}
}
copySlaveMetadata();
StackUtils.saveMasterProductBandNames(targetProduct,masterProductBands.toArray(new String[masterProductBands.size()]));
saveSlaveProductNames(targetProduct,sourceRasterMap);
updateMetadata();
final ProductNodeGroup<Placemark> masterGCPgroup=masterProduct.getGcpGroup();
if (masterGCPgroup.getNodeCount() > 0) {
OperatorUtils.copyGCPsToTarget(masterGCPgroup,GCPManager.instance().getGcpGroup(targetProduct.getBandAt(0)),targetProduct.getSceneGeoCoding());
}
if (!resamplingType.contains(""String_Node_Str"")) {
selectedResampling=ResamplingFactory.createResampling(resamplingType);
}
 else {
if (initialOffsetMethod.equals(INITIAL_OFFSET_GEOLOCATION)) {
computeTargetSlaveCoordinateOffsets_GCP();
}
if (initialOffsetMethod.equals(INITIAL_OFFSET_ORBIT)) {
computeTargetSlaveCoordinateOffsets_Orbits();
}
}
}
 catch (Throwable e) {
OperatorUtils.catchOperatorException(getId(),e);
}
}"
11432,"public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm){
  try {
    final Rectangle targetTileRectangle=targetTile.getRectangle();
    final int x0=targetTileRectangle.x;
    final int y0=targetTileRectangle.y;
    final int w=targetTileRectangle.width;
    final int h=targetTileRectangle.height;
    final int xMax=x0 + w;
    final int yMax=y0 + h;
    System.out.println(""String_Node_Str"" + x0 + ""String_Node_Str""+ y0+ ""String_Node_Str""+ w+ ""String_Node_Str""+ h);
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    final double[][] filteredTile=performFiltering(x0,y0,w,h,srcBandNames);
    final ProductData tgtData=targetTile.getDataBuffer();
    final TileIndex tgtIndex=new TileIndex(targetTile);
    for (int y=y0; y < yMax; ++y) {
      tgtIndex.calculateStride(y);
      final int yy=y - y0;
      for (int x=x0; x < xMax; ++x) {
        tgtData.setElemDoubleAt(tgtIndex.getIndex(x),filteredTile[yy][x - x0]);
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
 finally {
    pm.done();
  }
}","public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm){
  try {
    final Rectangle targetTileRectangle=targetTile.getRectangle();
    final int x0=targetTileRectangle.x;
    final int y0=targetTileRectangle.y;
    final int w=targetTileRectangle.width;
    final int h=targetTileRectangle.height;
    final int xMax=x0 + w;
    final int yMax=y0 + h;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    final double[][] filteredTile=performFiltering(x0,y0,w,h,srcBandNames);
    final ProductData tgtData=targetTile.getDataBuffer();
    final TileIndex tgtIndex=new TileIndex(targetTile);
    for (int y=y0; y < yMax; ++y) {
      tgtIndex.calculateStride(y);
      final int yy=y - y0;
      for (int x=x0; x < xMax; ++x) {
        tgtData.setElemDoubleAt(tgtIndex.getIndex(x),filteredTile[yy][x - x0]);
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
 finally {
    pm.done();
  }
}"
11433,"/** 
 * Find all pixels in the adaptive neighbourhood of a given pixel.
 * @param xc         X coordinate of the given pixel
 * @param yc         Y coordinate of the given pixel
 * @param sx0        X coordinate of the pixel at the upper left corner of the source rectangle
 * @param sy0        Y coordinate of the pixel at the upper left corner of the source rectangle
 * @param sw         Width of the source rectangle
 * @param sh         Height of the source rectangle
 * @param srcTileIntensity Source tile intensity.
 * @param noDataValue      Place holder for no data value.
 * @param seed       The initial seed value
 * @return anPixelList List of pixels in the adaptive neighbourhood
 */
private Pix[] getIDANPixels(final int xc,final int yc,final int sx0,final int sy0,final int sw,final int sh,final double[][] srcTileIntensity,final double noDataValue,final double seed){
  final double threshold50=(2 / 3) * sigmaV;
  final java.util.List<Pix> anPixelList=new ArrayList<>(anSize);
  final Pix[] bgPixelList=regionGrowing(xc,yc,sx0,sy0,sw,sh,srcTileIntensity,noDataValue,seed,threshold50,anPixelList);
  double newSeed=0.0;
  if (!anPixelList.isEmpty()) {
    for (    Pix pixel : anPixelList) {
      newSeed+=srcTileIntensity[pixel.y - sy0][pixel.x - sx0];
    }
    newSeed/=anPixelList.size();
  }
 else {
    newSeed=seed;
  }
  final double threshold95=2 * sigmaV;
  reExamBackgroundPixels(sx0,sy0,srcTileIntensity,noDataValue,newSeed,threshold95,anPixelList,bgPixelList);
  if (anPixelList.isEmpty()) {
    return new Pix[]{new Pix(xc,yc)};
  }
  return anPixelList.toArray(new Pix[anPixelList.size()]);
}","/** 
 * Find all pixels in the adaptive neighbourhood of a given pixel.
 * @param xc         X coordinate of the given pixel
 * @param yc         Y coordinate of the given pixel
 * @param sx0        X coordinate of the pixel at the upper left corner of the source rectangle
 * @param sy0        Y coordinate of the pixel at the upper left corner of the source rectangle
 * @param sw         Width of the source rectangle
 * @param sh         Height of the source rectangle
 * @param srcTileIntensity Source tile intensity.
 * @param noDataValue      Place holder for no data value.
 * @param seed       The initial seed value
 * @return anPixelList List of pixels in the adaptive neighbourhood
 */
private Pix[] getIDANPixels(final int xc,final int yc,final int sx0,final int sy0,final int sw,final int sh,final double[][] srcTileIntensity,final double noDataValue,final double seed){
  final double threshold50=(2.0 / 3.0) * sigmaV;
  final java.util.List<Pix> anPixelList=new ArrayList<>(anSize);
  final Pix[] bgPixelList=regionGrowing(xc,yc,sx0,sy0,sw,sh,srcTileIntensity,noDataValue,seed,threshold50,anPixelList);
  double newSeed=0.0;
  if (!anPixelList.isEmpty()) {
    for (    Pix pixel : anPixelList) {
      newSeed+=srcTileIntensity[pixel.y - sy0][pixel.x - sx0];
    }
    newSeed/=anPixelList.size();
  }
 else {
    newSeed=seed;
  }
  final double threshold95=2.0 * sigmaV;
  reExamBackgroundPixels(sx0,sy0,srcTileIntensity,noDataValue,newSeed,threshold95,anPixelList,bgPixelList);
  if (anPixelList.isEmpty()) {
    return new Pix[]{new Pix(xc,yc)};
  }
  return anPixelList.toArray(new Pix[anPixelList.size()]);
}"
11434,"private void getComplexMasterImagette(final ComplexCoregData compleData,final PixelPos gcpPixelPos){
  compleData.mII=new double[compleData.fWindowHeight][compleData.fWindowWidth];
  compleData.mIQ=new double[compleData.fWindowHeight][compleData.fWindowWidth];
  final int x0=(int)gcpPixelPos.x;
  final int y0=(int)gcpPixelPos.y;
  final int xul=x0 - compleData.fHalfWindowWidth + 1;
  final int yul=y0 - compleData.fHalfWindowHeight + 1;
  final Rectangle masterImagetteRectangle=new Rectangle(xul,yul,compleData.fWindowWidth,compleData.fWindowHeight);
  final Tile masterImagetteRaster1=getSourceTile(masterBand1,masterImagetteRectangle);
  final Tile masterImagetteRaster2=getSourceTile(masterBand2,masterImagetteRectangle);
  final ProductData masterData1=masterImagetteRaster1.getDataBuffer();
  final ProductData masterData2=masterImagetteRaster2.getDataBuffer();
  final TileIndex index=new TileIndex(masterImagetteRaster1);
  final double[][] mIIdata=compleData.mII;
  final double[][] mIQdata=compleData.mIQ;
  for (int j=0; j < compleData.fWindowHeight; j++) {
    index.calculateStride(yul + j);
    for (int i=0; i < compleData.fWindowWidth; i++) {
      final int idx=index.getIndex(xul + i);
      mIIdata[j][i]=masterData1.getElemDoubleAt(idx);
      mIQdata[j][i]=masterData2.getElemDoubleAt(idx);
    }
  }
  masterData1.dispose();
  masterData2.dispose();
}","private void getComplexMasterImagette(final ComplexCoregData complexData,final PixelPos gcpPixelPos){
  complexData.mII=new double[complexData.fWindowHeight][complexData.fWindowWidth];
  complexData.mIQ=new double[complexData.fWindowHeight][complexData.fWindowWidth];
  final int x0=(int)gcpPixelPos.x;
  final int y0=(int)gcpPixelPos.y;
  final int xul=x0 - complexData.fHalfWindowWidth + 1;
  final int yul=y0 - complexData.fHalfWindowHeight + 1;
  final Rectangle masterImagetteRectangle=new Rectangle(xul,yul,complexData.fWindowWidth,complexData.fWindowHeight);
  final Tile masterImagetteRaster1=getSourceTile(masterBand1,masterImagetteRectangle);
  final Tile masterImagetteRaster2=getSourceTile(masterBand2,masterImagetteRectangle);
  final ProductData masterData1=masterImagetteRaster1.getDataBuffer();
  final ProductData masterData2=masterImagetteRaster2.getDataBuffer();
  final TileIndex index=new TileIndex(masterImagetteRaster1);
  final double[][] mIIdata=complexData.mII;
  final double[][] mIQdata=complexData.mIQ;
  for (int j=0; j < complexData.fWindowHeight; j++) {
    index.calculateStride(yul + j);
    for (int i=0; i < complexData.fWindowWidth; i++) {
      final int idx=index.getIndex(xul + i);
      mIIdata[j][i]=masterData1.getElemDoubleAt(idx);
      mIQdata[j][i]=masterData2.getElemDoubleAt(idx);
    }
  }
  masterData1.dispose();
  masterData2.dispose();
}"
11435,"private static double computeCoherence(final ComplexCoregData compleData,final double a,final double[] p,final double[] d){
  final double[] point={p[0] + a * d[0],p[1] + a * d[1]};
  return computeCoherence(compleData,point);
}","private static double computeCoherence(final ComplexCoregData complexData,final double a,final double[] p,final double[] d){
  final double[] point={p[0] + a * d[0],p[1] + a * d[1]};
  return computeCoherence(complexData,point);
}"
11436,"private static double getCoherence(final ComplexCoregData compleData,final int row,final int col,final int coherenceWindowWidth,final int coherenceWindowHeight){
  double sum1=0.0;
  double sum2=0.0;
  double sum3=0.0;
  double sum4=0.0;
  double mr, mi, sr, si;
  final double[][] mIIdata=compleData.mII;
  final double[][] mIQdata=compleData.mIQ;
  final double[][] sIIdata=compleData.sII;
  final double[][] sIQdata=compleData.sIQ;
  double[] mII, mIQ, sII, sIQ;
  int rIdx, cIdx;
  for (int r=0; r < coherenceWindowHeight; r++) {
    rIdx=row + r;
    mII=mIIdata[rIdx];
    mIQ=mIQdata[rIdx];
    sII=sIIdata[rIdx];
    sIQ=sIQdata[rIdx];
    for (int c=0; c < coherenceWindowWidth; c++) {
      cIdx=col + c;
      mr=mII[cIdx];
      mi=mIQ[cIdx];
      sr=sII[cIdx];
      si=sIQ[cIdx];
      sum1+=mr * sr + mi * si;
      sum2+=mi * sr - mr * si;
      sum3+=mr * mr + mi * mi;
      sum4+=sr * sr + si * si;
    }
  }
  return Math.sqrt(sum1 * sum1 + sum2 * sum2) / Math.sqrt(sum3 * sum4);
}","private static double getCoherence(final ComplexCoregData complexData,final int row,final int col,final int coherenceWindowWidth,final int coherenceWindowHeight){
  double sum1=0.0;
  double sum2=0.0;
  double sum3=0.0;
  double sum4=0.0;
  double mr, mi, sr, si;
  final double[][] mIIdata=complexData.mII;
  final double[][] mIQdata=complexData.mIQ;
  final double[][] sIIdata=complexData.sII;
  final double[][] sIQdata=complexData.sIQ;
  double[] mII, mIQ, sII, sIQ;
  int rIdx, cIdx;
  for (int r=0; r < coherenceWindowHeight; r++) {
    rIdx=row + r;
    mII=mIIdata[rIdx];
    mIQ=mIQdata[rIdx];
    sII=sIIdata[rIdx];
    sIQ=sIQdata[rIdx];
    for (int c=0; c < coherenceWindowWidth; c++) {
      cIdx=col + c;
      mr=mII[cIdx];
      mi=mIQ[cIdx];
      sr=sII[cIdx];
      si=sIQ[cIdx];
      sum1+=mr * sr + mi * si;
      sum2+=mi * sr - mr * si;
      sum3+=mr * mr + mi * mi;
      sum4+=sr * sr + si * si;
    }
  }
  return Math.sqrt(sum1 * sum1 + sum2 * sum2) / Math.sqrt(sum3 * sum4);
}"
11437,"private void getInitialComplexSlaveImagette(final ComplexCoregData compleData,final Band slaveBand1,final Band slaveBand2,final PixelPos sGCPPixelPos){
  compleData.sII0=new double[compleData.fWindowHeight][compleData.fWindowWidth];
  compleData.sIQ0=new double[compleData.fWindowHeight][compleData.fWindowWidth];
  final int x0=(int)(sGCPPixelPos.x + 0.5);
  final int y0=(int)(sGCPPixelPos.y + 0.5);
  compleData.point0[0]=sGCPPixelPos.x;
  compleData.point0[1]=sGCPPixelPos.y;
  final int xul=x0 - compleData.fHalfWindowWidth + 1;
  final int yul=y0 - compleData.fHalfWindowHeight + 1;
  final Rectangle slaveImagetteRectangle=new Rectangle(xul,yul,compleData.fWindowWidth,compleData.fWindowHeight);
  final Tile slaveImagetteRaster1=getSourceTile(slaveBand1,slaveImagetteRectangle);
  final Tile slaveImagetteRaster2=getSourceTile(slaveBand2,slaveImagetteRectangle);
  final ProductData slaveData1=slaveImagetteRaster1.getDataBuffer();
  final ProductData slaveData2=slaveImagetteRaster2.getDataBuffer();
  final TileIndex index=new TileIndex(slaveImagetteRaster1);
  final double[][] sII0data=compleData.sII0;
  final double[][] sIQ0data=compleData.sIQ0;
  for (int j=0; j < compleData.fWindowHeight; j++) {
    index.calculateStride(yul + j);
    for (int i=0; i < compleData.fWindowWidth; i++) {
      final int idx=index.getIndex(xul + i);
      sII0data[j][i]=slaveData1.getElemDoubleAt(idx);
      sIQ0data[j][i]=slaveData2.getElemDoubleAt(idx);
    }
  }
  slaveData1.dispose();
  slaveData2.dispose();
}","private void getInitialComplexSlaveImagette(final ComplexCoregData complexData,final Band slaveBand1,final Band slaveBand2,final PixelPos sGCPPixelPos){
  complexData.sII0=new double[complexData.fWindowHeight][complexData.fWindowWidth];
  complexData.sIQ0=new double[complexData.fWindowHeight][complexData.fWindowWidth];
  complexData.point0[0]=sGCPPixelPos.x;
  complexData.point0[1]=sGCPPixelPos.y;
  final double[][] sII0data=complexData.sII0;
  final double[][] sIQ0data=complexData.sIQ0;
  final double[][] tmpI=new double[complexData.fWindowHeight][complexData.fWindowWidth];
  final double[][] tmpQ=new double[complexData.fWindowHeight][complexData.fWindowWidth];
  final int x0=(int)(sGCPPixelPos.x + 0.5);
  final int y0=(int)(sGCPPixelPos.y + 0.5);
  final int xul=x0 - complexData.fHalfWindowWidth + 1;
  final int yul=y0 - complexData.fHalfWindowHeight + 1;
  final Rectangle slaveImagetteRectangle=new Rectangle(xul,yul,complexData.fWindowWidth,complexData.fWindowHeight);
  final Tile slaveImagetteRaster1=getSourceTile(slaveBand1,slaveImagetteRectangle);
  final Tile slaveImagetteRaster2=getSourceTile(slaveBand2,slaveImagetteRectangle);
  final ProductData slaveData1=slaveImagetteRaster1.getDataBuffer();
  final ProductData slaveData2=slaveImagetteRaster2.getDataBuffer();
  final TileIndex index=new TileIndex(slaveImagetteRaster1);
  for (int j=0; j < complexData.fWindowHeight; j++) {
    index.calculateStride(yul + j);
    for (int i=0; i < complexData.fWindowWidth; i++) {
      final int idx=index.getIndex(xul + i);
      tmpI[j][i]=slaveData1.getElemDoubleAt(idx);
      tmpQ[j][i]=slaveData2.getElemDoubleAt(idx);
    }
  }
  slaveData1.dispose();
  slaveData2.dispose();
  final double xShift=sGCPPixelPos.x - x0;
  final double yShift=sGCPPixelPos.y - y0;
  getShiftedData(complexData,tmpI,tmpQ,xShift,yShift,sII0data,sIQ0data);
}"
11438,"/** 
 * Compute noise LUTs for the given range line.
 * @param y         Index of the given range line.
 * @param x0        X coordinate of the upper left corner pixel of the given tile.
 * @param y0        Y coordinate of the upper left corner pixel of the given tile.
 * @param w         Tile width.
 * @param noiseInfo Object of ThermalNoiseInfo class.
 * @param lut       The noise LUT.
 */
private static void computeTileNoiseLUT(final int y,final int x0,final int y0,final int w,final ThermalNoiseInfo noiseInfo,final double[] lut){
  try {
    final int noiseVecIdx=getNoiseVectorIndex(y0,noiseInfo);
    final Sentinel1Utils.NoiseVector noiseVector0=noiseInfo.noiseVectorList[noiseVecIdx];
    final Sentinel1Utils.NoiseVector noiseVector1=noiseInfo.noiseVectorList[noiseVecIdx + 1];
    final double azTime=noiseInfo.firstLineTime + y * noiseInfo.lineTimeInterval;
    final double azT0=noiseVector0.timeMJD;
    final double azT1=noiseVector1.timeMJD;
    final double muY=(azTime - azT0) / (azT1 - azT0);
    int pixelIdx0=getPixelIndex(x0,noiseVector0);
    int pixelIdx1=getPixelIndex(x0,noiseVector1);
    final int maxLength0=noiseVector0.pixels.length - 2;
    final int maxLength1=noiseVector1.pixels.length - 2;
    final int maxX=x0 + w;
    for (int x=x0; x < maxX; x++) {
      if (x > noiseVector0.pixels[pixelIdx0 + 1] && pixelIdx0 < maxLength0) {
        pixelIdx0++;
      }
      final int x00=noiseVector0.pixels[pixelIdx0];
      final int x01=noiseVector0.pixels[pixelIdx0 + 1];
      final double muX0=(double)(x - x00) / (double)(x01 - x00);
      final double noise0=Maths.interpolationLinear(noiseVector0.noiseLUT[pixelIdx0],noiseVector0.noiseLUT[pixelIdx0 + 1],muX0);
      if (x > noiseVector1.pixels[pixelIdx1 + 1] && pixelIdx1 < maxLength1) {
        pixelIdx1++;
      }
      final int x10=noiseVector1.pixels[pixelIdx1];
      final int x11=noiseVector1.pixels[pixelIdx1 + 1];
      final double muX1=(double)(x - x10) / (double)(x11 - x10);
      final double noise1=Maths.interpolationLinear(noiseVector1.noiseLUT[pixelIdx1],noiseVector1.noiseLUT[pixelIdx1 + 1],muX1);
      lut[x - x0]=Maths.interpolationLinear(noise0,noise1,muY);
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
}","/** 
 * Compute noise LUTs for the given range line.
 * @param y         Index of the given range line.
 * @param x0        X coordinate of the upper left corner pixel of the given tile.
 * @param w         Tile width.
 * @param noiseInfo Object of ThermalNoiseInfo class.
 * @param lut       The noise LUT.
 */
private static void computeTileNoiseLUT(final int y,final int x0,final int w,final ThermalNoiseInfo noiseInfo,final double[] lut){
  try {
    final int noiseVecIdx=getNoiseVectorIndex(y,noiseInfo);
    final Sentinel1Utils.NoiseVector noiseVector0=noiseInfo.noiseVectorList[noiseVecIdx];
    final Sentinel1Utils.NoiseVector noiseVector1=noiseInfo.noiseVectorList[noiseVecIdx + 1];
    final double azTime=noiseInfo.firstLineTime + y * noiseInfo.lineTimeInterval;
    final double azT0=noiseVector0.timeMJD;
    final double azT1=noiseVector1.timeMJD;
    final double muY=(azTime - azT0) / (azT1 - azT0);
    int pixelIdx0=getPixelIndex(x0,noiseVector0);
    int pixelIdx1=getPixelIndex(x0,noiseVector1);
    final int maxLength0=noiseVector0.pixels.length - 2;
    final int maxLength1=noiseVector1.pixels.length - 2;
    final int maxX=x0 + w;
    for (int x=x0; x < maxX; x++) {
      if (x > noiseVector0.pixels[pixelIdx0 + 1] && pixelIdx0 < maxLength0) {
        pixelIdx0++;
      }
      final int x00=noiseVector0.pixels[pixelIdx0];
      final int x01=noiseVector0.pixels[pixelIdx0 + 1];
      final double muX0=(double)(x - x00) / (double)(x01 - x00);
      final double noise0=Maths.interpolationLinear(noiseVector0.noiseLUT[pixelIdx0],noiseVector0.noiseLUT[pixelIdx0 + 1],muX0);
      if (x > noiseVector1.pixels[pixelIdx1 + 1] && pixelIdx1 < maxLength1) {
        pixelIdx1++;
      }
      final int x10=noiseVector1.pixels[pixelIdx1];
      final int x11=noiseVector1.pixels[pixelIdx1 + 1];
      final double muX1=(double)(x - x10) / (double)(x11 - x10);
      final double noise1=Maths.interpolationLinear(noiseVector1.noiseLUT[pixelIdx1],noiseVector1.noiseLUT[pixelIdx1 + 1],muX1);
      lut[x - x0]=Maths.interpolationLinear(noise0,noise1,muY);
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
}"
11439,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  try {
    final String targetBandName=targetBand.getName();
    final ThermalNoiseInfo noiseInfo=getNoiseInfo(targetBandName);
    Tile sourceRaster1=null;
    ProductData srcData1=null;
    ProductData srcData2=null;
    Band sourceBand1=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      final Tile sourceRaster2=getSourceTile(sourceBand2,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
      srcData2=sourceRaster2.getDataBuffer();
    }
    final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
    final ProductData trgData=targetTile.getDataBuffer();
    final TileIndex srcIndex=new TileIndex(sourceRaster1);
    final TileIndex tgtIndex=new TileIndex(targetTile);
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    final boolean complexData=bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY;
    Sentinel1Calibrator.CalibrationInfo calInfo=null;
    Sentinel1Calibrator.CALTYPE calType=null;
    if (absoluteCalibrationPerformed) {
      calInfo=getCalInfo(targetBandName);
      calType=Sentinel1Calibrator.getCalibrationType(targetBandName);
    }
    double dn, dn2, i, q;
    int srcIdx, tgtIdx;
    for (int y=y0; y < maxY; ++y) {
      srcIndex.calculateStride(y);
      tgtIndex.calculateStride(y);
      final double[] lut=new double[w];
      if (absoluteCalibrationPerformed) {
        final int calVecIdx=calInfo.getCalibrationVectorIndex(y);
        final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
        final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
        final float[] vec0LUT=Sentinel1Calibrator.getVector(calType,vec0);
        final float[] vec1LUT=Sentinel1Calibrator.getVector(calType,vec1);
        final int pixelIdx0=calInfo.getPixelIndex(x0,calVecIdx);
        computeTileScaledNoiseLUT(y,x0,y0,w,noiseInfo,calInfo,vec0.timeMJD,vec1.timeMJD,vec0LUT,vec1LUT,vec0.pixels,pixelIdx0,lut);
      }
 else {
        computeTileNoiseLUT(y,x0,y0,w,noiseInfo,lut);
      }
      for (int x=x0; x < maxX; ++x) {
        final int xx=x - x0;
        srcIdx=srcIndex.getIndex(x);
        tgtIdx=tgtIndex.getIndex(x);
        if (bandUnit == Unit.UnitType.AMPLITUDE) {
          dn=srcData1.getElemDoubleAt(srcIdx);
          dn2=dn * dn;
        }
 else         if (complexData) {
          i=srcData1.getElemDoubleAt(srcIdx);
          q=srcData2.getElemDoubleAt(srcIdx);
          dn2=i * i + q * q;
        }
 else         if (bandUnit == Unit.UnitType.INTENSITY) {
          dn2=srcData1.getElemDoubleAt(srcIdx);
        }
 else {
          throw new OperatorException(""String_Node_Str"");
        }
        trgData.setElemDoubleAt(tgtIdx,dn2 - lut[xx]);
      }
    }
  }
 catch (  Throwable e) {
    throw new OperatorException(e.getMessage());
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  try {
    final String targetBandName=targetBand.getName();
    final ThermalNoiseInfo noiseInfo=getNoiseInfo(targetBandName);
    Tile sourceRaster1=null;
    ProductData srcData1=null;
    ProductData srcData2=null;
    Band sourceBand1=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      final Tile sourceRaster2=getSourceTile(sourceBand2,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
      srcData2=sourceRaster2.getDataBuffer();
    }
    final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
    final ProductData trgData=targetTile.getDataBuffer();
    final TileIndex srcIndex=new TileIndex(sourceRaster1);
    final TileIndex tgtIndex=new TileIndex(targetTile);
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    final boolean complexData=bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY;
    Sentinel1Calibrator.CalibrationInfo calInfo=null;
    Sentinel1Calibrator.CALTYPE calType=null;
    if (absoluteCalibrationPerformed) {
      calInfo=getCalInfo(targetBandName);
      calType=Sentinel1Calibrator.getCalibrationType(targetBandName);
    }
    double dn, dn2, i, q;
    int srcIdx, tgtIdx;
    for (int y=y0; y < maxY; ++y) {
      srcIndex.calculateStride(y);
      tgtIndex.calculateStride(y);
      final double[] lut=new double[w];
      if (absoluteCalibrationPerformed) {
        final int calVecIdx=calInfo.getCalibrationVectorIndex(y);
        final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
        final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
        final float[] vec0LUT=Sentinel1Calibrator.getVector(calType,vec0);
        final float[] vec1LUT=Sentinel1Calibrator.getVector(calType,vec1);
        final int pixelIdx0=calInfo.getPixelIndex(x0,calVecIdx);
        computeTileScaledNoiseLUT(y,x0,w,noiseInfo,calInfo,vec0.timeMJD,vec1.timeMJD,vec0LUT,vec1LUT,vec0.pixels,pixelIdx0,lut);
      }
 else {
        computeTileNoiseLUT(y,x0,w,noiseInfo,lut);
      }
      for (int x=x0; x < maxX; ++x) {
        final int xx=x - x0;
        srcIdx=srcIndex.getIndex(x);
        tgtIdx=tgtIndex.getIndex(x);
        if (bandUnit == Unit.UnitType.AMPLITUDE) {
          dn=srcData1.getElemDoubleAt(srcIdx);
          dn2=dn * dn;
        }
 else         if (complexData) {
          i=srcData1.getElemDoubleAt(srcIdx);
          q=srcData2.getElemDoubleAt(srcIdx);
          dn2=i * i + q * q;
        }
 else         if (bandUnit == Unit.UnitType.INTENSITY) {
          dn2=srcData1.getElemDoubleAt(srcIdx);
        }
 else {
          throw new OperatorException(""String_Node_Str"");
        }
        trgData.setElemDoubleAt(tgtIdx,dn2 - lut[xx]);
      }
    }
  }
 catch (  Throwable e) {
    throw new OperatorException(e.getMessage());
  }
}"
11440,"/** 
 * Compute scaled noise LUTs for the given range line.
 * @param y         Index of the given range line.
 * @param x0        X coordinate of the upper left corner pixel of the given tile.
 * @param y0        Y coordinate of the upper left corner pixel of the given tile.
 * @param w         Tile width.
 * @param noiseInfo Object of ThermalNoiseInfo class.
 * @param calInfo   Object of CalibrationInfo class.
 * @param lut       The scaled noise LUT.
 */
private void computeTileScaledNoiseLUT(final int y,final int x0,final int y0,final int w,final ThermalNoiseInfo noiseInfo,final Sentinel1Calibrator.CalibrationInfo calInfo,final double azT0,final double azT1,final float[] vec0LUT,final float[] vec1LUT,final int[] vec0Pixels,final int pixelIdx0,final double[] lut){
  final double[] noiseLut=new double[w];
  computeTileNoiseLUT(y,x0,y0,w,noiseInfo,noiseLut);
  final double[] calLut=new double[w];
  computeTileCalibrationLUTs(y,x0,w,calInfo,azT0,azT1,vec0LUT,vec1LUT,vec0Pixels,pixelIdx0,calLut);
  if (removeThermalNoise) {
    for (int i=0; i < w; i++) {
      lut[i]=noiseLut[i] / (calLut[i] * calLut[i]);
    }
  }
 else {
    for (int i=0; i < w; i++) {
      lut[i]=-noiseLut[i] / (calLut[i] * calLut[i]);
    }
  }
}","/** 
 * Compute scaled noise LUTs for the given range line.
 * @param y         Index of the given range line.
 * @param x0        X coordinate of the upper left corner pixel of the given tile.
 * @param w         Tile width.
 * @param noiseInfo Object of ThermalNoiseInfo class.
 * @param calInfo   Object of CalibrationInfo class.
 * @param lut       The scaled noise LUT.
 */
private void computeTileScaledNoiseLUT(final int y,final int x0,final int w,final ThermalNoiseInfo noiseInfo,final Sentinel1Calibrator.CalibrationInfo calInfo,final double azT0,final double azT1,final float[] vec0LUT,final float[] vec1LUT,final int[] vec0Pixels,final int pixelIdx0,final double[] lut){
  final double[] noiseLut=new double[w];
  computeTileNoiseLUT(y,x0,w,noiseInfo,noiseLut);
  final double[] calLut=new double[w];
  computeTileCalibrationLUTs(y,x0,w,calInfo,azT0,azT1,vec0LUT,vec1LUT,vec0Pixels,pixelIdx0,calLut);
  if (removeThermalNoise) {
    for (int i=0; i < w; i++) {
      lut[i]=noiseLut[i] / (calLut[i] * calLut[i]);
    }
  }
 else {
    for (int i=0; i < w; i++) {
      lut[i]=-noiseLut[i] / (calLut[i] * calLut[i]);
    }
  }
}"
11441,"private void updateAbstractMetadata(){
  final MetadataElement absTgt=AbstractMetadata.getAbstractedMetadata(targetProduct);
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.num_output_lines,targetHeight);
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.num_samples_per_line,targetWidth);
  absTgt.setAttributeUTC(AbstractMetadata.first_line_time,new ProductData.UTC(targetFirstLineTime / Constants.secondsInDay));
  absTgt.setAttributeUTC(AbstractMetadata.last_line_time,new ProductData.UTC(targetLastLineTime / Constants.secondsInDay));
  absTgt.setAttributeDouble(AbstractMetadata.line_time_interval,targetLineTimeInterval);
  TiePointGrid latGrid=targetProduct.getTiePointGrid(OperatorUtils.TPG_LATITUDE);
  TiePointGrid lonGrid=targetProduct.getTiePointGrid(OperatorUtils.TPG_LONGITUDE);
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_near_lat,latGrid.getPixelFloat(0,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_near_long,lonGrid.getPixelFloat(0,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_far_lat,latGrid.getPixelFloat(targetWidth,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_far_long,lonGrid.getPixelFloat(targetWidth,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_near_lat,latGrid.getPixelFloat(0,targetHeight));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_near_long,lonGrid.getPixelFloat(0,targetHeight));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_far_lat,latGrid.getPixelFloat(targetWidth,targetHeight));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_far_long,lonGrid.getPixelFloat(targetWidth,targetHeight));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeElement(absTgt.getElement(""String_Node_Str""));
  final MetadataElement burstBoundaryTgt=new MetadataElement(""String_Node_Str"");
  for (int p=0; p < numOfSubSwath; p++) {
    MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct[p]);
    final MetadataElement burstBoundarySrc=absRoot.getElement(""String_Node_Str"");
    if (burstBoundarySrc != null) {
      final MetadataElement element=burstBoundarySrc.getElementAt(0);
      if (element != null) {
        burstBoundaryTgt.addElement(element.createDeepClone());
      }
    }
  }
  absTgt.addElement(burstBoundaryTgt);
  absTgt.removeElement(absTgt.getElement(""String_Node_Str""));
  final MetadataElement ESDMeasurementTgt=new MetadataElement(""String_Node_Str"");
  for (int p=0; p < numOfSubSwath; p++) {
    MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct[p]);
    final MetadataElement ESDMeasurementSrc=absRoot.getElement(""String_Node_Str"");
    if (ESDMeasurementSrc != null) {
      final MetadataElement element=ESDMeasurementSrc.getElementAt(0);
      if (element != null) {
        ESDMeasurementTgt.addElement(element.createDeepClone());
      }
    }
  }
  absTgt.addElement(ESDMeasurementTgt);
}","private void updateAbstractMetadata(){
  final MetadataElement absTgt=AbstractMetadata.getAbstractedMetadata(targetProduct);
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.num_output_lines,targetHeight);
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.num_samples_per_line,targetWidth);
  absTgt.setAttributeUTC(AbstractMetadata.first_line_time,new ProductData.UTC(targetFirstLineTime / Constants.secondsInDay));
  absTgt.setAttributeUTC(AbstractMetadata.last_line_time,new ProductData.UTC(targetLastLineTime / Constants.secondsInDay));
  absTgt.setAttributeDouble(AbstractMetadata.line_time_interval,targetLineTimeInterval);
  absTgt.setAttributeDouble(AbstractMetadata.slant_range_to_first_pixel,targetSlantRangeTimeToFirstPixel * Constants.lightSpeed);
  TiePointGrid latGrid=targetProduct.getTiePointGrid(OperatorUtils.TPG_LATITUDE);
  TiePointGrid lonGrid=targetProduct.getTiePointGrid(OperatorUtils.TPG_LONGITUDE);
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_near_lat,latGrid.getPixelFloat(0,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_near_long,lonGrid.getPixelFloat(0,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_far_lat,latGrid.getPixelFloat(targetWidth,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.first_far_long,lonGrid.getPixelFloat(targetWidth,0));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_near_lat,latGrid.getPixelFloat(0,targetHeight));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_near_long,lonGrid.getPixelFloat(0,targetHeight));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_far_lat,latGrid.getPixelFloat(targetWidth,targetHeight));
  AbstractMetadata.setAttribute(absTgt,AbstractMetadata.last_far_long,lonGrid.getPixelFloat(targetWidth,targetHeight));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeAttribute(absTgt.getAttribute(""String_Node_Str""));
  absTgt.removeElement(absTgt.getElement(""String_Node_Str""));
  final MetadataElement burstBoundaryTgt=new MetadataElement(""String_Node_Str"");
  for (int p=0; p < numOfSubSwath; p++) {
    MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct[p]);
    final MetadataElement burstBoundarySrc=absRoot.getElement(""String_Node_Str"");
    if (burstBoundarySrc != null) {
      final MetadataElement element=burstBoundarySrc.getElementAt(0);
      if (element != null) {
        burstBoundaryTgt.addElement(element.createDeepClone());
      }
    }
  }
  absTgt.addElement(burstBoundaryTgt);
  absTgt.removeElement(absTgt.getElement(""String_Node_Str""));
  final MetadataElement ESDMeasurementTgt=new MetadataElement(""String_Node_Str"");
  for (int p=0; p < numOfSubSwath; p++) {
    MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct[p]);
    final MetadataElement ESDMeasurementSrc=absRoot.getElement(""String_Node_Str"");
    if (ESDMeasurementSrc != null) {
      final MetadataElement element=ESDMeasurementSrc.getElementAt(0);
      if (element != null) {
        ESDMeasurementTgt.addElement(element.createDeepClone());
      }
    }
  }
  absTgt.addElement(ESDMeasurementTgt);
}"
11442,"private JComponent createPanel(){
  final JPanel contentPane=new JPanel(new GridBagLayout());
  final GridBagConstraints gbc=DialogUtils.createGridBagConstraints();
  gbc.fill=GridBagConstraints.BOTH;
  DialogUtils.addComponent(contentPane,gbc,""String_Node_Str"",new JScrollPane(bandList));
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,""String_Node_Str"",filter);
  filter.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent event){
      updateFilterSelection();
    }
  }
);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.gridy++;
  final int savedY=gbc.gridy;
  DialogUtils.addComponent(contentPane,gbc,filterSizeXLabel,filterSizeX);
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,filterSizeYLabel,filterSizeY);
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,dampingFactorLabel,dampingFactor);
  DialogUtils.addComponent(contentPane,gbc,estimateENLCheckBoxLabel,estimateENLCheckBox);
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,enlLabel,enl);
  gbc.gridy=savedY;
  DialogUtils.addComponent(contentPane,gbc,edgeThresholdLabel,edgeThreshold);
  gbc.weightx=1.0;
  DialogUtils.enableComponents(filterSizeXLabel,filterSizeX,true);
  DialogUtils.enableComponents(filterSizeYLabel,filterSizeY,true);
  DialogUtils.enableComponents(dampingFactorLabel,dampingFactor,false);
  DialogUtils.enableComponents(estimateENLCheckBoxLabel,estimateENLCheckBox,false);
  DialogUtils.enableComponents(enlLabel,enl,false);
  DialogUtils.enableComponents(edgeThresholdLabel,edgeThreshold,false);
  DialogUtils.fillPanel(contentPane,gbc);
  return contentPane;
}","private JComponent createPanel(){
  final JPanel contentPane=new JPanel(new GridBagLayout());
  final GridBagConstraints gbc=DialogUtils.createGridBagConstraints();
  gbc.fill=GridBagConstraints.BOTH;
  DialogUtils.addComponent(contentPane,gbc,""String_Node_Str"",new JScrollPane(bandList));
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,""String_Node_Str"",filter);
  filter.addItemListener(new ItemListener(){
    public void itemStateChanged(    ItemEvent event){
      updateFilterSelection();
    }
  }
);
  gbc.fill=GridBagConstraints.HORIZONTAL;
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,filterSizeXLabel,filterSizeX);
  DialogUtils.addComponent(contentPane,gbc,edgeThresholdLabel,edgeThreshold);
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,filterSizeYLabel,filterSizeY);
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,dampingFactorLabel,dampingFactor);
  DialogUtils.addComponent(contentPane,gbc,estimateENLCheckBoxLabel,estimateENLCheckBox);
  gbc.gridy++;
  DialogUtils.addComponent(contentPane,gbc,enlLabel,enl);
  gbc.weightx=1.0;
  DialogUtils.enableComponents(filterSizeXLabel,filterSizeX,true);
  DialogUtils.enableComponents(filterSizeYLabel,filterSizeY,true);
  DialogUtils.enableComponents(dampingFactorLabel,dampingFactor,false);
  DialogUtils.enableComponents(estimateENLCheckBoxLabel,estimateENLCheckBox,false);
  DialogUtils.enableComponents(enlLabel,enl,false);
  DialogUtils.enableComponents(edgeThresholdLabel,edgeThreshold,false);
  DialogUtils.fillPanel(contentPane,gbc);
  return contentPane;
}"
11443,"private void computeSubSwathEffectStartEndPixels(){
  subSwathEffectStartEndPixels=new SubSwathEffectStartEndPixels[numOfSubSwath];
  for (int i=0; i < numOfSubSwath; i++) {
    subSwathEffectStartEndPixels[i]=new SubSwathEffectStartEndPixels();
    if (i == 0) {
      subSwathEffectStartEndPixels[i].xMin=(int)Math.round((subSwath[i].slrTimeToFirstValidPixel - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
 else {
      final double midTime=(subSwath[i - 1].slrTimeToLastValidPixel + subSwath[i].slrTimeToFirstValidPixel) / 2.0;
      subSwathEffectStartEndPixels[i].xMin=(int)Math.round((midTime - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
    if (i < numOfSubSwath - 1) {
      final double midTime=(subSwath[i].slrTimeToLastValidPixel + subSwath[i + 1].slrTimeToFirstValidPixel) / 2.0;
      subSwathEffectStartEndPixels[i].xMax=(int)Math.round((midTime - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
 else {
      subSwathEffectStartEndPixels[i].xMax=(int)Math.round((subSwath[i].slrTimeToLastValidPixel - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
  }
}","private void computeSubSwathEffectStartEndPixels(){
  subSwathEffectStartEndPixels=new SubSwathEffectStartEndPixels[numOfSubSwath];
  for (int i=0; i < numOfSubSwath; i++) {
    subSwathEffectStartEndPixels[i]=new SubSwathEffectStartEndPixels();
    if (i == 0) {
      subSwathEffectStartEndPixels[i].xMin=0;
    }
 else {
      final double midTime=(subSwath[i - 1].slrTimeToLastValidPixel + subSwath[i].slrTimeToFirstValidPixel) / 2.0;
      subSwathEffectStartEndPixels[i].xMin=(int)Math.round((midTime - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
    if (i < numOfSubSwath - 1) {
      final double midTime=(subSwath[i].slrTimeToLastValidPixel + subSwath[i + 1].slrTimeToFirstValidPixel) / 2.0;
      subSwathEffectStartEndPixels[i].xMax=(int)Math.round((midTime - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
 else {
      subSwathEffectStartEndPixels[i].xMax=(int)Math.round((subSwath[i].slrTimeToLastPixel - subSwath[i].slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    }
  }
}"
11444,"/** 
 * Set pixel displacements in X and Y direction based on user selected angle.
 */
private void setXYDisplacements(){
switch (angleStr) {
case ANGLE_0:
    displacementX=displacement;
  displacementY=0;
break;
case ANGLE_45:
displacementX=displacement;
displacementY=displacement;
break;
case ANGLE_90:
displacementX=0;
displacementY=displacement;
break;
case ANGLE_135:
displacementX=-displacement;
displacementY=displacement;
break;
case ANGLE_ALL:
computeGLCPWithAllAngles=true;
break;
default :
throw new OperatorException(""String_Node_Str"" + angleStr);
}
}","/** 
 * Set pixel displacements in X and Y direction based on user selected angle.
 */
private void setXYDisplacements(){
switch (angleStr) {
case ANGLE_0:
    displacementX=displacement;
  displacementY=0;
break;
case ANGLE_45:
displacementX=-displacement;
displacementY=displacement;
break;
case ANGLE_90:
displacementX=0;
displacementY=displacement;
break;
case ANGLE_135:
displacementX=displacement;
displacementY=displacement;
break;
case ANGLE_ALL:
computeGLCPWithAllAngles=true;
break;
default :
throw new OperatorException(""String_Node_Str"" + angleStr);
}
}"
11445,"private Totals computeGLCM(final int x0,final int y0,final int xMax,final int yMax,final int[][] quantizedImage,final GLCMElem[] GLCM){
  final Totals totals=new Totals();
  int xx, yy, dX, dY;
  if (computeGLCPWithAllAngles) {
    for (int y=y0; y < yMax; y++) {
      yy=y - y0;
      for (int x=x0; x < xMax; x++) {
        xx=x - x0;
        final int i=quantizedImage[yy][xx];
        if (i < 0) {
          continue;
        }
        for (int angle=0; angle <= 135; angle+=45) {
switch (angle) {
case 0:
            dX=displacement;
          dY=0;
        break;
case 45:
      dX=displacement;
    dY=displacement;
  break;
case 90:
dX=0;
dY=displacement;
break;
case 135:
dX=-displacement;
dY=displacement;
break;
default :
throw new OperatorException(""String_Node_Str"" + angle);
}
int j;
if (y + dY >= y0 && y + dY < yMax && x + dX >= x0 && x + dX < xMax) {
j=quantizedImage[yy + dY][xx + dX];
if (j < 0) {
continue;
}
}
 else {
continue;
}
addElement(GLCM,i,j,totals);
addElement(GLCM,j,i,totals);
totals.totalCount++;
}
}
}
}
 else {
for (int y=y0; y < yMax; y++) {
yy=y - y0;
for (int x=x0; x < xMax; x++) {
xx=x - x0;
final int i=quantizedImage[yy][xx];
if (i < 0) {
continue;
}
int j;
if (y + displacementY >= y0 && y + displacementY < yMax && x + displacementX >= x0 && x + displacementX < xMax) {
j=quantizedImage[yy + displacementY][xx + displacementX];
if (j < 0) {
continue;
}
}
 else {
continue;
}
addElement(GLCM,i,j,totals);
addElement(GLCM,j,i,totals);
totals.totalCount++;
}
}
}
return totals;
}","private Totals computeGLCM(final int x0,final int y0,final int xMax,final int yMax,final int[][] quantizedImage,final GLCMElem[] GLCM){
  final Totals totals=new Totals();
  int xx, yy, dX, dY;
  if (computeGLCPWithAllAngles) {
    for (int y=y0; y < yMax; y++) {
      yy=y - y0;
      for (int x=x0; x < xMax; x++) {
        xx=x - x0;
        final int i=quantizedImage[yy][xx];
        if (i < 0) {
          continue;
        }
        for (int angle=0; angle <= 135; angle+=45) {
switch (angle) {
case 0:
            dX=displacement;
          dY=0;
        break;
case 45:
      dX=-displacement;
    dY=displacement;
  break;
case 90:
dX=0;
dY=displacement;
break;
case 135:
dX=displacement;
dY=displacement;
break;
default :
throw new OperatorException(""String_Node_Str"" + angle);
}
int j;
if (y + dY >= y0 && y + dY < yMax && x + dX >= x0 && x + dX < xMax) {
j=quantizedImage[yy + dY][xx + dX];
if (j < 0) {
continue;
}
}
 else {
continue;
}
addElement(GLCM,i,j,totals);
addElement(GLCM,j,i,totals);
totals.totalCount++;
}
}
}
}
 else {
for (int y=y0; y < yMax; y++) {
yy=y - y0;
for (int x=x0; x < xMax; x++) {
xx=x - x0;
final int i=quantizedImage[yy][xx];
if (i < 0) {
continue;
}
int j;
if (y + displacementY >= y0 && y + displacementY < yMax && x + displacementX >= x0 && x + displacementX < xMax) {
j=quantizedImage[yy + displacementY][xx + displacementX];
if (j < 0) {
continue;
}
}
 else {
continue;
}
addElement(GLCM,i,j,totals);
addElement(GLCM,j,i,totals);
totals.totalCount++;
}
}
}
return totals;
}"
11446,"/** 
 * Create warped image.
 * @param warp     The WARP polynomial.
 * @param srcImage The source image.
 * @return The warped image.
 */
private RenderedOp createWarpImage(WarpPolynomial warp,final RenderedImage srcImage){
  final ParameterBlock pb1=new ParameterBlock();
  pb1.addSource(srcImage);
  pb1.add(DataBuffer.TYPE_FLOAT);
  final RenderedImage srcImageFloat=JAI.create(""String_Node_Str"",pb1);
  final ParameterBlock pb2=new ParameterBlock();
  pb2.addSource(srcImageFloat);
  pb2.add(warp);
  if (interp != null) {
    pb2.add(interp);
  }
 else   if (interpTable != null) {
    pb2.add(interpTable);
  }
  return JAI.create(""String_Node_Str"",pb2);
}","/** 
 * Create warped image.
 * @param warp     The WARP polynomial.
 * @param srcImage The source image.
 * @return The warped image.
 */
private RenderedOp createWarpImage(WarpPolynomial warp,final RenderedImage srcImage){
  final ParameterBlock pb1=new ParameterBlock();
  pb1.addSource(srcImage);
  pb1.add(DataBuffer.TYPE_FLOAT);
  final RenderedImage srcImageFloat=JAI.create(""String_Node_Str"",pb1);
  if (warp == null) {
    return (RenderedOp)srcImageFloat;
  }
  final ParameterBlock pb2=new ParameterBlock();
  pb2.addSource(srcImageFloat);
  pb2.add(warp);
  if (interp != null) {
    pb2.add(interp);
  }
 else   if (interpTable != null) {
    pb2.add(interpTable);
  }
  return JAI.create(""String_Node_Str"",pb2);
}"
11447,"/** 
 * Create target product.
 */
private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName(),sourceProduct.getProductType(),sourceImageWidth,sourceImageHeight);
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
  final String[] masterBandNames=StackUtils.getMasterBandNames(sourceProduct);
  final int numSrcBands=sourceProduct.getNumBands();
  Band slvBand1=null, slvBand2=null;
  final String mstPol=OperatorUtils.getPolarizationFromBandName(masterBand1.getName());
  for (  Band slvBand : sourceProduct.getBands()) {
    if (!StringUtils.contains(masterBandNames,slvBand.getName()) && slvBand != masterBand1) {
      final String slvPol=OperatorUtils.getPolarizationFromBandName(slvBand.getName());
      if (mstPol == null || mstPol.equals(slvPol)) {
        final String unit=slvBand.getUnit();
        if (unit != null && !unit.contains(Unit.IMAGINARY)) {
          slvBand1=slvBand;
          break;
        }
 else         if (unit == null) {
          slvBand1=slvBand;
        }
      }
    }
  }
  boolean oneSlaveProcessed=false;
  for (int i=0; i < numSrcBands; ++i) {
    final Band srcBand=sourceProduct.getBandAt(i);
    final Band targetBand=targetProduct.addBand(srcBand.getName(),srcBand.getDataType());
    ProductUtils.copyRasterDataNodeProperties(srcBand,targetBand);
    sourceRasterMap.put(targetBand,srcBand);
    gcpsComputedMap.put(srcBand,false);
    if (srcBand == masterBand1 || srcBand == masterBand2 || oneSlaveProcessed || srcBand != slvBand1 || StringUtils.contains(masterBandNames,srcBand.getName())) {
      targetBand.setSourceImage(srcBand.getSourceImage());
    }
 else {
      final String unit=srcBand.getUnit();
      if (!oneSlaveProcessed && (unit == null || !unit.contains(Unit.IMAGINARY))) {
        oneSlaveProcessed=true;
        primarySlaveBand=srcBand;
        final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(targetProduct);
        AbstractMetadata.addAbstractedAttribute(absRoot,""String_Node_Str"",ProductData.TYPE_ASCII,""String_Node_Str"",""String_Node_Str"");
        absRoot.setAttributeString(""String_Node_Str"",primarySlaveBand.getName());
      }
    }
    if (complexCoregistration) {
      if (srcBand.getUnit() != null && srcBand.getUnit().equals(Unit.REAL)) {
        if (i + 1 < numSrcBands)         complexSrcMap.put(srcBand,sourceProduct.getBandAt(i + 1));
      }
    }
  }
}","/** 
 * Create target product.
 */
private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName(),sourceProduct.getProductType(),sourceImageWidth,sourceImageHeight);
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
  final String[] masterBandNames=StackUtils.getMasterBandNames(sourceProduct);
  final int numSrcBands=sourceProduct.getNumBands();
  Band slvBand1=null, slvBand2=null;
  final String mstPol=OperatorUtils.getPolarizationFromBandName(masterBand1.getName());
  for (  Band slvBand : sourceProduct.getBands()) {
    if (!StringUtils.contains(masterBandNames,slvBand.getName()) && slvBand != masterBand1) {
      final String slvPol=OperatorUtils.getPolarizationFromBandName(slvBand.getName());
      if (mstPol == null || slvPol == null || mstPol.equals(slvPol)) {
        final String unit=slvBand.getUnit();
        if (unit != null && !unit.contains(Unit.IMAGINARY)) {
          slvBand1=slvBand;
          break;
        }
 else         if (unit == null) {
          slvBand1=slvBand;
        }
      }
    }
  }
  boolean oneSlaveProcessed=false;
  for (int i=0; i < numSrcBands; ++i) {
    final Band srcBand=sourceProduct.getBandAt(i);
    final Band targetBand=targetProduct.addBand(srcBand.getName(),srcBand.getDataType());
    ProductUtils.copyRasterDataNodeProperties(srcBand,targetBand);
    sourceRasterMap.put(targetBand,srcBand);
    gcpsComputedMap.put(srcBand,false);
    if (srcBand == masterBand1 || srcBand == masterBand2 || oneSlaveProcessed || srcBand != slvBand1 || StringUtils.contains(masterBandNames,srcBand.getName())) {
      targetBand.setSourceImage(srcBand.getSourceImage());
    }
 else {
      final String unit=srcBand.getUnit();
      if (!oneSlaveProcessed && (unit == null || !unit.contains(Unit.IMAGINARY))) {
        oneSlaveProcessed=true;
        primarySlaveBand=srcBand;
        final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(targetProduct);
        AbstractMetadata.addAbstractedAttribute(absRoot,""String_Node_Str"",ProductData.TYPE_ASCII,""String_Node_Str"",""String_Node_Str"");
        absRoot.setAttributeString(""String_Node_Str"",primarySlaveBand.getName());
      }
    }
    if (complexCoregistration) {
      if (srcBand.getUnit() != null && srcBand.getUnit().equals(Unit.REAL)) {
        if (i + 1 < numSrcBands)         complexSrcMap.put(srcBand,sourceProduct.getBandAt(i + 1));
      }
    }
  }
}"
11448,"private synchronized void createReader(final ImageReader iioReader) throws IOException {
  reader=iioReader;
  initReader();
  numImages=reader.getNumImages(true);
  numBands=3;
  dataType=ProductData.TYPE_INT32;
  final ImageTypeSpecifier its=reader.getRawImageType(0);
  if (its != null) {
    numBands=reader.getRawImageType(0).getNumBands();
    dataType=bufferImageTypeToProductType(its.getBufferedImageType());
    if (its.getBufferedImageType() == BufferedImage.TYPE_BYTE_INDEXED) {
      isIndexed=true;
      createIndexedImageInfo(its.getColorModel());
    }
  }
}","private synchronized void createReader(final ImageReader iioReader) throws IOException {
  reader=iioReader;
  initReader();
  numImages=reader.getNumImages(!reader.isSeekForwardOnly());
  if (numImages < 0)   numImages=1;
  numBands=3;
  dataType=ProductData.TYPE_INT32;
  final ImageTypeSpecifier its=reader.getRawImageType(0);
  if (its != null) {
    numBands=reader.getRawImageType(0).getNumBands();
    dataType=bufferImageTypeToProductType(its.getBufferedImageType());
    if (its.getBufferedImageType() == BufferedImage.TYPE_BYTE_INDEXED) {
      isIndexed=true;
      createIndexedImageInfo(its.getColorModel());
    }
  }
}"
11449,"public void initReader(){
  if (reader != null) {
    reader.setInput(stream,true,true);
  }
}","public void initReader(){
  if (reader != null) {
    reader.setInput(stream,false,true);
  }
}"
11450,"/** 
 * Output normalized image.
 * @param x0              X coordinate of the upper left corner pixel of given tile.
 * @param y0              Y coordinate of the upper left corner pixel of given tile.
 * @param w               Width of given tile.
 * @param h               Height of given tile.
 * @param gamma0ReferenceArea The simulated image for flattened gamma0 generation.
 * @param sigma0ReferenceArea The simulated image for flattened sigma0 generation.
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed.
 */
private void outputNormalizedImage(final int x0,final int y0,final int w,final int h,final double[][] gamma0ReferenceArea,final double[][] sigma0ReferenceArea,final Map<Band,Tile> targetTiles,final Rectangle targetRectangle){
  try {
    for (    Band tgtBand : targetBands) {
      final Tile targetTile=targetTiles.get(tgtBand);
      final ProductData targetData=targetTile.getDataBuffer();
      final TileIndex tgtIndex=new TileIndex(targetTile);
      final String unit=tgtBand.getUnit();
      final String bandName=tgtBand.getName();
      Band srcBand=null;
      Tile sourceTile=null;
      ProductData sourceData=null;
      TileIndex srcIndex=null;
      if (bandName.contains(""String_Node_Str"") || bandName.contains(""String_Node_Str"")) {
        srcBand=targetBandToSourceBandMap.get(tgtBand);
        sourceTile=getSourceTile(srcBand,targetRectangle);
        sourceData=sourceTile.getDataBuffer();
        srcIndex=new TileIndex(sourceTile);
      }
      double[][] simulatedImage=gamma0ReferenceArea;
      if (bandName.contains(""String_Node_Str"")) {
        simulatedImage=sigma0ReferenceArea;
      }
      UnitType unitType=UnitType.AMPLITUDE;
      if (unit.contains(Unit.AMPLITUDE)) {
        unitType=UnitType.AMPLITUDE;
      }
 else       if (unit.contains(Unit.INTENSITY)) {
        unitType=UnitType.INTENSITY;
      }
 else       if (unit.contains(Unit.REAL) || unit.contains(Unit.IMAGINARY)) {
        unitType=UnitType.COMPLEX;
      }
 else       if (unit.contains(""String_Node_Str"")) {
        unitType=UnitType.RATIO;
      }
      if (unitType == UnitType.RATIO) {
        for (int y=y0; y < y0 + h; y++) {
          final int yy=y - y0;
          tgtIndex.calculateStride(y);
          for (int x=x0; x < x0 + w; x++) {
            final int xx=x - x0;
            final int tgtIdx=tgtIndex.getIndex(x);
            final double simVal=simulatedImage[yy][xx];
            if (simVal != noDataValue && simVal != 0.0) {
              targetData.setElemDoubleAt(tgtIdx,simVal / beta0);
            }
 else {
              targetData.setElemDoubleAt(tgtIdx,noDataValue);
            }
          }
        }
      }
 else {
        double v, simVal;
        int tgtIdx, srcIdx;
        for (int y=y0; y < y0 + h; y++) {
          final int yy=y - y0;
          tgtIndex.calculateStride(y);
          srcIndex.calculateStride(y);
          for (int x=x0; x < x0 + w; x++) {
            final int xx=x - x0;
            tgtIdx=tgtIndex.getIndex(x);
            srcIdx=srcIndex.getIndex(x);
            simVal=simulatedImage[yy][xx];
            if (simVal != noDataValue) {
              simVal/=beta0;
              if (isGRD) {
                simVal/=Math.sin(incidenceAngleTPG.getPixelDouble(x,y) * Constants.DTOR);
              }
              if (simVal > threshold) {
switch (unitType) {
case AMPLITUDE:
                  v=sourceData.getElemDoubleAt(srcIdx);
                targetData.setElemDoubleAt(tgtIdx,v * v / simVal);
              break;
case INTENSITY:
            v=sourceData.getElemDoubleAt(srcIdx);
          targetData.setElemDoubleAt(tgtIdx,v / simVal);
        break;
case COMPLEX:
      v=sourceData.getElemDoubleAt(srcIdx);
    targetData.setElemDoubleAt(tgtIdx,v / Math.sqrt(simVal));
  break;
}
}
}
 else {
targetData.setElemDoubleAt(tgtIdx,noDataValue);
}
}
}
}
}
}
 catch (Throwable e) {
OperatorUtils.catchOperatorException(getId(),e);
}
}","/** 
 * Output normalized image.
 * @param x0              X coordinate of the upper left corner pixel of given tile.
 * @param y0              Y coordinate of the upper left corner pixel of given tile.
 * @param w               Width of given tile.
 * @param h               Height of given tile.
 * @param gamma0ReferenceArea The simulated image for flattened gamma0 generation.
 * @param sigma0ReferenceArea The simulated image for flattened sigma0 generation.
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed.
 */
private void outputNormalizedImage(final int x0,final int y0,final int w,final int h,final double[][] gamma0ReferenceArea,final double[][] sigma0ReferenceArea,final Map<Band,Tile> targetTiles,final Rectangle targetRectangle){
  try {
    for (    Band tgtBand : targetBands) {
      final Tile targetTile=targetTiles.get(tgtBand);
      final ProductData targetData=targetTile.getDataBuffer();
      final TileIndex tgtIndex=new TileIndex(targetTile);
      final String unit=tgtBand.getUnit();
      final String bandName=tgtBand.getName();
      Band srcBand=null;
      Tile sourceTile=null;
      ProductData sourceData=null;
      TileIndex srcIndex=null;
      if (bandName.contains(""String_Node_Str"") || bandName.contains(""String_Node_Str"")) {
        srcBand=targetBandToSourceBandMap.get(tgtBand);
        sourceTile=getSourceTile(srcBand,targetRectangle);
        sourceData=sourceTile.getDataBuffer();
        srcIndex=new TileIndex(sourceTile);
      }
      double[][] simulatedImage=null;
      if (bandName.contains(""String_Node_Str"")) {
        simulatedImage=sigma0ReferenceArea.clone();
      }
 else {
        simulatedImage=gamma0ReferenceArea.clone();
      }
      UnitType unitType=UnitType.AMPLITUDE;
      if (unit.contains(Unit.AMPLITUDE)) {
        unitType=UnitType.AMPLITUDE;
      }
 else       if (unit.contains(Unit.INTENSITY)) {
        unitType=UnitType.INTENSITY;
      }
 else       if (unit.contains(Unit.REAL) || unit.contains(Unit.IMAGINARY)) {
        unitType=UnitType.COMPLEX;
      }
 else       if (unit.contains(""String_Node_Str"")) {
        unitType=UnitType.RATIO;
      }
      if (unitType == UnitType.RATIO) {
        for (int y=y0; y < y0 + h; y++) {
          final int yy=y - y0;
          tgtIndex.calculateStride(y);
          for (int x=x0; x < x0 + w; x++) {
            final int xx=x - x0;
            final int tgtIdx=tgtIndex.getIndex(x);
            double simVal=simulatedImage[yy][xx];
            if (simVal != noDataValue && simVal != 0.0) {
              simVal/=beta0;
              if (isGRD) {
                simVal/=Math.sin(incidenceAngleTPG.getPixelDouble(x,y) * Constants.DTOR);
              }
              targetData.setElemDoubleAt(tgtIdx,simVal);
            }
 else {
              targetData.setElemDoubleAt(tgtIdx,noDataValue);
            }
          }
        }
      }
 else {
        double v, simVal;
        int tgtIdx, srcIdx;
        for (int y=y0; y < y0 + h; y++) {
          final int yy=y - y0;
          tgtIndex.calculateStride(y);
          srcIndex.calculateStride(y);
          for (int x=x0; x < x0 + w; x++) {
            final int xx=x - x0;
            tgtIdx=tgtIndex.getIndex(x);
            srcIdx=srcIndex.getIndex(x);
            simVal=simulatedImage[yy][xx];
            if (simVal != noDataValue) {
              simVal/=beta0;
              if (isGRD) {
                simVal/=Math.sin(incidenceAngleTPG.getPixelDouble(x,y) * Constants.DTOR);
              }
              if (simVal > threshold) {
switch (unitType) {
case AMPLITUDE:
                  v=sourceData.getElemDoubleAt(srcIdx);
                targetData.setElemDoubleAt(tgtIdx,v * v / simVal);
              break;
case INTENSITY:
            v=sourceData.getElemDoubleAt(srcIdx);
          targetData.setElemDoubleAt(tgtIdx,v / simVal);
        break;
case COMPLEX:
      v=sourceData.getElemDoubleAt(srcIdx);
    targetData.setElemDoubleAt(tgtIdx,v / Math.sqrt(simVal));
  break;
}
}
}
 else {
targetData.setElemDoubleAt(tgtIdx,noDataValue);
}
}
}
}
}
}
 catch (Throwable e) {
OperatorUtils.catchOperatorException(getId(),e);
}
}"
11451,"/** 
 * Generate simulated image for normalization.
 * @param x0             X coordinate of the upper left corner pixel of given tile.
 * @param y0             Y coordinate of the upper left corner pixel of given tile.
 * @param w              Width of given tile.
 * @param h              Height of given tile.
 * @param gamma0ReferenceArea The simulated image for flattened gamma0 generation.
 * @param sigma0ReferenceArea The simulated image for flattened sigma0 generation.
 * @return Boolean flag indicating if the simulation is successful.
 */
private boolean generateSimulatedImage(final int x0,final int y0,final int w,final int h,final OverlapPercentage tileOverlapPercentage,final double[][] gamma0ReferenceArea,final double[][] sigma0ReferenceArea){
  try {
    final int ymin=Math.max(y0 - (int)(h * tileOverlapPercentage.tileOverlapUp),0);
    final int ymax=Math.min(y0 + h + (int)(h * tileOverlapPercentage.tileOverlapDown),sourceImageHeight);
    final int xmin=Math.max(x0 - (int)(w * tileOverlapPercentage.tileOverlapLeft),0);
    final int xmax=Math.min(x0 + w + (int)(w * tileOverlapPercentage.tileOverlapRight),sourceImageWidth);
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
      final double delta=(double)dem.getDescriptor().getTileWidthInDegrees() / (double)dem.getDescriptor().getTileWidth();
      final double extralat=20 * delta;
      final double extralon=20 * delta;
      final double latMin=latLonMinMax[0] - extralat;
      final double latMax=latLonMinMax[1] + extralat;
      final double lonMin=latLonMinMax[2] - extralon;
      final double lonMax=latLonMinMax[3] + extralon;
      final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
      final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
      final int latMaxIdx=(int)Math.floor(upperLeft.getY());
      final int latMinIdx=(int)Math.ceil(lowerRight.getY());
      final int lonMinIdx=(int)Math.floor(upperLeft.getX());
      final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
      final int nLat=latMinIdx - latMaxIdx;
      final int nLon=lonMaxIdx - lonMinIdx;
      final PixelPos pix=new PixelPos();
      final PositionData posData=new PositionData();
      for (int i=0; i < nLat; i++) {
        final double[] azimuthIndex=new double[nLon];
        final double[] rangeIndex=new double[nLon];
        final double[] gamma0Area=new double[nLon];
        final double[] elevationAngle=new double[nLon];
        final boolean[] savePixel=new boolean[nLon];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[nLon];
        }
        for (int j=0; j < nLon; j++) {
          pix.setLocation(lonMinIdx + j,latMaxIdx + i);
          final GeoPos gp=dem.getGeoPos(pix);
          final double alt=dem.getElevation(gp);
          if (alt == demNoDataValue)           continue;
          if (!getPosition(gp.lat,gp.lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(i,j,dem,latMaxIdx,lonMinIdx,posData.earthPoint,posData.sensorPos);
          gamma0Area[j]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[j] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[j]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[j]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[j]=posData.rangeIndex;
          azimuthIndex[j]=posData.azimuthIndex;
          savePixel[j]=rangeIndex[j] > x0 - 1 && rangeIndex[j] < x0 + w && azimuthIndex[j] > y0 - 1 && azimuthIndex[j] < y0 + h;
        }
        if (orbitOnWest) {
          double maxElevAngle=0.0;
          for (int jj=0; jj < nLon; jj++) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] >= maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int jj=nLon - 1; jj >= 0; --jj) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] >= maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
 else {
      final int widthExt=xmax - xmin;
      final int heightExt=ymax - ymin;
      final double[][] localDEM=new double[heightExt + 2][widthExt + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,xmin,ymin,widthExt,heightExt);
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,xmin,ymin,widthExt,heightExt,sourceProduct,true,localDEM);
      if (!valid) {
        return false;
      }
      final PositionData posData=new PositionData();
      final GeoPos geoPos=new GeoPos();
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        final double[] azimuthIndex=new double[widthExt];
        final double[] rangeIndex=new double[widthExt];
        final double[] gamma0Area=new double[widthExt];
        final double[] elevationAngle=new double[widthExt];
        final boolean[] savePixel=new boolean[widthExt];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[widthExt];
        }
        for (int x=xmin; x < xmax; x++) {
          final int xx=x - xmin;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(xmin,ymin,x,y,tileGeoRef,localDEM,posData.earthPoint,posData.sensorPos);
          gamma0Area[xx]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[xx] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[xx]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[xx]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[xx]=posData.rangeIndex;
          azimuthIndex[xx]=posData.azimuthIndex;
          savePixel[xx]=rangeIndex[xx] > x0 - 1 && rangeIndex[xx] < x0 + w && azimuthIndex[xx] > y0 - 1 && azimuthIndex[xx] < y0 + h;
        }
        if (nearRangeOnLeft) {
          double maxElevAngle=0.0;
          for (int i=0; i < widthExt; i++) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int i=widthExt - 1; i >= 0; --i) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
  return true;
}","/** 
 * Generate simulated image for normalization.
 * @param x0             X coordinate of the upper left corner pixel of given tile.
 * @param y0             Y coordinate of the upper left corner pixel of given tile.
 * @param w              Width of given tile.
 * @param h              Height of given tile.
 * @param gamma0ReferenceArea The simulated image for flattened gamma0 generation.
 * @param sigma0ReferenceArea The simulated image for flattened sigma0 generation.
 * @return Boolean flag indicating if the simulation is successful.
 */
private boolean generateSimulatedImage(final int x0,final int y0,final int w,final int h,final OverlapPercentage tileOverlapPercentage,final double[][] gamma0ReferenceArea,final double[][] sigma0ReferenceArea){
  try {
    final int ymin=Math.max(y0 - (int)(h * tileOverlapPercentage.tileOverlapUp),0);
    final int ymax=Math.min(y0 + h + (int)(h * tileOverlapPercentage.tileOverlapDown),sourceImageHeight);
    final int xmin=Math.max(x0 - (int)(w * tileOverlapPercentage.tileOverlapLeft),0);
    final int xmax=Math.min(x0 + w + (int)(w * tileOverlapPercentage.tileOverlapRight),sourceImageWidth);
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
      final double delta=(double)dem.getDescriptor().getTileWidthInDegrees() / (double)dem.getDescriptor().getTileWidth();
      final double extralat=20 * delta;
      final double extralon=20 * delta;
      final double latMin=latLonMinMax[0] - extralat;
      final double latMax=latLonMinMax[1] + extralat;
      final double lonMin=latLonMinMax[2] - extralon;
      final double lonMax=latLonMinMax[3] + extralon;
      final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
      final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
      final int latMaxIdx=(int)Math.floor(upperLeft.getY());
      final int latMinIdx=(int)Math.ceil(lowerRight.getY());
      final int lonMinIdx=(int)Math.floor(upperLeft.getX());
      final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
      final int nLat=latMinIdx - latMaxIdx;
      final int nLon=lonMaxIdx - lonMinIdx;
      final PixelPos pix=new PixelPos();
      final PositionData posData=new PositionData();
      for (int i=0; i < nLat; i++) {
        final double[] azimuthIndex=new double[nLon];
        final double[] rangeIndex=new double[nLon];
        final double[] gamma0Area=new double[nLon];
        final double[] elevationAngle=new double[nLon];
        final boolean[] savePixel=new boolean[nLon];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[nLon];
        }
        for (int j=0; j < nLon; j++) {
          final double pixelX=lonMinIdx + j;
          final double pixelY=latMaxIdx + i;
          pix.setLocation(pixelX,pixelY);
          final GeoPos gp=dem.getGeoPos(pix);
          final double alt=dem.getSample(pixelX,pixelY);
          if (alt == demNoDataValue)           continue;
          if (!getPosition(gp.lat,gp.lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(pixelX,pixelY,dem,posData.earthPoint,posData.sensorPos);
          gamma0Area[j]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[j] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[j]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[j]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[j]=posData.rangeIndex;
          azimuthIndex[j]=posData.azimuthIndex;
          savePixel[j]=rangeIndex[j] > x0 - 1 && rangeIndex[j] < x0 + w && azimuthIndex[j] > y0 - 1 && azimuthIndex[j] < y0 + h;
        }
        if (orbitOnWest) {
          double maxElevAngle=0.0;
          for (int jj=0; jj < nLon; jj++) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] >= maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int jj=nLon - 1; jj >= 0; --jj) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] >= maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
 else {
      final int widthExt=xmax - xmin;
      final int heightExt=ymax - ymin;
      final double[][] localDEM=new double[heightExt + 2][widthExt + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,xmin,ymin,widthExt,heightExt);
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,xmin,ymin,widthExt,heightExt,sourceProduct,true,localDEM);
      if (!valid) {
        return false;
      }
      final PositionData posData=new PositionData();
      final GeoPos geoPos=new GeoPos();
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        final double[] azimuthIndex=new double[widthExt];
        final double[] rangeIndex=new double[widthExt];
        final double[] gamma0Area=new double[widthExt];
        final double[] elevationAngle=new double[widthExt];
        final boolean[] savePixel=new boolean[widthExt];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[widthExt];
        }
        for (int x=xmin; x < xmax; x++) {
          final int xx=x - xmin;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(xmin,ymin,x,y,tileGeoRef,localDEM,posData.earthPoint,posData.sensorPos);
          gamma0Area[xx]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[xx] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[xx]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[xx]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[xx]=posData.rangeIndex;
          azimuthIndex[xx]=posData.azimuthIndex;
          savePixel[xx]=rangeIndex[xx] > x0 - 1 && rangeIndex[xx] < x0 + w && azimuthIndex[xx] > y0 - 1 && azimuthIndex[xx] < y0 + h;
        }
        if (nearRangeOnLeft) {
          double maxElevAngle=0.0;
          for (int i=0; i < widthExt; i++) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int i=widthExt - 1; i >= 0; --i) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
  return true;
}"
11452,"public LocalGeometry(final int i,final int j,final ElevationModel dem,final double latMaxIdx,final double lonMinIdx,final PosVector earthPoint,final PosVector sensorPos) throws Exception {
  PixelPos pix=new PixelPos();
  GeoPos gp;
  pix.setLocation(lonMinIdx + j,latMaxIdx + i);
  gp=dem.getGeoPos(pix);
  this.t00Lat=gp.lat;
  this.t00Lon=gp.lon;
  this.t00Height=dem.getElevation(gp);
  pix.setLocation(lonMinIdx + j,latMaxIdx + i - 1);
  gp=dem.getGeoPos(pix);
  this.t01Lat=gp.lat;
  this.t01Lon=gp.lon;
  this.t01Height=dem.getElevation(gp);
  pix.setLocation(lonMinIdx + j + 1,latMaxIdx + i);
  gp=dem.getGeoPos(pix);
  this.t10Lat=gp.lat;
  this.t10Lon=gp.lon;
  this.t10Height=dem.getElevation(gp);
  pix.setLocation(lonMinIdx + j + 1,latMaxIdx + i - 1);
  gp=dem.getGeoPos(pix);
  this.t11Lat=gp.lat;
  this.t11Lon=gp.lon;
  this.t11Height=dem.getElevation(gp);
  this.centerPoint=earthPoint;
  this.sensorPos=sensorPos;
}","public LocalGeometry(final double pixelX,final double pixelY,final ElevationModel dem,final PosVector earthPoint,final PosVector sensorPos) throws Exception {
  PixelPos pix=new PixelPos();
  GeoPos gp;
  pix.setLocation(pixelX,pixelY);
  gp=dem.getGeoPos(pix);
  this.t00Lat=gp.lat;
  this.t00Lon=gp.lon;
  this.t00Height=dem.getSample(pixelX,pixelY);
  pix.setLocation(pixelX,pixelY - 1);
  gp=dem.getGeoPos(pix);
  this.t01Lat=gp.lat;
  this.t01Lon=gp.lon;
  this.t01Height=dem.getSample(pixelX,pixelY);
  pix.setLocation(pixelX + 1,pixelY);
  gp=dem.getGeoPos(pix);
  this.t10Lat=gp.lat;
  this.t10Lon=gp.lon;
  this.t10Height=dem.getSample(pixelX,pixelY);
  pix.setLocation(pixelX + 1,pixelY - 1);
  gp=dem.getGeoPos(pix);
  this.t11Lat=gp.lat;
  this.t11Lon=gp.lon;
  this.t11Height=dem.getSample(pixelX,pixelY);
  this.centerPoint=earthPoint;
  this.sensorPos=sensorPos;
}"
11453,"/** 
 * Retrieve required data from Abstracted Metadata
 * @throws Exception if metadata not found
 */
private void getMetadata() throws Exception {
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
  srgrFlag=AbstractMetadata.getAttributeBoolean(absRoot,AbstractMetadata.srgr_flag);
  wavelength=SARUtils.getRadarFrequency(absRoot);
  rangeSpacing=AbstractMetadata.getAttributeDouble(absRoot,AbstractMetadata.range_spacing);
  azimuthSpacing=AbstractMetadata.getAttributeDouble(absRoot,AbstractMetadata.azimuth_spacing);
  firstLineUTC=AbstractMetadata.parseUTC(absRoot.getAttributeString(AbstractMetadata.first_line_time)).getMJD();
  lastLineUTC=AbstractMetadata.parseUTC(absRoot.getAttributeString(AbstractMetadata.last_line_time)).getMJD();
  lineTimeInterval=absRoot.getAttributeDouble(AbstractMetadata.line_time_interval) / Constants.secondsInDay;
  orbitStateVectors=AbstractMetadata.getOrbitStateVectors(absRoot);
  if (srgrFlag) {
    srgrConvParams=AbstractMetadata.getSRGRCoefficients(absRoot);
  }
 else {
    nearEdgeSlantRange=AbstractMetadata.getAttributeDouble(absRoot,AbstractMetadata.slant_range_to_first_pixel);
  }
  final String mission=RangeDopplerGeocodingOp.getMissionType(absRoot);
  final String pass=absRoot.getAttributeString(""String_Node_Str"");
  if (mission.equals(""String_Node_Str"") && pass.contains(""String_Node_Str"")) {
    nearRangeOnLeft=false;
  }
  if (mission.contains(""String_Node_Str"") || mission.contains(""String_Node_Str"") || mission.equals(""String_Node_Str"")|| mission.contains(""String_Node_Str"")) {
    skipBistaticCorrection=true;
  }
  final String prodType=absRoot.getAttributeString(AbstractMetadata.PRODUCT_TYPE);
  if (!prodType.contains(""String_Node_Str"")) {
    isGRD=true;
  }
}","/** 
 * Retrieve required data from Abstracted Metadata
 * @throws Exception if metadata not found
 */
private void getMetadata() throws Exception {
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
  srgrFlag=AbstractMetadata.getAttributeBoolean(absRoot,AbstractMetadata.srgr_flag);
  wavelength=SARUtils.getRadarFrequency(absRoot);
  rangeSpacing=AbstractMetadata.getAttributeDouble(absRoot,AbstractMetadata.range_spacing);
  azimuthSpacing=AbstractMetadata.getAttributeDouble(absRoot,AbstractMetadata.azimuth_spacing);
  firstLineUTC=AbstractMetadata.parseUTC(absRoot.getAttributeString(AbstractMetadata.first_line_time)).getMJD();
  lastLineUTC=AbstractMetadata.parseUTC(absRoot.getAttributeString(AbstractMetadata.last_line_time)).getMJD();
  lineTimeInterval=absRoot.getAttributeDouble(AbstractMetadata.line_time_interval) / Constants.secondsInDay;
  orbitStateVectors=AbstractMetadata.getOrbitStateVectors(absRoot);
  if (srgrFlag) {
    srgrConvParams=AbstractMetadata.getSRGRCoefficients(absRoot);
  }
 else {
    nearEdgeSlantRange=AbstractMetadata.getAttributeDouble(absRoot,AbstractMetadata.slant_range_to_first_pixel);
  }
  final String mission=RangeDopplerGeocodingOp.getMissionType(absRoot);
  final String pass=absRoot.getAttributeString(AbstractMetadata.PASS);
  final String antennaPointing=absRoot.getAttributeString(AbstractMetadata.antenna_pointing);
  if (mission.equals(""String_Node_Str"") && pass.contains(""String_Node_Str"")) {
    nearRangeOnLeft=false;
  }
  if ((pass.contains(""String_Node_Str"") && antennaPointing.contains(""String_Node_Str"")) || (pass.contains(""String_Node_Str"") && antennaPointing.contains(""String_Node_Str""))) {
    orbitOnWest=false;
  }
  if (mission.contains(""String_Node_Str"") || mission.contains(""String_Node_Str"") || mission.equals(""String_Node_Str"")|| mission.contains(""String_Node_Str"")) {
    skipBistaticCorrection=true;
  }
  final String prodType=absRoot.getAttributeString(AbstractMetadata.PRODUCT_TYPE);
  if (!prodType.contains(""String_Node_Str"")) {
    isGRD=true;
  }
}"
11454,"/** 
 * Generate simulated image for normalization.
 * @param x0             X coordinate of the upper left corner pixel of given tile.
 * @param y0             Y coordinate of the upper left corner pixel of given tile.
 * @param w              Width of given tile.
 * @param h              Height of given tile.
 * @param gamma0ReferenceArea The simulated image for flattened gamma0 generation.
 * @param sigma0ReferenceArea The simulated image for flattened sigma0 generation.
 * @return Boolean flag indicating if the simulation is successful.
 */
private boolean generateSimulatedImage(final int x0,final int y0,final int w,final int h,final OverlapPercentage tileOverlapPercentage,final double[][] gamma0ReferenceArea,final double[][] sigma0ReferenceArea){
  try {
    final int ymin=Math.max(y0 - (int)(h * tileOverlapPercentage.tileOverlapUp),0);
    final int ymax=Math.min(y0 + h + (int)(h * tileOverlapPercentage.tileOverlapDown),sourceImageHeight);
    final int xmin=Math.max(x0 - (int)(w * tileOverlapPercentage.tileOverlapLeft),0);
    final int xmax=Math.min(x0 + w + (int)(w * tileOverlapPercentage.tileOverlapRight),sourceImageWidth);
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
      final double delta=(double)dem.getDescriptor().getTileWidthInDegrees() / (double)dem.getDescriptor().getTileWidth();
      final double extralat=20 * delta;
      final double extralon=20 * delta;
      final double latMin=latLonMinMax[0] - extralat;
      final double latMax=latLonMinMax[1] + extralat;
      final double lonMin=latLonMinMax[2] - extralon;
      final double lonMax=latLonMinMax[3] + extralon;
      final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
      final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
      final int latMaxIdx=(int)Math.floor(upperLeft.getY());
      final int latMinIdx=(int)Math.ceil(lowerRight.getY());
      final int lonMinIdx=(int)Math.floor(upperLeft.getX());
      final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
      final int nLat=latMinIdx - latMaxIdx;
      final int nLon=lonMaxIdx - lonMinIdx;
      final PixelPos pix=new PixelPos();
      final PositionData posData=new PositionData();
      for (int i=0; i < nLat; i++) {
        final double[] azimuthIndex=new double[nLon];
        final double[] rangeIndex=new double[nLon];
        final double[] gamma0Area=new double[nLon];
        final double[] elevationAngle=new double[nLon];
        final boolean[] savePixel=new boolean[nLon];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[nLon];
        }
        for (int j=0; j < nLon; j++) {
          pix.setLocation(lonMinIdx + j,latMaxIdx + i);
          final GeoPos gp=dem.getGeoPos(pix);
          final double alt=dem.getElevation(gp);
          if (alt == demNoDataValue)           continue;
          if (!getPosition(gp.lat,gp.lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(i,j,dem,latMaxIdx,lonMinIdx,posData.earthPoint,posData.sensorPos);
          gamma0Area[j]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[j] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[j]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[j]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[j]=posData.rangeIndex;
          azimuthIndex[j]=posData.azimuthIndex;
          savePixel[j]=rangeIndex[j] > x0 - 1 && rangeIndex[j] < x0 + w && azimuthIndex[j] > y0 - 1 && azimuthIndex[j] < y0 + h;
        }
        if (nearRangeOnLeft) {
          double maxElevAngle=0.0;
          for (int jj=0; jj < nLon; jj++) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int jj=nLon - 1; jj >= 0; --jj) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
 else {
      final int widthExt=xmax - xmin;
      final int heightExt=ymax - ymin;
      final double[][] localDEM=new double[heightExt + 2][widthExt + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,xmin,ymin,widthExt,heightExt);
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,xmin,ymin,widthExt,heightExt,sourceProduct,true,localDEM);
      if (!valid) {
        return false;
      }
      final PositionData posData=new PositionData();
      final GeoPos geoPos=new GeoPos();
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        final double[] azimuthIndex=new double[widthExt];
        final double[] rangeIndex=new double[widthExt];
        final double[] gamma0Area=new double[widthExt];
        final double[] elevationAngle=new double[widthExt];
        final boolean[] savePixel=new boolean[widthExt];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[widthExt];
        }
        for (int x=xmin; x < xmax; x++) {
          final int xx=x - xmin;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(xmin,ymin,x,y,tileGeoRef,localDEM,posData.earthPoint,posData.sensorPos);
          gamma0Area[xx]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[xx] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[xx]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[xx]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[xx]=posData.rangeIndex;
          azimuthIndex[xx]=posData.azimuthIndex;
          savePixel[xx]=rangeIndex[xx] > x0 - 1 && rangeIndex[xx] < x0 + w && azimuthIndex[xx] > y0 - 1 && azimuthIndex[xx] < y0 + h;
        }
        if (nearRangeOnLeft) {
          double maxElevAngle=0.0;
          for (int i=0; i < widthExt; i++) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int i=widthExt - 1; i >= 0; --i) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
  return true;
}","/** 
 * Generate simulated image for normalization.
 * @param x0             X coordinate of the upper left corner pixel of given tile.
 * @param y0             Y coordinate of the upper left corner pixel of given tile.
 * @param w              Width of given tile.
 * @param h              Height of given tile.
 * @param gamma0ReferenceArea The simulated image for flattened gamma0 generation.
 * @param sigma0ReferenceArea The simulated image for flattened sigma0 generation.
 * @return Boolean flag indicating if the simulation is successful.
 */
private boolean generateSimulatedImage(final int x0,final int y0,final int w,final int h,final OverlapPercentage tileOverlapPercentage,final double[][] gamma0ReferenceArea,final double[][] sigma0ReferenceArea){
  try {
    final int ymin=Math.max(y0 - (int)(h * tileOverlapPercentage.tileOverlapUp),0);
    final int ymax=Math.min(y0 + h + (int)(h * tileOverlapPercentage.tileOverlapDown),sourceImageHeight);
    final int xmin=Math.max(x0 - (int)(w * tileOverlapPercentage.tileOverlapLeft),0);
    final int xmax=Math.min(x0 + w + (int)(w * tileOverlapPercentage.tileOverlapRight),sourceImageWidth);
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
      final double delta=(double)dem.getDescriptor().getTileWidthInDegrees() / (double)dem.getDescriptor().getTileWidth();
      final double extralat=20 * delta;
      final double extralon=20 * delta;
      final double latMin=latLonMinMax[0] - extralat;
      final double latMax=latLonMinMax[1] + extralat;
      final double lonMin=latLonMinMax[2] - extralon;
      final double lonMax=latLonMinMax[3] + extralon;
      final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
      final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
      final int latMaxIdx=(int)Math.floor(upperLeft.getY());
      final int latMinIdx=(int)Math.ceil(lowerRight.getY());
      final int lonMinIdx=(int)Math.floor(upperLeft.getX());
      final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
      final int nLat=latMinIdx - latMaxIdx;
      final int nLon=lonMaxIdx - lonMinIdx;
      final PixelPos pix=new PixelPos();
      final PositionData posData=new PositionData();
      for (int i=0; i < nLat; i++) {
        final double[] azimuthIndex=new double[nLon];
        final double[] rangeIndex=new double[nLon];
        final double[] gamma0Area=new double[nLon];
        final double[] elevationAngle=new double[nLon];
        final boolean[] savePixel=new boolean[nLon];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[nLon];
        }
        for (int j=0; j < nLon; j++) {
          pix.setLocation(lonMinIdx + j,latMaxIdx + i);
          final GeoPos gp=dem.getGeoPos(pix);
          final double alt=dem.getElevation(gp);
          if (alt == demNoDataValue)           continue;
          if (!getPosition(gp.lat,gp.lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(i,j,dem,latMaxIdx,lonMinIdx,posData.earthPoint,posData.sensorPos);
          gamma0Area[j]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[j] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[j]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[j]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[j]=posData.rangeIndex;
          azimuthIndex[j]=posData.azimuthIndex;
          savePixel[j]=rangeIndex[j] > x0 - 1 && rangeIndex[j] < x0 + w && azimuthIndex[j] > y0 - 1 && azimuthIndex[j] < y0 + h;
        }
        if (orbitOnWest) {
          double maxElevAngle=0.0;
          for (int jj=0; jj < nLon; jj++) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] >= maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int jj=nLon - 1; jj >= 0; --jj) {
            if (savePixel[jj] && (detectShadow && elevationAngle[jj] >= maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[jj];
              saveGamma0Area(x0,y0,w,h,gamma0Area[jj],azimuthIndex[jj],rangeIndex[jj],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[jj],azimuthIndex[jj],rangeIndex[jj],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
 else {
      final int widthExt=xmax - xmin;
      final int heightExt=ymax - ymin;
      final double[][] localDEM=new double[heightExt + 2][widthExt + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,xmin,ymin,widthExt,heightExt);
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,xmin,ymin,widthExt,heightExt,sourceProduct,true,localDEM);
      if (!valid) {
        return false;
      }
      final PositionData posData=new PositionData();
      final GeoPos geoPos=new GeoPos();
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        final double[] azimuthIndex=new double[widthExt];
        final double[] rangeIndex=new double[widthExt];
        final double[] gamma0Area=new double[widthExt];
        final double[] elevationAngle=new double[widthExt];
        final boolean[] savePixel=new boolean[widthExt];
        double[] sigma0Area=null;
        if (outputSigma0) {
          sigma0Area=new double[widthExt];
        }
        for (int x=xmin; x < xmax; x++) {
          final int xx=x - xmin;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(xmin,ymin,x,y,tileGeoRef,localDEM,posData.earthPoint,posData.sensorPos);
          gamma0Area[xx]=computeGamma0Area(localGeometry,demNoDataValue,noDataValue);
          if (gamma0Area[xx] == noDataValue)           continue;
          if (outputSigma0) {
            sigma0Area[xx]=computeSigma0Area(localGeometry,demNoDataValue,noDataValue);
          }
          elevationAngle[xx]=computeElevationAngle(posData.earthPoint,posData.sensorPos);
          rangeIndex[xx]=posData.rangeIndex;
          azimuthIndex[xx]=posData.azimuthIndex;
          savePixel[xx]=rangeIndex[xx] > x0 - 1 && rangeIndex[xx] < x0 + w && azimuthIndex[xx] > y0 - 1 && azimuthIndex[xx] < y0 + h;
        }
        if (nearRangeOnLeft) {
          double maxElevAngle=0.0;
          for (int i=0; i < widthExt; i++) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
 else {
          double maxElevAngle=0.0;
          for (int i=widthExt - 1; i >= 0; --i) {
            if (savePixel[i] && (detectShadow && elevationAngle[i] > maxElevAngle || !detectShadow)) {
              maxElevAngle=elevationAngle[i];
              saveGamma0Area(x0,y0,w,h,gamma0Area[i],azimuthIndex[i],rangeIndex[i],gamma0ReferenceArea);
              if (outputSigma0) {
                saveSigma0Area(x0,y0,w,h,sigma0Area[i],azimuthIndex[i],rangeIndex[i],sigma0ReferenceArea);
              }
            }
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
  return true;
}"
11455,"private boolean getPosition(final double lat,final double lon,final double alt,final int x0,final int y0,final int w,final int h,final PositionData data){
  GeoUtils.geo2xyzWGS84(lat,lon,alt,data.earthPoint);
  final double zeroDopplerTime=SARGeocoding.getEarthPointZeroDopplerTime(firstLineUTC,lineTimeInterval,wavelength,data.earthPoint,orbit.sensorPosition,orbit.sensorVelocity);
  if (zeroDopplerTime == SARGeocoding.NonValidZeroDopplerTime) {
    return false;
  }
  data.slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,data.earthPoint,data.sensorPos);
  final double zeroDopplerTimeWithoutBias=zeroDopplerTime + data.slantRange / Constants.lightSpeedInMetersPerDay;
  data.azimuthIndex=(zeroDopplerTimeWithoutBias - firstLineUTC) / lineTimeInterval;
  if (!(data.azimuthIndex >= y0 - 1 && data.azimuthIndex <= y0 + h)) {
    return false;
  }
  data.slantRange=SARGeocoding.computeSlantRange(zeroDopplerTimeWithoutBias,orbit,data.earthPoint,data.sensorPos);
  if (!srgrFlag) {
    data.rangeIndex=(data.slantRange - nearEdgeSlantRange) / rangeSpacing;
  }
 else {
    data.rangeIndex=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDopplerTimeWithoutBias,data.slantRange,nearEdgeSlantRange,srgrConvParams);
  }
  if (!nearRangeOnLeft) {
    data.rangeIndex=sourceImageWidth - 1 - data.rangeIndex;
  }
  if (!(data.rangeIndex >= x0 - 1 && data.rangeIndex <= x0 + w)) {
    return false;
  }
  return true;
}","private boolean getPosition(final double lat,final double lon,final double alt,final int x0,final int y0,final int w,final int h,final PositionData data){
  GeoUtils.geo2xyzWGS84(lat,lon,alt,data.earthPoint);
  final double zeroDopplerTime=SARGeocoding.getZeroDopplerTime(firstLineUTC,lineTimeInterval,wavelength,data.earthPoint,orbit);
  if (zeroDopplerTime == SARGeocoding.NonValidZeroDopplerTime) {
    return false;
  }
  data.slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,data.earthPoint,data.sensorPos);
  data.azimuthIndex=(zeroDopplerTime - firstLineUTC) / lineTimeInterval;
  if (!(data.azimuthIndex >= y0 - 1 && data.azimuthIndex <= y0 + h)) {
    return false;
  }
  if (!srgrFlag) {
    data.rangeIndex=(data.slantRange - nearEdgeSlantRange) / rangeSpacing;
  }
 else {
    data.rangeIndex=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDopplerTime,data.slantRange,nearEdgeSlantRange,srgrConvParams);
  }
  if (!nearRangeOnLeft) {
    data.rangeIndex=sourceImageWidth - 1 - data.rangeIndex;
  }
  if (!(data.rangeIndex >= x0 - 1 && data.rangeIndex <= x0 + w)) {
    return false;
  }
  return true;
}"
11456,"/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.snap.framework.datamodel.Product}annotated with the   {@link org.esa.snap.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    final InputProductValidator validator=new InputProductValidator(sourceProduct);
    validator.checkIfMapProjected(false);
    if (!validator.isCalibrated(sourceProduct)) {
      throw new OperatorException(""String_Node_Str"");
    }
    getMetadata();
    getTiePointGrid();
    getSourceImageDimension();
    computeSensorPositionsAndVelocities();
    createTargetProduct();
    if (externalDEMFile == null) {
      DEMFactory.checkIfDEMInstalled(demName);
    }
    DEMFactory.validateDEM(demName,sourceProduct);
    noDataValue=sourceProduct.getBands()[0].getNoDataValue();
    beta0=azimuthSpacing * rangeSpacing;
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.snap.framework.datamodel.Product}annotated with the   {@link org.esa.snap.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  outputSimulatedImage=true;
  try {
    final InputProductValidator validator=new InputProductValidator(sourceProduct);
    validator.checkIfMapProjected(false);
    if (!validator.isCalibrated(sourceProduct)) {
      throw new OperatorException(""String_Node_Str"");
    }
    getMetadata();
    getTiePointGrid();
    getSourceImageDimension();
    computeSensorPositionsAndVelocities();
    createTargetProduct();
    if (externalDEMFile == null) {
      DEMFactory.checkIfDEMInstalled(demName);
    }
    DEMFactory.validateDEM(demName,sourceProduct);
    noDataValue=sourceProduct.getBands()[0].getNoDataValue();
    beta0=azimuthSpacing * rangeSpacing;
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11457,"public void removeFactorsForCurrentTile(Band targetBand,Tile targetTile,String srcBandName) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final ProductData trgData=targetTile.getDataBuffer();
  final Band sourceBand1=sourceProduct.getBand(srcBandName);
  final Tile sourceTile=getSourceTile(sourceBand1,targetTileRectangle);
  final ProductData srcData=sourceTile.getDataBuffer();
  final String[] srcBandNames={targetBand.getName()};
  Band sourceBand2=null;
  if (srcBandNames.length > 1) {
    sourceBand2=sourceProduct.getBand(srcBandNames[1]);
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
  if (applyADCSaturationCorrection && !adcHasBeenTestedFlag) {
    testADC(sourceBand1,sourceBand2,bandUnit);
  }
  boolean applyADCSaturationCorrectionToCurrentTile=false;
  if (applyADCSaturationCorrection && th >= blockHeight && tw >= blockWidth) {
    applyADCSaturationCorrectionToCurrentTile=true;
  }
  double[][] adcPowerLoss=null;
  if (applyADCSaturationCorrectionToCurrentTile) {
    adcPowerLoss=computeADCPowerLossValuesForCurrentTile(sourceBand1,sourceBand2,tx0,ty0,tw,th,bandUnit);
  }
  double sigma=0.0;
  int adcJ=0;
  for (int x=tx0; x < tx0 + tw; x++) {
    double antennaPatternByRangeSpreadingLoss=0.0;
    if (!isComplex) {
      antennaPatternByRangeSpreadingLoss=antennaPatternGain[x] / rangeSpreadingLoss[x];
    }
    if (applyADCSaturationCorrectionToCurrentTile) {
      adcJ=Math.min(((x - tx0) / blockWidth),adcPowerLoss[0].length - 1);
    }
    for (int y=ty0; y < ty0 + th; y++) {
      final int srcIndex=sourceTile.getDataBufferIndex(x,y);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        final double dn=srcData.getElemDoubleAt(srcIndex);
        sigma=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
        sigma=FastMath.pow(10,srcData.getElemDoubleAt(srcIndex) / 5.0);
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        sigma=srcData.getElemDoubleAt(srcIndex);
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY_DB) {
        sigma=FastMath.pow(10,srcData.getElemDoubleAt(srcIndex) / 10.0);
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      if (!isComplex) {
        sigma*=antennaPatternByRangeSpreadingLoss;
      }
      if (!isERS1Mission) {
        sigma/=replicaPulseVariationsCorrectionFactor;
      }
      if (applyADCSaturationCorrectionToCurrentTile) {
        final int adcI=Math.min(((y - ty0) / blockHeight),adcPowerLoss.length - 1);
        sigma*=adcPowerLoss[adcI][adcJ];
      }
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        trgData.setElemDoubleAt(srcIndex,Math.sqrt(sigma));
      }
 else       if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
        trgData.setElemDoubleAt(srcIndex,5.0 * Math.log10(sigma));
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        trgData.setElemDoubleAt(srcIndex,sigma);
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY_DB) {
        trgData.setElemDoubleAt(srcIndex,10.0 * Math.log10(sigma));
      }
    }
  }
}","public void removeFactorsForCurrentTile(Band targetBand,Tile targetTile,String srcBandName) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final ProductData trgData=targetTile.getDataBuffer();
  final Band sourceBand1=sourceProduct.getBand(srcBandName);
  final Tile sourceTile=getSourceTile(sourceBand1,targetTileRectangle);
  final ProductData srcData=sourceTile.getDataBuffer();
  final String[] srcBandNames={targetBand.getName()};
  Band sourceBand2=null;
  if (srcBandNames.length > 1) {
    sourceBand2=sourceProduct.getBand(srcBandNames[1]);
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
  if (applyADCSaturationCorrection && !adcHasBeenTestedFlag) {
    testADC(sourceBand1,sourceBand2,bandUnit);
  }
  boolean applyADCSaturationCorrectionToCurrentTile=false;
  if (applyADCSaturationCorrection && th >= blockHeight && tw >= blockWidth) {
    applyADCSaturationCorrectionToCurrentTile=true;
  }
  double[][] adcPowerLoss=null;
  if (applyADCSaturationCorrectionToCurrentTile) {
    adcPowerLoss=computeADCPowerLossValuesForCurrentTile(sourceBand1,sourceBand2,tx0,ty0,tw,th,bandUnit);
  }
  double sigma=0.0;
  int adcJ=0;
  for (int x=tx0; x < tx0 + tw; x++) {
    double antennaPatternByRangeSpreadingLoss=0.0;
    if (!isComplex) {
      antennaPatternByRangeSpreadingLoss=antennaPatternGain[x] / rangeSpreadingLoss[x];
    }
    if (applyADCSaturationCorrectionToCurrentTile) {
      adcJ=Math.min(((x - tx0) / blockWidth),adcPowerLoss[0].length - 1);
    }
    for (int y=ty0; y < ty0 + th; y++) {
      final int srcIndex=sourceTile.getDataBufferIndex(x,y);
      final int tgtIndex=targetTile.getDataBufferIndex(x,y);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        final double dn=srcData.getElemDoubleAt(srcIndex);
        sigma=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
        sigma=FastMath.pow(10,srcData.getElemDoubleAt(srcIndex) / 5.0);
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        sigma=srcData.getElemDoubleAt(srcIndex);
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY_DB) {
        sigma=FastMath.pow(10,srcData.getElemDoubleAt(srcIndex) / 10.0);
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      if (!isComplex) {
        sigma*=antennaPatternByRangeSpreadingLoss;
      }
      if (!isERS1Mission) {
        sigma/=replicaPulseVariationsCorrectionFactor;
      }
      if (applyADCSaturationCorrectionToCurrentTile) {
        final int adcI=Math.min(((y - ty0) / blockHeight),adcPowerLoss.length - 1);
        sigma*=adcPowerLoss[adcI][adcJ];
      }
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        trgData.setElemDoubleAt(tgtIndex,Math.sqrt(sigma));
      }
 else       if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
        trgData.setElemDoubleAt(tgtIndex,5.0 * Math.log10(sigma));
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        trgData.setElemDoubleAt(tgtIndex,sigma);
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY_DB) {
        trgData.setElemDoubleAt(tgtIndex,10.0 * Math.log10(sigma));
      }
    }
  }
}"
11458,"private void computeTileInOneSwathShort(final int tx0,final int ty0,final int txMax,final int tyMax,final int firstSubSwathIndex,final Rectangle[] sourceRectangle,final String tgtBandName,final Tile tgtTile){
  final int yMin=computeYMin(subSwath[firstSubSwathIndex]);
  final int yMax=computeYMax(subSwath[firstSubSwathIndex]);
  final int xMin=computeXMin(subSwath[firstSubSwathIndex]);
  final int xMax=computeXMax(subSwath[firstSubSwathIndex]);
  final int firstY=Math.max(ty0,yMin);
  final int lastY=Math.min(tyMax,yMax + 1);
  final int firstX=Math.max(tx0,xMin);
  final int lastX=Math.min(txMax,xMax + 1);
  if (firstY >= lastY || firstX >= lastX) {
    return;
  }
  final String swathIndexStr=String.valueOf(getSubSwathIndex(subSwath[firstSubSwathIndex].subSwathName));
  final Band srcBand=getSourceBandFromTargetBandName(tgtBandName,acquisitionMode,swathIndexStr);
  final Tile srcRaster=getSourceTile(srcBand,sourceRectangle[0]);
  final TileIndex srcTileIndex=new TileIndex(srcRaster);
  final TileIndex tgtIndex=new TileIndex(tgtTile);
  final short[] srcArray=(short[])srcRaster.getDataBuffer().getElems();
  final short[] tgtArray=(short[])tgtTile.getDataBuffer().getElems();
  for (int y=firstY; y < lastY; y++) {
    final int sy0=getLineIndexInSourceProduct(y,subSwath[firstSubSwathIndex]);
    final int tgtOffset=tgtIndex.calculateStride(y);
    final Sentinel1Utils.SubSwathInfo firstSubSwath=subSwath[firstSubSwathIndex];
    final int offset=srcTileIndex.calculateStride(sy0);
    final int sx0=(int)Math.round(((targetSlantRangeTimeToFirstPixel + firstX * targetDeltaSlantRangeTime) - firstSubSwath.slrTimeToFirstValidPixel) / targetDeltaSlantRangeTime);
    System.arraycopy(srcArray,sx0 - offset,tgtArray,firstX - tgtOffset,lastX - firstX);
  }
}","private void computeTileInOneSwathShort(final int tx0,final int ty0,final int txMax,final int tyMax,final int firstSubSwathIndex,final Rectangle[] sourceRectangle,final String tgtBandName,final Tile tgtTile){
  final int yMin=computeYMin(subSwath[firstSubSwathIndex]);
  final int yMax=computeYMax(subSwath[firstSubSwathIndex]);
  final int xMin=computeXMin(subSwath[firstSubSwathIndex]);
  final int xMax=computeXMax(subSwath[firstSubSwathIndex]);
  final int firstY=Math.max(ty0,yMin);
  final int lastY=Math.min(tyMax,yMax + 1);
  final int firstX=Math.max(tx0,xMin);
  final int lastX=Math.min(txMax,xMax + 1);
  if (firstY >= lastY || firstX >= lastX) {
    return;
  }
  final String swathIndexStr=String.valueOf(getSubSwathIndex(subSwath[firstSubSwathIndex].subSwathName));
  final Band srcBand=getSourceBandFromTargetBandName(tgtBandName,acquisitionMode,swathIndexStr);
  final Tile srcRaster=getSourceTile(srcBand,sourceRectangle[0]);
  final TileIndex srcTileIndex=new TileIndex(srcRaster);
  final TileIndex tgtIndex=new TileIndex(tgtTile);
  final short[] srcArray=(short[])srcRaster.getDataBuffer().getElems();
  final short[] tgtArray=(short[])tgtTile.getDataBuffer().getElems();
  for (int y=firstY; y < lastY; y++) {
    final int sy0=getLineIndexInSourceProduct(y,subSwath[firstSubSwathIndex]);
    final int tgtOffset=tgtIndex.calculateStride(y);
    final Sentinel1Utils.SubSwathInfo firstSubSwath=subSwath[firstSubSwathIndex];
    final int offset=srcTileIndex.calculateStride(sy0);
    final int sx0=(int)Math.round(((targetSlantRangeTimeToFirstPixel + firstX * targetDeltaSlantRangeTime) - firstSubSwath.slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    System.arraycopy(srcArray,sx0 - offset,tgtArray,firstX - tgtOffset,lastX - firstX);
  }
}"
11459,"private int getSampleIndexInSourceProduct(final int tx,final Sentinel1Utils.SubSwathInfo subSwath){
  final int sx=(int)((((targetSlantRangeTimeToFirstPixel + tx * targetDeltaSlantRangeTime) - subSwath.slrTimeToFirstValidPixel) / targetDeltaSlantRangeTime) + 0.5);
  final int numOfValidSamples=subSwath.lastValidPixel - subSwath.firstValidPixel + 1;
  return sx < 0 ? 0 : sx > numOfValidSamples - 1 ? numOfValidSamples - 1 : sx;
}","private int getSampleIndexInSourceProduct(final int tx,final Sentinel1Utils.SubSwathInfo subSwath){
  final int sx=(int)((((targetSlantRangeTimeToFirstPixel + tx * targetDeltaSlantRangeTime) - subSwath.slrTimeToFirstPixel) / targetDeltaSlantRangeTime) + 0.5);
  return sx < 0 ? 0 : sx > subSwath.numOfSamples - 1 ? subSwath.numOfSamples - 1 : sx;
}"
11460,"private void computeTileInOneSwathFloat(final int tx0,final int ty0,final int txMax,final int tyMax,final int firstSubSwathIndex,final Rectangle[] sourceRectangle,final String tgtBandName,final Tile tgtTile){
  final int yMin=computeYMin(subSwath[firstSubSwathIndex]);
  final int yMax=computeYMax(subSwath[firstSubSwathIndex]);
  final int xMin=computeXMin(subSwath[firstSubSwathIndex]);
  final int xMax=computeXMax(subSwath[firstSubSwathIndex]);
  final int firstY=Math.max(ty0,yMin);
  final int lastY=Math.min(tyMax,yMax + 1);
  final int firstX=Math.max(tx0,xMin);
  final int lastX=Math.min(txMax,xMax + 1);
  if (firstY >= lastY || firstX >= lastX) {
    return;
  }
  final String swathIndexStr=String.valueOf(getSubSwathIndex(subSwath[firstSubSwathIndex].subSwathName));
  final Band srcBand=getSourceBandFromTargetBandName(tgtBandName,acquisitionMode,swathIndexStr);
  final Tile srcRaster=getSourceTile(srcBand,sourceRectangle[0]);
  final TileIndex srcTileIndex=new TileIndex(srcRaster);
  final TileIndex tgtIndex=new TileIndex(tgtTile);
  final float[] srcArray=(float[])srcRaster.getDataBuffer().getElems();
  final float[] tgtArray=(float[])tgtTile.getDataBuffer().getElems();
  for (int y=firstY; y < lastY; y++) {
    final int sy0=getLineIndexInSourceProduct(y,subSwath[firstSubSwathIndex]);
    final int tgtOffset=tgtIndex.calculateStride(y);
    final Sentinel1Utils.SubSwathInfo firstSubSwath=subSwath[firstSubSwathIndex];
    int offset=srcTileIndex.calculateStride(sy0);
    final int sx0=(int)Math.round(((targetSlantRangeTimeToFirstPixel + firstX * targetDeltaSlantRangeTime) - firstSubSwath.slrTimeToFirstValidPixel) / targetDeltaSlantRangeTime);
    System.arraycopy(srcArray,sx0 - offset,tgtArray,firstX - tgtOffset,lastX - firstX);
  }
}","private void computeTileInOneSwathFloat(final int tx0,final int ty0,final int txMax,final int tyMax,final int firstSubSwathIndex,final Rectangle[] sourceRectangle,final String tgtBandName,final Tile tgtTile){
  final int yMin=computeYMin(subSwath[firstSubSwathIndex]);
  final int yMax=computeYMax(subSwath[firstSubSwathIndex]);
  final int xMin=computeXMin(subSwath[firstSubSwathIndex]);
  final int xMax=computeXMax(subSwath[firstSubSwathIndex]);
  final int firstY=Math.max(ty0,yMin);
  final int lastY=Math.min(tyMax,yMax + 1);
  final int firstX=Math.max(tx0,xMin);
  final int lastX=Math.min(txMax,xMax + 1);
  if (firstY >= lastY || firstX >= lastX) {
    return;
  }
  final String swathIndexStr=String.valueOf(getSubSwathIndex(subSwath[firstSubSwathIndex].subSwathName));
  final Band srcBand=getSourceBandFromTargetBandName(tgtBandName,acquisitionMode,swathIndexStr);
  final Tile srcRaster=getSourceTile(srcBand,sourceRectangle[0]);
  final TileIndex srcTileIndex=new TileIndex(srcRaster);
  final TileIndex tgtIndex=new TileIndex(tgtTile);
  final float[] srcArray=(float[])srcRaster.getDataBuffer().getElems();
  final float[] tgtArray=(float[])tgtTile.getDataBuffer().getElems();
  for (int y=firstY; y < lastY; y++) {
    final int sy0=getLineIndexInSourceProduct(y,subSwath[firstSubSwathIndex]);
    final int tgtOffset=tgtIndex.calculateStride(y);
    final Sentinel1Utils.SubSwathInfo firstSubSwath=subSwath[firstSubSwathIndex];
    int offset=srcTileIndex.calculateStride(sy0);
    final int sx0=(int)Math.round(((targetSlantRangeTimeToFirstPixel + firstX * targetDeltaSlantRangeTime) - firstSubSwath.slrTimeToFirstPixel) / targetDeltaSlantRangeTime);
    System.arraycopy(srcArray,sx0 - offset,tgtArray,firstX - tgtOffset,lastX - firstX);
  }
}"
11461,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  OverlapPercentage tileOverlapPercentage=null;
  try {
    if (!isElevationModelAvailable) {
      getElevationModel();
    }
    tileOverlapPercentage=computeTileOverlapPercentage(x0,y0,w,h);
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
  final Tile targetTile=targetTiles.get(targetProduct.getBand(SIMULATED_BAND_NAME));
  final ProductData masterBuffer=targetTile.getDataBuffer();
  ProductData demBandBuffer=null;
  ProductData zeroHeightBandBuffer=null;
  ProductData localIncidenceAngleBandBuffer=null;
  ProductData layoverShadowMaskBuffer=null;
  if (saveDEM) {
    demBandBuffer=targetTiles.get(targetProduct.getBand(demBandName)).getDataBuffer();
  }
  if (saveZeroHeightSimulation) {
    zeroHeightBandBuffer=targetTiles.get(targetProduct.getBand(zeroHeightSimulationBandName)).getDataBuffer();
  }
  if (saveLocalIncidenceAngle) {
    localIncidenceAngleBandBuffer=targetTiles.get(targetProduct.getBand(simulatedLocalIncidenceAngleBandName)).getDataBuffer();
  }
  if (saveLayoverShadowMask) {
    layoverShadowMaskBuffer=targetTiles.get(targetProduct.getBand(layoverShadowMaskBandName)).getDataBuffer();
  }
  final int ymin=Math.max(y0 - (int)(h * tileOverlapPercentage.tileOverlapUp),0);
  final int ymax=Math.min(y0 + h + (int)(h * tileOverlapPercentage.tileOverlapDown),sourceImageHeight);
  final int xmin=Math.max(x0 - (int)(w * tileOverlapPercentage.tileOverlapLeft),0);
  final int xmax=Math.min(x0 + w + (int)(w * tileOverlapPercentage.tileOverlapRight),sourceImageWidth);
  final PositionData posData=new PositionData();
  final GeoPos geoPos=new GeoPos();
  double[] slrs=null;
  double[] elev=null;
  int[] index=null;
  boolean[] savePixel=null;
  try {
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
      final double latMin=latLonMinMax[0];
      final double latMax=latLonMinMax[1];
      final double lonMin=latLonMinMax[2];
      final double lonMax=latLonMinMax[3];
      final int nLat=(int)((latMax - latMin) / delLat) + 1;
      final int nLon=(int)((lonMax - lonMin) / delLon) + 1;
      final double[][] tileDEM=new double[nLat + 1][nLon + 1];
      final double[][] neighbourDEM=new double[3][3];
      double alt;
      if (saveLayoverShadowMask) {
        slrs=new double[nLon];
        elev=new double[nLon];
        index=new int[nLon];
        savePixel=new boolean[nLon];
      }
      for (int i=0; i < nLat; i++) {
        final double lat=latMin + i * delLat;
        Arrays.fill(slrs,0.0);
        Arrays.fill(elev,0.0);
        Arrays.fill(index,-1);
        Arrays.fill(savePixel,Boolean.FALSE);
        for (int j=0; j < nLon; j++) {
          double lon=lonMin + j * delLon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (saveZeroHeightSimulation) {
            alt=1;
          }
 else {
            geoPos.setLocation(lat,lon);
            alt=dem.getElevation(geoPos);
            if (alt == demNoDataValue)             continue;
          }
          tileDEM[i][j]=alt;
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(lat,lon,delLat,delLon,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          int r=0;
          for (int ii=Math.max(0,i - 1); ii <= i + 1; ++ii) {
            ii=Math.min(nLat,ii);
            int c=0;
            double neighbourLat=latMin + ii * delLat;
            for (int jj=Math.max(0,j - 1); jj <= j + 1; ++jj) {
              jj=Math.min(nLon,jj);
              neighbourDEM[r][c]=tileDEM[ii][jj];
              if (neighbourDEM[r][c] == 0) {
                if (saveZeroHeightSimulation) {
                  neighbourDEM[r][c]=1;
                }
 else {
                  geoPos.setLocation(neighbourLat,lonMin + jj * delLon);
                  neighbourDEM[r][c]=dem.getElevation(geoPos);
                }
                tileDEM[ii][jj]=neighbourDEM[r][c];
              }
              ++c;
            }
            ++r;
          }
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,0,0,0,0,neighbourDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle) {
            continue;
          }
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            if (rIndex >= x0 && rIndex < x0 + w && aIndex >= y0 && aIndex < y0 + h) {
              index[j]=targetTile.getDataBufferIndex(rIndex,aIndex);
              slrs[j]=posData.slantRange;
              elev[j]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[j]=true;
            }
 else {
              savePixel[j]=false;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
 else {
      final int widthExt=xmax - xmin;
      final int heightExt=ymax - ymin;
      if (saveLayoverShadowMask) {
        slrs=new double[widthExt];
        elev=new double[widthExt];
        index=new int[widthExt];
        savePixel=new boolean[widthExt];
      }
      final double[][] localDEM=new double[heightExt + 2][widthExt + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,xmin,ymin,widthExt,heightExt);
      if (saveZeroHeightSimulation) {
        for (        double[] aLocalDEM : localDEM) {
          Arrays.fill(aLocalDEM,1);
        }
      }
 else {
        final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,xmin,ymin,widthExt,heightExt,sourceProduct,true,localDEM);
        if (!valid)         return;
      }
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        Arrays.fill(slrs,0.0);
        Arrays.fill(elev,0.0);
        Arrays.fill(index,-1);
        Arrays.fill(savePixel,Boolean.FALSE);
        for (int x=xmin; x < xmax; x++) {
          final int xx=x - xmin;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (orbitMethod) {
            double[] latlon=jOrbit.lp2ell(new Point(x + 0.5,y + 0.5),meta);
            lat=latlon[0] * Constants.RTOD;
            lon=latlon[1] * Constants.RTOD;
            alt=dem.getElevation(new GeoPos(lat,lon));
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,xmin,ymin,x,y,localDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle)           continue;
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            if (rIndex >= x0 && rIndex < x0 + w && aIndex >= y0 && aIndex < y0 + h) {
              index[xx]=targetTile.getDataBufferIndex(rIndex,aIndex);
              slrs[xx]=posData.slantRange;
              elev[xx]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[xx]=true;
            }
 else {
              savePixel[xx]=false;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  OverlapPercentage tileOverlapPercentage=null;
  try {
    if (!isElevationModelAvailable) {
      getElevationModel();
    }
    tileOverlapPercentage=computeTileOverlapPercentage(x0,y0,w,h);
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
  final Tile targetTile=targetTiles.get(targetProduct.getBand(SIMULATED_BAND_NAME));
  final ProductData masterBuffer=targetTile.getDataBuffer();
  ProductData demBandBuffer=null;
  ProductData zeroHeightBandBuffer=null;
  ProductData localIncidenceAngleBandBuffer=null;
  ProductData layoverShadowMaskBuffer=null;
  if (saveDEM) {
    demBandBuffer=targetTiles.get(targetProduct.getBand(demBandName)).getDataBuffer();
  }
  if (saveZeroHeightSimulation) {
    zeroHeightBandBuffer=targetTiles.get(targetProduct.getBand(zeroHeightSimulationBandName)).getDataBuffer();
  }
  if (saveLocalIncidenceAngle) {
    localIncidenceAngleBandBuffer=targetTiles.get(targetProduct.getBand(simulatedLocalIncidenceAngleBandName)).getDataBuffer();
  }
  if (saveLayoverShadowMask) {
    layoverShadowMaskBuffer=targetTiles.get(targetProduct.getBand(layoverShadowMaskBandName)).getDataBuffer();
  }
  final int ymin=Math.max(y0 - (int)(h * tileOverlapPercentage.tileOverlapUp),0);
  final int ymax=Math.min(y0 + h + (int)(h * tileOverlapPercentage.tileOverlapDown),sourceImageHeight);
  final int xmin=Math.max(x0 - (int)(w * tileOverlapPercentage.tileOverlapLeft),0);
  final int xmax=Math.min(x0 + w + (int)(w * tileOverlapPercentage.tileOverlapRight),sourceImageWidth);
  final PositionData posData=new PositionData();
  final GeoPos geoPos=new GeoPos();
  double[] slrs=null;
  double[] elev=null;
  int[] index=null;
  boolean[] savePixel=null;
  try {
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
      final double latMin=latLonMinMax[0];
      final double latMax=latLonMinMax[1];
      final double lonMin=latLonMinMax[2];
      final double lonMax=latLonMinMax[3];
      final int nLat=(int)((latMax - latMin) / delLat) + 1;
      final int nLon=(int)((lonMax - lonMin) / delLon) + 1;
      final double[][] tileDEM=new double[nLat + 1][nLon + 1];
      final double[][] neighbourDEM=new double[3][3];
      double alt;
      if (saveLayoverShadowMask) {
        slrs=new double[nLon];
        elev=new double[nLon];
        index=new int[nLon];
        savePixel=new boolean[nLon];
      }
      for (int i=0; i < nLat; i++) {
        final double lat=latMin + i * delLat;
        if (saveLayoverShadowMask) {
          Arrays.fill(slrs,0.0);
          Arrays.fill(elev,0.0);
          Arrays.fill(index,-1);
          Arrays.fill(savePixel,Boolean.FALSE);
        }
        for (int j=0; j < nLon; j++) {
          double lon=lonMin + j * delLon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (saveZeroHeightSimulation) {
            alt=1;
          }
 else {
            geoPos.setLocation(lat,lon);
            alt=dem.getElevation(geoPos);
            if (alt == demNoDataValue)             continue;
          }
          tileDEM[i][j]=alt;
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(lat,lon,delLat,delLon,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          int r=0;
          for (int ii=Math.max(0,i - 1); ii <= i + 1; ++ii) {
            ii=Math.min(nLat,ii);
            int c=0;
            double neighbourLat=latMin + ii * delLat;
            for (int jj=Math.max(0,j - 1); jj <= j + 1; ++jj) {
              jj=Math.min(nLon,jj);
              neighbourDEM[r][c]=tileDEM[ii][jj];
              if (neighbourDEM[r][c] == 0) {
                if (saveZeroHeightSimulation) {
                  neighbourDEM[r][c]=1;
                }
 else {
                  geoPos.setLocation(neighbourLat,lonMin + jj * delLon);
                  neighbourDEM[r][c]=dem.getElevation(geoPos);
                }
                tileDEM[ii][jj]=neighbourDEM[r][c];
              }
              ++c;
            }
            ++r;
          }
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,0,0,0,0,neighbourDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle) {
            continue;
          }
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            if (rIndex >= x0 && rIndex < x0 + w && aIndex >= y0 && aIndex < y0 + h) {
              index[j]=targetTile.getDataBufferIndex(rIndex,aIndex);
              slrs[j]=posData.slantRange;
              elev[j]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[j]=true;
            }
 else {
              savePixel[j]=false;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
 else {
      final int widthExt=xmax - xmin;
      final int heightExt=ymax - ymin;
      if (saveLayoverShadowMask) {
        slrs=new double[widthExt];
        elev=new double[widthExt];
        index=new int[widthExt];
        savePixel=new boolean[widthExt];
      }
      final double[][] localDEM=new double[heightExt + 2][widthExt + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,xmin,ymin,widthExt,heightExt);
      if (saveZeroHeightSimulation) {
        for (        double[] aLocalDEM : localDEM) {
          Arrays.fill(aLocalDEM,1);
        }
      }
 else {
        final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,xmin,ymin,widthExt,heightExt,sourceProduct,true,localDEM);
        if (!valid)         return;
      }
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        if (saveLayoverShadowMask) {
          Arrays.fill(slrs,0.0);
          Arrays.fill(elev,0.0);
          Arrays.fill(index,-1);
          Arrays.fill(savePixel,Boolean.FALSE);
        }
        for (int x=xmin; x < xmax; x++) {
          final int xx=x - xmin;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (orbitMethod) {
            double[] latlon=jOrbit.lp2ell(new Point(x + 0.5,y + 0.5),meta);
            lat=latlon[0] * Constants.RTOD;
            lon=latlon[1] * Constants.RTOD;
            alt=dem.getElevation(new GeoPos(lat,lon));
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,xmin,ymin,x,y,localDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle)           continue;
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            if (rIndex >= x0 && rIndex < x0 + w && aIndex >= y0 && aIndex < y0 + h) {
              index[xx]=targetTile.getDataBufferIndex(rIndex,aIndex);
              slrs[xx]=posData.slantRange;
              elev[xx]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[xx]=true;
            }
 else {
              savePixel[xx]=false;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11462,"private static void saveSimulatedData(final double azimuthIndex,final double rangeIndex,double v,final int x0,final int y0,final int w,final int h,final Tile targetTile,final ProductData masterBuffer){
  final int ia0=(int)(azimuthIndex);
  final int ia1=ia0 + 1;
  final int ir0=(int)(rangeIndex);
  final int ir1=ir0 + 1;
  final double wr=rangeIndex - ir0;
  final double wa=azimuthIndex - ia0;
  final double wac=1 - wa;
  if (ir0 >= x0) {
    final double wrc=1 - wr;
    if (ia0 >= y0) {
      final int idx00=targetTile.getDataBufferIndex(ir0,ia0);
      masterBuffer.setElemDoubleAt(idx00,wrc * wac * v + masterBuffer.getElemDoubleAt(idx00));
    }
    if (ia1 < y0 + h) {
      final int idx10=targetTile.getDataBufferIndex(ir0,ia1);
      masterBuffer.setElemDoubleAt(idx10,wrc * wa * v + masterBuffer.getElemDoubleAt(idx10));
    }
  }
  if (ir1 < x0 + w) {
    if (ia0 >= y0) {
      final int idx01=targetTile.getDataBufferIndex(ir1,ia0);
      masterBuffer.setElemDoubleAt(idx01,wr * wac * v + masterBuffer.getElemDoubleAt(idx01));
    }
    if (ia1 < y0 + h) {
      final int idx11=targetTile.getDataBufferIndex(ir1,ia1);
      masterBuffer.setElemDoubleAt(idx11,wr * wa * v + masterBuffer.getElemDoubleAt(idx11));
    }
  }
}","private static void saveSimulatedData(final double azimuthIndex,final double rangeIndex,double v,final int x0,final int y0,final int w,final int h,final Tile targetTile,final ProductData masterBuffer){
  final int ia0=(int)(azimuthIndex);
  final int ia1=ia0 + 1;
  final int ir0=(int)(rangeIndex);
  final int ir1=ir0 + 1;
  final double wr=rangeIndex - ir0;
  final double wa=azimuthIndex - ia0;
  final double wac=1 - wa;
  if (ir0 >= x0 && ir0 < x0 + w) {
    final double wrc=1 - wr;
    if (ia0 >= y0 && ia0 < y0 + h) {
      final int idx00=targetTile.getDataBufferIndex(ir0,ia0);
      masterBuffer.setElemDoubleAt(idx00,wrc * wac * v + masterBuffer.getElemDoubleAt(idx00));
    }
    if (ia1 >= y0 && ia1 < y0 + h) {
      final int idx10=targetTile.getDataBufferIndex(ir0,ia1);
      masterBuffer.setElemDoubleAt(idx10,wrc * wa * v + masterBuffer.getElemDoubleAt(idx10));
    }
  }
  if (ir1 >= x0 && ir1 < x0 + w) {
    if (ia0 >= y0 && ia0 < y0 + h) {
      final int idx01=targetTile.getDataBufferIndex(ir1,ia0);
      masterBuffer.setElemDoubleAt(idx01,wr * wac * v + masterBuffer.getElemDoubleAt(idx01));
    }
    if (ia1 >= y0 && ia1 < y0 + h) {
      final int idx11=targetTile.getDataBufferIndex(ir1,ia1);
      masterBuffer.setElemDoubleAt(idx11,wr * wa * v + masterBuffer.getElemDoubleAt(idx11));
    }
  }
}"
11463,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
  if (bandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (bandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=i / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.IMAGINARY) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      sigma=dn2 * calibrationFactor;
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
  final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
  if (tgtBandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (srcBandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (tgtBandUnit == Unit.UnitType.REAL) {
          phaseTerm=i / Math.sqrt(dn2);
        }
 else         if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      sigma=dn2 * calibrationFactor;
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}"
11464,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Band sourceBand1;
  Tile sourceRaster1;
  ProductData srcData1;
  ProductData srcData2=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
  if (bandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final String pol=OperatorUtils.getBandPolarization(srcBandNames[0],absRoot);
  int prodBand=0;
  if (pol != null && mdsPolar[1] != null && mdsPolar[1].contains(pol)) {
    prodBand=1;
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final double[] incidenceAnglesArray=new double[w];
  final double[] slantRangeTimeArray=new double[w];
  double[][] targetTileOldAntPat=null;
  double[][] targetTileNewAntPat=null;
  double[][] targetTileSlantRange=null;
  if (applyAntennaPatternCorr) {
    targetTileNewAntPat=new double[h][w];
    targetTileSlantRange=new double[h][w];
    if (retroCalibrationFlag) {
      targetTileOldAntPat=new double[h][w];
    }
    if (wideSwathProductFlag) {
      computeWideSwathAntennaPatternForCurrentTile(x0,y0,w,h,targetTileOldAntPat,targetTileNewAntPat,targetTileSlantRange,slantRangeTPGInterp);
    }
 else {
      computeSingleSwathAntennaPatternForCurrentTile(x0,y0,w,h,targetTileOldAntPat,targetTileNewAntPat,targetTileSlantRange,prodBand,slantRangeTPGInterp);
    }
  }
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  final double theCalibrationFactor=newCalibrationConstant[prodBand];
  int srcIdx, tgtIdx;
  for (int y=y0, yy=0; y < maxY; ++y, ++yy) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    incidenceTPGInterp.getPixels(x0,y,w,1,incidenceAnglesArray,pm,TiePointInterpolator.InterpMode.QUADRATIC);
    if (applyRangeSpreadingCorr) {
      slantRangeTPGInterp.getPixels(x0,y,w,1,slantRangeTimeArray,pm,TiePointInterpolator.InterpMode.QUADRATIC);
    }
    for (int x=x0, xx=0; x < maxX; ++x, ++xx) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (bandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=i / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.IMAGINARY) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      double calFactor=1.0;
      if (retroCalibrationFlag) {
        calFactor*=targetTileOldAntPat[yy][xx];
      }
      calFactor*=FastMath.sin(incidenceAnglesArray[xx] * Constants.DTOR) / theCalibrationFactor;
      if (applyRangeSpreadingCorr && targetTileSlantRange != null) {
        calFactor*=FastMath.pow(targetTileSlantRange[yy][xx] / refSlantRange800km,rangeSpreadingCompPower);
      }
      if (applyAntennaPatternCorr) {
        calFactor/=targetTileNewAntPat[yy][xx];
      }
      sigma=dn2 * calFactor;
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Band sourceBand1;
  Tile sourceRaster1;
  ProductData srcData1;
  ProductData srcData2=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
  final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
  if (tgtBandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final String pol=OperatorUtils.getBandPolarization(srcBandNames[0],absRoot);
  int prodBand=0;
  if (pol != null && mdsPolar[1] != null && mdsPolar[1].contains(pol)) {
    prodBand=1;
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final double[] incidenceAnglesArray=new double[w];
  final double[] slantRangeTimeArray=new double[w];
  double[][] targetTileOldAntPat=null;
  double[][] targetTileNewAntPat=null;
  double[][] targetTileSlantRange=null;
  if (applyAntennaPatternCorr) {
    targetTileNewAntPat=new double[h][w];
    targetTileSlantRange=new double[h][w];
    if (retroCalibrationFlag) {
      targetTileOldAntPat=new double[h][w];
    }
    if (wideSwathProductFlag) {
      computeWideSwathAntennaPatternForCurrentTile(x0,y0,w,h,targetTileOldAntPat,targetTileNewAntPat,targetTileSlantRange,slantRangeTPGInterp);
    }
 else {
      computeSingleSwathAntennaPatternForCurrentTile(x0,y0,w,h,targetTileOldAntPat,targetTileNewAntPat,targetTileSlantRange,prodBand,slantRangeTPGInterp);
    }
  }
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  final double theCalibrationFactor=newCalibrationConstant[prodBand];
  int srcIdx, tgtIdx;
  for (int y=y0, yy=0; y < maxY; ++y, ++yy) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    incidenceTPGInterp.getPixels(x0,y,w,1,incidenceAnglesArray,pm,TiePointInterpolator.InterpMode.QUADRATIC);
    if (applyRangeSpreadingCorr) {
      slantRangeTPGInterp.getPixels(x0,y,w,1,slantRangeTimeArray,pm,TiePointInterpolator.InterpMode.QUADRATIC);
    }
    for (int x=x0, xx=0; x < maxX; ++x, ++xx) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (srcBandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (tgtBandUnit == Unit.UnitType.REAL) {
          phaseTerm=i / Math.sqrt(dn2);
        }
 else         if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      double calFactor=1.0;
      if (retroCalibrationFlag) {
        calFactor*=targetTileOldAntPat[yy][xx];
      }
      calFactor*=FastMath.sin(incidenceAnglesArray[xx] * Constants.DTOR) / theCalibrationFactor;
      if (applyRangeSpreadingCorr && targetTileSlantRange != null) {
        calFactor*=FastMath.pow(targetTileSlantRange[yy][xx] / refSlantRange800km,rangeSpreadingCompPower);
      }
      if (applyAntennaPatternCorr) {
        calFactor/=targetTileNewAntPat[yy][xx];
      }
      sigma=dn2 * calFactor;
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}"
11465,"public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
  if (bandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final String pol=OperatorUtils.getBandPolarization(srcBandNames[0],absRoot).toUpperCase();
  double Ks=1.0;
  if (pol != null && !pol.isEmpty() && applyConstantCorrection) {
    Ks=calibrationFactor.get(pol);
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  final double powFactor=FastMath.pow(referenceSlantRange,2 * referenceSlantRangeExp);
  final double sinRefIncidenceAngle=FastMath.sin(referenceIncidenceAngle);
  final double rescaleCalFactor=rescalingFactor * rescalingFactor * Ks;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (bandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=i / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.IMAGINARY) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY_DB) {
        dn2=FastMath.pow(10,srcData1.getElemDoubleAt(srcIdx) / 10.0);
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      double calFactor=1.0;
      if (applyRangeSpreadingLossCorrection)       calFactor*=powFactor;
      if (applyIncidenceAngleCorrection)       calFactor*=sinRefIncidenceAngle;
      calFactor/=rescaleCalFactor;
      sigma=dn2 * calFactor;
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}","public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
  final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
  if (tgtBandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final String pol=OperatorUtils.getBandPolarization(srcBandNames[0],absRoot).toUpperCase();
  double Ks=1.0;
  if (pol != null && !pol.isEmpty() && applyConstantCorrection) {
    Ks=calibrationFactor.get(pol);
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  final double powFactor=FastMath.pow(referenceSlantRange,2 * referenceSlantRangeExp);
  final double sinRefIncidenceAngle=FastMath.sin(referenceIncidenceAngle);
  final double rescaleCalFactor=rescalingFactor * rescalingFactor * Ks;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (srcBandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (tgtBandUnit == Unit.UnitType.REAL) {
          phaseTerm=i / Math.sqrt(dn2);
        }
 else         if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY_DB) {
        dn2=FastMath.pow(10,srcData1.getElemDoubleAt(srcIdx) / 10.0);
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      double calFactor=1.0;
      if (applyRangeSpreadingLossCorrection)       calFactor*=powFactor;
      if (applyIncidenceAngleCorrection)       calFactor*=sinRefIncidenceAngle;
      calFactor/=rescaleCalFactor;
      sigma=dn2 * calFactor;
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}"
11466,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  try {
    final Rectangle targetTileRectangle=targetTile.getRectangle();
    final int x0=targetTileRectangle.x;
    final int y0=targetTileRectangle.y;
    final int w=targetTileRectangle.width;
    final int h=targetTileRectangle.height;
    final ProductData trgData=targetTile.getDataBuffer();
    Band sourceBand1=null;
    Band sourceBand2=null;
    Tile sourceRaster1=null;
    Tile sourceRaster2=null;
    ProductData srcData1=null;
    ProductData srcData2=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      sourceRaster2=getSourceTile(sourceBand2,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
      srcData2=sourceRaster2.getDataBuffer();
    }
    final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
    if (bandUnit == Unit.UnitType.PHASE) {
      targetTile.setRawSamples(sourceRaster1.getRawSamples());
      return;
    }
    if (applyAntennaPatternCorrection && !isAntPattAvailable) {
      computeAntennaPatternCorrectionFactors(0,sourceImageWidth);
    }
    if (applyADCSaturationCorrection && !adcHasBeenTestedFlag) {
      testADC(sourceBand1,sourceBand2,bandUnit);
    }
    boolean applyADCSaturationCorrectionToCurrentTile=false;
    if (applyADCSaturationCorrection && h >= blockHeight && w >= blockWidth) {
      applyADCSaturationCorrectionToCurrentTile=true;
    }
    double[][] adcPowerLoss=null;
    if (applyADCSaturationCorrectionToCurrentTile) {
      adcPowerLoss=computeADCPowerLossValuesForCurrentTile(sourceBand1,sourceBand2,x0,y0,w,h,bandUnit);
    }
    final double k=calibrationConstant * FastMath.sin(referenceIncidenceAngle);
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    double sigma, dn, dn2, i, q, phaseTerm=0.0;
    int index;
    int adcJ=0;
    for (int x=x0; x < maxX; x++) {
      final double sinIncidenceAngleByK=FastMath.sin(incidenceAngles[x]) / k;
      if (applyADCSaturationCorrectionToCurrentTile) {
        adcJ=Math.min(((x - x0) / blockWidth),adcPowerLoss[0].length - 1);
      }
      for (int y=y0; y < maxY; y++) {
        index=sourceRaster1.getDataBufferIndex(x,y);
        if (bandUnit == Unit.UnitType.AMPLITUDE) {
          dn=srcData1.getElemDoubleAt(index);
          dn2=dn * dn;
        }
 else         if (bandUnit == Unit.UnitType.INTENSITY) {
          dn2=srcData1.getElemDoubleAt(index);
        }
 else         if (bandUnit == Unit.UnitType.REAL) {
          i=srcData1.getElemDoubleAt(index);
          q=srcData2.getElemDoubleAt(index);
          dn2=i * i + q * q;
          if (outputImageInComplex) {
            phaseTerm=i / Math.sqrt(dn2);
          }
        }
 else         if (bandUnit == Unit.UnitType.IMAGINARY) {
          i=srcData1.getElemDoubleAt(index);
          q=srcData2.getElemDoubleAt(index);
          dn2=i * i + q * q;
          if (outputImageInComplex) {
            phaseTerm=q / Math.sqrt(dn2);
          }
        }
 else         if (bandUnit == Unit.UnitType.INTENSITY_DB) {
          dn2=FastMath.pow(10,srcData1.getElemDoubleAt(index) / 10.0);
        }
 else {
          throw new OperatorException(""String_Node_Str"");
        }
        double calFactor=sinIncidenceAngleByK;
        if (applyAntennaPatternCorrection) {
          calFactor*=antennaPatternCorrFactor[x];
        }
        if (applyRangeSpreadingLossCorrection) {
          calFactor*=rangeSpreadingLoss[x];
        }
        if (applyReplicaPowerCorrection) {
          calFactor*=replicaPulseVariationsCorrectionFactor;
        }
        if (applyADCSaturationCorrectionToCurrentTile) {
          final int adcI=Math.min(((y - y0) / blockHeight),adcPowerLoss.length - 1);
          calFactor*=adcPowerLoss[adcI][adcJ];
        }
        sigma=dn2 * calFactor;
        if (isComplex && outputImageInComplex) {
          sigma=Math.sqrt(sigma) * phaseTerm;
        }
        if (outputImageScaleInDb) {
          if (sigma < underFlowFloat) {
            sigma=-underFlowFloat;
          }
 else {
            sigma=10.0 * Math.log10(sigma);
          }
        }
        trgData.setElemDoubleAt(targetTile.getDataBufferIndex(x,y),sigma);
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  try {
    final Rectangle targetTileRectangle=targetTile.getRectangle();
    final int x0=targetTileRectangle.x;
    final int y0=targetTileRectangle.y;
    final int w=targetTileRectangle.width;
    final int h=targetTileRectangle.height;
    final ProductData trgData=targetTile.getDataBuffer();
    Band sourceBand1=null;
    Band sourceBand2=null;
    Tile sourceRaster1=null;
    Tile sourceRaster2=null;
    ProductData srcData1=null;
    ProductData srcData2=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,targetTileRectangle);
      sourceRaster2=getSourceTile(sourceBand2,targetTileRectangle);
      srcData1=sourceRaster1.getDataBuffer();
      srcData2=sourceRaster2.getDataBuffer();
    }
    final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
    final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
    if (tgtBandUnit == Unit.UnitType.PHASE) {
      targetTile.setRawSamples(sourceRaster1.getRawSamples());
      return;
    }
    if (applyAntennaPatternCorrection && !isAntPattAvailable) {
      computeAntennaPatternCorrectionFactors(0,sourceImageWidth);
    }
    if (applyADCSaturationCorrection && !adcHasBeenTestedFlag) {
      testADC(sourceBand1,sourceBand2,srcBandUnit);
    }
    boolean applyADCSaturationCorrectionToCurrentTile=false;
    if (applyADCSaturationCorrection && h >= blockHeight && w >= blockWidth) {
      applyADCSaturationCorrectionToCurrentTile=true;
    }
    double[][] adcPowerLoss=null;
    if (applyADCSaturationCorrectionToCurrentTile) {
      adcPowerLoss=computeADCPowerLossValuesForCurrentTile(sourceBand1,sourceBand2,x0,y0,w,h,srcBandUnit);
    }
    final double k=calibrationConstant * FastMath.sin(referenceIncidenceAngle);
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    double sigma, dn, dn2, i, q, phaseTerm=0.0;
    int index;
    int adcJ=0;
    for (int x=x0; x < maxX; x++) {
      final double sinIncidenceAngleByK=FastMath.sin(incidenceAngles[x]) / k;
      if (applyADCSaturationCorrectionToCurrentTile) {
        adcJ=Math.min(((x - x0) / blockWidth),adcPowerLoss[0].length - 1);
      }
      for (int y=y0; y < maxY; y++) {
        index=sourceRaster1.getDataBufferIndex(x,y);
        if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
          dn=srcData1.getElemDoubleAt(index);
          dn2=dn * dn;
        }
 else         if (srcBandUnit == Unit.UnitType.INTENSITY) {
          dn2=srcData1.getElemDoubleAt(index);
        }
 else         if (srcBandUnit == Unit.UnitType.REAL) {
          i=srcData1.getElemDoubleAt(index);
          q=srcData2.getElemDoubleAt(index);
          dn2=i * i + q * q;
          if (tgtBandUnit == Unit.UnitType.REAL) {
            phaseTerm=i / Math.sqrt(dn2);
          }
 else           if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
            phaseTerm=q / Math.sqrt(dn2);
          }
        }
 else         if (srcBandUnit == Unit.UnitType.INTENSITY_DB) {
          dn2=FastMath.pow(10,srcData1.getElemDoubleAt(index) / 10.0);
        }
 else {
          throw new OperatorException(""String_Node_Str"");
        }
        double calFactor=sinIncidenceAngleByK;
        if (applyAntennaPatternCorrection) {
          calFactor*=antennaPatternCorrFactor[x];
        }
        if (applyRangeSpreadingLossCorrection) {
          calFactor*=rangeSpreadingLoss[x];
        }
        if (applyReplicaPowerCorrection) {
          calFactor*=replicaPulseVariationsCorrectionFactor;
        }
        if (applyADCSaturationCorrectionToCurrentTile) {
          final int adcI=Math.min(((y - y0) / blockHeight),adcPowerLoss.length - 1);
          calFactor*=adcPowerLoss[adcI][adcJ];
        }
        sigma=dn2 * calFactor;
        if (isComplex && outputImageInComplex) {
          sigma=Math.sqrt(sigma) * phaseTerm;
        }
        if (outputImageScaleInDb) {
          if (sigma < underFlowFloat) {
            sigma=-underFlowFloat;
          }
 else {
            sigma=10.0 * Math.log10(sigma);
          }
        }
        trgData.setElemDoubleAt(targetTile.getDataBufferIndex(x,y),sigma);
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
}"
11467,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma=0.0, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (bandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=i / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.IMAGINARY) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      if (isComplex) {
        if (gains != null) {
          sigma=dn2 / (gains[x + subsetOffsetX] * gains[x + subsetOffsetX]);
          if (outputImageInComplex) {
            sigma=Math.sqrt(sigma) * phaseTerm;
          }
        }
      }
 else {
        sigma=dn2 + offset;
        if (gains != null) {
          sigma/=gains[x + subsetOffsetX];
        }
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
  final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma=0.0, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (srcBandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (tgtBandUnit == Unit.UnitType.REAL) {
          phaseTerm=i / Math.sqrt(dn2);
        }
 else         if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      if (isComplex) {
        if (gains != null) {
          sigma=dn2 / (gains[x + subsetOffsetX] * gains[x + subsetOffsetX]);
          if (outputImageInComplex) {
            sigma=Math.sqrt(sigma) * phaseTerm;
          }
        }
      }
 else {
        sigma=dn2 + offset;
        if (gains != null) {
          sigma/=gains[x + subsetOffsetX];
        }
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}"
11468,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String targetBandName=targetBand.getName();
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBandName);
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final double noDataValue=sourceBand1.getNoDataValue();
  final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex trgIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final boolean complexData=bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY;
  final CalibrationInfo calInfo=targetBandToCalInfo.get(targetBandName);
  final CALTYPE calType=getCalibrationType(targetBandName);
  double dn=0.0, dn2, i, q, muX, lutVal, retroLutVal=1.0, calValue, calibrationFactor, phaseTerm=0.0;
  int srcIdx, trgIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    trgIndex.calculateStride(y);
    final int calVecIdx=calInfo.getCalibrationVectorIndex(y);
    final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
    final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
    final float[] vec0LUT=getVector(calType,vec0);
    final float[] vec1LUT=getVector(calType,vec1);
    float[] retroVec0LUT=null;
    float[] retroVec1LUT=null;
    if (dataType != null) {
      retroVec0LUT=getVector(dataType,vec0);
      retroVec1LUT=getVector(dataType,vec1);
    }
    final double azTime=calInfo.firstLineTime + y * calInfo.lineTimeInterval;
    final double muY=(azTime - vec0.timeMJD) / (vec1.timeMJD - vec0.timeMJD);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      trgIdx=trgIndex.getIndex(x);
      if (srcData1.getElemDoubleAt(srcIdx) == noDataValue) {
        continue;
      }
      final int pixelIdx=calInfo.getPixelIndex(x,calVecIdx);
      muX=(x - vec0.pixels[pixelIdx]) / (double)(vec0.pixels[pixelIdx + 1] - vec0.pixels[pixelIdx]);
      lutVal=(1 - muY) * ((1 - muX) * vec0LUT[pixelIdx] + muX * vec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * vec1LUT[pixelIdx] + muX * vec1LUT[pixelIdx + 1]);
      calibrationFactor=1.0 / (lutVal * lutVal);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        if (dataType != null) {
          retroLutVal=(1 - muY) * ((1 - muX) * retroVec0LUT[pixelIdx] + muX * retroVec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * retroVec1LUT[pixelIdx] + muX * retroVec1LUT[pixelIdx + 1]);
        }
        dn2=srcData1.getElemDoubleAt(srcIdx);
        calibrationFactor*=retroLutVal;
      }
 else       if (bandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=i / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.IMAGINARY) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      calValue=dn2 * calibrationFactor;
      if (isComplex && outputImageInComplex) {
        calValue=Math.sqrt(calValue) * phaseTerm;
      }
 else       if (isFormerIPFVersion) {
        calValue/=Math.sqrt(calibrationFactor);
      }
      trgData.setElemDoubleAt(trgIdx,calValue);
    }
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String targetBandName=targetBand.getName();
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBandName);
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final double noDataValue=sourceBand1.getNoDataValue();
  final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
  final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
  final ProductData tgtData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex trgIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final CalibrationInfo calInfo=targetBandToCalInfo.get(targetBandName);
  final CALTYPE calType=getCalibrationType(targetBandName);
  double dn=0.0, dn2, i, q, muX, lutVal, retroLutVal=1.0, calValue, calibrationFactor, phaseTerm=0.0;
  int srcIdx, trgIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    trgIndex.calculateStride(y);
    final int calVecIdx=calInfo.getCalibrationVectorIndex(y);
    final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
    final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
    final float[] vec0LUT=getVector(calType,vec0);
    final float[] vec1LUT=getVector(calType,vec1);
    float[] retroVec0LUT=null;
    float[] retroVec1LUT=null;
    if (dataType != null) {
      retroVec0LUT=getVector(dataType,vec0);
      retroVec1LUT=getVector(dataType,vec1);
    }
    final double azTime=calInfo.firstLineTime + y * calInfo.lineTimeInterval;
    final double muY=(azTime - vec0.timeMJD) / (vec1.timeMJD - vec0.timeMJD);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      trgIdx=trgIndex.getIndex(x);
      if (srcData1.getElemDoubleAt(srcIdx) == noDataValue) {
        continue;
      }
      final int pixelIdx=calInfo.getPixelIndex(x,calVecIdx);
      muX=(x - vec0.pixels[pixelIdx]) / (double)(vec0.pixels[pixelIdx + 1] - vec0.pixels[pixelIdx]);
      lutVal=(1 - muY) * ((1 - muX) * vec0LUT[pixelIdx] + muX * vec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * vec1LUT[pixelIdx] + muX * vec1LUT[pixelIdx + 1]);
      calibrationFactor=1.0 / (lutVal * lutVal);
      if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY) {
        if (dataType != null) {
          retroLutVal=(1 - muY) * ((1 - muX) * retroVec0LUT[pixelIdx] + muX * retroVec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * retroVec1LUT[pixelIdx] + muX * retroVec1LUT[pixelIdx + 1]);
        }
        dn2=srcData1.getElemDoubleAt(srcIdx);
        calibrationFactor*=retroLutVal;
      }
 else       if (srcBandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (tgtBandUnit == Unit.UnitType.REAL) {
          phaseTerm=i / Math.sqrt(dn2);
        }
 else         if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      calValue=dn2 * calibrationFactor;
      if (isComplex && outputImageInComplex) {
        calValue=Math.sqrt(calValue) * phaseTerm;
      }
      tgtData.setElemDoubleAt(trgIdx,calValue);
    }
  }
}"
11469,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  Tile srcGIMTile=null;
  ProductData srcGIMData=null;
  if (useIncidenceAngleFromGIM) {
    srcGIMTile=calibrationOp.getSourceTile(sourceGIMProduct.getBand(""String_Node_Str""),targetTileRectangle);
    srcGIMData=srcGIMTile.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(targetBand);
  final double noDataValue=sourceBand1.getNoDataValue();
  if (bandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final String pol=OperatorUtils.getBandPolarization(srcBandNames[0],absRoot).toUpperCase();
  double Ks=0.0;
  if (pol != null) {
    Ks=calibrationFactor.get(pol);
  }
  double[][] tileNoise=null;
  if (!noiseCorrectedFlag) {
    tileNoise=new double[h][w];
    computeTileNoise(pol,x0,y0,w,h,tileNoise);
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        if (dn == noDataValue) {
          continue;
        }
        dn2=dn * dn;
      }
 else       if (bandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (bandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=i / Math.sqrt(dn2);
        }
      }
 else       if (bandUnit == Unit.UnitType.IMAGINARY) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (outputImageInComplex) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      double inciAng;
      if (useIncidenceAngleFromGIM) {
        final int gim=srcGIMData.getElemIntAt(srcIdx);
        inciAng=(gim - (gim % 10)) / 100.0 * Constants.DTOR;
      }
 else {
        inciAng=incidenceAngle.getPixelDouble(x,y) * Constants.DTOR;
      }
      if (noiseCorrectedFlag) {
        sigma=Ks * dn2 * FastMath.sin(inciAng);
      }
 else {
        sigma=Ks * (dn2 - tileNoise[y - y0][x - x0]) * FastMath.sin(inciAng);
      }
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.snap.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  Tile srcGIMTile=null;
  ProductData srcGIMData=null;
  if (useIncidenceAngleFromGIM) {
    srcGIMTile=calibrationOp.getSourceTile(sourceGIMProduct.getBand(""String_Node_Str""),targetTileRectangle);
    srcGIMData=srcGIMTile.getDataBuffer();
  }
  final Unit.UnitType tgtBandUnit=Unit.getUnitType(targetBand);
  final Unit.UnitType srcBandUnit=Unit.getUnitType(sourceBand1);
  final double noDataValue=sourceBand1.getNoDataValue();
  if (tgtBandUnit == Unit.UnitType.PHASE) {
    targetTile.setRawSamples(sourceRaster1.getRawSamples());
    return;
  }
  final String pol=OperatorUtils.getBandPolarization(srcBandNames[0],absRoot).toUpperCase();
  double Ks=0.0;
  if (pol != null) {
    Ks=calibrationFactor.get(pol);
  }
  double[][] tileNoise=null;
  if (!noiseCorrectedFlag) {
    tileNoise=new double[h][w];
    computeTileNoise(pol,x0,y0,w,h,tileNoise);
  }
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex tgtIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  double sigma, dn, dn2, i, q, phaseTerm=0.0;
  int srcIdx, tgtIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    tgtIndex.calculateStride(y);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      tgtIdx=tgtIndex.getIndex(x);
      if (srcBandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        dn2=dn * dn;
      }
 else       if (srcBandUnit == Unit.UnitType.INTENSITY) {
        dn2=srcData1.getElemDoubleAt(srcIdx);
      }
 else       if (srcBandUnit == Unit.UnitType.REAL) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        dn2=i * i + q * q;
        if (tgtBandUnit == Unit.UnitType.REAL) {
          phaseTerm=i / Math.sqrt(dn2);
        }
 else         if (tgtBandUnit == Unit.UnitType.IMAGINARY) {
          phaseTerm=q / Math.sqrt(dn2);
        }
      }
 else {
        throw new OperatorException(""String_Node_Str"");
      }
      double inciAng;
      if (useIncidenceAngleFromGIM) {
        final int gim=srcGIMData.getElemIntAt(srcIdx);
        inciAng=(gim - (gim % 10)) / 100.0 * Constants.DTOR;
      }
 else {
        inciAng=incidenceAngle.getPixelDouble(x,y) * Constants.DTOR;
      }
      if (noiseCorrectedFlag) {
        sigma=Ks * dn2 * FastMath.sin(inciAng);
      }
 else {
        sigma=Ks * (dn2 - tileNoise[y - y0][x - x0]) * FastMath.sin(inciAng);
      }
      if (isComplex && outputImageInComplex) {
        sigma=Math.sqrt(sigma) * phaseTerm;
      }
      if (outputImageScaleInDb) {
        if (sigma < underFlowFloat) {
          sigma=-underFlowFloat;
        }
 else {
          sigma=10.0 * Math.log10(sigma);
        }
      }
      trgData.setElemDoubleAt(tgtIdx,sigma);
    }
  }
}"
11470,"public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (incidenceAngleSelection.contains(USE_INCIDENCE_ANGLE_FROM_DEM)) {
    return sigma * calibrationFactor * FastMath.sin(localIncidenceAngle * Constants.DTOR);
  }
 else {
    return sigma * calibrationFactor;
  }
}","public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (incidenceAngleSelection.contains(USE_INCIDENCE_ANGLE_FROM_DEM)) {
    return sigma * calibrationFactor * FastMath.sin(localIncidenceAngle * Constants.DTOR);
  }
 else {
    return sigma * calibrationFactor;
  }
}"
11471,"/** 
 * Apply calibrations to the given point. The following calibrations are included: calibration constant, antenna pattern compensation, range spreading loss correction and incidence angle correction.
 * @param v                   The pixel value.
 * @param slantRange          The slant range (in m).
 * @param satelliteHeight     The distance from satellite to earth centre (in m).
 * @param sceneToEarthCentre  The distance from the backscattering element position to earth centre (in m).
 * @param localIncidenceAngle The local incidence angle (in degrees).
 * @param bandPolar           The source band polarization index.
 * @param bandUnit            The source band unit.
 * @param subSwathIndex       The sub swath index for current pixel for wide swath product case.
 * @return The calibrated pixel value.
 */
public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  int bandPolarIdx=0;
  if (bandPolar != null && mdsPolar[1] != null && mdsPolar[1].contains(bandPolar)) {
    bandPolarIdx=1;
  }
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
    sigma=FastMath.pow(10,v / 5.0);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  sigma*=FastMath.sin(Math.abs(localIncidenceAngle) * Constants.DTOR) / newCalibrationConstant[bandPolarIdx];
  if (multilookFlag && antElevCorrFlag) {
    return sigma;
  }
  if (auxFile == null || !auxFile.contains(CalibrationOp.PRODUCT_AUX)) {
    sigma*=FastMath.pow(slantRange / refSlantRange800km,rangeSpreadingCompPower);
  }
  if (applyAntennaPatternCorr) {
    final double elevationAngle=computeElevationAngle(slantRange,satelliteHeight,sceneToEarthCentre);
    double gain;
    if (wideSwathProductFlag) {
      if (subSwathIndex[0] == INVALID_SUB_SWATH_INDEX) {
        final TiePointInterpolator slantRangeTPGInterp=new TiePointInterpolator(slantRangeTime);
        computeSubSwathIndex(rangeIndex,azimuthIndex,newRefElevationAngle,subSwathIndex,slantRangeTPGInterp);
      }
      gain=getAntennaPatternGain(elevationAngle,bandPolarIdx,newRefElevationAngle,newAntennaPatternWideSwath,false,subSwathIndex);
    }
 else {
      gain=computeAntPatGain(elevationAngle,newRefElevationAngle[0],newAntennaPatternSingleSwath[bandPolarIdx]);
    }
    sigma/=gain;
  }
  return sigma;
}","/** 
 * Apply calibrations to the given point. The following calibrations are included: calibration constant, antenna pattern compensation, range spreading loss correction and incidence angle correction.
 * @param v                   The pixel value.
 * @param slantRange          The slant range (in m).
 * @param satelliteHeight     The distance from satellite to earth centre (in m).
 * @param sceneToEarthCentre  The distance from the backscattering element position to earth centre (in m).
 * @param localIncidenceAngle The local incidence angle (in degrees).
 * @param bandPolar           The source band polarization index.
 * @param bandUnit            The source band unit.
 * @param subSwathIndex       The sub swath index for current pixel for wide swath product case.
 * @return The calibrated pixel value.
 */
public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  int bandPolarIdx=0;
  if (bandPolar != null && mdsPolar[1] != null && mdsPolar[1].contains(bandPolar)) {
    bandPolarIdx=1;
  }
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
    sigma=FastMath.pow(10,v / 5.0);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  sigma*=FastMath.sin(Math.abs(localIncidenceAngle) * Constants.DTOR) / newCalibrationConstant[bandPolarIdx];
  if (multilookFlag && antElevCorrFlag) {
    return sigma;
  }
  if (auxFile == null || !auxFile.contains(CalibrationOp.PRODUCT_AUX)) {
    sigma*=FastMath.pow(slantRange / refSlantRange800km,rangeSpreadingCompPower);
  }
  if (applyAntennaPatternCorr) {
    final double elevationAngle=computeElevationAngle(slantRange,satelliteHeight,sceneToEarthCentre);
    double gain;
    if (wideSwathProductFlag) {
      if (subSwathIndex[0] == INVALID_SUB_SWATH_INDEX) {
        final TiePointInterpolator slantRangeTPGInterp=new TiePointInterpolator(slantRangeTime);
        computeSubSwathIndex(rangeIndex,azimuthIndex,newRefElevationAngle,subSwathIndex,slantRangeTPGInterp);
      }
      gain=getAntennaPatternGain(elevationAngle,bandPolarIdx,newRefElevationAngle,newAntennaPatternWideSwath,false,subSwathIndex);
    }
 else {
      gain=computeAntPatGain(elevationAngle,newRefElevationAngle[0],newAntennaPatternSingleSwath[bandPolarIdx]);
    }
    sigma/=gain;
  }
  return sigma;
}"
11472,"/** 
 * Apply calibrations to the given point. The following calibrations are included: calibration constant, antenna pattern compensation, range spreading loss correction and incidence angle correction.
 * @param v                   The pixel value.
 * @param slantRange          The slant range (in m).
 * @param satelliteHeight     The distance from satellite to earth centre (in m).
 * @param sceneToEarthCentre  The distance from the backscattering element position to earth centre (in m).
 * @param localIncidenceAngle The local incidence angle (in degrees).
 * @param bandPolar           The source band polarization index.
 * @param bandUnit            The source band unit.
 * @param subSwathIndex       The sub swath index for current pixel for wide swath product case.
 * @return The calibrated pixel value.
 */
public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double Ks=1.0;
  if (applyConstantCorrection) {
    Ks=calibrationFactor.get(bandPolar.toUpperCase());
  }
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (applyRangeSpreadingLossCorrection)   sigma*=FastMath.pow(referenceSlantRange,2 * referenceSlantRangeExp);
  if (applyIncidenceAngleCorrection)   sigma*=FastMath.sin(referenceIncidenceAngle);
  sigma/=(rescalingFactor * rescalingFactor * Ks);
  if (outputImageScaleInDb) {
    if (sigma < underFlowFloat) {
      sigma=-underFlowFloat;
    }
 else {
      sigma=10.0 * Math.log10(sigma);
    }
  }
  return sigma;
}","/** 
 * Apply calibrations to the given point. The following calibrations are included: calibration constant, antenna pattern compensation, range spreading loss correction and incidence angle correction.
 * @param v                   The pixel value.
 * @param slantRange          The slant range (in m).
 * @param satelliteHeight     The distance from satellite to earth centre (in m).
 * @param sceneToEarthCentre  The distance from the backscattering element position to earth centre (in m).
 * @param localIncidenceAngle The local incidence angle (in degrees).
 * @param bandPolar           The source band polarization index.
 * @param bandUnit            The source band unit.
 * @param subSwathIndex       The sub swath index for current pixel for wide swath product case.
 * @return The calibrated pixel value.
 */
public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double Ks=1.0;
  if (applyConstantCorrection) {
    Ks=calibrationFactor.get(bandPolar.toUpperCase());
  }
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (applyRangeSpreadingLossCorrection)   sigma*=FastMath.pow(referenceSlantRange,2 * referenceSlantRangeExp);
  if (applyIncidenceAngleCorrection)   sigma*=FastMath.sin(referenceIncidenceAngle);
  sigma/=(rescalingFactor * rescalingFactor * Ks);
  if (outputImageScaleInDb) {
    if (sigma < underFlowFloat) {
      sigma=-underFlowFloat;
    }
 else {
      sigma=10.0 * Math.log10(sigma);
    }
  }
  return sigma;
}"
11473,"public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,final int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
    sigma=FastMath.pow(10,v / 5.0);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (multilookFlag && antennaPatternCorrectionFlag) {
    return FastMath.sin(Math.abs(localIncidenceAngle) * Constants.DTOR) / FastMath.sin(referenceIncidenceAngle) / calibrationConstant;
  }
  sigma*=FastMath.sin(Math.abs(localIncidenceAngle) * Constants.DTOR) / FastMath.sin(referenceIncidenceAngle);
  sigma/=getNewAntennaPatternGainSquare((int)rangeIndex);
  sigma*=rangeSpreadingLoss[(int)rangeIndex];
  sigma*=replicaPulseVariationsCorrectionFactor;
  sigma/=calibrationConstant;
  return sigma;
}","public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,final int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.AMPLITUDE_DB) {
    sigma=FastMath.pow(10,v / 5.0);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (multilookFlag && antennaPatternCorrectionFlag) {
    return FastMath.sin(Math.abs(localIncidenceAngle) * Constants.DTOR) / FastMath.sin(referenceIncidenceAngle) / calibrationConstant;
  }
  sigma*=FastMath.sin(Math.abs(localIncidenceAngle) * Constants.DTOR) / FastMath.sin(referenceIncidenceAngle);
  sigma/=getNewAntennaPatternGainSquare((int)rangeIndex);
  sigma*=rangeSpreadingLoss[(int)rangeIndex];
  sigma*=replicaPulseVariationsCorrectionFactor;
  sigma/=calibrationConstant;
  return sigma;
}"
11474,"public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (isComplex) {
    if (gains != null) {
      sigma/=(gains[(int)rangeIndex] * gains[(int)rangeIndex]);
    }
  }
 else {
    sigma+=offset;
    if (gains != null) {
      sigma/=gains[(int)rangeIndex];
    }
  }
  if (incidenceAngleSelection.contains(USE_INCIDENCE_ANGLE_FROM_DEM)) {
    return sigma * FastMath.sin(localIncidenceAngle * Constants.DTOR);
  }
 else {
    return sigma;
  }
}","public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  if (isComplex) {
    if (gains != null) {
      sigma/=(gains[(int)rangeIndex] * gains[(int)rangeIndex]);
    }
  }
 else {
    sigma+=offset;
    if (gains != null) {
      sigma/=gains[(int)rangeIndex];
    }
  }
  if (incidenceAngleSelection.contains(USE_INCIDENCE_ANGLE_FROM_DEM)) {
    return sigma * FastMath.sin(localIncidenceAngle * Constants.DTOR);
  }
 else {
    return sigma;
  }
}"
11475,"public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  final String targetBandName=""String_Node_Str"" + bandPolar.toUpperCase();
  final CalibrationInfo calInfo=targetBandToCalInfo.get(targetBandName);
  final int calVecIdx=calInfo.getCalibrationVectorIndex((int)azimuthIndex);
  final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
  final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
  final CALTYPE calType=getCalibrationType(targetBandName);
  final float[] vec0LUT=getVector(calType,vec0);
  final float[] vec1LUT=getVector(calType,vec1);
  final int pixelIdx=calInfo.getPixelIndex((int)rangeIndex,calVecIdx);
  final double azTime=calInfo.firstLineTime + azimuthIndex * calInfo.lineTimeInterval;
  final double muY=(azTime - vec0.timeMJD) / (vec1.timeMJD - vec0.timeMJD);
  final double muX=(rangeIndex - vec0.pixels[pixelIdx]) / (double)(vec0.pixels[pixelIdx + 1] - vec0.pixels[pixelIdx]);
  final double lutVal=(1 - muY) * ((1 - muX) * vec0LUT[pixelIdx] + muX * vec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * vec1LUT[pixelIdx] + muX * vec1LUT[pixelIdx + 1]);
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v / (lutVal * lutVal);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY) {
    sigma=v / (lutVal * lutVal);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0) / (lutVal * lutVal);
  }
 else   if (bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v / lutVal;
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  return sigma;
}","public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  final CalibrationInfo calInfo=targetBandToCalInfo.get(bandName);
  final int calVecIdx=calInfo.getCalibrationVectorIndex((int)azimuthIndex);
  final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
  final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
  final CALTYPE calType=getCalibrationType(bandName);
  final float[] vec0LUT=getVector(calType,vec0);
  final float[] vec1LUT=getVector(calType,vec1);
  final int pixelIdx=calInfo.getPixelIndex((int)rangeIndex,calVecIdx);
  final double azTime=calInfo.firstLineTime + azimuthIndex * calInfo.lineTimeInterval;
  final double muY=(azTime - vec0.timeMJD) / (vec1.timeMJD - vec0.timeMJD);
  final double muX=(rangeIndex - vec0.pixels[pixelIdx]) / (double)(vec0.pixels[pixelIdx + 1] - vec0.pixels[pixelIdx]);
  final double lutVal=(1 - muY) * ((1 - muX) * vec0LUT[pixelIdx] + muX * vec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * vec1LUT[pixelIdx] + muX * vec1LUT[pixelIdx + 1]);
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v / (lutVal * lutVal);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY) {
    sigma=v / (lutVal * lutVal);
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0) / (lutVal * lutVal);
  }
 else   if (bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v / lutVal;
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  return sigma;
}"
11476,"public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  final double Ks=calibrationFactor.get(bandPolar.toUpperCase());
  sigma*=Ks * FastMath.sin(localIncidenceAngle * Constants.DTOR);
  return sigma;
}","public double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex){
  double sigma=0.0;
  if (bandUnit == Unit.UnitType.AMPLITUDE) {
    sigma=v * v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY || bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY) {
    sigma=v;
  }
 else   if (bandUnit == Unit.UnitType.INTENSITY_DB) {
    sigma=FastMath.pow(10,v / 10.0);
  }
 else {
    throw new OperatorException(""String_Node_Str"");
  }
  final double Ks=calibrationFactor.get(bandPolar.toUpperCase());
  sigma*=Ks * FastMath.sin(localIncidenceAngle * Constants.DTOR);
  return sigma;
}"
11477,"double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex);","double applyCalibration(final double v,final double rangeIndex,final double azimuthIndex,final double slantRange,final double satelliteHeight,final double sceneToEarthCentre,final double localIncidenceAngle,final String bandName,final String bandPolar,final Unit.UnitType bandUnit,int[] subSwathIndex);"
11478,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    processingStarted=true;
    try {
      if (!isElevationModelAvailable) {
        getElevationModel();
      }
    }
 catch (    Exception e) {
      throw new OperatorException(e);
    }
    final int x0=targetRectangle.x;
    final int y0=targetRectangle.y;
    final int w=targetRectangle.width;
    final int h=targetRectangle.height;
    final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,x0 - 1,y0 - 1,w + 2,h + 2);
    double[][] localDEM=new double[h + 2][w + 2];
    if (useAvgSceneHeight) {
      DEMFactory.fillDEM(localDEM,avgSceneHeight);
    }
 else {
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,x0,y0,w,h,sourceProduct,nodataValueAtSea,localDEM);
      if (!valid && nodataValueAtSea)       return;
    }
    final GeoPos geoPos=new GeoPos();
    final PosVector earthPoint=new PosVector();
    final PosVector sensorPos=new PosVector();
    final int srcMaxRange=sourceImageWidth - 1;
    final int srcMaxAzimuth=sourceImageHeight - 1;
    ProductData demBuffer=null;
    ProductData latBuffer=null;
    ProductData lonBuffer=null;
    ProductData localIncidenceAngleBuffer=null;
    ProductData projectedLocalIncidenceAngleBuffer=null;
    ProductData incidenceAngleFromEllipsoidBuffer=null;
    final List<TileData> trgTileList=new ArrayList<>();
    final Set<Band> keySet=targetTiles.keySet();
    for (    Band targetBand : keySet) {
      if (targetBand.getName().equals(""String_Node_Str"")) {
        demBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        latBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        lonBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        localIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        projectedLocalIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        incidenceAngleFromEllipsoidBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      final Band[] srcBands=targetBandNameToSourceBand.get(targetBand.getName());
      final TileData td=new TileData(targetTiles.get(targetBand),srcBands,isPolsar,targetBand.getName(),getBandUnit(targetBand.getName()),absRoot,calibrator,imgResampling);
      td.applyRadiometricNormalization=targetBandApplyRadiometricNormalizationFlag.get(targetBand.getName());
      td.applyRetroCalibration=targetBandApplyRetroCalibrationFlag.get(targetBand.getName());
      trgTileList.add(td);
    }
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    final TileData[] trgTiles=trgTileList.toArray(new TileData[trgTileList.size()]);
    final EarthGravitationalModel96 egm=EarthGravitationalModel96.instance();
    int diffLat=Math.abs(latitude.getPixelInt(0,0) - latitude.getPixelInt(0,targetImageHeight));
    for (int y=y0; y < maxY; y++) {
      final int yy=y - y0 + 1;
      for (int x=x0; x < maxX; x++) {
        final int index=trgTiles[0].targetTile.getDataBufferIndex(x,y);
        double alt=localDEM[yy][x - x0 + 1];
        if (alt == demNoDataValue && !useAvgSceneHeight) {
          if (nodataValueAtSea) {
            continue;
          }
        }
        tileGeoRef.getGeoPos(x,y,geoPos);
        final double lat=geoPos.lat;
        double lon=geoPos.lon;
        if (lon >= 180.0) {
          lon-=360.0;
        }
        if (alt == demNoDataValue && !nodataValueAtSea) {
          alt=egm.getEGM(lat,lon);
        }
        GeoUtils.geo2xyzWGS84(lat,lon,alt,earthPoint);
        double zeroDopplerTime=SARGeocoding.getEarthPointZeroDopplerTime(firstLineUTC,lineTimeInterval,wavelength,earthPoint,orbit.sensorPosition,orbit.sensorVelocity);
        if (Double.compare(zeroDopplerTime,SARGeocoding.NonValidZeroDopplerTime) == 0) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        double slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        if (!skipBistaticCorrection) {
          zeroDopplerTime+=slantRange / Constants.lightSpeedInMetersPerDay;
          slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        }
        double rangeIndex=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDopplerTime,slantRange,nearEdgeSlantRange,srgrConvParams);
        if (rangeIndex == -1.0) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        if (!nearRangeOnLeft) {
          rangeIndex=srcMaxRange - rangeIndex;
        }
        final double azimuthIndex=(zeroDopplerTime - firstLineUTC) / lineTimeInterval;
        if (!SARGeocoding.isValidCell(rangeIndex,azimuthIndex,lat,lon,diffLat,latitude,longitude,srcMaxRange,srcMaxAzimuth,sensorPos)) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
        }
 else {
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          if (saveLocalIncidenceAngle || saveProjectedLocalIncidenceAngle || saveSigmaNought) {
            final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,earthPoint,sensorPos);
            SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,saveLocalIncidenceAngle,saveProjectedLocalIncidenceAngle,saveSigmaNought,x0,y0,x,y,localDEM,localIncidenceAngles);
            if (saveLocalIncidenceAngle && localIncidenceAngles[0] != SARGeocoding.NonValidIncidenceAngle) {
              localIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[0]);
            }
            if (saveProjectedLocalIncidenceAngle && localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
              projectedLocalIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[1]);
            }
          }
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,alt);
          }
          if (saveLatLon) {
            latBuffer.setElemDoubleAt(index,lat);
            lonBuffer.setElemDoubleAt(index,lon);
          }
          if (saveIncidenceAngleFromEllipsoid && incidenceAngle != null) {
            incidenceAngleFromEllipsoidBuffer.setElemDoubleAt(index,incidenceAngle.getPixelDouble(rangeIndex,azimuthIndex));
          }
          double satelliteHeight=0;
          double sceneToEarthCentre=0;
          if (saveSigmaNought) {
            satelliteHeight=Math.sqrt(sensorPos.x * sensorPos.x + sensorPos.y * sensorPos.y + sensorPos.z * sensorPos.z);
            sceneToEarthCentre=Math.sqrt(earthPoint.x * earthPoint.x + earthPoint.y * earthPoint.y + earthPoint.z * earthPoint.z);
          }
          for (          TileData tileData : trgTiles) {
            int[] subSwathIndex={INVALID_SUB_SWATH_INDEX};
            double v=getPixelValue(azimuthIndex,rangeIndex,tileData,subSwathIndex);
            if (v != tileData.noDataValue && tileData.applyRadiometricNormalization) {
              if (localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
                v=calibrator.applyCalibration(v,rangeIndex,azimuthIndex,slantRange,satelliteHeight,sceneToEarthCentre,localIncidenceAngles[1],tileData.bandPolar,tileData.bandUnit,subSwathIndex);
              }
 else {
                v=tileData.noDataValue;
              }
            }
            tileData.tileDataBuffer.setElemDoubleAt(index,v);
          }
          orthoDataProduced=true;
        }
      }
    }
    localDEM=null;
  }
 catch (  Throwable e) {
    orthoDataProduced=true;
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    processingStarted=true;
    try {
      if (!isElevationModelAvailable) {
        getElevationModel();
      }
    }
 catch (    Exception e) {
      throw new OperatorException(e);
    }
    final int x0=targetRectangle.x;
    final int y0=targetRectangle.y;
    final int w=targetRectangle.width;
    final int h=targetRectangle.height;
    final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,x0 - 1,y0 - 1,w + 2,h + 2);
    double[][] localDEM=new double[h + 2][w + 2];
    if (useAvgSceneHeight) {
      DEMFactory.fillDEM(localDEM,avgSceneHeight);
    }
 else {
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,x0,y0,w,h,sourceProduct,nodataValueAtSea,localDEM);
      if (!valid && nodataValueAtSea)       return;
    }
    final GeoPos geoPos=new GeoPos();
    final PosVector earthPoint=new PosVector();
    final PosVector sensorPos=new PosVector();
    final int srcMaxRange=sourceImageWidth - 1;
    final int srcMaxAzimuth=sourceImageHeight - 1;
    ProductData demBuffer=null;
    ProductData latBuffer=null;
    ProductData lonBuffer=null;
    ProductData localIncidenceAngleBuffer=null;
    ProductData projectedLocalIncidenceAngleBuffer=null;
    ProductData incidenceAngleFromEllipsoidBuffer=null;
    final List<TileData> trgTileList=new ArrayList<>();
    final Set<Band> keySet=targetTiles.keySet();
    for (    Band targetBand : keySet) {
      if (targetBand.getName().equals(""String_Node_Str"")) {
        demBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        latBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        lonBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        localIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        projectedLocalIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      if (targetBand.getName().equals(""String_Node_Str"")) {
        incidenceAngleFromEllipsoidBuffer=targetTiles.get(targetBand).getDataBuffer();
        continue;
      }
      final Band[] srcBands=targetBandNameToSourceBand.get(targetBand.getName());
      final TileData td=new TileData(targetTiles.get(targetBand),srcBands,isPolsar,targetBand.getName(),getBandUnit(targetBand.getName()),absRoot,calibrator,imgResampling);
      td.applyRadiometricNormalization=targetBandApplyRadiometricNormalizationFlag.get(targetBand.getName());
      td.applyRetroCalibration=targetBandApplyRetroCalibrationFlag.get(targetBand.getName());
      trgTileList.add(td);
    }
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    final TileData[] trgTiles=trgTileList.toArray(new TileData[trgTileList.size()]);
    final EarthGravitationalModel96 egm=EarthGravitationalModel96.instance();
    int diffLat=Math.abs(latitude.getPixelInt(0,0) - latitude.getPixelInt(0,targetImageHeight));
    for (int y=y0; y < maxY; y++) {
      final int yy=y - y0 + 1;
      for (int x=x0; x < maxX; x++) {
        final int index=trgTiles[0].targetTile.getDataBufferIndex(x,y);
        double alt=localDEM[yy][x - x0 + 1];
        if (alt == demNoDataValue && !useAvgSceneHeight) {
          if (nodataValueAtSea) {
            continue;
          }
        }
        tileGeoRef.getGeoPos(x,y,geoPos);
        final double lat=geoPos.lat;
        double lon=geoPos.lon;
        if (lon >= 180.0) {
          lon-=360.0;
        }
        if (alt == demNoDataValue && !nodataValueAtSea) {
          alt=egm.getEGM(lat,lon);
        }
        GeoUtils.geo2xyzWGS84(lat,lon,alt,earthPoint);
        double zeroDopplerTime=SARGeocoding.getEarthPointZeroDopplerTime(firstLineUTC,lineTimeInterval,wavelength,earthPoint,orbit.sensorPosition,orbit.sensorVelocity);
        if (Double.compare(zeroDopplerTime,SARGeocoding.NonValidZeroDopplerTime) == 0) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        double slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        if (!skipBistaticCorrection) {
          zeroDopplerTime+=slantRange / Constants.lightSpeedInMetersPerDay;
          slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        }
        double rangeIndex=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDopplerTime,slantRange,nearEdgeSlantRange,srgrConvParams);
        if (rangeIndex == -1.0) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        if (!nearRangeOnLeft) {
          rangeIndex=srcMaxRange - rangeIndex;
        }
        final double azimuthIndex=(zeroDopplerTime - firstLineUTC) / lineTimeInterval;
        if (!SARGeocoding.isValidCell(rangeIndex,azimuthIndex,lat,lon,diffLat,latitude,longitude,srcMaxRange,srcMaxAzimuth,sensorPos)) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
        }
 else {
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          if (saveLocalIncidenceAngle || saveProjectedLocalIncidenceAngle || saveSigmaNought) {
            final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,earthPoint,sensorPos);
            SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,saveLocalIncidenceAngle,saveProjectedLocalIncidenceAngle,saveSigmaNought,x0,y0,x,y,localDEM,localIncidenceAngles);
            if (saveLocalIncidenceAngle && localIncidenceAngles[0] != SARGeocoding.NonValidIncidenceAngle) {
              localIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[0]);
            }
            if (saveProjectedLocalIncidenceAngle && localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
              projectedLocalIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[1]);
            }
          }
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,alt);
          }
          if (saveLatLon) {
            latBuffer.setElemDoubleAt(index,lat);
            lonBuffer.setElemDoubleAt(index,lon);
          }
          if (saveIncidenceAngleFromEllipsoid && incidenceAngle != null) {
            incidenceAngleFromEllipsoidBuffer.setElemDoubleAt(index,incidenceAngle.getPixelDouble(rangeIndex,azimuthIndex));
          }
          double satelliteHeight=0;
          double sceneToEarthCentre=0;
          if (saveSigmaNought) {
            satelliteHeight=Math.sqrt(sensorPos.x * sensorPos.x + sensorPos.y * sensorPos.y + sensorPos.z * sensorPos.z);
            sceneToEarthCentre=Math.sqrt(earthPoint.x * earthPoint.x + earthPoint.y * earthPoint.y + earthPoint.z * earthPoint.z);
          }
          for (          TileData tileData : trgTiles) {
            int[] subSwathIndex={INVALID_SUB_SWATH_INDEX};
            double v=getPixelValue(azimuthIndex,rangeIndex,tileData,subSwathIndex);
            if (v != tileData.noDataValue && tileData.applyRadiometricNormalization) {
              if (localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
                v=calibrator.applyCalibration(v,rangeIndex,azimuthIndex,slantRange,satelliteHeight,sceneToEarthCentre,localIncidenceAngles[1],tileData.bandName,tileData.bandPolar,tileData.bandUnit,subSwathIndex);
              }
 else {
                v=tileData.noDataValue;
              }
            }
            tileData.tileDataBuffer.setElemDoubleAt(index,v);
          }
          orthoDataProduced=true;
        }
      }
    }
    localDEM=null;
  }
 catch (  Throwable e) {
    orthoDataProduced=true;
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11479,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  processingStarted=true;
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  final int ymax=y0 + h;
  final int xmax=x0 + w;
  final GeoPos geoPos=new GeoPos();
  final PosVector earthPoint=new PosVector();
  final PosVector sensorPos=new PosVector();
  final int srcMaxRange=sourceImageWidth - 1;
  final int srcMaxAzimuth=sourceImageHeight - 1;
  ProductData demBuffer=null;
  ProductData latBuffer=null;
  ProductData lonBuffer=null;
  ProductData localIncidenceAngleBuffer=null;
  ProductData projectedLocalIncidenceAngleBuffer=null;
  ProductData layoverShadowingMasksBuffer=null;
  ProductData incidenceAngleFromEllipsoidBuffer=null;
  final Set<Band> keySet=targetTiles.keySet();
  if (!warpDataAvailable) {
    getWarpData(keySet,targetRectangle);
    outputResidualAndShiftFiles();
  }
  final List<RangeDopplerGeocodingOp.TileData> trgTileList=new ArrayList<>();
  for (  Band targetBand : keySet) {
    if (targetBand.getName().equals(""String_Node_Str"")) {
      demBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      latBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      lonBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      localIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      projectedLocalIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(SARSimulationOp.layoverShadowMaskBandName)) {
      layoverShadowingMasksBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      incidenceAngleFromEllipsoidBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    final Band[] srcBands=new Band[]{sourceProduct.getBand(srcBandNames[0]),srcBandNames.length > 1 ? sourceProduct.getBand(srcBandNames[1]) : null};
    final RangeDopplerGeocodingOp.TileData td=new RangeDopplerGeocodingOp.TileData(targetTiles.get(targetBand),srcBands,isPolsar,targetBand.getName(),getBandUnit(targetBand.getName()),absRoot,calibrator,imgResampling);
    td.applyRadiometricNormalization=targetBandapplyRadiometricNormalizationFlag.get(targetBand.getName());
    td.applyRetroCalibration=targetBandApplyRetroCalibrationFlag.get(targetBand.getName());
    trgTileList.add(td);
  }
  final RangeDopplerGeocodingOp.TileData[] trgTiles=trgTileList.toArray(new RangeDopplerGeocodingOp.TileData[trgTileList.size()]);
  final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,x0 - 1,y0 - 1,w + 2,h + 2);
  int diffLat=Math.abs(latitude.getPixelInt(0,0) - latitude.getPixelInt(0,targetImageHeight));
  try {
    final double[][] localDEM=new double[h + 2][w + 2];
    if (useAvgSceneHeight) {
      DEMFactory.fillDEM(localDEM,avgSceneHeight);
    }
 else {
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,x0,y0,w,h,sourceProduct,true,localDEM);
      if (!valid)       return;
    }
    for (int y=y0; y < ymax; y++) {
      final int yy=y - y0 + 1;
      for (int x=x0; x < xmax; x++) {
        final int index=trgTiles[0].targetTile.getDataBufferIndex(x,y);
        final double alt=localDEM[yy][x - x0 + 1];
        if (!useAvgSceneHeight && alt == demNoDataValue) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        tileGeoRef.getGeoPos(x,y,geoPos);
        if (!geoPos.isValid()) {
          continue;
        }
        final double lat=geoPos.lat;
        double lon=geoPos.lon;
        if (lon >= 180.0) {
          lon-=360.0;
        }
        GeoUtils.geo2xyzWGS84(lat,lon,alt,earthPoint);
        final double zeroDopplerTime=getEarthPointZeroDopplerTime(earthPoint);
        if (Double.compare(zeroDopplerTime,NonValidZeroDopplerTime) == 0) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        double slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        double zeroDoppler=zeroDopplerTime;
        if (!skipBistaticCorrection) {
          zeroDoppler=zeroDopplerTime + slantRange / Constants.lightSpeedInMetersPerDay;
          slantRange=SARGeocoding.computeSlantRange(zeroDoppler,orbit,earthPoint,sensorPos);
        }
        final double azimuthIndex=(zeroDoppler - firstLineUTC) / lineTimeInterval;
        double rangeIndex=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDoppler,slantRange,nearEdgeSlantRange,srgrConvParams);
        if (!nearRangeOnLeft) {
          rangeIndex=srcMaxRange - rangeIndex;
        }
        if (!SARGeocoding.isValidCell(rangeIndex,azimuthIndex,lat,lon,diffLat,latitude,longitude,srcMaxRange,srcMaxAzimuth,sensorPos)) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
        }
 else {
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          if (saveLocalIncidenceAngle || saveProjectedLocalIncidenceAngle || saveSigmaNought) {
            final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,earthPoint,sensorPos);
            SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,saveLocalIncidenceAngle,saveProjectedLocalIncidenceAngle,saveSigmaNought,x0,y0,x,y,localDEM,localIncidenceAngles);
            if (saveLocalIncidenceAngle && localIncidenceAngles[0] != SARGeocoding.NonValidIncidenceAngle) {
              localIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[0]);
            }
            if (saveProjectedLocalIncidenceAngle && localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
              projectedLocalIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[1]);
            }
          }
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,alt);
          }
          if (saveLatLon) {
            latBuffer.setElemDoubleAt(index,lat);
            lonBuffer.setElemDoubleAt(index,lon);
          }
          if (saveLayoverShadowMask) {
            final Rectangle srcRect=new Rectangle((int)(rangeIndex + 0.5),(int)(azimuthIndex + 0.5),1,1);
            final Tile sourceTile=getSourceTile(maskBand,srcRect);
            final int m=sourceTile.getDataBuffer().getElemIntAt(sourceTile.getDataBufferIndex((int)(rangeIndex + 0.5),(int)(azimuthIndex + 0.5)));
            layoverShadowingMasksBuffer.setElemIntAt(index,m);
          }
          if (saveIncidenceAngleFromEllipsoid) {
            incidenceAngleFromEllipsoidBuffer.setElemDoubleAt(index,incidenceAngle.getPixelDouble(rangeIndex,azimuthIndex));
          }
          for (          RangeDopplerGeocodingOp.TileData tileData : trgTiles) {
            final Unit.UnitType bandUnit=getBandUnit(tileData.bandName);
            final String[] srcBandName=targetBandNameToSourceBandName.get(tileData.bandName);
            final Band srcBand=sourceProduct.getBand(srcBandName[0]);
            final PixelPos pixelPos=new PixelPos();
            final WarpOp.WarpData warpData=warpDataMap.get(srcBand);
            if (warpData.notEnoughGCPs) {
              continue;
            }
            WarpOp.getWarpedCoords(warpData,warpPolynomialOrder,rangeIndex,azimuthIndex,pixelPos);
            if (pixelPos.x < 0.0 || pixelPos.x >= srcMaxRange || pixelPos.y < 0.0 || pixelPos.y >= srcMaxAzimuth) {
              tileData.tileDataBuffer.setElemDoubleAt(index,tileData.noDataValue);
              continue;
            }
            final int[] subSwathIndex={INVALID_SUB_SWATH_INDEX};
            double v=getPixelValue(pixelPos.y,pixelPos.x,tileData,subSwathIndex);
            if (v != tileData.noDataValue && tileData.applyRadiometricNormalization) {
              if (localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
                final double satelliteHeight=Math.sqrt(sensorPos.x * sensorPos.x + sensorPos.y * sensorPos.y + sensorPos.z * sensorPos.z);
                final double sceneToEarthCentre=Math.sqrt(earthPoint.x * earthPoint.x + earthPoint.y * earthPoint.y + earthPoint.z * earthPoint.z);
                v=calibrator.applyCalibration(v,rangeIndex,azimuthIndex,slantRange,satelliteHeight,sceneToEarthCentre,localIncidenceAngles[1],tileData.bandPolar,bandUnit,subSwathIndex);
              }
 else {
                v=tileData.noDataValue;
              }
            }
            tileData.tileDataBuffer.setElemDoubleAt(index,v);
          }
          orthoDataProduced=true;
        }
      }
    }
  }
 catch (  Throwable e) {
    orthoDataProduced=true;
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  processingStarted=true;
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  final int ymax=y0 + h;
  final int xmax=x0 + w;
  final GeoPos geoPos=new GeoPos();
  final PosVector earthPoint=new PosVector();
  final PosVector sensorPos=new PosVector();
  final int srcMaxRange=sourceImageWidth - 1;
  final int srcMaxAzimuth=sourceImageHeight - 1;
  ProductData demBuffer=null;
  ProductData latBuffer=null;
  ProductData lonBuffer=null;
  ProductData localIncidenceAngleBuffer=null;
  ProductData projectedLocalIncidenceAngleBuffer=null;
  ProductData layoverShadowingMasksBuffer=null;
  ProductData incidenceAngleFromEllipsoidBuffer=null;
  final Set<Band> keySet=targetTiles.keySet();
  if (!warpDataAvailable) {
    getWarpData(keySet,targetRectangle);
    outputResidualAndShiftFiles();
  }
  final List<RangeDopplerGeocodingOp.TileData> trgTileList=new ArrayList<>();
  for (  Band targetBand : keySet) {
    if (targetBand.getName().equals(""String_Node_Str"")) {
      demBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      latBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      lonBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      localIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      projectedLocalIncidenceAngleBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(SARSimulationOp.layoverShadowMaskBandName)) {
      layoverShadowingMasksBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    if (targetBand.getName().equals(""String_Node_Str"")) {
      incidenceAngleFromEllipsoidBuffer=targetTiles.get(targetBand).getDataBuffer();
      continue;
    }
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    final Band[] srcBands=new Band[]{sourceProduct.getBand(srcBandNames[0]),srcBandNames.length > 1 ? sourceProduct.getBand(srcBandNames[1]) : null};
    final RangeDopplerGeocodingOp.TileData td=new RangeDopplerGeocodingOp.TileData(targetTiles.get(targetBand),srcBands,isPolsar,targetBand.getName(),getBandUnit(targetBand.getName()),absRoot,calibrator,imgResampling);
    td.applyRadiometricNormalization=targetBandapplyRadiometricNormalizationFlag.get(targetBand.getName());
    td.applyRetroCalibration=targetBandApplyRetroCalibrationFlag.get(targetBand.getName());
    trgTileList.add(td);
  }
  final RangeDopplerGeocodingOp.TileData[] trgTiles=trgTileList.toArray(new RangeDopplerGeocodingOp.TileData[trgTileList.size()]);
  final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,x0 - 1,y0 - 1,w + 2,h + 2);
  int diffLat=Math.abs(latitude.getPixelInt(0,0) - latitude.getPixelInt(0,targetImageHeight));
  try {
    final double[][] localDEM=new double[h + 2][w + 2];
    if (useAvgSceneHeight) {
      DEMFactory.fillDEM(localDEM,avgSceneHeight);
    }
 else {
      final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,x0,y0,w,h,sourceProduct,true,localDEM);
      if (!valid)       return;
    }
    for (int y=y0; y < ymax; y++) {
      final int yy=y - y0 + 1;
      for (int x=x0; x < xmax; x++) {
        final int index=trgTiles[0].targetTile.getDataBufferIndex(x,y);
        final double alt=localDEM[yy][x - x0 + 1];
        if (!useAvgSceneHeight && alt == demNoDataValue) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        tileGeoRef.getGeoPos(x,y,geoPos);
        if (!geoPos.isValid()) {
          continue;
        }
        final double lat=geoPos.lat;
        double lon=geoPos.lon;
        if (lon >= 180.0) {
          lon-=360.0;
        }
        GeoUtils.geo2xyzWGS84(lat,lon,alt,earthPoint);
        final double zeroDopplerTime=getEarthPointZeroDopplerTime(earthPoint);
        if (Double.compare(zeroDopplerTime,NonValidZeroDopplerTime) == 0) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
          continue;
        }
        double slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        double zeroDoppler=zeroDopplerTime;
        if (!skipBistaticCorrection) {
          zeroDoppler=zeroDopplerTime + slantRange / Constants.lightSpeedInMetersPerDay;
          slantRange=SARGeocoding.computeSlantRange(zeroDoppler,orbit,earthPoint,sensorPos);
        }
        final double azimuthIndex=(zeroDoppler - firstLineUTC) / lineTimeInterval;
        double rangeIndex=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDoppler,slantRange,nearEdgeSlantRange,srgrConvParams);
        if (!nearRangeOnLeft) {
          rangeIndex=srcMaxRange - rangeIndex;
        }
        if (!SARGeocoding.isValidCell(rangeIndex,azimuthIndex,lat,lon,diffLat,latitude,longitude,srcMaxRange,srcMaxAzimuth,sensorPos)) {
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,demNoDataValue);
          }
        }
 else {
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          if (saveLocalIncidenceAngle || saveProjectedLocalIncidenceAngle || saveSigmaNought) {
            final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,earthPoint,sensorPos);
            SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,saveLocalIncidenceAngle,saveProjectedLocalIncidenceAngle,saveSigmaNought,x0,y0,x,y,localDEM,localIncidenceAngles);
            if (saveLocalIncidenceAngle && localIncidenceAngles[0] != SARGeocoding.NonValidIncidenceAngle) {
              localIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[0]);
            }
            if (saveProjectedLocalIncidenceAngle && localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
              projectedLocalIncidenceAngleBuffer.setElemDoubleAt(index,localIncidenceAngles[1]);
            }
          }
          if (saveDEM) {
            demBuffer.setElemDoubleAt(index,alt);
          }
          if (saveLatLon) {
            latBuffer.setElemDoubleAt(index,lat);
            lonBuffer.setElemDoubleAt(index,lon);
          }
          if (saveLayoverShadowMask) {
            final Rectangle srcRect=new Rectangle((int)(rangeIndex + 0.5),(int)(azimuthIndex + 0.5),1,1);
            final Tile sourceTile=getSourceTile(maskBand,srcRect);
            final int m=sourceTile.getDataBuffer().getElemIntAt(sourceTile.getDataBufferIndex((int)(rangeIndex + 0.5),(int)(azimuthIndex + 0.5)));
            layoverShadowingMasksBuffer.setElemIntAt(index,m);
          }
          if (saveIncidenceAngleFromEllipsoid) {
            incidenceAngleFromEllipsoidBuffer.setElemDoubleAt(index,incidenceAngle.getPixelDouble(rangeIndex,azimuthIndex));
          }
          for (          RangeDopplerGeocodingOp.TileData tileData : trgTiles) {
            final Unit.UnitType bandUnit=getBandUnit(tileData.bandName);
            final String[] srcBandName=targetBandNameToSourceBandName.get(tileData.bandName);
            final Band srcBand=sourceProduct.getBand(srcBandName[0]);
            final PixelPos pixelPos=new PixelPos();
            final WarpOp.WarpData warpData=warpDataMap.get(srcBand);
            if (warpData.notEnoughGCPs) {
              continue;
            }
            WarpOp.getWarpedCoords(warpData,warpPolynomialOrder,rangeIndex,azimuthIndex,pixelPos);
            if (pixelPos.x < 0.0 || pixelPos.x >= srcMaxRange || pixelPos.y < 0.0 || pixelPos.y >= srcMaxAzimuth) {
              tileData.tileDataBuffer.setElemDoubleAt(index,tileData.noDataValue);
              continue;
            }
            final int[] subSwathIndex={INVALID_SUB_SWATH_INDEX};
            double v=getPixelValue(pixelPos.y,pixelPos.x,tileData,subSwathIndex);
            if (v != tileData.noDataValue && tileData.applyRadiometricNormalization) {
              if (localIncidenceAngles[1] != SARGeocoding.NonValidIncidenceAngle) {
                final double satelliteHeight=Math.sqrt(sensorPos.x * sensorPos.x + sensorPos.y * sensorPos.y + sensorPos.z * sensorPos.z);
                final double sceneToEarthCentre=Math.sqrt(earthPoint.x * earthPoint.x + earthPoint.y * earthPoint.y + earthPoint.z * earthPoint.z);
                v=calibrator.applyCalibration(v,rangeIndex,azimuthIndex,slantRange,satelliteHeight,sceneToEarthCentre,localIncidenceAngles[1],tileData.bandName,tileData.bandPolar,bandUnit,subSwathIndex);
              }
 else {
                v=tileData.noDataValue;
              }
            }
            tileData.tileDataBuffer.setElemDoubleAt(index,v);
          }
          orthoDataProduced=true;
        }
      }
    }
  }
 catch (  Throwable e) {
    orthoDataProduced=true;
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11480,"private void checkSourceProductType(){
  final PolBandUtils.MATRIX sourceProductType=PolBandUtils.getSourceProductType(sourceProduct);
  if (sourceProductType == PolBandUtils.MATRIX.UNKNOWN) {
    throw new OperatorException(""String_Node_Str"");
  }
switch (matrix) {
case C2:
    if (sourceProductType != PolBandUtils.MATRIX.DUAL_HH_HV && sourceProductType != PolBandUtils.MATRIX.DUAL_HH_VV && sourceProductType != PolBandUtils.MATRIX.DUAL_HH_VV) {
      throw new OperatorException(""String_Node_Str"");
    }
  break;
case C3:
case C4:
case T3:
case T4:
if (PolBandUtils.isDualPol(sourceProductType)) {
  throw new OperatorException(""String_Node_Str"");
}
break;
default :
throw new OperatorException(""String_Node_Str"" + matrix);
}
}","private void checkSourceProductType(){
  final PolBandUtils.MATRIX sourceProductType=PolBandUtils.getSourceProductType(sourceProduct);
  if (sourceProductType == PolBandUtils.MATRIX.UNKNOWN) {
    throw new OperatorException(""String_Node_Str"");
  }
switch (matrix) {
case C2:
    if (sourceProductType != PolBandUtils.MATRIX.DUAL_HH_HV && sourceProductType != PolBandUtils.MATRIX.DUAL_VH_VV && sourceProductType != PolBandUtils.MATRIX.DUAL_HH_VV) {
      throw new OperatorException(""String_Node_Str"");
    }
  break;
case C3:
case C4:
case T3:
case T4:
if (PolBandUtils.isDualPol(sourceProductType)) {
  throw new OperatorException(""String_Node_Str"");
}
break;
default :
throw new OperatorException(""String_Node_Str"" + matrix);
}
}"
11481,"private PixelPos[][] computeSlavePixPos(final int subSwathIndex,final int mBurstIndex,final int sBurstIndex,final int x0,final int y0,final int w,final int h,final double[] extendedAmount,ProgressMonitor pm) throws Exception {
  try {
    final int xmin=Math.max(x0 - (int)extendedAmount[3],0);
    final int ymin=Math.max(y0 - (int)extendedAmount[1],0);
    final int ymax=y0 + h + (int)Math.abs(extendedAmount[0]);
    final int xmax=x0 + w + (int)Math.abs(extendedAmount[2]);
    final double[] latLonMinMax=new double[4];
    computeImageGeoBoundary(subSwathIndex,mBurstIndex,xmin,xmax,ymin,ymax,latLonMinMax);
    final double delta=(double)dem.getDescriptor().getDegreeRes() / (double)dem.getDescriptor().getPixelRes();
    final double extralat=20 * delta;
    double extralon=20 * delta;
    if (avgSceneHeight >= 2000.0) {
      extralon=20 * delta + 4.0 / 25.0;
    }
    final double latMin=latLonMinMax[0] - extralat;
    final double latMax=latLonMinMax[1] + extralat;
    final double lonMin=latLonMinMax[2] - extralon;
    final double lonMax=latLonMinMax[3] + extralon;
    final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
    final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
    final int latMaxIdx=(int)Math.floor(upperLeft.getY());
    final int latMinIdx=(int)Math.ceil(lowerRight.getY());
    final int lonMinIdx=(int)Math.floor(upperLeft.getX());
    final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
    final int numLines=latMinIdx - latMaxIdx;
    final int numPixels=lonMaxIdx - lonMinIdx;
    double[][] masterAz=new double[numLines][numPixels];
    double[][] masterRg=new double[numLines][numPixels];
    double[][] slaveAz=new double[numLines][numPixels];
    double[][] slaveRg=new double[numLines][numPixels];
    double[][] lat=new double[numLines][numPixels];
    double[][] lon=new double[numLines][numPixels];
    final PositionData posData=new PositionData();
    final PixelPos pix=new PixelPos();
    boolean noValidSlavePixPos=true;
    for (int l=0; l < numLines; l++) {
      for (int p=0; p < numPixels; p++) {
        pix.setLocation(lonMinIdx + p,latMaxIdx + l);
        GeoPos gp=dem.getGeoPos(pix);
        lat[l][p]=gp.lat;
        lon[l][p]=gp.lon;
        final double alt=dem.getElevation(gp);
        if (alt != demNoDataValue) {
          GeoUtils.geo2xyzWGS84(gp.lat,gp.lon,alt,posData.earthPoint);
          if (getPosition(subSwathIndex,mBurstIndex,mSU,mOrbit,posData)) {
            masterAz[l][p]=posData.azimuthIndex;
            masterRg[l][p]=posData.rangeIndex;
            if (getPosition(subSwathIndex,sBurstIndex,sSU,sOrbit,posData)) {
              slaveAz[l][p]=posData.azimuthIndex;
              slaveRg[l][p]=posData.rangeIndex;
              noValidSlavePixPos=false;
              continue;
            }
          }
        }
        masterAz[l][p]=invalidIndex;
        masterRg[l][p]=invalidIndex;
      }
    }
    if (noValidSlavePixPos) {
      return null;
    }
    final org.jlinda.core.Window tileWindow=new org.jlinda.core.Window(y0,y0 + h - 1,x0,x0 + w - 1);
    final double rgAzRatio=mSU.rangeSpacing / mSU.azimuthSpacing;
    final double[][] latArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] lonArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] azArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] rgArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    for (    double[] data : azArray) {
      Arrays.fill(data,invalidIndex);
    }
    for (    double[] data : rgArray) {
      Arrays.fill(data,invalidIndex);
    }
    TriangleUtils.gridDataLinear(masterAz,masterRg,slaveAz,slaveRg,lat,lon,azArray,rgArray,latArray,lonArray,tileWindow,rgAzRatio,1,1,invalidIndex,0);
    boolean allElementsAreNull=true;
    final PixelPos[][] slavePixelPos=new PixelPos[h][w];
    double alt=0;
    for (int yy=0; yy < h; yy++) {
      for (int xx=0; xx < w; xx++) {
        if (maskOutAreaWithoutElevation) {
          alt=dem.getElevation(new GeoPos(latArray[yy][xx],lonArray[yy][xx]));
        }
        if (rgArray[yy][xx] == invalidIndex || azArray[yy][xx] == invalidIndex || (maskOutAreaWithoutElevation && alt == demNoDataValue)) {
          slavePixelPos[yy][xx]=null;
        }
 else {
          slavePixelPos[yy][xx]=new PixelPos(rgArray[yy][xx],azArray[yy][xx]);
          allElementsAreNull=false;
        }
      }
    }
    if (allElementsAreNull) {
      return null;
    }
    return slavePixelPos;
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
  return null;
}","private PixelPos[][] computeSlavePixPos(final int subSwathIndex,final int mBurstIndex,final int sBurstIndex,final int x0,final int y0,final int w,final int h,final double[] extendedAmount,ProgressMonitor pm) throws Exception {
  try {
    final int xmin=x0 - (int)extendedAmount[3];
    final int ymin=y0 - (int)extendedAmount[1];
    final int ymax=y0 + h + (int)Math.abs(extendedAmount[0]);
    final int xmax=x0 + w + (int)Math.abs(extendedAmount[2]);
    final double[] latLonMinMax=new double[4];
    computeImageGeoBoundary(subSwathIndex,mBurstIndex,xmin,xmax,ymin,ymax,latLonMinMax);
    final double delta=(double)dem.getDescriptor().getDegreeRes() / (double)dem.getDescriptor().getPixelRes();
    final double extralat=20 * delta;
    final double extralon=20 * delta;
    final double latMin=latLonMinMax[0] - extralat;
    final double latMax=latLonMinMax[1] + extralat;
    final double lonMin=latLonMinMax[2] - extralon;
    final double lonMax=latLonMinMax[3] + extralon;
    final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
    final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
    final int latMaxIdx=(int)Math.floor(upperLeft.getY());
    final int latMinIdx=(int)Math.ceil(lowerRight.getY());
    final int lonMinIdx=(int)Math.floor(upperLeft.getX());
    final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
    final int numLines=latMinIdx - latMaxIdx;
    final int numPixels=lonMaxIdx - lonMinIdx;
    double[][] masterAz=new double[numLines][numPixels];
    double[][] masterRg=new double[numLines][numPixels];
    double[][] slaveAz=new double[numLines][numPixels];
    double[][] slaveRg=new double[numLines][numPixels];
    double[][] lat=new double[numLines][numPixels];
    double[][] lon=new double[numLines][numPixels];
    final PositionData posData=new PositionData();
    final PixelPos pix=new PixelPos();
    boolean noValidSlavePixPos=true;
    for (int l=0; l < numLines; l++) {
      for (int p=0; p < numPixels; p++) {
        pix.setLocation(lonMinIdx + p,latMaxIdx + l);
        GeoPos gp=dem.getGeoPos(pix);
        lat[l][p]=gp.lat;
        lon[l][p]=gp.lon;
        final double alt=dem.getElevation(gp);
        if (alt != demNoDataValue) {
          GeoUtils.geo2xyzWGS84(gp.lat,gp.lon,alt,posData.earthPoint);
          if (getPosition(subSwathIndex,mBurstIndex,mSU,mOrbit,posData)) {
            masterAz[l][p]=posData.azimuthIndex;
            masterRg[l][p]=posData.rangeIndex;
            if (getPosition(subSwathIndex,sBurstIndex,sSU,sOrbit,posData)) {
              slaveAz[l][p]=posData.azimuthIndex;
              slaveRg[l][p]=posData.rangeIndex;
              noValidSlavePixPos=false;
              continue;
            }
          }
        }
        masterAz[l][p]=invalidIndex;
        masterRg[l][p]=invalidIndex;
      }
    }
    if (noValidSlavePixPos) {
      return null;
    }
    final org.jlinda.core.Window tileWindow=new org.jlinda.core.Window(y0,y0 + h - 1,x0,x0 + w - 1);
    final double rgAzRatio=mSU.rangeSpacing / mSU.azimuthSpacing;
    final double[][] latArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] lonArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] azArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] rgArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    for (    double[] data : azArray) {
      Arrays.fill(data,invalidIndex);
    }
    for (    double[] data : rgArray) {
      Arrays.fill(data,invalidIndex);
    }
    TriangleUtils.gridDataLinear(masterAz,masterRg,slaveAz,slaveRg,lat,lon,azArray,rgArray,latArray,lonArray,tileWindow,rgAzRatio,1,1,invalidIndex,0);
    boolean allElementsAreNull=true;
    final PixelPos[][] slavePixelPos=new PixelPos[h][w];
    double alt=0;
    for (int yy=0; yy < h; yy++) {
      for (int xx=0; xx < w; xx++) {
        if (maskOutAreaWithoutElevation) {
          alt=dem.getElevation(new GeoPos(latArray[yy][xx],lonArray[yy][xx]));
        }
        if (rgArray[yy][xx] == invalidIndex || azArray[yy][xx] == invalidIndex || (maskOutAreaWithoutElevation && alt == demNoDataValue)) {
          slavePixelPos[yy][xx]=null;
        }
 else {
          slavePixelPos[yy][xx]=new PixelPos(rgArray[yy][xx],azArray[yy][xx]);
          allElementsAreNull=false;
        }
      }
    }
    if (allElementsAreNull) {
      return null;
    }
    return slavePixelPos;
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
  return null;
}"
11482,"/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    if (sourceProduct == null) {
      return;
    }
    checkSourceProductValidity();
    masterProduct=sourceProduct[0];
    slaveProduct=sourceProduct[1];
    mSU=new Sentinel1Utils(masterProduct);
    sSU=new Sentinel1Utils(slaveProduct);
    sSU.computeDopplerRate();
    sSU.computeReferenceTime();
    mOrbit=mSU.getOrbit();
    sOrbit=sSU.getOrbit();
    mSubSwath=mSU.getSubSwath();
    sSubSwath=sSU.getSubSwath();
    final String[] mSubSwathNames=mSU.getSubSwathNames();
    final String[] sSubSwathNames=sSU.getSubSwathNames();
    if (mSubSwathNames.length != 1 || sSubSwathNames.length != 1) {
      throw new OperatorException(""String_Node_Str"");
    }
    if (!mSubSwathNames[0].equals(sSubSwathNames[0])) {
      throw new OperatorException(""String_Node_Str"");
    }
    subSwathName=mSubSwathNames[0];
    subSwathIndex=1;
    swathIndexStr=mSubSwathNames[0].substring(2);
    final String[] mPolarizations=mSU.getPolarizations();
    final String[] sPolarizations=sSU.getPolarizations();
    if (!mPolarizations[0].equals(sPolarizations[0])) {
      throw new OperatorException(""String_Node_Str"");
    }
    polarization=mPolarizations[0];
    if (externalDEMFile == null) {
      DEMFactory.checkIfDEMInstalled(demName);
    }
    DEMFactory.validateDEM(demName,masterProduct);
    selectedResampling=ResamplingFactory.createResampling(resamplingType);
    getMeanTerrainElevation();
    createTargetProduct();
    updateTargetProductMetadata();
    final Band masterBandI=getBand(masterProduct,""String_Node_Str"",swathIndexStr,polarization);
    noDataValue=masterBandI.getNoDataValue();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    if (sourceProduct == null) {
      return;
    }
    checkSourceProductValidity();
    masterProduct=sourceProduct[0];
    slaveProduct=sourceProduct[1];
    mSU=new Sentinel1Utils(masterProduct);
    sSU=new Sentinel1Utils(slaveProduct);
    sSU.computeDopplerRate();
    sSU.computeReferenceTime();
    mOrbit=mSU.getOrbit();
    sOrbit=sSU.getOrbit();
    mSubSwath=mSU.getSubSwath();
    sSubSwath=sSU.getSubSwath();
    final String[] mSubSwathNames=mSU.getSubSwathNames();
    final String[] sSubSwathNames=sSU.getSubSwathNames();
    if (mSubSwathNames.length != 1 || sSubSwathNames.length != 1) {
      throw new OperatorException(""String_Node_Str"");
    }
    if (!mSubSwathNames[0].equals(sSubSwathNames[0])) {
      throw new OperatorException(""String_Node_Str"");
    }
    subSwathName=mSubSwathNames[0];
    subSwathIndex=1;
    swathIndexStr=mSubSwathNames[0].substring(2);
    final String[] mPolarizations=mSU.getPolarizations();
    final String[] sPolarizations=sSU.getPolarizations();
    if (!mPolarizations[0].equals(sPolarizations[0])) {
      throw new OperatorException(""String_Node_Str"");
    }
    polarization=mPolarizations[0];
    if (externalDEMFile == null) {
      DEMFactory.checkIfDEMInstalled(demName);
    }
    DEMFactory.validateDEM(demName,masterProduct);
    selectedResampling=ResamplingFactory.createResampling(resamplingType);
    createTargetProduct();
    updateTargetProductMetadata();
    final Band masterBandI=getBand(masterProduct,""String_Node_Str"",swathIndexStr,polarization);
    noDataValue=masterBandI.getNoDataValue();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11483,"private synchronized void computeBurstOffset() throws Exception {
  if (burstOffsetComputed)   return;
  try {
    final int h=mSubSwath[subSwathIndex - 1].latitude.length;
    final int w=mSubSwath[subSwathIndex - 1].latitude[0].length;
    final PosVector earthPoint=new PosVector();
    for (int i=0; i < h; i++) {
      for (int j=0; j < w; j++) {
        final double lat=mSubSwath[subSwathIndex - 1].latitude[i][j];
        final double lon=mSubSwath[subSwathIndex - 1].longitude[i][j];
        final double alt=dem.getElevation(new GeoPos(lat,lon));
        if (alt == demNoDataValue) {
          continue;
        }
        GeoUtils.geo2xyzWGS84(lat,lon,alt,earthPoint);
        final BurstIndices mBurstIndices=getBurstIndices(subSwathIndex,mSU,mOrbit,earthPoint);
        final BurstIndices sBurstIndices=getBurstIndices(subSwathIndex,sSU,sOrbit,earthPoint);
        if (mBurstIndices == null || sBurstIndices == null || (mBurstIndices.firstBurstIndex == -1 && mBurstIndices.secondBurstIndex == -1) || (sBurstIndices.firstBurstIndex == -1 && sBurstIndices.secondBurstIndex == -1)) {
          continue;
        }
        if (mBurstIndices.inUpperPartOfFirstBurst == sBurstIndices.inUpperPartOfFirstBurst) {
          burstOffset=sBurstIndices.firstBurstIndex - mBurstIndices.firstBurstIndex;
        }
 else         if (sBurstIndices.secondBurstIndex != -1 && mBurstIndices.inUpperPartOfFirstBurst == sBurstIndices.inUpperPartOfSecondBurst) {
          burstOffset=sBurstIndices.secondBurstIndex - mBurstIndices.firstBurstIndex;
        }
 else         if (mBurstIndices.secondBurstIndex != -1 && mBurstIndices.inUpperPartOfSecondBurst == sBurstIndices.inUpperPartOfFirstBurst) {
          burstOffset=sBurstIndices.firstBurstIndex - mBurstIndices.secondBurstIndex;
        }
 else         if (mBurstIndices.secondBurstIndex != -1 && sBurstIndices.secondBurstIndex != -1 && mBurstIndices.inUpperPartOfSecondBurst == sBurstIndices.inUpperPartOfSecondBurst) {
          burstOffset=sBurstIndices.secondBurstIndex - mBurstIndices.secondBurstIndex;
        }
        burstOffsetComputed=true;
        return;
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}","private synchronized void computeBurstOffset() throws Exception {
  if (burstOffsetComputed)   return;
  try {
    final int h=mSubSwath[subSwathIndex - 1].latitude.length;
    final int w=mSubSwath[subSwathIndex - 1].latitude[0].length;
    final PosVector earthPoint=new PosVector();
    for (int i=0; i < h; i++) {
      for (int j=0; j < w; j++) {
        final double lat=mSubSwath[subSwathIndex - 1].latitude[i][j];
        final double lon=mSubSwath[subSwathIndex - 1].longitude[i][j];
        final double alt=dem.getElevation(new GeoPos(lat,lon));
        if (alt == demNoDataValue) {
          continue;
        }
        GeoUtils.geo2xyzWGS84(lat,lon,alt,earthPoint);
        final BurstIndices mBurstIndices=getBurstIndices(subSwathIndex,mSU,mOrbit,earthPoint);
        final BurstIndices sBurstIndices=getBurstIndices(subSwathIndex,sSU,sOrbit,earthPoint);
        if (mBurstIndices == null || sBurstIndices == null || (mBurstIndices.firstBurstIndex == -1 && mBurstIndices.secondBurstIndex == -1) || (sBurstIndices.firstBurstIndex == -1 && sBurstIndices.secondBurstIndex == -1)) {
          continue;
        }
        if (mBurstIndices.inUpperPartOfFirstBurst == sBurstIndices.inUpperPartOfFirstBurst) {
          burstOffset=sBurstIndices.firstBurstIndex - mBurstIndices.firstBurstIndex;
        }
 else         if (sBurstIndices.secondBurstIndex != -1 && mBurstIndices.inUpperPartOfFirstBurst == sBurstIndices.inUpperPartOfSecondBurst) {
          burstOffset=sBurstIndices.secondBurstIndex - mBurstIndices.firstBurstIndex;
        }
 else         if (mBurstIndices.secondBurstIndex != -1 && mBurstIndices.inUpperPartOfSecondBurst == sBurstIndices.inUpperPartOfFirstBurst) {
          burstOffset=sBurstIndices.firstBurstIndex - mBurstIndices.secondBurstIndex;
        }
 else         if (mBurstIndices.secondBurstIndex != -1 && sBurstIndices.secondBurstIndex != -1 && mBurstIndices.inUpperPartOfSecondBurst == sBurstIndices.inUpperPartOfSecondBurst) {
          burstOffset=sBurstIndices.secondBurstIndex - mBurstIndices.secondBurstIndex;
        }
 else {
          continue;
        }
        burstOffsetComputed=true;
        return;
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
}"
11484,"@Override public void actionPerformed(final CommandEvent event){
  final LayerSourceAssistantPane pane=new LayerSourceAssistantPane(VisatApp.getApp().getApplicationWindow(),""String_Node_Str"",getAppContext());
  final LayerSourceDescriptor[] layerSourceDescriptors=BeamUiActivator.getInstance().getLayerSources();
  pane.show(new SelectLayerSourceAssistantPage(layerSourceDescriptors));
}","@Override public void actionPerformed(final CommandEvent event){
  final LayerSourceAssistantPane pane=new LayerSourceAssistantPane(VisatApp.getApp().getApplicationWindow(),""String_Node_Str"");
  final LayerSourceDescriptor[] layerSourceDescriptors=BeamUiActivator.getInstance().getLayerSources();
  pane.show(new SelectLayerSourceAssistantPage(layerSourceDescriptors));
}"
11485,"public Point lph2xyz(final double azTime,final double rgTime,final double height,final Point approxXYZCentre) throws Exception {
  logger.setLevel(Level.OFF);
  Point satellitePosition;
  Point satelliteVelocity;
  Point ellipsoidPosition;
  double[] equationSet=new double[3];
  double[][] partialsXYZ=new double[3][3];
  satellitePosition=getXYZ(azTime);
  satelliteVelocity=getXYZDot(azTime);
  ellipsoidPosition=approxXYZCentre;
  for (int iter=0; iter <= MAXITER; iter++) {
    Point dsat_P=ellipsoidPosition.min(satellitePosition);
    equationSet[0]=-eq1_Doppler(satelliteVelocity,dsat_P);
    equationSet[1]=-eq2_Range(dsat_P,rgTime);
    equationSet[2]=-eq3_Ellipsoid(ellipsoidPosition,height);
    partialsXYZ[0][0]=satelliteVelocity.x;
    partialsXYZ[0][1]=satelliteVelocity.y;
    partialsXYZ[0][2]=satelliteVelocity.z;
    partialsXYZ[1][0]=2 * dsat_P.x;
    partialsXYZ[1][1]=2 * dsat_P.y;
    partialsXYZ[1][2]=2 * dsat_P.z;
    partialsXYZ[2][0]=(2 * ellipsoidPosition.x) / (FastMath.pow(ell_a + height,2));
    partialsXYZ[2][1]=(2 * ellipsoidPosition.y) / (FastMath.pow(ell_a + height,2));
    partialsXYZ[2][2]=(2 * ellipsoidPosition.z) / (FastMath.pow(ell_b + height,2));
    double[] ellipsoidPositionSolution=LinearAlgebraUtils.solve33(partialsXYZ,equationSet);
    ellipsoidPosition.x+=ellipsoidPositionSolution[0];
    ellipsoidPosition.y+=ellipsoidPositionSolution[1];
    ellipsoidPosition.z+=ellipsoidPositionSolution[2];
    logger.fine(""String_Node_Str"" + ellipsoidPosition.x);
    logger.fine(""String_Node_Str"" + ellipsoidPosition.y);
    logger.fine(""String_Node_Str"" + ellipsoidPosition.z);
    if (Math.abs(ellipsoidPositionSolution[0]) < CRITERPOS && Math.abs(ellipsoidPositionSolution[1]) < CRITERPOS && Math.abs(ellipsoidPositionSolution[2]) < CRITERPOS) {
      logger.info(""String_Node_Str"" + ellipsoidPosition + ""String_Node_Str"");
      break;
    }
 else     if (iter >= MAXITER) {
      logger.warning(""String_Node_Str"" + MAXITER + ""String_Node_Str"");
      logger.warning(""String_Node_Str"" + CRITERPOS + ""String_Node_Str""+ ArrayUtils.toString(ellipsoidPositionSolution)+ ""String_Node_Str"");
      if (MAXITER > 10) {
        logger.severe(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  return new Point(ellipsoidPosition);
}","public Point lph2xyz(final double azTime,final double rgTime,final double height,final Point approxXYZCentre) throws Exception {
  logger.setLevel(Level.OFF);
  Point satellitePosition;
  Point satelliteVelocity;
  Point ellipsoidPosition=new Point(approxXYZCentre);
  double[] equationSet=new double[3];
  double[][] partialsXYZ=new double[3][3];
  satellitePosition=getXYZ(azTime);
  satelliteVelocity=getXYZDot(azTime);
  for (int iter=0; iter <= MAXITER; iter++) {
    Point dsat_P=ellipsoidPosition.min(satellitePosition);
    equationSet[0]=-eq1_Doppler(satelliteVelocity,dsat_P);
    equationSet[1]=-eq2_Range(dsat_P,rgTime);
    equationSet[2]=-eq3_Ellipsoid(ellipsoidPosition,height);
    partialsXYZ[0][0]=satelliteVelocity.x;
    partialsXYZ[0][1]=satelliteVelocity.y;
    partialsXYZ[0][2]=satelliteVelocity.z;
    partialsXYZ[1][0]=2 * dsat_P.x;
    partialsXYZ[1][1]=2 * dsat_P.y;
    partialsXYZ[1][2]=2 * dsat_P.z;
    partialsXYZ[2][0]=(2 * ellipsoidPosition.x) / (FastMath.pow(ell_a + height,2));
    partialsXYZ[2][1]=(2 * ellipsoidPosition.y) / (FastMath.pow(ell_a + height,2));
    partialsXYZ[2][2]=(2 * ellipsoidPosition.z) / (FastMath.pow(ell_b + height,2));
    double[] ellipsoidPositionSolution=LinearAlgebraUtils.solve33(partialsXYZ,equationSet);
    ellipsoidPosition.x+=ellipsoidPositionSolution[0];
    ellipsoidPosition.y+=ellipsoidPositionSolution[1];
    ellipsoidPosition.z+=ellipsoidPositionSolution[2];
    logger.fine(""String_Node_Str"" + ellipsoidPosition.x);
    logger.fine(""String_Node_Str"" + ellipsoidPosition.y);
    logger.fine(""String_Node_Str"" + ellipsoidPosition.z);
    if (Math.abs(ellipsoidPositionSolution[0]) < CRITERPOS && Math.abs(ellipsoidPositionSolution[1]) < CRITERPOS && Math.abs(ellipsoidPositionSolution[2]) < CRITERPOS) {
      logger.info(""String_Node_Str"" + ellipsoidPosition + ""String_Node_Str"");
      break;
    }
 else     if (iter >= MAXITER) {
      logger.warning(""String_Node_Str"" + MAXITER + ""String_Node_Str"");
      logger.warning(""String_Node_Str"" + CRITERPOS + ""String_Node_Str""+ ArrayUtils.toString(ellipsoidPositionSolution)+ ""String_Node_Str"");
      if (MAXITER > 10) {
        logger.severe(""String_Node_Str"");
        throw new Exception(""String_Node_Str"");
      }
    }
  }
  return ellipsoidPosition;
}"
11486,"private PixelPos[][] computeSlavePixPos(final int subSwathIndex,final int mBurstIndex,final int sBurstIndex,final int x0,final int y0,final int w,final int h,final double[] tileOverlapPercentage,ProgressMonitor pm) throws Exception {
  try {
    final int xmin=x0;
    final int ymin=Math.max(y0 - (int)(tileSize * tileOverlapPercentage[1]),0);
    final int ymax=y0 + h + (int)(tileSize * Math.abs(tileOverlapPercentage[0]));
    final int xmax=x0 + w;
    final double[] latLonMinMax=new double[4];
    computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
    final double delta=(double)dem.getDescriptor().getDegreeRes() / (double)dem.getDescriptor().getPixelRes();
    final double extralat=2 * delta;
    final double extralon=2 * delta + 4.0 / 25.0;
    final double latMin=latLonMinMax[0] - extralat;
    final double latMax=latLonMinMax[1] + extralat;
    final double lonMin=latLonMinMax[2] - extralon;
    final double lonMax=latLonMinMax[3] + extralon;
    final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
    final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
    final int latMaxIdx=(int)Math.floor(upperLeft.getY());
    final int latMinIdx=(int)Math.ceil(lowerRight.getY());
    final int lonMinIdx=(int)Math.floor(upperLeft.getX());
    final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
    final int numLines=latMinIdx - latMaxIdx;
    final int numPixels=lonMaxIdx - lonMinIdx;
    double[][] masterAz=new double[numLines][numPixels];
    double[][] masterRg=new double[numLines][numPixels];
    double[][] slaveAz=new double[numLines][numPixels];
    double[][] slaveRg=new double[numLines][numPixels];
    final PositionData posData=new PositionData();
    boolean noValidSlavePixPos=true;
    for (int l=0; l < numLines; l++) {
      for (int p=0; p < numPixels; p++) {
        GeoPos gp=dem.getGeoPos(new PixelPos(lonMinIdx + p,latMaxIdx + l));
        final double alt=dem.getElevation(gp);
        if (alt != demNoDataValue) {
          GeoUtils.geo2xyzWGS84(gp.lat,gp.lon,alt,posData.earthPoint);
          if (getPosition(subSwathIndex,mBurstIndex,mSU,mOrbit,posData)) {
            masterAz[l][p]=posData.azimuthIndex;
            masterRg[l][p]=posData.rangeIndex;
            if (getPosition(subSwathIndex,sBurstIndex,sSU,sOrbit,posData)) {
              slaveAz[l][p]=posData.azimuthIndex;
              slaveRg[l][p]=posData.rangeIndex;
              noValidSlavePixPos=false;
              continue;
            }
          }
        }
        masterAz[l][p]=invalidIndex;
        masterRg[l][p]=invalidIndex;
      }
    }
    if (noValidSlavePixPos) {
      return null;
    }
    final org.jlinda.core.Window tileWindow=new org.jlinda.core.Window(y0,y0 + h - 1,x0,x0 + w - 1);
    final double rgAzRatio=mSU.rangeSpacing / mSU.azimuthSpacing;
    final double[][] azArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] rgArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    for (    double[] data : azArray) {
      Arrays.fill(data,invalidIndex);
    }
    for (    double[] data : rgArray) {
      Arrays.fill(data,invalidIndex);
    }
    TriangleUtils.gridDataLinear(masterAz,masterRg,slaveAz,slaveRg,azArray,rgArray,tileWindow,rgAzRatio,1,1,invalidIndex,0);
    boolean allElementsAreNull=true;
    final PixelPos[][] slavePixelPos=new PixelPos[h][w];
    for (int yy=0; yy < h; yy++) {
      for (int xx=0; xx < w; xx++) {
        if (rgArray[yy][xx] == invalidIndex || azArray[yy][xx] == invalidIndex) {
          slavePixelPos[yy][xx]=null;
        }
 else {
          slavePixelPos[yy][xx]=new PixelPos(rgArray[yy][xx],azArray[yy][xx]);
          allElementsAreNull=false;
        }
      }
    }
    if (allElementsAreNull) {
      return null;
    }
    return slavePixelPos;
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
  return null;
}","private PixelPos[][] computeSlavePixPos(final int subSwathIndex,final int mBurstIndex,final int sBurstIndex,final int x0,final int y0,final int w,final int h,final double[] tileOverlapPercentage,ProgressMonitor pm) throws Exception {
  try {
    final int xmin=x0;
    final int ymin=Math.max(y0 - (int)(tileSize * tileOverlapPercentage[1]),0);
    final int ymax=y0 + h + (int)(tileSize * Math.abs(tileOverlapPercentage[0]));
    final int xmax=x0 + w;
    final double[] latLonMinMax=new double[4];
    computeImageGeoBoundary(xmin,xmax,ymin,ymax,latLonMinMax);
    final double delta=(double)dem.getDescriptor().getDegreeRes() / (double)dem.getDescriptor().getPixelRes();
    final double extralat=2 * delta;
    final double extralon=2 * delta + 4.0 / 25.0;
    final double latMin=latLonMinMax[0] - extralat;
    final double latMax=latLonMinMax[1] + extralat;
    final double lonMin=latLonMinMax[2] - extralon;
    final double lonMax=latLonMinMax[3] + extralon;
    final PixelPos upperLeft=dem.getIndex(new GeoPos(latMax,lonMin));
    final PixelPos lowerRight=dem.getIndex(new GeoPos(latMin,lonMax));
    final int latMaxIdx=(int)Math.floor(upperLeft.getY());
    final int latMinIdx=(int)Math.ceil(lowerRight.getY());
    final int lonMinIdx=(int)Math.floor(upperLeft.getX());
    final int lonMaxIdx=(int)Math.ceil(lowerRight.getX());
    final int numLines=latMinIdx - latMaxIdx;
    final int numPixels=lonMaxIdx - lonMinIdx;
    double[][] masterAz=new double[numLines][numPixels];
    double[][] masterRg=new double[numLines][numPixels];
    double[][] slaveAz=new double[numLines][numPixels];
    double[][] slaveRg=new double[numLines][numPixels];
    double[][] lat=new double[numLines][numPixels];
    double[][] lon=new double[numLines][numPixels];
    final PositionData posData=new PositionData();
    boolean noValidSlavePixPos=true;
    for (int l=0; l < numLines; l++) {
      for (int p=0; p < numPixels; p++) {
        GeoPos gp=dem.getGeoPos(new PixelPos(lonMinIdx + p,latMaxIdx + l));
        lat[l][p]=gp.lat;
        lon[l][p]=gp.lon;
        final double alt=dem.getElevation(gp);
        if (alt != demNoDataValue) {
          GeoUtils.geo2xyzWGS84(gp.lat,gp.lon,alt,posData.earthPoint);
          if (getPosition(subSwathIndex,mBurstIndex,mSU,mOrbit,posData)) {
            masterAz[l][p]=posData.azimuthIndex;
            masterRg[l][p]=posData.rangeIndex;
            if (getPosition(subSwathIndex,sBurstIndex,sSU,sOrbit,posData)) {
              slaveAz[l][p]=posData.azimuthIndex;
              slaveRg[l][p]=posData.rangeIndex;
              noValidSlavePixPos=false;
              continue;
            }
          }
        }
        masterAz[l][p]=invalidIndex;
        masterRg[l][p]=invalidIndex;
      }
    }
    if (noValidSlavePixPos) {
      return null;
    }
    final org.jlinda.core.Window tileWindow=new org.jlinda.core.Window(y0,y0 + h - 1,x0,x0 + w - 1);
    final double rgAzRatio=mSU.rangeSpacing / mSU.azimuthSpacing;
    final double[][] latArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] lonArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] azArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    final double[][] rgArray=new double[(int)tileWindow.lines()][(int)tileWindow.pixels()];
    for (    double[] data : azArray) {
      Arrays.fill(data,invalidIndex);
    }
    for (    double[] data : rgArray) {
      Arrays.fill(data,invalidIndex);
    }
    TriangleUtils.gridDataLinear(masterAz,masterRg,slaveAz,slaveRg,lat,lon,azArray,rgArray,latArray,lonArray,tileWindow,rgAzRatio,1,1,invalidIndex,0);
    boolean allElementsAreNull=true;
    final PixelPos[][] slavePixelPos=new PixelPos[h][w];
    for (int yy=0; yy < h; yy++) {
      for (int xx=0; xx < w; xx++) {
        final double alt=dem.getElevation(new GeoPos(latArray[yy][xx],lonArray[yy][xx]));
        if (rgArray[yy][xx] == invalidIndex || azArray[yy][xx] == invalidIndex || alt == demNoDataValue) {
          slavePixelPos[yy][xx]=null;
        }
 else {
          slavePixelPos[yy][xx]=new PixelPos(rgArray[yy][xx],azArray[yy][xx]);
          allElementsAreNull=false;
        }
      }
    }
    if (allElementsAreNull) {
      return null;
    }
    return slavePixelPos;
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(""String_Node_Str"",e);
  }
  return null;
}"
11487,"private static void interpolate(final double xyRatio,final org.jlinda.core.Window tileWindow,final double xScale,final double yScale,final double offset,final double invalidIndex,FastDelaunayTriangulator FDT,final double[][] z1_in,final double[][] z2_in,final double[][] z1_out,final double[][] z2_out){
  final double x_min=tileWindow.linelo;
  final double y_min=tileWindow.pixlo;
  int i, j;
  long i_min, i_max, j_min, j_max;
  double xp, yp;
  double xkj, ykj, xlj, ylj;
  double f;
  double a, b, c;
  double zj, zk, zl, zkj, zlj;
  double[] vx=new double[4];
  double[] vy=new double[4];
  double[] vz=new double[3];
  double[] abc1=new double[3];
  double[] abc2=new double[3];
  final int nx=(int)tileWindow.lines();
  final int ny=(int)tileWindow.pixels();
  for (  Triangle triangle : FDT.triangles) {
    vx[0]=vx[3]=triangle.getA().x;
    vy[0]=vy[3]=triangle.getA().y / xyRatio;
    vx[1]=triangle.getB().x;
    vy[1]=triangle.getB().y / xyRatio;
    vx[2]=triangle.getC().x;
    vy[2]=triangle.getC().y / xyRatio;
    if (vx[0] == invalidIndex || vx[1] == invalidIndex || vx[2] == invalidIndex || vy[0] == invalidIndex || vy[1] == invalidIndex || vy[2] == invalidIndex) {
      continue;
    }
    xp=Math.min(Math.min(vx[0],vx[1]),vx[2]);
    i_min=coordToIndex(xp,x_min,xScale,offset);
    xp=Math.max(Math.max(vx[0],vx[1]),vx[2]);
    i_max=coordToIndex(xp,x_min,xScale,offset);
    yp=Math.min(Math.min(vy[0],vy[1]),vy[2]);
    j_min=coordToIndex(yp,y_min,yScale,offset);
    yp=Math.max(Math.max(vy[0],vy[1]),vy[2]);
    j_max=coordToIndex(yp,y_min,yScale,offset);
    if ((i_max < 0) || (i_min >= nx)) {
      continue;
    }
    if ((j_max < 0) || (j_min >= ny)) {
      continue;
    }
    if (i_min < 0) {
      i_min=0;
    }
    if (i_max >= nx) {
      i_max=nx - 1;
    }
    if (j_min < 0) {
      j_min=0;
    }
    if (j_max >= ny) {
      j_max=ny - 1;
    }
    xkj=vx[1] - vx[0];
    ykj=vy[1] - vy[0];
    xlj=vx[2] - vx[0];
    ylj=vy[2] - vy[0];
    f=1.0 / (xkj * ylj - ykj * xlj);
    vz[0]=triangle.getA().z;
    vz[1]=triangle.getB().z;
    vz[2]=triangle.getC().z;
    abc1=getABC(vx,vy,vz,z1_in,f,xkj,ykj,xlj,ylj);
    abc2=getABC(vx,vy,vz,z2_in,f,xkj,ykj,xlj,ylj);
    for (i=(int)i_min; i <= i_max; i++) {
      xp=indexToCoord(i,x_min,xScale,offset);
      for (j=(int)j_min; j <= j_max; j++) {
        yp=indexToCoord(j,y_min,yScale,offset);
        if (!pointInTriangle(vx,vy,xp,yp)) {
          continue;
        }
        z1_out[i][j]=abc1[0] * xp + abc1[1] * yp + abc1[2];
        z2_out[i][j]=abc2[0] * xp + abc2[1] * yp + abc2[2];
      }
    }
  }
}","private static void interpolate(final double xyRatio,final org.jlinda.core.Window tileWindow,final double xScale,final double yScale,final double offset,final double invalidIndex,FastDelaunayTriangulator FDT,final double[][] z1_in,final double[][] z2_in,final double[][] z3_in,final double[][] z4_in,final double[][] z1_out,final double[][] z2_out,final double[][] z3_out,final double[][] z4_out){
  final double x_min=tileWindow.linelo;
  final double y_min=tileWindow.pixlo;
  int i, j;
  long i_min, i_max, j_min, j_max;
  double xp, yp;
  double xkj, ykj, xlj, ylj;
  double f;
  double a, b, c;
  double zj, zk, zl, zkj, zlj;
  double[] vx=new double[4];
  double[] vy=new double[4];
  double[] vz=new double[3];
  double[] abc1=new double[3];
  double[] abc2=new double[3];
  double[] abc3=new double[3];
  double[] abc4=new double[3];
  final int nx=(int)tileWindow.lines();
  final int ny=(int)tileWindow.pixels();
  for (  Triangle triangle : FDT.triangles) {
    vx[0]=vx[3]=triangle.getA().x;
    vy[0]=vy[3]=triangle.getA().y / xyRatio;
    vx[1]=triangle.getB().x;
    vy[1]=triangle.getB().y / xyRatio;
    vx[2]=triangle.getC().x;
    vy[2]=triangle.getC().y / xyRatio;
    if (vx[0] == invalidIndex || vx[1] == invalidIndex || vx[2] == invalidIndex || vy[0] == invalidIndex || vy[1] == invalidIndex || vy[2] == invalidIndex) {
      continue;
    }
    xp=Math.min(Math.min(vx[0],vx[1]),vx[2]);
    i_min=coordToIndex(xp,x_min,xScale,offset);
    xp=Math.max(Math.max(vx[0],vx[1]),vx[2]);
    i_max=coordToIndex(xp,x_min,xScale,offset);
    yp=Math.min(Math.min(vy[0],vy[1]),vy[2]);
    j_min=coordToIndex(yp,y_min,yScale,offset);
    yp=Math.max(Math.max(vy[0],vy[1]),vy[2]);
    j_max=coordToIndex(yp,y_min,yScale,offset);
    if ((i_max < 0) || (i_min >= nx)) {
      continue;
    }
    if ((j_max < 0) || (j_min >= ny)) {
      continue;
    }
    if (i_min < 0) {
      i_min=0;
    }
    if (i_max >= nx) {
      i_max=nx - 1;
    }
    if (j_min < 0) {
      j_min=0;
    }
    if (j_max >= ny) {
      j_max=ny - 1;
    }
    xkj=vx[1] - vx[0];
    ykj=vy[1] - vy[0];
    xlj=vx[2] - vx[0];
    ylj=vy[2] - vy[0];
    f=1.0 / (xkj * ylj - ykj * xlj);
    vz[0]=triangle.getA().z;
    vz[1]=triangle.getB().z;
    vz[2]=triangle.getC().z;
    abc1=getABC(vx,vy,vz,z1_in,f,xkj,ykj,xlj,ylj);
    abc2=getABC(vx,vy,vz,z2_in,f,xkj,ykj,xlj,ylj);
    abc3=getABC(vx,vy,vz,z3_in,f,xkj,ykj,xlj,ylj);
    abc4=getABC(vx,vy,vz,z4_in,f,xkj,ykj,xlj,ylj);
    for (i=(int)i_min; i <= i_max; i++) {
      xp=indexToCoord(i,x_min,xScale,offset);
      for (j=(int)j_min; j <= j_max; j++) {
        yp=indexToCoord(j,y_min,yScale,offset);
        if (!pointInTriangle(vx,vy,xp,yp)) {
          continue;
        }
        z1_out[i][j]=abc1[0] * xp + abc1[1] * yp + abc1[2];
        z2_out[i][j]=abc2[0] * xp + abc2[1] * yp + abc2[2];
        z3_out[i][j]=abc3[0] * xp + abc3[1] * yp + abc3[2];
        z4_out[i][j]=abc4[0] * xp + abc4[1] * yp + abc4[2];
      }
    }
  }
}"
11488,"public static void gridDataLinear(final double[][] x_in,final double[][] y_in,final double[][] z1_in,final double[][] z2_in,final double[][] z1_out,final double[][] z2_out,final org.jlinda.core.Window window,final double xyRatio,final int xScale,final int yScale,final double invalidIndex,final int offset) throws Exception {
  final FastDelaunayTriangulator FDT=triangulate(x_in,y_in,xyRatio,invalidIndex);
  if (FDT == null) {
    return;
  }
  interpolate(xyRatio,window,xScale,yScale,offset,invalidIndex,FDT,z1_in,z2_in,z1_out,z2_out);
}","public static void gridDataLinear(final double[][] x_in,final double[][] y_in,final double[][] z1_in,final double[][] z2_in,final double[][] z3_in,final double[][] z4_in,final double[][] z1_out,final double[][] z2_out,final double[][] z3_out,final double[][] z4_out,final org.jlinda.core.Window window,final double xyRatio,final int xScale,final int yScale,final double invalidIndex,final int offset) throws Exception {
  final FastDelaunayTriangulator FDT=triangulate(x_in,y_in,xyRatio,invalidIndex);
  if (FDT == null) {
    return;
  }
  interpolate(xyRatio,window,xScale,yScale,offset,invalidIndex,FDT,z1_in,z2_in,z3_in,z4_in,z1_out,z2_out,z3_out,z4_out);
}"
11489,"/** 
 * Generate simulated image for normalization.
 * @param x0             X coordinate of the upper left corner pixel of given tile.
 * @param y0             Y coordinate of the upper left corner pixel of given tile.
 * @param w              Width of given tile.
 * @param h              Height of given tile.
 * @param simulatedImage The simulated image.
 * @return Boolean flag indicating if the simulation is successful.
 */
private boolean generateSimulatedImage(final int x0,final int y0,final int w,final int h,double[][] simulatedImage){
  try {
    int ymin=0;
    int ymax=0;
    if (tileOverlapPercentage >= 0.0f) {
      ymin=Math.max(y0 - (int)(tileSize * tileOverlapPercentage),0);
      ymax=y0 + h;
    }
 else {
      ymin=y0;
      ymax=y0 + h + (int)(tileSize * Math.abs(tileOverlapPercentage));
    }
    final TerrainData terrainData=new TerrainData(w,ymax - ymin);
    final boolean valid=getLocalDEM(x0,ymin,w,ymax - ymin,terrainData);
    if (!valid) {
      return false;
    }
    final double[] earthPoint=new double[3];
    final double[] sensorPos=new double[3];
    for (int y=ymin; y < ymax; y++) {
      final double[] azimuthIndex=new double[w];
      final double[] rangeIndex=new double[w];
      final double[] illuminatedArea=new double[w];
      final double[] elevationAngle=new double[w];
      final boolean[] savePixel=new boolean[w];
      for (int x=x0; x < x0 + w; x++) {
        final int i=x - x0;
        final int xx=x - x0 + 1;
        final int yy=y - ymin + 1;
        final double alt=terrainData.localDEM[yy][xx];
        if (alt == demNoDataValue) {
          savePixel[i]=false;
          continue;
        }
        GeoUtils.geo2xyzWGS84(terrainData.latPixels[yy][xx],terrainData.lonPixels[yy][xx],alt,earthPoint);
        final double zeroDopplerTime=SARGeocoding.getEarthPointZeroDopplerTime(firstLineUTC,lineTimeInterval,wavelength,earthPoint,orbit.sensorPosition,orbit.sensorVelocity);
        double slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        final double zeroDopplerTimeWithoutBias=zeroDopplerTime + slantRange / Constants.lightSpeedInMetersPerDay;
        azimuthIndex[i]=(zeroDopplerTimeWithoutBias - firstLineUTC) / lineTimeInterval;
        slantRange=SARGeocoding.computeSlantRange(zeroDopplerTimeWithoutBias,orbit,earthPoint,sensorPos);
        rangeIndex[i]=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDopplerTimeWithoutBias,slantRange,nearEdgeSlantRange,srgrConvParams);
        if (rangeIndex[i] <= 0.0) {
          continue;
        }
        if (!nearRangeOnLeft) {
          rangeIndex[i]=sourceImageWidth - 1 - rangeIndex[i];
        }
        final LocalGeometry localGeometry=new LocalGeometry(x,y,earthPoint,sensorPos,terrainData,xx,yy);
        illuminatedArea[i]=computeLocalIlluminatedArea(x0,ymin,x,y,localGeometry,terrainData.localDEM,demNoDataValue);
        if (illuminatedArea[i] == noDataValue) {
          savePixel[i]=false;
          continue;
        }
        elevationAngle[i]=computeElevationAngle(slantRange,earthPoint,sensorPos);
        savePixel[i]=rangeIndex[i] >= x0 && rangeIndex[i] < x0 + w && azimuthIndex[i] > y0 - 1 && azimuthIndex[i] < y0 + h;
      }
      if (nearRangeOnLeft) {
        double maxElevAngle=0.0;
        for (int x=x0; x < x0 + w; x++) {
          int i=x - x0;
          if (savePixel[i] && elevationAngle[i] > maxElevAngle) {
            maxElevAngle=elevationAngle[i];
            saveLocalIlluminatedArea(x0,y0,w,h,illuminatedArea[i],azimuthIndex[i],rangeIndex[i],simulatedImage);
          }
        }
      }
 else {
        double maxElevAngle=0.0;
        for (int x=x0 + w - 1; x >= x0; x--) {
          int i=x - x0;
          if (savePixel[i] && elevationAngle[i] > maxElevAngle) {
            maxElevAngle=elevationAngle[i];
            saveLocalIlluminatedArea(x0,y0,w,h,illuminatedArea[i],azimuthIndex[i],rangeIndex[i],simulatedImage);
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
  return true;
}","/** 
 * Generate simulated image for normalization.
 * @param x0             X coordinate of the upper left corner pixel of given tile.
 * @param y0             Y coordinate of the upper left corner pixel of given tile.
 * @param w              Width of given tile.
 * @param h              Height of given tile.
 * @param simulatedImage The simulated image.
 * @return Boolean flag indicating if the simulation is successful.
 */
private boolean generateSimulatedImage(final int x0,final int y0,final int w,final int h,double[][] simulatedImage){
  try {
    int ymin=0;
    int ymax=0;
    if (tileOverlapPercentage >= 0.0f) {
      ymin=Math.max(y0 - (int)(tileSize * tileOverlapPercentage),0);
      ymax=y0 + h;
    }
 else {
      ymin=y0;
      ymax=y0 + h + (int)(tileSize * Math.abs(tileOverlapPercentage));
    }
    final TerrainData terrainData=new TerrainData(w,ymax - ymin);
    final boolean valid=getLocalDEM(x0,ymin,w,ymax - ymin,terrainData);
    if (!valid) {
      return false;
    }
    final double[] earthPoint=new double[3];
    final double[] sensorPos=new double[3];
    for (int y=ymin; y < ymax; y++) {
      final double[] azimuthIndex=new double[w];
      final double[] rangeIndex=new double[w];
      final double[] illuminatedArea=new double[w];
      final double[] elevationAngle=new double[w];
      final boolean[] savePixel=new boolean[w];
      for (int x=x0; x < x0 + w; x++) {
        final int i=x - x0;
        final int xx=x - x0 + 1;
        final int yy=y - ymin + 1;
        final double alt=terrainData.localDEM[yy][xx];
        if (alt == demNoDataValue) {
          savePixel[i]=false;
          continue;
        }
        GeoUtils.geo2xyzWGS84(terrainData.latPixels[yy][xx],terrainData.lonPixels[yy][xx],alt,earthPoint);
        final double zeroDopplerTime=SARGeocoding.getEarthPointZeroDopplerTime(firstLineUTC,lineTimeInterval,wavelength,earthPoint,orbit.sensorPosition,orbit.sensorVelocity);
        double slantRange=SARGeocoding.computeSlantRange(zeroDopplerTime,orbit,earthPoint,sensorPos);
        final double zeroDopplerTimeWithoutBias=zeroDopplerTime + slantRange / Constants.lightSpeedInMetersPerDay;
        azimuthIndex[i]=(zeroDopplerTimeWithoutBias - firstLineUTC) / lineTimeInterval;
        slantRange=SARGeocoding.computeSlantRange(zeroDopplerTimeWithoutBias,orbit,earthPoint,sensorPos);
        rangeIndex[i]=SARGeocoding.computeRangeIndex(srgrFlag,sourceImageWidth,firstLineUTC,lastLineUTC,rangeSpacing,zeroDopplerTimeWithoutBias,slantRange,nearEdgeSlantRange,srgrConvParams);
        if (rangeIndex[i] <= 0.0) {
          continue;
        }
        if (!nearRangeOnLeft) {
          rangeIndex[i]=sourceImageWidth - 1 - rangeIndex[i];
        }
        final LocalGeometry localGeometry=new LocalGeometry(earthPoint,sensorPos,terrainData,xx,yy);
        illuminatedArea[i]=computeLocalIlluminatedArea(x0,ymin,x,y,localGeometry,terrainData.localDEM,demNoDataValue);
        if (illuminatedArea[i] == noDataValue) {
          savePixel[i]=false;
          continue;
        }
        elevationAngle[i]=computeElevationAngle(slantRange,earthPoint,sensorPos);
        savePixel[i]=rangeIndex[i] >= x0 && rangeIndex[i] < x0 + w && azimuthIndex[i] > y0 - 1 && azimuthIndex[i] < y0 + h;
      }
      if (nearRangeOnLeft) {
        double maxElevAngle=0.0;
        for (int x=x0; x < x0 + w; x++) {
          int i=x - x0;
          if (savePixel[i] && elevationAngle[i] > maxElevAngle) {
            maxElevAngle=elevationAngle[i];
            saveLocalIlluminatedArea(x0,y0,w,h,illuminatedArea[i],azimuthIndex[i],rangeIndex[i],simulatedImage);
          }
        }
      }
 else {
        double maxElevAngle=0.0;
        for (int x=x0 + w - 1; x >= x0; x--) {
          int i=x - x0;
          if (savePixel[i] && elevationAngle[i] > maxElevAngle) {
            maxElevAngle=elevationAngle[i];
            saveLocalIlluminatedArea(x0,y0,w,h,illuminatedArea[i],azimuthIndex[i],rangeIndex[i],simulatedImage);
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
  return true;
}"
11490,"public LocalGeometry(final int x,final int y,final double[] earthPoint,final double[] sensPos,final TerrainData terrainData,final int xx,final int yy){
  t00Lat=terrainData.latPixels[yy][xx];
  t00Lon=terrainData.lonPixels[yy][xx];
  t01Lat=terrainData.latPixels[yy - 1][xx];
  t01Lon=terrainData.lonPixels[yy - 1][xx];
  t10Lat=terrainData.latPixels[yy][xx + 1];
  t10Lon=terrainData.lonPixels[yy][xx + 1];
  t11Lat=terrainData.latPixels[yy + 1][xx + 1];
  t11Lon=terrainData.lonPixels[yy + 1][xx + 1];
  centerPoint=earthPoint;
  sensorPos=sensPos;
}","public LocalGeometry(final double[] earthPoint,final double[] sensPos,final TerrainData terrainData,final int xx,final int yy){
  t00Lat=terrainData.latPixels[yy][xx];
  t00Lon=terrainData.lonPixels[yy][xx];
  t00Height=terrainData.localDEM[yy][xx];
  t01Lat=terrainData.latPixels[yy - 1][xx];
  t01Lon=terrainData.lonPixels[yy - 1][xx];
  t01Height=terrainData.localDEM[yy - 1][xx];
  t10Lat=terrainData.latPixels[yy][xx + 1];
  t10Lon=terrainData.lonPixels[yy][xx + 1];
  t10Height=terrainData.localDEM[yy][xx + 1];
  t11Lat=terrainData.latPixels[yy - 1][xx + 1];
  t11Lon=terrainData.lonPixels[yy - 1][xx + 1];
  t11Height=terrainData.localDEM[yy - 1][xx + 1];
  centerPoint=earthPoint;
  sensorPos=sensPos;
}"
11491,"/** 
 * Compute local illuminated area for given point.
 * @param xMin           Start of the simulated area in range direction.
 * @param yMin           Start of the simulated area in azimuth direction.
 * @param x              X coordinate of given point.
 * @param y              Y coordinate of given point.
 * @param lg             Local geometry information.
 * @param localDEM       The digital elevation model.
 * @param demNoDataValue Invalid DEM value.
 * @return The computed local illuminated area.
 */
private double computeLocalIlluminatedArea(final int xMin,final int yMin,final int x,final int y,final LocalGeometry lg,final double[][] localDEM,final double demNoDataValue){
  final int yy=y - yMin + 1;
  final int xx=x - xMin + 1;
  final double h00=localDEM[yy][xx];
  final double h01=localDEM[yy - 1][xx];
  final double h10=localDEM[yy][xx + 1];
  final double h11=localDEM[yy - 1][xx + 1];
  if (h00 == demNoDataValue || h01 == demNoDataValue || h10 == demNoDataValue || h11 == demNoDataValue) {
    return noDataValue;
  }
  final double[] t00=new double[3];
  final double[] t01=new double[3];
  final double[] t10=new double[3];
  final double[] t11=new double[3];
  GeoUtils.geo2xyzWGS84(lg.t00Lat,lg.t00Lon,h00,t00);
  GeoUtils.geo2xyzWGS84(lg.t01Lat,lg.t01Lon,h01,t01);
  GeoUtils.geo2xyzWGS84(lg.t10Lat,lg.t10Lon,h10,t10);
  GeoUtils.geo2xyzWGS84(lg.t11Lat,lg.t11Lon,h11,t11);
  final double[] s={lg.sensorPos[0] - lg.centerPoint[0],lg.sensorPos[1] - lg.centerPoint[1],lg.sensorPos[2] - lg.centerPoint[2]};
  Maths.normalizeVector(s);
  final double t00s=Maths.innerProduct(t00,s);
  final double t01s=Maths.innerProduct(t01,s);
  final double t10s=Maths.innerProduct(t10,s);
  final double t11s=Maths.innerProduct(t11,s);
  final double[] p00={t00[0] - t00s * s[0],t00[1] - t00s * s[1],t00[2] - t00s * s[2]};
  final double[] p01={t01[0] - t01s * s[0],t01[1] - t01s * s[1],t01[2] - t01s * s[2]};
  final double[] p10={t10[0] - t10s * s[0],t10[1] - t10s * s[1],t10[2] - t10s * s[2]};
  final double[] p11={t11[0] - t11s * s[0],t11[1] - t11s * s[1],t11[2] - t11s * s[2]};
  final double p00p01=distance(p00,p01);
  final double p00p10=distance(p00,p10);
  final double p11p01=distance(p11,p01);
  final double p11p10=distance(p11,p10);
  final double p10p01=distance(p10,p01);
  final double h1=0.5 * (p00p01 + p00p10 + p10p01);
  final double h2=0.5 * (p11p01 + p11p10 + p10p01);
  return Math.sqrt(h1 * (h1 - p00p01) * (h1 - p00p10)* (h1 - p10p01)) + Math.sqrt(h2 * (h2 - p11p01) * (h2 - p11p10)* (h2 - p10p01));
}","/** 
 * Compute local illuminated area for given point.
 * @param xMin           Start of the simulated area in range direction.
 * @param yMin           Start of the simulated area in azimuth direction.
 * @param x              X coordinate of given point.
 * @param y              Y coordinate of given point.
 * @param lg             Local geometry information.
 * @param localDEM       The digital elevation model.
 * @param demNoDataValue Invalid DEM value.
 * @return The computed local illuminated area.
 */
private double computeLocalIlluminatedArea(final int xMin,final int yMin,final int x,final int y,final LocalGeometry lg,final double[][] localDEM,final double demNoDataValue){
  if (lg.t00Height == demNoDataValue || lg.t01Height == demNoDataValue || lg.t10Height == demNoDataValue || lg.t11Height == demNoDataValue) {
    return noDataValue;
  }
  final double[] t00=new double[3];
  final double[] t01=new double[3];
  final double[] t10=new double[3];
  final double[] t11=new double[3];
  GeoUtils.geo2xyzWGS84(lg.t00Lat,lg.t00Lon,lg.t00Height,t00);
  GeoUtils.geo2xyzWGS84(lg.t01Lat,lg.t01Lon,lg.t01Height,t01);
  GeoUtils.geo2xyzWGS84(lg.t10Lat,lg.t10Lon,lg.t10Height,t10);
  GeoUtils.geo2xyzWGS84(lg.t11Lat,lg.t11Lon,lg.t11Height,t11);
  final double[] s={lg.sensorPos[0] - lg.centerPoint[0],lg.sensorPos[1] - lg.centerPoint[1],lg.sensorPos[2] - lg.centerPoint[2]};
  Maths.normalizeVector(s);
  final double t00s=Maths.innerProduct(t00,s);
  final double t01s=Maths.innerProduct(t01,s);
  final double t10s=Maths.innerProduct(t10,s);
  final double t11s=Maths.innerProduct(t11,s);
  final double[] p00={t00[0] - t00s * s[0],t00[1] - t00s * s[1],t00[2] - t00s * s[2]};
  final double[] p01={t01[0] - t01s * s[0],t01[1] - t01s * s[1],t01[2] - t01s * s[2]};
  final double[] p10={t10[0] - t10s * s[0],t10[1] - t10s * s[1],t10[2] - t10s * s[2]};
  final double[] p11={t11[0] - t11s * s[0],t11[1] - t11s * s[1],t11[2] - t11s * s[2]};
  final double p00p01=distance(p00,p01);
  final double p00p10=distance(p00,p10);
  final double p11p01=distance(p11,p01);
  final double p11p10=distance(p11,p10);
  final double p10p01=distance(p10,p01);
  final double h1=0.5 * (p00p01 + p00p10 + p10p01);
  final double h2=0.5 * (p11p01 + p11p10 + p10p01);
  return Math.sqrt(h1 * (h1 - p00p01) * (h1 - p00p10)* (h1 - p10p01)) + Math.sqrt(h2 * (h2 - p11p01) * (h2 - p11p10)* (h2 - p10p01));
}"
11492,"public double ta2line(double azitime){
  return 1.0 + PRF * (azitime - tAzi1);
}","public double ta2line(double azitime){
  return (azitime - tAzi1) / lineTimeInterval;
}"
11493,"public SLCImage(MetadataElement element){
  this();
  this.sensor=element.getAttributeString(AbstractMetadata.MISSION);
  this.mission=sensor;
  this.orbitNumber=element.getAttributeInt(AbstractMetadata.REL_ORBIT);
  this.radar_wavelength=(LIGHT_SPEED / MEGA) / element.getAttributeDouble(AbstractMetadata.radar_frequency);
  this.PRF=element.getAttributeDouble(AbstractMetadata.pulse_repetition_frequency);
  final String t_azi1_UTC=element.getAttributeUTC(AbstractMetadata.first_line_time).toString();
  this.mjd=element.getAttributeUTC(AbstractMetadata.first_line_time).getMJD();
  this.tAzi1=DateUtils.dateTimeToSecOfDay(t_azi1_UTC);
  this.rangeBandwidth=element.getAttributeDouble(AbstractMetadata.range_bandwidth);
  this.azimuthBandwidth=element.getAttributeDouble(AbstractMetadata.azimuth_bandwidth);
  this.rsr2x=(element.getAttributeDouble(AbstractMetadata.range_sampling_rate) * MEGA * 2);
  this.tRange1=element.getAttributeDouble(AbstractMetadata.slant_range_to_first_pixel) / LIGHT_SPEED;
  this.approxRadarCentreOriginal.x=element.getAttributeDouble(AbstractMetadata.num_samples_per_line) / 2.0d;
  this.approxRadarCentreOriginal.y=element.getAttributeDouble(AbstractMetadata.num_output_lines) / 2.0d;
  this.approxGeoCentreOriginal.lat=(float)((element.getAttributeDouble(AbstractMetadata.first_near_lat) + element.getAttributeDouble(AbstractMetadata.first_far_lat) + element.getAttributeDouble(AbstractMetadata.last_near_lat)+ element.getAttributeDouble(AbstractMetadata.last_far_lat)) / 4);
  this.approxGeoCentreOriginal.lon=(float)((element.getAttributeDouble(AbstractMetadata.first_near_long) + element.getAttributeDouble(AbstractMetadata.first_far_long) + element.getAttributeDouble(AbstractMetadata.last_near_long)+ element.getAttributeDouble(AbstractMetadata.last_far_long)) / 4);
  final double[] xyz=new double[3];
  Ellipsoid.ell2xyz(getApproxGeoCentreOriginal(),xyz);
  this.approxXYZCentreOriginal.x=xyz[0];
  this.approxXYZCentreOriginal.y=xyz[1];
  this.approxXYZCentreOriginal.z=xyz[2];
  final int pix0=element.getAttributeInt(AbstractMetadata.subset_offset_x);
  final int pixN=pix0 + element.getAttributeInt(AbstractMetadata.num_samples_per_line);
  final int lin0=element.getAttributeInt(AbstractMetadata.subset_offset_y);
  final int linN=lin0 + element.getAttributeInt(AbstractMetadata.num_output_lines);
  this.currentWindow=new Window(lin0,linN,pix0,pixN);
  final AbstractMetadata.DopplerCentroidCoefficientList[] dopplersArray=AbstractMetadata.getDopplerCentroidCoefficients(element);
  final String t_azi_original=dopplersArray[0].time.toString();
  this.tAzi_original=DateUtils.dateTimeToSecOfDay(t_azi_original);
  if (dopplersArray[0].coefficients.length > 0)   this.doppler.f_DC_a0=dopplersArray[0].coefficients[0];
  if (dopplersArray[0].coefficients.length > 1)   this.doppler.f_DC_a1=dopplersArray[0].coefficients[1];
  if (dopplersArray[0].coefficients.length > 2)   this.doppler.f_DC_a2=dopplersArray[0].coefficients[2];
  this.doppler.checkConstant();
  this.mlAz=(int)element.getAttributeDouble(AbstractMetadata.azimuth_looks);
  this.mlRg=(int)element.getAttributeDouble(AbstractMetadata.range_looks);
}","public SLCImage(MetadataElement element){
  this();
  this.sensor=element.getAttributeString(AbstractMetadata.MISSION);
  this.mission=sensor;
  this.orbitNumber=element.getAttributeInt(AbstractMetadata.REL_ORBIT);
  this.radar_wavelength=(LIGHT_SPEED / MEGA) / element.getAttributeDouble(AbstractMetadata.radar_frequency);
  this.PRF=element.getAttributeDouble(AbstractMetadata.pulse_repetition_frequency);
  final String t_azi1_UTC=element.getAttributeUTC(AbstractMetadata.first_line_time).toString();
  this.mjd=element.getAttributeUTC(AbstractMetadata.first_line_time).getMJD();
  this.tAzi1=DateUtils.dateTimeToSecOfDay(t_azi1_UTC);
  this.lineTimeInterval=element.getAttributeDouble(AbstractMetadata.line_time_interval);
  this.rangeBandwidth=element.getAttributeDouble(AbstractMetadata.range_bandwidth);
  this.azimuthBandwidth=element.getAttributeDouble(AbstractMetadata.azimuth_bandwidth);
  this.rsr2x=(element.getAttributeDouble(AbstractMetadata.range_sampling_rate) * MEGA * 2);
  this.tRange1=element.getAttributeDouble(AbstractMetadata.slant_range_to_first_pixel) / LIGHT_SPEED;
  this.approxRadarCentreOriginal.x=element.getAttributeDouble(AbstractMetadata.num_samples_per_line) / 2.0d;
  this.approxRadarCentreOriginal.y=element.getAttributeDouble(AbstractMetadata.num_output_lines) / 2.0d;
  this.approxGeoCentreOriginal.lat=(float)((element.getAttributeDouble(AbstractMetadata.first_near_lat) + element.getAttributeDouble(AbstractMetadata.first_far_lat) + element.getAttributeDouble(AbstractMetadata.last_near_lat)+ element.getAttributeDouble(AbstractMetadata.last_far_lat)) / 4);
  this.approxGeoCentreOriginal.lon=(float)((element.getAttributeDouble(AbstractMetadata.first_near_long) + element.getAttributeDouble(AbstractMetadata.first_far_long) + element.getAttributeDouble(AbstractMetadata.last_near_long)+ element.getAttributeDouble(AbstractMetadata.last_far_long)) / 4);
  final double[] xyz=new double[3];
  Ellipsoid.ell2xyz(getApproxGeoCentreOriginal(),xyz);
  this.approxXYZCentreOriginal.x=xyz[0];
  this.approxXYZCentreOriginal.y=xyz[1];
  this.approxXYZCentreOriginal.z=xyz[2];
  final int pix0=element.getAttributeInt(AbstractMetadata.subset_offset_x);
  final int pixN=pix0 + element.getAttributeInt(AbstractMetadata.num_samples_per_line);
  final int lin0=element.getAttributeInt(AbstractMetadata.subset_offset_y);
  final int linN=lin0 + element.getAttributeInt(AbstractMetadata.num_output_lines);
  this.currentWindow=new Window(lin0,linN,pix0,pixN);
  final AbstractMetadata.DopplerCentroidCoefficientList[] dopplersArray=AbstractMetadata.getDopplerCentroidCoefficients(element);
  final String t_azi_original=dopplersArray[0].time.toString();
  this.tAzi_original=DateUtils.dateTimeToSecOfDay(t_azi_original);
  if (dopplersArray[0].coefficients.length > 0)   this.doppler.f_DC_a0=dopplersArray[0].coefficients[0];
  if (dopplersArray[0].coefficients.length > 1)   this.doppler.f_DC_a1=dopplersArray[0].coefficients[1];
  if (dopplersArray[0].coefficients.length > 2)   this.doppler.f_DC_a2=dopplersArray[0].coefficients[2];
  this.doppler.checkConstant();
  this.mlAz=(int)element.getAttributeDouble(AbstractMetadata.azimuth_looks);
  this.mlRg=(int)element.getAttributeDouble(AbstractMetadata.range_looks);
}"
11494,"public double line2ta(double line){
  return tAzi1 + ((line - 1.0) / PRF);
}","public double line2ta(double line){
  return tAzi1 + (line * lineTimeInterval);
}"
11495,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTileMap   The target tiles associated with all target bands to be computed.
 * @param targetRectangle The rectangle of target tile.
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTileMap,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    int y0=targetRectangle.y;
    int yN=y0 + targetRectangle.height - 1;
    int x0=targetRectangle.x;
    int xN=targetRectangle.x + targetRectangle.width - 1;
    final Window tileWindow=new Window(y0,yN,x0,xN);
    Band topoPhaseBand;
    Band targetBand_I;
    Band targetBand_Q;
    for (    String ifgKey : targetMap.keySet()) {
      ProductContainer product=targetMap.get(ifgKey);
      GeoPoint[] geoCorners=GeoUtils.computeCorners(product.sourceMaster.metaData,product.sourceMaster.orbit,tileWindow);
      PixelPos[] pixelCorners=new PixelPos[2];
      pixelCorners[0]=dem.getIndex(new GeoPos(geoCorners[0].lat,geoCorners[0].lon));
      pixelCorners[1]=dem.getIndex(new GeoPos(geoCorners[1].lat,geoCorners[1].lon));
      double[] tileHeights=computeMaxHeight(pixelCorners,targetRectangle);
      GeoPoint geoExtent=GeoUtils.defineExtraPhiLam(tileHeights[0],tileHeights[1],tileWindow,product.sourceMaster.metaData,product.sourceMaster.orbit);
      geoCorners=GeoUtils.extendCorners(geoExtent,geoCorners);
      pixelCorners[0]=dem.getIndex(new GeoPos(geoCorners[0].lat,geoCorners[0].lon));
      pixelCorners[1]=dem.getIndex(new GeoPos(geoCorners[1].lat,geoCorners[1].lon));
      pixelCorners[0]=new PixelPos(Math.ceil(pixelCorners[0].x),Math.floor(pixelCorners[0].y));
      pixelCorners[1]=new PixelPos(Math.floor(pixelCorners[1].x),Math.ceil(pixelCorners[1].y));
      GeoPos upperLeftGeo=dem.getGeoPos(pixelCorners[0]);
      int nLatPixels=(int)Math.abs(pixelCorners[1].y - pixelCorners[0].y);
      int nLonPixels=(int)Math.abs(pixelCorners[1].x - pixelCorners[0].x);
      int startX=(int)pixelCorners[0].x;
      int endX=startX + nLonPixels;
      int startY=(int)pixelCorners[0].y;
      int endY=startY + nLatPixels;
      double[][] elevation=new double[nLatPixels][nLonPixels];
      for (int y=startY, i=0; y < endY; y++, i++) {
        for (int x=startX, j=0; x < endX; x++, j++) {
          try {
            double elev=dem.getSample(x,y);
            if (Double.isNaN(elev))             elev=demNoDataValue;
            elevation[i][j]=elev;
          }
 catch (          Exception e) {
            elevation[i][j]=demNoDataValue;
          }
        }
      }
      DemTile demTile=new DemTile(upperLeftGeo.lat * Constants.DTOR,upperLeftGeo.lon * Constants.DTOR,nLatPixels,nLonPixels,Math.abs(demSamplingLat),Math.abs(demSamplingLon),(long)demNoDataValue);
      demTile.setData(elevation);
      final TopoPhase topoPhase=new TopoPhase(product.sourceMaster.metaData,product.sourceMaster.orbit,product.sourceSlave.metaData,product.sourceSlave.orbit,tileWindow,demTile);
      topoPhase.radarCode();
      topoPhase.gridData();
      Tile tileReal=getSourceTile(product.sourceMaster.realBand,targetRectangle);
      Tile tileImag=getSourceTile(product.sourceMaster.imagBand,targetRectangle);
      ComplexDoubleMatrix complexIfg=TileUtilsDoris.pullComplexDoubleMatrix(tileReal,tileImag);
      final ComplexDoubleMatrix cplxTopoPhase=new ComplexDoubleMatrix(MatrixFunctions.cos(new DoubleMatrix(topoPhase.demPhase)),MatrixFunctions.sin(new DoubleMatrix(topoPhase.demPhase)));
      complexIfg.muli(cplxTopoPhase.conji());
      targetBand_I=targetProduct.getBand(product.targetBandName_I);
      Tile tileOutReal=targetTileMap.get(targetBand_I);
      TileUtilsDoris.pushDoubleMatrix(complexIfg.real(),tileOutReal,targetRectangle);
      targetBand_Q=targetProduct.getBand(product.targetBandName_Q);
      Tile tileOutImag=targetTileMap.get(targetBand_Q);
      TileUtilsDoris.pushDoubleMatrix(complexIfg.imag(),tileOutImag,targetRectangle);
      topoPhaseBand=targetProduct.getBand(product.masterSubProduct.targetBandName_I);
      Tile tileOutTopoPhase=targetTileMap.get(topoPhaseBand);
      TileUtilsDoris.pushDoubleArray2D(topoPhase.demPhase,tileOutTopoPhase,targetRectangle);
    }
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTileMap   The target tiles associated with all target bands to be computed.
 * @param targetRectangle The rectangle of target tile.
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTileMap,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    int y0=targetRectangle.y;
    int yN=y0 + targetRectangle.height - 1;
    int x0=targetRectangle.x;
    int xN=targetRectangle.x + targetRectangle.width - 1;
    final Window tileWindow=new Window(y0,yN,x0,xN);
    Band topoPhaseBand;
    Band targetBand_I;
    Band targetBand_Q;
    for (    String ifgKey : targetMap.keySet()) {
      ProductContainer product=targetMap.get(ifgKey);
      GeoPoint[] geoCorners=GeoUtils.computeCorners(product.sourceMaster.metaData,product.sourceMaster.orbit,tileWindow);
      PixelPos[] pixelCorners=new PixelPos[2];
      pixelCorners[0]=dem.getIndex(new GeoPos(geoCorners[0].lat,geoCorners[0].lon));
      pixelCorners[1]=dem.getIndex(new GeoPos(geoCorners[1].lat,geoCorners[1].lon));
      final int x0DEM=(int)Math.round(pixelCorners[0].x);
      final int y0DEM=(int)Math.round(pixelCorners[0].y);
      final int x1DEM=(int)Math.round(pixelCorners[1].x);
      final int y1DEM=(int)Math.round(pixelCorners[1].y);
      final Rectangle demTileRect=new Rectangle(x0DEM,y0DEM,x1DEM - x0DEM + 1,y1DEM - y0DEM + 1);
      double[] tileHeights=computeMaxHeight(pixelCorners,demTileRect);
      GeoPoint geoExtent=GeoUtils.defineExtraPhiLam(tileHeights[0],tileHeights[1],tileWindow,product.sourceMaster.metaData,product.sourceMaster.orbit);
      geoCorners=GeoUtils.extendCorners(geoExtent,geoCorners);
      pixelCorners[0]=dem.getIndex(new GeoPos(geoCorners[0].lat,geoCorners[0].lon));
      pixelCorners[1]=dem.getIndex(new GeoPos(geoCorners[1].lat,geoCorners[1].lon));
      pixelCorners[0]=new PixelPos(Math.floor(pixelCorners[0].x),Math.floor(pixelCorners[0].y));
      pixelCorners[1]=new PixelPos(Math.ceil(pixelCorners[1].x),Math.ceil(pixelCorners[1].y));
      GeoPos upperLeftGeo=dem.getGeoPos(pixelCorners[0]);
      int nLatPixels=(int)Math.abs(pixelCorners[1].y - pixelCorners[0].y);
      int nLonPixels=(int)Math.abs(pixelCorners[1].x - pixelCorners[0].x);
      int startX=(int)pixelCorners[0].x;
      int endX=startX + nLonPixels;
      int startY=(int)pixelCorners[0].y;
      int endY=startY + nLatPixels;
      double[][] elevation=new double[nLatPixels][nLonPixels];
      for (int y=startY, i=0; y < endY; y++, i++) {
        for (int x=startX, j=0; x < endX; x++, j++) {
          try {
            double elev=dem.getSample(x,y);
            if (Double.isNaN(elev)) {
              elev=demNoDataValue;
            }
            elevation[i][j]=elev;
          }
 catch (          Exception e) {
            elevation[i][j]=demNoDataValue;
          }
        }
      }
      DemTile demTile=new DemTile(upperLeftGeo.lat * Constants.DTOR,upperLeftGeo.lon * Constants.DTOR,nLatPixels,nLonPixels,Math.abs(demSamplingLat),Math.abs(demSamplingLon),(long)demNoDataValue);
      demTile.setData(elevation);
      final TopoPhase topoPhase=new TopoPhase(product.sourceMaster.metaData,product.sourceMaster.orbit,product.sourceSlave.metaData,product.sourceSlave.orbit,tileWindow,demTile);
      topoPhase.radarCode();
      topoPhase.gridData();
      Tile tileReal=getSourceTile(product.sourceMaster.realBand,targetRectangle);
      Tile tileImag=getSourceTile(product.sourceMaster.imagBand,targetRectangle);
      ComplexDoubleMatrix complexIfg=TileUtilsDoris.pullComplexDoubleMatrix(tileReal,tileImag);
      final ComplexDoubleMatrix cplxTopoPhase=new ComplexDoubleMatrix(MatrixFunctions.cos(new DoubleMatrix(topoPhase.demPhase)),MatrixFunctions.sin(new DoubleMatrix(topoPhase.demPhase)));
      complexIfg.muli(cplxTopoPhase.conji());
      targetBand_I=targetProduct.getBand(product.targetBandName_I);
      Tile tileOutReal=targetTileMap.get(targetBand_I);
      TileUtilsDoris.pushDoubleMatrix(complexIfg.real(),tileOutReal,targetRectangle);
      targetBand_Q=targetProduct.getBand(product.targetBandName_Q);
      Tile tileOutImag=targetTileMap.get(targetBand_Q);
      TileUtilsDoris.pushDoubleMatrix(complexIfg.imag(),tileOutImag,targetRectangle);
      topoPhaseBand=targetProduct.getBand(product.masterSubProduct.targetBandName_I);
      Tile tileOutTopoPhase=targetTileMap.get(topoPhaseBand);
      TileUtilsDoris.pushDoubleArray2D(topoPhase.demPhase,tileOutTopoPhase,targetRectangle);
    }
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
}"
11496,"private double[] computeMaxHeight(PixelPos[] corners,Rectangle rectangle) throws Exception {
  final float extraTileX=(float)(1 + tileExtensionPercent / 100);
  final float extraTileY=(float)(1 + tileExtensionPercent / 100);
  final float scaleMaxHeight=(float)(1 + tileExtensionPercent / 100);
  double[] heightArray=new double[2];
  final int numberOfPoints=(int)(10 * Math.sqrt(Math.sqrt(rectangle.width * rectangle.height)));
  int offsetX=(int)(extraTileX * rectangle.width);
  int offsetY=(int)(extraTileY * rectangle.height);
  final Window window=new Window((long)(corners[0].y - offsetY),(long)(corners[1].y + offsetY),(long)(corners[0].x - offsetX),(long)(corners[1].x + offsetX));
  final int[][] points=MathUtils.distributePoints(numberOfPoints,window);
  final ArrayList<Double> heights=new ArrayList();
  for (  int[] point : points) {
    double height=dem.getSample(point[1],point[0]);
    if (!Double.isNaN(height) && height != demNoDataValue) {
      heights.add(height);
    }
  }
  if (heights.size() > 2) {
    heightArray[0]=Collections.min(heights);
    heightArray[1]=Collections.max(heights) * scaleMaxHeight;
  }
 else {
    heightArray[0]=0;
    heightArray[1]=0;
  }
  return heightArray;
}","private double[] computeMaxHeight(PixelPos[] corners,Rectangle rectangle) throws Exception {
  final float extraTileX=(float)(1 + tileExtensionPercent / 100.0);
  final float extraTileY=(float)(1 + tileExtensionPercent / 100.0);
  final float scaleMaxHeight=(float)(1 + tileExtensionPercent / 100.0);
  double[] heightArray=new double[2];
  final int numberOfPoints=(int)(10 * Math.sqrt(Math.sqrt(rectangle.width * rectangle.height)));
  final int offsetX=(int)(extraTileX * rectangle.width);
  final int offsetY=(int)(extraTileY * rectangle.height);
  final Window window=new Window((long)(corners[0].y - offsetY),(long)(corners[1].y + offsetY),(long)(corners[0].x - offsetX),(long)(corners[1].x + offsetX));
  final int[][] points=MathUtils.distributePoints(numberOfPoints,window);
  final ArrayList<Double> heights=new ArrayList();
  for (  int[] point : points) {
    double height=dem.getSample(point[1],point[0]);
    if (!Double.isNaN(height) && height != demNoDataValue) {
      heights.add(height);
    }
  }
  if (heights.size() > 2) {
    heightArray[0]=Collections.min(heights);
    heightArray[1]=Collections.max(heights) * scaleMaxHeight;
  }
 else {
    heightArray[0]=0;
    heightArray[1]=0;
  }
  return heightArray;
}"
11497,"@Override public void updateParameters(){
  paramMap.put(""String_Node_Str"",Integer.parseInt(orbitDegree.getText()));
  paramMap.put(""String_Node_Str"",demName.getSelectedItem());
  final String extFileStr=externalDEMFile.getText();
  if (!extFileStr.isEmpty()) {
    paramMap.put(""String_Node_Str"",new File(extFileStr));
    paramMap.put(""String_Node_Str"",Double.parseDouble(externalDEMNoDataValue.getText()));
  }
  paramMap.put(""String_Node_Str"",topoPhaseBandName.getText());
}","@Override public void updateParameters(){
  paramMap.put(""String_Node_Str"",Integer.parseInt(orbitDegree.getText()));
  paramMap.put(""String_Node_Str"",demName.getSelectedItem());
  final String extFileStr=externalDEMFile.getText();
  if (!extFileStr.isEmpty()) {
    paramMap.put(""String_Node_Str"",new File(extFileStr));
    paramMap.put(""String_Node_Str"",Double.parseDouble(externalDEMNoDataValue.getText()));
  }
  paramMap.put(""String_Node_Str"",topoPhaseBandName.getText());
  paramMap.put(""String_Node_Str"",tileExtensionPercent.getSelectedItem());
}"
11498,"private void computePartialTile2(final int subSwathIndex,final int burstIndex,Rectangle targetRectangle,final Map<Band,Tile> targetTileMap) throws Exception {
  try {
    final int cohx0=targetRectangle.x - (cohWinRg - 1) / 2;
    final int cohy0=targetRectangle.y - (cohWinAz - 1) / 2;
    final int cohw=targetRectangle.width + cohWinRg - 1;
    final int cohh=targetRectangle.height + cohWinAz - 1;
    final Rectangle rect=new Rectangle(cohx0,cohy0,cohw,cohh);
    final BorderExtender border=BorderExtender.createInstance(BorderExtender.BORDER_ZERO);
    final int y0=targetRectangle.y;
    final int yN=y0 + targetRectangle.height - 1;
    final int x0=targetRectangle.x;
    final int xN=targetRectangle.x + targetRectangle.width - 1;
    final long minLine=burstIndex * subSwath[subSwathIndex - 1].linesPerBurst;
    final long maxLine=minLine + subSwath[subSwathIndex - 1].linesPerBurst - 1;
    final long minPixel=0;
    final long maxPixel=subSwath[subSwathIndex - 1].samplesPerBurst - 1;
    Band targetBand_I;
    Band targetBand_Q;
    for (    String ifgKey : targetMap.keySet()) {
      final ProductContainer product=targetMap.get(ifgKey);
      final Tile mstTileReal=getSourceTile(product.sourceMaster.realBand,rect,border);
      final Tile mstTileImag=getSourceTile(product.sourceMaster.imagBand,rect,border);
      final ComplexDoubleMatrix dataMaster=TileUtilsDoris.pullComplexDoubleMatrix(mstTileReal,mstTileImag);
      final Tile slvTileReal=getSourceTile(product.sourceSlave.realBand,rect,border);
      final Tile slvTileImag=getSourceTile(product.sourceSlave.imagBand,rect,border);
      final ComplexDoubleMatrix dataSlave=TileUtilsDoris.pullComplexDoubleMatrix(slvTileReal,slvTileImag);
      ComplexDoubleMatrix dataMaster2=null, dataSlave2=null;
      if (includeCoherence) {
        dataMaster2=new ComplexDoubleMatrix(mstTileReal.getHeight(),mstTileReal.getWidth());
        dataSlave2=new ComplexDoubleMatrix(slvTileReal.getHeight(),slvTileReal.getWidth());
        dataMaster2.copy(dataMaster);
        dataSlave2.copy(dataSlave);
      }
      if (subtractFlatEarthPhase) {
        DoubleMatrix rangeAxisNormalized=DoubleMatrix.linspace(x0,xN,dataMaster.columns);
        rangeAxisNormalized=normalizeDoubleMatrix(rangeAxisNormalized,minPixel,maxPixel);
        DoubleMatrix azimuthAxisNormalized=DoubleMatrix.linspace(y0,yN,dataMaster.rows);
        azimuthAxisNormalized=normalizeDoubleMatrix(azimuthAxisNormalized,minLine,maxLine);
        final String polynomialName=product.sourceSlave.name + ""String_Node_Str"" + (subSwathIndex - 1)+ ""String_Node_Str""+ burstIndex;
        final DoubleMatrix polyCoeffs=flatEarthPolyMap.get(polynomialName);
        final DoubleMatrix realReferencePhase=PolyUtils.polyval(azimuthAxisNormalized,rangeAxisNormalized,polyCoeffs,PolyUtils.degreeFromCoefficients(polyCoeffs.length));
        final ComplexDoubleMatrix complexReferencePhase=new ComplexDoubleMatrix(MatrixFunctions.cos(realReferencePhase),MatrixFunctions.sin(realReferencePhase));
        dataSlave.muli(complexReferencePhase);
      }
      dataMaster.muli(dataSlave.conji());
      targetBand_I=targetProduct.getBand(product.getBandName(Unit.REAL));
      Tile tileOutReal=targetTileMap.get(targetBand_I);
      targetBand_Q=targetProduct.getBand(product.getBandName(Unit.IMAGINARY));
      Tile tileOutImag=targetTileMap.get(targetBand_Q);
      DoubleMatrix cohMatrix=null;
      ProductData samplesCoh=null;
      if (includeCoherence) {
        for (int i=0; i < dataMaster.length; i++) {
          double tmp=norm(dataMaster2.get(i));
          dataMaster2.put(i,dataMaster2.get(i).mul(dataSlave2.get(i).conj()));
          dataSlave2.put(i,new ComplexDouble(norm(dataSlave2.get(i)),tmp));
        }
        cohMatrix=SarUtils.coherence2(dataMaster2,dataSlave2,cohWinAz,cohWinRg);
        final Band targetBandCoh=targetProduct.getBand(product.getBandName(Unit.COHERENCE));
        final Tile tileOutCoh=targetTileMap.get(targetBandCoh);
        samplesCoh=tileOutCoh.getDataBuffer();
      }
      final ProductData samplesReal=tileOutReal.getDataBuffer();
      final ProductData samplesImag=tileOutImag.getDataBuffer();
      final DoubleMatrix dataReal=dataMaster.real();
      final DoubleMatrix dataImag=dataMaster.imag();
      final int maxX=targetRectangle.x + targetRectangle.width;
      final int maxY=targetRectangle.y + targetRectangle.height;
      final TileIndex tgtIndex=new TileIndex(tileOutReal);
      for (int y=targetRectangle.y; y < maxY; y++) {
        tgtIndex.calculateStride(y);
        final int yy=y - targetRectangle.y;
        for (int x=targetRectangle.x; x < maxX; x++) {
          final int trgIndex=tgtIndex.getIndex(x);
          final int xx=x - targetRectangle.x;
          samplesReal.setElemFloatAt(trgIndex,(float)dataReal.get(yy,xx));
          samplesImag.setElemFloatAt(trgIndex,(float)dataImag.get(yy,xx));
          if (samplesCoh != null) {
            samplesCoh.setElemFloatAt(trgIndex,(float)cohMatrix.get(yy,xx));
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","private void computePartialTile2(final int subSwathIndex,final int burstIndex,Rectangle targetRectangle,final Map<Band,Tile> targetTileMap) throws Exception {
  try {
    final int rgOffset=(cohWinRg - 1) / 2;
    final int azOffset=(cohWinAz - 1) / 2;
    final int cohx0=targetRectangle.x - rgOffset;
    final int cohy0=targetRectangle.y - azOffset;
    final int cohw=targetRectangle.width + cohWinRg - 1;
    final int cohh=targetRectangle.height + cohWinAz - 1;
    final Rectangle rect=new Rectangle(cohx0,cohy0,cohw,cohh);
    final BorderExtender border=BorderExtender.createInstance(BorderExtender.BORDER_ZERO);
    final int y0=rect.y;
    final int yN=y0 + rect.height - 1;
    final int x0=rect.x;
    final int xN=rect.x + rect.width - 1;
    final long minLine=burstIndex * subSwath[subSwathIndex - 1].linesPerBurst;
    final long maxLine=minLine + subSwath[subSwathIndex - 1].linesPerBurst - 1;
    final long minPixel=0;
    final long maxPixel=subSwath[subSwathIndex - 1].samplesPerBurst - 1;
    Band targetBand_I;
    Band targetBand_Q;
    for (    String ifgKey : targetMap.keySet()) {
      final ProductContainer product=targetMap.get(ifgKey);
      final Tile mstTileReal=getSourceTile(product.sourceMaster.realBand,rect,border);
      final Tile mstTileImag=getSourceTile(product.sourceMaster.imagBand,rect,border);
      final ComplexDoubleMatrix dataMaster=TileUtilsDoris.pullComplexDoubleMatrix(mstTileReal,mstTileImag);
      final Tile slvTileReal=getSourceTile(product.sourceSlave.realBand,rect,border);
      final Tile slvTileImag=getSourceTile(product.sourceSlave.imagBand,rect,border);
      final ComplexDoubleMatrix dataSlave=TileUtilsDoris.pullComplexDoubleMatrix(slvTileReal,slvTileImag);
      ComplexDoubleMatrix dataMaster2=null, dataSlave2=null;
      if (includeCoherence) {
        dataMaster2=new ComplexDoubleMatrix(mstTileReal.getHeight(),mstTileReal.getWidth());
        dataSlave2=new ComplexDoubleMatrix(slvTileReal.getHeight(),slvTileReal.getWidth());
        dataMaster2.copy(dataMaster);
        dataSlave2.copy(dataSlave);
      }
      if (subtractFlatEarthPhase) {
        DoubleMatrix rangeAxisNormalized=DoubleMatrix.linspace(x0,xN,dataMaster.columns);
        rangeAxisNormalized=normalizeDoubleMatrix(rangeAxisNormalized,minPixel,maxPixel);
        DoubleMatrix azimuthAxisNormalized=DoubleMatrix.linspace(y0,yN,dataMaster.rows);
        azimuthAxisNormalized=normalizeDoubleMatrix(azimuthAxisNormalized,minLine,maxLine);
        final String polynomialName=product.sourceSlave.name + ""String_Node_Str"" + (subSwathIndex - 1)+ ""String_Node_Str""+ burstIndex;
        final DoubleMatrix polyCoeffs=flatEarthPolyMap.get(polynomialName);
        final DoubleMatrix realReferencePhase=PolyUtils.polyval(azimuthAxisNormalized,rangeAxisNormalized,polyCoeffs,PolyUtils.degreeFromCoefficients(polyCoeffs.length));
        final ComplexDoubleMatrix complexReferencePhase=new ComplexDoubleMatrix(MatrixFunctions.cos(realReferencePhase),MatrixFunctions.sin(realReferencePhase));
        dataSlave.muli(complexReferencePhase);
      }
      dataMaster.muli(dataSlave.conji());
      targetBand_I=targetProduct.getBand(product.getBandName(Unit.REAL));
      Tile tileOutReal=targetTileMap.get(targetBand_I);
      targetBand_Q=targetProduct.getBand(product.getBandName(Unit.IMAGINARY));
      Tile tileOutImag=targetTileMap.get(targetBand_Q);
      DoubleMatrix cohMatrix=null;
      ProductData samplesCoh=null;
      if (includeCoherence) {
        for (int i=0; i < dataMaster.length; i++) {
          double tmp=norm(dataMaster2.get(i));
          dataMaster2.put(i,dataMaster2.get(i).mul(dataSlave2.get(i).conj()));
          dataSlave2.put(i,new ComplexDouble(norm(dataSlave2.get(i)),tmp));
        }
        cohMatrix=SarUtils.coherence2(dataMaster2,dataSlave2,cohWinAz,cohWinRg);
        final Band targetBandCoh=targetProduct.getBand(product.getBandName(Unit.COHERENCE));
        final Tile tileOutCoh=targetTileMap.get(targetBandCoh);
        samplesCoh=tileOutCoh.getDataBuffer();
      }
      final ProductData samplesReal=tileOutReal.getDataBuffer();
      final ProductData samplesImag=tileOutImag.getDataBuffer();
      final DoubleMatrix dataReal=dataMaster.real();
      final DoubleMatrix dataImag=dataMaster.imag();
      final int maxX=targetRectangle.x + targetRectangle.width;
      final int maxY=targetRectangle.y + targetRectangle.height;
      final TileIndex tgtIndex=new TileIndex(tileOutReal);
      for (int y=targetRectangle.y; y < maxY; y++) {
        tgtIndex.calculateStride(y);
        final int yy=y - targetRectangle.y;
        for (int x=targetRectangle.x; x < maxX; x++) {
          final int trgIndex=tgtIndex.getIndex(x);
          final int xx=x - targetRectangle.x;
          samplesReal.setElemFloatAt(trgIndex,(float)dataReal.get(yy + azOffset,xx + rgOffset));
          samplesImag.setElemFloatAt(trgIndex,(float)dataImag.get(yy + azOffset,xx + rgOffset));
          if (samplesCoh != null) {
            samplesCoh.setElemFloatAt(trgIndex,(float)cohMatrix.get(yy,xx));
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11499,"private void computeTileStackForNormalProduct(final Map<Band,Tile> targetTileMap,Rectangle targetRectangle,final ProgressMonitor pm) throws OperatorException {
  try {
    final int cohx0=targetRectangle.x - (cohWinRg - 1) / 2;
    final int cohy0=targetRectangle.y - (cohWinAz - 1) / 2;
    final int cohw=targetRectangle.width + cohWinRg - 1;
    final int cohh=targetRectangle.height + cohWinAz - 1;
    targetRectangle=new Rectangle(cohx0,cohy0,cohw,cohh);
    final BorderExtender border=BorderExtender.createInstance(BorderExtender.BORDER_ZERO);
    final int y0=targetRectangle.y;
    final int yN=y0 + targetRectangle.height - 1;
    final int x0=targetRectangle.x;
    final int xN=targetRectangle.x + targetRectangle.width - 1;
    for (    String ifgKey : targetMap.keySet()) {
      final ProductContainer product=targetMap.get(ifgKey);
      final Tile mstTileReal=getSourceTile(product.sourceMaster.realBand,targetRectangle,border);
      final Tile mstTileImag=getSourceTile(product.sourceMaster.imagBand,targetRectangle,border);
      final ComplexDoubleMatrix dataMaster=TileUtilsDoris.pullComplexDoubleMatrix(mstTileReal,mstTileImag);
      final Tile slvTileReal=getSourceTile(product.sourceSlave.realBand,targetRectangle,border);
      final Tile slvTileImag=getSourceTile(product.sourceSlave.imagBand,targetRectangle,border);
      final ComplexDoubleMatrix dataSlave=TileUtilsDoris.pullComplexDoubleMatrix(slvTileReal,slvTileImag);
      ComplexDoubleMatrix dataMaster2=null, dataSlave2=null;
      if (includeCoherence) {
        dataMaster2=new ComplexDoubleMatrix(mstTileReal.getHeight(),mstTileReal.getWidth());
        dataSlave2=new ComplexDoubleMatrix(slvTileReal.getHeight(),slvTileReal.getWidth());
        dataMaster2.copy(dataMaster);
        dataSlave2.copy(dataSlave);
      }
      if (subtractFlatEarthPhase) {
        DoubleMatrix rangeAxisNormalized=DoubleMatrix.linspace(x0,xN,dataMaster.columns);
        rangeAxisNormalized=normalizeDoubleMatrix(rangeAxisNormalized,0,sourceImageWidth - 1);
        DoubleMatrix azimuthAxisNormalized=DoubleMatrix.linspace(y0,yN,dataMaster.rows);
        azimuthAxisNormalized=normalizeDoubleMatrix(azimuthAxisNormalized,0,sourceImageHeight - 1);
        final DoubleMatrix polyCoeffs=flatEarthPolyMap.get(product.sourceSlave.name);
        final DoubleMatrix realReferencePhase=PolyUtils.polyval(azimuthAxisNormalized,rangeAxisNormalized,polyCoeffs,PolyUtils.degreeFromCoefficients(polyCoeffs.length));
        final ComplexDoubleMatrix complexReferencePhase=new ComplexDoubleMatrix(MatrixFunctions.cos(realReferencePhase),MatrixFunctions.sin(realReferencePhase));
        dataSlave.muli(complexReferencePhase);
      }
      dataMaster.muli(dataSlave.conji());
      final Band targetBand_I=targetProduct.getBand(product.getBandName(Unit.REAL));
      final Tile tileOutReal=targetTileMap.get(targetBand_I);
      final Band targetBand_Q=targetProduct.getBand(product.getBandName(Unit.IMAGINARY));
      final Tile tileOutImag=targetTileMap.get(targetBand_Q);
      DoubleMatrix cohMatrix=null;
      ProductData samplesCoh=null;
      if (includeCoherence) {
        for (int i=0; i < dataMaster.length; i++) {
          double tmp=norm(dataMaster2.get(i));
          dataMaster2.put(i,dataMaster2.get(i).mul(dataSlave2.get(i).conj()));
          dataSlave2.put(i,new ComplexDouble(norm(dataSlave2.get(i)),tmp));
        }
        cohMatrix=SarUtils.coherence2(dataMaster2,dataSlave2,cohWinAz,cohWinRg);
        final Band targetBandCoh=targetProduct.getBand(product.getBandName(Unit.COHERENCE));
        final Tile tileOutCoh=targetTileMap.get(targetBandCoh);
        samplesCoh=tileOutCoh.getDataBuffer();
      }
      final ProductData samplesReal=tileOutReal.getDataBuffer();
      final ProductData samplesImag=tileOutImag.getDataBuffer();
      final DoubleMatrix dataReal=dataMaster.real();
      final DoubleMatrix dataImag=dataMaster.imag();
      final Rectangle rect=tileOutReal.getRectangle();
      final int maxX=rect.x + rect.width;
      final int maxY=rect.y + rect.height;
      final TileIndex tgtIndex=new TileIndex(tileOutReal);
      for (int y=rect.y; y < maxY; y++) {
        tgtIndex.calculateStride(y);
        final int yy=y - rect.y;
        for (int x=rect.x; x < maxX; x++) {
          final int trgIndex=tgtIndex.getIndex(x);
          final int xx=x - rect.x;
          samplesReal.setElemFloatAt(trgIndex,(float)dataReal.get(yy,xx));
          samplesImag.setElemFloatAt(trgIndex,(float)dataImag.get(yy,xx));
          if (samplesCoh != null) {
            samplesCoh.setElemFloatAt(trgIndex,(float)cohMatrix.get(yy,xx));
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}","private void computeTileStackForNormalProduct(final Map<Band,Tile> targetTileMap,Rectangle targetRectangle,final ProgressMonitor pm) throws OperatorException {
  try {
    final int rgOffset=(cohWinRg - 1) / 2;
    final int azOffset=(cohWinAz - 1) / 2;
    final int cohx0=targetRectangle.x - rgOffset;
    final int cohy0=targetRectangle.y - azOffset;
    final int cohw=targetRectangle.width + cohWinRg - 1;
    final int cohh=targetRectangle.height + cohWinAz - 1;
    targetRectangle=new Rectangle(cohx0,cohy0,cohw,cohh);
    final BorderExtender border=BorderExtender.createInstance(BorderExtender.BORDER_ZERO);
    final int y0=targetRectangle.y;
    final int yN=y0 + targetRectangle.height - 1;
    final int x0=targetRectangle.x;
    final int xN=targetRectangle.x + targetRectangle.width - 1;
    for (    String ifgKey : targetMap.keySet()) {
      final ProductContainer product=targetMap.get(ifgKey);
      final Tile mstTileReal=getSourceTile(product.sourceMaster.realBand,targetRectangle,border);
      final Tile mstTileImag=getSourceTile(product.sourceMaster.imagBand,targetRectangle,border);
      final ComplexDoubleMatrix dataMaster=TileUtilsDoris.pullComplexDoubleMatrix(mstTileReal,mstTileImag);
      final Tile slvTileReal=getSourceTile(product.sourceSlave.realBand,targetRectangle,border);
      final Tile slvTileImag=getSourceTile(product.sourceSlave.imagBand,targetRectangle,border);
      final ComplexDoubleMatrix dataSlave=TileUtilsDoris.pullComplexDoubleMatrix(slvTileReal,slvTileImag);
      ComplexDoubleMatrix dataMaster2=null, dataSlave2=null;
      if (includeCoherence) {
        dataMaster2=new ComplexDoubleMatrix(mstTileReal.getHeight(),mstTileReal.getWidth());
        dataSlave2=new ComplexDoubleMatrix(slvTileReal.getHeight(),slvTileReal.getWidth());
        dataMaster2.copy(dataMaster);
        dataSlave2.copy(dataSlave);
      }
      if (subtractFlatEarthPhase) {
        DoubleMatrix rangeAxisNormalized=DoubleMatrix.linspace(x0,xN,dataMaster.columns);
        rangeAxisNormalized=normalizeDoubleMatrix(rangeAxisNormalized,0,sourceImageWidth - 1);
        DoubleMatrix azimuthAxisNormalized=DoubleMatrix.linspace(y0,yN,dataMaster.rows);
        azimuthAxisNormalized=normalizeDoubleMatrix(azimuthAxisNormalized,0,sourceImageHeight - 1);
        final DoubleMatrix polyCoeffs=flatEarthPolyMap.get(product.sourceSlave.name);
        final DoubleMatrix realReferencePhase=PolyUtils.polyval(azimuthAxisNormalized,rangeAxisNormalized,polyCoeffs,PolyUtils.degreeFromCoefficients(polyCoeffs.length));
        final ComplexDoubleMatrix complexReferencePhase=new ComplexDoubleMatrix(MatrixFunctions.cos(realReferencePhase),MatrixFunctions.sin(realReferencePhase));
        dataSlave.muli(complexReferencePhase);
      }
      dataMaster.muli(dataSlave.conji());
      final Band targetBand_I=targetProduct.getBand(product.getBandName(Unit.REAL));
      final Tile tileOutReal=targetTileMap.get(targetBand_I);
      final Band targetBand_Q=targetProduct.getBand(product.getBandName(Unit.IMAGINARY));
      final Tile tileOutImag=targetTileMap.get(targetBand_Q);
      DoubleMatrix cohMatrix=null;
      ProductData samplesCoh=null;
      if (includeCoherence) {
        for (int i=0; i < dataMaster.length; i++) {
          double tmp=norm(dataMaster2.get(i));
          dataMaster2.put(i,dataMaster2.get(i).mul(dataSlave2.get(i).conj()));
          dataSlave2.put(i,new ComplexDouble(norm(dataSlave2.get(i)),tmp));
        }
        cohMatrix=SarUtils.coherence2(dataMaster2,dataSlave2,cohWinAz,cohWinRg);
        final Band targetBandCoh=targetProduct.getBand(product.getBandName(Unit.COHERENCE));
        final Tile tileOutCoh=targetTileMap.get(targetBandCoh);
        samplesCoh=tileOutCoh.getDataBuffer();
      }
      final ProductData samplesReal=tileOutReal.getDataBuffer();
      final ProductData samplesImag=tileOutImag.getDataBuffer();
      final DoubleMatrix dataReal=dataMaster.real();
      final DoubleMatrix dataImag=dataMaster.imag();
      final Rectangle rect=tileOutReal.getRectangle();
      final int maxX=rect.x + rect.width;
      final int maxY=rect.y + rect.height;
      final TileIndex tgtIndex=new TileIndex(tileOutReal);
      for (int y=rect.y; y < maxY; y++) {
        tgtIndex.calculateStride(y);
        final int yy=y - rect.y;
        for (int x=rect.x; x < maxX; x++) {
          final int trgIndex=tgtIndex.getIndex(x);
          final int xx=x - rect.x;
          samplesReal.setElemFloatAt(trgIndex,(float)dataReal.get(yy,xx));
          samplesImag.setElemFloatAt(trgIndex,(float)dataImag.get(yy,xx));
          if (samplesCoh != null) {
            samplesCoh.setElemFloatAt(trgIndex,(float)cohMatrix.get(yy,xx));
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}"
11500,"private void getSlvApproxSceneCentreAzimuthTime() throws Exception {
  final MetadataElement root=AbstractMetadata.getOriginalProductMetadata(sourceProduct);
  final MetadataElement slvRoot=AbstractMetadata.getSlaveMetadata(root);
  final double firstLineTime=slvRoot.getAttributeUTC(AbstractMetadata.first_line_time).getMJD() * Constants.secondsInDay;
  final double lastLineTime=slvRoot.getAttributeUTC(AbstractMetadata.last_line_time).getMJD() * Constants.secondsInDay;
  slvScenseCentreAzimuthTime=0.5 * (firstLineTime + lastLineTime);
}","private void getSlvApproxSceneCentreAzimuthTime() throws Exception {
  MetadataElement slaveElem=sourceProduct.getMetadataRoot().getElement(AbstractMetadata.SLAVE_METADATA_ROOT);
  MetadataElement[] slaveRoot=slaveElem.getElements();
  final MetadataElement slvRoot=slaveRoot[0];
  final double firstLineTimeInDays=slvRoot.getAttributeUTC(AbstractMetadata.first_line_time).getMJD();
  final double firstLineTime=(firstLineTimeInDays - (int)firstLineTimeInDays) * Constants.secondsInDay;
  final double lastLineTimeInDays=slvRoot.getAttributeUTC(AbstractMetadata.last_line_time).getMJD();
  final double lastLineTime=(lastLineTimeInDays - (int)lastLineTimeInDays) * Constants.secondsInDay;
  slvScenseCentreAzimuthTime=0.5 * (firstLineTime + lastLineTime);
}"
11501,"/** 
 * Create a flat earth phase polynomial for a given burst in TOPSAR product.
 */
private DoubleMatrix estimateFlatEarthPolynomial(SLCImage masterMetadata,Orbit masterOrbit,SLCImage slaveMetadata,Orbit slaveOrbit,final int subSwathIndex,final int burstIndex) throws Exception {
  long minLine=burstIndex * subSwath[subSwathIndex - 1].linesPerBurst;
  long maxLine=minLine + subSwath[subSwathIndex - 1].linesPerBurst - 1;
  long minPixel=0;
  long maxPixel=subSwath[subSwathIndex - 1].samplesPerBurst - 1;
  int numberOfCoefficients=PolyUtils.numberOfCoefficients(srpPolynomialDegree);
  int[][] position=MathUtils.distributePoints(srpNumberPoints,new Window(minLine,maxLine,minPixel,maxPixel));
  DoubleMatrix y=new DoubleMatrix(srpNumberPoints);
  DoubleMatrix A=new DoubleMatrix(srpNumberPoints,numberOfCoefficients);
  double masterMinPi4divLam=(-4 * Constants.PI * Constants.lightSpeed) / masterMetadata.getRadarWavelength();
  double slaveMinPi4divLam=(-4 * Constants.PI * Constants.lightSpeed) / slaveMetadata.getRadarWavelength();
  for (int i=0; i < srpNumberPoints; ++i) {
    double line=position[i][0];
    double pixel=position[i][1];
    final double mstRgTime=subSwath[subSwathIndex - 1].slrTimeToFirstPixel + pixel * su.rangeSpacing / Constants.lightSpeed;
    final double mstAzTime=subSwath[subSwathIndex - 1].burstFirstLineTime[burstIndex] + (line - burstIndex * subSwath[subSwathIndex - 1].linesPerBurst) * subSwath[subSwathIndex - 1].azimuthTimeInterval;
    org.jlinda.core.Point xyzMaster=masterOrbit.lph2xyz(mstAzTime,mstRgTime,0.0,mstSceneCentreXYZ);
    org.jlinda.core.Point slaveTimeVector=slaveOrbit.xyz2t(xyzMaster,slvScenseCentreAzimuthTime);
    final double slaveTimeRange=slaveTimeVector.x;
    y.put(i,(masterMinPi4divLam * mstRgTime) - (slaveMinPi4divLam * slaveTimeRange));
    double posL=PolyUtils.normalize2(line,minLine,maxLine);
    double posP=PolyUtils.normalize2(pixel,minPixel,maxPixel);
    int index=0;
    for (int j=0; j <= srpPolynomialDegree; j++) {
      for (int k=0; k <= j; k++) {
        A.put(i,index,(FastMath.pow(posL,(double)(j - k)) * FastMath.pow(posP,(double)k)));
        index++;
      }
    }
  }
  DoubleMatrix Atranspose=A.transpose();
  DoubleMatrix N=Atranspose.mmul(A);
  DoubleMatrix rhs=Atranspose.mmul(y);
  return Solve.solve(N,rhs);
}","/** 
 * Create a flat earth phase polynomial for a given burst in TOPSAR product.
 */
private DoubleMatrix estimateFlatEarthPolynomial(SLCImage masterMetadata,Orbit masterOrbit,SLCImage slaveMetadata,Orbit slaveOrbit,final int subSwathIndex,final int burstIndex) throws Exception {
  long minLine=burstIndex * subSwath[subSwathIndex - 1].linesPerBurst;
  long maxLine=minLine + subSwath[subSwathIndex - 1].linesPerBurst - 1;
  long minPixel=0;
  long maxPixel=subSwath[subSwathIndex - 1].samplesPerBurst - 1;
  int numberOfCoefficients=PolyUtils.numberOfCoefficients(srpPolynomialDegree);
  int[][] position=MathUtils.distributePoints(srpNumberPoints,new Window(minLine,maxLine,minPixel,maxPixel));
  DoubleMatrix y=new DoubleMatrix(srpNumberPoints);
  DoubleMatrix A=new DoubleMatrix(srpNumberPoints,numberOfCoefficients);
  double masterMinPi4divLam=(-4 * Constants.PI * Constants.lightSpeed) / masterMetadata.getRadarWavelength();
  double slaveMinPi4divLam=(-4 * Constants.PI * Constants.lightSpeed) / slaveMetadata.getRadarWavelength();
  for (int i=0; i < srpNumberPoints; ++i) {
    double line=position[i][0];
    double pixel=position[i][1];
    final double mstRgTime=subSwath[subSwathIndex - 1].slrTimeToFirstPixel + pixel * su.rangeSpacing / Constants.lightSpeed;
    final double mstAzTime=line2AzimuthTime(line,subSwathIndex,burstIndex);
    org.jlinda.core.Point xyzMaster=masterOrbit.lph2xyz(mstAzTime,mstRgTime,0.0,mstSceneCentreXYZ);
    org.jlinda.core.Point slaveTimeVector=slaveOrbit.xyz2t(xyzMaster,slvScenseCentreAzimuthTime);
    final double slaveTimeRange=slaveTimeVector.x;
    y.put(i,(masterMinPi4divLam * mstRgTime) - (slaveMinPi4divLam * slaveTimeRange));
    double posL=PolyUtils.normalize2(line,minLine,maxLine);
    double posP=PolyUtils.normalize2(pixel,minPixel,maxPixel);
    int index=0;
    for (int j=0; j <= srpPolynomialDegree; j++) {
      for (int k=0; k <= j; k++) {
        A.put(i,index,(FastMath.pow(posL,(double)(j - k)) * FastMath.pow(posP,(double)k)));
        index++;
      }
    }
  }
  DoubleMatrix Atranspose=A.transpose();
  DoubleMatrix N=Atranspose.mmul(A);
  DoubleMatrix rhs=Atranspose.mmul(y);
  return Solve.solve(N,rhs);
}"
11502,"/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    if (doNotSubtract) {
      productName=""String_Node_Str"";
      productTag=""String_Node_Str"";
    }
 else {
      productName=""String_Node_Str"";
      productTag=""String_Node_Str"";
    }
    constructSourceMetadata();
    constructTargetMetadata();
    createTargetProduct();
    getSourceImageDimension();
    if (!doNotSubtract) {
      final InputProductValidator validator=new InputProductValidator(sourceProduct);
      validator.checkIfCoregisteredStack();
      isTOPSARBurstProduct=validator.isTOPSARBurstProduct();
      if (isTOPSARBurstProduct) {
        su=new Sentinel1Utils(sourceProduct);
        subSwath=su.getSubSwath();
        numSubSwaths=su.getNumOfSubSwath();
        subSwathIndex=1;
        getMstApproxSceneCentreXYZ();
        getSlvApproxSceneCentreAzimuthTime();
        constructFlatEarthPolynomialsForTOPSARProduct();
      }
 else {
        constructFlatEarthPolynomials();
      }
    }
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
}","/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    if (doNotSubtract) {
      productName=""String_Node_Str"";
      productTag=""String_Node_Str"";
    }
 else {
      productName=""String_Node_Str"";
      productTag=""String_Node_Str"";
    }
    final InputProductValidator validator=new InputProductValidator(sourceProduct);
    validator.checkIfCoregisteredStack();
    isTOPSARBurstProduct=validator.isTOPSARBurstProduct();
    if (isTOPSARBurstProduct) {
      final String topsarTag=getTOPSARTag(sourceProduct);
      productTag=topsarTag + ""String_Node_Str"" + productTag;
    }
    constructSourceMetadata();
    constructTargetMetadata();
    createTargetProduct();
    getSourceImageDimension();
    if (!doNotSubtract) {
      if (isTOPSARBurstProduct) {
        su=new Sentinel1Utils(sourceProduct);
        subSwath=su.getSubSwath();
        numSubSwaths=su.getNumOfSubSwath();
        subSwathIndex=1;
        getMstApproxSceneCentreXYZ();
        getSlvApproxSceneCentreAzimuthTime();
        constructFlatEarthPolynomialsForTOPSARProduct();
      }
 else {
        constructFlatEarthPolynomials();
      }
    }
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
}"
11503,"private void constructFlatEarthPolynomialsForTOPSARProduct() throws Exception {
  for (  Integer keyMaster : masterMap.keySet()) {
    CplxContainer master=masterMap.get(keyMaster);
    for (    Integer keySlave : slaveMap.keySet()) {
      CplxContainer slave=slaveMap.get(keySlave);
      for (int s=0; s < numSubSwaths; s++) {
        final int numBursts=subSwath[s].numOfBursts;
        for (int b=0; b < numBursts; b++) {
          final String polynomialName=slave.name + ""String_Node_Str"" + s+ ""String_Node_Str""+ b;
          flatEarthPolyMap.put(polynomialName,estimateFlatEarthPolynomial(master.metaData,master.orbit,slave.metaData,slave.orbit,s,b));
        }
      }
    }
  }
}","private void constructFlatEarthPolynomialsForTOPSARProduct() throws Exception {
  for (  Integer keyMaster : masterMap.keySet()) {
    CplxContainer master=masterMap.get(keyMaster);
    for (    Integer keySlave : slaveMap.keySet()) {
      CplxContainer slave=slaveMap.get(keySlave);
      for (int s=0; s < numSubSwaths; s++) {
        final int numBursts=subSwath[s].numOfBursts;
        for (int b=0; b < numBursts; b++) {
          final String polynomialName=slave.name + ""String_Node_Str"" + s+ ""String_Node_Str""+ b;
          flatEarthPolyMap.put(polynomialName,estimateFlatEarthPolynomial(master.metaData,master.orbit,slave.metaData,slave.orbit,s + 1,b));
        }
      }
    }
  }
}"
11504,"private int getPolyCoeffIndex(final double time){
  final int nv=orbitStateVectors.length;
  if (time < orbitStateVectors[0].time_mjd) {
    return 0;
  }
  if (time > orbitStateVectors[nv - 1].time_mjd) {
    return nv - 2;
  }
  for (int i=0; i < nv - 1; i++) {
    if (time >= orbitStateVectors[i].time_mjd && time < orbitStateVectors[i + 1].time_mjd) {
      return i;
    }
  }
  return -1;
}","private int getPolyCoeffIndex(final double time){
  final int nv=orbitStateVectors.length;
  if (time < orbitStateVectors[0].time_mjd) {
    return 0;
  }
  if (time >= orbitStateVectors[nv - 1].time_mjd) {
    return nv - 2;
  }
  for (int i=0; i < nv - 1; i++) {
    if (time >= orbitStateVectors[i].time_mjd && time < orbitStateVectors[i + 1].time_mjd) {
      return i;
    }
  }
  return -1;
}"
11505,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final int x0=targetRectangle.x;
    final int y0=targetRectangle.y;
    final int w=targetRectangle.width;
    final int h=targetRectangle.height;
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    final double[][] C3r=new double[3][3];
    final double[][] C3i=new double[3][3];
    final double[][] C4r=new double[4][4];
    final double[][] C4i=new double[4][4];
    final double[][] T3r=new double[3][3];
    final double[][] T3i=new double[3][3];
    final double[][] T4r=new double[4][4];
    final double[][] T4i=new double[4][4];
    for (    final PolBandUtils.QuadSourceBand bandList : srcBandList) {
      final Tile[] sourceTiles=new Tile[bandList.srcBands.length];
      final ProductData[] dataBuffers=new ProductData[bandList.srcBands.length];
      for (int i=0; i < bandList.srcBands.length; i++) {
        sourceTiles[i]=getSourceTile(bandList.srcBands[i],targetRectangle);
        dataBuffers[i]=sourceTiles[i].getDataBuffer();
      }
      final TileIndex trgIndex=new TileIndex(sourceTiles[0]);
      double theta, t11, t12Re, t12Im, t13Re, t13Im, t22, t23Re, t23Im, t33, c, s, c2, s2, s4, cs;
      for (int y=y0; y < maxY; ++y) {
        trgIndex.calculateStride(y);
        for (int x=x0; x < maxX; ++x) {
          final int idx=trgIndex.getIndex(x);
          if (sourceProductType == PolBandUtils.MATRIX.T3) {
            PolOpUtils.getCoherencyMatrixT3(idx,dataBuffers,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.T4) {
            PolOpUtils.getCoherencyMatrixT4(idx,dataBuffers,T4r,T4i);
            PolOpUtils.t4ToT3(T4r,T4i,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.C3) {
            PolOpUtils.getCovarianceMatrixC3(idx,dataBuffers,C3r,C3i);
            PolOpUtils.c3ToT3(C3r,C3i,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.C4) {
            PolOpUtils.getCovarianceMatrixC4(idx,dataBuffers,C4r,C4i);
            PolOpUtils.c4ToT4(C4r,C4i,T4r,T4i);
            PolOpUtils.t4ToT3(T4r,T4i,T3r,T3i);
          }
          theta=estimateOrientationAngle(T3r[1][2],T3r[1][1],T3r[2][2]);
          c=FastMath.cos(2 * theta);
          s=FastMath.sin(2 * theta);
          c2=c * c;
          s2=s * s;
          cs=c * s;
          t11=T3r[0][0];
          t12Re=T3r[0][1] * c - T3r[0][2] * s;
          t12Im=T3i[0][1] * c - T3i[0][2] * s;
          t13Re=T3r[0][1] * s + T3r[0][2] * c;
          t13Im=T3i[0][1] * s + T3i[0][2] * c;
          t22=T3r[1][1] * c2 + T3r[2][2] * s2 - 2 * T3r[1][2] * cs;
          t23Re=T3r[1][2] * (c2 - s2) + (T3r[1][1] - T3r[2][2]) * cs;
          t23Im=T3i[1][2];
          t33=T3r[1][1] * s2 + T3r[2][2] * c2 + 2 * T3r[1][2] * cs;
          for (          Band targetBand : bandList.targetBands) {
            final String targetBandName=targetBand.getName();
            final Tile targetTile=targetTiles.get(targetBand);
            if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t11);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t12Re);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t12Im);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t13Re);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t13Im);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t22);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t23Re);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t23Im);
            }
 else             if (targetBandName.contains(""String_Node_Str"")) {
              targetTile.getDataBuffer().setElemFloatAt(idx,(float)t33);
            }
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final int x0=targetRectangle.x;
    final int y0=targetRectangle.y;
    final int w=targetRectangle.width;
    final int h=targetRectangle.height;
    final int maxY=y0 + h;
    final int maxX=x0 + w;
    final double[][] C3r=new double[3][3];
    final double[][] C3i=new double[3][3];
    final double[][] C4r=new double[4][4];
    final double[][] C4i=new double[4][4];
    final double[][] T3r=new double[3][3];
    final double[][] T3i=new double[3][3];
    final double[][] T4r=new double[4][4];
    final double[][] T4i=new double[4][4];
    final TileIndex tgtIndex=new TileIndex(targetTiles.get(getTargetProduct().getBandAt(0)));
    for (    final PolBandUtils.QuadSourceBand bandList : srcBandList) {
      final Tile[] sourceTiles=new Tile[bandList.srcBands.length];
      final ProductData[] dataBuffers=new ProductData[bandList.srcBands.length];
      for (int i=0; i < bandList.srcBands.length; i++) {
        sourceTiles[i]=getSourceTile(bandList.srcBands[i],targetRectangle);
        dataBuffers[i]=sourceTiles[i].getDataBuffer();
      }
      final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
      final ProductData[] targetDataBuffers=new ProductData[9];
      for (      final Band targetBand : bandList.targetBands) {
        final String targetBandName=targetBand.getName();
        final ProductData dataBuffer=targetTiles.get(targetBand).getDataBuffer();
        if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[0]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[1]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[2]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[3]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[4]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[5]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[6]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[7]=dataBuffer;
 else         if (PolBandUtils.isBandForMatrixElement(targetBandName,""String_Node_Str""))         targetDataBuffers[8]=dataBuffer;
      }
      final double[][] Tr=new double[3][3];
      final double[][] Ti=new double[3][3];
      int srcIdx, tgtIdx;
      double theta, c, s, c2, s2, cs;
      for (int y=y0; y < maxY; ++y) {
        srcIndex.calculateStride(y);
        tgtIndex.calculateStride(y);
        for (int x=x0; x < maxX; ++x) {
          srcIdx=srcIndex.getIndex(x);
          tgtIdx=tgtIndex.getIndex(x);
          if (sourceProductType == PolBandUtils.MATRIX.FULL) {
            PolOpUtils.getT3(srcIdx,sourceProductType,dataBuffers,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.T3) {
            PolOpUtils.getCoherencyMatrixT3(srcIdx,dataBuffers,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.T4) {
            PolOpUtils.getCoherencyMatrixT4(srcIdx,dataBuffers,T4r,T4i);
            PolOpUtils.t4ToT3(T4r,T4i,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.C3) {
            PolOpUtils.getCovarianceMatrixC3(srcIdx,dataBuffers,C3r,C3i);
            PolOpUtils.c3ToT3(C3r,C3i,T3r,T3i);
          }
 else           if (sourceProductType == PolBandUtils.MATRIX.C4) {
            PolOpUtils.getCovarianceMatrixC4(srcIdx,dataBuffers,C4r,C4i);
            PolOpUtils.c4ToT4(C4r,C4i,T4r,T4i);
            PolOpUtils.t4ToT3(T4r,T4i,T3r,T3i);
          }
          theta=estimateOrientationAngle(T3r[1][2],T3r[1][1],T3r[2][2]);
          c=FastMath.cos(2 * theta);
          s=FastMath.sin(2 * theta);
          c2=c * c;
          s2=s * s;
          cs=c * s;
          Tr[0][0]=T3r[0][0];
          Tr[0][1]=T3r[0][1] * c - T3r[0][2] * s;
          Ti[0][1]=T3i[0][1] * c - T3i[0][2] * s;
          Tr[0][2]=T3r[0][1] * s + T3r[0][2] * c;
          Ti[0][2]=T3i[0][1] * s + T3i[0][2] * c;
          Tr[1][1]=T3r[1][1] * c2 + T3r[2][2] * s2 - 2 * T3r[1][2] * cs;
          Tr[1][2]=T3r[1][2] * (c2 - s2) + (T3r[1][1] - T3r[2][2]) * cs;
          Ti[1][2]=T3i[1][2];
          Tr[2][2]=T3r[1][1] * s2 + T3r[2][2] * c2 + 2 * T3r[1][2] * cs;
          saveT3(Tr,Ti,tgtIdx,targetDataBuffers);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}"
11506,"private static ProductData.UTC getStartTime(final BinaryRecord sceneRec,final MetadataElement origProductMetadata,final String tagInSummary){
  ProductData.UTC time=getUTCScanStartTime(sceneRec,null);
  if (time.equalElems(AbstractMetadata.NO_METADATA_UTC)) {
    try {
      ProductData.UTC summaryTime=null;
      final MetadataElement summaryElem=origProductMetadata.getElement(""String_Node_Str"");
      if (summaryElem != null) {
        for (        MetadataAttribute sum : summaryElem.getAttributes()) {
          if (sum.getName().contains(tagInSummary)) {
            summaryTime=AbstractMetadata.parseUTC(summaryElem.getAttributeString(sum.getName().trim()),dateFormat2);
          }
        }
      }
      ProductData.UTC workReportTime=null;
      final MetadataElement workReportElem=origProductMetadata.getElement(""String_Node_Str"");
      if (workReportElem != null) {
        String valueStr=workReportElem.getAttributeString(""String_Node_Str"");
        if (valueStr != null && valueStr.length() > 0) {
          workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
        }
        if (workReportTime == null) {
          valueStr=workReportElem.getAttributeString(""String_Node_Str"");
          if (valueStr != null && valueStr.length() > 0) {
            workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
          }
        }
      }
      ProductData.UTC imgRecTime=null;
      final MetadataElement imageDescriptorElem=origProductMetadata.getElement(""String_Node_Str"");
      if (imageDescriptorElem != null) {
        final MetadataElement imageRecordElem=imageDescriptorElem.getElement(""String_Node_Str"");
        if (imageRecordElem != null) {
          final int year=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int days=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int milliseconds=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int days_since_2000=(year - 2000) * 365 + days + 1;
          final int seconds=milliseconds / 1000;
          final int microseconds=(milliseconds - seconds * 1000) * 1000;
          imgRecTime=new ProductData.UTC(days_since_2000,seconds,microseconds);
        }
      }
      if (summaryTime != null)       return summaryTime;
 else       if (workReportTime != null)       return workReportTime;
      return imgRecTime;
    }
 catch (    Exception e) {
      time=AbstractMetadata.NO_METADATA_UTC;
    }
  }
  return time;
}","private static ProductData.UTC getStartTime(final BinaryRecord sceneRec,final MetadataElement origProductMetadata,final String tagInSummary){
  ProductData.UTC time=getUTCScanStartTime(sceneRec,null);
  if (time.equalElems(AbstractMetadata.NO_METADATA_UTC)) {
    try {
      ProductData.UTC summaryTime=null;
      final MetadataElement summaryElem=origProductMetadata.getElement(""String_Node_Str"");
      if (summaryElem != null) {
        for (        MetadataAttribute sum : summaryElem.getAttributes()) {
          if (sum.getName().contains(tagInSummary)) {
            summaryTime=AbstractMetadata.parseUTC(summaryElem.getAttributeString(sum.getName().trim()),dateFormat2);
          }
        }
      }
      ProductData.UTC workReportTime=null;
      final MetadataElement workReportElem=origProductMetadata.getElement(""String_Node_Str"");
      if (workReportElem != null) {
        String valueStr=workReportElem.getAttributeString(""String_Node_Str"");
        if (valueStr != null && valueStr.length() > 0) {
          workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
        }
        if (workReportTime == null) {
          valueStr=workReportElem.getAttributeString(""String_Node_Str"");
          if (valueStr != null && valueStr.length() > 0) {
            workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
          }
        }
      }
      ProductData.UTC imgRecTime=null;
      final MetadataElement imageDescriptorElem=origProductMetadata.getElement(""String_Node_Str"");
      if (imageDescriptorElem != null) {
        final MetadataElement imageRecordElem=imageDescriptorElem.getElement(""String_Node_Str"");
        if (imageRecordElem != null) {
          final int year=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int days=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int milliseconds=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          StringBuffer sb=new StringBuffer(String.valueOf(year));
          String dayStr=String.valueOf(days);
          for (int i=dayStr.length(); i < 3; i++) {
            sb.append('0');
          }
          sb.append(dayStr);
          String millisecondStr=String.valueOf(milliseconds);
          for (int i=millisecondStr.length(); i < 8; i++) {
            sb.append('0');
          }
          sb.append(millisecondStr);
          imgRecTime=ProductData.UTC.parse(sb.toString(),dateFormat3);
        }
      }
      if (summaryTime != null)       return summaryTime;
 else       if (workReportTime != null)       return workReportTime;
      return imgRecTime;
    }
 catch (    Exception e) {
      time=AbstractMetadata.NO_METADATA_UTC;
    }
  }
  return time;
}"
11507,"/** 
 * Add user selected bands to target product.
 */
private void addSelectedBands(){
  final Band[] sourceBands=OperatorUtils.getSourceBands(sourceProduct,sourceBandNames);
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
  String tgtBandName;
  String tgtUnit;
  for (int i=0; i < sourceBands.length; i++) {
    final Band srcBand=sourceBands[i];
    final String srcBandName=srcBand.getName();
    final String unit=srcBand.getUnit();
    if (unit == null) {
      throw new OperatorException(""String_Node_Str"" + srcBandName + ""String_Node_Str"");
    }
    if (unit.contains(Unit.DB)) {
      throw new OperatorException(""String_Node_Str"");
    }
 else     if (unit.contains(Unit.PHASE)) {
      continue;
    }
 else     if (unit.contains(Unit.IMAGINARY)) {
      throw new OperatorException(""String_Node_Str"");
    }
 else     if (unit.contains(Unit.REAL)) {
      if (i + 1 >= sourceBands.length) {
        throw new OperatorException(""String_Node_Str"");
      }
      final String nextUnit=sourceBands[i + 1].getUnit();
      if (nextUnit == null || !nextUnit.contains(Unit.IMAGINARY)) {
        throw new OperatorException(""String_Node_Str"");
      }
      tgtBandName=srcBandName;
      tgtUnit=unit;
    }
 else {
      final String pol=OperatorUtils.getBandPolarization(srcBandName,absRoot);
      tgtBandName=""String_Node_Str"";
      if (pol != null && !pol.isEmpty()) {
        tgtBandName=""String_Node_Str"" + pol.toUpperCase();
      }
      tgtUnit=Unit.INTENSITY;
    }
    if (targetProduct.getBand(tgtBandName) == null) {
      Band tgtBand=targetProduct.addBand(tgtBandName,ProductData.TYPE_FLOAT32);
      tgtBand.setUnit(tgtUnit);
      targetBandToSourceBandMap.put(tgtBand,srcBand);
    }
  }
  if (outputSimulatedImage) {
    Band tgtBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
    tgtBand.setUnit(""String_Node_Str"");
  }
  targetBands=targetProduct.getBands();
  for (int i=0; i < targetBands.length; ++i) {
    if (targetBands[i].getUnit().equals(Unit.REAL)) {
      final String trgBandName=targetBands[i].getName();
      final String suffix=trgBandName.substring(trgBandName.indexOf(""String_Node_Str""));
      ReaderUtils.createVirtualIntensityBand(targetProduct,targetBands[i],targetBands[i + 1],""String_Node_Str"",suffix);
    }
  }
}","/** 
 * Add user selected bands to target product.
 */
private void addSelectedBands(){
  final Band[] sourceBands=OperatorUtils.getSourceBands(sourceProduct,sourceBandNames);
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
  String tgtBandName;
  String tgtUnit;
  for (int i=0; i < sourceBands.length; i++) {
    final Band srcBand=sourceBands[i];
    final String srcBandName=srcBand.getName();
    final String unit=srcBand.getUnit();
    if (unit == null) {
      throw new OperatorException(""String_Node_Str"" + srcBandName + ""String_Node_Str"");
    }
    if (unit.contains(Unit.DB)) {
      throw new OperatorException(""String_Node_Str"");
    }
 else     if (unit.contains(Unit.PHASE)) {
      continue;
    }
 else     if (unit.contains(Unit.REAL) || unit.contains(Unit.IMAGINARY)) {
      tgtBandName=srcBandName;
      tgtUnit=unit;
    }
 else {
      final String pol=OperatorUtils.getBandPolarization(srcBandName,absRoot);
      tgtBandName=""String_Node_Str"";
      if (pol != null && !pol.isEmpty()) {
        tgtBandName=""String_Node_Str"" + pol.toUpperCase();
      }
      tgtUnit=Unit.INTENSITY;
    }
    if (targetProduct.getBand(tgtBandName) == null) {
      Band tgtBand=targetProduct.addBand(tgtBandName,ProductData.TYPE_FLOAT32);
      tgtBand.setUnit(tgtUnit);
      targetBandToSourceBandMap.put(tgtBand,srcBand);
    }
  }
  if (outputSimulatedImage) {
    Band tgtBand=targetProduct.addBand(""String_Node_Str"",ProductData.TYPE_FLOAT32);
    tgtBand.setUnit(""String_Node_Str"");
  }
  targetBands=targetProduct.getBands();
  for (int i=0; i < targetBands.length; ++i) {
    if (targetBands[i].getUnit().equals(Unit.REAL)) {
      final String trgBandName=targetBands[i].getName();
      final int idx=trgBandName.indexOf(""String_Node_Str"");
      String suffix=""String_Node_Str"";
      if (idx != -1) {
        suffix=trgBandName.substring(trgBandName.indexOf(""String_Node_Str""));
      }
      ReaderUtils.createVirtualIntensityBand(targetProduct,targetBands[i],targetBands[i + 1],""String_Node_Str"",suffix);
    }
  }
}"
11508,"private static ProductData.UTC getEndTime(final BinaryRecord sceneRec,final MetadataElement origProductMetadata,final String tagInSummary,final ProductData.UTC startTime){
  ProductData.UTC time=getUTCScanStartTime(sceneRec,null);
  if (time.equalElems(AbstractMetadata.NO_METADATA_UTC)) {
    try {
      ProductData.UTC summaryTime=null;
      final MetadataElement summaryElem=origProductMetadata.getElement(""String_Node_Str"");
      if (summaryElem != null) {
        for (        MetadataAttribute sum : summaryElem.getAttributes()) {
          if (sum.getName().contains(tagInSummary)) {
            summaryTime=AbstractMetadata.parseUTC(summaryElem.getAttributeString(sum.getName().trim()),dateFormat2);
          }
        }
      }
      ProductData.UTC workReportTime=null;
      final MetadataElement workReportElem=origProductMetadata.getElement(""String_Node_Str"");
      if (workReportElem != null) {
        String valueStr=workReportElem.getAttributeString(""String_Node_Str"");
        if (valueStr != null && valueStr.length() > 0) {
          workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
        }
        if (workReportTime == null) {
          valueStr=workReportElem.getAttributeString(""String_Node_Str"");
          if (valueStr != null && valueStr.length() > 0) {
            workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
          }
        }
        if (workReportTime == null) {
          for (          MetadataAttribute workRep : workReportElem.getAttributes()) {
            if (workRep.getName().contains(""String_Node_Str"")) {
              final ProductData.UTC centreTime=AbstractMetadata.parseUTC(workReportElem.getAttributeString(workRep.getName().trim()),dateFormat2);
              final double diff=centreTime.getMJD() - startTime.getMJD();
              workReportTime=new ProductData.UTC(startTime.getMJD() + (diff * 2.0));
            }
          }
        }
      }
      ProductData.UTC imgRecTime=null;
      final MetadataElement imageDescriptorElem=origProductMetadata.getElement(""String_Node_Str"");
      if (imageDescriptorElem != null) {
        final int numRecords=imageDescriptorElem.getAttributeInt(""String_Node_Str"",0);
        final MetadataElement imageRecordElem=imageDescriptorElem.getElement(""String_Node_Str"");
        if (imageRecordElem != null) {
          final int year=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int days=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          double milliseconds=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final double prf=imageRecordElem.getAttributeDouble(""String_Node_Str"",0);
          final int days_since_2000=(year - 2000) * 365 + days + 1;
          milliseconds+=(double)(numRecords - 1) * Constants.oneMillion / prf;
          final int seconds=(int)(milliseconds / 1000);
          final double microseconds=(milliseconds - seconds * 1000.0) * 1000.0;
          imgRecTime=new ProductData.UTC(days_since_2000,seconds,(int)microseconds);
        }
      }
      if (summaryTime != null)       return summaryTime;
 else       if (workReportTime != null)       return workReportTime;
 else       if (imgRecTime != null)       return imgRecTime;
      final String centreTimeStr=sceneRec.getAttributeString(""String_Node_Str"");
      final ProductData.UTC centreTime=AbstractMetadata.parseUTC(centreTimeStr.trim(),dateFormat1);
      final double diff=centreTime.getMJD() - startTime.getMJD();
      return new ProductData.UTC(startTime.getMJD() + (diff * 2.0));
    }
 catch (    Exception e) {
      time=AbstractMetadata.NO_METADATA_UTC;
    }
  }
  return time;
}","private static ProductData.UTC getEndTime(final BinaryRecord sceneRec,final MetadataElement origProductMetadata,final String tagInSummary,final ProductData.UTC startTime){
  ProductData.UTC time=getUTCScanStartTime(sceneRec,null);
  if (time.equalElems(AbstractMetadata.NO_METADATA_UTC)) {
    try {
      ProductData.UTC summaryTime=null;
      final MetadataElement summaryElem=origProductMetadata.getElement(""String_Node_Str"");
      if (summaryElem != null) {
        for (        MetadataAttribute sum : summaryElem.getAttributes()) {
          if (sum.getName().contains(tagInSummary)) {
            summaryTime=AbstractMetadata.parseUTC(summaryElem.getAttributeString(sum.getName().trim()),dateFormat2);
          }
        }
      }
      ProductData.UTC workReportTime=null;
      final MetadataElement workReportElem=origProductMetadata.getElement(""String_Node_Str"");
      if (workReportElem != null) {
        String valueStr=workReportElem.getAttributeString(""String_Node_Str"");
        if (valueStr != null && valueStr.length() > 0) {
          workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
        }
        if (workReportTime == null) {
          valueStr=workReportElem.getAttributeString(""String_Node_Str"");
          if (valueStr != null && valueStr.length() > 0) {
            workReportTime=AbstractMetadata.parseUTC(valueStr,dateFormat2);
          }
        }
        if (workReportTime == null) {
          for (          MetadataAttribute workRep : workReportElem.getAttributes()) {
            if (workRep.getName().contains(""String_Node_Str"")) {
              final ProductData.UTC centreTime=AbstractMetadata.parseUTC(workReportElem.getAttributeString(workRep.getName().trim()),dateFormat2);
              final double diff=centreTime.getMJD() - startTime.getMJD();
              workReportTime=new ProductData.UTC(startTime.getMJD() + (diff * 2.0));
            }
          }
        }
      }
      ProductData.UTC imgRecTime=null;
      final MetadataElement imageDescriptorElem=origProductMetadata.getElement(""String_Node_Str"");
      if (imageDescriptorElem != null) {
        final int numRecords=imageDescriptorElem.getAttributeInt(""String_Node_Str"",0);
        final MetadataElement imageRecordElem=imageDescriptorElem.getElement(""String_Node_Str"");
        if (imageRecordElem != null) {
          final int year=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final int days=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          int milliseconds=imageRecordElem.getAttributeInt(""String_Node_Str"",0);
          final double prf=imageRecordElem.getAttributeDouble(""String_Node_Str"",0);
          milliseconds+=(int)((numRecords - 1) * Constants.oneMillion / prf);
          StringBuffer sb=new StringBuffer(String.valueOf(year));
          String dayStr=String.valueOf(days);
          for (int i=dayStr.length(); i < 3; i++) {
            sb.append('0');
          }
          sb.append(dayStr);
          String millisecondStr=String.valueOf(milliseconds);
          for (int i=millisecondStr.length(); i < 8; i++) {
            sb.append('0');
          }
          sb.append(millisecondStr);
          imgRecTime=ProductData.UTC.parse(sb.toString(),dateFormat3);
        }
      }
      if (summaryTime != null)       return summaryTime;
 else       if (workReportTime != null)       return workReportTime;
 else       if (imgRecTime != null)       return imgRecTime;
      final String centreTimeStr=sceneRec.getAttributeString(""String_Node_Str"");
      final ProductData.UTC centreTime=AbstractMetadata.parseUTC(centreTimeStr.trim(),dateFormat1);
      final double diff=centreTime.getMJD() - startTime.getMJD();
      return new ProductData.UTC(startTime.getMJD() + (diff * 2.0));
    }
 catch (    Exception e) {
      time=AbstractMetadata.NO_METADATA_UTC;
    }
  }
  return time;
}"
11509,"public static String getPolarType(final Product product) throws Exception {
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(product);
  if (absRoot != null) {
    final String pol1=absRoot.getAttributeString(AbstractMetadata.mds1_tx_rx_polar,""String_Node_Str"").trim();
    final String pol2=absRoot.getAttributeString(AbstractMetadata.mds2_tx_rx_polar,""String_Node_Str"").trim();
    final String pol3=absRoot.getAttributeString(AbstractMetadata.mds3_tx_rx_polar,""String_Node_Str"").trim();
    final String pol4=absRoot.getAttributeString(AbstractMetadata.mds4_tx_rx_polar,""String_Node_Str"").trim();
    if (!pol1.isEmpty() && !pol2.isEmpty()) {
      if (!pol3.isEmpty() && !pol4.isEmpty()) {
        return ""String_Node_Str"";
      }
      return ""String_Node_Str"";
    }
  }
  return ""String_Node_Str"";
}","public static String getPolarType(final Product product) throws Exception {
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(product);
  if (absRoot != null) {
    if (!AbstractMetadata.isNoData(absRoot,AbstractMetadata.mds1_tx_rx_polar) && !AbstractMetadata.isNoData(absRoot,AbstractMetadata.mds2_tx_rx_polar)) {
      if (!AbstractMetadata.isNoData(absRoot,AbstractMetadata.mds3_tx_rx_polar) && !AbstractMetadata.isNoData(absRoot,AbstractMetadata.mds4_tx_rx_polar)) {
        return ""String_Node_Str"";
      }
      return ""String_Node_Str"";
    }
  }
  return ""String_Node_Str"";
}"
11510,"private void addFirstLastLineTimes(final int rasterHeight){
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(product);
  final MetadataElement root=AbstractMetadata.getOriginalProductMetadata(product);
  final MetadataElement globalElem=root.getElement(NetcdfConstants.GLOBAL_ATTRIBUTES_NAME);
  final MetadataElement bandElem=getBandElement(product.getBandAt(0));
  final double referenceUTC=ReaderUtils.getTime(globalElem,""String_Node_Str"",AbstractMetadata.dateFormat).getMJD();
  double firstLineTime=bandElem.getAttributeDouble(""String_Node_Str"",0) / (24 * 3600);
  if (firstLineTime == 0) {
    firstLineTime=globalElem.getElement(""String_Node_Str"").getElement(""String_Node_Str"").getAttributeDouble(""String_Node_Str"") / (24 * 3600);
  }
  double lastLineTime=bandElem.getAttributeDouble(""String_Node_Str"",0) / (24 * 3600);
  if (lastLineTime == 0) {
    lastLineTime=globalElem.getElement(""String_Node_Str"").getElement(""String_Node_Str"").getAttributeDouble(""String_Node_Str"") / (24 * 3600);
  }
  double lineTimeInterval=bandElem.getAttributeDouble(""String_Node_Str"",0);
  final ProductData.UTC startTime=new ProductData.UTC(referenceUTC + firstLineTime);
  final ProductData.UTC stopTime=new ProductData.UTC(referenceUTC + lastLineTime);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_line_time,startTime);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_line_time,stopTime);
  product.setStartTime(startTime);
  product.setEndTime(stopTime);
  if (lineTimeInterval == 0) {
    lineTimeInterval=ReaderUtils.getLineTimeInterval(startTime,stopTime,rasterHeight);
  }
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.line_time_interval,lineTimeInterval);
}","private void addFirstLastLineTimes(final int rasterHeight){
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(product);
  final MetadataElement root=AbstractMetadata.getOriginalProductMetadata(product);
  final MetadataElement globalElem=root.getElement(NetcdfConstants.GLOBAL_ATTRIBUTES_NAME);
  final MetadataElement bandElem=getBandElement(product.getBandAt(0));
  final double referenceUTC=ReaderUtils.getTime(globalElem,""String_Node_Str"",AbstractMetadata.dateFormat).getMJD();
  double firstLineTime=bandElem.getAttributeDouble(""String_Node_Str"",0) / (24 * 3600);
  if (firstLineTime == 0) {
    final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"");
    if (s01Elem != null) {
      firstLineTime=s01Elem.getElement(""String_Node_Str"").getAttributeDouble(""String_Node_Str"") / (24 * 3600);
    }
 else {
      firstLineTime=globalElem.getAttributeDouble(""String_Node_Str"") / (24 * 3600);
    }
  }
  double lastLineTime=bandElem.getAttributeDouble(""String_Node_Str"",0) / (24 * 3600);
  if (lastLineTime == 0) {
    final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"");
    if (s01Elem != null) {
      lastLineTime=s01Elem.getElement(""String_Node_Str"").getAttributeDouble(""String_Node_Str"") / (24 * 3600);
    }
 else {
      lastLineTime=globalElem.getAttributeDouble(""String_Node_Str"") / (24 * 3600);
    }
  }
  double lineTimeInterval=bandElem.getAttributeDouble(""String_Node_Str"",0);
  final ProductData.UTC startTime=new ProductData.UTC(referenceUTC + firstLineTime);
  final ProductData.UTC stopTime=new ProductData.UTC(referenceUTC + lastLineTime);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.first_line_time,startTime);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.last_line_time,stopTime);
  product.setStartTime(startTime);
  product.setEndTime(stopTime);
  if (lineTimeInterval == 0) {
    lineTimeInterval=ReaderUtils.getLineTimeInterval(startTime,stopTime,rasterHeight);
  }
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.line_time_interval,lineTimeInterval);
}"
11511,"private void addAbstractedMetadataHeader(Product product,MetadataElement root) throws IOException {
  final MetadataElement absRoot=AbstractMetadata.addAbstractedMetadataHeader(root);
  final String defStr=AbstractMetadata.NO_METADATA_STRING;
  final int defInt=AbstractMetadata.NO_METADATA;
  final MetadataElement globalElem=AbstractMetadata.addOriginalProductMetadata(product.getMetadataRoot()).getElement(NetcdfConstants.GLOBAL_ATTRIBUTES_NAME);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PRODUCT,globalElem.getAttributeString(""String_Node_Str"",defStr));
  final String productType=globalElem.getAttributeString(""String_Node_Str"",defStr);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PRODUCT_TYPE,productType);
  final String mode=globalElem.getAttributeString(""String_Node_Str"",defStr);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.SPH_DESCRIPTOR,mode);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ACQUISITION_MODE,mode);
  if (mode.contains(""String_Node_Str"") && productType.contains(""String_Node_Str"")) {
    throw new IOException(""String_Node_Str"" + mode + ""String_Node_Str"");
  }
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.MISSION,globalElem.getAttributeString(""String_Node_Str"",""String_Node_Str""));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PROC_TIME,ReaderUtils.getTime(globalElem,""String_Node_Str"",AbstractMetadata.dateFormat));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ProcessingSystemIdentifier,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.antenna_pointing,globalElem.getAttributeString(""String_Node_Str"",defStr).toLowerCase());
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ABS_ORBIT,globalElem.getAttributeInt(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PASS,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.SAMPLE_TYPE,getSampleType(globalElem));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.num_output_lines,product.getSceneRasterHeight());
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.num_samples_per_line,product.getSceneRasterWidth());
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.TOT_SIZE,ReaderUtils.getTotalSize(product));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.radar_frequency,globalElem.getAttributeDouble(""String_Node_Str"",defInt) / Constants.oneMillion);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.algorithm,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.geo_ref_system,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_looks,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.azimuth_looks,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  if (productType.contains(""String_Node_Str"")) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.map_projection,globalElem.getAttributeString(""String_Node_Str"",defStr));
  }
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.coregistered_stack,0);
  final String rngSpreadComp=globalElem.getAttributeString(""String_Node_Str"",defStr);
  if (rngSpreadComp.equals(""String_Node_Str""))   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_spread_comp_flag,0);
 else   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_spread_comp_flag,1);
  final String incAngComp=globalElem.getAttributeString(""String_Node_Str"",defStr);
  if (incAngComp.equals(""String_Node_Str""))   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.inc_angle_comp_flag,0);
 else   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.inc_angle_comp_flag,1);
  final String antElevComp=globalElem.getAttributeString(""String_Node_Str"",defStr);
  if (antElevComp.equals(""String_Node_Str""))   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ant_elev_corr_flag,0);
 else   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ant_elev_corr_flag,1);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ref_inc_angle,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ref_slant_range,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ref_slant_range_exp,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.rescaling_factor,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"");
  if (s01Elem != null) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.pulse_repetition_frequency,s01Elem.getAttributeDouble(""String_Node_Str"",defInt));
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_sampling_rate,s01Elem.getAttributeDouble(""String_Node_Str"",defInt) / Constants.oneMillion);
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.mds1_tx_rx_polar,s01Elem.getAttributeString(""String_Node_Str"",defStr));
    final double rangeBW=s01Elem.getAttributeDouble(""String_Node_Str"");
    final double azimuthBW=s01Elem.getAttributeDouble(""String_Node_Str"");
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_bandwidth,rangeBW / Constants.oneMillion);
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.azimuth_bandwidth,azimuthBW);
  }
  final MetadataElement s02Elem=globalElem.getElement(""String_Node_Str"");
  if (s02Elem != null) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.mds2_tx_rx_polar,s02Elem.getAttributeString(""String_Node_Str"",defStr));
  }
  if (isComplex) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.srgr_flag,0);
  }
 else {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.srgr_flag,1);
  }
  addOrbitStateVectors(absRoot,globalElem);
}","private void addAbstractedMetadataHeader(Product product,MetadataElement root) throws IOException {
  final MetadataElement absRoot=AbstractMetadata.addAbstractedMetadataHeader(root);
  final String defStr=AbstractMetadata.NO_METADATA_STRING;
  final int defInt=AbstractMetadata.NO_METADATA;
  final MetadataElement globalElem=AbstractMetadata.addOriginalProductMetadata(product.getMetadataRoot()).getElement(NetcdfConstants.GLOBAL_ATTRIBUTES_NAME);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PRODUCT,globalElem.getAttributeString(""String_Node_Str"",defStr));
  final String productType=globalElem.getAttributeString(""String_Node_Str"",defStr);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PRODUCT_TYPE,productType);
  final String mode=globalElem.getAttributeString(""String_Node_Str"",defStr);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.SPH_DESCRIPTOR,mode);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ACQUISITION_MODE,mode);
  if (mode.contains(""String_Node_Str"") && productType.contains(""String_Node_Str"")) {
    throw new IOException(""String_Node_Str"" + mode + ""String_Node_Str"");
  }
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.MISSION,""String_Node_Str"");
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PROC_TIME,ReaderUtils.getTime(globalElem,""String_Node_Str"",AbstractMetadata.dateFormat));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ProcessingSystemIdentifier,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.antenna_pointing,globalElem.getAttributeString(""String_Node_Str"",defStr).toLowerCase());
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ABS_ORBIT,globalElem.getAttributeInt(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.PASS,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.SAMPLE_TYPE,getSampleType(globalElem));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.num_output_lines,product.getSceneRasterHeight());
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.num_samples_per_line,product.getSceneRasterWidth());
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.TOT_SIZE,ReaderUtils.getTotalSize(product));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.radar_frequency,globalElem.getAttributeDouble(""String_Node_Str"",defInt) / Constants.oneMillion);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.algorithm,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.geo_ref_system,globalElem.getAttributeString(""String_Node_Str"",defStr));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_looks,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.azimuth_looks,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  if (productType.contains(""String_Node_Str"")) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.map_projection,globalElem.getAttributeString(""String_Node_Str"",defStr));
  }
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.coregistered_stack,0);
  final String rngSpreadComp=globalElem.getAttributeString(""String_Node_Str"",defStr);
  if (rngSpreadComp.equals(""String_Node_Str""))   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_spread_comp_flag,0);
 else   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_spread_comp_flag,1);
  final String incAngComp=globalElem.getAttributeString(""String_Node_Str"",defStr);
  if (incAngComp.equals(""String_Node_Str""))   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.inc_angle_comp_flag,0);
 else   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.inc_angle_comp_flag,1);
  final String antElevComp=globalElem.getAttributeString(""String_Node_Str"",defStr);
  if (antElevComp.equals(""String_Node_Str""))   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ant_elev_corr_flag,0);
 else   AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ant_elev_corr_flag,1);
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ref_inc_angle,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ref_slant_range,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.ref_slant_range_exp,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  AbstractMetadata.setAttribute(absRoot,AbstractMetadata.rescaling_factor,globalElem.getAttributeDouble(""String_Node_Str"",defInt));
  final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"");
  if (s01Elem != null) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.pulse_repetition_frequency,s01Elem.getAttributeDouble(""String_Node_Str"",defInt));
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_sampling_rate,s01Elem.getAttributeDouble(""String_Node_Str"",defInt) / Constants.oneMillion);
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.mds1_tx_rx_polar,s01Elem.getAttributeString(""String_Node_Str"",defStr));
    final double rangeBW=s01Elem.getAttributeDouble(""String_Node_Str"");
    final double azimuthBW=s01Elem.getAttributeDouble(""String_Node_Str"");
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_bandwidth,rangeBW / Constants.oneMillion);
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.azimuth_bandwidth,azimuthBW);
  }
 else {
    final String prefix=""String_Node_Str"";
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.pulse_repetition_frequency,globalElem.getAttributeDouble(prefix + ""String_Node_Str"",defInt));
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_sampling_rate,globalElem.getAttributeDouble(prefix + ""String_Node_Str"",defInt) / Constants.oneMillion);
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.mds1_tx_rx_polar,globalElem.getAttributeString(prefix + ""String_Node_Str"",defStr));
    final double rangeBW=globalElem.getAttributeDouble(prefix + ""String_Node_Str"");
    final double azimuthBW=globalElem.getAttributeDouble(prefix + ""String_Node_Str"");
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.range_bandwidth,rangeBW / Constants.oneMillion);
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.azimuth_bandwidth,azimuthBW);
  }
  final MetadataElement s02Elem=globalElem.getElement(""String_Node_Str"");
  if (s02Elem != null) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.mds2_tx_rx_polar,s02Elem.getAttributeString(""String_Node_Str"",defStr));
  }
 else {
    final String prefix=""String_Node_Str"";
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.mds2_tx_rx_polar,globalElem.getAttributeString(prefix + ""String_Node_Str"",defStr));
  }
  if (isComplex) {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.srgr_flag,0);
  }
 else {
    AbstractMetadata.setAttribute(absRoot,AbstractMetadata.srgr_flag,1);
  }
  addOrbitStateVectors(absRoot,globalElem);
}"
11512,"private static String getPolarization(final Product product,final int cnt){
  final MetadataElement globalElem=AbstractMetadata.getOriginalProductMetadata(product).getElement(NetcdfConstants.GLOBAL_ATTRIBUTES_NAME);
  if (globalElem != null) {
    final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"" + cnt);
    if (s01Elem != null) {
      final String polStr=s01Elem.getAttributeString(""String_Node_Str"",""String_Node_Str"");
      if (!polStr.isEmpty())       return polStr;
    }
  }
  return null;
}","private static String getPolarization(final Product product,final int cnt){
  final MetadataElement globalElem=AbstractMetadata.getOriginalProductMetadata(product).getElement(NetcdfConstants.GLOBAL_ATTRIBUTES_NAME);
  if (globalElem != null) {
    final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"" + cnt);
    if (s01Elem != null) {
      final String polStr=s01Elem.getAttributeString(""String_Node_Str"",""String_Node_Str"");
      if (!polStr.isEmpty())       return polStr;
    }
 else {
      final String prefix=""String_Node_Str"" + cnt + '_';
      final String polStr=globalElem.getAttributeString(prefix + ""String_Node_Str"",""String_Node_Str"");
      if (!polStr.isEmpty())       return polStr;
    }
  }
  return null;
}"
11513,"/** 
 * Get calibration factors from abstracted metadata.
 */
private void getCalibrationFactors(){
  String pol;
  double factor=0.0;
  final MetadataElement globalElem=origMetadataRoot.getElement(""String_Node_Str"");
  final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"");
  if (s01Elem != null) {
    pol=s01Elem.getAttributeString(""String_Node_Str"").toUpperCase();
    factor=s01Elem.getAttributeDouble(""String_Node_Str"");
    calibrationFactor.put(pol,factor);
  }
  final MetadataElement s02Elem=globalElem.getElement(""String_Node_Str"");
  if (s02Elem != null) {
    pol=s02Elem.getAttributeString(""String_Node_Str"").toUpperCase();
    factor=s02Elem.getAttributeDouble(""String_Node_Str"");
    calibrationFactor.put(pol,factor);
  }
  referenceSlantRange=absRoot.getAttributeDouble(AbstractMetadata.ref_slant_range);
  referenceSlantRangeExp=absRoot.getAttributeDouble(AbstractMetadata.ref_slant_range_exp);
  referenceIncidenceAngle=absRoot.getAttributeDouble(AbstractMetadata.ref_inc_angle) * Math.PI / 180.0;
  rescalingFactor=absRoot.getAttributeDouble(AbstractMetadata.rescaling_factor);
}","/** 
 * Get calibration factors from abstracted metadata.
 */
private void getCalibrationFactors(){
  String pol;
  double factor=0.0;
  final MetadataElement globalElem=origMetadataRoot.getElement(""String_Node_Str"");
  final MetadataElement s01Elem=globalElem.getElement(""String_Node_Str"");
  if (s01Elem != null) {
    pol=s01Elem.getAttributeString(""String_Node_Str"").toUpperCase();
    factor=s01Elem.getAttributeDouble(""String_Node_Str"");
    calibrationFactor.put(pol,factor);
  }
 else {
    pol=globalElem.getAttributeString(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"").toUpperCase();
    if (!pol.isEmpty()) {
      factor=globalElem.getAttributeDouble(""String_Node_Str"" + ""String_Node_Str"");
      calibrationFactor.put(pol,factor);
    }
  }
  final MetadataElement s02Elem=globalElem.getElement(""String_Node_Str"");
  if (s02Elem != null) {
    pol=s02Elem.getAttributeString(""String_Node_Str"").toUpperCase();
    factor=s02Elem.getAttributeDouble(""String_Node_Str"");
    calibrationFactor.put(pol,factor);
  }
 else {
    pol=globalElem.getAttributeString(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"").toUpperCase();
    if (!pol.isEmpty()) {
      factor=globalElem.getAttributeDouble(""String_Node_Str"" + ""String_Node_Str"");
      calibrationFactor.put(pol,factor);
    }
  }
  referenceSlantRange=absRoot.getAttributeDouble(AbstractMetadata.ref_slant_range);
  referenceSlantRangeExp=absRoot.getAttributeDouble(AbstractMetadata.ref_slant_range_exp);
  referenceIncidenceAngle=absRoot.getAttributeDouble(AbstractMetadata.ref_inc_angle) * Math.PI / 180.0;
  rescalingFactor=absRoot.getAttributeDouble(AbstractMetadata.rescaling_factor);
}"
11514,"@Test public void testProcessAllCosmo() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsCosmoSkymed,null,exceptionExemptions);
}","@Test public void testProcessAllCosmo() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsCosmoSkymed,productTypeExemptions,exceptionExemptions);
}"
11515,"@Test public void testProcessAllALOS() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsALOS,null,exceptionExemptions);
}","@Test public void testProcessAllALOS() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsALOS,productTypeExemptions,exceptionExemptions);
}"
11516,"@Test public void testProcessAllRadarsat2() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsRadarsat2,null,exceptionExemptions);
}","@Test public void testProcessAllRadarsat2() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsRadarsat2,productTypeExemptions,exceptionExemptions);
}"
11517,"@Test public void testProcessAllTerraSARX() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsTerraSarX,null,exceptionExemptions);
}","@Test public void testProcessAllTerraSARX() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsTerraSarX,productTypeExemptions,exceptionExemptions);
}"
11518,"@Test public void testProcessAllSentinel1() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsSentinel1,null,exceptionExemptions);
}","@Test public void testProcessAllSentinel1() throws Exception {
  TestUtils.testProcessAllInPath(spi,TestUtils.rootPathsSentinel1,productTypeExemptions,exceptionExemptions);
}"
11519,"/** 
 * Processes a product and compares it to processed product known to be correct
 * @throws Exception general exception
 */
@Test public void testProcessing() throws Exception {
  final File inputFile=TestData.inputASAR_WSM;
  if (!inputFile.exists()) {
    TestUtils.skipTest(this,inputFile + ""String_Node_Str"");
    return;
  }
  final Product sourceProduct=TestUtils.readSourceProduct(inputFile);
  final GeolocationGridGeocodingOp op=(GeolocationGridGeocodingOp)spi.createOperator();
  assertNotNull(op);
  op.setSourceProduct(sourceProduct);
  final String[] excemptionList={""String_Node_Str""};
  final Product targetProduct=op.getTargetProduct();
  TestUtils.verifyProduct(targetProduct,true,true,true);
}","/** 
 * Processes a product and compares it to processed product known to be correct
 * @throws Exception general exception
 */
@Test public void testProcessing() throws Exception {
  final File inputFile=TestData.inputASAR_WSM;
  if (!inputFile.exists()) {
    TestUtils.skipTest(this,inputFile + ""String_Node_Str"");
    return;
  }
  final Product sourceProduct=TestUtils.readSourceProduct(inputFile);
  final GeolocationGridGeocodingOp op=(GeolocationGridGeocodingOp)spi.createOperator();
  assertNotNull(op);
  op.setSourceProduct(sourceProduct);
  final Product targetProduct=op.getTargetProduct();
  TestUtils.verifyProduct(targetProduct,true,true,true);
}"
11520,"/** 
 * Processes a product and compares it to processed product known to be correct
 * @throws Exception general exception
 */
@Test public void testProcessing() throws Exception {
  final File inputFile=new File(s1FolderFilePath);
  final Product sourceProduct=TestUtils.readSourceProduct(inputFile);
  final TOPSARDeburstOp op=(TOPSARDeburstOp)spi.createOperator();
  assertNotNull(op);
  op.setSourceProduct(sourceProduct);
  final Product targetProduct=op.getTargetProduct();
  TestUtils.verifyProduct(targetProduct,false,false);
  final Band targetBand=targetProduct.getBandAt(0);
  assertNotNull(targetBand);
  final int bandWidth=5000;
  final int bandHeight=5000;
  final float[] floatValues=new float[bandWidth * bandHeight];
  targetBand.readPixels(0,0,bandWidth,bandHeight,floatValues,ProgressMonitor.NULL);
}","/** 
 * Processes a product and compares it to processed product known to be correct
 * @throws Exception general exception
 */
@Test @Ignore public void testProcessing() throws Exception {
  final File inputFile=new File(s1FolderFilePath);
  final Product sourceProduct=TestUtils.readSourceProduct(inputFile);
  final TOPSARDeburstOp op=(TOPSARDeburstOp)spi.createOperator();
  assertNotNull(op);
  op.setSourceProduct(sourceProduct);
  final Product targetProduct=op.getTargetProduct();
  TestUtils.verifyProduct(targetProduct,false,false);
  final Band targetBand=targetProduct.getBandAt(0);
  assertNotNull(targetBand);
  final int bandWidth=5000;
  final int bandHeight=5000;
  final float[] floatValues=new float[bandWidth * bandHeight];
  targetBand.readPixels(0,0,bandWidth,bandHeight,floatValues,ProgressMonitor.NULL);
}"
11521,"public static void resetPolarizations(final MetadataElement absRoot,final int isPolsar,final int isCal){
  if (isPolsar > 0) {
    absRoot.setAttributeString(AbstractMetadata.mds1_tx_rx_polar,""String_Node_Str"");
    absRoot.setAttributeString(AbstractMetadata.mds2_tx_rx_polar,""String_Node_Str"");
    absRoot.setAttributeString(AbstractMetadata.mds3_tx_rx_polar,""String_Node_Str"");
    absRoot.setAttributeString(AbstractMetadata.mds4_tx_rx_polar,""String_Node_Str"");
    absRoot.setAttributeInt(AbstractMetadata.polsarData,1);
  }
  if (isCal > 0) {
    absRoot.setAttributeInt(AbstractMetadata.abs_calibration_flag,1);
  }
}","public static void resetPolarizations(final MetadataElement absRoot,final int isPolsar,final int isCal){
  if (isPolsar > 0) {
    absRoot.setAttributeString(AbstractMetadata.mds1_tx_rx_polar,AbstractMetadata.NO_METADATA_STRING);
    absRoot.setAttributeString(AbstractMetadata.mds2_tx_rx_polar,AbstractMetadata.NO_METADATA_STRING);
    absRoot.setAttributeString(AbstractMetadata.mds3_tx_rx_polar,AbstractMetadata.NO_METADATA_STRING);
    absRoot.setAttributeString(AbstractMetadata.mds4_tx_rx_polar,AbstractMetadata.NO_METADATA_STRING);
    absRoot.setAttributeInt(AbstractMetadata.polsarData,1);
  }
  if (isCal > 0) {
    absRoot.setAttributeInt(AbstractMetadata.abs_calibration_flag,1);
  }
}"
11522,"@Override protected String getCSName(final RasterDataNode raster){
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(raster.getProduct());
  final String mapProjStr=absRoot.getAttributeString(AbstractMetadata.map_projection,""String_Node_Str"").trim();
  if (!mapProjStr.isEmpty()) {
    return mapProjStr;
  }
  final GeoCoding geoCoding=raster.getGeoCoding();
  if (geoCoding instanceof MapGeoCoding || geoCoding instanceof CrsGeoCoding) {
    return geoCoding.getMapCRS().getName().toString();
  }
 else {
    return ""String_Node_Str"";
  }
}","@Override protected String getCSName(final RasterDataNode raster){
  final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(raster.getProduct());
  if (!AbstractMetadata.isNoData(absRoot,AbstractMetadata.map_projection)) {
    return absRoot.getAttributeString(AbstractMetadata.map_projection,AbstractMetadata.NO_METADATA_STRING);
  }
  final GeoCoding geoCoding=raster.getGeoCoding();
  if (geoCoding instanceof MapGeoCoding || geoCoding instanceof CrsGeoCoding) {
    return geoCoding.getMapCRS().getName().toString();
  }
 else {
    return ""String_Node_Str"";
  }
}"
11523,"private static Product createSubsampledProduct(final Product product) throws IOException {
  final String quicklookBandName=ProductUtils.findSuitableQuicklookBandName(product);
  final ProductSubsetDef productSubsetDef=new ProductSubsetDef(""String_Node_Str"");
  int scaleFactor=product.getSceneRasterWidth() / 1000;
  if (scaleFactor < 1) {
    scaleFactor=1;
  }
  productSubsetDef.setSubSampling(scaleFactor,scaleFactor);
  productSubsetDef.setTreatVirtualBandsAsRealBands(true);
  productSubsetDef.setNodeNames(new String[]{quicklookBandName});
  Product productSubset=product.createSubset(productSubsetDef,quicklookBandName,null);
  if (!isMapProjected(product)) {
    try {
      final Map<String,Object> projParameters=new HashMap<String,Object>();
      Map<String,Product> projProducts=new HashMap<String,Product>();
      projProducts.put(""String_Node_Str"",productSubset);
      projParameters.put(""String_Node_Str"",""String_Node_Str"");
      productSubset=GPF.createProduct(""String_Node_Str"",projParameters,projProducts);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return productSubset;
}","private static Product createSubsampledProduct(final Product product) throws IOException {
  final String quicklookBandName=ProductUtils.findSuitableQuicklookBandName(product);
  final ProductSubsetDef productSubsetDef=new ProductSubsetDef(""String_Node_Str"");
  int scaleFactor=product.getSceneRasterWidth() / 1000;
  if (scaleFactor < 1) {
    scaleFactor=1;
  }
  productSubsetDef.setSubSampling(scaleFactor,scaleFactor);
  productSubsetDef.setTreatVirtualBandsAsRealBands(true);
  productSubsetDef.setNodeNames(new String[]{quicklookBandName});
  Product productSubset=product.createSubset(productSubsetDef,quicklookBandName,null);
  if (!OperatorUtils.isMapProjected(product)) {
    try {
      final Map<String,Object> projParameters=new HashMap<String,Object>();
      Map<String,Product> projProducts=new HashMap<String,Product>();
      projProducts.put(""String_Node_Str"",productSubset);
      projParameters.put(""String_Node_Str"",""String_Node_Str"");
      productSubset=GPF.createProduct(""String_Node_Str"",projParameters,projProducts);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return productSubset;
}"
11524,"/** 
 * Get the variance of pixel intensities in a given rectanglar region.
 * @param neighborValues The pixel values in the given rectanglar region.
 * @param mean           of neighbourhood
 * @return var The variance value.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs in computation of the variance.
 */
private static double getVarianceValue(final double[] neighborValues,final double mean){
  double var=0.0;
  if (neighborValues.length > 1) {
    for (    double neighborValue : neighborValues) {
      final double diff=neighborValue - mean;
      var+=diff * diff;
    }
    var/=neighborValues.length;
  }
  return var;
}","/** 
 * Get the variance of pixel intensities in a given rectanglar region.
 * @param neighborValues The pixel values in the given rectanglar region.
 * @param mean           of neighbourhood
 * @return var The variance value.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs in computation of the variance.
 */
private static double getVarianceValue(final double[] neighborValues,final double mean){
  double var=0.0;
  if (neighborValues.length > 1) {
    for (    double neighborValue : neighborValues) {
      final double diff=neighborValue - mean;
      var+=diff * diff;
    }
    var/=(neighborValues.length - 1);
  }
  return var;
}"
11525,"private void computeZ98Values(final Tile sourceTile,final Rectangle sourceRectangle,final ProductData[] sourceDataBuffers,Z98 z98){
  final TileIndex srcIndex=new TileIndex(sourceTile);
  final int sx0=sourceRectangle.x;
  final int sy0=sourceRectangle.y;
  final int sw=sourceRectangle.width;
  final int sh=sourceRectangle.height;
  final int maxY=sy0 + sh;
  final int maxX=sx0 + sw;
  final int z98Index=(int)(sw * sh * 0.98);
  double[] t11=new double[sw * sh];
  double[] t22=new double[sw * sh];
  double[] t33=new double[sw * sh];
  final double[][] Tr=new double[3][3];
  final double[][] Ti=new double[3][3];
  int k=0;
  for (int y=sy0; y < maxY; y++) {
    srcIndex.calculateStride(y);
    for (int x=sx0; x < maxX; x++) {
      final int index=srcIndex.getIndex(x);
      PolOpUtils.getT3(index,sourceProductType,sourceDataBuffers,Tr,Ti);
      t11[k]=Tr[0][0];
      t22[k]=Tr[1][1];
      t33[k]=Tr[2][2];
      k++;
    }
  }
  Arrays.sort(t11);
  Arrays.sort(t22);
  Arrays.sort(t33);
  z98.t11=t11[z98Index];
  z98.t22=t22[z98Index];
  z98.t33=t33[z98Index];
}","private void computeZ98Values(final Tile sourceTile,final Rectangle sourceRectangle,final ProductData[] sourceDataBuffers,Z98 z98){
  final TileIndex srcIndex=new TileIndex(sourceTile);
  final int sx0=sourceRectangle.x;
  final int sy0=sourceRectangle.y;
  final int sw=sourceRectangle.width;
  final int sh=sourceRectangle.height;
  final int maxY=sy0 + sh;
  final int maxX=sx0 + sw;
  final int z98Index=(int)(sw * sh * 0.98) - 1;
  double[] t11=new double[sw * sh];
  double[] t22=new double[sw * sh];
  double[] t33=new double[sw * sh];
  final double[][] Tr=new double[3][3];
  final double[][] Ti=new double[3][3];
  int k=0;
  for (int y=sy0; y < maxY; y++) {
    srcIndex.calculateStride(y);
    for (int x=sx0; x < maxX; x++) {
      final int index=srcIndex.getIndex(x);
      PolOpUtils.getT3(index,sourceProductType,sourceDataBuffers,Tr,Ti);
      t11[k]=Tr[0][0];
      t22[k]=Tr[1][1];
      t33[k]=Tr[2][2];
      k++;
    }
  }
  Arrays.sort(t11);
  Arrays.sort(t22);
  Arrays.sort(t33);
  z98.t11=t11[z98Index];
  z98.t22=t22[z98Index];
  z98.t33=t33[z98Index];
}"
11526,"private void leeSigmaFilter(final Map<Band,Tile> targetTiles,final Rectangle targetRectangle){
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final Rectangle sourceRectangle=getSourceTileRectangle(x0,y0,w,h);
  final int sx0=sourceRectangle.x;
  final int sy0=sourceRectangle.y;
  final int sw=sourceRectangle.width;
  final int sh=sourceRectangle.height;
  final TileIndex trgIndex=new TileIndex(targetTiles.get(getTargetProduct().getBandAt(0)));
  for (  final PolBandUtils.QuadSourceBand bandList : srcBandList) {
    final Tile[] sourceTiles=new Tile[bandList.srcBands.length];
    final ProductData[] sourceDataBuffers=new ProductData[bandList.srcBands.length];
    for (int i=0; i < bandList.srcBands.length; ++i) {
      sourceTiles[i]=getSourceTile(bandList.srcBands[i],sourceRectangle);
      sourceDataBuffers[i]=sourceTiles[i].getDataBuffer();
    }
    final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
    final ProductData[] targetDataBuffers=new ProductData[9];
    for (    final Band targetBand : bandList.targetBands) {
      final String targetBandName=targetBand.getName();
      final ProductData dataBuffer=targetTiles.get(targetBand).getDataBuffer();
      if (targetBandName.contains(""String_Node_Str"") || targetBandName.contains(""String_Node_Str""))       targetDataBuffers[0]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[1]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[2]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[3]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[4]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str"") || targetBandName.contains(""String_Node_Str""))       targetDataBuffers[5]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[6]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[7]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str"") || targetBandName.contains(""String_Node_Str""))       targetDataBuffers[8]=dataBuffer;
    }
    Z98 z98=new Z98();
    computeZ98Values(sourceTiles[0],sourceRectangle,sourceDataBuffers,z98);
    double[][] Tr=new double[3][3];
    double[][] Ti=new double[3][3];
    int xx, yy, trgIdx, srcIdx;
    boolean[][] isPointTarget=new boolean[h][w];
    T3[][] filterWindowT3=null;
    T3[][] targetWindowT3=null;
    for (int y=y0; y < maxY; ++y) {
      yy=y - y0;
      trgIndex.calculateStride(y);
      srcIndex.calculateStride(y);
      for (int x=x0; x < maxX; ++x) {
        xx=x - x0;
        trgIdx=trgIndex.getIndex(x);
        srcIdx=srcIndex.getIndex(x);
        PolOpUtils.getT3(srcIdx,sourceProductType,sourceDataBuffers,Tr,Ti);
        if (y - halfFilterSize < sy0 || y + halfFilterSize > sy0 + sh - 1 || x - halfFilterSize < sx0 || x + halfFilterSize > sx0 + sw - 1) {
          filterWindowT3=new T3[filterWindowSize][filterWindowSize];
          getWindowPixelT3s(x,y,sourceDataBuffers,sx0,sy0,sw,sh,sourceTiles[0],filterWindowT3);
          final int n=setPixelsInSigmaRange(filterWindowT3);
          computeFilteredT3(filterWindowT3,n,sigmaVSqr,Tr,Ti);
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        if (isPointTarget[yy][xx]) {
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        targetWindowT3=new T3[targetWindowSize][targetWindowSize];
        getWindowPixelT3s(x,y,sourceDataBuffers,sx0,sy0,sw,sh,sourceTiles[0],targetWindowT3);
        if (checkPointTarget(z98,targetWindowT3,isPointTarget,x0,y0,w,h)) {
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        double[] sigmaRangeT11=new double[2];
        double[] sigmaRangeT22=new double[2];
        double[] sigmaRangeT33=new double[2];
        computeSigmaRange(targetWindowT3,0,sigmaRangeT11);
        computeSigmaRange(targetWindowT3,1,sigmaRangeT22);
        computeSigmaRange(targetWindowT3,2,sigmaRangeT33);
        filterWindowT3=new T3[filterWindowSize][filterWindowSize];
        getWindowPixelT3s(x,y,sourceDataBuffers,sx0,sy0,sw,sh,sourceTiles[0],filterWindowT3);
        final int n=selectPixelsInSigmaRange(sigmaRangeT11,sigmaRangeT22,sigmaRangeT33,filterWindowT3);
        if (n == 0) {
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        computeFilteredT3(filterWindowT3,n,sigmaVPSqr,Tr,Ti);
        saveT3(Tr,Ti,trgIdx,targetDataBuffers);
      }
    }
  }
}","private void leeSigmaFilter(final Map<Band,Tile> targetTiles,final Rectangle targetRectangle){
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final Rectangle sourceRectangle=getSourceTileRectangle(x0,y0,w,h);
  final int sx0=sourceRectangle.x;
  final int sy0=sourceRectangle.y;
  final int sw=sourceRectangle.width;
  final int sh=sourceRectangle.height;
  final TileIndex trgIndex=new TileIndex(targetTiles.get(getTargetProduct().getBandAt(0)));
  for (  final PolBandUtils.QuadSourceBand bandList : srcBandList) {
    final Tile[] sourceTiles=new Tile[bandList.srcBands.length];
    final ProductData[] sourceDataBuffers=new ProductData[bandList.srcBands.length];
    for (int i=0; i < bandList.srcBands.length; ++i) {
      sourceTiles[i]=getSourceTile(bandList.srcBands[i],sourceRectangle);
      sourceDataBuffers[i]=sourceTiles[i].getDataBuffer();
    }
    final TileIndex srcIndex=new TileIndex(sourceTiles[0]);
    final ProductData[] targetDataBuffers=new ProductData[9];
    for (    final Band targetBand : bandList.targetBands) {
      final String targetBandName=targetBand.getName();
      final ProductData dataBuffer=targetTiles.get(targetBand).getDataBuffer();
      if (targetBandName.contains(""String_Node_Str"") || targetBandName.contains(""String_Node_Str""))       targetDataBuffers[0]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[1]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[2]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[3]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[4]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str"") || targetBandName.contains(""String_Node_Str""))       targetDataBuffers[5]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[6]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str""))       targetDataBuffers[7]=dataBuffer;
 else       if (targetBandName.contains(""String_Node_Str"") || targetBandName.contains(""String_Node_Str""))       targetDataBuffers[8]=dataBuffer;
    }
    Z98 z98=new Z98();
    computeZ98Values(sourceTiles[0],sourceRectangle,sourceDataBuffers,z98);
    double[][] Tr=new double[3][3];
    double[][] Ti=new double[3][3];
    int xx, yy, trgIdx, srcIdx;
    boolean[][] isPointTarget=new boolean[h][w];
    T3[][] filterWindowT3=null;
    T3[][] targetWindowT3=null;
    for (int y=y0; y < maxY; ++y) {
      yy=y - y0;
      trgIndex.calculateStride(y);
      srcIndex.calculateStride(y);
      for (int x=x0; x < maxX; ++x) {
        xx=x - x0;
        trgIdx=trgIndex.getIndex(x);
        srcIdx=srcIndex.getIndex(x);
        PolOpUtils.getT3(srcIdx,sourceProductType,sourceDataBuffers,Tr,Ti);
        if (isPointTarget[yy][xx]) {
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        if (y - halfFilterSize < sy0 || y + halfFilterSize > sy0 + sh - 1 || x - halfFilterSize < sx0 || x + halfFilterSize > sx0 + sw - 1) {
          filterWindowT3=new T3[filterWindowSize][filterWindowSize];
          getWindowPixelT3s(x,y,sourceDataBuffers,sx0,sy0,sw,sh,sourceTiles[0],filterWindowT3);
          final int n=setPixelsInSigmaRange(filterWindowT3);
          computeFilteredT3(filterWindowT3,n,sigmaVSqr,Tr,Ti);
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        targetWindowT3=new T3[targetWindowSize][targetWindowSize];
        getWindowPixelT3s(x,y,sourceDataBuffers,sx0,sy0,sw,sh,sourceTiles[0],targetWindowT3);
        if (checkPointTarget(z98,targetWindowT3,isPointTarget,x0,y0,w,h)) {
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        double[] sigmaRangeT11=new double[2];
        double[] sigmaRangeT22=new double[2];
        double[] sigmaRangeT33=new double[2];
        computeSigmaRange(targetWindowT3,0,sigmaRangeT11);
        computeSigmaRange(targetWindowT3,1,sigmaRangeT22);
        computeSigmaRange(targetWindowT3,2,sigmaRangeT33);
        filterWindowT3=new T3[filterWindowSize][filterWindowSize];
        getWindowPixelT3s(x,y,sourceDataBuffers,sx0,sy0,sw,sh,sourceTiles[0],filterWindowT3);
        final int n=selectPixelsInSigmaRange(sigmaRangeT11,sigmaRangeT22,sigmaRangeT33,filterWindowT3);
        if (n == 0) {
          saveT3(Tr,Ti,trgIdx,targetDataBuffers);
          continue;
        }
        computeFilteredT3(filterWindowT3,n,sigmaVPSqr,Tr,Ti);
        saveT3(Tr,Ti,trgIdx,targetDataBuffers);
      }
    }
  }
}"
11527,"public void readImageIORasterBand(final int sourceOffsetX,final int sourceOffsetY,final int sourceStepX,final int sourceStepY,final ProductData destBuffer,final int destOffsetX,final int destOffsetY,final int destWidth,final int destHeight,final int imageID,final int bandSampleOffset) throws IOException {
  final ImageReadParam param=reader.getDefaultReadParam();
  param.setSourceSubsampling(sourceStepX,sourceStepY,sourceOffsetX % sourceStepX,sourceOffsetY % sourceStepY);
  final Raster data=getData(param,destOffsetX,destOffsetY,destWidth,destHeight);
  final DataBuffer dataBuffer=data.getDataBuffer();
  final SampleModel sampleModel=data.getSampleModel();
  final int dataBufferType=dataBuffer.getDataType();
  final int sampleOffset=imageID + bandSampleOffset;
  final Object dest=destBuffer.getElems();
  if (dest instanceof int[] && (dataBufferType == DataBuffer.TYPE_USHORT || dataBufferType == DataBuffer.TYPE_SHORT || dataBufferType == DataBuffer.TYPE_INT)) {
    sampleModel.getSamples(0,0,destWidth,destHeight,sampleOffset,(int[])dest,dataBuffer);
  }
 else   if (dataBufferType == DataBuffer.TYPE_FLOAT && dest instanceof float[]) {
    sampleModel.getSamples(0,0,destWidth,destHeight,sampleOffset,(float[])dest,dataBuffer);
  }
 else   if (dataBufferType == DataBuffer.TYPE_DOUBLE && dest instanceof double[]) {
    sampleModel.getSamples(0,0,destWidth,destHeight,sampleOffset,(double[])dest,dataBuffer);
  }
 else {
    final double[] dArray=new double[destWidth * destHeight];
    sampleModel.getSamples(0,0,data.getWidth(),data.getHeight(),sampleOffset,dArray,dataBuffer);
    int i=0;
    for (    double value : dArray) {
      destBuffer.setElemDoubleAt(i++,value);
    }
  }
}","public void readImageIORasterBand(final int sourceOffsetX,final int sourceOffsetY,final int sourceStepX,final int sourceStepY,final ProductData destBuffer,final int destOffsetX,final int destOffsetY,final int destWidth,final int destHeight,final int imageID,final int bandSampleOffset) throws IOException {
  final ImageReadParam param=reader.getDefaultReadParam();
  param.setSourceSubsampling(sourceStepX,sourceStepY,sourceOffsetX % sourceStepX,sourceOffsetY % sourceStepY);
  final Raster data=getData(param,destOffsetX,destOffsetY,destWidth,destHeight);
  final DataBuffer dataBuffer=data.getDataBuffer();
  final SampleModel sampleModel=data.getSampleModel();
  final int dataBufferType=dataBuffer.getDataType();
  final int sampleOffset=imageID + bandSampleOffset;
  final Object dest=destBuffer.getElems();
  try {
    if (dest instanceof int[] && (dataBufferType == DataBuffer.TYPE_USHORT || dataBufferType == DataBuffer.TYPE_SHORT || dataBufferType == DataBuffer.TYPE_INT)) {
      sampleModel.getSamples(0,0,destWidth,destHeight,sampleOffset,(int[])dest,dataBuffer);
    }
 else     if (dataBufferType == DataBuffer.TYPE_FLOAT && dest instanceof float[]) {
      sampleModel.getSamples(0,0,destWidth,destHeight,sampleOffset,(float[])dest,dataBuffer);
    }
 else     if (dataBufferType == DataBuffer.TYPE_DOUBLE && dest instanceof double[]) {
      sampleModel.getSamples(0,0,destWidth,destHeight,sampleOffset,(double[])dest,dataBuffer);
    }
 else {
      final double[] dArray=new double[destWidth * destHeight];
      sampleModel.getSamples(0,0,data.getWidth(),data.getHeight(),sampleOffset,dArray,dataBuffer);
      int i=0;
      for (      double value : dArray) {
        destBuffer.setElemDoubleAt(i++,value);
      }
    }
  }
 catch (  Exception e) {
    try {
      final double[] dArray=new double[destWidth * destHeight];
      sampleModel.getSamples(0,0,data.getWidth(),data.getHeight(),sampleOffset,dArray,dataBuffer);
      int i=0;
      for (      double value : dArray) {
        destBuffer.setElemDoubleAt(i++,value);
      }
    }
 catch (    Exception e2) {
      int size=destWidth * destHeight;
      for (int i=0; i < size; ++i) {
        destBuffer.setElemDoubleAt(i++,0);
      }
    }
  }
}"
11528,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String targetBandName=targetBand.getName();
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBandName);
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex trgIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final boolean complexData=bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY;
  final CalibrationInfo calInfo=targetBandToCalInfo.get(targetBandName);
  final Sentinel1Calibrator.CALTYPE calType=Sentinel1Calibrator.getCalibrationType(targetBandName);
  double dn, dn2, i, q, muX, lutVal, retroLutVal=1.0;
  int srcIdx, trgIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    trgIndex.calculateStride(y);
    final int calVecIdx=calInfo.getCalibrationVectorIndex(y);
    final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
    final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
    final float[] vec0LUT=Sentinel1Calibrator.getVector(calType,vec0);
    final float[] vec1LUT=Sentinel1Calibrator.getVector(calType,vec1);
    float[] retroVec0LUT=null;
    float[] retroVec1LUT=null;
    if (dataType != null) {
      retroVec0LUT=Sentinel1Calibrator.getVector(dataType,vec0);
      retroVec1LUT=Sentinel1Calibrator.getVector(dataType,vec1);
    }
    final double azTime=calInfo.firstLineTime + y * calInfo.lineTimeInterval;
    final double muY=(azTime - vec0.timeMJD) / (vec1.timeMJD - vec0.timeMJD);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      trgIdx=trgIndex.getIndex(x);
      final int pixelIdx=calInfo.getPixelIndex(x,calVecIdx);
      muX=(x - vec0.pixels[pixelIdx]) / (double)(vec0.pixels[pixelIdx + 1] - vec0.pixels[pixelIdx]);
      lutVal=(1 - muY) * ((1 - muX) * vec0LUT[pixelIdx] + muX * vec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * vec1LUT[pixelIdx] + muX * vec1LUT[pixelIdx + 1]);
      if (dataType != null) {
        retroLutVal=(1 - muY) * ((1 - muX) * retroVec0LUT[pixelIdx] + muX * retroVec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * retroVec1LUT[pixelIdx] + muX * retroVec1LUT[pixelIdx + 1]);
      }
      if (complexData) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        trgData.setElemDoubleAt(trgIdx,(i * i + q * q) / (lutVal * lutVal));
      }
 else       if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        trgData.setElemDoubleAt(trgIdx,(dn * dn) / (lutVal * lutVal));
      }
 else {
        dn2=srcData1.getElemDoubleAt(srcIdx);
        trgData.setElemDoubleAt(trgIdx,dn2 * retroLutVal / (lutVal * lutVal));
      }
    }
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int x0=targetTileRectangle.x;
  final int y0=targetTileRectangle.y;
  final int w=targetTileRectangle.width;
  final int h=targetTileRectangle.height;
  Tile sourceRaster1=null;
  ProductData srcData1=null;
  ProductData srcData2=null;
  Band sourceBand1=null;
  final String targetBandName=targetBand.getName();
  final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBandName);
  if (srcBandNames.length == 1) {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
  }
 else {
    sourceBand1=sourceProduct.getBand(srcBandNames[0]);
    final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
    sourceRaster1=calibrationOp.getSourceTile(sourceBand1,targetTileRectangle);
    final Tile sourceRaster2=calibrationOp.getSourceTile(sourceBand2,targetTileRectangle);
    srcData1=sourceRaster1.getDataBuffer();
    srcData2=sourceRaster2.getDataBuffer();
  }
  final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
  final ProductData trgData=targetTile.getDataBuffer();
  final TileIndex srcIndex=new TileIndex(sourceRaster1);
  final TileIndex trgIndex=new TileIndex(targetTile);
  final int maxY=y0 + h;
  final int maxX=x0 + w;
  final boolean complexData=bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY;
  final CalibrationInfo calInfo=targetBandToCalInfo.get(targetBandName);
  final Sentinel1Calibrator.CALTYPE calType=Sentinel1Calibrator.getCalibrationType(targetBandName);
  double dn, dn2, i, q, muX, lutVal, retroLutVal=1.0;
  int srcIdx, trgIdx;
  for (int y=y0; y < maxY; ++y) {
    srcIndex.calculateStride(y);
    trgIndex.calculateStride(y);
    final int calVecIdx=calInfo.getCalibrationVectorIndex(y);
    final Sentinel1Utils.CalibrationVector vec0=calInfo.getCalibrationVector(calVecIdx);
    final Sentinel1Utils.CalibrationVector vec1=calInfo.getCalibrationVector(calVecIdx + 1);
    final float[] vec0LUT=getVector(calType,vec0);
    final float[] vec1LUT=getVector(calType,vec1);
    float[] retroVec0LUT=null;
    float[] retroVec1LUT=null;
    if (dataType != null) {
      retroVec0LUT=getVector(dataType,vec0);
      retroVec1LUT=getVector(dataType,vec1);
    }
    final double azTime=calInfo.firstLineTime + y * calInfo.lineTimeInterval;
    final double muY=(azTime - vec0.timeMJD) / (vec1.timeMJD - vec0.timeMJD);
    for (int x=x0; x < maxX; ++x) {
      srcIdx=srcIndex.getIndex(x);
      trgIdx=trgIndex.getIndex(x);
      final int pixelIdx=calInfo.getPixelIndex(x,calVecIdx);
      muX=(x - vec0.pixels[pixelIdx]) / (double)(vec0.pixels[pixelIdx + 1] - vec0.pixels[pixelIdx]);
      lutVal=(1 - muY) * ((1 - muX) * vec0LUT[pixelIdx] + muX * vec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * vec1LUT[pixelIdx] + muX * vec1LUT[pixelIdx + 1]);
      if (dataType != null) {
        retroLutVal=(1 - muY) * ((1 - muX) * retroVec0LUT[pixelIdx] + muX * retroVec0LUT[pixelIdx + 1]) + muY * ((1 - muX) * retroVec1LUT[pixelIdx] + muX * retroVec1LUT[pixelIdx + 1]);
      }
      if (complexData) {
        i=srcData1.getElemDoubleAt(srcIdx);
        q=srcData2.getElemDoubleAt(srcIdx);
        trgData.setElemDoubleAt(trgIdx,(i * i + q * q) / (lutVal * lutVal));
      }
 else       if (bandUnit == Unit.UnitType.AMPLITUDE) {
        dn=srcData1.getElemDoubleAt(srcIdx);
        trgData.setElemDoubleAt(trgIdx,(dn * dn) / (lutVal * lutVal));
      }
 else {
        dn2=srcData1.getElemDoubleAt(srcIdx);
        trgData.setElemDoubleAt(trgIdx,dn2 * retroLutVal / (lutVal * lutVal));
      }
    }
  }
}"
11529,"public int getCalibrationVectorIndex(final int y){
  for (int i=0; i < count; i++) {
    if (y < calibrationVectorList[i].line) {
      return i - 1;
    }
  }
  return -1;
}","public int getCalibrationVectorIndex(final int y){
  for (int i=1; i < count; i++) {
    if (y < calibrationVectorList[i].line) {
      return i - 1;
    }
  }
  return -1;
}"
11530,"/** 
 * Find pixels in the adaptive neighbourhood (AN) of a given pixel using region growing method.
 * @param xc          X coordinate of the given pixel
 * @param yc          Y coordinate of the given pixel
 * @param sx0         X coordinate of the pixel at the upper left corner of the source rectangle
 * @param sy0         Y coordinate of the pixel at the upper left corner of the source rectangle
 * @param sw          Width of the source rectangle
 * @param sh          Height of the source rectangle
 * @param data11Real  Data of the 1st diagonal element in coherency matrix for all pixels in source rectangle
 * @param data22Real  Data of the 2nd diagonal element in coherency matrix for all pixels in source rectangle
 * @param data33Real  Data of the 3rd diagonal element in coherency matrix for all pixels in source rectangle
 * @param seed        The initial seed value for AN
 * @param threshold   Threshold used in searching for pixels in AN
 * @param anPixelList List of pixels in AN
 * @return bgPixelList List of pixels rejected in searching for AN pixels
 */
private Pix[] regionGrowing(final int xc,final int yc,final int sx0,final int sy0,final int sw,final int sh,final double[][] data11Real,final double[][] data22Real,final double[][] data33Real,final Seed seed,final double threshold,final List<Pix> anPixelList){
  final int rc=yc - sy0;
  final int cc=xc - sx0;
  final Map<Integer,Boolean> visited=new HashMap<>(anSize + 8);
  final List<Pix> bgPixelList=new ArrayList<>(anSize);
  if (distance(data11Real[rc][cc],data22Real[rc][cc],data33Real[rc][cc],seed) < threshold) {
    visited.put(rc * sw + cc,true);
    anPixelList.add(new Pix(xc,yc));
  }
 else {
    bgPixelList.add(new Pix(xc,yc));
  }
  final List<Pix> front=new ArrayList<>(anSize);
  front.add(new Pix(xc,yc));
  final List<Pix> newfront=new ArrayList<>(anSize);
  final int width=sx0 + sw;
  final int height=sy0 + sh;
  int r, c;
  Integer index;
  while (anPixelList.size() < anSize && !front.isEmpty()) {
    newfront.clear();
    for (    final Pix p : front) {
      final int[] x={p.x - 1,p.x,p.x + 1,p.x - 1,p.x + 1,p.x - 1,p.x,p.x + 1};
      final int[] y={p.y - 1,p.y - 1,p.y - 1,p.y,p.y,p.y + 1,p.y + 1,p.y + 1};
      for (int i=0; i < 8; i++) {
        if (x[i] >= sx0 && x[i] < width && y[i] >= sy0 && y[i] < height) {
          r=y[i] - sy0;
          c=x[i] - sx0;
          index=r * sw + c;
          if (visited.get(index) == null) {
            final Pix newPos=new Pix(x[i],y[i]);
            if (distance(data11Real[r][c],data22Real[r][c],data33Real[r][c],seed) < threshold) {
              visited.put(index,true);
              anPixelList.add(newPos);
              newfront.add(newPos);
            }
 else {
              bgPixelList.add(newPos);
            }
          }
        }
      }
      if (anPixelList.size() > anSize) {
        break;
      }
    }
    front.clear();
    front.addAll(newfront);
  }
  return bgPixelList.toArray(new Pix[bgPixelList.size()]);
}","/** 
 * Find pixels in the adaptive neighbourhood (AN) of a given pixel using region growing method.
 * @param xc          X coordinate of the given pixel
 * @param yc          Y coordinate of the given pixel
 * @param sx0         X coordinate of the pixel at the upper left corner of the source rectangle
 * @param sy0         Y coordinate of the pixel at the upper left corner of the source rectangle
 * @param sw          Width of the source rectangle
 * @param sh          Height of the source rectangle
 * @param data11Real  Data of the 1st diagonal element in coherency matrix for all pixels in source rectangle
 * @param data22Real  Data of the 2nd diagonal element in coherency matrix for all pixels in source rectangle
 * @param data33Real  Data of the 3rd diagonal element in coherency matrix for all pixels in source rectangle
 * @param seed        The initial seed value for AN
 * @param threshold   Threshold used in searching for pixels in AN
 * @param anPixelList List of pixels in AN
 * @return bgPixelList List of pixels rejected in searching for AN pixels
 */
private Pix[] regionGrowing(final int xc,final int yc,final int sx0,final int sy0,final int sw,final int sh,final double[][] data11Real,final double[][] data22Real,final double[][] data33Real,final Seed seed,final double threshold,final List<Pix> anPixelList){
  final int rc=yc - sy0;
  final int cc=xc - sx0;
  final Map<Integer,Boolean> visited=new HashMap<>(anSize + 8);
  final List<Pix> bgPixelList=new ArrayList<>(anSize);
  if (distance(data11Real[rc][cc],data22Real[rc][cc],data33Real[rc][cc],seed) < threshold) {
    anPixelList.add(new Pix(xc,yc));
  }
 else {
    bgPixelList.add(new Pix(xc,yc));
  }
  visited.put(rc * sw + cc,true);
  final List<Pix> front=new ArrayList<>(anSize);
  front.add(new Pix(xc,yc));
  final List<Pix> newfront=new ArrayList<>(anSize);
  final int width=sx0 + sw;
  final int height=sy0 + sh;
  int r, c;
  Integer index;
  while (anPixelList.size() < anSize && !front.isEmpty()) {
    newfront.clear();
    for (    final Pix p : front) {
      final int[] x={p.x - 1,p.x,p.x + 1,p.x - 1,p.x + 1,p.x - 1,p.x,p.x + 1};
      final int[] y={p.y - 1,p.y - 1,p.y - 1,p.y,p.y,p.y + 1,p.y + 1,p.y + 1};
      for (int i=0; i < 8; i++) {
        if (x[i] >= sx0 && x[i] < width && y[i] >= sy0 && y[i] < height) {
          r=y[i] - sy0;
          c=x[i] - sx0;
          index=r * sw + c;
          if (visited.get(index) == null) {
            visited.put(index,true);
            final Pix newPos=new Pix(x[i],y[i]);
            if (distance(data11Real[r][c],data22Real[r][c],data33Real[r][c],seed) < threshold) {
              anPixelList.add(newPos);
              newfront.add(newPos);
            }
 else {
              bgPixelList.add(newPos);
            }
          }
        }
      }
      if (anPixelList.size() > anSize) {
        break;
      }
    }
    front.clear();
    front.addAll(newfront);
  }
  return bgPixelList.toArray(new Pix[bgPixelList.size()]);
}"
11531,"/** 
 * Compute zero Doppler time for given point with the product orbit state vectors using bisection method.
 * @param firstLineUTC     The zero Doppler time for the first range line.
 * @param lineTimeInterval The line time interval.
 * @param wavelength       The radar wavelength.
 * @param earthPoint       The earth point in xyz coordinate.
 * @param orbit            The object holding orbit state vectors.
 * @return The zero Doppler time in days if it is found, NonValidZeroDopplerTime otherwise.
 * @throws OperatorException The operator exception.
 */
public static double getZeroDopplerTime(final double firstLineUTC,final double lineTimeInterval,final double wavelength,final double[] earthPoint,final SARGeocoding.Orbit orbit) throws OperatorException {
  final int numOrbitVec=orbit.orbitStateVectors.length;
  double[] sensorPosition=new double[3];
  double[] sensorVelocity=new double[3];
  double firstVecTime=0.0;
  double secondVecTime=0.0;
  double firstVecFreq=0.0;
  double secondVecFreq=0.0;
  for (int i=0; i < numOrbitVec; i++) {
    sensorPosition[0]=orbit.orbitStateVectors[i].x_pos;
    sensorPosition[1]=orbit.orbitStateVectors[i].y_pos;
    sensorPosition[2]=orbit.orbitStateVectors[i].z_pos;
    sensorVelocity[0]=orbit.orbitStateVectors[i].x_vel;
    sensorVelocity[1]=orbit.orbitStateVectors[i].y_vel;
    sensorVelocity[2]=orbit.orbitStateVectors[i].z_vel;
    final double currentFreq=getDopplerFrequency(earthPoint,sensorPosition,sensorVelocity,wavelength);
    if (i == 0 || firstVecFreq * currentFreq > 0) {
      firstVecTime=orbit.orbitStateVectors[i].time_mjd;
      firstVecFreq=currentFreq;
    }
 else {
      secondVecTime=orbit.orbitStateVectors[i].time_mjd;
      secondVecFreq=currentFreq;
      break;
    }
  }
  if (firstVecFreq * secondVecFreq >= 0.0) {
    return NonValidZeroDopplerTime;
  }
  double lowerBoundTime=firstVecTime;
  double upperBoundTime=secondVecTime;
  double lowerBoundFreq=firstVecTime;
  double upperBoundFreq=secondVecFreq;
  double diffTime=Math.abs(upperBoundTime - lowerBoundTime);
  while (diffTime > Math.abs(lineTimeInterval)) {
    final double midTime=(upperBoundTime + lowerBoundTime) / 2.0;
    orbit.getPositionVelocity(midTime,sensorPosition,sensorVelocity);
    final double midFreq=getDopplerFrequency(earthPoint,sensorPosition,sensorVelocity,wavelength);
    if (midFreq * lowerBoundFreq > 0.0) {
      lowerBoundTime=midTime;
      lowerBoundFreq=midFreq;
    }
 else     if (midFreq * upperBoundFreq > 0.0) {
      upperBoundTime=midTime;
      upperBoundFreq=midFreq;
    }
 else     if (Double.compare(midFreq,0.0) == 0) {
      return midTime;
    }
    diffTime=Math.abs(upperBoundTime - lowerBoundTime);
  }
  return lowerBoundTime - lowerBoundFreq * (upperBoundTime - lowerBoundTime) / (upperBoundFreq - lowerBoundFreq);
}","/** 
 * Compute zero Doppler time for given point with the product orbit state vectors using bisection method.
 * @param firstLineUTC     The zero Doppler time for the first range line.
 * @param lineTimeInterval The line time interval.
 * @param wavelength       The radar wavelength.
 * @param earthPoint       The earth point in xyz coordinate.
 * @param orbit            The object holding orbit state vectors.
 * @return The zero Doppler time in days if it is found, NonValidZeroDopplerTime otherwise.
 * @throws OperatorException The operator exception.
 */
public static double getZeroDopplerTime(final double firstLineUTC,final double lineTimeInterval,final double wavelength,final double[] earthPoint,final SARGeocoding.Orbit orbit) throws OperatorException {
  final int numOrbitVec=orbit.orbitStateVectors.length;
  double[] sensorPosition=new double[3];
  double[] sensorVelocity=new double[3];
  double firstVecTime=0.0;
  double secondVecTime=0.0;
  double firstVecFreq=0.0;
  double secondVecFreq=0.0;
  for (int i=0; i < numOrbitVec; i++) {
    sensorPosition[0]=orbit.orbitStateVectors[i].x_pos;
    sensorPosition[1]=orbit.orbitStateVectors[i].y_pos;
    sensorPosition[2]=orbit.orbitStateVectors[i].z_pos;
    sensorVelocity[0]=orbit.orbitStateVectors[i].x_vel;
    sensorVelocity[1]=orbit.orbitStateVectors[i].y_vel;
    sensorVelocity[2]=orbit.orbitStateVectors[i].z_vel;
    final double currentFreq=getDopplerFrequency(earthPoint,sensorPosition,sensorVelocity,wavelength);
    if (i == 0 || firstVecFreq * currentFreq > 0) {
      firstVecTime=orbit.orbitStateVectors[i].time_mjd;
      firstVecFreq=currentFreq;
    }
 else {
      secondVecTime=orbit.orbitStateVectors[i].time_mjd;
      secondVecFreq=currentFreq;
      break;
    }
  }
  if (firstVecFreq * secondVecFreq >= 0.0) {
    return NonValidZeroDopplerTime;
  }
  double lowerBoundTime=firstVecTime;
  double upperBoundTime=secondVecTime;
  double lowerBoundFreq=firstVecFreq;
  double upperBoundFreq=secondVecFreq;
  double diffTime=Math.abs(upperBoundTime - lowerBoundTime);
  while (diffTime > Math.abs(lineTimeInterval)) {
    final double midTime=(upperBoundTime + lowerBoundTime) / 2.0;
    orbit.getPositionVelocity(midTime,sensorPosition,sensorVelocity);
    final double midFreq=getDopplerFrequency(earthPoint,sensorPosition,sensorVelocity,wavelength);
    if (midFreq * lowerBoundFreq > 0.0) {
      lowerBoundTime=midTime;
      lowerBoundFreq=midFreq;
    }
 else     if (midFreq * upperBoundFreq > 0.0) {
      upperBoundTime=midTime;
      upperBoundFreq=midFreq;
    }
 else     if (Double.compare(midFreq,0.0) == 0) {
      return midTime;
    }
    diffTime=Math.abs(upperBoundTime - lowerBoundTime);
  }
  return lowerBoundTime - lowerBoundFreq * (upperBoundTime - lowerBoundTime) / (upperBoundFreq - lowerBoundFreq);
}"
11532,"@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames(),(Object[])paramMap.get(""String_Node_Str""));
  if (sourceProducts != null) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    if (absRoot != null) {
      final String sampleType=absRoot.getAttributeString(AbstractMetadata.SAMPLE_TYPE);
      if (sampleType.equals(""String_Node_Str"")) {
        auxFile.removeItem(CalibrationOp.PRODUCT_AUX);
        auxFile.setSelectedItem(paramMap.get(""String_Node_Str""));
      }
 else {
        if (auxFile.getItemCount() == 2) {
          auxFile.addItem(CalibrationOp.PRODUCT_AUX);
        }
        auxFile.setSelectedItem(CalibrationOp.PRODUCT_AUX);
      }
      final String mission=absRoot.getAttributeString(AbstractMetadata.MISSION);
      if (!mission.equals(""String_Node_Str"")) {
        auxFile.setEnabled(false);
        auxFileLabel.setEnabled(false);
      }
 else {
        auxFile.setEnabled(true);
        auxFileLabel.setEnabled(true);
      }
      DialogUtils.enableComponents(auxFileLabel,auxFile,true);
      DialogUtils.enableComponents(bandListLabel,bandListPane,true);
      saveInComplexCheckBox.setVisible(true);
      saveInDbCheckBox.setVisible(true);
      createGamma0VirtualBandCheckBox.setVisible(true);
      createBeta0VirtualBandCheckBox.setVisible(true);
      DialogUtils.enableComponents(polListLabel,polListPane,false);
      outputSigmaBandCheckBox.setVisible(false);
      outputGammaBandCheckBox.setVisible(false);
      outputBetaBandCheckBox.setVisible(false);
      outputDNBandCheckBox.setVisible(false);
      if (mission.equals(""String_Node_Str"") && sampleType.equals(""String_Node_Str"")) {
        saveInComplexCheckBox.setEnabled(true);
        saveInComplexCheckBox.setSelected(false);
        if (saveInComplex) {
          saveInDbCheckBox.setEnabled(false);
          createGamma0VirtualBandCheckBox.setEnabled(false);
          createBeta0VirtualBandCheckBox.setEnabled(false);
          saveInDbCheckBox.setSelected(false);
          createGamma0VirtualBandCheckBox.setSelected(false);
          createBeta0VirtualBandCheckBox.setSelected(false);
        }
 else {
          saveInDbCheckBox.setEnabled(true);
          createGamma0VirtualBandCheckBox.setEnabled(true);
          createBeta0VirtualBandCheckBox.setEnabled(true);
        }
      }
 else       if (mission.startsWith(""String_Node_Str"")) {
        final String[] polarisations=Sentinel1Utils.getProductPolarizations(absRoot);
        polList.setListData(polarisations);
        OperatorUIUtils.initParamList(polList,polarisations);
        DialogUtils.enableComponents(auxFileLabel,auxFile,false);
        DialogUtils.enableComponents(externalAuxFileLabel,externalAuxFile,false);
        DialogUtils.enableComponents(bandListLabel,bandListPane,false);
        saveInComplexCheckBox.setVisible(false);
        saveInDbCheckBox.setVisible(false);
        createGamma0VirtualBandCheckBox.setVisible(false);
        createBeta0VirtualBandCheckBox.setVisible(false);
        DialogUtils.enableComponents(polListLabel,polListPane,true);
        outputSigmaBandCheckBox.setVisible(true);
        outputGammaBandCheckBox.setVisible(true);
        outputBetaBandCheckBox.setVisible(true);
        outputDNBandCheckBox.setVisible(true);
      }
 else {
        saveInComplexCheckBox.setEnabled(false);
        saveInComplexCheckBox.setSelected(false);
      }
    }
  }
 else {
    auxFile.setSelectedItem(paramMap.get(""String_Node_Str""));
  }
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalAuxFile.setText(extFile.getAbsolutePath());
  }
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveInComplex=paramVal;
    saveInComplexCheckBox.setSelected(saveInComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveInDb=paramVal;
    saveInDbCheckBox.setSelected(saveInDb);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    createGamma0VirtualBand=paramVal;
    createGamma0VirtualBandCheckBox.setSelected(createGamma0VirtualBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    createBeta0VirtualBand=paramVal;
    createBeta0VirtualBandCheckBox.setSelected(createBeta0VirtualBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputSigmaBand=paramVal;
    outputSigmaBandCheckBox.setSelected(outputSigmaBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputGammaBand=paramVal;
    outputGammaBandCheckBox.setSelected(outputGammaBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputBetaBand=paramVal;
    outputBetaBandCheckBox.setSelected(outputBetaBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputDNBand=paramVal;
    outputDNBandCheckBox.setSelected(outputDNBand);
  }
}","@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames(),(Object[])paramMap.get(""String_Node_Str""));
  if (sourceProducts != null) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    if (absRoot != null) {
      final String sampleType=absRoot.getAttributeString(AbstractMetadata.SAMPLE_TYPE);
      if (sampleType.equals(""String_Node_Str"")) {
        auxFile.removeItem(CalibrationOp.PRODUCT_AUX);
        auxFile.setSelectedItem(paramMap.get(""String_Node_Str""));
      }
 else {
        if (auxFile.getItemCount() == 2) {
          auxFile.addItem(CalibrationOp.PRODUCT_AUX);
        }
        auxFile.setSelectedItem(CalibrationOp.PRODUCT_AUX);
      }
      final String mission=absRoot.getAttributeString(AbstractMetadata.MISSION);
      if (!mission.equals(""String_Node_Str"")) {
        auxFile.setEnabled(false);
        auxFileLabel.setEnabled(false);
      }
 else {
        auxFile.setEnabled(true);
        auxFileLabel.setEnabled(true);
      }
      DialogUtils.enableComponents(auxFileLabel,auxFile,true);
      DialogUtils.enableComponents(bandListLabel,bandListPane,true);
      saveInComplexCheckBox.setVisible(true);
      saveInDbCheckBox.setVisible(true);
      createGamma0VirtualBandCheckBox.setVisible(true);
      createBeta0VirtualBandCheckBox.setVisible(true);
      DialogUtils.enableComponents(polListLabel,polListPane,false);
      outputSigmaBandCheckBox.setVisible(false);
      outputGammaBandCheckBox.setVisible(false);
      outputBetaBandCheckBox.setVisible(false);
      outputDNBandCheckBox.setVisible(false);
      if (mission.equals(""String_Node_Str"") && sampleType.equals(""String_Node_Str"")) {
        saveInComplexCheckBox.setEnabled(true);
        saveInComplexCheckBox.setSelected(false);
        if (saveInComplex) {
          saveInDbCheckBox.setEnabled(false);
          createGamma0VirtualBandCheckBox.setEnabled(false);
          createBeta0VirtualBandCheckBox.setEnabled(false);
          saveInDbCheckBox.setSelected(false);
          createGamma0VirtualBandCheckBox.setSelected(false);
          createBeta0VirtualBandCheckBox.setSelected(false);
        }
 else {
          saveInDbCheckBox.setEnabled(true);
          createGamma0VirtualBandCheckBox.setEnabled(true);
          createBeta0VirtualBandCheckBox.setEnabled(true);
        }
      }
 else       if (mission.startsWith(""String_Node_Str"")) {
        OperatorUIUtils.initParamList(polList,Sentinel1Utils.getProductPolarizations(absRoot),(String[])paramMap.get(""String_Node_Str""));
        DialogUtils.enableComponents(auxFileLabel,auxFile,false);
        DialogUtils.enableComponents(externalAuxFileLabel,externalAuxFile,false);
        DialogUtils.enableComponents(bandListLabel,bandListPane,false);
        saveInComplexCheckBox.setVisible(false);
        saveInDbCheckBox.setVisible(false);
        createGamma0VirtualBandCheckBox.setVisible(false);
        createBeta0VirtualBandCheckBox.setVisible(false);
        DialogUtils.enableComponents(polListLabel,polListPane,true);
        outputSigmaBandCheckBox.setVisible(true);
        outputGammaBandCheckBox.setVisible(true);
        outputBetaBandCheckBox.setVisible(true);
        outputDNBandCheckBox.setVisible(true);
      }
 else {
        saveInComplexCheckBox.setEnabled(false);
        saveInComplexCheckBox.setSelected(false);
      }
    }
  }
 else {
    auxFile.setSelectedItem(paramMap.get(""String_Node_Str""));
  }
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalAuxFile.setText(extFile.getAbsolutePath());
  }
  Boolean paramVal;
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveInComplex=paramVal;
    saveInComplexCheckBox.setSelected(saveInComplex);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    saveInDb=paramVal;
    saveInDbCheckBox.setSelected(saveInDb);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    createGamma0VirtualBand=paramVal;
    createGamma0VirtualBandCheckBox.setSelected(createGamma0VirtualBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    createBeta0VirtualBand=paramVal;
    createBeta0VirtualBandCheckBox.setSelected(createBeta0VirtualBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputSigmaBand=paramVal;
    outputSigmaBandCheckBox.setSelected(outputSigmaBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputGammaBand=paramVal;
    outputGammaBandCheckBox.setSelected(outputGammaBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputBetaBand=paramVal;
    outputBetaBandCheckBox.setSelected(outputBetaBand);
  }
  paramVal=(Boolean)paramMap.get(""String_Node_Str"");
  if (paramVal != null) {
    outputDNBand=paramVal;
    outputDNBandCheckBox.setSelected(outputDNBand);
  }
}"
11533,"@Override public void initParameters(){
  if (sourceProducts != null && sourceProducts.length > 0) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    final String[] polarisations=Sentinel1Utils.getProductPolarizations(absRoot);
    polList.setListData(polarisations);
    OperatorUIUtils.initParamList(polList,polarisations);
  }
}","@Override public void initParameters(){
  if (sourceProducts != null && sourceProducts.length > 0) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    OperatorUIUtils.initParamList(polList,Sentinel1Utils.getProductPolarizations(absRoot),(String[])paramMap.get(""String_Node_Str""));
  }
}"
11534,"@Override public void initParameters(){
  if (sourceProducts != null && sourceProducts.length > 0) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    final String acquisitionMode=absRoot.getAttributeString(AbstractMetadata.ACQUISITION_MODE);
    subswathCombo.removeAllItems();
    if (acquisitionMode.equals(""String_Node_Str"")) {
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
    }
 else     if (acquisitionMode.equals(""String_Node_Str"")) {
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
    }
    String subswath=(String)paramMap.get(""String_Node_Str"");
    if (subswath == null) {
      subswath=acquisitionMode + '1';
    }
    subswathCombo.setSelectedItem(subswath);
    final String[] polarisations=Sentinel1Utils.getProductPolarizations(absRoot);
    polList.setListData(polarisations);
    OperatorUIUtils.initParamList(polList,polarisations);
  }
}","@Override public void initParameters(){
  if (sourceProducts != null && sourceProducts.length > 0) {
    final MetadataElement absRoot=AbstractMetadata.getAbstractedMetadata(sourceProducts[0]);
    final String acquisitionMode=absRoot.getAttributeString(AbstractMetadata.ACQUISITION_MODE);
    subswathCombo.removeAllItems();
    if (acquisitionMode.equals(""String_Node_Str"")) {
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
    }
 else     if (acquisitionMode.equals(""String_Node_Str"")) {
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
      subswathCombo.addItem(""String_Node_Str"");
    }
    String subswath=(String)paramMap.get(""String_Node_Str"");
    if (subswath == null) {
      subswath=acquisitionMode + '1';
    }
    subswathCombo.setSelectedItem(subswath);
    OperatorUIUtils.initParamList(polList,Sentinel1Utils.getProductPolarizations(absRoot),(String[])paramMap.get(""String_Node_Str""));
  }
}"
11535,"/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
    getMission();
    getProductType();
    getAcquisitionMode();
    getCalibrationFlag();
    su=new Sentinel1Utils(sourceProduct);
    if (selectedPolarisations == null || selectedPolarisations.length == 0) {
      selectedPolarisations=su.getPolarizations();
    }
    computeTargetStartEndTime();
    computeTargetSlantRangeTimeToFirstAndLastPixels();
    computeTargetWidthAndHeight();
    createTargetProduct();
    updateTargetProductMetadata();
  }
 catch (  Throwable e) {
    throw new OperatorException(e.getMessage());
  }
}","/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
    getMission();
    getProductType();
    getAcquisitionMode();
    getCalibrationFlag();
    su=new Sentinel1Utils(sourceProduct);
    subSwath=su.getSubSwath();
    if (selectedPolarisations == null || selectedPolarisations.length == 0) {
      selectedPolarisations=su.getPolarizations();
    }
    computeTargetStartEndTime();
    computeTargetSlantRangeTimeToFirstAndLastPixels();
    computeTargetWidthAndHeight();
    createTargetProduct();
    updateTargetProductMetadata();
  }
 catch (  Throwable e) {
    throw new OperatorException(e.getMessage());
  }
}"
11536,"private static String extractPolarization(String filename){
  final int idx=filename.lastIndexOf(""String_Node_Str"") + 13;
  return filename.substring(idx,idx + 2);
}","private static String extractPolarization(String filename){
  final int idx=filename.lastIndexOf(""String_Node_Str"") + 6;
  final String pp=filename.substring(idx,idx + 2);
  if (pp.equals(""String_Node_Str"") || pp.equals(""String_Node_Str"") || pp.equals(""String_Node_Str"")|| pp.equals(""String_Node_Str"")) {
    return pp + ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"";
  }
}"
11537,"/** 
 * Compute the mean value of pixels of the source image in the sliding window.
 * @param tx       The x coordinate of a pixel in the current target tile.
 * @param ty       The y coordinate of a pixel in the current target tile.
 * @param srcData1 The product data for i band in case of complex product.
 * @param srcData2 The product data for q band in case of complex product.
 * @param nRgLooks number of range looks
 * @param nAzLooks number of azimuth looks
 * @return The mean value.
 */
private static double getMeanValue(final int tx,final int ty,final ProductData srcData1,final ProductData srcData2,final TileIndex srcIndex,final int nRgLooks,final int nAzLooks,final boolean isdB,final boolean isComplex){
  final int xStart=tx * nRgLooks;
  final int yStart=ty * nAzLooks;
  final int xEnd=xStart + nRgLooks;
  final int yEnd=yStart + nAzLooks;
  double meanValue=0.0;
  int offset;
  if (isdB) {
    for (int y=yStart; y < yEnd; y++) {
      offset=srcIndex.calculateStride(y);
      for (int x=xStart; x < xEnd; x++) {
        meanValue+=Math.pow(10,srcData1.getElemDoubleAt(x - offset) / 10.0);
      }
    }
    meanValue/=(nRgLooks * nAzLooks);
    return 10.0 * Math.log10(meanValue);
  }
 else   if (isComplex) {
    double i, q;
    int index;
    for (int y=yStart; y < yEnd; y++) {
      offset=srcIndex.calculateStride(y);
      for (int x=xStart; x < xEnd; x++) {
        index=x - offset;
        i=srcData1.getElemDoubleAt(index);
        q=srcData2.getElemDoubleAt(index);
        meanValue+=i * i + q * q;
      }
    }
  }
 else {
    for (int y=yStart; y < yEnd; y++) {
      offset=srcIndex.calculateStride(y);
      for (int x=xStart; x < xEnd; x++) {
        meanValue+=srcData1.getElemDoubleAt(x - offset);
      }
    }
  }
  return meanValue / (nRgLooks * nAzLooks);
}","/** 
 * Compute the mean value of pixels of the source image in the sliding window.
 * @param tx       The x coordinate of a pixel in the current target tile.
 * @param ty       The y coordinate of a pixel in the current target tile.
 * @param srcData1 The product data for i band in case of complex product.
 * @param srcData2 The product data for q band in case of complex product.
 * @param nRgLooks number of range looks
 * @param nAzLooks number of azimuth looks
 * @return The mean value.
 */
private static double getMeanValue(final int tx,final int ty,final ProductData srcData1,final ProductData srcData2,final TileIndex srcIndex,final int nRgLooks,final int nAzLooks,final boolean isdB,final boolean isComplex,final boolean isPolsar){
  final int xStart=tx * nRgLooks;
  final int yStart=ty * nAzLooks;
  final int xEnd=xStart + nRgLooks;
  final int yEnd=yStart + nAzLooks;
  double meanValue=0.0;
  int offset;
  if (isdB) {
    for (int y=yStart; y < yEnd; y++) {
      offset=srcIndex.calculateStride(y);
      for (int x=xStart; x < xEnd; x++) {
        meanValue+=Math.pow(10,srcData1.getElemDoubleAt(x - offset) / 10.0);
      }
    }
    meanValue/=(nRgLooks * nAzLooks);
    return 10.0 * Math.log10(meanValue);
  }
 else   if (isComplex && !isPolsar) {
    double i, q;
    int index;
    for (int y=yStart; y < yEnd; y++) {
      offset=srcIndex.calculateStride(y);
      for (int x=xStart; x < xEnd; x++) {
        index=x - offset;
        i=srcData1.getElemDoubleAt(index);
        q=srcData2.getElemDoubleAt(index);
        meanValue+=i * i + q * q;
      }
    }
  }
 else {
    for (int y=yStart; y < yEnd; y++) {
      offset=srcIndex.calculateStride(y);
      for (int x=xStart; x < xEnd; x++) {
        meanValue+=srcData1.getElemDoubleAt(x - offset);
      }
    }
  }
  return meanValue / (nRgLooks * nAzLooks);
}"
11538,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final int x0=tx0 * nRgLooks;
  final int y0=ty0 * nAzLooks;
  final int w=tw * nRgLooks;
  final int h=th * nAzLooks;
  final Rectangle sourceTileRectangle=new Rectangle(x0,y0,w,h);
  try {
    Tile sourceRaster1;
    Tile sourceRaster2=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    Band sourceBand1;
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      if (sourceRaster1 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      sourceRaster2=getSourceTile(sourceBand2,sourceTileRectangle);
      if (sourceRaster1 == null || sourceRaster2 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
    final ProductData trgData=targetTile.getDataBuffer();
    final ProductData srcData1=sourceRaster1.getDataBuffer();
    final ProductData srcData2=sourceRaster2 != null ? sourceRaster2.getDataBuffer() : null;
    final TileIndex trgIndex=new TileIndex(targetTile);
    final TileIndex srcIndex=new TileIndex(sourceRaster1);
    final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
    final boolean isdB=bandUnit == Unit.UnitType.INTENSITY_DB || bandUnit == Unit.UnitType.AMPLITUDE_DB;
    final boolean isComplex=outputIntensity && (bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY);
    double meanValue;
    final int maxy=ty0 + th;
    final int maxx=tx0 + tw;
    if (nRgLooks == 1 && nAzLooks == 1) {
      if (!isComplex && targetTile.getDataBuffer().getType() == sourceRaster1.getDataBuffer().getType()) {
        targetTile.setRawSamples(sourceRaster1.getRawSamples());
      }
 else {
        for (int ty=ty0; ty < maxy; ty++) {
          trgIndex.calculateStride(ty);
          srcIndex.calculateStride(ty);
          for (int tx=tx0; tx < maxx; tx++) {
            final int index=srcIndex.getIndex(tx);
            final double i=srcData1.getElemDoubleAt(index);
            if (srcData2 != null) {
              final double q=srcData2.getElemDoubleAt(index);
              trgData.setElemDoubleAt(trgIndex.getIndex(tx),i * i + q * q);
            }
 else {
              trgData.setElemDoubleAt(trgIndex.getIndex(tx),i);
            }
          }
        }
      }
    }
 else {
      for (int ty=ty0; ty < maxy; ty++) {
        trgIndex.calculateStride(ty);
        for (int tx=tx0; tx < maxx; tx++) {
          meanValue=getMeanValue(tx,ty,srcData1,srcData2,srcIndex,nRgLooks,nAzLooks,isdB,isComplex);
          trgData.setElemDoubleAt(trgIndex.getIndex(tx),meanValue);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final int x0=tx0 * nRgLooks;
  final int y0=ty0 * nAzLooks;
  final int w=tw * nRgLooks;
  final int h=th * nAzLooks;
  final Rectangle sourceTileRectangle=new Rectangle(x0,y0,w,h);
  try {
    Tile sourceRaster1;
    Tile sourceRaster2=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    Band sourceBand1;
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      if (sourceRaster1 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      sourceRaster2=getSourceTile(sourceBand2,sourceTileRectangle);
      if (sourceRaster1 == null || sourceRaster2 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
    final ProductData trgData=targetTile.getDataBuffer();
    final ProductData srcData1=sourceRaster1.getDataBuffer();
    final ProductData srcData2=sourceRaster2 != null ? sourceRaster2.getDataBuffer() : null;
    final TileIndex trgIndex=new TileIndex(targetTile);
    final TileIndex srcIndex=new TileIndex(sourceRaster1);
    final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
    final boolean isdB=bandUnit == Unit.UnitType.INTENSITY_DB || bandUnit == Unit.UnitType.AMPLITUDE_DB;
    final boolean isComplex=outputIntensity && (bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY);
    double meanValue;
    final int maxy=ty0 + th;
    final int maxx=tx0 + tw;
    if (nRgLooks == 1 && nAzLooks == 1) {
      if (!isComplex && targetTile.getDataBuffer().getType() == sourceRaster1.getDataBuffer().getType()) {
        targetTile.setRawSamples(sourceRaster1.getRawSamples());
      }
 else {
        for (int ty=ty0; ty < maxy; ty++) {
          trgIndex.calculateStride(ty);
          srcIndex.calculateStride(ty);
          for (int tx=tx0; tx < maxx; tx++) {
            final int index=srcIndex.getIndex(tx);
            final double i=srcData1.getElemDoubleAt(index);
            if (srcData2 != null) {
              final double q=srcData2.getElemDoubleAt(index);
              trgData.setElemDoubleAt(trgIndex.getIndex(tx),i * i + q * q);
            }
 else {
              trgData.setElemDoubleAt(trgIndex.getIndex(tx),i);
            }
          }
        }
      }
    }
 else {
      for (int ty=ty0; ty < maxy; ty++) {
        trgIndex.calculateStride(ty);
        for (int tx=tx0; tx < maxx; tx++) {
          meanValue=getMeanValue(tx,ty,srcData1,srcData2,srcIndex,nRgLooks,nAzLooks,isdB,isComplex,isPolsar);
          trgData.setElemDoubleAt(trgIndex.getIndex(tx),meanValue);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}"
11539,"/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    GeoCoding sourceGeoCoding=sourceProduct.getGeoCoding();
    if (sourceGeoCoding instanceof CrsGeoCoding) {
      throw new OperatorException(""String_Node_Str"");
    }
    absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
    getRangeAzimuthSpacing();
    getRangeAzimuthLooks();
    getSourceImageDimension();
    createTargetProduct();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    GeoCoding sourceGeoCoding=sourceProduct.getGeoCoding();
    if (sourceGeoCoding instanceof CrsGeoCoding) {
      throw new OperatorException(""String_Node_Str"");
    }
    absRoot=AbstractMetadata.getAbstractedMetadata(sourceProduct);
    isPolsar=absRoot.getAttributeInt(AbstractMetadata.polsarData,0) == 1;
    getRangeAzimuthSpacing();
    getRangeAzimuthLooks();
    getSourceImageDimension();
    createTargetProduct();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11540,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTileMap   The target tiles associated with all target bands to be computed.
 * @param targetRectangle The rectangle of target tile.
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTileMap,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    if (onlyGCPsOnLand && dem == null) {
      createDEM();
    }
    final String[] masterBandNames=StackUtils.getMasterBandNames(sourceProduct);
    final Map<String,Band> singleSlvBandMap=new HashMap<String,Band>();
    final Map<Band,Band> bandList=new HashMap<Band,Band>();
    for (    Band targetBand : targetProduct.getBands()) {
      final Band slaveBand=sourceRasterMap.get(targetBand);
      if (gcpsCalculated && slaveBand == primarySlaveBand) {
        bandList.put(targetBand,slaveBand);
        break;
      }
      if (slaveBand == masterBand1 || slaveBand == masterBand2 || StringUtils.contains(masterBandNames,slaveBand.getName()))       continue;
      if (!useAllPolarimetricBands) {
        final String mstPol=OperatorUtils.getPolarizationFromBandName(masterBand1.getName());
        final String slvProductName=StackUtils.getSlaveProductName(targetProduct,targetBand,mstPol);
        if (slvProductName == null || singleSlvBandMap.get(slvProductName) != null) {
          continue;
        }
        singleSlvBandMap.put(slvProductName,targetBand);
      }
      final String unit=slaveBand.getUnit();
      if (unit != null && (unit.contains(Unit.IMAGINARY) || unit.contains(Unit.BIT)))       continue;
      bandList.put(targetBand,slaveBand);
    }
    int bandCnt=0;
    Band firstTargetBand=null;
    for (    Band targetBand : bandList.keySet()) {
      ++bandCnt;
      final Band slaveBand=bandList.get(targetBand);
      if (collocatedStack || !collocatedStack && bandCnt == 1) {
        final String bandCountStr=bandCnt + ""String_Node_Str"" + bandList.size();
        if (complexCoregistration) {
          computeSlaveGCPs(slaveBand,complexSrcMap.get(slaveBand),targetBand,bandCountStr);
        }
 else {
          computeSlaveGCPs(slaveBand,null,targetBand,bandCountStr);
        }
        if (bandCnt == 1) {
          firstTargetBand=targetBand;
        }
      }
 else {
        copyFirstTargetBandGCPs(firstTargetBand,targetBand);
      }
      final Tile targetTile=targetTileMap.get(targetBand);
      if (targetTile != null) {
        targetTile.setRawSamples(getSourceTile(slaveBand,targetRectangle).getRawSamples());
      }
    }
    setGCPsCalculated();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTileMap   The target tiles associated with all target bands to be computed.
 * @param targetRectangle The rectangle of target tile.
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTileMap,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    if (onlyGCPsOnLand && dem == null) {
      createDEM();
    }
    final String[] masterBandNames=StackUtils.getMasterBandNames(sourceProduct);
    final Map<String,Band> singleSlvBandMap=new HashMap<String,Band>();
    final Map<Band,Band> bandList=new HashMap<Band,Band>();
    for (    Band targetBand : targetProduct.getBands()) {
      final Band slaveBand=sourceRasterMap.get(targetBand);
      if (gcpsComputedMap.get(slaveBand)) {
        bandList.put(targetBand,primarySlaveBand);
        break;
      }
      if (slaveBand == masterBand1 || slaveBand == masterBand2 || StringUtils.contains(masterBandNames,slaveBand.getName())) {
        continue;
      }
      if (collocatedStack && !useAllPolarimetricBands) {
        final String mstPol=OperatorUtils.getPolarizationFromBandName(masterBand1.getName());
        final String slvProductName=StackUtils.getSlaveProductName(targetProduct,targetBand,mstPol);
        if (slvProductName == null || singleSlvBandMap.get(slvProductName) != null) {
          continue;
        }
        singleSlvBandMap.put(slvProductName,targetBand);
      }
      final String unit=slaveBand.getUnit();
      if (unit != null && (unit.contains(Unit.IMAGINARY) || unit.contains(Unit.BIT))) {
        continue;
      }
      bandList.put(targetBand,slaveBand);
    }
    int bandCnt=0;
    Band firstTargetBand=null;
    for (    Band targetBand : bandList.keySet()) {
      ++bandCnt;
      final Band slaveBand=bandList.get(targetBand);
      if (collocatedStack || !collocatedStack && bandCnt == 1) {
        final String bandCountStr=bandCnt + ""String_Node_Str"" + bandList.size();
        if (complexCoregistration) {
          computeSlaveGCPs(slaveBand,complexSrcMap.get(slaveBand),targetBand,bandCountStr);
        }
 else {
          computeSlaveGCPs(slaveBand,null,targetBand,bandCountStr);
        }
        if (bandCnt == 1) {
          firstTargetBand=targetBand;
        }
      }
 else {
        copyFirstTargetBandGCPs(firstTargetBand,targetBand);
      }
      if (slaveBand == primarySlaveBand) {
        final Tile targetTile=targetTileMap.get(targetBand);
        if (targetTile != null) {
          targetTile.setRawSamples(getSourceTile(slaveBand,targetRectangle).getRawSamples());
        }
      }
    }
    setGCPsCalculated();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11541,"/** 
 * Compute slave GCPs for the given tile.
 * @param slaveBand  the input band
 * @param slaveBand2 for complex
 * @param targetBand the output band
 */
private synchronized void computeSlaveGCPs(final Band slaveBand,final Band slaveBand2,final Band targetBand,final String bandCountStr) throws OperatorException {
  if (gcpsComputedMap.get(slaveBand))   return;
  try {
    final ProductNodeGroup<Placemark> targetGCPGroup=targetProduct.getGcpGroup(targetBand);
    final GeoCoding tgtGeoCoding=targetProduct.getGeoCoding();
    final int[] offset=new int[2];
    if (computeOffset) {
      determiningImageOffset(slaveBand,slaveBand2,offset);
    }
    final ThreadManager threadManager=new ThreadManager();
    final int numberOfMasterGCPs=masterGcpGroup.getNodeCount();
    final StatusProgressMonitor status=new StatusProgressMonitor(numberOfMasterGCPs,""String_Node_Str"" + bandCountStr + ' '+ slaveBand.getName()+ ""String_Node_Str"");
    for (int i=0; i < numberOfMasterGCPs; ++i) {
      checkForCancellation();
      final Placemark mPin=masterGcpGroup.get(i);
      if (checkMasterGCPValidity(mPin)) {
        final GeoPos mGCPGeoPos=mPin.getGeoPos();
        final PixelPos mGCPPixelPos=mPin.getPixelPos();
        final PixelPos sGCPPixelPos=new PixelPos(mPin.getPixelPos().x + offset[0],mPin.getPixelPos().y + offset[1]);
        if (!checkSlaveGCPValidity(sGCPPixelPos)) {
          continue;
        }
        final Thread worker=new Thread(){
          @Override public void run(){
            boolean getSlaveGCP=getCoarseSlaveGCPPosition(slaveBand,slaveBand2,mGCPPixelPos,sGCPPixelPos);
            if (getSlaveGCP && complexCoregistration && applyFineRegistration) {
              getSlaveGCP=getFineSlaveGCPPosition(slaveBand,slaveBand2,mGCPPixelPos,sGCPPixelPos);
            }
            if (getSlaveGCP) {
              final Placemark sPin=Placemark.createPointPlacemark(GcpDescriptor.getInstance(),mPin.getName(),mPin.getLabel(),mPin.getDescription(),sGCPPixelPos,mGCPGeoPos,tgtGeoCoding);
              addPlacemark(sPin);
            }
          }
          private synchronized void addPlacemark(          final Placemark pin){
            targetGCPGroup.add(pin);
          }
        }
;
        threadManager.add(worker);
      }
      status.worked(i);
    }
    threadManager.finish();
    gcpsComputedMap.put(slaveBand,true);
    MemUtils.tileCacheFreeOldTiles();
    status.done();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId() + ""String_Node_Str"",e);
  }
}","/** 
 * Compute slave GCPs for the given tile.
 * @param slaveBand  the input band
 * @param slaveBand2 for complex
 * @param targetBand the output band
 */
private synchronized void computeSlaveGCPs(final Band slaveBand,final Band slaveBand2,final Band targetBand,final String bandCountStr) throws OperatorException {
  if (gcpsComputedMap.get(slaveBand)) {
    return;
  }
  gcpsComputedMap.put(slaveBand,true);
  try {
    final ProductNodeGroup<Placemark> targetGCPGroup=targetProduct.getGcpGroup(targetBand);
    final GeoCoding tgtGeoCoding=targetProduct.getGeoCoding();
    final int[] offset=new int[2];
    if (computeOffset) {
      determiningImageOffset(slaveBand,slaveBand2,offset);
    }
    final ThreadManager threadManager=new ThreadManager();
    final int numberOfMasterGCPs=masterGcpGroup.getNodeCount();
    final StatusProgressMonitor status=new StatusProgressMonitor(numberOfMasterGCPs,""String_Node_Str"" + bandCountStr + ' '+ slaveBand.getName()+ ""String_Node_Str"");
    for (int i=0; i < numberOfMasterGCPs; ++i) {
      checkForCancellation();
      final Placemark mPin=masterGcpGroup.get(i);
      if (checkMasterGCPValidity(mPin)) {
        final GeoPos mGCPGeoPos=mPin.getGeoPos();
        final PixelPos mGCPPixelPos=mPin.getPixelPos();
        final PixelPos sGCPPixelPos=new PixelPos(mPin.getPixelPos().x + offset[0],mPin.getPixelPos().y + offset[1]);
        if (!checkSlaveGCPValidity(sGCPPixelPos)) {
          continue;
        }
        final Thread worker=new Thread(){
          @Override public void run(){
            boolean getSlaveGCP=getCoarseSlaveGCPPosition(slaveBand,slaveBand2,mGCPPixelPos,sGCPPixelPos);
            if (getSlaveGCP && complexCoregistration && applyFineRegistration) {
              getSlaveGCP=getFineSlaveGCPPosition(slaveBand,slaveBand2,mGCPPixelPos,sGCPPixelPos);
            }
            if (getSlaveGCP) {
              final Placemark sPin=Placemark.createPointPlacemark(GcpDescriptor.getInstance(),mPin.getName(),mPin.getLabel(),mPin.getDescription(),sGCPPixelPos,mGCPGeoPos,tgtGeoCoding);
              addPlacemark(sPin);
            }
          }
          private synchronized void addPlacemark(          final Placemark pin){
            targetGCPGroup.add(pin);
          }
        }
;
        threadManager.add(worker);
      }
      status.worked(i);
    }
    threadManager.finish();
    MemUtils.tileCacheFreeOldTiles();
    status.done();
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId() + ""String_Node_Str"",e);
  }
}"
11542,"@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames());
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null)   demName.setSelectedItem(DEMFactory.appendAutoDEM(demNameParam));
  demResamplingMethod.setSelectedItem(paramMap.get(""String_Node_Str""));
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalDEMFile.setText(extFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null && !textAreaKeyListener.isChangedByUser()) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
  isSARSimTC=(Boolean)paramMap.get(""String_Node_Str"");
  if (isSARSimTC == null)   isSARSimTC=true;
  if (!isSARSimTC) {
    reGridMethod=(Boolean)paramMap.get(""String_Node_Str"");
    reGridMethodCheckBox.setSelected(reGridMethod);
    orbitMethod=(Boolean)paramMap.get(""String_Node_Str"");
    orbitMethodCheckBox.setSelected(orbitMethod);
    saveDEM=(Boolean)paramMap.get(""String_Node_Str"");
    saveDEMCheckBox.setSelected(saveDEM);
    saveZeroHeightSimulation=(Boolean)paramMap.get(""String_Node_Str"");
    saveZeroHeightSimulationCheckBox.setSelected(saveZeroHeightSimulation);
    saveLocalIncidenceAngle=(Boolean)paramMap.get(""String_Node_Str"");
    saveLocalIncidenceAngleCheckBox.setSelected(saveLocalIncidenceAngle);
  }
  saveLayoverShadowMask=(Boolean)paramMap.get(""String_Node_Str"");
  saveLayoverShadowMaskCheckBox.setSelected(saveLayoverShadowMask);
  enableExtraOptions(!isSARSimTC);
}","@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames());
  final String demNameParam=(String)paramMap.get(""String_Node_Str"");
  if (demNameParam != null)   demName.setSelectedItem(DEMFactory.appendAutoDEM(demNameParam));
  demResamplingMethod.setSelectedItem(paramMap.get(""String_Node_Str""));
  final File extFile=(File)paramMap.get(""String_Node_Str"");
  if (extFile != null) {
    externalDEMFile.setText(extFile.getAbsolutePath());
    extNoDataValue=(Double)paramMap.get(""String_Node_Str"");
    if (extNoDataValue != null && !textAreaKeyListener.isChangedByUser()) {
      externalDEMNoDataValue.setText(String.valueOf(extNoDataValue));
    }
  }
  isSARSimTC=(Boolean)paramMap.get(""String_Node_Str"");
  if (isSARSimTC == null)   isSARSimTC=true;
  if (!isSARSimTC) {
    reGridMethod=(Boolean)paramMap.get(""String_Node_Str"");
    reGridMethodCheckBox.setSelected(reGridMethod);
    orbitMethod=(Boolean)paramMap.get(""String_Node_Str"");
    orbitMethodCheckBox.setSelected(orbitMethod);
    saveDEM=(Boolean)paramMap.get(""String_Node_Str"");
    saveDEMCheckBox.setSelected(saveDEM);
    saveZeroHeightSimulation=(Boolean)paramMap.get(""String_Node_Str"");
    saveZeroHeightSimulationCheckBox.setSelected(saveZeroHeightSimulation);
    saveLocalIncidenceAngle=(Boolean)paramMap.get(""String_Node_Str"");
    saveLocalIncidenceAngleCheckBox.setSelected(saveLocalIncidenceAngle);
  }
  saveLayoverShadowMask=(Boolean)paramMap.get(""String_Node_Str"");
  if (saveLayoverShadowMask != null) {
    saveLayoverShadowMaskCheckBox.setSelected(saveLayoverShadowMask);
  }
  enableExtraOptions(!isSARSimTC);
}"
11543,"/** 
 * Update target product metadata.
 */
private void updateTargetProductMetadata(){
  final MetadataElement origMetadataRoot=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  final MetadataElement annotationElem=origMetadataRoot.getElement(""String_Node_Str"");
  final MetadataElement[] annotationDataSetListElem=annotationElem.getElements();
  for (  MetadataElement elem : annotationDataSetListElem) {
    final MetadataElement productElem=elem.getElement(""String_Node_Str"");
    final MetadataElement imageAnnotationElem=productElem.getElement(""String_Node_Str"");
    final MetadataElement processingInformationElem=imageAnnotationElem.getElement(""String_Node_Str"");
    if (removeThermalNoise) {
      processingInformationElem.getAttribute(""String_Node_Str"").getData().setElemBoolean(true);
    }
    if (reIntroduceThermalNoise) {
      processingInformationElem.getAttribute(""String_Node_Str"").getData().setElemBoolean(false);
    }
  }
}","/** 
 * Update target product metadata.
 */
private void updateTargetProductMetadata(){
  final MetadataElement origMetadataRoot=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  final MetadataElement annotationElem=origMetadataRoot.getElement(""String_Node_Str"");
  final MetadataElement[] annotationDataSetListElem=annotationElem.getElements();
  for (  MetadataElement elem : annotationDataSetListElem) {
    final MetadataElement productElem=elem.getElement(""String_Node_Str"");
    final MetadataElement imageAnnotationElem=productElem.getElement(""String_Node_Str"");
    final MetadataElement processingInformationElem=imageAnnotationElem.getElement(""String_Node_Str"");
    if (removeThermalNoise) {
      processingInformationElem.getAttribute(""String_Node_Str"").getData().setElems(""String_Node_Str"");
    }
    if (reIntroduceThermalNoise) {
      processingInformationElem.getAttribute(""String_Node_Str"").getData().setElems(""String_Node_Str"");
    }
  }
}"
11544,"private static double linearInterpolate(int x0,int x1,int x,double y0,double y1){
  return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
}","private static double linearInterpolate(final int x0,final int x1,final int x,final double y0,final double y1){
  if (x1 == x0) {
    return y0;
  }
 else {
    return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
  }
}"
11545,"private static double computeValue(int x,int y,int[] line,ArrayList<int[]> pixel,ArrayList<double[]> value){
  final int leftYIdx=findLeftOfBracket(y,line);
  final int rightYIdx=(y == line[leftYIdx]) ? leftYIdx : leftYIdx + 1;
  double val=0.0;
  checkBracket(leftYIdx,rightYIdx,line.length - 1);
  if (leftYIdx == rightYIdx) {
    if (y != line[leftYIdx]) {
      throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx);
    }
  }
 else   if (y <= line[leftYIdx] || y >= line[rightYIdx]) {
    throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx+ ""String_Node_Str""+ line[leftYIdx]+ ""String_Node_Str""+ rightYIdx+ ""String_Node_Str""+ line[rightYIdx]);
  }
  final double topVal=linearInterpolateAlongLine(x,leftYIdx,pixel,value);
  final double bottomVal=linearInterpolateAlongLine(x,rightYIdx,pixel,value);
  val=linearInterpolate(leftYIdx,rightYIdx,y,topVal,bottomVal);
  return val;
}","private static double computeValue(final int x,final int y,final int[] line,final ArrayList<int[]> pixel,final ArrayList<double[]> value){
  final int leftYIdx=findLeftOfBracket(y,line);
  final int rightYIdx=(y == line[leftYIdx]) ? leftYIdx : leftYIdx + 1;
  double val=0.0;
  checkBracket(leftYIdx,rightYIdx,line.length - 1);
  if (leftYIdx == rightYIdx) {
    if (y != line[leftYIdx]) {
      throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx);
    }
  }
 else   if (y <= line[leftYIdx] || y >= line[rightYIdx]) {
    throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx+ ""String_Node_Str""+ line[leftYIdx]+ ""String_Node_Str""+ rightYIdx+ ""String_Node_Str""+ line[rightYIdx]);
  }
  final double topVal=linearInterpolateAlongLine(x,leftYIdx,pixel,value);
  final double bottomVal=linearInterpolateAlongLine(x,rightYIdx,pixel,value);
  val=linearInterpolate(line[leftYIdx],line[rightYIdx],y,topVal,bottomVal);
  return val;
}"
11546,"private int readValuesForOneVector(MetadataElement vector,String intNames[],ArrayList<int[]> intValues,String doubleNames[],ArrayList<double[]> doubleValues){
  if (vector == null || intNames.length == 0 && doubleNames.length == 0) {
    return -1;
  }
  final String lineStr=vector.getAttributeString(""String_Node_Str"");
  final int line=Integer.parseInt(lineStr);
  System.out.println(vector.getName() + ""String_Node_Str"" + vector.getAttributeString(""String_Node_Str"")+ ""String_Node_Str""+ line);
  final int count=(intNames.length > 0) ? Integer.parseInt(getMetadataElement(vector,intNames[0]).getAttributeString(""String_Node_Str"")) : Integer.parseInt(getMetadataElement(vector,doubleNames[0]).getAttributeString(""String_Node_Str""));
  for (  String name : intNames) {
    final String[] valuesAsArrayOfStrings=readValuesAsArrayOfStrings(vector,name,count);
    final int values[]=new int[count];
    for (int i=0; i < count; i++) {
      values[i]=Integer.parseInt(valuesAsArrayOfStrings[i]);
    }
    intValues.add(values);
  }
  for (  String name : doubleNames) {
    final String[] valuesAsArrayOfStrings=readValuesAsArrayOfStrings(vector,name,count);
    final double values[]=new double[count];
    for (int i=0; i < count; i++) {
      values[i]=Double.parseDouble(valuesAsArrayOfStrings[i]);
    }
    doubleValues.add(values);
  }
  return line;
}","private int readValuesForOneVector(MetadataElement vector,String intNames[],ArrayList<int[]> intValues,String doubleNames[],ArrayList<double[]> doubleValues){
  if (vector == null || intNames.length == 0 && doubleNames.length == 0) {
    return -1;
  }
  final String lineStr=vector.getAttributeString(""String_Node_Str"");
  final int line=Integer.parseInt(lineStr);
  final int count=(intNames.length > 0) ? Integer.parseInt(getMetadataElement(vector,intNames[0]).getAttributeString(""String_Node_Str"")) : Integer.parseInt(getMetadataElement(vector,doubleNames[0]).getAttributeString(""String_Node_Str""));
  for (  String name : intNames) {
    final String[] valuesAsArrayOfStrings=readValuesAsArrayOfStrings(vector,name,count);
    final int values[]=new int[count];
    for (int i=0; i < count; i++) {
      values[i]=Integer.parseInt(valuesAsArrayOfStrings[i]);
    }
    intValues.add(values);
  }
  for (  String name : doubleNames) {
    final String[] valuesAsArrayOfStrings=readValuesAsArrayOfStrings(vector,name,count);
    final double values[]=new double[count];
    for (int i=0; i < count; i++) {
      values[i]=Double.parseDouble(valuesAsArrayOfStrings[i]);
    }
    doubleValues.add(values);
  }
  return line;
}"
11547,"private static double linearInterpolateAlongLine(int x,int yIdx,ArrayList<int[]> pixel,ArrayList<double[]> value){
  final int leftXIdx=findLeftOfBracket(x,pixel.get(yIdx));
  final int rightXIdx=(x == pixel.get(yIdx)[leftXIdx]) ? leftXIdx : leftXIdx + 1;
  checkBracket(leftXIdx,rightXIdx,pixel.get(yIdx).length);
  final double leftNoise=value.get(yIdx)[leftXIdx];
  final double rightNoise=value.get(yIdx)[rightXIdx];
  return linearInterpolate(leftXIdx,rightXIdx,x,leftNoise,rightNoise);
}","private static double linearInterpolateAlongLine(final int x,final int yIdx,final ArrayList<int[]> pixel,final ArrayList<double[]> value){
  final int leftXIdx=findLeftOfBracket(x,pixel.get(yIdx));
  final int rightXIdx=(x == pixel.get(yIdx)[leftXIdx]) ? leftXIdx : leftXIdx + 1;
  checkBracket(leftXIdx,rightXIdx,pixel.get(yIdx).length);
  final double leftNoise=value.get(yIdx)[leftXIdx];
  final double rightNoise=value.get(yIdx)[rightXIdx];
  return linearInterpolate(pixel.get(yIdx)[leftXIdx],pixel.get(yIdx)[rightXIdx],x,leftNoise,rightNoise);
}"
11548,"private static void checkBracket(int left,int right,int max){
  if (left < 0 || right < 0 || left > max || right > max) {
    throw new OperatorException(""String_Node_Str"" + left + ""String_Node_Str""+ right+ ""String_Node_Str""+ max);
  }
}","private static void checkBracket(final int left,final int right,final int max){
  if (left < 0 || right < 0 || left > max || right > max) {
    throw new OperatorException(""String_Node_Str"" + left + ""String_Node_Str""+ right+ ""String_Node_Str""+ max);
  }
}"
11549,"private void updateTargetProductMetadata(){
  final MetadataElement oriProdMetadata=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  final MetadataElement finalMetadataElem=getParentMetadataElemForFlag(oriProdMetadata);
  if (performCorrection) {
    finalMetadataElem.setAttributeString(ANNOTATION_FLAG_NAME,""String_Node_Str"");
  }
 else {
    finalMetadataElem.setAttributeString(ANNOTATION_FLAG_NAME,""String_Node_Str"");
  }
}","private void updateTargetProductMetadata(){
  final MetadataElement oriProdMetadata=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  final MetadataElement finalMetadataElem=getParentMetadataElemForFlag(oriProdMetadata);
  if (removeNoise) {
    finalMetadataElem.setAttributeString(ANNOTATION_FLAG_NAME,""String_Node_Str"");
  }
 else {
    finalMetadataElem.setAttributeString(ANNOTATION_FLAG_NAME,""String_Node_Str"");
  }
}"
11550,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final Rectangle sourceTileRectangle=new Rectangle(tx0,ty0,tw,th);
  try {
    final String bandName=targetBand.getName();
    final Band srcBand=sourceProduct.getBand(bandName);
    final Tile srcTile=getSourceTile(srcBand,sourceTileRectangle);
    if (srcTile == null) {
      throw new OperatorException(""String_Node_Str"" + targetBand.getName());
    }
    final ProductData srcData=srcTile.getDataBuffer();
    final ProductData tgtData=targetTile.getDataBuffer();
    final int maxy=ty0 + th;
    final int maxx=tx0 + tw;
    ArrayList<double[]> calibrationValue=null;
    final NOISE_BAND_TYPE noiseBandType=getNoiseBandType(bandName);
switch (noiseBandType) {
case SIGMA0:
      calibrationValue=sigma0;
    break;
case BETA0:
  calibrationValue=beta0;
break;
case GAMMA:
calibrationValue=gamma;
break;
case DN:
calibrationValue=dn;
break;
case INVALID:
throw new OperatorException(""String_Node_Str"" + bandName);
}
for (int y=ty0; y < maxy; y++) {
for (int x=tx0; x < maxx; x++) {
final int index=targetTile.getDataBufferIndex(x,y);
final Double srcValue=srcData.getElemDoubleAt(index);
final double eta=computeValue(x,y,noiseLine,noisePixel,noiseValue);
final double A=computeValue(x,y,calibrationLine,calibrationPixel,calibrationValue);
final double noise=performCorrection ? eta / A : -eta / A;
final double tgtValue=srcValue + noise;
tgtData.setElemDoubleAt(index,tgtValue);
}
}
}
 catch (Throwable e) {
OperatorUtils.catchOperatorException(getId(),e);
}
 finally {
pm.done();
}
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final Rectangle sourceTileRectangle=new Rectangle(tx0,ty0,tw,th);
  try {
    final String bandName=targetBand.getName();
    final Band srcBand=sourceProduct.getBand(bandName);
    final Tile srcTile=getSourceTile(srcBand,sourceTileRectangle);
    if (srcTile == null) {
      throw new OperatorException(""String_Node_Str"" + targetBand.getName());
    }
    final ProductData srcData=srcTile.getDataBuffer();
    final ProductData tgtData=targetTile.getDataBuffer();
    final int maxy=ty0 + th;
    final int maxx=tx0 + tw;
    ArrayList<double[]> calibrationValue=null;
    final NOISE_BAND_TYPE noiseBandType=getNoiseBandType(bandName);
switch (noiseBandType) {
case SIGMA0:
      calibrationValue=sigma0;
    break;
case BETA0:
  calibrationValue=beta0;
break;
case GAMMA:
calibrationValue=gamma;
break;
case DN:
calibrationValue=dn;
break;
case INVALID:
throw new OperatorException(""String_Node_Str"" + bandName);
}
for (int y=ty0; y < maxy; y++) {
for (int x=tx0; x < maxx; x++) {
final int index=targetTile.getDataBufferIndex(x,y);
final Double srcValue=srcData.getElemDoubleAt(index);
final double eta=computeValue(x,y,noiseLine,noisePixel,noiseValue);
final double A=computeValue(x,y,calibrationLine,calibrationPixel,calibrationValue);
final double noise=removeNoise ? eta / A : -eta / A;
final double tgtValue=srcValue - noise;
tgtData.setElemDoubleAt(index,tgtValue);
}
}
}
 catch (Throwable e) {
OperatorUtils.catchOperatorException(getId(),e);
}
 finally {
pm.done();
}
}"
11551,"/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    final MetadataElement oriProdMetadata=AbstractMetadata.getOriginalProductMetadata(sourceProduct);
    final MetadataElement finalMetadataElem=getParentMetadataElemForFlag(oriProdMetadata);
    final String flag=finalMetadataElem.getAttributeString(ANNOTATION_FLAG_NAME);
    performCorrection=flag.toLowerCase().equals(""String_Node_Str"");
    createTargetProduct();
    updateTargetProductMetadata();
    readLUTs(oriProdMetadata);
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Initializes this operator and sets the one and only target product. <p>The target product can be either defined by a field of type   {@link org.esa.beam.framework.datamodel.Product} annotated with the{@link org.esa.beam.framework.gpf.annotations.TargetProduct TargetProduct} annotation orby calling  {@link #setTargetProduct} method.</p><p>The framework calls this method after it has created this operator. Any client code that must be performed before computation of tile data should be placed here.</p>
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during operator initialisation.
 * @see #getTargetProduct()
 */
@Override public void initialize() throws OperatorException {
  try {
    final MetadataElement oriProdMetadata=AbstractMetadata.getOriginalProductMetadata(sourceProduct);
    final MetadataElement finalMetadataElem=getParentMetadataElemForFlag(oriProdMetadata);
    final String flag=finalMetadataElem.getAttributeString(ANNOTATION_FLAG_NAME);
    removeNoise=flag.toLowerCase().equals(""String_Node_Str"");
    createTargetProduct();
    updateTargetProductMetadata();
    readLUTs(oriProdMetadata);
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11552,"private static double computeValue(int x,int y,int[] line,ArrayList<int[]> pixel,ArrayList<double[]> value,int debugNum){
  final int leftYIdx=findLeftOfBracket(y,line);
  final int rightYIdx=(y == line[leftYIdx]) ? leftYIdx : leftYIdx + 1;
  double val=0.0;
  checkBracket(leftYIdx,rightYIdx,line.length - 1);
  if (leftYIdx == rightYIdx) {
    if (y != line[leftYIdx]) {
      throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx+ ""String_Node_Str""+ debugNum);
    }
  }
 else   if (y <= line[leftYIdx] || y >= line[rightYIdx]) {
    throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx+ ""String_Node_Str""+ rightYIdx+ ""String_Node_Str""+ debugNum);
  }
  final double topVal=linearInterpolateAlongLine(x,leftYIdx,pixel,value);
  final double bottomVal=linearInterpolateAlongLine(x,rightYIdx,pixel,value);
  val=linearInterpolate(leftYIdx,rightYIdx,y,topVal,bottomVal);
  return val;
}","private static double computeValue(int x,int y,int[] line,ArrayList<int[]> pixel,ArrayList<double[]> value,int debugNum){
  final int leftYIdx=findLeftOfBracket(y,line);
  final int rightYIdx=(y == line[leftYIdx]) ? leftYIdx : leftYIdx + 1;
  double val=0.0;
  checkBracket(leftYIdx,rightYIdx,line.length - 1);
  if (leftYIdx == rightYIdx) {
    if (y != line[leftYIdx]) {
      throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx+ ""String_Node_Str""+ debugNum);
    }
  }
 else   if (y <= line[leftYIdx] || y >= line[rightYIdx]) {
    throw new OperatorException(""String_Node_Str"" + y + ""String_Node_Str""+ leftYIdx+ ""String_Node_Str""+ line[leftYIdx]+ ""String_Node_Str""+ rightYIdx+ ""String_Node_Str""+ line[rightYIdx]+ ""String_Node_Str""+ debugNum);
  }
  final double topVal=linearInterpolateAlongLine(x,leftYIdx,pixel,value);
  final double bottomVal=linearInterpolateAlongLine(x,rightYIdx,pixel,value);
  val=linearInterpolate(leftYIdx,rightYIdx,y,topVal,bottomVal);
  return val;
}"
11553,"private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName(),sourceProduct.getProductType(),sourceProduct.getSceneRasterWidth(),sourceProduct.getSceneRasterHeight());
  final Band[] sourceBands=sourceProduct.getBands();
  for (  Band srcBand : sourceBands) {
    if ((srcBand instanceof VirtualBand)) {
      final VirtualBand srcVirtualBand=(VirtualBand)srcBand;
      final VirtualBand newVirtualBand=new VirtualBand(srcBand.getName(),srcBand.getDataType(),srcBand.getSceneRasterWidth(),srcBand.getRasterHeight(),srcVirtualBand.getExpression());
      targetProduct.addBand(newVirtualBand);
      ProductUtils.copyRasterDataNodeProperties(srcBand,newVirtualBand);
    }
    if (shouldApplyCorrection(srcBand)) {
      final Band newBand=new Band(srcBand.getName(),srcBand.getDataType(),srcBand.getSceneRasterWidth(),srcBand.getRasterHeight());
      targetProduct.addBand(newBand);
      ProductUtils.copyRasterDataNodeProperties(srcBand,newBand);
    }
 else {
      ProductUtils.copyBand(srcBand.getName(),sourceProduct,targetProduct,true);
    }
  }
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
}","private void createTargetProduct(){
  targetProduct=new Product(sourceProduct.getName(),sourceProduct.getProductType(),sourceProduct.getSceneRasterWidth(),sourceProduct.getSceneRasterHeight());
  final Band[] sourceBands=sourceProduct.getBands();
  for (  Band srcBand : sourceBands) {
    if ((srcBand instanceof VirtualBand)) {
      final VirtualBand srcVirtualBand=(VirtualBand)srcBand;
      final VirtualBand newVirtualBand=new VirtualBand(srcBand.getName(),srcBand.getDataType(),srcBand.getSceneRasterWidth(),srcBand.getRasterHeight(),srcVirtualBand.getExpression());
      targetProduct.addBand(newVirtualBand);
      ProductUtils.copyRasterDataNodeProperties(srcBand,newVirtualBand);
    }
 else     if (shouldApplyCorrection(srcBand)) {
      final Band newBand=new Band(srcBand.getName(),srcBand.getDataType(),srcBand.getSceneRasterWidth(),srcBand.getRasterHeight());
      targetProduct.addBand(newBand);
      ProductUtils.copyRasterDataNodeProperties(srcBand,newBand);
    }
 else {
      ProductUtils.copyBand(srcBand.getName(),sourceProduct,targetProduct,true);
    }
  }
  ProductUtils.copyProductNodes(sourceProduct,targetProduct);
}"
11554,"/** 
 * Compute kernel function value for a given pair of samples.
 * @param x1 The first sample.
 * @param x2 The second sample.
 * @return The kernel function value.
 * @throws Exception The exception.
 */
public double kernel(final double[] x1,final double[] x2) throws Exception {
  if (x1.length != x2.length) {
    throw new Exception(""String_Node_Str"");
  }
  double sum=0.0;
  for (int i=0; i < x1.length; i++) {
    final double d=x1[i] - x2[i];
    sum+=d * d;
  }
  return Math.exp(-modelParameters.gamma * sum);
}","/** 
 * Compute kernel function value for a given pair of samples.
 * @param x1 The first sample.
 * @param x2 The second sample.
 * @return The kernel function value.
 * @throws Exception The exception.
 */
public double kernel(final double[] x1,final double[] x2) throws Exception {
  if (x1.length != numFeatures || x2.length != numFeatures) {
    throw new Exception(""String_Node_Str"");
  }
  double sum=0.0;
  for (int i=0; i < x1.length; i++) {
    final double d=scale(i,x1[i]) - scale(i,x2[i]);
    sum+=d * d;
  }
  return Math.exp(-modelParameters.gamma * sum);
}"
11555,"/** 
 * Reconstruct full pol coherency matrix T3 using compact pol data. The random volume over ground (RVOG) model is assumed.
 * @param sourceProductType The compact pol source product type
 * @param idx Pixel index in source product
 * @param dataBuffers Source band data buffers
 * @param Tr Real part of the reconstructed T3 matrix
 * @param Ti Imaginary part of the reconstructed T3 matrix
 */
public static void reconstructCoherencyMatrixT3(final PolBandUtils.MATRIX sourceProductType,final int idx,final ProductData[] dataBuffers,final double[][] Tr,final double[][] Ti){
  final double[][] Cr=new double[2][2];
  final double[][] Ci=new double[2][2];
  final double[] kr=new double[2];
  final double[] ki=new double[2];
  final double[] g=new double[4];
  if (sourceProductType == PolBandUtils.MATRIX.C2) {
    getCovarianceMatrixC2(idx,dataBuffers,Cr,Ci);
    computeCompactPolStokesVector(Cr,Ci,g);
  }
 else   if (sourceProductType == PolBandUtils.MATRIX.COMPACT) {
    getCompactPolScatterVector(idx,dataBuffers,kr,ki);
    computeCompactPolStokesVector(kr,ki,g);
  }
  if (g[0] <= 0) {
    return;
  }
  final double m=Math.sqrt(g[1] * g[1] + g[2] * g[2] + g[3] * g[3]) / g[0];
  final double mv=0.5 * g[0] * (1 - m);
  final double ms=2.0 * g[0] * m;
  final double alpha=0.5 * Math.atan(Math.sqrt(g[1] * g[1] + g[2] * g[2]) / g[3]);
  final double phi=Math.acos(g[1] / Math.sqrt(g[1] * g[1] + g[2] * g[2]));
  final double cosAlpha=Math.cos(alpha);
  final double sinAlpha=Math.sin(alpha);
  final double cosPhi=Math.cos(phi);
  final double sinPhi=Math.sin(phi);
  Tr[0][0]=ms * cosAlpha * cosAlpha + 2.0 * mv;
  Ti[0][0]=0.0;
  Tr[0][1]=ms * cosAlpha * sinAlpha* cosPhi;
  Ti[0][1]=ms * cosAlpha * sinAlpha* sinPhi;
  Tr[0][2]=0.0;
  Ti[0][2]=0.0;
  Tr[1][0]=Tr[0][1];
  Ti[1][0]=-Ti[0][1];
  Tr[1][1]=ms * sinAlpha * sinAlpha + mv;
  Ti[1][1]=0.0;
  Tr[1][2]=0.0;
  Ti[1][2]=0.0;
  Tr[2][0]=0.0;
  Ti[2][0]=0.0;
  Tr[2][1]=0.0;
  Ti[2][1]=0.0;
  Tr[2][2]=mv;
  Ti[2][2]=0.0;
}","/** 
 * Reconstruct full pol coherency matrix T3 using compact pol data. The random volume over ground (RVOG) model is assumed.
 * @param sourceProductType The compact pol source product type
 * @param idx Pixel index in source product
 * @param dataBuffers Source band data buffers
 * @param Tr Real part of the reconstructed T3 matrix
 * @param Ti Imaginary part of the reconstructed T3 matrix
 */
public static void reconstructCoherencyMatrixT3(final PolBandUtils.MATRIX sourceProductType,final int idx,final ProductData[] dataBuffers,final double[][] Tr,final double[][] Ti){
  final double[][] Cr=new double[2][2];
  final double[][] Ci=new double[2][2];
  final double[] kr=new double[2];
  final double[] ki=new double[2];
  final double[] g=new double[4];
  if (sourceProductType == PolBandUtils.MATRIX.C2) {
    getCovarianceMatrixC2(idx,dataBuffers,Cr,Ci);
    computeCompactPolStokesVector(Cr,Ci,g);
  }
 else   if (sourceProductType == PolBandUtils.MATRIX.COMPACT) {
    getCompactPolScatterVector(idx,dataBuffers,kr,ki);
    computeCompactPolStokesVector(kr,ki,g);
  }
  if (g[0] <= 0 || g[3] == 0) {
    return;
  }
  final double m=Math.sqrt(g[1] * g[1] + g[2] * g[2] + g[3] * g[3]) / g[0];
  final double mv=0.5 * g[0] * (1 - m);
  final double ms=2.0 * g[0] * m;
  final double alpha=0.5 * Math.atan(Math.sqrt(g[1] * g[1] + g[2] * g[2]) / (-g[3]));
  final double phi=Math.acos(g[1] / Math.sqrt(g[1] * g[1] + g[2] * g[2]));
  final double cosAlpha=Math.cos(alpha);
  final double sinAlpha=Math.sin(alpha);
  final double cosPhi=Math.cos(phi);
  final double sinPhi=Math.sin(phi);
  Tr[0][0]=ms * cosAlpha * cosAlpha + 2.0 * mv;
  Ti[0][0]=0.0;
  Tr[0][1]=ms * cosAlpha * sinAlpha* cosPhi;
  Ti[0][1]=ms * cosAlpha * sinAlpha* sinPhi;
  Tr[0][2]=0.0;
  Ti[0][2]=0.0;
  Tr[1][0]=Tr[0][1];
  Ti[1][0]=-Ti[0][1];
  Tr[1][1]=ms * sinAlpha * sinAlpha + mv;
  Ti[1][1]=0.0;
  Tr[1][2]=0.0;
  Ti[1][2]=0.0;
  Tr[2][0]=0.0;
  Ti[2][0]=0.0;
  Tr[2][1]=0.0;
  Ti[2][1]=0.0;
  Tr[2][2]=mv;
  Ti[2][2]=0.0;
}"
11556,"private void getCornerCoords(MetadataElement sceneInfo,MetadataElement geocodedImageInfo){
  int maxRow=0, maxCol=0;
  int minRow=Integer.MAX_VALUE, minCol=Integer.MAX_VALUE;
  final List<CornerCoord> coordList=new ArrayList<CornerCoord>();
  final MetadataElement[] children=sceneInfo.getElements();
  for (  MetadataElement child : children) {
    if (child.getName().equals(""String_Node_Str"")) {
      final int refRow=child.getAttributeInt(""String_Node_Str"",0);
      final int refCol=child.getAttributeInt(""String_Node_Str"",0);
      coordList.add(new CornerCoord(refRow,refCol,(float)child.getAttributeDouble(""String_Node_Str"",0),(float)child.getAttributeDouble(""String_Node_Str"",0),(float)child.getAttributeDouble(""String_Node_Str"",0) * 1000000000f,(float)child.getAttributeDouble(""String_Node_Str"",0)));
      if (refRow > maxRow)       maxRow=refRow;
      if (refCol > maxCol)       maxCol=refCol;
      if (refRow < minRow)       minRow=refRow;
      if (refCol < minCol)       minCol=refCol;
    }
  }
  int[] indexArray={0,1,2,3};
  if (minRow == maxRow && minCol == maxCol && geocodedImageInfo != null) {
    final MetadataElement geoParameter=geocodedImageInfo.getElement(""String_Node_Str"");
    final MetadataElement sceneCoordsGeographic=geoParameter.getElement(""String_Node_Str"");
    final float latUL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float latUR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float latLL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float latLR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonUL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonUR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonLL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonLR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    int k=0;
    final double e=1e-3;
    for (    CornerCoord coord : coordList) {
      if (Math.abs(coord.lat - latUL) < e && Math.abs(coord.lon - lonUL) < e) {
        indexArray[k]=0;
      }
 else       if (Math.abs(coord.lat - latUR) < e && Math.abs(coord.lon - lonUR) < e) {
        indexArray[k]=1;
      }
 else       if (Math.abs(coord.lat - latLL) < e && Math.abs(coord.lon - lonLL) < e) {
        indexArray[k]=2;
      }
 else       if (Math.abs(coord.lat - latLR) < e && Math.abs(coord.lon - lonLR) < e) {
        indexArray[k]=3;
      }
      k++;
    }
  }
  int index=0;
  for (  CornerCoord coord : coordList) {
    if (minRow == maxRow && minCol == maxCol) {
      latCorners[indexArray[index]]=coord.lat;
      lonCorners[indexArray[index]]=coord.lon;
      slantRangeCorners[indexArray[index]]=coord.rangeTime;
      incidenceCorners[indexArray[index]]=coord.incidenceAngle;
      ++index;
    }
 else {
      index=-1;
      if (coord.refRow == minRow) {
        if (Math.abs(coord.refCol - minCol) < Math.abs(coord.refCol - maxCol)) {
          index=0;
        }
 else {
          index=1;
        }
      }
 else       if (coord.refRow == maxRow) {
        if (Math.abs(coord.refCol - minCol) < Math.abs(coord.refCol - maxCol)) {
          index=2;
        }
 else {
          index=3;
        }
      }
      if (index >= 0) {
        latCorners[index]=coord.lat;
        lonCorners[index]=coord.lon;
        slantRangeCorners[index]=coord.rangeTime;
        incidenceCorners[index]=coord.incidenceAngle;
      }
    }
  }
}","private void getCornerCoords(MetadataElement sceneInfo,MetadataElement geocodedImageInfo){
  int maxRow=0, maxCol=0;
  int minRow=Integer.MAX_VALUE, minCol=Integer.MAX_VALUE;
  final List<CornerCoord> coordList=new ArrayList<CornerCoord>();
  final MetadataElement[] children=sceneInfo.getElements();
  for (  MetadataElement child : children) {
    if (child.getName().equals(""String_Node_Str"")) {
      final int refRow=child.getAttributeInt(""String_Node_Str"",0);
      final int refCol=child.getAttributeInt(""String_Node_Str"",0);
      coordList.add(new CornerCoord(refRow,refCol,(float)child.getAttributeDouble(""String_Node_Str"",0),(float)child.getAttributeDouble(""String_Node_Str"",0),(float)child.getAttributeDouble(""String_Node_Str"",0) * 1000000000f,(float)child.getAttributeDouble(""String_Node_Str"",0)));
      if (refRow > maxRow)       maxRow=refRow;
      if (refCol > maxCol)       maxCol=refCol;
      if (refRow < minRow)       minRow=refRow;
      if (refCol < minCol)       minCol=refCol;
    }
  }
  int[] indexArray={0,1,2,3};
  if (minRow == maxRow && minCol == maxCol && geocodedImageInfo != null) {
    final MetadataElement geoParameter=geocodedImageInfo.getElement(""String_Node_Str"");
    final MetadataElement sceneCoordsGeographic=geoParameter.getElement(""String_Node_Str"");
    final float latUL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float latUR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float latLL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float latLR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonUL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonUR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonLL=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    final float lonLR=(float)sceneCoordsGeographic.getAttributeDouble(""String_Node_Str"",0);
    int k=0;
    double d0, d1, d2, d3;
    for (    CornerCoord coord : coordList) {
      d0=Math.abs(coord.lat - latUL) + Math.abs(coord.lon - lonUL);
      d1=Math.abs(coord.lat - latUR) + Math.abs(coord.lon - lonUR);
      d2=Math.abs(coord.lat - latLL) + Math.abs(coord.lon - lonLL);
      d3=Math.abs(coord.lat - latLR) + Math.abs(coord.lon - lonLR);
      if (d0 <= d1 && d0 <= d2 && d0 <= d3) {
        indexArray[k]=0;
      }
 else       if (d1 <= d0 && d1 <= d2 && d1 <= d3) {
        indexArray[k]=1;
      }
 else       if (d2 <= d0 && d2 <= d1 && d2 <= d3) {
        indexArray[k]=2;
      }
 else       if (d3 <= d0 && d3 <= d1 && d3 <= d2) {
        indexArray[k]=3;
      }
      k++;
    }
  }
  int index=0;
  for (  CornerCoord coord : coordList) {
    if (minRow == maxRow && minCol == maxCol) {
      latCorners[indexArray[index]]=coord.lat;
      lonCorners[indexArray[index]]=coord.lon;
      slantRangeCorners[indexArray[index]]=coord.rangeTime;
      incidenceCorners[indexArray[index]]=coord.incidenceAngle;
      ++index;
    }
 else {
      index=-1;
      if (coord.refRow == minRow) {
        if (Math.abs(coord.refCol - minCol) < Math.abs(coord.refCol - maxCol)) {
          index=0;
        }
 else {
          index=1;
        }
      }
 else       if (coord.refRow == maxRow) {
        if (Math.abs(coord.refCol - minCol) < Math.abs(coord.refCol - maxCol)) {
          index=2;
        }
 else {
          index=3;
        }
      }
      if (index >= 0) {
        latCorners[index]=coord.lat;
        lonCorners[index]=coord.lon;
        slantRangeCorners[index]=coord.rangeTime;
        incidenceCorners[index]=coord.incidenceAngle;
      }
    }
  }
}"
11557,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTileMap The target tiles associated with all target bands to be computed.
 * @param targetRectangle The rectangle of target tile.
 * @param pm A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTileMap,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    if (!statsCalculated) {
      calculateStatistics();
    }
    final ProductData[] bandsRawSamples=new ProductData[numOfSourceBands];
    for (int i=0; i < numOfSourceBands; i++) {
      bandsRawSamples[i]=getSourceTile(sourceProduct.getBand(sourceBandNames[i]),targetRectangle).getRawSamples();
    }
    final int n=bandsRawSamples[0].getNumElems();
    for (int i=0; i < numPCA; i++) {
      final Band targetBand=targetProduct.getBand(""String_Node_Str"" + i);
      final Tile targetTile=targetTileMap.get(targetBand);
      final ProductData trgData=targetTile.getDataBuffer();
      for (int k=0; k < n; k++) {
        double vPCA=0.0;
        for (int j=0; j < numOfSourceBands; j++) {
          vPCA+=bandsRawSamples[j].getElemDoubleAt(k) * eigenVectorMatrices[j][i];
        }
        trgData.setElemDoubleAt(k,vPCA - minPCA[i]);
      }
    }
  }
 catch (  Throwable e) {
    throw new OperatorException(e);
  }
 finally {
    pm.done();
  }
  pcaImageComputed=true;
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTileMap The target tiles associated with all target bands to be computed.
 * @param targetRectangle The rectangle of target tile.
 * @param pm A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTileMap,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final int x0=targetRectangle.x;
    final int y0=targetRectangle.y;
    final int w=targetRectangle.width;
    final int h=targetRectangle.height;
    if (!statsCalculated) {
      calculateStatistics();
    }
    final ProductData[] bandsRawSamples=new ProductData[numOfSourceBands];
    for (int i=0; i < numOfSourceBands; i++) {
      bandsRawSamples[i]=getSourceTile(sourceProduct.getBand(sourceBandNames[i]),targetRectangle).getRawSamples();
    }
    for (int i=0; i < numPCA; i++) {
      final Band targetBand=targetProduct.getBand(""String_Node_Str"" + i);
      final Tile targetTile=targetTileMap.get(targetBand);
      final ProductData trgData=targetTile.getDataBuffer();
      final TileIndex targetIndex=new TileIndex(targetTile);
      int index;
      int k=0;
      for (int y=y0; y < y0 + h; y++) {
        targetIndex.calculateStride(y);
        for (int x=x0; x < x0 + w; x++) {
          index=targetIndex.getIndex(x);
          double vPCA=0.0;
          for (int j=0; j < numOfSourceBands; j++) {
            vPCA+=bandsRawSamples[j].getElemDoubleAt(k) * eigenVectorMatrices[j][i];
          }
          k++;
          trgData.setElemDoubleAt(index,vPCA - minPCA[i]);
        }
      }
    }
  }
 catch (  Throwable e) {
    throw new OperatorException(e);
  }
 finally {
    pm.done();
  }
  pcaImageComputed=true;
}"
11558,"public UIValidation validateParameters(){
  if (getSelectedFilter(tree) == null && kernelFile.getText().equals(""String_Node_Str""))   return new UIValidation(UIValidation.State.ERROR,""String_Node_Str"");
  return new UIValidation(UIValidation.State.OK,""String_Node_Str"");
}","public UIValidation validateParameters(){
  if (sourceProducts != null) {
    if (getSelectedFilter(tree) == null && kernelFile.getText().equals(""String_Node_Str""))     return new UIValidation(UIValidation.State.ERROR,""String_Node_Str"");
  }
  return new UIValidation(UIValidation.State.OK,""String_Node_Str"");
}"
11559,"/** 
 * Convert satellite position from deodetic coordinate to global cartesian coordinate.
 * @param dataRecord The data record read from delft orbit file.
 * @return The data record in cartesian coordinate.
 */
private OrbitPositionRecord computeOrbitPosition(OrbitDataRecord dataRecord){
  final double time=(double)dataRecord.time / Constants.secondsInDay;
  final double utcTime=time + days1985To2000;
  final double alt=(double)dataRecord.heightOfCenterOfMass / 1000.0;
  double lat, lon;
  if (productSpecifier.contains(""String_Node_Str"")) {
    lat=(double)dataRecord.latitude / Constants.oneMillion;
    lon=(double)dataRecord.longitude / Constants.oneMillion;
  }
 else   if (productSpecifier.contains(""String_Node_Str"")) {
    lat=(double)dataRecord.latitude / Constants.oneMillion;
    lon=(double)dataRecord.longitude / Constants.oneMillion;
    if (lon > 180) {
      lon-=360;
    }
  }
 else {
    throw new OperatorException(""String_Node_Str"" + productSpecifier);
  }
  final double[] xyz=new double[3];
  GeoUtils.geo2xyz(lat,lon,alt,xyz,GeoUtils.EarthModel.GRS80);
  final OrbitPositionRecord orbitPosition=new OrbitPositionRecord();
  orbitPosition.utcTime=utcTime;
  orbitPosition.xPos=xyz[0];
  orbitPosition.yPos=xyz[1];
  orbitPosition.zPos=xyz[2];
  return orbitPosition;
}","/** 
 * Convert satellite position from deodetic coordinate to global cartesian coordinate.
 * @param dataRecord The data record read from delft orbit file.
 * @return The data record in cartesian coordinate.
 */
private OrbitPositionRecord computeOrbitPosition(OrbitDataRecord dataRecord){
  final double time=(double)dataRecord.time / Constants.secondsInDay;
  final double utcTime=time + days1985To2000;
  final double alt=(double)dataRecord.heightOfCenterOfMass / 1000.0;
  double lat, lon;
  if (productSpecifier.contains(""String_Node_Str"")) {
    lat=(double)dataRecord.latitude / Constants.tenMillion;
    lon=(double)dataRecord.longitude / Constants.tenMillion;
  }
 else   if (productSpecifier.contains(""String_Node_Str"")) {
    lat=(double)dataRecord.latitude / Constants.oneMillion;
    lon=(double)dataRecord.longitude / Constants.oneMillion;
    if (lon > 180) {
      lon-=360;
    }
  }
 else {
    throw new OperatorException(""String_Node_Str"" + productSpecifier);
  }
  final double[] xyz=new double[3];
  GeoUtils.geo2xyz(lat,lon,alt,xyz,GeoUtils.EarthModel.GRS80);
  final OrbitPositionRecord orbitPosition=new OrbitPositionRecord();
  orbitPosition.utcTime=utcTime;
  orbitPosition.xPos=xyz[0];
  orbitPosition.yPos=xyz[1];
  orbitPosition.zPos=xyz[2];
  return orbitPosition;
}"
11560,"/** 
 * Removes the given product from this product manager if it exists.
 * @param product the product to be removed, ignored if <code>null</code>
 * @return true, if the product was removed
 */
public boolean removeProduct(Product product){
  if (product != null) {
    int index=productList.indexOf(product);
    if (index >= 0) {
      if (productList.remove(product)) {
        productList.clearRemovedList();
        product.removeProductNodeListener(productNodeNameChangeListener);
        product.resetRefNo();
        clearProductManager(product);
        fireEvent(product,PRODUCT_REMOVED);
        return true;
      }
    }
  }
  return false;
}","/** 
 * Removes the given product from this product manager if it exists.
 * @param product the product to be removed, ignored if <code>null</code>
 * @return true, if the product was removed
 */
public boolean removeProduct(Product product){
  if (product != null) {
    int index=productList.indexOf(product);
    if (index >= 0) {
      if (productList.remove(product)) {
        productList.clearRemovedList();
        product.removeProductNodeListener(productNodeNameChangeListener);
        clearProductManager(product);
        fireEvent(product,PRODUCT_REMOVED);
        product.resetRefNo();
        return true;
      }
    }
  }
  return false;
}"
11561,"/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final int x0=tx0 * nRgLooks;
  final int y0=ty0 * nAzLooks;
  final int w=tw * nRgLooks;
  final int h=th * nAzLooks;
  final Rectangle sourceTileRectangle=new Rectangle(x0,y0,w,h);
  try {
    Tile sourceRaster1;
    Tile sourceRaster2=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    Band sourceBand1;
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      if (sourceRaster1 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      sourceRaster2=getSourceTile(sourceBand2,sourceTileRectangle);
      if (sourceRaster1 == null || sourceRaster2 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
    final ProductData trgData=targetTile.getDataBuffer();
    final ProductData srcData1=sourceRaster1.getDataBuffer();
    final ProductData srcData2=sourceRaster2 != null ? sourceRaster2.getDataBuffer() : null;
    final TileIndex trgIndex=new TileIndex(targetTile);
    final TileIndex srcIndex=new TileIndex(sourceRaster1);
    final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
    final boolean isdB=bandUnit == Unit.UnitType.INTENSITY_DB || bandUnit == Unit.UnitType.AMPLITUDE_DB;
    final boolean isComplex=outputIntensity && (bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY);
    double meanValue;
    int tOffset, sOffset;
    final int maxy=ty0 + th;
    final int maxx=tx0 + tw;
    if (nRgLooks == 1 && nAzLooks == 1) {
      if (isComplex) {
        for (int ty=ty0; ty < maxy; ty++) {
          tOffset=trgIndex.calculateStride(ty);
          sOffset=srcIndex.calculateStride(ty);
          for (int tx=tx0; tx < maxx; tx++) {
            final int sIndex=tx - sOffset;
            final double i=srcData1.getElemDoubleAt(sIndex);
            final double q=srcData2.getElemDoubleAt(sIndex);
            trgData.setElemDoubleAt(tx - tOffset,i * i + q * q);
          }
        }
      }
 else {
        targetTile.setRawSamples(getSourceTile(sourceBand1,targetTile.getRectangle()).getRawSamples());
      }
    }
 else {
      for (int ty=ty0; ty < maxy; ty++) {
        trgIndex.calculateStride(ty);
        for (int tx=tx0; tx < maxx; tx++) {
          meanValue=getMeanValue(tx,ty,srcData1,srcData2,srcIndex,nRgLooks,nAzLooks,isdB,isComplex);
          trgData.setElemDoubleAt(trgIndex.getIndex(tx),meanValue);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}","/** 
 * Called by the framework in order to compute a tile for the given target band. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetBand The target band.
 * @param targetTile The current tile associated with the target band to be computed.
 * @param pm         A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException If an error occurs during computation of the target raster.
 */
@Override public synchronized void computeTile(Band targetBand,Tile targetTile,ProgressMonitor pm) throws OperatorException {
  final Rectangle targetTileRectangle=targetTile.getRectangle();
  final int tx0=targetTileRectangle.x;
  final int ty0=targetTileRectangle.y;
  final int tw=targetTileRectangle.width;
  final int th=targetTileRectangle.height;
  final int x0=tx0 * nRgLooks;
  final int y0=ty0 * nAzLooks;
  final int w=tw * nRgLooks;
  final int h=th * nAzLooks;
  final Rectangle sourceTileRectangle=new Rectangle(x0,y0,w,h);
  try {
    Tile sourceRaster1;
    Tile sourceRaster2=null;
    final String[] srcBandNames=targetBandNameToSourceBandName.get(targetBand.getName());
    Band sourceBand1;
    if (srcBandNames.length == 1) {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      if (sourceRaster1 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
 else {
      sourceBand1=sourceProduct.getBand(srcBandNames[0]);
      final Band sourceBand2=sourceProduct.getBand(srcBandNames[1]);
      sourceRaster1=getSourceTile(sourceBand1,sourceTileRectangle);
      sourceRaster2=getSourceTile(sourceBand2,sourceTileRectangle);
      if (sourceRaster1 == null || sourceRaster2 == null) {
        throw new OperatorException(""String_Node_Str"");
      }
    }
    final ProductData trgData=targetTile.getDataBuffer();
    final ProductData srcData1=sourceRaster1.getDataBuffer();
    final ProductData srcData2=sourceRaster2 != null ? sourceRaster2.getDataBuffer() : null;
    final TileIndex trgIndex=new TileIndex(targetTile);
    final TileIndex srcIndex=new TileIndex(sourceRaster1);
    final Unit.UnitType bandUnit=Unit.getUnitType(sourceBand1);
    final boolean isdB=bandUnit == Unit.UnitType.INTENSITY_DB || bandUnit == Unit.UnitType.AMPLITUDE_DB;
    final boolean isComplex=outputIntensity && (bandUnit == Unit.UnitType.REAL || bandUnit == Unit.UnitType.IMAGINARY);
    double meanValue;
    int offset;
    final int maxy=ty0 + th;
    final int maxx=tx0 + tw;
    if (nRgLooks == 1 && nAzLooks == 1) {
      if (!isComplex && targetTile.getDataBuffer().getType() == sourceRaster1.getDataBuffer().getType()) {
        targetTile.setRawSamples(sourceRaster1.getRawSamples());
      }
 else {
        for (int ty=ty0; ty < maxy; ty++) {
          offset=trgIndex.calculateStride(ty);
          for (int tx=tx0; tx < maxx; tx++) {
            final int index=tx - offset;
            final double i=srcData1.getElemDoubleAt(index);
            if (srcData2 != null) {
              final double q=srcData2.getElemDoubleAt(index);
              trgData.setElemDoubleAt(index,i * i + q * q);
            }
 else {
              trgData.setElemDoubleAt(index,i);
            }
          }
        }
      }
    }
 else {
      for (int ty=ty0; ty < maxy; ty++) {
        trgIndex.calculateStride(ty);
        for (int tx=tx0; tx < maxx; tx++) {
          meanValue=getMeanValue(tx,ty,srcData1,srcData2,srcIndex,nRgLooks,nAzLooks,isdB,isComplex);
          trgData.setElemDoubleAt(trgIndex.getIndex(tx),meanValue);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}"
11562,"@Override public void initialize() throws OperatorException {
  if (width == 0) {
    width=sourceProduct.getSceneRasterWidth() - regionX;
  }
  if (height == 0) {
    height=sourceProduct.getSceneRasterHeight() - regionY;
  }
  if (regionX + width > sourceProduct.getSceneRasterWidth()) {
    throw new OperatorException(""String_Node_Str"" + sourceProduct.getSceneRasterWidth() + ""String_Node_Str""+ sourceProduct.getSceneRasterHeight());
  }
  if (regionY + height > sourceProduct.getSceneRasterHeight()) {
    throw new OperatorException(""String_Node_Str"" + sourceProduct.getSceneRasterWidth() + ""String_Node_Str""+ sourceProduct.getSceneRasterHeight());
  }
  subsetReader=new ProductSubsetBuilder();
  final ProductSubsetDef subsetDef=new ProductSubsetDef();
  subsetDef.addNodeNames(sourceProduct.getTiePointGridNames());
  if (sourceBandNames != null && sourceBandNames.length > 0) {
    subsetDef.addNodeNames(sourceBandNames);
  }
 else {
    subsetDef.addNodeNames(sourceProduct.getBandNames());
  }
  subsetDef.setRegion(regionX,regionY,width,height);
  if (geoRegion != null) {
    final Rectangle region=computePixelRegion(sourceProduct,geoRegion,0);
    if (region != null) {
      if (region.isEmpty()) {
        throw new OperatorException(""String_Node_Str"" + sourceProduct.getName());
      }
      subsetDef.setRegion(region);
    }
  }
  subsetDef.setSubSampling(subSamplingX,subSamplingY);
  subsetDef.setIgnoreMetadata(false);
  try {
    targetProduct=subsetReader.readProductNodes(sourceProduct,subsetDef);
    for (    Band b : targetProduct.getBands()) {
      if (b instanceof VirtualBand) {
        targetProduct.removeBand(b);
        final Band newBand=targetProduct.addBand(b.getName(),b.getDataType());
        newBand.setNoDataValue(b.getNoDataValue());
        newBand.setNoDataValueUsed(b.isNoDataValueUsed());
        newBand.setDescription(b.getDescription());
        newBand.setUnit(b.getUnit());
        bandMap.put(newBand,b);
      }
    }
  }
 catch (  Throwable t) {
    throw new OperatorException(t);
  }
}","@Override public void initialize() throws OperatorException {
  if (width == 0 || regionX + width > sourceProduct.getSceneRasterWidth()) {
    width=sourceProduct.getSceneRasterWidth() - regionX;
  }
  if (height == 0 || regionY + height > sourceProduct.getSceneRasterHeight()) {
    height=sourceProduct.getSceneRasterHeight() - regionY;
  }
  subsetReader=new ProductSubsetBuilder();
  final ProductSubsetDef subsetDef=new ProductSubsetDef();
  subsetDef.addNodeNames(sourceProduct.getTiePointGridNames());
  if (sourceBandNames != null && sourceBandNames.length > 0) {
    subsetDef.addNodeNames(sourceBandNames);
  }
 else {
    subsetDef.addNodeNames(sourceProduct.getBandNames());
  }
  subsetDef.setRegion(regionX,regionY,width,height);
  if (geoRegion != null) {
    final Rectangle region=computePixelRegion(sourceProduct,geoRegion,0);
    if (region != null) {
      if (region.isEmpty()) {
        throw new OperatorException(""String_Node_Str"" + sourceProduct.getName());
      }
      subsetDef.setRegion(region);
    }
  }
  subsetDef.setSubSampling(subSamplingX,subSamplingY);
  subsetDef.setIgnoreMetadata(false);
  try {
    targetProduct=subsetReader.readProductNodes(sourceProduct,subsetDef);
    for (    Band b : targetProduct.getBands()) {
      if (b instanceof VirtualBand) {
        targetProduct.removeBand(b);
        final Band newBand=targetProduct.addBand(b.getName(),b.getDataType());
        newBand.setNoDataValue(b.getNoDataValue());
        newBand.setNoDataValueUsed(b.isNoDataValueUsed());
        newBand.setDescription(b.getDescription());
        newBand.setUnit(b.getUnit());
        bandMap.put(newBand,b);
      }
    }
  }
 catch (  Throwable t) {
    throw new OperatorException(t);
  }
}"
11563,"@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames());
  regionX.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  regionY.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  Integer widthVal=(Integer)paramMap.get(""String_Node_Str"");
  Integer heightVal=(Integer)paramMap.get(""String_Node_Str"");
  if (sourceProducts != null && sourceProducts.length > 0) {
    if (widthVal == null || widthVal == 0)     widthVal=sourceProducts[0].getSceneRasterWidth();
    if (heightVal == null || heightVal == 0)     heightVal=sourceProducts[0].getSceneRasterHeight();
    worldMapUI.getModel().setAutoZoomEnabled(true);
    worldMapUI.getModel().setProducts(sourceProducts);
    worldMapUI.getModel().setSelectedProduct(sourceProducts[0]);
    worldMapUI.getWorlMapPane().zoomToProduct(sourceProducts[0]);
  }
  width.setText(String.valueOf(widthVal));
  height.setText(String.valueOf(heightVal));
  subSamplingX.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  subSamplingY.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  geoRegion=(Geometry)paramMap.get(""String_Node_Str"");
  if (geoRegion != null) {
    geoCoordRadio.setSelected(true);
    final Coordinate coord[]=geoRegion.getCoordinates();
    worldMapUI.setSelectionStart((float)coord[0].y,(float)coord[0].x);
    worldMapUI.setSelectionEnd((float)coord[2].y,(float)coord[2].x);
    pixelPanel.setVisible(false);
    geoPanel.setVisible(true);
  }
}","@Override public void initParameters(){
  OperatorUIUtils.initParamList(bandList,getBandNames());
  regionX.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  regionY.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  Integer widthVal=(Integer)paramMap.get(""String_Node_Str"");
  Integer heightVal=(Integer)paramMap.get(""String_Node_Str"");
  if (sourceProducts != null && sourceProducts.length > 0) {
    if (widthVal == null || widthVal == 0)     widthVal=sourceProducts[0].getSceneRasterWidth();
    if (heightVal == null || heightVal == 0)     heightVal=sourceProducts[0].getSceneRasterHeight();
    worldMapUI.getModel().setAutoZoomEnabled(true);
    worldMapUI.getModel().setProducts(sourceProducts);
    worldMapUI.getModel().setSelectedProduct(sourceProducts[0]);
    worldMapUI.getWorlMapPane().zoomToProduct(sourceProducts[0]);
  }
  width.setText(String.valueOf(widthVal));
  height.setText(String.valueOf(heightVal));
  subSamplingX.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  subSamplingY.setText(String.valueOf(paramMap.get(""String_Node_Str"")));
  geoRegion=(Geometry)paramMap.get(""String_Node_Str"");
  if (geoRegion != null) {
    geoCoordRadio.setSelected(true);
    final Coordinate coord[]=geoRegion.getCoordinates();
    worldMapUI.setSelectionStart((float)coord[0].y,(float)coord[0].x);
    worldMapUI.setSelectionEnd((float)coord[2].y,(float)coord[2].x);
    pixelPanel.setVisible(false);
    geoPanel.setVisible(true);
    getGeoRegion();
  }
}"
11564,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  double tileOverlapPercentage;
  try {
    if (!isElevationModelAvailable) {
      getElevationModel();
    }
    tileOverlapPercentage=computeTileOverlapPercentage(x0,y0,w,h);
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
  final Tile targetTile=targetTiles.get(targetProduct.getBand(SIMULATED_BAND_NAME));
  final ProductData masterBuffer=targetTile.getDataBuffer();
  ProductData demBandBuffer=null;
  ProductData zeroHeightBandBuffer=null;
  ProductData localIncidenceAngleBandBuffer=null;
  ProductData layoverShadowMaskBuffer=null;
  if (saveDEM) {
    demBandBuffer=targetTiles.get(targetProduct.getBand(demBandName)).getDataBuffer();
  }
  if (saveZeroHeightSimulation) {
    zeroHeightBandBuffer=targetTiles.get(targetProduct.getBand(zeroHeightSimulationBandName)).getDataBuffer();
  }
  if (saveLocalIncidenceAngle) {
    localIncidenceAngleBandBuffer=targetTiles.get(targetProduct.getBand(simulatedLocalIncidenceAngleBandName)).getDataBuffer();
  }
  if (saveLayoverShadowMask) {
    layoverShadowMaskBuffer=targetTiles.get(targetProduct.getBand(layoverShadowMaskBandName)).getDataBuffer();
  }
  int ymin, ymax;
  if (tileOverlapPercentage >= 0.0f) {
    ymin=Math.max(y0 - (int)(tileSize * tileOverlapPercentage),0);
    ymax=y0 + h;
  }
 else {
    ymin=y0;
    ymax=y0 + h + (int)(tileSize * Math.abs(tileOverlapPercentage));
  }
  final int xmax=x0 + w;
  final PositionData posData=new PositionData();
  final GeoPos geoPos=new GeoPos();
  double[] slrs=null;
  double[] elev=null;
  int[] index=null;
  final boolean[] savePixel=new boolean[w];
  if (saveLayoverShadowMask) {
    slrs=new double[w];
    elev=new double[w];
    index=new int[w];
  }
  try {
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(x0,xmax,ymin,ymax,latLonMinMax);
      final double latMin=latLonMinMax[0];
      final double latMax=latLonMinMax[1];
      final double lonMin=latLonMinMax[2];
      final double lonMax=latLonMinMax[3];
      final int nLat=(int)((latMax - latMin) / delLat) + 1;
      final int nLon=(int)((lonMax - lonMin) / delLon) + 1;
      final double[][] tileDEM=new double[nLat + 1][nLon + 1];
      final double[][] neighbourDEM=new double[3][3];
      double alt;
      for (int i=0; i < nLat; i++) {
        final double lat=latMin + i * delLat;
        for (int j=0; j < nLon; j++) {
          double lon=lonMin + j * delLon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (saveZeroHeightSimulation) {
            alt=1;
          }
 else {
            geoPos.setLocation((float)lat,(float)lon);
            alt=dem.getElevation(geoPos);
            if (alt == demNoDataValue)             continue;
          }
          tileDEM[i][j]=alt;
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(lat,lon,delLat,delLon,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          int r=0;
          for (int ii=Math.max(0,i - 1); ii <= i + 1; ++ii) {
            ii=Math.min(nLat,ii);
            int c=0;
            float neighbourLat=(float)(latMin + ii * delLat);
            for (int jj=Math.max(0,j - 1); jj <= j + 1; ++jj) {
              jj=Math.min(nLon,jj);
              neighbourDEM[r][c]=tileDEM[ii][jj];
              if (neighbourDEM[r][c] == 0) {
                if (saveZeroHeightSimulation) {
                  neighbourDEM[r][c]=1;
                }
 else {
                  geoPos.setLocation(neighbourLat,(float)(lonMin + jj * delLon));
                  neighbourDEM[r][c]=dem.getElevation(geoPos);
                }
                tileDEM[ii][jj]=neighbourDEM[r][c];
              }
              ++c;
            }
            ++r;
          }
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,0,0,0,0,neighbourDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle) {
            continue;
          }
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            index[rIndex]=targetTile.getDataBufferIndex(rIndex,aIndex);
            if (index[rIndex] < 0) {
              savePixel[rIndex]=false;
            }
 else {
              slrs[rIndex]=posData.slantRange;
              elev[rIndex]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[rIndex]=true;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
 else {
      final double[][] localDEM=new double[ymax - ymin + 2][w + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,x0,ymin,w,ymax - ymin);
      if (saveZeroHeightSimulation) {
        for (        double[] aLocalDEM : localDEM) {
          Arrays.fill(aLocalDEM,1);
        }
      }
 else {
        final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,x0,ymin,w,ymax - ymin,localDEM);
        if (!valid)         return;
      }
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        for (int x=x0; x < xmax; x++) {
          final int xx=x - x0;
          double alt=localDEM[yy][xx];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (orbitMethod) {
            double[] latlon=orbit.lp2ell(new Point(x + 0.5,y + 0.5),meta);
            lat=latlon[0] * MathUtils.RTOD;
            lon=latlon[1] * MathUtils.RTOD;
            alt=dem.getElevation(new GeoPos((float)lat,(float)lon));
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,x0,ymin,x,y,localDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle)           continue;
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            index[xx]=targetTile.getDataBufferIndex(rIndex,aIndex);
            if (index[xx] < 0) {
              savePixel[xx]=false;
            }
 else {
              slrs[xx]=posData.slantRange;
              elev[xx]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[xx]=true;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  final int x0=targetRectangle.x;
  final int y0=targetRectangle.y;
  final int w=targetRectangle.width;
  final int h=targetRectangle.height;
  double tileOverlapPercentage;
  try {
    if (!isElevationModelAvailable) {
      getElevationModel();
    }
    tileOverlapPercentage=computeTileOverlapPercentage(x0,y0,w,h);
  }
 catch (  Exception e) {
    throw new OperatorException(e);
  }
  final Tile targetTile=targetTiles.get(targetProduct.getBand(SIMULATED_BAND_NAME));
  final ProductData masterBuffer=targetTile.getDataBuffer();
  ProductData demBandBuffer=null;
  ProductData zeroHeightBandBuffer=null;
  ProductData localIncidenceAngleBandBuffer=null;
  ProductData layoverShadowMaskBuffer=null;
  if (saveDEM) {
    demBandBuffer=targetTiles.get(targetProduct.getBand(demBandName)).getDataBuffer();
  }
  if (saveZeroHeightSimulation) {
    zeroHeightBandBuffer=targetTiles.get(targetProduct.getBand(zeroHeightSimulationBandName)).getDataBuffer();
  }
  if (saveLocalIncidenceAngle) {
    localIncidenceAngleBandBuffer=targetTiles.get(targetProduct.getBand(simulatedLocalIncidenceAngleBandName)).getDataBuffer();
  }
  if (saveLayoverShadowMask) {
    layoverShadowMaskBuffer=targetTiles.get(targetProduct.getBand(layoverShadowMaskBandName)).getDataBuffer();
  }
  int ymin, ymax;
  if (tileOverlapPercentage >= 0.0f) {
    ymin=Math.max(y0 - (int)(tileSize * tileOverlapPercentage),0);
    ymax=y0 + h;
  }
 else {
    ymin=y0;
    ymax=y0 + h + (int)(tileSize * Math.abs(tileOverlapPercentage));
  }
  final int xmax=x0 + w;
  final PositionData posData=new PositionData();
  final GeoPos geoPos=new GeoPos();
  double[] slrs=null;
  double[] elev=null;
  int[] index=null;
  final boolean[] savePixel=new boolean[w];
  if (saveLayoverShadowMask) {
    slrs=new double[w];
    elev=new double[w];
    index=new int[w];
  }
  try {
    if (reGridMethod) {
      final double[] latLonMinMax=new double[4];
      computeImageGeoBoundary(x0,xmax,ymin,ymax,latLonMinMax);
      final double latMin=latLonMinMax[0];
      final double latMax=latLonMinMax[1];
      final double lonMin=latLonMinMax[2];
      final double lonMax=latLonMinMax[3];
      final int nLat=(int)((latMax - latMin) / delLat) + 1;
      final int nLon=(int)((lonMax - lonMin) / delLon) + 1;
      final double[][] tileDEM=new double[nLat + 1][nLon + 1];
      final double[][] neighbourDEM=new double[3][3];
      double alt;
      for (int i=0; i < nLat; i++) {
        final double lat=latMin + i * delLat;
        for (int j=0; j < nLon; j++) {
          double lon=lonMin + j * delLon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (saveZeroHeightSimulation) {
            alt=1;
          }
 else {
            geoPos.setLocation((float)lat,(float)lon);
            alt=dem.getElevation(geoPos);
            if (alt == demNoDataValue)             continue;
          }
          tileDEM[i][j]=alt;
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(lat,lon,delLat,delLon,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          int r=0;
          for (int ii=Math.max(0,i - 1); ii <= i + 1; ++ii) {
            ii=Math.min(nLat,ii);
            int c=0;
            float neighbourLat=(float)(latMin + ii * delLat);
            for (int jj=Math.max(0,j - 1); jj <= j + 1; ++jj) {
              jj=Math.min(nLon,jj);
              neighbourDEM[r][c]=tileDEM[ii][jj];
              if (neighbourDEM[r][c] == 0) {
                if (saveZeroHeightSimulation) {
                  neighbourDEM[r][c]=1;
                }
 else {
                  geoPos.setLocation(neighbourLat,(float)(lonMin + jj * delLon));
                  neighbourDEM[r][c]=dem.getElevation(geoPos);
                }
                tileDEM[ii][jj]=neighbourDEM[r][c];
              }
              ++c;
            }
            ++r;
          }
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,0,0,0,0,neighbourDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle) {
            continue;
          }
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            index[rIndex]=targetTile.getDataBufferIndex(rIndex,aIndex);
            if (index[rIndex] < 0) {
              savePixel[rIndex]=false;
            }
 else {
              slrs[rIndex]=posData.slantRange;
              elev[rIndex]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[rIndex]=true;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
 else {
      final double[][] localDEM=new double[ymax - ymin + 2][w + 2];
      final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,x0,ymin,w,ymax - ymin);
      if (saveZeroHeightSimulation) {
        for (        double[] aLocalDEM : localDEM) {
          Arrays.fill(aLocalDEM,1);
        }
      }
 else {
        final boolean valid=DEMFactory.getLocalDEM(dem,demNoDataValue,demResamplingMethod,tileGeoRef,x0,ymin,w,ymax - ymin,localDEM);
        if (!valid)         return;
      }
      for (int y=ymin; y < ymax; y++) {
        final int yy=y - ymin;
        for (int x=x0; x < xmax; x++) {
          final int xx=x - x0;
          double alt=localDEM[yy + 1][xx + 1];
          if (alt == demNoDataValue)           continue;
          tileGeoRef.getGeoPos(x,y,geoPos);
          if (!geoPos.isValid())           continue;
          double lat=geoPos.lat;
          double lon=geoPos.lon;
          if (lon >= 180.0) {
            lon-=360.0;
          }
          if (orbitMethod) {
            double[] latlon=orbit.lp2ell(new Point(x + 0.5,y + 0.5),meta);
            lat=latlon[0] * MathUtils.RTOD;
            lon=latlon[1] * MathUtils.RTOD;
            alt=dem.getElevation(new GeoPos((float)lat,(float)lon));
          }
          if (!getPosition(lat,lon,alt,x0,y0,w,h,posData))           continue;
          final LocalGeometry localGeometry=new LocalGeometry(x,y,tileGeoRef,posData.earthPoint,posData.sensorPos);
          final double[] localIncidenceAngles={SARGeocoding.NonValidIncidenceAngle,SARGeocoding.NonValidIncidenceAngle};
          SARGeocoding.computeLocalIncidenceAngle(localGeometry,demNoDataValue,false,true,false,x0,ymin,x,y,localDEM,localIncidenceAngles);
          if (localIncidenceAngles[1] == SARGeocoding.NonValidIncidenceAngle)           continue;
          final double v=computeBackscatteredPower(localIncidenceAngles[1]);
          saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,v,x0,y0,w,h,targetTile,masterBuffer);
          int idx=0;
          if (saveDEM || saveLocalIncidenceAngle)           idx=targetTile.getDataBufferIndex((int)posData.rangeIndex,(int)posData.azimuthIndex);
          if (saveDEM && idx >= 0) {
            demBandBuffer.setElemDoubleAt(idx,alt);
          }
          if (saveZeroHeightSimulation) {
            saveSimulatedData(posData.azimuthIndex,posData.rangeIndex,1,x0,y0,w,h,targetTile,zeroHeightBandBuffer);
          }
          if (saveLocalIncidenceAngle && idx >= 0) {
            localIncidenceAngleBandBuffer.setElemDoubleAt(idx,localIncidenceAngles[1]);
          }
          if (saveLayoverShadowMask) {
            int rIndex=(int)posData.rangeIndex;
            int aIndex=(int)posData.azimuthIndex;
            index[xx]=targetTile.getDataBufferIndex(rIndex,aIndex);
            if (index[xx] < 0) {
              savePixel[xx]=false;
            }
 else {
              slrs[xx]=posData.slantRange;
              elev[xx]=computeElevationAngle(posData.slantRange,posData.earthPoint,posData.sensorPos);
              savePixel[xx]=true;
            }
          }
        }
        if (saveLayoverShadowMask) {
          computeLayoverShadow(savePixel,slrs,index,elev,layoverShadowMaskBuffer);
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11565,"private double computeMaxShift(final int txMax){
  return absShift + Math.round(txMax * fracShift);
}","private double computeMaxShift(final int txMax,final int ty0) throws Exception {
  if (useMapreadyShiftOnly) {
    return Math.round(txMax * fracShift);
  }
 else {
    return computeShift(txMax,ty0) + Math.round(txMax * fracShift);
  }
}"
11566,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final int tx0=targetRectangle.x;
    final int ty0=targetRectangle.y;
    final int tw=targetRectangle.width;
    final int th=targetRectangle.height;
    final int tyMax=ty0 + th;
    final int txMax=tx0 + tw;
    final int maxShift=(int)computeMaxShift(txMax);
    final Rectangle sourceRectangle=getSourceRectangle(tx0,ty0,tw,th,maxShift);
    final int sx0=sourceRectangle.x;
    final int sy0=sourceRectangle.y;
    final int sw=sourceRectangle.width;
    final int sh=sourceRectangle.height;
    final int syMax=sy0 + sh;
    final int sxMax=sx0 + sw;
    final Set<Band> keySet=targetTiles.keySet();
    double totalShift;
    for (    Band targetBand : keySet) {
      final Tile targetTile=targetTiles.get(targetBand);
      final Tile sourceTile=getSourceTile(sourceProduct.getBand(targetBand.getName()),sourceRectangle);
      final ProductData trgDataBuffer=targetTile.getDataBuffer();
      final ProductData srcDataBuffer=sourceTile.getDataBuffer();
      final TileIndex srcIndex=new TileIndex(sourceTile);
      for (int y=sy0; y < syMax; y++) {
        srcIndex.calculateStride(y);
        for (int x=sx0; x < sxMax; x++) {
          if (useMapreadyShiftOnly) {
            totalShift=Math.round(fracShift * x);
          }
 else           if (useFAQShiftOnly) {
            totalShift=computeShift(x,y);
          }
 else           if (useBoth) {
            double faqShift=computeShift(x,y);
            double fraction=Math.round(fracShift * x);
            totalShift=faqShift + fraction;
          }
 else {
            throw new OperatorException(""String_Node_Str"");
          }
          final int newy=y + (int)totalShift;
          if (newy >= ty0 && newy < tyMax) {
            final int trgIdx=targetTile.getDataBufferIndex(x,newy);
            trgDataBuffer.setElemFloatAt(trgIdx,srcDataBuffer.getElemFloatAt(srcIndex.getIndex(x)));
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final int tx0=targetRectangle.x;
    final int ty0=targetRectangle.y;
    final int tw=targetRectangle.width;
    final int th=targetRectangle.height;
    final int tyMax=ty0 + th;
    final int txMax=tx0 + tw;
    final int maxShift=(int)computeMaxShift(txMax,ty0);
    final Rectangle sourceRectangle=getSourceRectangle(tx0,ty0,tw,th,maxShift);
    final int sx0=sourceRectangle.x;
    final int sy0=sourceRectangle.y;
    final int sw=sourceRectangle.width;
    final int sh=sourceRectangle.height;
    final int syMax=sy0 + sh;
    final int sxMax=sx0 + sw;
    final Set<Band> keySet=targetTiles.keySet();
    double totalShift;
    for (    Band targetBand : keySet) {
      final Tile targetTile=targetTiles.get(targetBand);
      final Tile sourceTile=getSourceTile(sourceProduct.getBand(targetBand.getName()),sourceRectangle);
      final ProductData trgDataBuffer=targetTile.getDataBuffer();
      final ProductData srcDataBuffer=sourceTile.getDataBuffer();
      final TileIndex srcIndex=new TileIndex(sourceTile);
      for (int y=sy0; y < syMax; y++) {
        srcIndex.calculateStride(y);
        for (int x=sx0; x < sxMax; x++) {
          if (useMapreadyShiftOnly) {
            totalShift=Math.round(fracShift * x);
          }
 else           if (useFAQShiftOnly) {
            totalShift=computeShift(x,y);
          }
 else           if (useBoth) {
            double faqShift=computeShift(x,y);
            double fraction=Math.round(fracShift * x);
            totalShift=faqShift + fraction;
          }
 else {
            throw new OperatorException(""String_Node_Str"");
          }
          final int newy=y + (int)totalShift;
          if (newy >= ty0 && newy < tyMax) {
            final int trgIdx=targetTile.getDataBufferIndex(x,newy);
            trgDataBuffer.setElemFloatAt(trgIdx,srcDataBuffer.getElemFloatAt(srcIndex.getIndex(x)));
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
}"
11567,"public void getPixelPos(final GeoPos geo,final PixelPos pix){
  if (geo.lon < 0) {
    geo.lon+=360;
  }
  geocoding.getPixelPos(geo,pix);
}","public void getPixelPos(final GeoPos geo,final PixelPos pix){
  if (geocoding.isCrossingMeridianAt180() && geo.lon < 0) {
    geo.lon+=360;
  }
  geocoding.getPixelPos(geo,pix);
}"
11568,"/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final List<Product> validProducts=new ArrayList<Product>(sourceProduct.length);
    for (    final Product srcProduct : selectedProducts) {
      final Rectangle srcRect=srcRectMap.get(srcProduct);
      if (srcRect == null || !srcRect.intersects(targetRectangle)) {
        continue;
      }
      validProducts.add(srcProduct);
    }
    if (validProducts.isEmpty()) {
      return;
    }
    final GeoPos geoPos=new GeoPos();
    final PixelPos pixelPos=new PixelPos();
    final int minX=targetRectangle.x;
    final int minY=targetRectangle.y;
    final int maxX=targetRectangle.x + targetRectangle.width - 1;
    final int maxY=targetRectangle.y + targetRectangle.height - 1;
    final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,minX,minY,maxX - minX,maxY - minY);
    final List<PixelPos[]> srcPixelCoords=new ArrayList<PixelPos[]>(validProducts.size());
    final int numPixelPos=targetRectangle.width * targetRectangle.height;
    for (    Product validProduct : validProducts) {
      srcPixelCoords.add(new PixelPos[numPixelPos]);
    }
    int coordIndex=0;
    int prodIndex;
    for (int y=minY; y <= maxY; ++y) {
      for (int x=minX; x <= maxX; ++x) {
        tileGeoRef.getGeoPos(x,y,geoPos);
        prodIndex=0;
        for (        final Product srcProduct : validProducts) {
          srcProduct.getGeoCoding().getPixelPos(geoPos,pixelPos);
          if (pixelPos.x >= feather && pixelPos.y >= feather && pixelPos.x < srcProduct.getSceneRasterWidth() - feather && pixelPos.y < srcProduct.getSceneRasterHeight() - feather) {
            srcPixelCoords.get(prodIndex)[coordIndex]=new PixelPos(pixelPos.x,pixelPos.y);
          }
 else {
            srcPixelCoords.get(prodIndex)[coordIndex]=null;
          }
          ++prodIndex;
        }
        ++coordIndex;
      }
    }
    final Resampling resampling=ResamplingFactory.createResampling(resamplingMethod);
    if (gradientDomainMosaic) {
      performGradientDomainMosaic(targetTiles,targetRectangle,srcPixelCoords,validProducts,resampling,pm);
      return;
    }
    final List<SourceData> validSourceData=new ArrayList<SourceData>(validProducts.size());
    for (    final Map.Entry<Band,Tile> bandTileEntry : targetTiles.entrySet()) {
      final String trgBandName=bandTileEntry.getKey().getName();
      validSourceData.clear();
      prodIndex=0;
      for (      final Product srcProduct : validProducts) {
        final Band srcBand=srcProduct.getBand(trgBandName);
        if (srcBand == null) {
          continue;
        }
        final PixelPos[] pixPos=srcPixelCoords.get(prodIndex);
        final Rectangle sourceRectangle=getBoundingBox(pixPos,feather,feather,srcProduct.getSceneRasterWidth() - feather,srcProduct.getSceneRasterHeight() - feather,4);
        if (sourceRectangle != null) {
          double min=0, max=0, mean=0, std=0;
          if (normalizeByMean) {
            try {
              final Stx stats=srcBand.getStx(true,ProgressMonitor.NULL);
              mean=stats.getMean();
              min=stats.getMin();
              max=stats.getMax();
              std=stats.getStandardDeviation();
            }
 catch (            Throwable e) {
              normalizeByMean=false;
            }
          }
          final Tile srcTile=getSourceTile(srcBand,sourceRectangle);
          if (srcTile != null) {
            validSourceData.add(new SourceData(srcTile,pixPos,resampling,min,max,mean,std));
          }
        }
        ++prodIndex;
      }
      if (!validSourceData.isEmpty()) {
        collocateSourceBand(validSourceData,resampling,bandTileEntry.getValue());
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}","/** 
 * Called by the framework in order to compute the stack of tiles for the given target bands. <p>The default implementation throws a runtime exception with the message ""not implemented"".</p>
 * @param targetTiles     The current tiles to be computed for each target band.
 * @param targetRectangle The area in pixel coordinates to be computed (same for all rasters in <code>targetRasters</code>).
 * @param pm              A progress monitor which should be used to determine computation cancelation requests.
 * @throws org.esa.beam.framework.gpf.OperatorException if an error occurs during computation of the target rasters.
 */
@Override public void computeTileStack(Map<Band,Tile> targetTiles,Rectangle targetRectangle,ProgressMonitor pm) throws OperatorException {
  try {
    final List<Product> validProducts=new ArrayList<Product>(sourceProduct.length);
    for (    final Product srcProduct : selectedProducts) {
      final Rectangle srcRect=srcRectMap.get(srcProduct);
      if (srcRect == null || !srcRect.intersects(targetRectangle)) {
        continue;
      }
      validProducts.add(srcProduct);
    }
    if (validProducts.isEmpty()) {
      return;
    }
    final GeoPos geoPos=new GeoPos();
    final PixelPos pixelPos=new PixelPos();
    final int minX=targetRectangle.x;
    final int minY=targetRectangle.y;
    final int maxX=targetRectangle.x + targetRectangle.width - 1;
    final int maxY=targetRectangle.y + targetRectangle.height - 1;
    final TileGeoreferencing tileGeoRef=new TileGeoreferencing(targetProduct,minX,minY,maxX - minX + 1,maxY - minY + 1);
    final List<PixelPos[]> srcPixelCoords=new ArrayList<PixelPos[]>(validProducts.size());
    final int numPixelPos=targetRectangle.width * targetRectangle.height;
    for (    Product validProduct : validProducts) {
      srcPixelCoords.add(new PixelPos[numPixelPos]);
    }
    int coordIndex=0;
    int prodIndex;
    for (int y=minY; y <= maxY; ++y) {
      for (int x=minX; x <= maxX; ++x) {
        tileGeoRef.getGeoPos(x,y,geoPos);
        prodIndex=0;
        for (        final Product srcProduct : validProducts) {
          srcProduct.getGeoCoding().getPixelPos(geoPos,pixelPos);
          if (pixelPos.x >= feather && pixelPos.y >= feather && pixelPos.x < srcProduct.getSceneRasterWidth() - feather && pixelPos.y < srcProduct.getSceneRasterHeight() - feather) {
            srcPixelCoords.get(prodIndex)[coordIndex]=new PixelPos(pixelPos.x,pixelPos.y);
          }
 else {
            srcPixelCoords.get(prodIndex)[coordIndex]=null;
          }
          ++prodIndex;
        }
        ++coordIndex;
      }
    }
    final Resampling resampling=ResamplingFactory.createResampling(resamplingMethod);
    if (gradientDomainMosaic) {
      performGradientDomainMosaic(targetTiles,targetRectangle,srcPixelCoords,validProducts,resampling,pm);
      return;
    }
    final List<SourceData> validSourceData=new ArrayList<SourceData>(validProducts.size());
    for (    final Map.Entry<Band,Tile> bandTileEntry : targetTiles.entrySet()) {
      final String trgBandName=bandTileEntry.getKey().getName();
      validSourceData.clear();
      prodIndex=0;
      for (      final Product srcProduct : validProducts) {
        final Band srcBand=srcProduct.getBand(trgBandName);
        if (srcBand == null) {
          continue;
        }
        final PixelPos[] pixPos=srcPixelCoords.get(prodIndex);
        final Rectangle sourceRectangle=getBoundingBox(pixPos,feather,feather,srcProduct.getSceneRasterWidth() - feather,srcProduct.getSceneRasterHeight() - feather,4);
        if (sourceRectangle != null) {
          double min=0, max=0, mean=0, std=0;
          if (normalizeByMean) {
            try {
              final Stx stats=srcBand.getStx(true,ProgressMonitor.NULL);
              mean=stats.getMean();
              min=stats.getMin();
              max=stats.getMax();
              std=stats.getStandardDeviation();
            }
 catch (            Throwable e) {
              normalizeByMean=false;
            }
          }
          final Tile srcTile=getSourceTile(srcBand,sourceRectangle);
          if (srcTile != null) {
            validSourceData.add(new SourceData(srcTile,pixPos,resampling,min,max,mean,std));
          }
        }
        ++prodIndex;
      }
      if (!validSourceData.isEmpty()) {
        collocateSourceBand(validSourceData,resampling,bandTileEntry.getValue());
      }
    }
  }
 catch (  Throwable e) {
    OperatorUtils.catchOperatorException(getId(),e);
  }
 finally {
    pm.done();
  }
}"
11569,"@Override public GeoPos getGeoPos(PixelPos pixelPos){
  float pixelLat=(float)((RASTER_HEIGHT - pixelPos.y) / DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 90.0);
  float pixelLon=(float)(pixelPos.x / DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 180.0);
  return new GeoPos(pixelLat,pixelLon);
}","@Override public GeoPos getGeoPos(PixelPos pixelPos){
  float pixelLat=(float)((RASTER_HEIGHT - pixelPos.y) * DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 90.0);
  float pixelLon=(float)(pixelPos.x * DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 180.0);
  return new GeoPos(pixelLat,pixelLon);
}"
11570,"public final synchronized float getElevation(final GeoPos geoPos) throws Exception {
  final double pixelY=getIndexY(geoPos);
  if (pixelY < 0) {
    return NO_DATA_VALUE;
  }
  resampling.computeIndex(getIndexX(geoPos),pixelY,RASTER_WIDTH,RASTER_HEIGHT,resamplingIndex);
  final float elevation=resampling.resample(resamplingRaster,resamplingIndex);
  return Float.isNaN(elevation) ? NO_DATA_VALUE : elevation;
}","public final synchronized float getElevation(final GeoPos geoPos) throws Exception {
  if (geoPos.lon > 180) {
    geoPos.lon-=360;
  }
  final double pixelY=getIndexY(geoPos);
  if (pixelY < 0) {
    return NO_DATA_VALUE;
  }
  resampling.computeIndex(getIndexX(geoPos),pixelY,RASTER_WIDTH,RASTER_HEIGHT,resamplingIndex);
  final float elevation=resampling.resample(resamplingRaster,resamplingIndex);
  return Float.isNaN(elevation) ? NO_DATA_VALUE : elevation;
}"
11571,"/** 
 * Get an array of rectangles for all source tiles of the image
 * @param sourceProduct the input
 * @param tileSize the rect
 * @param margin feathered area
 * @return Array of rectangles
 */
public static Rectangle[] getAllTileRectangles(final Product sourceProduct,final Dimension tileSize,final int margin){
  final int rasterHeight=sourceProduct.getSceneRasterHeight() - margin - margin;
  final int rasterWidth=sourceProduct.getSceneRasterWidth() - margin - margin;
  final Rectangle boundary=new Rectangle(rasterWidth,rasterHeight);
  final int tileCountX=MathUtils.ceilInt(boundary.width / (double)tileSize.width);
  final int tileCountY=MathUtils.ceilInt(boundary.height / (double)tileSize.height);
  final Rectangle[] rectangles=new Rectangle[tileCountX * tileCountY];
  int index=0;
  for (int tileY=0; tileY < tileCountY; tileY++) {
    for (int tileX=0; tileX < tileCountX; tileX++) {
      final Rectangle tileRectangle=new Rectangle(tileX * tileSize.width + margin,tileY * tileSize.height + margin,tileSize.width,tileSize.height);
      final Rectangle intersection=boundary.intersection(tileRectangle);
      rectangles[index]=intersection;
      index++;
    }
  }
  return rectangles;
}","/** 
 * Get an array of rectangles for all source tiles of the image
 * @param sourceProduct the input
 * @param tileSize the rect
 * @param margin feathered area
 * @return Array of rectangles
 */
public static Rectangle[] getAllTileRectangles(final Product sourceProduct,final Dimension tileSize,final int margin){
  final int rasterHeight=sourceProduct.getSceneRasterHeight() - margin - margin;
  final int rasterWidth=sourceProduct.getSceneRasterWidth() - margin - margin;
  final Rectangle boundary=new Rectangle(margin,margin,rasterWidth,rasterHeight);
  final int tileCountX=MathUtils.ceilInt(boundary.width / (double)tileSize.width);
  final int tileCountY=MathUtils.ceilInt(boundary.height / (double)tileSize.height);
  final Rectangle[] rectangles=new Rectangle[tileCountX * tileCountY];
  int index=0;
  for (int tileY=0; tileY < tileCountY; tileY++) {
    for (int tileX=0; tileX < tileCountX; tileX++) {
      final Rectangle tileRectangle=new Rectangle(tileX * tileSize.width + margin,tileY * tileSize.height + margin,tileSize.width,tileSize.height);
      final Rectangle intersection=boundary.intersection(tileRectangle);
      rectangles[index]=intersection;
      index++;
    }
  }
  return rectangles;
}"
11572,"@Override public GeoPos getGeoPos(final PixelPos pixelPos){
  final float pixelLat=(float)((RASTER_HEIGHT - pixelPos.y) / DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 90.0);
  final float pixelLon=(float)(pixelPos.x / DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 180.0);
  return new GeoPos(pixelLat,pixelLon);
}","@Override public GeoPos getGeoPos(final PixelPos pixelPos){
  final float pixelLat=(float)(90.0 - pixelPos.y * DEGREE_RES_BY_NUM_PIXELS_PER_TILE);
  final float pixelLon=(float)(pixelPos.x * DEGREE_RES_BY_NUM_PIXELS_PER_TILE - 180.0);
  return new GeoPos(pixelLat,pixelLon);
}"
11573,"@Override public double getIndexY(final GeoPos geoPos){
  return RASTER_HEIGHT - (geoPos.lat + 90.0) / DEGREE_RES_BY_NUM_PIXELS_PER_TILE;
}","@Override public double getIndexY(final GeoPos geoPos){
  return RASTER_HEIGHT - (geoPos.lat + 90.0) * DEGREE_RES_BY_NUM_PIXELS_PER_TILEinv;
}"
11574,"@Override public double getIndexX(final GeoPos geoPos){
  return (geoPos.lon + 180.0) / DEGREE_RES_BY_NUM_PIXELS_PER_TILE;
}","@Override public double getIndexX(final GeoPos geoPos){
  return (geoPos.lon + 180.0) * DEGREE_RES_BY_NUM_PIXELS_PER_TILEinv;
}"
11575,"/** 
 * Update the metadata in the target product.
 */
private void updateTargetProductMetadata(){
  final MetadataElement abs=AbstractMetadata.getAbstractedMetadata(targetProduct);
  abs.getAttribute(AbstractMetadata.abs_calibration_flag).getData().setElemBoolean(true);
  final MetadataElement origProdRoot=AbstractMetadata.getOriginalProductMetadata(sourceProduct);
  origProdRoot.removeElement(origProdRoot.getElement(lutsigma));
  origProdRoot.removeElement(origProdRoot.getElement(lutgamma));
  origProdRoot.removeElement(origProdRoot.getElement(lutbeta));
}","/** 
 * Update the metadata in the target product.
 */
private void updateTargetProductMetadata(){
  final MetadataElement abs=AbstractMetadata.getAbstractedMetadata(targetProduct);
  abs.getAttribute(AbstractMetadata.abs_calibration_flag).getData().setElemBoolean(true);
  final MetadataElement origProdRoot=AbstractMetadata.getOriginalProductMetadata(targetProduct);
  origProdRoot.removeElement(origProdRoot.getElement(lutsigma));
  origProdRoot.removeElement(origProdRoot.getElement(lutgamma));
  origProdRoot.removeElement(origProdRoot.getElement(lutbeta));
}"
11576,"/** 
 * Get antenna pattern gain array from metadata.
 */
private void getLUT(){
  final MetadataElement origProdRoot=AbstractMetadata.getOriginalProductMetadata(sourceProduct);
  final MetadataElement lutSigmaElem=origProdRoot.getElement(lutsigma);
  if (lutSigmaElem != null) {
    offset=lutSigmaElem.getAttributeDouble(""String_Node_Str"",0);
    final MetadataAttribute gainsAttrib=lutSigmaElem.getAttribute(""String_Node_Str"");
    if (gainsAttrib != null) {
      gains=(double[])gainsAttrib.getData().getElems();
    }
  }
 else {
    throw new OperatorException(lutsigma + ""String_Node_Str"" + lutsigma+ ""String_Node_Str"");
  }
  if (gains.length < targetProduct.getSceneRasterWidth()) {
    throw new OperatorException(""String_Node_Str"");
  }
}","/** 
 * Get antenna pattern gain array from metadata.
 */
private void getLUT(){
  final MetadataElement origProdRoot=AbstractMetadata.getOriginalProductMetadata(sourceProduct);
  final MetadataElement lutSigmaElem=origProdRoot.getElement(lutsigma);
  if (lutSigmaElem != null) {
    offset=lutSigmaElem.getAttributeDouble(""String_Node_Str"",0);
    final MetadataAttribute gainsAttrib=lutSigmaElem.getAttribute(""String_Node_Str"");
    if (gainsAttrib != null) {
      gains=(double[])gainsAttrib.getData().getElems();
    }
  }
 else {
    throw new OperatorException(lutsigma + ""String_Node_Str"" + lutsigma+ ""String_Node_Str"");
  }
  if (gains.length < sourceProduct.getSceneRasterWidth()) {
    throw new OperatorException(""String_Node_Str"");
  }
}"
11577,"/** 
 * Compute source image geodetic boundary (minimum/maximum latitude/longitude) from the its corner latitude/longitude.
 * @param sourceProduct The input source product.
 * @throws OperatorException for no geocoding
 * @return geoBoundary The object to pass back the max/min lat/lon.
 */
public static ImageGeoBoundary computeImageGeoBoundary(final Product sourceProduct) throws OperatorException {
  final ImageGeoBoundary geoBoundary=new ImageGeoBoundary();
  final GeoCoding geoCoding=sourceProduct.getGeoCoding();
  if (geoCoding == null) {
    throw new OperatorException(""String_Node_Str"");
  }
  final GeoPos geoPosFirstNear=geoCoding.getGeoPos(new PixelPos(0,0),null);
  final GeoPos geoPosFirstFar=geoCoding.getGeoPos(new PixelPos(sourceProduct.getSceneRasterWidth() - 1,0),null);
  final GeoPos geoPosLastNear=geoCoding.getGeoPos(new PixelPos(0,sourceProduct.getSceneRasterHeight() - 1),null);
  final GeoPos geoPosLastFar=geoCoding.getGeoPos(new PixelPos(sourceProduct.getSceneRasterWidth() - 1,sourceProduct.getSceneRasterHeight() - 1),null);
  final double[] lats={geoPosFirstNear.getLat(),geoPosFirstFar.getLat(),geoPosLastNear.getLat(),geoPosLastFar.getLat()};
  final double[] lons={geoPosFirstNear.getLon(),geoPosFirstFar.getLon(),geoPosLastNear.getLon(),geoPosLastFar.getLon()};
  geoBoundary.latMin=90.0;
  geoBoundary.latMax=-90.0;
  for (  double lat : lats) {
    if (lat < geoBoundary.latMin) {
      geoBoundary.latMin=lat;
    }
    if (lat > geoBoundary.latMax) {
      geoBoundary.latMax=lat;
    }
  }
  geoBoundary.lonMin=360.0;
  geoBoundary.lonMax=0.0;
  for (  double lon : lons) {
    if (lon < 0) {
      lon+=360;
    }
    if (lon < geoBoundary.lonMin) {
      geoBoundary.lonMin=lon;
    }
    if (lon > geoBoundary.lonMax) {
      geoBoundary.lonMax=lon;
    }
  }
  return geoBoundary;
}","/** 
 * Compute source image geodetic boundary (minimum/maximum latitude/longitude) from the its corner latitude/longitude.
 * @param sourceProduct The input source product.
 * @throws OperatorException for no geocoding
 * @return geoBoundary The object to pass back the max/min lat/lon.
 */
public static ImageGeoBoundary computeImageGeoBoundary(final Product sourceProduct) throws OperatorException {
  final ImageGeoBoundary geoBoundary=new ImageGeoBoundary();
  final GeoCoding geoCoding=sourceProduct.getGeoCoding();
  if (geoCoding == null) {
    throw new OperatorException(""String_Node_Str"");
  }
  final GeoPos geoPosFirstNear=geoCoding.getGeoPos(new PixelPos(0,0),null);
  final GeoPos geoPosFirstFar=geoCoding.getGeoPos(new PixelPos(sourceProduct.getSceneRasterWidth() - 1,0),null);
  final GeoPos geoPosLastNear=geoCoding.getGeoPos(new PixelPos(0,sourceProduct.getSceneRasterHeight() - 1),null);
  final GeoPos geoPosLastFar=geoCoding.getGeoPos(new PixelPos(sourceProduct.getSceneRasterWidth() - 1,sourceProduct.getSceneRasterHeight() - 1),null);
  final double[] lats={geoPosFirstNear.getLat(),geoPosFirstFar.getLat(),geoPosLastNear.getLat(),geoPosLastFar.getLat()};
  final double[] lons={geoPosFirstNear.getLon(),geoPosFirstFar.getLon(),geoPosLastNear.getLon(),geoPosLastFar.getLon()};
  geoBoundary.latMin=90.0;
  geoBoundary.latMax=-90.0;
  for (  double lat : lats) {
    if (lat < geoBoundary.latMin) {
      geoBoundary.latMin=lat;
    }
    if (lat > geoBoundary.latMax) {
      geoBoundary.latMax=lat;
    }
  }
  geoBoundary.lonMin=180.0;
  geoBoundary.lonMax=-180.0;
  for (  double lon : lons) {
    if (lon < geoBoundary.lonMin) {
      geoBoundary.lonMin=lon;
    }
    if (lon > geoBoundary.lonMax) {
      geoBoundary.lonMax=lon;
    }
  }
  if (geoBoundary.lonMax - geoBoundary.lonMin >= 180) {
    geoBoundary.lonMin=360.0;
    geoBoundary.lonMax=0.0;
    for (    double lon : lons) {
      if (lon < 0) {
        lon+=360;
      }
      if (lon < geoBoundary.lonMin) {
        geoBoundary.lonMin=lon;
      }
      if (lon > geoBoundary.lonMax) {
        geoBoundary.lonMax=lon;
      }
    }
  }
  return geoBoundary;
}"
11578,"/** 
 * Reads a data product and returns a in-memory representation of it. This method was called by <code>readProductNodes(input, subsetInfo)</code> of the abstract superclass.
 * @throws IllegalArgumentException if <code>input</code> type is not one of the supported input sources.
 * @throws IOException              if an I/O error occurs
 */
@Override protected Product readProductNodesImpl() throws IOException {
  if (getInput() instanceof Product) {
    sourceProduct=(Product)getInput();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + getInput());
  }
  Debug.assertNotNull(sourceProduct);
  sceneRasterWidth=sourceProduct.getSceneRasterWidth();
  sceneRasterHeight=sourceProduct.getSceneRasterHeight();
  if (getSubsetDef() != null) {
    Dimension s=getSubsetDef().getSceneRasterSize(sceneRasterWidth,sceneRasterHeight);
    sceneRasterWidth=s.width;
    sceneRasterHeight=s.height;
  }
  final Product targetProduct=createProduct();
  updateMetadata(targetProduct,getSubsetDef());
  return targetProduct;
}","/** 
 * Reads a data product and returns a in-memory representation of it. This method was called by <code>readProductNodes(input, subsetInfo)</code> of the abstract superclass.
 * @throws IllegalArgumentException if <code>input</code> type is not one of the supported input sources.
 * @throws IOException              if an I/O error occurs
 */
@Override protected Product readProductNodesImpl() throws IOException {
  if (getInput() instanceof Product) {
    sourceProduct=(Product)getInput();
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + getInput());
  }
  Debug.assertNotNull(sourceProduct);
  sceneRasterWidth=sourceProduct.getSceneRasterWidth();
  sceneRasterHeight=sourceProduct.getSceneRasterHeight();
  if (getSubsetDef() != null) {
    Dimension s=getSubsetDef().getSceneRasterSize(sceneRasterWidth,sceneRasterHeight);
    sceneRasterWidth=s.width;
    sceneRasterHeight=s.height;
  }
  final Product targetProduct=createProduct();
  updateMetadata(sourceProduct,targetProduct,getSubsetDef());
  return targetProduct;
}"
11579,"private static void updateMetadata(final Product product,ProductSubsetDef subsetDef) throws IOException {
  try {
    final MetadataElement root=product.getMetadataRoot();
    if (root == null)     return;
    final MetadataElement absRoot=root.getElement(""String_Node_Str"");
    if (absRoot == null)     return;
    final String mission=absRoot.getAttributeString(""String_Node_Str"");
    boolean nearRangeOnLeft=true;
    if (mission.equals(""String_Node_Str"")) {
      final String pass=absRoot.getAttributeString(""String_Node_Str"");
      if (pass.contains(""String_Node_Str"")) {
        nearRangeOnLeft=false;
      }
    }
    final MetadataAttribute firstLineTime=absRoot.getAttribute(""String_Node_Str"");
    if (firstLineTime != null) {
      final ProductData.UTC startTime=product.getStartTime();
      if (startTime != null)       firstLineTime.getData().setElems(startTime.getArray());
    }
    final MetadataAttribute lastLineTime=absRoot.getAttribute(""String_Node_Str"");
    if (lastLineTime != null) {
      final ProductData.UTC endTime=product.getEndTime();
      if (endTime != null)       lastLineTime.getData().setElems(endTime.getArray());
    }
    final MetadataAttribute totalSize=absRoot.getAttribute(""String_Node_Str"");
    if (totalSize != null)     totalSize.getData().setElemUInt(product.getRawStorageSize());
    if (nearRangeOnLeft) {
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,0.5f);
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",product.getSceneRasterWidth() - 1 + 0.5f,0.5f);
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,product.getSceneRasterHeight() - 1 + 0.5f);
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",product.getSceneRasterWidth() - 1 + 0.5f,product.getSceneRasterHeight() - 1 + 0.5f);
    }
 else {
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",product.getSceneRasterWidth() - 1 + 0.5f,0.5f);
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,0.5f);
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",product.getSceneRasterWidth() - 1 + 0.5f,product.getSceneRasterHeight() - 1 + 0.5f);
      setLatLongMetadata(product,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,product.getSceneRasterHeight() - 1 + 0.5f);
    }
    final MetadataAttribute height=absRoot.getAttribute(""String_Node_Str"");
    if (height != null)     height.getData().setElemUInt(product.getSceneRasterHeight());
    final MetadataAttribute width=absRoot.getAttribute(""String_Node_Str"");
    if (width != null)     width.getData().setElemUInt(product.getSceneRasterWidth());
    final MetadataAttribute offsetX=absRoot.getAttribute(""String_Node_Str"");
    if (offsetX != null && subsetDef.getRegion() != null)     offsetX.getData().setElemUInt(subsetDef.getRegion().x);
    final MetadataAttribute offsetY=absRoot.getAttribute(""String_Node_Str"");
    if (offsetY != null && subsetDef.getRegion() != null)     offsetY.getData().setElemUInt(subsetDef.getRegion().y);
    final MetadataAttribute slantRange=absRoot.getAttribute(""String_Node_Str"");
    if (slantRange != null) {
      final TiePointGrid srTPG=product.getTiePointGrid(""String_Node_Str"");
      if (srTPG != null) {
        final double slantRangeTime;
        if (nearRangeOnLeft) {
          slantRangeTime=srTPG.getPixelDouble(0,0) / 1000000000.0;
        }
 else {
          slantRangeTime=srTPG.getPixelDouble(product.getSceneRasterWidth() - 1,0) / 1000000000.0;
        }
        final double halfLightSpeed=299792458.0 / 2.0;
        final double slantRangeDist=slantRangeTime * halfLightSpeed;
        slantRange.getData().setElemDouble(slantRangeDist);
      }
    }
    setSubsetSRGRCoefficients(product,subsetDef,absRoot);
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}","private static void updateMetadata(final Product sourceProduct,final Product targetProduct,ProductSubsetDef subsetDef) throws IOException {
  try {
    final MetadataElement root=targetProduct.getMetadataRoot();
    if (root == null)     return;
    final MetadataElement absRoot=root.getElement(""String_Node_Str"");
    if (absRoot == null)     return;
    boolean nearRangeOnLeft=isNearRangeOnLeft(targetProduct);
    final MetadataAttribute firstLineTime=absRoot.getAttribute(""String_Node_Str"");
    if (firstLineTime != null) {
      final ProductData.UTC startTime=targetProduct.getStartTime();
      if (startTime != null)       firstLineTime.getData().setElems(startTime.getArray());
    }
    final MetadataAttribute lastLineTime=absRoot.getAttribute(""String_Node_Str"");
    if (lastLineTime != null) {
      final ProductData.UTC endTime=targetProduct.getEndTime();
      if (endTime != null)       lastLineTime.getData().setElems(endTime.getArray());
    }
    final MetadataAttribute totalSize=absRoot.getAttribute(""String_Node_Str"");
    if (totalSize != null)     totalSize.getData().setElemUInt(targetProduct.getRawStorageSize());
    if (nearRangeOnLeft) {
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,0.5f);
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",targetProduct.getSceneRasterWidth() - 1 + 0.5f,0.5f);
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,targetProduct.getSceneRasterHeight() - 1 + 0.5f);
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",targetProduct.getSceneRasterWidth() - 1 + 0.5f,targetProduct.getSceneRasterHeight() - 1 + 0.5f);
    }
 else {
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",targetProduct.getSceneRasterWidth() - 1 + 0.5f,0.5f);
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,0.5f);
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",targetProduct.getSceneRasterWidth() - 1 + 0.5f,targetProduct.getSceneRasterHeight() - 1 + 0.5f);
      setLatLongMetadata(targetProduct,absRoot,""String_Node_Str"",""String_Node_Str"",0.5f,targetProduct.getSceneRasterHeight() - 1 + 0.5f);
    }
    final MetadataAttribute height=absRoot.getAttribute(""String_Node_Str"");
    if (height != null)     height.getData().setElemUInt(targetProduct.getSceneRasterHeight());
    final MetadataAttribute width=absRoot.getAttribute(""String_Node_Str"");
    if (width != null)     width.getData().setElemUInt(targetProduct.getSceneRasterWidth());
    final MetadataAttribute offsetX=absRoot.getAttribute(""String_Node_Str"");
    if (offsetX != null && subsetDef.getRegion() != null)     offsetX.getData().setElemUInt(subsetDef.getRegion().x);
    final MetadataAttribute offsetY=absRoot.getAttribute(""String_Node_Str"");
    if (offsetY != null && subsetDef.getRegion() != null)     offsetY.getData().setElemUInt(subsetDef.getRegion().y);
    final MetadataAttribute slantRange=absRoot.getAttribute(""String_Node_Str"");
    if (slantRange != null) {
      final TiePointGrid srTPG=targetProduct.getTiePointGrid(""String_Node_Str"");
      if (srTPG != null) {
        final double slantRangeTime;
        if (nearRangeOnLeft) {
          slantRangeTime=srTPG.getPixelDouble(0,0) / 1000000000.0;
        }
 else {
          slantRangeTime=srTPG.getPixelDouble(targetProduct.getSceneRasterWidth() - 1,0) / 1000000000.0;
        }
        final double halfLightSpeed=299792458.0 / 2.0;
        final double slantRangeDist=slantRangeTime * halfLightSpeed;
        slantRange.getData().setElemDouble(slantRangeDist);
      }
    }
    setSubsetSRGRCoefficients(sourceProduct,targetProduct,subsetDef,absRoot,nearRangeOnLeft);
  }
 catch (  Exception e) {
    throw new IOException(e);
  }
}"
11580,"private static void setSubsetSRGRCoefficients(final Product product,final ProductSubsetDef subsetDef,final MetadataElement absRoot){
  final MetadataElement SRGRCoefficientsElem=absRoot.getElement(""String_Node_Str"");
  if (SRGRCoefficientsElem != null) {
    final ProductData.UTC startTimeUTC=product.getStartTime();
    final ProductData.UTC endTimeUTC=product.getEndTime();
    final double startTime=startTimeUTC == null ? 0 : startTimeUTC.getMJD();
    final double endTime=endTimeUTC == null ? 0 : endTimeUTC.getMJD();
    final double rangeSpacing=absRoot.getAttributeDouble(""String_Node_Str"",0);
    final double colIndex=subsetDef.getRegion() == null ? 0 : subsetDef.getRegion().getX();
    MetadataElement itemBeforeStart=null;
    if (startTimeUTC != null && endTimeUTC != null) {
      for (      MetadataElement srgrList : SRGRCoefficientsElem.getElements()) {
        final ProductData.UTC time=srgrList.getAttributeUTC(""String_Node_Str"");
        if (time.getMJD() < startTime) {
          if (itemBeforeStart == null) {
            itemBeforeStart=srgrList;
          }
 else {
            final ProductData.UTC maxTimeSoFar=itemBeforeStart.getAttributeUTC(""String_Node_Str"");
            if (maxTimeSoFar.getMJD() < time.getMJD()) {
              itemBeforeStart=srgrList;
            }
          }
        }
      }
    }
    for (    MetadataElement srgrList : SRGRCoefficientsElem.getElements()) {
      final ProductData.UTC time=srgrList.getAttributeUTC(""String_Node_Str"");
      if (startTimeUTC != null && endTimeUTC != null && (time.getMJD() < startTime || time.getMJD() > endTime) && srgrList != itemBeforeStart) {
        SRGRCoefficientsElem.removeElement(srgrList);
      }
 else {
        final double grO=srgrList.getAttributeDouble(""String_Node_Str"",0);
        final double ground_range_origin_subset=grO + colIndex * rangeSpacing;
        srgrList.setAttributeDouble(""String_Node_Str"",ground_range_origin_subset);
      }
    }
  }
}","private static void setSubsetSRGRCoefficients(final Product sourceProduct,final Product targetProduct,final ProductSubsetDef subsetDef,final MetadataElement absRoot,final boolean nearRangeOnLeft){
  final MetadataElement SRGRCoefficientsElem=absRoot.getElement(""String_Node_Str"");
  if (SRGRCoefficientsElem != null) {
    final ProductData.UTC startTimeUTC=targetProduct.getStartTime();
    final ProductData.UTC endTimeUTC=targetProduct.getEndTime();
    final double startTime=startTimeUTC == null ? 0 : startTimeUTC.getMJD();
    final double endTime=endTimeUTC == null ? 0 : endTimeUTC.getMJD();
    final double rangeSpacing=absRoot.getAttributeDouble(""String_Node_Str"",0);
    final double colIndex=subsetDef.getRegion() == null ? 0 : subsetDef.getRegion().getX();
    MetadataElement itemBeforeStart=null;
    if (startTimeUTC != null && endTimeUTC != null) {
      for (      MetadataElement srgrList : SRGRCoefficientsElem.getElements()) {
        final ProductData.UTC time=srgrList.getAttributeUTC(""String_Node_Str"");
        if (time.getMJD() < startTime) {
          if (itemBeforeStart == null) {
            itemBeforeStart=srgrList;
          }
 else {
            final ProductData.UTC maxTimeSoFar=itemBeforeStart.getAttributeUTC(""String_Node_Str"");
            if (maxTimeSoFar.getMJD() < time.getMJD()) {
              itemBeforeStart=srgrList;
            }
          }
        }
      }
    }
    for (    MetadataElement srgrList : SRGRCoefficientsElem.getElements()) {
      final ProductData.UTC time=srgrList.getAttributeUTC(""String_Node_Str"");
      if (startTimeUTC != null && endTimeUTC != null && (time.getMJD() < startTime || time.getMJD() > endTime) && srgrList != itemBeforeStart) {
        SRGRCoefficientsElem.removeElement(srgrList);
      }
 else {
        final double grO=srgrList.getAttributeDouble(""String_Node_Str"",0);
        double ground_range_origin_subset;
        if (nearRangeOnLeft) {
          ground_range_origin_subset=grO + colIndex * rangeSpacing;
        }
 else {
          final double colIndexFromRight=sourceProduct.getSceneRasterWidth() - colIndex - targetProduct.getSceneRasterWidth();
          ground_range_origin_subset=grO + colIndexFromRight * rangeSpacing;
        }
        srgrList.setAttributeDouble(""String_Node_Str"",ground_range_origin_subset);
      }
    }
  }
}"
11581,"@Nonnull @SuppressFBWarnings(""String_Node_Str"") private CSSPageRule _createPageRule(@Nonnull final CSSNode aNode){
  _expectNodeType(aNode,ECSSNodeType.PAGERULE);
  final int nChildCount=aNode.jjtGetNumChildren();
  if (m_eVersion == ECSSVersion.CSS30) {
    if (nChildCount < 1)     _throwUnexpectedChildrenCount(aNode,""String_Node_Str"" + nChildCount + ""String_Node_Str"");
    final ICommonsList<String> aSelectors=new CommonsArrayList<>();
    for (int nIndex=0; nIndex < nChildCount - 1; ++nIndex) {
      final CSSNode aChildNode=aNode.jjtGetChild(nIndex);
      _expectNodeType(aChildNode,ECSSNodeType.PAGESELECTOR);
      aSelectors.add(aChildNode.getText());
    }
    final CSSPageRule ret=new CSSPageRule(aSelectors);
    ret.setSourceLocation(aNode.getSourceLocation());
    final CSSNode aBodyNode=aNode.jjtGetChild(nChildCount - 1);
    _expectNodeType(aBodyNode,ECSSNodeType.PAGERULEBLOCK);
    final int nBodyChildren=aBodyNode.jjtGetNumChildren();
    for (int nIndex=0; nIndex < nBodyChildren; ++nIndex) {
      final CSSNode aBodyChildNode=aBodyNode.jjtGetChild(nIndex);
      if (ECSSNodeType.STYLEDECLARATION.isNode(aBodyChildNode,m_eVersion)) {
        final CSSDeclaration aDeclaration=_createDeclaration(aBodyChildNode);
        if (aDeclaration != null)         ret.addMember(aDeclaration);
      }
 else       if (ECSSNodeType.PAGEMARGINSYMBOL.isNode(aBodyChildNode,m_eVersion)) {
        final CSSPageMarginBlock aBlock=new CSSPageMarginBlock(aBodyChildNode.getText());
        final CSSNode aBodyNextChildNode=aBodyNode.jjtGetChild(nIndex + 1);
        _readStyleDeclarationList(aBodyNextChildNode,aDeclaration -> aBlock.addDeclaration(aDeclaration));
        ret.addMember(aBlock);
        ++nIndex;
      }
 else       if (!ECSSNodeType.isErrorNode(aBodyChildNode,m_eVersion))       m_aErrorHandler.onCSSInterpretationError(""String_Node_Str"" + ECSSNodeType.getNodeName(aBodyChildNode,m_eVersion));
    }
    return ret;
  }
 else {
    String sPseudoPage=null;
    int nStartIndex=0;
    if (nChildCount > 0) {
      final CSSNode aFirstChild=aNode.jjtGetChild(0);
      if (ECSSNodeType.PSEUDOPAGE.isNode(aFirstChild,m_eVersion)) {
        sPseudoPage=aFirstChild.getText();
        nStartIndex++;
      }
    }
    final CSSPageRule ret=new CSSPageRule(sPseudoPage);
    ret.setSourceLocation(aNode.getSourceLocation());
    for (int nIndex=nStartIndex; nIndex < nChildCount; ++nIndex) {
      final CSSNode aChildNode=aNode.jjtGetChild(nIndex);
      if (ECSSNodeType.STYLEDECLARATIONLIST.isNode(aChildNode,m_eVersion)) {
        _readStyleDeclarationList(aChildNode,aDeclaration -> ret.addMember(aDeclaration));
      }
 else       if (!ECSSNodeType.isErrorNode(aChildNode,m_eVersion))       m_aErrorHandler.onCSSInterpretationError(""String_Node_Str"" + ECSSNodeType.getNodeName(aChildNode,m_eVersion));
    }
    return ret;
  }
}","@Nonnull @SuppressFBWarnings(""String_Node_Str"") private CSSPageRule _createPageRule(@Nonnull final CSSNode aNode){
  _expectNodeType(aNode,ECSSNodeType.PAGERULE);
  final int nChildCount=aNode.jjtGetNumChildren();
  if (m_eVersion == ECSSVersion.CSS30) {
    if (nChildCount < 1)     _throwUnexpectedChildrenCount(aNode,""String_Node_Str"" + nChildCount + ""String_Node_Str"");
    final ICommonsList<String> aSelectors=new CommonsArrayList<>();
    for (int nIndex=0; nIndex < nChildCount - 1; ++nIndex) {
      final CSSNode aChildNode=aNode.jjtGetChild(nIndex);
      _expectNodeType(aChildNode,ECSSNodeType.PAGESELECTOR);
      aSelectors.add(aChildNode.getText());
    }
    final CSSPageRule ret=new CSSPageRule(aSelectors);
    ret.setSourceLocation(aNode.getSourceLocation());
    final CSSNode aBodyNode=aNode.jjtGetChild(nChildCount - 1);
    _expectNodeType(aBodyNode,ECSSNodeType.PAGERULEBLOCK);
    final int nBodyChildren=aBodyNode.jjtGetNumChildren();
    for (int nIndex=0; nIndex < nBodyChildren; ++nIndex) {
      final CSSNode aBodyChildNode=aBodyNode.jjtGetChild(nIndex);
      if (ECSSNodeType.STYLEDECLARATION.isNode(aBodyChildNode,m_eVersion)) {
        final CSSDeclaration aDeclaration=_createDeclaration(aBodyChildNode);
        if (aDeclaration != null)         ret.addMember(aDeclaration);
      }
 else       if (ECSSNodeType.PAGEMARGINSYMBOL.isNode(aBodyChildNode,m_eVersion)) {
        final CSSPageMarginBlock aBlock=new CSSPageMarginBlock(aBodyChildNode.getText());
        final CSSNode aBodyNextChildNode=aBodyNode.jjtGetChild(nIndex + 1);
        _readStyleDeclarationList(aBodyNextChildNode,aDeclaration -> aBlock.addDeclaration(aDeclaration));
        ret.addMember(aBlock);
        ++nIndex;
      }
 else       if (!ECSSNodeType.isErrorNode(aBodyChildNode,m_eVersion))       m_aErrorHandler.onCSSInterpretationError(""String_Node_Str"" + ECSSNodeType.getNodeName(aBodyChildNode,m_eVersion));
    }
    return ret;
  }
  String sPseudoPage=null;
  int nStartIndex=0;
  if (nChildCount > 0) {
    final CSSNode aFirstChild=aNode.jjtGetChild(0);
    if (ECSSNodeType.PSEUDOPAGE.isNode(aFirstChild,m_eVersion)) {
      sPseudoPage=aFirstChild.getText();
      nStartIndex++;
    }
  }
  final CSSPageRule ret=new CSSPageRule(sPseudoPage);
  ret.setSourceLocation(aNode.getSourceLocation());
  for (int nIndex=nStartIndex; nIndex < nChildCount; ++nIndex) {
    final CSSNode aChildNode=aNode.jjtGetChild(nIndex);
    if (ECSSNodeType.STYLEDECLARATIONLIST.isNode(aChildNode,m_eVersion)) {
      _readStyleDeclarationList(aChildNode,aDeclaration -> ret.addMember(aDeclaration));
    }
 else     if (!ECSSNodeType.isErrorNode(aChildNode,m_eVersion))     m_aErrorHandler.onCSSInterpretationError(""String_Node_Str"" + ECSSNodeType.getNodeName(aChildNode,m_eVersion));
  }
  return ret;
}"
11582,"@Parameters(name=""String_Node_Str"") public static Iterable<Object[]> data(){
  return new CommonsArrayList<>(new Object[]{true},new Object[]{false});
}","@Parameters(name=""String_Node_Str"") public static Iterable<Object[]> data(){
  return new CommonsArrayList<>(new Object[]{Boolean.TRUE},new Object[]{Boolean.FALSE});
}"
11583,"@Parameters(name=""String_Node_Str"") public static Iterable<Object[]> data(){
  return new CommonsArrayList<>(new Object[]{true},new Object[]{false});
}","@Parameters(name=""String_Node_Str"") public static Iterable<Object[]> data(){
  return new CommonsArrayList<>(new Object[]{Boolean.TRUE},new Object[]{Boolean.FALSE});
}"
11584,"@Nonnull private CSSExpressionMemberMathProduct _createExpressionMathProduct(@Nonnull final CSSNode aNode){
  _expectNodeType(aNode,ECSSNodeType.MATHPRODUCT);
  final CSSExpressionMemberMathProduct ret=new CSSExpressionMemberMathProduct();
  ret.setSourceLocation(aNode.getSourceLocation());
  for (  final CSSNode aChildNode : aNode) {
    if (ECSSNodeType.MATHUNIT.isNode(aChildNode,m_eVersion)) {
      final int nChildCount=aChildNode.jjtGetNumChildren();
      if (nChildCount == 0) {
        final CSSExpressionMemberMathUnitSimple aMember=new CSSExpressionMemberMathUnitSimple(aChildNode.getText());
        aMember.setSourceLocation(aChildNode.getSourceLocation());
        ret.addMember(aMember);
      }
 else       if (nChildCount == 1 && ECSSNodeType.FUNCTION.isNode(aChildNode.jjtGetChild(0),m_eVersion)) {
        ret.addMember(_createExpressionFunction(aChildNode.jjtGetChild(0)));
      }
 else {
        if ((nChildCount % 2) != 1)         _throwUnexpectedChildrenCount(aChildNode,""String_Node_Str"" + nChildCount);
        final CSSExpressionMemberMathProduct aNestedProduct=new CSSExpressionMemberMathProduct();
        for (int i=0; i < nChildCount; ++i) {
          final CSSNode aChildChildNode=aChildNode.jjtGetChild(i);
          if (ECSSNodeType.MATHPRODUCT.isNode(aChildChildNode,m_eVersion)) {
            aNestedProduct.addMember(_createExpressionMathProduct(aChildChildNode));
          }
 else           if (ECSSNodeType.MATHSUMOPERATOR.isNode(aChildChildNode,m_eVersion)) {
            final String sText=aChildChildNode.getText();
            final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
            if (eMathOp == null)             s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else             aNestedProduct.addMember(eMathOp);
          }
 else           s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aChildNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildChildNode,m_eVersion));
        }
        ret.addMember(new CSSExpressionMemberMathUnitProduct(aNestedProduct));
      }
    }
 else     if (ECSSNodeType.MATHPRODUCTOPERATOR.isNode(aChildNode,m_eVersion)) {
      final String sText=aChildNode.getText();
      final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
      if (eMathOp == null)       s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else       ret.addMember(eMathOp);
    }
 else     s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildNode,m_eVersion));
  }
  return ret;
}","@Nonnull private CSSExpressionMemberMathProduct _createExpressionMathProduct(@Nonnull final CSSNode aNode){
  _expectNodeType(aNode,ECSSNodeType.MATHPRODUCT);
  final CSSExpressionMemberMathProduct ret=new CSSExpressionMemberMathProduct();
  ret.setSourceLocation(aNode.getSourceLocation());
  for (  final CSSNode aChildNode : aNode) {
    if (ECSSNodeType.MATHUNIT.isNode(aChildNode,m_eVersion)) {
      final int nChildCount=aChildNode.jjtGetNumChildren();
      if (nChildCount == 0) {
        final CSSExpressionMemberMathUnitSimple aMember=new CSSExpressionMemberMathUnitSimple(aChildNode.getText());
        aMember.setSourceLocation(aChildNode.getSourceLocation());
        ret.addMember(aMember);
      }
 else       if (nChildCount == 1 && ECSSNodeType.FUNCTION.isNode(aChildNode.jjtGetChild(0),m_eVersion)) {
        ret.addMember(_createExpressionFunction(aChildNode.jjtGetChild(0)));
      }
 else {
        if ((nChildCount % 2) == 0)         _throwUnexpectedChildrenCount(aChildNode,""String_Node_Str"" + nChildCount);
        final CSSExpressionMemberMathProduct aNestedProduct=new CSSExpressionMemberMathProduct();
        for (int i=0; i < nChildCount; ++i) {
          final CSSNode aChildChildNode=aChildNode.jjtGetChild(i);
          if (ECSSNodeType.MATHPRODUCT.isNode(aChildChildNode,m_eVersion)) {
            aNestedProduct.addMember(_createExpressionMathProduct(aChildChildNode));
          }
 else           if (ECSSNodeType.MATHSUMOPERATOR.isNode(aChildChildNode,m_eVersion)) {
            final String sText=aChildChildNode.getText();
            final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
            if (eMathOp == null)             s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else             aNestedProduct.addMember(eMathOp);
          }
 else           s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aChildNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildChildNode,m_eVersion));
        }
        ret.addMember(new CSSExpressionMemberMathUnitProduct(aNestedProduct));
      }
    }
 else     if (ECSSNodeType.MATHPRODUCTOPERATOR.isNode(aChildNode,m_eVersion)) {
      final String sText=aChildNode.getText();
      final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
      if (eMathOp == null)       s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else       ret.addMember(eMathOp);
    }
 else     s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildNode,m_eVersion));
  }
  return ret;
}"
11585,"/** 
 * In CSS, identifiers (including element names, classes, and IDs in selectors) can contain only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-) and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by a digit. Identifiers can also contain escaped characters and any ISO 10646 character as a numeric code (see next item). For instance, the identifier ""B&amp;W?"" may be written as ""B\&amp;W\?"" or ""B\26 W\3F"".
 * @param aPattern pattern to check
 * @return The input string
 */
@Nonnull public static String validateIdentifier(@Nonnull final StringBuilder aPattern){
  final int nLength=aPattern.length();
  final char c1=aPattern.charAt(0);
  final char c2=nLength <= 1 ? 0 : aPattern.charAt(1);
  if (c1 == '-' || c1 == '$' || c1 == '*') {
    if (nLength > 1 && Character.isDigit(c2))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
 else {
    if (Character.isDigit(c1))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
  if (nLength > 1 && c1 == '-' && c2 == '-')   throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  return aPattern.toString();
}","/** 
 * In CSS, identifiers (including element names, classes, and IDs in selectors) can contain only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-) and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by a digit. Identifiers can also contain escaped characters and any ISO 10646 character as a numeric code (see next item). For instance, the identifier ""B&amp;W?"" may be written as ""B\&amp;W\?"" or ""B\26 W\3F"".<br> CSS Variables on the other hand allow for double dashes: https://www.w3.org/TR/css-variables-1/#defining-variables
 * @param aPattern pattern to check
 * @return The input string
 */
@Nonnull public static String validateIdentifier(@Nonnull final StringBuilder aPattern){
  final int nLength=aPattern.length();
  final char c1=aPattern.charAt(0);
  final char c2=nLength <= 1 ? 0 : aPattern.charAt(1);
  if (c1 == '-' || c1 == '$' || c1 == '*') {
    if (nLength > 1 && Character.isDigit(c2))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
 else {
    if (Character.isDigit(c1))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
  if (false)   if (nLength > 1 && c1 == '-' && c2 == '-')   throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  return aPattern.toString();
}"
11586,"@Nonnull private CSSExpressionMemberMathProduct _createExpressionMathProduct(@Nonnull final CSSNode aNode){
  _expectNodeType(aNode,ECSSNodeType.MATHPRODUCT);
  final CSSExpressionMemberMathProduct ret=new CSSExpressionMemberMathProduct();
  ret.setSourceLocation(aNode.getSourceLocation());
  for (  final CSSNode aChildNode : aNode) {
    if (ECSSNodeType.MATHUNIT.isNode(aChildNode,m_eVersion)) {
      final int nChildCount=aChildNode.jjtGetNumChildren();
      if (nChildCount == 0) {
        final CSSExpressionMemberMathUnitSimple aMember=new CSSExpressionMemberMathUnitSimple(aChildNode.getText());
        aMember.setSourceLocation(aChildNode.getSourceLocation());
        ret.addMember(aMember);
      }
 else {
        if (nChildCount != 1)         _throwUnexpectedChildrenCount(aChildNode,""String_Node_Str"" + nChildCount);
        final CSSNode aChildChildNode=aChildNode.jjtGetChild(0);
        final CSSExpressionMemberMathProduct aNestedProduct=_createExpressionMathProduct(aChildChildNode);
        final CSSExpressionMemberMathUnitProduct aMember=new CSSExpressionMemberMathUnitProduct(aNestedProduct);
        ret.addMember(aMember);
      }
    }
 else     if (ECSSNodeType.MATHPRODUCTOPERATOR.isNode(aChildNode,m_eVersion)) {
      final String sText=aChildNode.getText();
      final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
      if (eMathOp == null)       s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else       ret.addMember(eMathOp);
    }
 else     s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildNode,m_eVersion));
  }
  return ret;
}","@Nonnull private CSSExpressionMemberMathProduct _createExpressionMathProduct(@Nonnull final CSSNode aNode){
  _expectNodeType(aNode,ECSSNodeType.MATHPRODUCT);
  final CSSExpressionMemberMathProduct ret=new CSSExpressionMemberMathProduct();
  ret.setSourceLocation(aNode.getSourceLocation());
  for (  final CSSNode aChildNode : aNode) {
    if (ECSSNodeType.MATHUNIT.isNode(aChildNode,m_eVersion)) {
      final int nChildCount=aChildNode.jjtGetNumChildren();
      if (nChildCount == 0) {
        final CSSExpressionMemberMathUnitSimple aMember=new CSSExpressionMemberMathUnitSimple(aChildNode.getText());
        aMember.setSourceLocation(aChildNode.getSourceLocation());
        ret.addMember(aMember);
      }
 else {
        if ((nChildCount % 2) != 1)         _throwUnexpectedChildrenCount(aChildNode,""String_Node_Str"" + nChildCount);
        final CSSExpressionMemberMathProduct aNestedProduct=new CSSExpressionMemberMathProduct();
        for (int i=0; i < nChildCount; ++i) {
          final CSSNode aChildChildNode=aChildNode.jjtGetChild(i);
          if (ECSSNodeType.MATHPRODUCT.isNode(aChildChildNode,m_eVersion)) {
            aNestedProduct.addMember(_createExpressionMathProduct(aChildChildNode));
          }
 else           if (ECSSNodeType.MATHSUMOPERATOR.isNode(aChildChildNode,m_eVersion)) {
            final String sText=aChildChildNode.getText();
            final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
            if (eMathOp == null)             s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else             aNestedProduct.addMember(eMathOp);
          }
 else           s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aChildNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildChildNode,m_eVersion));
        }
        ret.addMember(new CSSExpressionMemberMathUnitProduct(aNestedProduct));
      }
    }
 else     if (ECSSNodeType.MATHPRODUCTOPERATOR.isNode(aChildNode,m_eVersion)) {
      final String sText=aChildNode.getText();
      final ECSSMathOperator eMathOp=ECSSMathOperator.getFromNameOrNull(sText);
      if (eMathOp == null)       s_aLogger.error(""String_Node_Str"" + sText + ""String_Node_Str"");
 else       ret.addMember(eMathOp);
    }
 else     s_aLogger.error(""String_Node_Str"" + ECSSNodeType.getNodeName(aNode,m_eVersion) + ""String_Node_Str""+ ECSSNodeType.getNodeName(aChildNode,m_eVersion));
  }
  return ret;
}"
11587,"protected final void testReadGood(final String sBaseDir){
  final File aBaseDir=new File(sBaseDir);
  if (!aBaseDir.exists())   throw new IllegalArgumentException(""String_Node_Str"" + sBaseDir + ""String_Node_Str"");
  for (  final File aFile : new FileSystemRecursiveIterator(aBaseDir).withFilter(IFileFilter.filenameEndsWith(""String_Node_Str""))) {
    final String sKey=aFile.getAbsolutePath();
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + sKey);
    final CollectingCSSParseErrorHandler aErrorHdl=new CollectingCSSParseErrorHandler(new LoggingCSSParseErrorHandler());
    m_aReaderSettings.setCustomErrorHandler(aErrorHdl);
    final CascadingStyleSheet aCSS=CSSReader.readFromFile(aFile,m_aReaderSettings);
    assertNotNull(sKey,aCSS);
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + aErrorHdl.getAllParseErrors().toString());
    CommonsTestHelper.testDefaultSerialization(aCSS);
    String sCSS=new CSSWriter(m_aWriterSettings.setOptimizedOutput(true)).getCSSAsString(aCSS);
    assertNotNull(sKey,sCSS);
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + sCSS);
    final CascadingStyleSheet aCSSReRead=CSSReader.readFromStringReader(sCSS,m_aReaderSettings);
    assertNotNull(""String_Node_Str"" + sKey + ""String_Node_Str""+ sCSS,aCSSReRead);
    assertEquals(sKey,aCSS,aCSSReRead);
    sCSS=new CSSWriter(m_aWriterSettings.setOptimizedOutput(false)).getCSSAsString(aCSS);
    assertNotNull(sKey,sCSS);
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + sCSS);
    assertEquals(sKey,aCSS,CSSReader.readFromStringReader(sCSS,m_aReaderSettings));
    sCSS=new CSSWriter(m_aWriterSettings.setOptimizedOutput(false).setRemoveUnnecessaryCode(true)).getCSSAsString(aCSS);
    assertNotNull(sKey,sCSS);
    assertNotNull(sKey,CSSReader.readFromStringReader(sCSS,m_aReaderSettings));
    m_aWriterSettings.setRemoveUnnecessaryCode(false);
  }
}","protected final void testReadGood(final String sBaseDir){
  final File aBaseDir=new File(sBaseDir);
  if (!aBaseDir.exists())   throw new IllegalArgumentException(""String_Node_Str"" + sBaseDir + ""String_Node_Str"");
  for (  final File aFile : new FileSystemRecursiveIterator(aBaseDir).withFilter(IFileFilter.filenameEndsWith(""String_Node_Str""))) {
    final String sKey=aFile.getAbsolutePath();
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + sKey);
    final CollectingCSSParseErrorHandler aErrorHdl=new CollectingCSSParseErrorHandler(new LoggingCSSParseErrorHandler());
    m_aReaderSettings.setCustomErrorHandler(aErrorHdl);
    final CascadingStyleSheet aCSS=CSSReader.readFromFile(aFile,m_aReaderSettings);
    assertNotNull(sKey,aCSS);
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + aErrorHdl.getAllParseErrors().toString());
    CommonsTestHelper.testDefaultSerialization(aCSS);
    String sCSS=new CSSWriter(m_aWriterSettings.setOptimizedOutput(true)).getCSSAsString(aCSS);
    assertNotNull(sKey,sCSS);
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + sCSS);
    final CascadingStyleSheet aCSSReRead=CSSReader.readFromStringReader(sCSS,m_aReaderSettings);
    assertNotNull(""String_Node_Str"" + sKey + ""String_Node_Str""+ sCSS,aCSSReRead);
    assertEquals(sKey + ""String_Node_Str"" + sCSS,aCSS,aCSSReRead);
    sCSS=new CSSWriter(m_aWriterSettings.setOptimizedOutput(false)).getCSSAsString(aCSS);
    assertNotNull(sKey,sCSS);
    if (m_bDebug)     m_aLogger.info(""String_Node_Str"" + sCSS);
    assertEquals(sKey,aCSS,CSSReader.readFromStringReader(sCSS,m_aReaderSettings));
    sCSS=new CSSWriter(m_aWriterSettings.setOptimizedOutput(false).setRemoveUnnecessaryCode(true)).getCSSAsString(aCSS);
    assertNotNull(sKey,sCSS);
    assertNotNull(sKey,CSSReader.readFromStringReader(sCSS,m_aReaderSettings));
    m_aWriterSettings.setRemoveUnnecessaryCode(false);
  }
}"
11588,"public CSSShortHandDescriptor(@Nonnull final ECSSProperty eProperty,@Nonnull @Nonempty final CSSPropertyWithDefaultValue... aSubProperties){
  ValueEnforcer.notNull(eProperty,""String_Node_Str"");
  ValueEnforcer.notEmptyNoNullValue(aSubProperties,""String_Node_Str"");
  m_eProperty=eProperty;
  m_aSubProperties=CollectionHelper.newList(aSubProperties);
  int nMinArgs=0;
  int nMaxArgs=0;
  final int nMax=aSubProperties.length;
  for (int i=0; i < nMax; ++i) {
    final CSSPropertyWithDefaultValue aSubProperty=aSubProperties[i];
    final ICSSProperty aProp=aSubProperty.getProperty();
    if (aProp instanceof CSSPropertyFree && i < nMax - 1)     throw new IllegalArgumentException(""String_Node_Str"" + aSubProperty + ""String_Node_Str"");
    nMinArgs+=aProp.getMinimumArgumentCount();
    nMaxArgs+=aProp.getMaximumArgumentCount();
  }
  m_nMinArgCount=nMinArgs;
  m_nMaxArgCount=nMaxArgs;
}","public CSSShortHandDescriptor(@Nonnull final ECSSProperty eProperty,@Nonnull @Nonempty final CSSPropertyWithDefaultValue... aSubProperties){
  ValueEnforcer.notNull(eProperty,""String_Node_Str"");
  ValueEnforcer.notEmptyNoNullValue(aSubProperties,""String_Node_Str"");
  m_eProperty=eProperty;
  m_aSubProperties=CollectionHelper.newList(aSubProperties);
  final int nMax=aSubProperties.length;
  for (int i=0; i < nMax; ++i) {
    final CSSPropertyWithDefaultValue aSubProperty=aSubProperties[i];
    final ICSSProperty aProp=aSubProperty.getProperty();
    if (aProp instanceof CSSPropertyFree && i < nMax - 1)     throw new IllegalArgumentException(""String_Node_Str"" + aSubProperty + ""String_Node_Str"");
  }
}"
11589,"@Nonnull @ReturnsMutableCopy public List<CSSDeclaration> getSplitIntoPieces(@Nonnull final CSSDeclaration aDeclaration){
  ValueEnforcer.notNull(aDeclaration,""String_Node_Str"");
  if (!aDeclaration.getProperty().equals(m_eProperty.getName()))   throw new IllegalArgumentException(""String_Node_Str"" + aDeclaration.getProperty() + ""String_Node_Str""+ m_eProperty.getName()+ ""String_Node_Str"");
  final int nSubProperties=m_aSubProperties.size();
  final List<CSSDeclaration> ret=new ArrayList<CSSDeclaration>();
  final List<ICSSExpressionMember> aExpressionMembers=aDeclaration.getExpression().getAllMembers();
  modifyExpressionMembers(aExpressionMembers);
  final int nExpressionMembers=aExpressionMembers.size();
  final CSSWriterSettings aCWS=new CSSWriterSettings(ECSSVersion.CSS30,false);
  final boolean[] aHandledSubProperties=new boolean[nSubProperties];
  for (int nExprMemberIndex=0; nExprMemberIndex < nExpressionMembers; ++nExprMemberIndex) {
    final ICSSExpressionMember aMember=aExpressionMembers.get(nExprMemberIndex);
    for (int nSubPropIndex=0; nSubPropIndex < nSubProperties; ++nSubPropIndex)     if (!aHandledSubProperties[nSubPropIndex]) {
      final CSSPropertyWithDefaultValue aSubProp=m_aSubProperties.get(nSubPropIndex);
      final ICSSProperty aProperty=aSubProp.getProperty();
      final int nMinArgs=aProperty.getMinimumArgumentCount();
      if (nExprMemberIndex + nMinArgs - 1 < nExpressionMembers) {
        final StringBuilder aSB=new StringBuilder();
        for (int k=0; k < nMinArgs; ++k) {
          final String sValue=aMember.getAsCSSString(aCWS,0);
          if (aSB.length() > 0)           aSB.append(' ');
          aSB.append(sValue);
        }
        if (aProperty.isValidValue(aSB.toString())) {
          final CSSExpression aExpr=new CSSExpression();
          for (int k=0; k < nMinArgs; ++k)           aExpr.addMember(aExpressionMembers.get(nExprMemberIndex + k));
          ret.add(new CSSDeclaration(aSubProp.getProperty().getPropertyName(),aExpr));
          nExprMemberIndex+=nMinArgs - 1;
          aHandledSubProperties[nSubPropIndex]=true;
          break;
        }
      }
    }
  }
  for (int nSubPropIndex=0; nSubPropIndex < nSubProperties; ++nSubPropIndex)   if (!aHandledSubProperties[nSubPropIndex]) {
    final CSSPropertyWithDefaultValue aSubProp=m_aSubProperties.get(nSubPropIndex);
    final CSSExpression aExpr=new CSSExpression();
    aExpr.addMember(new CSSExpressionMemberTermSimple(aSubProp.getDefaultValue()));
    ret.add(new CSSDeclaration(aSubProp.getProperty().getPropertyName(),aExpr));
  }
  return ret;
}","@Nonnull @ReturnsMutableCopy public List<CSSDeclaration> getSplitIntoPieces(@Nonnull final CSSDeclaration aDeclaration){
  ValueEnforcer.notNull(aDeclaration,""String_Node_Str"");
  if (!aDeclaration.getProperty().equals(m_eProperty.getName()))   throw new IllegalArgumentException(""String_Node_Str"" + aDeclaration.getProperty() + ""String_Node_Str""+ m_eProperty.getName()+ ""String_Node_Str"");
  final int nSubProperties=m_aSubProperties.size();
  final List<CSSDeclaration> ret=new ArrayList<>();
  final List<ICSSExpressionMember> aExpressionMembers=aDeclaration.getExpression().getAllMembers();
  modifyExpressionMembers(aExpressionMembers);
  final int nExpressionMembers=aExpressionMembers.size();
  final CSSWriterSettings aCWS=new CSSWriterSettings(ECSSVersion.CSS30,false);
  final boolean[] aHandledSubProperties=new boolean[nSubProperties];
  for (int nExprMemberIndex=0; nExprMemberIndex < nExpressionMembers; ++nExprMemberIndex) {
    final ICSSExpressionMember aMember=aExpressionMembers.get(nExprMemberIndex);
    for (int nSubPropIndex=0; nSubPropIndex < nSubProperties; ++nSubPropIndex)     if (!aHandledSubProperties[nSubPropIndex]) {
      final CSSPropertyWithDefaultValue aSubProp=m_aSubProperties.get(nSubPropIndex);
      final ICSSProperty aProperty=aSubProp.getProperty();
      final int nMinArgs=aProperty.getMinimumArgumentCount();
      if (nExprMemberIndex + nMinArgs - 1 < nExpressionMembers) {
        final StringBuilder aSB=new StringBuilder();
        for (int k=0; k < nMinArgs; ++k) {
          final String sValue=aMember.getAsCSSString(aCWS,0);
          if (aSB.length() > 0)           aSB.append(' ');
          aSB.append(sValue);
        }
        if (aProperty.isValidValue(aSB.toString())) {
          final CSSExpression aExpr=new CSSExpression();
          for (int k=0; k < nMinArgs; ++k)           aExpr.addMember(aExpressionMembers.get(nExprMemberIndex + k));
          ret.add(new CSSDeclaration(aSubProp.getProperty().getPropertyName(),aExpr));
          nExprMemberIndex+=nMinArgs - 1;
          aHandledSubProperties[nSubPropIndex]=true;
          break;
        }
      }
    }
  }
  for (int nSubPropIndex=0; nSubPropIndex < nSubProperties; ++nSubPropIndex)   if (!aHandledSubProperties[nSubPropIndex]) {
    final CSSPropertyWithDefaultValue aSubProp=m_aSubProperties.get(nSubPropIndex);
    final CSSExpression aExpr=new CSSExpression();
    aExpr.addMember(new CSSExpressionMemberTermSimple(aSubProp.getDefaultValue()));
    ret.add(new CSSDeclaration(aSubProp.getProperty().getPropertyName(),aExpr));
  }
  return ret;
}"
11590,"public void onException(@Nonnull final com.helger.css.parser.ParseException ex){
  s_aLogger.error(""String_Node_Str"" + LoggingCSSParseErrorHandler.createLoggingStringParseError(ex));
}","public void onException(@Nonnull final ParseException ex){
  s_aLogger.error(""String_Node_Str"" + LoggingCSSParseErrorHandler.createLoggingStringParseError(ex));
}"
11591,"/** 
 * Method to adjust line and column numbers for the start of a token.
 * @param newLine line index
 * @param newCol column index
 */
public void adjustBeginLineColumn(int newLine,final int newCol){
  int start=m_nTokenBegin;
  int len;
  if (m_nBufpos >= m_nTokenBegin) {
    len=m_nBufpos - m_nTokenBegin + m_nInBuf + 1;
  }
 else {
    len=m_nBufsize - m_nTokenBegin + m_nBufpos + 1 + m_nInBuf;
  }
  int i=0, j=0, k=0;
  int nextColDiff=0, columnDiff=0;
  while (i < len && m_aBufLine[j=start % m_nBufsize] == m_aBufLine[k=++start % m_nBufsize]) {
    m_aBufLine[j]=newLine;
    nextColDiff=columnDiff + m_aBufColumn[k] - m_aBufColumn[j];
    m_aBufColumn[j]=newCol + columnDiff;
    columnDiff=nextColDiff;
    i++;
  }
  if (i < len) {
    m_aBufLine[j]=newLine++;
    m_aBufColumn[j]=newCol + columnDiff;
    while (i++ < len) {
      if (m_aBufLine[j=start % m_nBufsize] != m_aBufLine[++start % m_nBufsize])       m_aBufLine[j]=newLine++;
 else       m_aBufLine[j]=newLine;
    }
  }
  m_nLine=m_aBufLine[j];
  m_nColumn=m_aBufColumn[j];
}","/** 
 * Method to adjust line and column numbers for the start of a token.
 * @param nNewLine line index
 * @param newCol column index
 */
public void adjustBeginLineColumn(final int nNewLine,final int newCol){
  int start=m_nTokenBegin;
  int newLine=nNewLine;
  int len;
  if (m_nBufpos >= m_nTokenBegin) {
    len=m_nBufpos - m_nTokenBegin + m_nInBuf + 1;
  }
 else {
    len=m_nBufsize - m_nTokenBegin + m_nBufpos + 1 + m_nInBuf;
  }
  int i=0;
  int j=0;
  int k=0;
  int nextColDiff=0;
  int columnDiff=0;
  while (i < len && m_aBufLine[j=start % m_nBufsize] == m_aBufLine[k=++start % m_nBufsize]) {
    m_aBufLine[j]=newLine;
    nextColDiff=columnDiff + m_aBufColumn[k] - m_aBufColumn[j];
    m_aBufColumn[j]=newCol + columnDiff;
    columnDiff=nextColDiff;
    i++;
  }
  if (i < len) {
    m_aBufLine[j]=newLine++;
    m_aBufColumn[j]=newCol + columnDiff;
    while (i++ < len) {
      if (m_aBufLine[j=start % m_nBufsize] != m_aBufLine[++start % m_nBufsize])       m_aBufLine[j]=newLine++;
 else       m_aBufLine[j]=newLine;
    }
  }
  m_nLine=m_aBufLine[j];
  m_nColumn=m_aBufColumn[j];
}"
11592,"public CSSParseError(@Nonnull final Token aLastValidToken,@Nonnull final int[][] aExpectedTokenSequencesVal,@Nonnull final String[] aTokenImageVal,@Nullable final Token aLastSkippedToken){
  ValueEnforcer.notNull(aLastValidToken,""String_Node_Str"");
  ValueEnforcer.notNull(aExpectedTokenSequencesVal,""String_Node_Str"");
  ValueEnforcer.notNull(aTokenImageVal,""String_Node_Str"");
  m_aLastValidToken=new ReadOnlyToken(aLastValidToken);
  final StringBuilder aExpected=new StringBuilder();
  for (  final int[] aExpectedTokens : aExpectedTokenSequencesVal) {
    if (aExpected.length() > 0)     aExpected.append(""String_Node_Str"");
    for (    final int nExpectedToken : aExpectedTokens)     aExpected.append(' ').append(aTokenImageVal[nExpectedToken]);
  }
  m_sExpectedTokens=aExpected.toString();
  m_aFirstSkippedToken=new ReadOnlyToken(aLastValidToken.next);
  m_aLastSkippedToken=aLastSkippedToken == null ? null : new ReadOnlyToken(aLastSkippedToken);
  m_sErrorMessage=LoggingCSSParseErrorHandler.createLoggingStringParseError(aLastValidToken,aExpectedTokenSequencesVal,aTokenImageVal,aLastSkippedToken);
}","public CSSParseError(@Nonnull final Token aLastValidToken,@Nonnull final int[][] aExpectedTokenSequencesVal,@Nonnull final String[] aTokenImageVal,@Nullable final Token aLastSkippedToken){
  ValueEnforcer.notNull(aLastValidToken,""String_Node_Str"");
  ValueEnforcer.notNull(aExpectedTokenSequencesVal,""String_Node_Str"");
  ValueEnforcer.notNull(aTokenImageVal,""String_Node_Str"");
  m_aLastValidToken=new ReadOnlyToken(aLastValidToken);
  final StringBuilder aExpected=new StringBuilder();
  for (  final int[] aExpectedTokens : aExpectedTokenSequencesVal) {
    if (aExpected.length() > 0)     aExpected.append(',');
    for (    final int nExpectedToken : aExpectedTokens)     aExpected.append(' ').append(aTokenImageVal[nExpectedToken]);
  }
  m_sExpectedTokens=aExpected.toString();
  m_aFirstSkippedToken=new ReadOnlyToken(aLastValidToken.next);
  m_aLastSkippedToken=aLastSkippedToken == null ? null : new ReadOnlyToken(aLastSkippedToken);
  m_sErrorMessage=LoggingCSSParseErrorHandler.createLoggingStringParseError(aLastValidToken,aExpectedTokenSequencesVal,aTokenImageVal,aLastSkippedToken);
}"
11593,"@Test public void testSpecialCasesAsString(){
  final boolean bBrowserCompliantMode=isBrowserCompliantMode();
  final CSSReaderSettings aSettings=new CSSReaderSettings().setCSSVersion(ECSSVersion.CSS30).setCustomErrorHandler(new LoggingCSSParseErrorHandler()).setBrowserCompliantMode(bBrowserCompliantMode);
  String sCSS=""String_Node_Str"";
  CascadingStyleSheet aCSS, aCSS2;
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(bBrowserCompliantMode ? ""String_Node_Str"" : ""String_Node_Str"",new CSSWriter(ECSSVersion.CSS30,true).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(ECSSVersion.CSS30,true).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  aCSS2=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS2);
  assertEquals(""String_Node_Str"",new CSSWriter(ECSSVersion.CSS30,true).getCSSAsString(aCSS2));
  assertEquals(aCSS,aCSS2);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
}","@Test public void testSpecialCasesAsString(){
  final boolean bBrowserCompliantMode=isBrowserCompliantMode();
  final CSSReaderSettings aSettings=new CSSReaderSettings().setCSSVersion(ECSSVersion.CSS30).setCustomErrorHandler(new LoggingCSSParseErrorHandler()).setBrowserCompliantMode(bBrowserCompliantMode);
  String sCSS=""String_Node_Str"";
  CascadingStyleSheet aCSS;
  CascadingStyleSheet aCSS2;
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(bBrowserCompliantMode ? ""String_Node_Str"" : ""String_Node_Str"",new CSSWriter(ECSSVersion.CSS30,true).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(ECSSVersion.CSS30,true).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  aCSS2=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS2);
  assertEquals(""String_Node_Str"",new CSSWriter(ECSSVersion.CSS30,true).getCSSAsString(aCSS2));
  assertEquals(aCSS,aCSS2);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNotNull(aCSS);
  assertEquals(""String_Node_Str"",new CSSWriter(new CSSWriterSettings(ECSSVersion.CSS30).setOptimizedOutput(true)).getCSSAsString(aCSS));
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
  sCSS=""String_Node_Str"";
  aCSS=CSSReader.readFromStringReader(sCSS,aSettings);
  assertNull(aCSS);
}"
11594,"/** 
 * In CSS, identifiers (including element names, classes, and IDs in selectors) can contain only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-) and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by a digit. Identifiers can also contain escaped characters and any ISO 10646 character as a numeric code (see next item). For instance, the identifier ""B&W?"" may be written as ""B\&W\?"" or ""B\26 W\3F"".
 * @param aPattern pattern to check
 * @return The input string
 */
@Nonnull public static String validateIdentifier(@Nonnull final StringBuilder aPattern){
  final int nLength=aPattern.length();
  final char c1=aPattern.charAt(0);
  final char c2=nLength <= 1 ? 0 : aPattern.charAt(1);
  if (c1 == '-' || c1 == '$' || c1 == '*') {
    if (nLength > 1 && Character.isDigit(c2))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
 else {
    if (Character.isDigit(c1))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
  if (nLength > 1 && c1 == '-' && c2 == '-')   throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  return aPattern.toString();
}","/** 
 * In CSS, identifiers (including element names, classes, and IDs in selectors) can contain only the characters [a-zA-Z0-9] and ISO 10646 characters U+00A0 and higher, plus the hyphen (-) and the underscore (_); they cannot start with a digit, two hyphens, or a hyphen followed by a digit. Identifiers can also contain escaped characters and any ISO 10646 character as a numeric code (see next item). For instance, the identifier ""B&amp;W?"" may be written as ""B\&amp;W\?"" or ""B\26 W\3F"".
 * @param aPattern pattern to check
 * @return The input string
 */
@Nonnull public static String validateIdentifier(@Nonnull final StringBuilder aPattern){
  final int nLength=aPattern.length();
  final char c1=aPattern.charAt(0);
  final char c2=nLength <= 1 ? 0 : aPattern.charAt(1);
  if (c1 == '-' || c1 == '$' || c1 == '*') {
    if (nLength > 1 && Character.isDigit(c2))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
 else {
    if (Character.isDigit(c1))     throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  }
  if (nLength > 1 && c1 == '-' && c2 == '-')   throw new IllegalArgumentException(""String_Node_Str"" + aPattern);
  return aPattern.toString();
}"
11595,"@Test public void testGetMatchingUnitExclPercentage(){
  for (  final ECSSUnit eUnit : ECSSUnit.values())   if (eUnit != ECSSUnit.PERCENTAGE) {
    String sText=eUnit.format(5);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitExclPercentage(sText));
    sText=eUnit.format(3.14159265);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitExclPercentage(sText));
  }
}","@Test public void testGetMatchingUnitExclPercentage(){
  for (  final ECSSUnit eUnit : ECSSUnit.values())   if (eUnit != ECSSUnit.PERCENTAGE) {
    String sText=eUnit.format(5);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitExclPercentage(sText));
    sText=eUnit.format(2.12345678);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitExclPercentage(sText));
  }
}"
11596,"@Test public void testGetMatchingUnitInclPercentage(){
  for (  final ECSSUnit eUnit : ECSSUnit.values()) {
    String sText=eUnit.format(5);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitInclPercentage(sText));
    sText=eUnit.format(3.14159265);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitInclPercentage(sText));
  }
}","@Test public void testGetMatchingUnitInclPercentage(){
  for (  final ECSSUnit eUnit : ECSSUnit.values()) {
    String sText=eUnit.format(5);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitInclPercentage(sText));
    sText=eUnit.format(2.12345678);
    assertSame(sText,eUnit,CSSNumberHelper.getMatchingUnitInclPercentage(sText));
  }
}"
11597,"/** 
 * Replace the URI string in the existing   {@link CSSURI} object.
 * @param sURIString The new URI string to set. May neither be <code>null</code> nor empty.
 * @return this
 */
@Nonnull public CSSExpressionMemberTermURI setURIString(@Nonnull @Nonempty final String sURIString){
  m_aURI.setURI(sURIString);
  return this;
}","/** 
 * Replace the URI string in the existing   {@link CSSURI} object.
 * @param sURIString The new URI string to set. May not be <code>null</code> but may be empty.
 * @return this
 */
@Nonnull public CSSExpressionMemberTermURI setURIString(@Nonnull final String sURIString){
  m_aURI.setURI(sURIString);
  return this;
}"
11598,"/** 
 * Set the URI of the file to be imported.
 * @param sLocationURI The location URI to use. May not be <code>null</code>.
 * @return this;
 */
@Nonnull public CSSImportRule setLocationString(@Nonnull @Nonempty final String sLocationURI){
  m_aLocation.setURI(sLocationURI);
  return this;
}","/** 
 * Set the URI of the file to be imported.
 * @param sLocationURI The location URI to use. May not be <code>null</code>.
 * @return this;
 */
@Nonnull public CSSImportRule setLocationString(@Nonnull final String sLocationURI){
  m_aLocation.setURI(sLocationURI);
  return this;
}"
11599,"public CSSURI(@Nonnull @Nonempty final String sURI){
  setURI(sURI);
}","public CSSURI(@Nonnull final String sURI){
  setURI(sURI);
}"
11600,"/** 
 * Set the URI string of this object. This may either be a regular URI or a data URL string (starting with ""data:""). The passed string may not start with the prefix ""url("" and end with "")"".
 * @param sURI The URI to be set. May neither be <code>null</code> nor empty.
 * @return this
 */
@Nonnull public CSSURI setURI(@Nonnull @Nonempty final String sURI){
  ValueEnforcer.notEmpty(sURI,""String_Node_Str"");
  if (CSSURLHelper.isURLValue(sURI))   throw new IllegalArgumentException(""String_Node_Str"");
  m_sURI=sURI;
  return this;
}","/** 
 * Set the URI string of this object. This may either be a regular URI or a data URL string (starting with ""data:""). The passed string may not start with the prefix ""url("" and end with "")"".
 * @param sURI The URI to be set. May not be <code>null</code> but may be empty (even though an empty URL usually does not make sense).
 * @return this
 */
@Nonnull public CSSURI setURI(@Nonnull final String sURI){
  ValueEnforcer.notNull(sURI,""String_Node_Str"");
  if (CSSURLHelper.isURLValue(sURI))   throw new IllegalArgumentException(""String_Node_Str"");
  m_sURI=sURI;
  return this;
}"
11601,"/** 
 * @return The URI string (without the leading ""url("" and the closing "")"")
 */
@Nonnull @Nonempty public String getURI(){
  return m_sURI;
}","/** 
 * @return The URI string (without the leading ""url("" and the closing "")"")
 */
@Nonnull public String getURI(){
  return m_sURI;
}"
11602,"/** 
 * Surround the passed URL with the CSS ""url(...)"". When the passed URL contains characters that require quoting, quotes are automatically added!
 * @param sURL URL to be wrapped. May neither be <code>null</code> nor empty.
 * @param bForceQuoteURL if <code>true</code> single quotes are added around the URL
 * @return <code>url(<i>sURL</i>)</code> or <code>url('<i>sURL</i>')</code>
 */
@Nonnull @Nonempty public static String getAsCSSURL(@Nonnull @Nonempty final String sURL,final boolean bForceQuoteURL){
  ValueEnforcer.notEmpty(sURL,""String_Node_Str"");
  final StringBuilder aSB=new StringBuilder(CCSSValue.PREFIX_URL_OPEN);
  final boolean bAreQuotesRequired=bForceQuoteURL || isCSSURLRequiringQuotes(sURL);
  if (bAreQuotesRequired) {
    final int nIndexSingleQuote=sURL.indexOf('\'');
    final int nIndexDoubleQuote=sURL.indexOf('""');
    final char cQuote=nIndexSingleQuote >= 0 && nIndexDoubleQuote < 0 ? '""' : '\'';
    aSB.append(cQuote).append(getEscapedCSSURL(sURL,cQuote)).append(cQuote);
  }
 else {
    aSB.append(sURL);
  }
  return aSB.append(CCSSValue.SUFFIX_URL_CLOSE).toString();
}","/** 
 * Surround the passed URL with the CSS ""url(...)"". When the passed URL contains characters that require quoting, quotes are automatically added!
 * @param sURL URL to be wrapped. May not be <code>null</code> but maybe empty.
 * @param bForceQuoteURL if <code>true</code> single quotes are added around the URL
 * @return <code>url(<i>sURL</i>)</code> or <code>url('<i>sURL</i>')</code>
 */
@Nonnull @Nonempty public static String getAsCSSURL(@Nonnull final String sURL,final boolean bForceQuoteURL){
  ValueEnforcer.notNull(sURL,""String_Node_Str"");
  final StringBuilder aSB=new StringBuilder(CCSSValue.PREFIX_URL_OPEN);
  final boolean bAreQuotesRequired=bForceQuoteURL || isCSSURLRequiringQuotes(sURL);
  if (bAreQuotesRequired) {
    final int nIndexSingleQuote=sURL.indexOf('\'');
    final int nIndexDoubleQuote=sURL.indexOf('""');
    final char cQuote=nIndexSingleQuote >= 0 && nIndexDoubleQuote < 0 ? '""' : '\'';
    aSB.append(cQuote).append(getEscapedCSSURL(sURL,cQuote)).append(cQuote);
  }
 else {
    aSB.append(sURL);
  }
  return aSB.append(CCSSValue.SUFFIX_URL_CLOSE).toString();
}"
11603,"@Test public void testGetAsCSSURL(){
  for (  final String sURL : new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) {
    final String sEscaped=CSSURLHelper.getAsCSSURL(sURL,false);
    assertEquals(sURL,ParseUtils.trimUrl(sEscaped));
  }
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  final SimpleURL aURL=new SimpleURL(""String_Node_Str"",new SMap(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(aURL,false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(aURL,true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(new SimpleURL(),false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(new SimpleURL(),true));
  assertEquals(aURL,new SimpleURL(CSSURLHelper.getURLValue(CSSURLHelper.getAsCSSURL(aURL,true))));
  try {
    CSSURLHelper.getAsCSSURL(""String_Node_Str"",false);
    fail();
  }
 catch (  final IllegalArgumentException ex) {
  }
}","@Test public void testGetAsCSSURL(){
  for (  final String sURL : new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) {
    final String sEscaped=CSSURLHelper.getAsCSSURL(sURL,false);
    assertEquals(sURL,ParseUtils.trimUrl(sEscaped));
  }
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  final SimpleURL aURL=new SimpleURL(""String_Node_Str"",new SMap(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(aURL,false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(aURL,true));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(new SimpleURL(),false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(new SimpleURL(),true));
  assertEquals(aURL,new SimpleURL(CSSURLHelper.getURLValue(CSSURLHelper.getAsCSSURL(aURL,true))));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",false));
  assertEquals(""String_Node_Str"",CSSURLHelper.getAsCSSURL(""String_Node_Str"",true));
}"
11604,"@Override public int getCount(){
  return 7;
}","@Override public int getCount(){
  return 6;
}"
11605,"@Override public void onNavigationDrawerItemSelected(int position){
switch (position) {
case 0:
    getSupportFragmentManager().beginTransaction().replace(R.id.container,new MainFragment()).commit();
  break;
case 1:
if (PlayerController.isLoggedIn(this)) {
  getSupportFragmentManager().beginTransaction().replace(R.id.container,ProfileFragment.newInstance(PlayerController.getName())).commit();
}
 else {
  showInputDialog(ShotsFragment.MY_SHOTS);
}
break;
case 2:
if (PlayerController.isLoggedIn(this)) {
getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(ShotsFragment.MY_SHOTS)).commit();
}
 else {
showInputDialog(ShotsFragment.MY_SHOTS);
}
break;
case 3:
if (PlayerController.isLoggedIn(this)) {
getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(ShotsFragment.FOLLOWING)).commit();
}
 else {
showInputDialog(ShotsFragment.FOLLOWING);
}
break;
case 4:
if (PlayerController.isLoggedIn(this)) {
getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(ShotsFragment.LIKES)).commit();
}
 else {
showInputDialog(ShotsFragment.LIKES);
}
break;
case 5:
break;
case 6:
break;
}
}","@Override public void onNavigationDrawerItemSelected(int position){
switch (position) {
case 0:
    getSupportFragmentManager().beginTransaction().replace(R.id.container,new MainFragment()).commit();
  break;
case 1:
if (PlayerController.isLoggedIn(this)) {
  getSupportFragmentManager().beginTransaction().replace(R.id.container,ProfileFragment.newInstance(PlayerController.getName())).commit();
}
 else {
  showInputDialog(-1);
}
break;
case 2:
if (PlayerController.isLoggedIn(this)) {
getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(ShotsFragment.MY_SHOTS)).commit();
}
 else {
showInputDialog(ShotsFragment.MY_SHOTS);
}
break;
case 3:
if (PlayerController.isLoggedIn(this)) {
getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(ShotsFragment.FOLLOWING)).commit();
}
 else {
showInputDialog(ShotsFragment.FOLLOWING);
}
break;
case 4:
if (PlayerController.isLoggedIn(this)) {
getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(ShotsFragment.LIKES)).commit();
}
 else {
showInputDialog(ShotsFragment.LIKES);
}
break;
case 5:
break;
case 6:
break;
}
}"
11606,"@Override public void onConfirm(String username,int type){
  PlayerController.setName(MainActivity.this,username);
  getSupportFragmentManager().beginTransaction().replace(R.id.container,ShotsFragment.newInstance(type)).commit();
}","@Override public void onConfirm(String username,int type){
  PlayerController.setName(MainActivity.this,username);
  Fragment fragment;
  if (type == -1) {
    fragment=ProfileFragment.newInstance(username);
  }
 else {
    fragment=ShotsFragment.newInstance(type);
  }
  getSupportFragmentManager().beginTransaction().replace(R.id.container,fragment).commit();
}"
11607,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @AllowedSourceTypes(CommandSourceType.PLAYER) @PermissionRequired(""String_Node_Str"") public void debug(CommandSource source,String[] args,String mode){
  TridentPlayer player=(TridentPlayer)source;
  NetClient client=player.net();
  if (mode.equals(""String_Node_Str"")) {
    Position playerPosition=player.getPosition();
    int chunkLoadRadius=3;
    for (int x=playerPosition.getChunkX() - chunkLoadRadius; x <= playerPosition.getChunkX() + chunkLoadRadius; x++) {
      for (int z=playerPosition.getChunkZ() - chunkLoadRadius; z <= playerPosition.getChunkZ() + chunkLoadRadius; z++) {
        TridentChunk chunk=(TridentChunk)playerPosition.getWorld().getChunkAt(x,z);
        client.sendPacket(new PlayOutChunk(chunk));
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    int i=0;
    for (    String word : ""String_Node_Str"".split(""String_Node_Str"")) {
      BossBar bb=BossBar.newBossBar();
      bb.setTitle(ChatComponent.text(word).setColor(ChatColor.of((char)('a' + i))));
      bb.setColor(BossBarColor.values()[i]);
      bb.setDivision(BossBarDivision.values()[i++]);
      bb.setHealth(i * .25f);
      bb.setDarkenSky(false);
      bb.setDragonBar(false);
      player.addBossBar(bb);
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    Title title=Title.newTitle();
    title.setHeader(ChatComponent.create().setColor(ChatColor.AQUA).setText(""String_Node_Str""));
    title.setSubtitle(ChatComponent.create().setColor(ChatColor.GOLD).setText(""String_Node_Str""));
    title.setFadeIn(0);
    title.setStay(600);
    title.setFadeOut(0);
    player.sendTitle(title);
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.resetTitle();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.sendMessage(ChatComponent.create().setText(""String_Node_Str"").setHoverEvent(HoverEvent.item(Item.newItem(Substance.STONE,30,(byte)1))));
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.getWorld().getWeather().beginRaining();
    player.getWorld().getWeather().beginThunder();
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @AllowedSourceTypes(CommandSourceType.PLAYER) @PermissionRequired(""String_Node_Str"") public void debug(CommandSource source,String[] args,String mode){
  TridentPlayer player=(TridentPlayer)source;
  NetClient client=player.net();
  if (mode.equals(""String_Node_Str"")) {
    Position playerPosition=player.getPosition();
    int chunkLoadRadius=3;
    for (int x=playerPosition.getChunkX() - chunkLoadRadius; x <= playerPosition.getChunkX() + chunkLoadRadius; x++) {
      for (int z=playerPosition.getChunkZ() - chunkLoadRadius; z <= playerPosition.getChunkZ() + chunkLoadRadius; z++) {
        TridentChunk chunk=(TridentChunk)playerPosition.getWorld().getChunkAt(x,z);
        client.sendPacket(new PlayOutChunk(chunk));
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    int i=0;
    for (    String word : ""String_Node_Str"".split(""String_Node_Str"")) {
      BossBar bb=BossBar.newBossBar();
      bb.setTitle(ChatComponent.text(word).setColor(ChatColor.of((char)('a' + i))));
      bb.setColor(BossBarColor.values()[i]);
      bb.setDivision(BossBarDivision.values()[i++]);
      bb.setHealth(i * .25f);
      bb.setDarkenSky(false);
      bb.setDragonBar(false);
      player.addBossBar(bb);
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    Title title=Title.newTitle();
    title.setHeader(ChatComponent.create().setColor(ChatColor.AQUA).setText(""String_Node_Str""));
    title.setSubtitle(ChatComponent.create().setColor(ChatColor.GOLD).setText(""String_Node_Str""));
    title.setFadeIn(0);
    title.setStay(600);
    title.setFadeOut(0);
    player.sendTitle(title);
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.resetTitle();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.sendMessage(ChatComponent.create().setText(""String_Node_Str"").setHoverEvent(HoverEvent.item(Item.newItem(Substance.STONE,30,(byte)1))));
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.getWorld().getWeather().beginRaining();
    player.getWorld().getWeather().beginThunder();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.getMetadata().setCustomNameVisible(true);
    player.getMetadata().setCustomName(""String_Node_Str"");
    player.updateMetadata();
  }
}"
11608,"/** 
 * Calculates the next ID number for a new window.
 * @return the next window ID
 */
private static int calculateNextId(){
  int t;
  do {
    t=ThreadLocalRandom.current().nextInt(256);
  }
 while (REGISTERED_WINDOWS.containsKey(t));
  return t;
}","/** 
 * Calculates the next ID number for a new window.
 * @return the next window ID
 */
private static int calculateNextId(){
  int t;
  do {
    t=ThreadLocalRandom.current().nextInt(255) + 1;
  }
 while (REGISTERED_WINDOWS.containsKey(t));
  return t;
}"
11609,"private PlayOutTabListItem(PlayOutTabListItem.PlayOutTabListItemActionType action){
  super(PlayOutTabListItem.class);
  this.action=action;
}","private PlayOutTabListItem(ActionType action){
  super(PlayOutTabListItem.class);
  this.action=action;
}"
11610,"public void update(UUID uuid,ChatComponent displayName){
  PlayOutTabListItem.PlayOutTabListItemUpdateDisplayName.PlayerData data=new PlayOutTabListItem.PlayOutTabListItemUpdateDisplayName.PlayerData(uuid,displayName);
  this.updates.add(data);
}","public void update(UUID uuid,ChatComponent displayName){
  UpdateDisplayName.PlayerData data=new UpdateDisplayName.PlayerData(uuid,displayName);
  this.updates.add(data);
}"
11611,"public static PlayOutTabListItemAddPlayer addPlayerPacket(){
  return new PlayOutTabListItemAddPlayer();
}","public static AddPlayer addPlayerPacket(){
  return new AddPlayer();
}"
11612,"public static PlayOutTabListItemUpdateDisplayName updatePlayerPacket(){
  return new PlayOutTabListItemUpdateDisplayName();
}","public static UpdateDisplayName updatePlayerPacket(){
  return new UpdateDisplayName();
}"
11613,"public static PlayOutTabListItemRemovePlayer removePlayerPacket(){
  return new PlayOutTabListItemRemovePlayer();
}","public static RemovePlayer removePlayerPacket(){
  return new RemovePlayer();
}"
11614,"public static PlayOutTabListItemUpdateGamemode updateGamemodePacket(){
  return new PlayOutTabListItemUpdateGamemode();
}","public static UpdateGameMode updateGamemodePacket(){
  return new UpdateGameMode();
}"
11615,"public static PlayOutTabListItemUpdateLatency updateLatencyPacket(){
  return new PlayOutTabListItemUpdateLatency();
}","public static UpdateLatency updateLatencyPacket(){
  return new UpdateLatency();
}"
11616,"@Override public void setDisplayName(ChatComponent displayName){
  if (displayName != null && displayName.getText() == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.displayName=displayName != null ? displayName : ChatComponent.text(this.name);
  this.featuredTabLists.forEach(TabList::update);
}","@Override public void setDisplayName(ChatComponent displayName){
  if (displayName != null && displayName.getText() == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.displayName=displayName != null ? displayName : ChatComponent.text(this.name);
synchronized (this.featuredTabLists) {
    this.featuredTabLists.forEach(TabList::update);
  }
}"
11617,"@Override public void setTabList(TabList tabList){
  TabList old=this.tabList;
  if (old != null) {
    old.unsubscribe(this);
  }
  if (tabList != null) {
    this.tabList=tabList;
    tabList.subscribe(this);
    ((TridentTabList)tabList).forceSend(this);
  }
}","@Override public void setTabList(TabList tabList){
synchronized (this.featuredTabLists) {
    TridentTabList old=this.tabList;
    if (old != null) {
      old.unsubscribe(this);
      this.featuredTabLists.remove(old);
    }
    if (tabList != null) {
      this.tabList=(TridentTabList)tabList;
      this.tabList.subscribe(this);
      this.featuredTabLists.add(tabList);
    }
  }
}"
11618,"/** 
 * Sets the texture of this player to a different skin data.
 * @param skinTextures the skin textures
 */
public void setTextures(TabListElement.PlayerProperty skinTextures){
  this.skinTextures=skinTextures;
  this.featuredTabLists.forEach(TabList::update);
}","/** 
 * Sets the texture of this player to a different skin data.
 * @param skinTextures the skin textures
 */
public void setTextures(TabListElement.PlayerProperty skinTextures){
  this.skinTextures=skinTextures;
synchronized (this.featuredTabLists) {
    this.featuredTabLists.forEach(TabList::update);
  }
}"
11619,"@Override public void setElement(int slot,ChatComponent value){
synchronized (this.lock) {
    if (value != null) {
      if (this.elements.size() > slot && this.elements.get(slot) != null) {
        this.elements.get(slot).setDisplayName(value);
        PlayOutTabListItem.PlayOutTabListItemUpdateDisplayName packet=PlayOutTabListItem.updatePlayerPacket();
        packet.update(this.elements.get(slot).getUuid(),value);
        this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
      }
 else {
        List<TabListElement> addedElements=new ArrayList<>();
        for (int i=0; i < slot; i++) {
          if (this.elements.size() == i || this.elements.get(i) == null) {
            TabListElement blank=new TabListElement();
            blank.setName(this.getName(i));
            blank.setBlank(true);
            blank.setDisplayName(ChatComponent.empty());
            this.elements.add(i,blank);
            addedElements.add(blank);
          }
        }
        TabListElement element=new TabListElement();
        element.setDisplayName(value);
        element.setName(this.getName(slot));
        this.elements.add(slot,element);
        addedElements.add(element);
        if (!addedElements.isEmpty()) {
          PlayOutTabListItem.PlayOutTabListItemAddPlayer packet=PlayOutTabListItem.addPlayerPacket();
          addedElements.forEach(e -> packet.addPlayer(e.getUuid(),e.getName(),e.getGameMode(),e.getPing(),e.getDisplayName()));
          this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
        }
      }
    }
 else {
      if (this.elements.size() > slot && this.elements.get(slot) != null) {
        if (slot == this.elements.size() - 1) {
          List<TabListElement> removedElements=new ArrayList<>();
          removedElements.add(this.elements.get(slot));
          this.elements.remove(slot);
          for (int i=this.elements.size() - 1; i >= 0; i--) {
            if (this.elements.get(i).isBlank()) {
              removedElements.add(this.elements.get(i));
              this.elements.remove(i);
            }
 else {
              break;
            }
          }
          PlayOutTabListItem.PlayOutTabListItemRemovePlayer packet=PlayOutTabListItem.removePlayerPacket();
          removedElements.forEach(e -> packet.removePlayer(e.getUuid()));
          this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
        }
 else {
          this.elements.get(slot).setDisplayName(ChatComponent.empty());
          this.elements.get(slot).setBlank(true);
          PlayOutTabListItem.PlayOutTabListItemUpdateDisplayName packet=PlayOutTabListItem.updatePlayerPacket();
          packet.update(this.elements.get(slot).getUuid(),ChatComponent.empty());
          this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
        }
      }
    }
  }
}","@Override public void setElement(int slot,ChatComponent value){
synchronized (this.lock) {
    if (value != null) {
      if (this.elements.size() > slot && this.elements.get(slot) != null) {
        this.elements.get(slot).setDisplayName(value);
        PlayOutTabListItem.UpdateDisplayName packet=PlayOutTabListItem.updatePlayerPacket();
        packet.update(this.elements.get(slot).getUuid(),value);
        this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
      }
 else {
        List<TabListElement> addedElements=new ArrayList<>();
        for (int i=0; i < slot; i++) {
          if (this.elements.size() == i || this.elements.get(i) == null) {
            TabListElement blank=new TabListElement();
            blank.setName(this.getName(i));
            blank.setBlank(true);
            blank.setDisplayName(ChatComponent.empty());
            this.elements.add(i,blank);
            addedElements.add(blank);
          }
        }
        TabListElement element=new TabListElement();
        element.setDisplayName(value);
        element.setName(this.getName(slot));
        this.elements.add(slot,element);
        addedElements.add(element);
        if (!addedElements.isEmpty()) {
          PlayOutTabListItem.AddPlayer packet=PlayOutTabListItem.addPlayerPacket();
          addedElements.forEach(e -> packet.addPlayer(e.getUuid(),e.getName(),e.getGameMode(),e.getPing(),e.getDisplayName()));
          this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
        }
      }
    }
 else {
      if (this.elements.size() > slot && this.elements.get(slot) != null) {
        if (slot == this.elements.size() - 1) {
          List<TabListElement> removedElements=new ArrayList<>();
          removedElements.add(this.elements.get(slot));
          this.elements.remove(slot);
          for (int i=this.elements.size() - 1; i >= 0; i--) {
            if (this.elements.get(i).isBlank()) {
              removedElements.add(this.elements.get(i));
              this.elements.remove(i);
            }
 else {
              break;
            }
          }
          PlayOutTabListItem.RemovePlayer packet=PlayOutTabListItem.removePlayerPacket();
          removedElements.forEach(e -> packet.removePlayer(e.getUuid()));
          this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
        }
 else {
          this.elements.get(slot).setDisplayName(ChatComponent.empty());
          this.elements.get(slot).setBlank(true);
          PlayOutTabListItem.UpdateDisplayName packet=PlayOutTabListItem.updatePlayerPacket();
          packet.update(this.elements.get(slot).getUuid(),ChatComponent.empty());
          this.getUserList().forEach(player -> ((TridentPlayer)player).net().sendPacket(packet));
        }
      }
    }
  }
}"
11620,"@Override public void update(){
synchronized (this.lock) {
    this.elements.clear();
    List<TridentPlayer> players=new ArrayList<>(TridentPlayer.getPlayers().values());
    players.sort(Comparator.comparing(p -> p.getDisplayName().getText()));
    players.forEach(p -> {
      p.featuredTabLists.add(this);
      this.elements.add(new TabListElement(p));
    }
);
  }
  super.update();
}","@Override public void update(){
synchronized (this.lock) {
    this.elements.clear();
    TridentPlayer.getPlayers().values().stream().sorted(Comparator.comparing(p -> p.getDisplayName().getText())).forEach(p -> this.elements.add(new TabListElement(p)));
  }
  super.update();
}"
11621,"@Override public void subscribe(Player player){
  this.users.add(player);
}","public void subscribe(Player player){
  this.users.add(player);
  PlayOutTabListItem.AddPlayer addPacket=PlayOutTabListItem.addPlayerPacket();
  PlayOutPlayerListHeaderAndFooter headerAndFooterPacket=new PlayOutPlayerListHeaderAndFooter(this.header,this.footer);
synchronized (this.lock) {
    this.elements.forEach(addPacket::addPlayer);
  }
  NetClient net=((TridentPlayer)player).net();
  net.sendPacket(addPacket);
  net.sendPacket(headerAndFooterPacket);
}"
11622,"@Override public void unsubscribe(Player player){
  this.users.remove(player);
  PlayOutTabListItem.PlayOutTabListItemRemovePlayer packet=PlayOutTabListItem.removePlayerPacket();
  List<TabListElement> elements;
synchronized (this.lock) {
    elements=this.elements;
  }
  for (  TabListElement element : elements) {
    packet.removePlayer(element.getUuid());
  }
  NetClient net=((TridentPlayer)player).net();
  net.sendPacket(packet);
  net.sendPacket(new PlayOutPlayerListHeaderAndFooter(ChatComponent.empty(),ChatComponent.empty()));
}","public void unsubscribe(Player player){
  this.users.remove(player);
  PlayOutTabListItem.RemovePlayer packet=PlayOutTabListItem.removePlayerPacket();
  List<TabListElement> elements;
synchronized (this.lock) {
    elements=this.elements;
  }
  for (  TabListElement element : elements) {
    packet.removePlayer(element.getUuid());
  }
  NetClient net=((TridentPlayer)player).net();
  net.sendPacket(packet);
  net.sendPacket(new PlayOutPlayerListHeaderAndFooter(ChatComponent.empty(),ChatComponent.empty()));
}"
11623,"/** 
 * Sends the tab list to all subscribed players.
 */
@Override public void update(){
  PlayOutPlayerListHeaderAndFooter headerAndFooterPacket=new PlayOutPlayerListHeaderAndFooter(this.header,this.footer);
  PlayOutTabListItem.PlayOutTabListItemAddPlayer addPacket=PlayOutTabListItem.addPlayerPacket();
  PlayOutTabListItem.PlayOutTabListItemRemovePlayer removePacket=PlayOutTabListItem.removePlayerPacket();
  PlayOutTabListItem.PlayOutTabListItemUpdateGamemode updateGamemodePacket=PlayOutTabListItem.updateGamemodePacket();
  PlayOutTabListItem.PlayOutTabListItemUpdateLatency updateLatencyPacket=PlayOutTabListItem.updateLatencyPacket();
  PlayOutTabListItem.PlayOutTabListItemUpdateDisplayName updateNamePacket=PlayOutTabListItem.updatePlayerPacket();
  Map<UUID,TabListElement> lastSeen=new LinkedHashMap<>();
  Map<UUID,TabListElement> currentElements=new LinkedHashMap<>();
  this.lastSeen.forEach(e -> lastSeen.put(e.getUuid(),e));
synchronized (this.lock) {
    this.elements.forEach(e -> currentElements.put(e.getUuid(),e));
  }
  if (currentElements.containsKey(null)) {
    throw new IllegalStateException(""String_Node_Str"" + currentElements.get(null) + ""String_Node_Str"");
  }
  lastSeen.entrySet().stream().filter(e -> !currentElements.containsKey(e.getKey())).forEach(e -> {
    removePacket.removePlayer(e.getKey());
    currentElements.remove(e.getKey());
  }
);
  currentElements.forEach((key,value) -> {
    if (lastSeen.containsKey(key)) {
      TabListElement last=lastSeen.get(key);
      if (!Objects.equals(value.getDisplayName(),last.getDisplayName())) {
        updateNamePacket.update(key,value.getDisplayName());
      }
      if (value.getGameMode() != last.getGameMode()) {
        updateGamemodePacket.update(key,value.getGameMode());
      }
      if (value.getPing() != last.getPing()) {
        updateLatencyPacket.update(key,value.getPing());
      }
    }
 else {
      addPacket.addPlayer(value);
    }
  }
);
synchronized (this.lock) {
    this.lastSeen.clear();
    this.lastSeen.addAll(this.elements);
  }
  this.users.forEach(p -> {
    TridentPlayer player=(TridentPlayer)p;
    if (removePacket.getActionCount() > 0)     player.net().sendPacket(removePacket);
    if (addPacket.getActionCount() > 0)     player.net().sendPacket(addPacket);
    if (updateGamemodePacket.getActionCount() > 0)     player.net().sendPacket(updateGamemodePacket);
    if (updateLatencyPacket.getActionCount() > 0)     player.net().sendPacket(updateLatencyPacket);
    if (updateNamePacket.getActionCount() > 0)     player.net().sendPacket(updateNamePacket);
    player.net().sendPacket(headerAndFooterPacket);
  }
);
}","/** 
 * Sends the tab list to all subscribed players.
 */
@Override public void update(){
  PlayOutPlayerListHeaderAndFooter headerAndFooterPacket=new PlayOutPlayerListHeaderAndFooter(this.header,this.footer);
  PlayOutTabListItem.AddPlayer addPacket=PlayOutTabListItem.addPlayerPacket();
  PlayOutTabListItem.RemovePlayer removePacket=PlayOutTabListItem.removePlayerPacket();
  PlayOutTabListItem.UpdateGameMode updateGamemodePacket=PlayOutTabListItem.updateGamemodePacket();
  PlayOutTabListItem.UpdateLatency updateLatencyPacket=PlayOutTabListItem.updateLatencyPacket();
  PlayOutTabListItem.UpdateDisplayName updateNamePacket=PlayOutTabListItem.updatePlayerPacket();
  Map<UUID,TabListElement> lastSeen=new LinkedHashMap<>();
  Map<UUID,TabListElement> currentElements=new LinkedHashMap<>();
  this.lastSeen.forEach(e -> lastSeen.put(e.getUuid(),e));
synchronized (this.lock) {
    this.elements.forEach(e -> currentElements.put(e.getUuid(),e));
  }
  if (currentElements.containsKey(null)) {
    throw new IllegalStateException(""String_Node_Str"" + currentElements.get(null) + ""String_Node_Str"");
  }
  lastSeen.entrySet().stream().filter(e -> !currentElements.containsKey(e.getKey())).forEach(e -> {
    removePacket.removePlayer(e.getKey());
    currentElements.remove(e.getKey());
  }
);
  currentElements.forEach((key,value) -> {
    if (lastSeen.containsKey(key)) {
      TabListElement last=lastSeen.get(key);
      if (!Objects.equals(value.getDisplayName(),last.getDisplayName())) {
        updateNamePacket.update(key,value.getDisplayName());
      }
      if (value.getGameMode() != last.getGameMode()) {
        updateGamemodePacket.update(key,value.getGameMode());
      }
      if (value.getPing() != last.getPing()) {
        updateLatencyPacket.update(key,value.getPing());
      }
    }
 else {
      addPacket.addPlayer(value);
    }
  }
);
synchronized (this.lock) {
    this.lastSeen.clear();
    this.lastSeen.addAll(this.elements);
  }
  this.users.forEach(p -> {
    TridentPlayer player=(TridentPlayer)p;
    if (removePacket.getActionCount() > 0)     player.net().sendPacket(removePacket);
    if (addPacket.getActionCount() > 0)     player.net().sendPacket(addPacket);
    if (updateGamemodePacket.getActionCount() > 0)     player.net().sendPacket(updateGamemodePacket);
    if (updateLatencyPacket.getActionCount() > 0)     player.net().sendPacket(updateLatencyPacket);
    if (updateNamePacket.getActionCount() > 0)     player.net().sendPacket(updateNamePacket);
    player.net().sendPacket(headerAndFooterPacket);
  }
);
}"
11624,"@Override public void runCommand(String command){
  this.logger.log(""String_Node_Str"" + command);
  try {
    if (!ServerThreadPool.forSpec(PoolSpec.PLUGINS).submit(() -> this.commandHandler.dispatch(command,this)).get()) {
      this.logger.log(""String_Node_Str"" + command.split(""String_Node_Str"")[0] + ""String_Node_Str"");
    }
  }
 catch (  InterruptedException|ExecutionException e) {
    e.printStackTrace();
  }
}","@Override public void runCommand(String command){
  this.logger.log(""String_Node_Str"" + command);
  try {
    if (!ServerThreadPool.forSpec(PoolSpec.PLUGINS).submit(() -> this.commandHandler.dispatch(command,this)).get()) {
      this.logger.log(""String_Node_Str"" + command.split(""String_Node_Str"")[0] + ""String_Node_Str"");
    }
  }
 catch (  InterruptedException|ExecutionException e) {
    throw new RuntimeException(e);
  }
}"
11625,"@Override @Policy(""String_Node_Str"") public void shutdown(){
  Debug.tryCheckThread();
  this.logger.warn(""String_Node_Str"");
  this.shutdownState=true;
  try {
    this.logger.log(""String_Node_Str"");
    TridentPlayer.getPlayers().values().forEach(p -> p.kick(ChatComponent.text(""String_Node_Str"")));
    this.tick.interrupt();
    this.logger.log(""String_Node_Str"");
    if (!this.pluginLoader.unloadAll()) {
      this.logger.error(""String_Node_Str"");
    }
    for (    World world : TridentWorldLoader.getInstance().getWorlds().values()) {
      this.logger.log(""String_Node_Str"" + world.getName() + ""String_Node_Str"");
      world.save();
    }
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.logger.log(""String_Node_Str"");
    ServerThreadPool.shutdownAll();
    this.logger.log(""String_Node_Str"");
    this.server.shutdown();
  }
 catch (  IOException|InterruptedException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
  System.exit(0);
}","@Override @Policy(""String_Node_Str"") public void shutdown(){
  Debug.tryCheckThread();
  this.logger.warn(""String_Node_Str"");
  this.shutdownState=true;
  try {
    this.logger.log(""String_Node_Str"");
    if (!this.pluginLoader.unloadAll()) {
      this.logger.error(""String_Node_Str"");
    }
    this.tick.interrupt();
    this.logger.log(""String_Node_Str"");
    int removed=0;
    Semaphore sem=new Semaphore(0);
    for (    TridentPlayer player : TridentPlayer.getPlayers().values()) {
      removed++;
      player.net().disconnect(ChatComponent.text(""String_Node_Str"")).addListener(future -> sem.release());
    }
    sem.tryAcquire(removed,10,TimeUnit.SECONDS);
    this.logger.log(""String_Node_Str"");
    this.server.shutdown();
    for (    World world : TridentWorldLoader.getInstance().getWorlds().values()) {
      this.logger.log(""String_Node_Str"" + world.getName() + ""String_Node_Str"");
      world.save();
    }
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.logger.log(""String_Node_Str"");
    ServerThreadPool.shutdownAll();
  }
 catch (  IOException|InterruptedException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
  System.exit(0);
}"
11626,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @AllowedSourceTypes(CommandSourceType.PLAYER) @PermissionRequired(""String_Node_Str"") public void debug(CommandSource source,String[] args,String mode){
  TridentPlayer player=(TridentPlayer)source;
  NetClient client=player.net();
  if (mode.equals(""String_Node_Str"")) {
    Position playerPosition=player.getPosition();
    int chunkLoadRadius=3;
    for (int x=playerPosition.getChunkX() - chunkLoadRadius; x <= playerPosition.getChunkX() + chunkLoadRadius; x++) {
      for (int z=playerPosition.getChunkZ() - chunkLoadRadius; z <= playerPosition.getChunkZ() + chunkLoadRadius; z++) {
        TridentChunk chunk=(TridentChunk)playerPosition.getWorld().getChunkAt(x,z);
        client.sendPacket(new PlayOutChunk(chunk));
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    int i=0;
    for (    String word : ""String_Node_Str"".split(""String_Node_Str"")) {
      BossBar bb=BossBar.newBossBar();
      bb.setTitle(ChatComponent.text(word).setColor(ChatColor.of((char)('a' + i))));
      bb.setColor(BossBarColor.values()[i]);
      bb.setDivision(BossBarDivision.values()[i++]);
      bb.setHealth(i * .25f);
      bb.setDarkenSky(false);
      bb.setDragonBar(false);
      player.addBossBar(bb);
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    Title title=Title.newTitle();
    title.setHeader(ChatComponent.create().setColor(ChatColor.AQUA).setText(""String_Node_Str""));
    title.setSubtitle(ChatComponent.create().setColor(ChatColor.GOLD).setText(""String_Node_Str""));
    title.setFadeIn(0);
    title.setStay(600);
    title.setFadeOut(0);
    player.sendTitle(title);
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.resetTitle();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.sendMessage(ChatComponent.create().setText(""String_Node_Str"").setHoverEvent(HoverEvent.item(Item.newItem(Substance.STONE,30,(byte)1))));
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @AllowedSourceTypes(CommandSourceType.PLAYER) @PermissionRequired(""String_Node_Str"") public void debug(CommandSource source,String[] args,String mode){
  TridentPlayer player=(TridentPlayer)source;
  NetClient client=player.net();
  if (mode.equals(""String_Node_Str"")) {
    Position playerPosition=player.getPosition();
    int chunkLoadRadius=3;
    for (int x=playerPosition.getChunkX() - chunkLoadRadius; x <= playerPosition.getChunkX() + chunkLoadRadius; x++) {
      for (int z=playerPosition.getChunkZ() - chunkLoadRadius; z <= playerPosition.getChunkZ() + chunkLoadRadius; z++) {
        TridentChunk chunk=(TridentChunk)playerPosition.getWorld().getChunkAt(x,z);
        client.sendPacket(new PlayOutChunk(chunk));
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    int i=0;
    for (    String word : ""String_Node_Str"".split(""String_Node_Str"")) {
      BossBar bb=BossBar.newBossBar();
      bb.setTitle(ChatComponent.text(word).setColor(ChatColor.of((char)('a' + i))));
      bb.setColor(BossBarColor.values()[i]);
      bb.setDivision(BossBarDivision.values()[i++]);
      bb.setHealth(i * .25f);
      bb.setDarkenSky(false);
      bb.setDragonBar(false);
      player.addBossBar(bb);
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    Title title=Title.newTitle();
    title.setHeader(ChatComponent.create().setColor(ChatColor.AQUA).setText(""String_Node_Str""));
    title.setSubtitle(ChatComponent.create().setColor(ChatColor.GOLD).setText(""String_Node_Str""));
    title.setFadeIn(0);
    title.setStay(600);
    title.setFadeOut(0);
    player.sendTitle(title);
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.resetTitle();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.sendMessage(ChatComponent.create().setText(""String_Node_Str"").setHoverEvent(HoverEvent.item(Item.newItem(Substance.STONE,30,(byte)1))));
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.getWorld().getWeather().beginRaining();
    player.getWorld().getWeather().beginThunder();
  }
}"
11627,"@Override public ForkJoinWorkerThread newThread(ForkJoinPool pool){
  ForkJoinWorkerThread worker=ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
  worker.setName(this.name + ""String_Node_Str"" + worker.getPoolIndex());
  return worker;
}","@Override public ForkJoinWorkerThread newThread(ForkJoinPool pool){
  ForkJoinWorkerThread worker=ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
  worker.setName(this.name + ""String_Node_Str"" + worker.getPoolIndex());
  worker.setUncaughtExceptionHandler(this);
  return worker;
}"
11628,"/** 
 * Exports the given resource and copies it into the given destination path.
 * @param dest the destination
 * @param resource the resource to copy
 */
public static void exportResource(Path dest,String resource){
  InputStream stream=ConfigIo.class.getResourceAsStream(resource);
  try {
    Files.copy(stream,dest);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Exports the given resource and copies it into the given destination path.
 * @param dest the destination
 * @param resource the resource to copy
 */
public static void exportResource(Path dest,String resource){
  InputStream stream=ConfigIo.class.getResourceAsStream(resource);
  try {
    Files.copy(stream,dest);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
11629,"@Override protected void decode(ChannelHandlerContext ctx,ByteBuf buf,List<Object> list) throws Exception {
  ByteBuf decrypt=buf;
  NetCrypto crypto=this.client.getCryptoModule();
  if (crypto != null && crypto.isCryptoEnabled()) {
    decrypt=ctx.alloc().buffer();
    crypto.decrypt(buf,decrypt);
  }
  int fullLen=rvint(decrypt);
  ByteBuf decompressed;
  if (this.client.doCompression()) {
    int uncompressed=rvint(decrypt);
    if (uncompressed != 0) {
      if (uncompressed < TridentServer.cfg().compressionThresh()) {
        this.client.disconnect(""String_Node_Str"");
        return;
      }
      decompressed=ctx.alloc().buffer();
      byte[] in=arr(decrypt,fullLen - BigInteger.valueOf(uncompressed).toByteArray().length);
      Inflater inflater=INFLATER.get();
      inflater.setInput(in);
      byte[] buffer=new byte[NetClient.BUFFER_SIZE];
      while (!inflater.finished()) {
        int bytes=inflater.inflate(buffer);
        decompressed.writeBytes(buffer,0,bytes);
      }
      inflater.reset();
    }
 else {
      decompressed=decrypt.readBytes(fullLen - OutEncoder.VINT_LEN);
    }
  }
 else {
    decompressed=decrypt.readBytes(fullLen);
  }
  try {
    int id=rvint(decompressed);
    Class<? extends Packet> cls=PacketRegistry.byId(this.client.getState(),Packet.Bound.SERVER,id);
    PacketIn packet=PacketRegistry.make(cls);
    LOGGER.debug(""String_Node_Str"" + packet.getClass().getSimpleName());
    packet.read(decompressed,this.client);
  }
  finally {
    decompressed.release();
    if (decrypt != buf) {
      decrypt.release();
    }
  }
}","@Override protected void decode(ChannelHandlerContext ctx,ByteBuf buf,List<Object> list) throws Exception {
  ByteBuf decrypt=buf;
  NetCrypto crypto=this.client.getCryptoModule();
  if (crypto != null) {
    decrypt=ctx.alloc().buffer();
    crypto.decrypt(buf,decrypt,this.actualReadableBytes());
  }
  int fullLen=rvint(decrypt);
  ByteBuf decompressed;
  if (this.client.doCompression()) {
    int uncompressed=rvint(decrypt);
    if (uncompressed != 0) {
      if (uncompressed < TridentServer.cfg().compressionThresh()) {
        this.client.disconnect(""String_Node_Str"");
        return;
      }
      decompressed=ctx.alloc().buffer();
      byte[] in=arr(decrypt,fullLen - BigInteger.valueOf(uncompressed).toByteArray().length);
      Inflater inflater=INFLATER.get();
      inflater.setInput(in);
      byte[] buffer=new byte[NetClient.BUFFER_SIZE];
      while (!inflater.finished()) {
        int bytes=inflater.inflate(buffer);
        decompressed.writeBytes(buffer,0,bytes);
      }
      inflater.reset();
    }
 else {
      decompressed=decrypt.readBytes(fullLen - OutEncoder.VINT_LEN);
    }
  }
 else {
    decompressed=decrypt.readBytes(fullLen);
  }
  try {
    int id=rvint(decompressed);
    Class<? extends Packet> cls=PacketRegistry.byId(this.client.getState(),Packet.Bound.SERVER,id);
    PacketIn packet=PacketRegistry.make(cls);
    LOGGER.debug(""String_Node_Str"" + packet.getClass().getSimpleName());
    packet.read(decompressed,this.client);
  }
  finally {
    decompressed.release();
    if (decrypt != buf) {
      decrypt.release();
    }
  }
}"
11630,"/** 
 * Disconnects this client from the server.
 * @param reason the reason for disconnecting
 */
public void disconnect(ChatComponent reason){
  TridentPlayer player=this.player.get();
  if (this.player.compareAndSet(player,null)) {
    this.channel.closeFuture().removeListener(this.futureListener);
    NetClient.NetState state=this.state;
    if (state == NetClient.NetState.LOGIN) {
      this.sendPacket(new LoginOutDisconnect(reason)).addListener(future -> {
        this.channel.close();
        TridentServer.getInstance().getLogger().log(""String_Node_Str"" + this.name + ""String_Node_Str""+ reason.getText());
      }
);
    }
 else     if (state == NetClient.NetState.PLAY) {
      if (player != null) {
        this.sendPacket(new PlayOutDisconnect(reason)).addListener(future -> {
          this.channel.close();
          player.remove();
          TridentServer.getInstance().getLogger().log(""String_Node_Str"" + this.name + ""String_Node_Str""+ player.getUuid()+ ""String_Node_Str""+ reason.getText());
        }
);
      }
    }
 else     if (state == NetState.STATUS) {
      this.channel.close();
    }
    CLIENTS.remove(this.channel.remoteAddress());
  }
}","/** 
 * Disconnects this client from the server.
 * @param reason the reason for disconnecting
 */
public Future<Void> disconnect(ChatComponent reason){
  String name=this.name.get();
  if (name == null) {
    this.channel.close();
    CLIENTS.remove(this.channel.remoteAddress());
    return null;
  }
  if (name.equals(""String_Node_Str"")) {
    return null;
  }
  Future<Void> waiter=null;
  if (this.name.compareAndSet(name,""String_Node_Str"")) {
    NetClient.NetState state=this.state;
    if (state == NetClient.NetState.LOGIN) {
      waiter=this.sendPacket(new LoginOutDisconnect(reason)).addListener(future -> {
        this.channel.close();
        TridentServer.getInstance().getLogger().log(""String_Node_Str"" + name + ""String_Node_Str""+ reason.getText());
      }
);
    }
 else     if (state == NetClient.NetState.PLAY) {
      TridentPlayer player=this.player;
      if (player != null) {
        waiter=this.sendPacket(new PlayOutDisconnect(reason)).addListener(future -> {
          this.channel.close();
          player.remove();
          TridentServer.getInstance().getLogger().log(""String_Node_Str"" + name + ""String_Node_Str""+ player.getUuid()+ ""String_Node_Str""+ reason.getText());
        }
);
      }
    }
 else     if (state == NetState.STATUS) {
      waiter=this.channel.close();
    }
    CLIENTS.remove(this.channel.remoteAddress());
  }
  return waiter;
}"
11631,"/** 
 * Decrypts the given byte buffer with the information provided by this crypto module.
 * @param buf the buffer
 * @param dest the destination
 */
public void decrypt(ByteBuf buf,ByteBuf dest){
  Function<Integer,Cipher> init=this.cipherInit;
  if (init == null) {
    dest.writeBytes(buf);
    return;
  }
  byte[] bytes=arr(buf);
  Cipher cipher=init.apply(Cipher.DECRYPT_MODE);
  dest.writeBytes(cipher.update(bytes));
}","/** 
 * Decrypts the given byte buffer with the information provided by this crypto module.
 * @param buf the buffer
 * @param dest the destination
 */
public void decrypt(ByteBuf buf,ByteBuf dest,int len){
  Function<Integer,Cipher> init=this.cipherInit;
  if (init == null) {
    dest.writeBytes(buf,len);
    return;
  }
  byte[] bytes=arr(buf,len);
  Cipher cipher=init.apply(Cipher.DECRYPT_MODE);
  dest.writeBytes(cipher.update(bytes));
}"
11632,"/** 
 * Begins encryption checking.
 * @param encryptedSecret the encrypted shared secret
 * @param encryptedToken the encrypted token
 * @return the decrypted secret, or {@code null} if thisoperation did not complete successfully
 */
public byte[] begin(byte[] encryptedSecret,byte[] encryptedToken){
  try {
    Cipher keyPairCipher=Cipher.getInstance(KEY_PAIR_ALGO);
    keyPairCipher.init(Cipher.DECRYPT_MODE,this.kp.getPrivate());
    byte[] decryptedSecret=keyPairCipher.doFinal(encryptedSecret);
    byte[] decryptedToken=keyPairCipher.doFinal(encryptedToken);
    if (Arrays.equals(decryptedToken,this.token)) {
      SecretKey sharedSecret=new SecretKeySpec(decryptedSecret,SECRET_ALGO);
      IvParameterSpec iv=new IvParameterSpec(sharedSecret.getEncoded());
      this.cipherInit=mode -> {
        try {
          if (mode == Cipher.DECRYPT_MODE) {
            Cipher instance=this.decrypt.get();
            if (instance == null) {
              instance=Cipher.getInstance(CIPHER_NAME);
              instance.init(mode,sharedSecret,iv);
              this.decrypt.set(instance);
            }
            return instance;
          }
 else {
            Cipher instance=this.encrypt.get();
            if (instance == null) {
              instance=Cipher.getInstance(CIPHER_NAME);
              instance.init(mode,sharedSecret,iv);
              this.encrypt.set(instance);
            }
            return instance;
          }
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
;
      cryptoEnabled=true;
      return decryptedSecret;
    }
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException|InvalidKeyException|BadPaddingException|IllegalBlockSizeException e) {
    throw new RuntimeException(e);
  }
  return null;
}","/** 
 * Begins encryption checking.
 * @param encryptedSecret the encrypted shared secret
 * @param encryptedToken the encrypted token
 * @return the decrypted secret, or {@code null} if thisoperation did not complete successfully
 */
public byte[] begin(byte[] encryptedSecret,byte[] encryptedToken){
  try {
    Cipher keyPairCipher=Cipher.getInstance(KEY_PAIR_ALGO);
    keyPairCipher.init(Cipher.DECRYPT_MODE,this.kp.getPrivate());
    byte[] decryptedSecret=keyPairCipher.doFinal(encryptedSecret);
    byte[] decryptedToken=keyPairCipher.doFinal(encryptedToken);
    if (Arrays.equals(decryptedToken,this.token)) {
      SecretKey sharedSecret=new SecretKeySpec(decryptedSecret,SECRET_ALGO);
      IvParameterSpec iv=new IvParameterSpec(sharedSecret.getEncoded());
      this.cipherInit=mode -> {
        try {
          if (mode == Cipher.DECRYPT_MODE) {
            Cipher instance=this.decrypt.get();
            if (instance == null) {
              instance=Cipher.getInstance(CIPHER_NAME);
              instance.init(mode,sharedSecret,iv);
              this.decrypt.set(instance);
            }
            return instance;
          }
 else {
            Cipher instance=this.encrypt.get();
            if (instance == null) {
              instance=Cipher.getInstance(CIPHER_NAME);
              instance.init(mode,sharedSecret,iv);
              this.encrypt.set(instance);
            }
            return instance;
          }
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
;
      return decryptedSecret;
    }
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException|InvalidKeyException|BadPaddingException|IllegalBlockSizeException e) {
    throw new RuntimeException(e);
  }
  return null;
}"
11633,"@Override @Policy(""String_Node_Str"") public boolean unregister(Class<? extends SimpleChannelListener> cls){
  Debug.tryCheckThread();
  return TridentPluginChannel.unregister(cls);
}","@Override @Policy(""String_Node_Str"") public boolean unregister(Class<? extends SimpleChannelListener> cls){
  return TridentPluginChannel.unregister(cls);
}"
11634,"@Override @Policy(""String_Node_Str"") public void register(SimpleChannelListener listener){
  Debug.tryCheckThread();
  TridentPluginChannel.register(listener);
}","@Override @Policy(""String_Node_Str"") public void register(SimpleChannelListener listener){
  TridentPluginChannel.register(listener);
}"
11635,"@Override @Policy(""String_Node_Str"") public void reload(){
  Debug.tryCheckThread();
  this.logger.warn(""String_Node_Str"");
  try {
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.opsList.save();
    this.config.load();
    this.opsList.load();
    this.logger.log(""String_Node_Str"");
    this.pluginLoader.reload();
  }
 catch (  IOException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
}","@Override @Policy(""String_Node_Str"") public void reload(){
  this.logger.warn(""String_Node_Str"");
  try {
    this.logger.log(""String_Node_Str"");
    this.config.load();
    this.opsList.load();
    this.logger.log(""String_Node_Str"");
    this.pluginLoader.reload();
  }
 catch (  IOException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
}"
11636,"@Override public Collection<TridentPlayer> getPlayersFuzzyMatching(String filter){
  Objects.requireNonNull(filter,""String_Node_Str"");
  return getPlayers().stream().filter(p -> {
    String f=filter;
    String n=p.getName();
    while (n.length() >= f.length()) {
      if (f.length() == 0 || n.length() == 0)       return true;
      int index=n.indexOf(f.charAt(0));
      if (index < 0)       break;
      n=n.substring(index + 1);
      f=f.substring(1);
    }
    return false;
  }
).collect(Collectors.toList());
}","@Override public Collection<TridentPlayer> getPlayersFuzzyMatching(String filter){
  Objects.requireNonNull(filter,""String_Node_Str"");
  return getPlayers().stream().filter(p -> {
    String f=filter;
    String n=p.getName();
    while (n.length() >= f.length()) {
      if (f.isEmpty() || n.isEmpty())       return true;
      int index=n.indexOf(f.charAt(0));
      if (index < 0)       break;
      n=n.substring(index + 1);
      f=f.substring(1);
    }
    return false;
  }
).collect(Collectors.toList());
}"
11637,"@Override @Policy(""String_Node_Str"") public void shutdown(){
  Debug.tryCheckThread();
  this.logger.warn(""String_Node_Str"");
  this.shutdownState=true;
  try {
    this.logger.log(""String_Node_Str"");
    if (!this.pluginLoader.unloadAll()) {
      this.logger.error(""String_Node_Str"");
    }
    this.tick.interrupt();
    this.logger.log(""String_Node_Str"");
    int removed=0;
    Semaphore sem=new Semaphore(0);
    for (    TridentPlayer player : TridentPlayer.getPlayers().values()) {
      removed++;
      player.net().disconnect(ChatComponent.text(""String_Node_Str"")).addListener(future -> sem.release());
    }
    sem.tryAcquire(removed,10,TimeUnit.SECONDS);
    this.logger.log(""String_Node_Str"");
    this.server.shutdown();
    for (    World world : TridentWorldLoader.getInstance().getWorlds().values()) {
      this.logger.log(""String_Node_Str"" + world.getName() + ""String_Node_Str"");
      world.save();
    }
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.logger.log(""String_Node_Str"");
    ServerThreadPool.shutdownAll();
  }
 catch (  IOException|InterruptedException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
  System.exit(0);
}","@Override @Policy(""String_Node_Str"") public void shutdown(){
  this.logger.warn(""String_Node_Str"");
  this.shutdownState=true;
  try {
    this.logger.log(""String_Node_Str"");
    if (!this.pluginLoader.unloadAll()) {
      this.logger.error(""String_Node_Str"");
    }
    this.tick.interrupt();
    this.logger.log(""String_Node_Str"");
    int removed=0;
    Semaphore sem=new Semaphore(0);
    for (    TridentPlayer player : TridentPlayer.getPlayers().values()) {
      removed++;
      player.net().disconnect(ChatComponent.text(""String_Node_Str"")).addListener(future -> sem.release());
    }
    sem.tryAcquire(removed,10,TimeUnit.SECONDS);
    this.logger.log(""String_Node_Str"");
    this.server.shutdown();
    for (    World world : TridentWorldLoader.getInstance().getWorlds().values()) {
      this.logger.log(""String_Node_Str"" + world.getName() + ""String_Node_Str"");
      world.save();
    }
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.logger.log(""String_Node_Str"");
    ServerThreadPool.shutdownAll();
  }
 catch (  IOException|InterruptedException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
  System.exit(0);
}"
11638,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @PermissionRequired(""String_Node_Str"") public void kick(CommandSource source,String[] args,@PlayerExactMatch Player player,String... reason){
  if (player != null) {
    String reasonString=reason.length == 0 ? ""String_Node_Str"" : String.join(""String_Node_Str"",reason);
    player.kick(ChatComponent.text(reasonString));
    TridentServer.getInstance().getLogger().log(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ reason);
  }
 else {
    source.sendMessage(ChatComponent.text(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @PermissionRequired(""String_Node_Str"") public void kick(CommandSource source,String[] args,@PlayerExactMatch Player player,String... reason){
  if (player != null) {
    String reasonString=reason.length == 0 ? ""String_Node_Str"" : String.join(""String_Node_Str"",reason);
    player.kick(ChatComponent.text(reasonString));
    TridentServer.getInstance().getLogger().log(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ reasonString);
  }
 else {
    source.sendMessage(ChatComponent.text(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
}"
11639,"@Override public int hashCode(){
  return id().hashCode();
}","@Override public int hashCode(){
  return this.id().hashCode();
}"
11640,"@Override public String toString(){
  return id();
}","@Override public String toString(){
  return this.id();
}"
11641,"private TridentDummyCommandPlugin(String id,String display){
  if (!Arrays.asList(""String_Node_Str"",""String_Node_Str"").contains(id))   throw new IllegalArgumentException(""String_Node_Str"");
  if (!used0.compareAndSet(0,1) && !used1.compareAndSet(0,1)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  PluginDesc pluginDesc=new PluginDesc(){
    @Override public boolean equals(    Object obj){
      return obj == this;
    }
    @Override public int hashCode(){
      return id().hashCode();
    }
    @Override public String toString(){
      return id();
    }
    @Override public Class<? extends Annotation> annotationType(){
      return PluginDesc.class;
    }
    @Override public String id(){
      return id;
    }
    @Override public String name(){
      return display;
    }
    @Override public String version(){
      return ""String_Node_Str"";
    }
    @Override public String author(){
      return ""String_Node_Str"";
    }
    @Override public String[] depends(){
      return new String[0];
    }
  }
;
  try {
    Field f=Plugin.class.getDeclaredField(""String_Node_Str"");
    f.setAccessible(true);
    f.set(this,pluginDesc);
  }
 catch (  ReflectiveOperationException ex) {
    ex.printStackTrace();
  }
}","private TridentDummyCommandPlugin(String id,String display){
  if (!Arrays.asList(""String_Node_Str"",""String_Node_Str"").contains(id))   throw new IllegalArgumentException(""String_Node_Str"");
  if (!used0.compareAndSet(0,1) && !used1.compareAndSet(0,1)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  PluginDesc pluginDesc=new PluginDesc(){
    @Override public boolean equals(    Object obj){
      return obj == this;
    }
    @Override public int hashCode(){
      return this.id().hashCode();
    }
    @Override public String toString(){
      return this.id();
    }
    @Override public Class<? extends Annotation> annotationType(){
      return PluginDesc.class;
    }
    @Override public String id(){
      return id;
    }
    @Override public String name(){
      return display;
    }
    @Override public String version(){
      return ""String_Node_Str"";
    }
    @Override public String author(){
      return ""String_Node_Str"";
    }
    @Override public String[] depends(){
      return new String[0];
    }
  }
;
  try {
    Field f=Plugin.class.getDeclaredField(""String_Node_Str"");
    f.setAccessible(true);
    f.set(this,pluginDesc);
  }
 catch (  ReflectiveOperationException ex) {
    ex.printStackTrace();
  }
}"
11642,"/** 
 * Creates a new netclient that represents a client's connection to the server.
 * @param ctx the context
 */
public NetClient(ChannelHandlerContext ctx){
  this.channel=ctx.channel();
  this.state=NetClient.NetState.HANDSHAKE;
  this.channel.closeFuture().addListener(this.futureListener);
}","/** 
 * Creates a new netclient that represents a client's connection to the server.
 * @param ctx the context
 */
public NetClient(ChannelHandlerContext ctx){
  this.channel=ctx.channel();
  this.state=NetClient.NetState.HANDSHAKE;
  this.channel.closeFuture().addListener(future -> new GenericFutureListener<Future<Void>>(){
    @Override public void operationComplete(    Future<Void> f) throws Exception {
      f.removeListener(this);
      NetClient.this.disconnect(""String_Node_Str"");
    }
  }
);
}"
11643,"@Override public void read(ByteBuf buf,NetClient client){
  long endStamp=System.currentTimeMillis();
  long time=buf.readLong();
  client.setPing(endStamp - time);
  client.sendPacket(new StatusOutPong(time));
}","@Override public void read(ByteBuf buf,NetClient client){
  long endStamp=System.currentTimeMillis();
  long time=buf.readLong();
  client.getPing().set(endStamp - time);
  client.sendPacket(new StatusOutPong(time));
}"
11644,"public static void init(){
  if (!init.compareAndSet(false,true))   return;
  String userDir=System.getProperty(""String_Node_Str"");
  logger=Logger.get(""String_Node_Str"");
  iconPath=Paths.get(""String_Node_Str"");
  try {
    loadIcon();
  }
 catch (  IOException ex) {
    logger.log(""String_Node_Str"");
  }
  Thread watcherThread=new Thread(() -> {
    try {
      Path dir=Paths.get(userDir);
      WatchService service=dir.getFileSystem().newWatchService();
      WatchKey watchKey=dir.register(service,ENTRY_CREATE,ENTRY_MODIFY,ENTRY_DELETE);
      while (true) {
        try {
          WatchKey eventKey=service.take();
          logger.log(""String_Node_Str"");
          if (eventKey != watchKey) {
            logger.warn(String.format(""String_Node_Str"",eventKey,watchKey));
            break;
          }
          eventKey.pollEvents().forEach(e -> {
            if (!e.context().equals(iconPath))             return;
            logger.log(""String_Node_Str"" + e.kind());
            if (e.kind() == ENTRY_CREATE || e.kind() == ENTRY_MODIFY) {
              try {
                loadIcon();
              }
 catch (              IOException ex) {
                ex.printStackTrace();
              }
            }
 else             if (e.kind() == ENTRY_DELETE) {
              b64icon.set(null);
            }
          }
);
          if (!eventKey.reset()) {
            logger.log(""String_Node_Str"");
            break;
          }
        }
 catch (        InterruptedException ex) {
          ex.printStackTrace();
          break;
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
,""String_Node_Str"");
  watcherThread.setDaemon(true);
  watcherThread.start();
}","public static void init(){
  if (!init.compareAndSet(false,true))   return;
  try {
    loadIcon();
  }
 catch (  IOException ex) {
    logger.log(""String_Node_Str"");
  }
  String userDir=System.getProperty(""String_Node_Str"");
  Thread watcherThread=new Thread(() -> {
    try {
      Path dir=Paths.get(userDir);
      WatchService service=dir.getFileSystem().newWatchService();
      WatchKey watchKey=dir.register(service,ENTRY_CREATE,ENTRY_MODIFY,ENTRY_DELETE);
      while (true) {
        try {
          WatchKey eventKey=service.take();
          logger.log(""String_Node_Str"");
          if (eventKey != watchKey) {
            logger.warn(String.format(""String_Node_Str"",eventKey,watchKey));
            break;
          }
          eventKey.pollEvents().forEach(e -> {
            if (!e.context().equals(iconPath))             return;
            logger.log(""String_Node_Str"" + e.kind());
            if (e.kind() == ENTRY_CREATE || e.kind() == ENTRY_MODIFY) {
              try {
                loadIcon();
              }
 catch (              IOException ex) {
                ex.printStackTrace();
              }
            }
 else             if (e.kind() == ENTRY_DELETE) {
              b64icon.set(null);
            }
          }
);
          if (!eventKey.reset()) {
            logger.log(""String_Node_Str"");
            break;
          }
        }
 catch (        InterruptedException ex) {
          ex.printStackTrace();
          break;
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
,""String_Node_Str"");
  watcherThread.setDaemon(true);
  watcherThread.start();
}"
11645,"public void chat(String msg){
  ChatComponent chat=ChatComponent.create().setTranslate(""String_Node_Str"").addWith(ChatComponent.create().setText(getName()).setClickEvent(ClickEvent.of(ClickAction.SUGGEST_COMMAND,""String_Node_Str"" + getName() + ""String_Node_Str""))).addWith(msg);
  Collection<Player> recipients=new ArrayList<>(TridentPlayer.getPlayers().values());
  PlayerChatEvent _event=new PlayerChatEvent(this,chat,recipients);
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).submit(() -> {
    TridentServer.getInstance().getEventController().dispatch(_event,event -> {
      if (!event.isCancelled()) {
        ChatComponent chatComponent=event.getChatComponent();
        event.getRecipients().forEach(p -> p.sendMessage(chatComponent,ChatType.CHAT));
      }
      TridentServer.getInstance().getLogger().log(getName() + ""String_Node_Str"" + getUuid()+ ""String_Node_Str""+ msg);
    }
);
  }
);
}","@Override public void chat(String msg){
  ChatComponent chat=ChatComponent.create().setTranslate(""String_Node_Str"").addWith(ChatComponent.create().setText(this.getName()).setClickEvent(ClickEvent.of(ClickAction.SUGGEST_COMMAND,""String_Node_Str"" + this.getName() + ""String_Node_Str""))).addWith(msg);
  Collection<Player> recipients=new ArrayList<>(TridentPlayer.getPlayers().values());
  PlayerChatEvent _event=new PlayerChatEvent(this,chat,recipients);
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).submit(() -> TridentServer.getInstance().getEventController().dispatch(_event,event -> {
    if (!event.isCancelled()) {
      ChatComponent chatComponent=event.getChatComponent();
      event.getRecipients().forEach(p -> p.sendMessage(chatComponent,ChatType.CHAT));
    }
    TridentServer.getInstance().getLogger().log(getName() + ""String_Node_Str"" + getUuid()+ ""String_Node_Str""+ msg);
  }
));
}"
11646,"@Override public void sendMessage(ChatComponent text){
  StringBuilder builder=new StringBuilder();
  builder.append(text.getColor()).append(text.getText());
  for (  ChatComponent e : text.getExtra()) {
    if (e.getColor() != null) {
      builder.append(e.getColor());
    }
    builder.append(e.getText());
  }
  this.logger.log(builder.toString());
}","@Override public void sendMessage(ChatComponent text){
  StringBuilder builder=new StringBuilder();
  if (text.getColor() != null)   builder.append(text.getColor());
  builder.append(text.getText());
  for (  ChatComponent e : text.getExtra()) {
    if (e.getColor() != null) {
      builder.append(e.getColor());
    }
    builder.append(e.getText());
  }
  this.logger.log(builder.toString());
}"
11647,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") @ParamsAnnotations.AllowedSourceTypes({CommandSourceType.PLAYER,CommandSourceType.CONSOLE}) public void deop(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player){
  if (player == null) {
    source.sendMessage(ChatComponent.create().setColor(ChatColor.RED).setText(""String_Node_Str""));
  }
 else {
    player.setOp(false);
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") @ParamsAnnotations.AllowedSourceTypes({CommandSourceType.PLAYER,CommandSourceType.CONSOLE}) public void deop(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player){
  if (player == null) {
    source.sendMessage(ChatComponent.create().setColor(ChatColor.RED).setText(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
 else {
    player.setOp(false);
  }
}"
11648,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") public void kick(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player,String... reason){
  if (player != null) {
    String reasonString=reason.length == 0 ? ""String_Node_Str"" : String.join(""String_Node_Str"",reason);
    player.kick(ChatComponent.text(reasonString));
    TridentServer.getInstance().getLogger().log(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ reason);
  }
 else {
    source.sendMessage(ChatComponent.text(""String_Node_Str""));
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") public void kick(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player,String... reason){
  if (player != null) {
    String reasonString=reason.length == 0 ? ""String_Node_Str"" : String.join(""String_Node_Str"",reason);
    player.kick(ChatComponent.text(reasonString));
    TridentServer.getInstance().getLogger().log(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ reason);
  }
 else {
    source.sendMessage(ChatComponent.text(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
}"
11649,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") @ParamsAnnotations.AllowedSourceTypes({CommandSourceType.PLAYER,CommandSourceType.CONSOLE}) public void op(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player){
  if (player == null) {
    source.sendMessage(ChatComponent.create().setColor(ChatColor.RED).setText(""String_Node_Str""));
  }
 else {
    player.setOp(true);
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") @ParamsAnnotations.AllowedSourceTypes({CommandSourceType.PLAYER,CommandSourceType.CONSOLE}) public void op(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player){
  if (player == null) {
    source.sendMessage(ChatComponent.create().setColor(ChatColor.RED).setText(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
 else {
    player.setOp(true);
  }
}"
11650,"@Command(name=""String_Node_Str"",aliases=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") @ParamsAnnotations.AllowedSourceTypes(CommandSourceType.PLAYER) public void teleport(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player,double x,double y,double z,@ParamsAnnotations.MaxCount(2) float... direction){
  if (player == null) {
    source.sendMessage(ChatComponent.create().setColor(ChatColor.RED).setText(""String_Node_Str""));
  }
 else {
    float pitch=direction.length > 0 ? direction[0] : 0;
    float yaw=direction.length > 1 ? direction[1] : 0;
    player.setPosition(new Position(player.getWorld(),x,y,z,pitch,yaw));
  }
}","@Command(name=""String_Node_Str"",aliases=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @ParamsAnnotations.PermissionRequired(""String_Node_Str"") @ParamsAnnotations.AllowedSourceTypes(CommandSourceType.PLAYER) public void teleport(CommandSource source,String[] args,@ParamsAnnotations.PlayerExactMatch Player player,double x,double y,double z,@ParamsAnnotations.MaxCount(2) float... direction){
  if (player == null) {
    source.sendMessage(ChatComponent.create().setColor(ChatColor.RED).setText(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
 else {
    float pitch=direction.length > 0 ? direction[0] : 0;
    float yaw=direction.length > 1 ? direction[1] : 0;
    player.setPosition(new Position(player.getWorld(),x,y,z,pitch,yaw));
  }
}"
11651,"@Override public Collection<TridentPlayer> getPlayers(){
  return TridentPlayer.getPlayers().values().stream().filter(p -> p.net().getState() == NetClient.NetState.PLAY).collect(Collectors.toSet());
}","@Override public Collection<TridentPlayer> getPlayers(){
  return Collections.unmodifiableCollection(TridentPlayer.getPlayers().values());
}"
11652,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @AllowedSourceTypes(CommandSourceType.PLAYER) @PermissionRequired(""String_Node_Str"") public void debug(CommandSource source,String[] args,String mode){
  TridentPlayer player=(TridentPlayer)source;
  NetClient client=player.net();
  if (mode.equals(""String_Node_Str"")) {
    Position playerPosition=player.getPosition();
    int chunkLoadRadius=3;
    for (int x=playerPosition.getChunkX() - chunkLoadRadius; x <= playerPosition.getChunkX() + chunkLoadRadius; x++) {
      for (int z=playerPosition.getChunkZ() - chunkLoadRadius; z <= playerPosition.getChunkZ() + chunkLoadRadius; z++) {
        TridentChunk chunk=(TridentChunk)playerPosition.getWorld().getChunkAt(x,z);
        client.sendPacket(new PlayOutChunk(chunk));
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    int i=0;
    for (    String word : ""String_Node_Str"".split(""String_Node_Str"")) {
      BossBar bb=BossBar.newBossBar();
      bb.setTitle(ChatComponent.text(word).setColor(ChatColor.of((char)('a' + i))));
      bb.setColor(BossBarColor.values()[i]);
      bb.setDivision(BossBarDivision.values()[i++]);
      bb.setHealth(i * .25f);
      bb.setDarkenSky(false);
      bb.setDragonBar(false);
      player.addBossBar(bb);
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    Title title=Title.newTitle();
    title.setHeader(ChatComponent.create().setColor(ChatColor.AQUA).setText(""String_Node_Str""));
    title.setSubtitle(ChatComponent.create().setColor(ChatColor.GOLD).setText(""String_Node_Str""));
    title.setFadeIn(0);
    title.setStay(600);
    title.setFadeOut(0);
    player.sendTitle(title);
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.resetTitle();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.sendMessage(ChatComponent.create().setText(""String_Node_Str"").setHoverEvent(HoverEvent.item(Item.newItem(Substance.STONE,30,(byte)1))));
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.getWorld().getWeather().beginRaining();
    player.getWorld().getWeather().beginThunder();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    PlayOutTabListItem.RemovePlayer removePlayer=PlayOutTabListItem.removePlayerPacket();
    removePlayer.removePlayer(player.getUuid());
    PlayOutTabListItem.AddPlayer addPlayer=PlayOutTabListItem.addPlayerPacket();
    addPlayer.addPlayer(player.getUuid(),""String_Node_Str"",player.getGameMode(),0,player.getDisplayName(),Collections.singletonList(player.getSkinTextures()));
    RecipientSelector.whoCanSee(player,false,removePlayer,new PlayOutDestroyEntities(Collections.singletonList(player)),addPlayer);
    RecipientSelector.whoCanSee(player,true,player.getSpawnPacket());
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @AllowedSourceTypes(CommandSourceType.PLAYER) @PermissionRequired(""String_Node_Str"") public void debug(CommandSource source,String[] args,String mode){
  TridentPlayer player=(TridentPlayer)source;
  NetClient client=player.net();
  if (mode.equals(""String_Node_Str"")) {
    Position playerPosition=player.getPosition();
    int chunkLoadRadius=3;
    for (int x=playerPosition.getChunkX() - chunkLoadRadius; x <= playerPosition.getChunkX() + chunkLoadRadius; x++) {
      for (int z=playerPosition.getChunkZ() - chunkLoadRadius; z <= playerPosition.getChunkZ() + chunkLoadRadius; z++) {
        TridentChunk chunk=(TridentChunk)playerPosition.getWorld().getChunkAt(x,z);
        client.sendPacket(new PlayOutChunk(chunk));
      }
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    int i=0;
    for (    String word : ""String_Node_Str"".split(""String_Node_Str"")) {
      BossBar bb=BossBar.newBossBar();
      bb.setTitle(ChatComponent.text(word).setColor(ChatColor.of((char)('a' + i))));
      bb.setColor(BossBarColor.values()[i]);
      bb.setDivision(BossBarDivision.values()[i++]);
      bb.setHealth(i * .25f);
      bb.setDarkenSky(false);
      bb.setDragonBar(false);
      player.addBossBar(bb);
    }
  }
 else   if (mode.equals(""String_Node_Str"")) {
    Title title=Title.newTitle();
    title.setHeader(ChatComponent.create().setColor(ChatColor.AQUA).setText(""String_Node_Str""));
    title.setSubtitle(ChatComponent.create().setColor(ChatColor.GOLD).setText(""String_Node_Str""));
    title.setFadeIn(0);
    title.setStay(600);
    title.setFadeOut(0);
    player.sendTitle(title);
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.resetTitle();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.sendMessage(ChatComponent.create().setText(""String_Node_Str"").setHoverEvent(HoverEvent.item(Item.newItem(Substance.STONE,30,(byte)1))));
  }
 else   if (mode.equals(""String_Node_Str"")) {
    player.getWorld().getWeather().beginRaining();
    player.getWorld().getWeather().beginThunder();
  }
 else   if (mode.equals(""String_Node_Str"")) {
    PlayOutTabListItem.RemovePlayer removePlayer=PlayOutTabListItem.removePlayerPacket();
    removePlayer.removePlayer(player.getUuid());
    PlayOutTabListItem.AddPlayer addPlayer=PlayOutTabListItem.addPlayerPacket();
    addPlayer.addPlayer(player.getUuid(),""String_Node_Str"",player.getGameMode(),0,player.getDisplayName(),Collections.singletonList(player.getSkinTextures()));
    RecipientSelector.whoCanSee(player,false,new PlayOutDestroyEntities(Collections.singletonList(player)),addPlayer);
    RecipientSelector.whoCanSee(player,true,player.getSpawnPacket());
  }
}"
11653,"@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @PermissionRequired(""String_Node_Str"") public void kick(CommandSource source,String[] args,@PlayerExactMatch Player player,String... reason){
  if (player != null) {
    String reasonString=reason.length == 0 ? ""String_Node_Str"" : String.join(""String_Node_Str"",reason);
    player.kick(ChatComponent.text(reasonString));
    TridentServer.getInstance().getLogger().log(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ reasonString);
  }
 else {
    source.sendMessage(ChatComponent.text(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
}","@Command(name=""String_Node_Str"",help=""String_Node_Str"",desc=""String_Node_Str"") @PermissionRequired(""String_Node_Str"") public void kick(CommandSource source,String[] args,Player player,String... reason){
  if (player != null) {
    String reasonString=reason.length == 0 ? ""String_Node_Str"" : String.join(""String_Node_Str"",reason);
    player.kick(ChatComponent.text(reasonString));
    TridentServer.getInstance().getLogger().log(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ reasonString);
  }
 else {
    source.sendMessage(ChatComponent.text(""String_Node_Str"" + args[1] + ""String_Node_Str""));
  }
}"
11654,"/** 
 * Creates a new netclient that represents a client's connection to the server.
 * @param ctx the context
 */
public NetClient(ChannelHandlerContext ctx){
  this.channel=ctx.channel();
  this.state=NetClient.NetState.HANDSHAKE;
  this.channel.closeFuture().addListener(future -> new GenericFutureListener<Future<Void>>(){
    @Override public void operationComplete(    Future<Void> f) throws Exception {
      f.removeListener(this);
      NetClient.this.disconnect(""String_Node_Str"");
    }
  }
);
}","/** 
 * Creates a new netclient that represents a client's connection to the server.
 * @param ctx the context
 */
public NetClient(ChannelHandlerContext ctx){
  this.channel=ctx.channel();
  this.state=NetClient.NetState.HANDSHAKE;
  this.channel.closeFuture().addListener(new ChannelFutureListener(){
    @Override public void operationComplete(    ChannelFuture channelFuture) throws Exception {
      channelFuture.removeListener(this);
      NetClient.this.disconnect(""String_Node_Str"");
    }
  }
);
}"
11655,"@Override public void operationComplete(Future<Void> f) throws Exception {
  f.removeListener(this);
  NetClient.this.disconnect(""String_Node_Str"");
}","@Override public void operationComplete(ChannelFuture channelFuture) throws Exception {
  channelFuture.removeListener(this);
  NetClient.this.disconnect(""String_Node_Str"");
}"
11656,"/** 
 * Resumes the joining process after the player has confirmed the client spawn position.
 */
public void resumeLogin(){
  if (!this.finishedLogin.compareAndSet(false,true)) {
    return;
  }
  TridentWorld world=this.getWorld();
  this.client.sendPacket(new PlayOutJoinGame(this,world));
  this.client.sendPacket(PlayOutPluginMsg.BRAND);
  TridentPluginChannel.autoAdd(this);
  this.client.sendPacket(new PlayOutDifficulty(world));
  this.client.sendPacket(new PlayOutSpawnPos());
  this.client.sendPacket(new PlayOutPlayerAbilities(this));
  this.inventory.update();
  this.client.sendPacket(new PlayOutPosLook(this));
  this.client.sendPacket(new PlayOutTime(world.getAge().longValue(),world.getTime()));
  if (world.getWeather().isRaining()) {
    this.client.sendPacket(new PlayOutGameState(2,0));
  }
  this.setTabList(TridentGlobalTabList.getInstance());
  TridentGlobalTabList.getInstance().update();
  Collections.addAll(this.permissions,""String_Node_Str"");
  if (TridentServer.getInstance().getOpsList().getOps().contains(this.uuid)) {
    this.op=true;
  }
  if (Debug.IS_DEBUGGING) {
    this.permissions.add(""String_Node_Str"");
  }
  RecipientSelector.whoCanSee(this,true,new PlayOutSpawnPlayer(this));
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).execute(() -> {
    ChatComponent chat=ChatComponent.create().setColor(ChatColor.YELLOW).setTranslate(""String_Node_Str"").addWith(this.name);
    PlayerJoinEvent event=new PlayerJoinEvent(this,chat);
    TridentServer.getInstance().getEventController().dispatch(event);
    ChatComponent message=event.getMessage();
    if (message != null)     TridentServer.getInstance().getPlayers().forEach(p -> p.sendMessage(message,ChatType.CHAT));
  }
);
  TridentServer.getInstance().getLogger().log(""String_Node_Str"" + this.name + ""String_Node_Str""+ this.uuid+ ""String_Node_Str"");
}","/** 
 * Resumes the joining process after the player has confirmed the client spawn position.
 */
public void resumeLogin(){
  if (!this.finishedLogin.compareAndSet(false,true)) {
    return;
  }
  TridentWorld world=this.getWorld();
  this.client.sendPacket(new PlayOutJoinGame(this,world));
  this.client.sendPacket(PlayOutPluginMsg.BRAND);
  TridentPluginChannel.autoAdd(this);
  this.client.sendPacket(new PlayOutDifficulty(world));
  this.client.sendPacket(new PlayOutSpawnPos());
  this.client.sendPacket(new PlayOutPlayerAbilities(this));
  this.inventory.update();
  this.client.sendPacket(new PlayOutPosLook(this));
  this.client.sendPacket(new PlayOutTime(world.getAge().longValue(),world.getTime()));
  if (world.getWeather().isRaining()) {
    this.client.sendPacket(new PlayOutGameState(2,0));
  }
  this.setTabList(TridentGlobalTabList.getInstance());
  TridentGlobalTabList.getInstance().update();
  Collections.addAll(this.permissions,""String_Node_Str"");
  if (TridentServer.getInstance().getOpsList().getOps().contains(this.uuid)) {
    this.op=true;
  }
  if (Debug.IS_DEBUGGING) {
    this.permissions.add(""String_Node_Str"");
  }
  RecipientSelector.whoCanSee(this,true,new PlayOutSpawnPlayer(this));
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).execute(() -> {
    ChatComponent chat=ChatComponent.create().setColor(ChatColor.YELLOW).setTranslate(""String_Node_Str"").addWith(this.name);
    PlayerJoinEvent event=new PlayerJoinEvent(this,chat);
    TridentServer.getInstance().getEventController().dispatch(event);
    ChatComponent message=event.getMessage();
    if (message != null)     players.values().forEach(p -> p.sendMessage(message,ChatType.CHAT));
  }
);
  TridentServer.getInstance().getLogger().log(""String_Node_Str"" + this.name + ""String_Node_Str""+ this.uuid+ ""String_Node_Str"");
}"
11657,"@Override public void doRemove(){
  if (TridentPlayer.players.remove(this.uuid) == null) {
    Login.finish();
  }
  TridentPluginChannel.autoRemove(this);
  playerNames.remove(this.name);
  this.setTabList(null);
  TridentGlobalTabList.getInstance().update();
  TridentInventory.clean();
  for (  TridentChunk chunk : this.heldChunks.values()) {
    chunk.getHolders().remove(this);
  }
  this.heldChunks.clear();
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).execute(() -> {
    ChatComponent chat=ChatComponent.create().setColor(ChatColor.YELLOW).setTranslate(""String_Node_Str"").addWith(this.name);
    PlayerQuitEvent event=new PlayerQuitEvent(this,chat);
    TridentServer.getInstance().getEventController().dispatch(event);
    ChatComponent message=event.getMessage();
    if (message != null)     TridentServer.getInstance().getPlayers().forEach(p -> p.sendMessage(message,ChatType.CHAT));
  }
);
  this.client.disconnect(ChatComponent.empty());
}","@Override public void doRemove(){
  if (TridentPlayer.players.remove(this.uuid) == null) {
    Login.finish();
  }
  TridentPluginChannel.autoRemove(this);
  playerNames.remove(this.name);
  this.setTabList(null);
  TridentGlobalTabList.getInstance().update();
  TridentInventory.clean();
  for (  TridentChunk chunk : this.heldChunks.values()) {
    chunk.getHolders().remove(this);
  }
  this.heldChunks.clear();
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).execute(() -> {
    ChatComponent chat=ChatComponent.create().setColor(ChatColor.YELLOW).setTranslate(""String_Node_Str"").addWith(this.name);
    PlayerQuitEvent event=new PlayerQuitEvent(this,chat);
    TridentServer.getInstance().getEventController().dispatch(event);
    ChatComponent message=event.getMessage();
    if (message != null)     players.values().forEach(p -> p.sendMessage(message,ChatType.CHAT));
  }
);
  this.client.disconnect(ChatComponent.empty());
}"
11658,"@Override public ChatComponent getElement(int slot){
  return null;
}","@Override public ChatComponent getElement(int slot){
  throw new RuntimeException(""String_Node_Str"");
}"
11659,"@Override @Policy(""String_Node_Str"") public void shutdown(){
  Debug.tryCheckThread();
  this.logger.warn(""String_Node_Str"");
  this.shutdownState=true;
  try {
    this.logger.log(""String_Node_Str"");
    TridentPlayer.getPlayers().values().forEach(p -> p.kick(ChatComponent.text(""String_Node_Str"")));
    this.logger.log(""String_Node_Str"");
    if (!this.pluginLoader.unloadAll()) {
      this.logger.error(""String_Node_Str"");
    }
    for (    World world : TridentWorldLoader.getInstance().getWorlds().values()) {
      this.logger.log(""String_Node_Str"" + world.getName() + ""String_Node_Str"");
      world.save();
    }
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.logger.log(""String_Node_Str"");
    this.tick.interrupt();
    ServerThreadPool.shutdownAll();
    this.logger.log(""String_Node_Str"");
    this.server.shutdown();
  }
 catch (  IOException|InterruptedException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
  System.exit(0);
}","@Override @Policy(""String_Node_Str"") public void shutdown(){
  Debug.tryCheckThread();
  this.logger.warn(""String_Node_Str"");
  this.shutdownState=true;
  try {
    this.logger.log(""String_Node_Str"");
    TridentPlayer.getPlayers().values().forEach(p -> p.kick(ChatComponent.text(""String_Node_Str"")));
    this.tick.interrupt();
    this.logger.log(""String_Node_Str"");
    if (!this.pluginLoader.unloadAll()) {
      this.logger.error(""String_Node_Str"");
    }
    for (    World world : TridentWorldLoader.getInstance().getWorlds().values()) {
      this.logger.log(""String_Node_Str"" + world.getName() + ""String_Node_Str"");
      world.save();
    }
    this.logger.log(""String_Node_Str"");
    this.config.save();
    this.logger.log(""String_Node_Str"");
    ServerThreadPool.shutdownAll();
    this.logger.log(""String_Node_Str"");
    this.server.shutdown();
  }
 catch (  IOException|InterruptedException e) {
    JiraExceptionCatcher.serverException(e);
    return;
  }
  this.logger.success(""String_Node_Str"");
  System.exit(0);
}"
11660,"/** 
 * Entity superconstructor.
 * @param world the world which the entity is located
 */
public TridentEntity(World world,PoolSpec spec){
  this.id=EID_COUNTER.incrementAndGet();
  this.position=new Position(world);
  this.pool=ServerThreadPool.forSpec(spec);
  EntityMetaType metaType=this.getClass().getAnnotation(EntityMetaType.class);
  if (metaType == null) {
    throw new RuntimeException(this.getClass() + ""String_Node_Str"");
  }
  try {
    this.metadata=metaType.value().getConstructor(EntityMetadata.class).newInstance(new EntityMetadata());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entity superconstructor.
 * @param world the world which the entity is located
 */
public TridentEntity(World world,PoolSpec spec){
  this.id=EID_COUNTER.incrementAndGet();
  this.position=world.getWorldOptions().getSpawn().toPosition(world);
  this.pool=ServerThreadPool.forSpec(spec);
  EntityMetaType metaType=this.getClass().getAnnotation(EntityMetaType.class);
  if (metaType == null) {
    throw new RuntimeException(this.getClass() + ""String_Node_Str"");
  }
  try {
    this.metadata=metaType.value().getConstructor(EntityMetadata.class).newInstance(new EntityMetadata());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
11661,"/** 
 * Spawns a new player.
 * @param client the client representing the player
 * @param name the player name
 * @param uuid the player UUID
 * @param skinTextures the player textures
 */
public static TridentPlayer spawn(NetClient client,String name,UUID uuid,TabListElement.PlayerProperty skinTextures){
  TridentWorld world=TridentServer.getInstance().getWorldLoader().getDefaultWorld();
  TridentPlayer player=new TridentPlayer(client,world,name,uuid,skinTextures);
  client.setPlayer(player);
  TridentPlayer.players.put(uuid,player);
  Login.finish();
  TridentPlayer.playerNames.put(name,player);
  player.position=world.getWorldOptions().getSpawn().toPosition(world);
  player.updateChunks();
  player.resumeLogin();
  return player;
}","/** 
 * Spawns a new player.
 * @param client the client representing the player
 * @param name the player name
 * @param uuid the player UUID
 * @param skinTextures the player textures
 */
public static TridentPlayer spawn(NetClient client,String name,UUID uuid,TabListElement.PlayerProperty skinTextures){
  TridentWorld world=TridentServer.getInstance().getWorldLoader().getDefaultWorld();
  TridentPlayer player=new TridentPlayer(client,world,name,uuid,skinTextures);
  client.setPlayer(player);
  TridentPlayer.players.put(uuid,player);
  Login.finish();
  TridentPlayer.playerNames.put(name,player);
  player.updateChunks();
  player.resumeLogin();
  return player;
}"
11662,"/** 
 * Send an update to the client with the chunks If direction is null, chunks around the player will be sent
 */
public void updateChunks(){
  TridentWorld world=(TridentWorld)this.getPosition().getWorld();
  int centerX=this.getPosition().getChunkX();
  int centerZ=this.getPosition().getChunkZ();
  int radius=this.renderDistance;
  this.pool.execute(() -> {
    for (int x=centerX - radius; x < centerX + radius; x++) {
      for (int z=centerZ - radius; z < centerZ + radius; z++) {
        TridentChunk chunk=world.getChunkAt(x,z);
        if (!this.heldChunks.contains(chunk)) {
          this.heldChunks.add(chunk);
          chunk.getHolders().add(this);
          this.net().sendPacket(new PlayOutChunk(chunk));
          chunk.getEntities().forEach(e -> this.net().sendPacket(((TridentEntity)e).getSpawnPacket()));
        }
      }
    }
  }
);
  this.pool.execute(() -> {
    for (    TridentChunk chunk : this.heldChunks) {
      if (Math.abs(chunk.getX() - centerX) > radius || Math.abs(chunk.getZ() - centerZ) > radius) {
        this.heldChunks.remove(chunk);
        chunk.getHolders().remove(this);
        this.net().sendPacket(new PlayOutUnloadChunk(chunk.getX(),chunk.getZ()));
        if (!chunk.getEntitySet().isEmpty() || !chunk.getOccupants().isEmpty()) {
          this.net().sendPacket(new PlayOutDestroyEntities(chunk.getEntities().collect(Collectors.toList())));
        }
      }
    }
  }
);
}","/** 
 * Send an update to the client with the chunks If direction is null, chunks around the player will be sent
 */
public void updateChunks(){
  TridentWorld world=(TridentWorld)this.getPosition().getWorld();
  int centerX=this.getPosition().getChunkX();
  int centerZ=this.getPosition().getChunkZ();
  int radius=this.renderDistance;
  this.pool.execute(() -> {
    for (int x=centerX - radius; x < centerX + radius; x++) {
      for (int z=centerZ - radius; z < centerZ + radius; z++) {
        TridentChunk chunk=world.getChunkAt(x,z);
        if (!this.heldChunks.contains(chunk)) {
          this.heldChunks.add(chunk);
          chunk.getEntities().forEach(e -> this.net().sendPacket(((TridentEntity)e).getSpawnPacket()));
          chunk.getHolders().add(this);
          this.net().sendPacket(new PlayOutChunk(chunk));
        }
      }
    }
  }
);
  this.pool.execute(() -> {
    for (    TridentChunk chunk : this.heldChunks) {
      if (Math.abs(chunk.getX() - centerX) > radius || Math.abs(chunk.getZ() - centerZ) > radius) {
        this.heldChunks.remove(chunk);
        chunk.getHolders().remove(this);
        this.net().sendPacket(new PlayOutUnloadChunk(chunk.getX(),chunk.getZ()));
        if (!chunk.getEntitySet().isEmpty() || !chunk.getOccupants().isEmpty()) {
          this.net().sendPacket(new PlayOutDestroyEntities(chunk.getEntities().collect(Collectors.toList())));
        }
        chunk.checkValidForGc();
      }
    }
  }
);
}"
11663,"@Override public Iterator<TridentChunk> iterator(){
  return this.values().iterator();
}","@Nonnull @Override public Iterator<TridentChunk> iterator(){
  return this.values().iterator();
}"
11664,"/** 
 * Obtains the chunk at the given location and determines whether a chunk will be generated if it does not exist yet.
 * @param x the x coordinate
 * @param z the z coordinate
 * @param gen {@code true} to generate if non-existant
 * @return the chunk, or {@code null}
 */
public TridentChunk get(int x,int z,boolean gen){
  long key=(long)x << 32 | z & 0xFFFFFFFFL;
synchronized (this.lock) {
    TridentChunk chunk=this.chunks.get(key);
    if (chunk == null && gen) {
      chunk=new TridentChunk(this.world,x,z);
      chunk.generate();
      this.chunks.put(key,chunk);
    }
    return chunk;
  }
}","/** 
 * Obtains the chunk at the given location and determines whether a chunk will be generated if it does not exist yet.
 * @param x the x coordinate
 * @param z the z coordinate
 * @param gen {@code true} to generate if non-existant
 * @return the chunk, or {@code null}
 */
public TridentChunk get(int x,int z,boolean gen){
  long key=(long)x << 32 | z & 0xFFFFFFFFL;
  boolean doGenerate=false;
  TridentChunk chunk;
synchronized (this.lock) {
    chunk=this.chunks.get(key);
    if ((chunk == null || !chunk.canUse()) && gen) {
      chunk=new TridentChunk(this.world,x,z);
      this.chunks.put(key,chunk);
      doGenerate=true;
    }
  }
  if (doGenerate) {
    chunk.generate();
  }
  if (chunk != null) {
    return chunk.waitReady();
  }
 else {
    return null;
  }
}"
11665,"/** 
 * Reads the chunk data from the region file compound.
 * @param compound the compound to read
 */
public void read(Tag.Compound compound){
  this.inhabited.add(compound.getLong(""String_Node_Str""));
  Tag.List<Tag.Compound> sectionList=compound.getList(""String_Node_Str"");
  for (  Tag.Compound c : sectionList) {
    ChunkSection section=new ChunkSection(this.world.getWorldOptions().getDimension() == Dimension.OVERWORLD);
    section.read(c);
    byte y=c.getByte(""String_Node_Str"");
    this.sections.set(y,section);
  }
  int[] heightMap=compound.getIntArray(""String_Node_Str"");
  for (int i=0; i < heightMap.length; i++) {
    this.heights.set(i,heightMap[i]);
  }
  if (compound.getByte(""String_Node_Str"") == 1) {
    this.ready.countDown();
  }
}","/** 
 * Reads the chunk data from the region file compound.
 * @param compound the compound to read
 */
public void read(Tag.Compound compound){
  this.inhabited.add(compound.getLong(""String_Node_Str""));
  Tag.List<Tag.Compound> sectionList=compound.getList(""String_Node_Str"");
  for (  Tag.Compound c : sectionList) {
    ChunkSection section=new ChunkSection(this.world.getWorldOptions().getDimension() == Dimension.OVERWORLD);
    section.read(c);
    byte y=c.getByte(""String_Node_Str"");
    this.sections.set(y,section);
  }
  int[] heightMap=compound.getIntArray(""String_Node_Str"");
  for (int i=0; i < heightMap.length; i++) {
    this.heights.set(i,heightMap[i]);
  }
  if (compound.getByte(""String_Node_Str"") == 1) {
    this.generationInProgress.set(true);
    this.ready.countDown();
  }
}"
11666,"/** 
 * Ticks the chunk, updating the inhabited time, tile entities, stateful blocks, and entities.
 */
public void tick(){
  this.inhabited.add(this.occupants.size());
}","/** 
 * Ticks the chunk, updating the inhabited time, tile entities, stateful blocks, and entities.
 */
public void tick(){
  ARBITRARY_POOL.execute(() -> {
    this.inhabited.add(this.occupants.size());
    if (this.world.getTime() == 0) {
      this.checkValidForGc();
    }
  }
);
}"
11667,"/** 
 * Generates the chunk.
 */
public void generate(){
  if (this.ready.getCount() == 0) {
    return;
  }
  Region region=Region.getFile(this,false);
  if (region == null) {
    this.runGenerator();
  }
 else {
    int rX=this.x & 31;
    int rZ=this.z & 31;
    if (region.hasChunk(rX,rZ)) {
      try (DataInputStream in=region.getChunkDataInputStream(rX,rZ)){
        Tag.Compound compound=Tag.decode(in).getCompound(""String_Node_Str"");
        CompletableFuture.runAsync(() -> this.read(compound),ARBITRARY_POOL).whenCompleteAsync((v,t) -> {
          if (this.ready.getCount() == 1) {
            this.runGenerator();
          }
        }
,ARBITRARY_POOL);
        this.waitReady();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
 else {
      this.runGenerator();
    }
  }
}","/** 
 * Generates the chunk.
 */
public void generate(){
  if (!this.generationInProgress.compareAndSet(false,true)) {
    return;
  }
  Region region=Region.getFile(this,false);
  if (region == null) {
    this.runGenerator();
  }
 else {
    int rX=this.x & 31;
    int rZ=this.z & 31;
    if (region.hasChunk(rX,rZ)) {
      try (DataInputStream in=region.getChunkDataInputStream(rX,rZ)){
        Tag.Compound compound=Tag.decode(in).getCompound(""String_Node_Str"");
        CompletableFuture.runAsync(() -> this.read(compound),ARBITRARY_POOL).whenCompleteAsync((v,t) -> {
          if (this.ready.getCount() == 1) {
            this.runGenerator();
          }
        }
,ARBITRARY_POOL);
        this.waitReady();
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
 else {
      this.runGenerator();
    }
  }
}"
11668,"private void doTick(){
  int curTime;
  int newTime;
  do {
    curTime=this.time.get();
    newTime=curTime++;
    if (newTime == 24000) {
      newTime=0;
    }
  }
 while (!this.time.compareAndSet(curTime,newTime));
  this.chunks.forEach(TridentChunk::tick);
}","private void doTick(){
  int curTime;
  int newTime;
  do {
    curTime=this.time.get();
    newTime=curTime + 1;
    if (newTime == 24000) {
      newTime=0;
    }
  }
 while (!this.time.compareAndSet(curTime,newTime));
  this.chunks.forEach(TridentChunk::tick);
}"
11669,"@Override public void write(ByteBuf buf){
  buf.writeInt(this.player.getId());
  buf.writeByte(this.opts.getGameMode().asByte());
  buf.writeInt(this.opts.getDimension().asByte());
  buf.writeByte(this.opts.getDifficulty().asByte());
  buf.writeByte(0);
  wstr(buf,this.type.toString());
  buf.writeBoolean(false);
}","@Override public void write(ByteBuf buf){
  buf.writeInt(this.player.getId());
  buf.writeByte(this.opts.getGameMode().asByte());
  buf.writeInt(this.opts.getDimension().asByte());
  buf.writeByte(this.opts.getDifficulty().asByte());
  buf.writeByte(0);
  wstr(buf,this.type.toString());
  buf.writeBoolean(this.opts.getGameRules().get(GameRule.REDUCE_DEBUG));
}"
11670,"/** 
 * Resumes the joining process after the player has confirmed the client spawn position.
 */
public void resumeLogin(){
  if (!this.finishedLogin.compareAndSet(false,true)) {
    return;
  }
  this.client.sendPacket(new PlayOutJoinGame(this,this.getWorld()));
  this.client.sendPacket(PlayOutPluginMsg.BRAND);
  TridentPluginChannel.autoAdd(this);
  this.client.sendPacket(new PlayOutDifficulty(this.getWorld()));
  this.client.sendPacket(new PlayOutSpawnPos());
  this.client.sendPacket(new PlayOutPosLook(this));
  this.client.sendPacket(new PlayOutPlayerAbilities(this));
  this.setTabList(TridentGlobalTabList.getInstance());
  TridentGlobalTabList.getInstance().update();
  Collections.addAll(this.permissions,""String_Node_Str"");
  if (TridentServer.getInstance().getOpsList().getOps().contains(this.uuid)) {
    this.op=true;
  }
  PlayOutSpawnPlayer spawnThis=new PlayOutSpawnPlayer(this);
  ChatComponent chat=ChatComponent.create().setColor(ChatColor.YELLOW).setTranslate(""String_Node_Str"").addWith(this.name);
  TridentPlayer.players.values().stream().filter(p -> !p.equals(this)).forEach(p -> {
    p.sendMessage(chat,ChatType.CHAT);
    p.net().sendPacket(spawnThis);
    PlayOutSpawnPlayer oldPlayerPacket=new PlayOutSpawnPlayer(p);
    this.client.sendPacket(oldPlayerPacket);
  }
);
  TridentServer.getInstance().getLogger().log(""String_Node_Str"" + this.name + ""String_Node_Str""+ this.uuid+ ""String_Node_Str"");
}","/** 
 * Resumes the joining process after the player has confirmed the client spawn position.
 */
public void resumeLogin(){
  if (!this.finishedLogin.compareAndSet(false,true)) {
    return;
  }
  this.client.sendPacket(new PlayOutJoinGame(this,this.getWorld()));
  this.client.sendPacket(PlayOutPluginMsg.BRAND);
  TridentPluginChannel.autoAdd(this);
  this.client.sendPacket(new PlayOutDifficulty(this.getWorld()));
  this.client.sendPacket(new PlayOutSpawnPos());
  this.client.sendPacket(new PlayOutPosLook(this));
  this.client.sendPacket(new PlayOutPlayerAbilities(this));
  this.setTabList(TridentGlobalTabList.getInstance());
  TridentGlobalTabList.getInstance().update();
  Collections.addAll(this.permissions,""String_Node_Str"");
  if (TridentServer.getInstance().getOpsList().getOps().contains(this.uuid)) {
    this.op=true;
  }
  PlayOutSpawnPlayer spawnThis=new PlayOutSpawnPlayer(this);
  ChatComponent chat=ChatComponent.create().setColor(ChatColor.YELLOW).setTranslate(""String_Node_Str"").addWith(this.name);
  TridentPlayer.players.values().stream().filter(p -> !p.equals(this)).forEach(p -> {
    p.sendMessage(chat,ChatType.CHAT);
    p.net().sendPacket(spawnThis);
    PlayOutSpawnPlayer oldPlayerPacket=new PlayOutSpawnPlayer(p);
    this.client.sendPacket(oldPlayerPacket);
  }
);
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).execute(() -> TridentServer.getInstance().getEventController().dispatch(new PlayerJoinEvent(this)));
  TridentServer.getInstance().getLogger().log(""String_Node_Str"" + this.name + ""String_Node_Str""+ this.uuid+ ""String_Node_Str"");
}"
11671,"/** 
 * Spawns a new player.
 * @param client the client representing the player
 * @param name the player name
 * @param uuid the player UUID
 * @param skinTextures the player textures
 */
public static TridentPlayer spawn(NetClient client,String name,UUID uuid,TabListElement.PlayerProperty skinTextures){
  TridentWorld world=TridentServer.getInstance().getWorldLoader().getDefaultWorld();
  TridentPlayer player=new TridentPlayer(client,world,name,uuid,skinTextures);
  client.setPlayer(player);
  TridentPlayer.players.put(uuid,player);
  Login.finish();
  TridentPlayer.playerNames.put(name,player);
  ServerThreadPool.forSpec(PoolSpec.PLUGINS).execute(() -> TridentServer.getInstance().getEventController().dispatch(new PlayerJoinEvent(player)));
  player.setPosition(world.getWorldOptions().getSpawn().toPosition(world));
  player.updateChunks();
  player.resumeLogin();
  return player;
}","/** 
 * Spawns a new player.
 * @param client the client representing the player
 * @param name the player name
 * @param uuid the player UUID
 * @param skinTextures the player textures
 */
public static TridentPlayer spawn(NetClient client,String name,UUID uuid,TabListElement.PlayerProperty skinTextures){
  TridentWorld world=TridentServer.getInstance().getWorldLoader().getDefaultWorld();
  TridentPlayer player=new TridentPlayer(client,world,name,uuid,skinTextures);
  client.setPlayer(player);
  TridentPlayer.players.put(uuid,player);
  Login.finish();
  TridentPlayer.playerNames.put(name,player);
  player.position=world.getWorldOptions().getSpawn().toPosition(world);
  player.updateChunks();
  player.resumeLogin();
  return player;
}"
11672,"/** 
 * Updates the usability state field in order to check if this chunk may still be used or is reclaimable.
 */
public void checkValidForGc(){
  this.useState.set(TRANSITION);
  if (this.holders.isEmpty()) {
    this.useState.set(UNUSABLE);
    if (this.world.removeChunkAt(this.x,this.z) != null) {
      Region region=Region.getFile(this,true);
      int rX=this.x & 31;
      int rZ=this.z & 31;
      if (region.hasChunk(rX,rZ)) {
        try (DataInputStream in=region.getChunkDataInputStream(rX,rZ)){
          Tag.Compound root=Tag.decode(in);
          Tag.Compound compound=root.getCompound(""String_Node_Str"");
          CompletableFuture.runAsync(() -> this.write(compound),ARBITRARY_POOL).whenCompleteAsync((v,t) -> {
            try (DataOutputStream out=region.getChunkDataOutputStream(rX,rZ)){
              root.write(out);
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
,ARBITRARY_POOL);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
 else {
        ARBITRARY_POOL.execute(() -> {
          Tag.Compound root=new Tag.Compound(""String_Node_Str"");
          Tag.Compound level=new Tag.Compound(""String_Node_Str"");
          root.putCompound(level);
          this.write(level);
          try (DataOutputStream out=region.getChunkDataOutputStream(rX,rZ)){
            root.write(out);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
);
      }
    }
  }
 else {
    this.useState.set(USABLE);
  }
}","/** 
 * Updates the usability state field in order to check if this chunk may still be used or is reclaimable.
 */
public void checkValidForGc(){
  this.useState.set(TRANSITION);
  int centerX=this.world.getWorldOptions().getSpawn().getIntX() >> 4;
  int centerZ=this.world.getWorldOptions().getSpawn().getIntZ() >> 4;
  if (this.holders.isEmpty() && (Math.abs(centerX - this.x) > 3 || Math.abs(centerZ - this.z) > 3)) {
    this.useState.set(UNUSABLE);
    if (this.world.removeChunkAt(this.x,this.z) != null) {
      Region region=Region.getFile(this,true);
      int rX=this.x & 31;
      int rZ=this.z & 31;
      if (region.hasChunk(rX,rZ)) {
        try (DataInputStream in=region.getChunkDataInputStream(rX,rZ)){
          Tag.Compound root=Tag.decode(in);
          Tag.Compound compound=root.getCompound(""String_Node_Str"");
          CompletableFuture.runAsync(() -> this.write(compound),ARBITRARY_POOL).whenCompleteAsync((v,t) -> {
            try (DataOutputStream out=region.getChunkDataOutputStream(rX,rZ)){
              root.write(out);
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
,ARBITRARY_POOL);
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
 else {
        ARBITRARY_POOL.execute(() -> {
          Tag.Compound root=new Tag.Compound(""String_Node_Str"");
          Tag.Compound level=new Tag.Compound(""String_Node_Str"");
          root.putCompound(level);
          this.write(level);
          try (DataOutputStream out=region.getChunkDataOutputStream(rX,rZ)){
            root.write(out);
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
);
      }
    }
  }
 else {
    this.useState.set(USABLE);
  }
}"
11673,"/** 
 * Loads a new world with the given name and folder.
 * @param name the name of the world
 * @param enclosing the enclosing folder
 */
public TridentWorld(String name,Path enclosing){
  this.name=name;
  this.directory=enclosing;
  try (GZIPInputStream stream=new GZIPInputStream(new FileInputStream(this.directory.resolve(""String_Node_Str"").toFile()))){
    Tag.Compound root=Tag.decode(new DataInputStream(stream));
    Tag.Compound compound=root.getCompound(""String_Node_Str"");
    this.worldOptions=new WorldOptImpl(this,compound);
    this.generatorOptions=new GenOptImpl(compound);
    this.weather.read(compound);
    this.border.read(compound);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Loads a new world with the given name and folder.
 * @param name the name of the world
 * @param enclosing the enclosing folder
 */
public TridentWorld(String name,Path enclosing){
  this.name=name;
  this.directory=enclosing;
  try (GZIPInputStream stream=new GZIPInputStream(new FileInputStream(this.directory.resolve(""String_Node_Str"").toFile()))){
    Tag.Compound root=Tag.decode(new DataInputStream(stream));
    Tag.Compound compound=root.getCompound(""String_Node_Str"");
    this.worldOptions=new WorldOptImpl(this,compound);
    this.generatorOptions=new GenOptImpl(compound);
    this.weather.read(compound);
    this.border.read(compound);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  int centerX=this.worldOptions.getSpawn().getIntX() >> 4;
  int centerZ=this.worldOptions.getSpawn().getIntZ() >> 4;
  int radius=3;
  for (int x=centerX - radius; x < centerX + radius; x++) {
    for (int z=centerZ - radius; z < centerZ + radius; z++) {
      this.getChunkAt(x,z);
    }
  }
}"
11674,"/** 
 * Creates a new set of world options which implements those found in the compound file for this world.
 * @param world the world to create options for
 * @param compound the compound to read data from
 */
public WorldOptImpl(TridentWorld world,Tag.Compound compound){
  this.world=world;
  this.dimension=Dimension.OVERWORLD;
}","/** 
 * Creates a new set of world options which implements those found in the compound file for this world.
 * @param world the world to create options for
 * @param compound the compound to read data from
 */
@Debug(""String_Node_Str"") public WorldOptImpl(TridentWorld world,Tag.Compound compound){
  this.world=world;
  this.dimension=Dimension.OVERWORLD;
  this.gameMode=GameMode.CREATIVE;
  this.difficulty.set(Difficulty.from(compound.getByte(""String_Node_Str"")),compound.getByte(""String_Node_Str"") == 1);
  this.spawn=new Vector(compound.getInt(""String_Node_Str""),compound.getInt(""String_Node_Str""),compound.getInt(""String_Node_Str""));
  Tag.Compound rulesCmp=compound.getCompound(""String_Node_Str"");
  for (  String s : rulesCmp.getEntries().keySet()) {
    GameRule<Object> rule=GameRule.from(s);
    this.gameRules.set(rule,rule.parseValue(rulesCmp.getString(s)));
  }
}"
11675,"@Override public void updateMetadata(){
  PlayOutEntityMetadata packet=new PlayOutEntityMetadata(this);
  RecipientSelector.whoCanSee(this,packet,false);
}","@Override public void updateMetadata(){
  PlayOutEntityMetadata packet=new PlayOutEntityMetadata(this);
  RecipientSelector.whoCanSee(this,false,packet);
}"
11676,"/** 
 * Entity superconstructor.
 * @param world the world which the entity is located
 */
public TridentEntity(World world,PoolSpec spec){
  this.id=EID_COUNTER.incrementAndGet();
  this.position=world.getWorldOptions().getSpawn().toPosition(world);
  this.pool=ServerThreadPool.forSpec(spec);
  EntityMetaType metaType=this.getClass().getAnnotation(EntityMetaType.class);
  if (metaType == null) {
    throw new RuntimeException(this.getClass() + ""String_Node_Str"");
  }
  try {
    this.metadata=metaType.value().getConstructor(EntityMetadata.class).newInstance(new EntityMetadata());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Entity superconstructor.
 * @param world the world which the entity is located
 */
public TridentEntity(TridentWorld world,PoolSpec spec){
  this.id=EID_COUNTER.incrementAndGet();
  this.pool=ServerThreadPool.forSpec(spec);
  Position pos=world.getWorldOptions().getSpawn().toPosition(world);
  this.position=pos;
  if (this instanceof Player) {
    TridentPlayer player=(TridentPlayer)this;
    world.getOccupants().add(player);
    world.getChunkAt(pos.getChunkX(),pos.getChunkZ()).getOccupants().add(player);
  }
 else {
    world.getEntitySet().add(this);
    world.getEntitySet().add(this);
  }
  EntityMetaType metaType=this.getClass().getAnnotation(EntityMetaType.class);
  if (metaType == null) {
    throw new RuntimeException(this.getClass() + ""String_Node_Str"");
  }
  try {
    this.metadata=metaType.value().getConstructor(EntityMetadata.class).newInstance(new EntityMetadata());
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
11677,"@Override public final void setPosition(Position position){
  Position old=this.position;
  this.position=position;
  TridentWorld fromWorld=(TridentWorld)old.getWorld();
  TridentWorld destWorld=(TridentWorld)position.getWorld();
  if (!destWorld.equals(fromWorld)) {
    if (this instanceof Player) {
      fromWorld.getOccupants().remove(this);
      destWorld.getOccupants().add((TridentPlayer)this);
    }
 else {
      fromWorld.getEntitySet().remove(this);
      destWorld.getEntitySet().add(this);
    }
  }
  int destCX=position.getChunkX();
  int destCZ=position.getChunkZ();
  TridentChunk destChunk=destWorld.getChunkAt(destCX,destCZ,true);
  int fromCX=old.getChunkX();
  int fromCZ=old.getChunkZ();
  if (fromCX != destCX || fromCZ != destCZ) {
    TridentChunk fromChunk=fromWorld.getChunkAt(fromCX,fromCZ,false);
    List<Entity> destroy=Collections.singletonList(this);
    if (this instanceof Player) {
      if (fromChunk == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      TridentPlayer player=(TridentPlayer)this;
      fromChunk.getOccupants().remove(player);
      destChunk.getOccupants().add(player);
      Stream.concat(fromChunk.getHolders().stream(),destChunk.getHolders().stream()).distinct().forEach(p -> {
        if (!fromChunk.getHolders().contains(p)) {
          p.net().sendPacket(new PlayOutSpawnPlayer(player));
        }
        if (!destChunk.getHolders().contains(p)) {
          p.net().sendPacket(new PlayOutDestroyEntities(destroy));
        }
      }
);
      player.updateChunks();
    }
 else {
      if (fromChunk != null) {
        fromChunk.getEntitySet().remove(this);
      }
      destChunk.getEntitySet().add(this);
      Stream.concat(fromChunk.getHolders().stream(),destChunk.getHolders().stream()).distinct().forEach(p -> {
        if (!fromChunk.getHolders().contains(p)) {
          p.net().sendPacket(this.getSpawnPacket());
        }
        if (!destChunk.getHolders().contains(p)) {
          p.net().sendPacket(new PlayOutDestroyEntities(destroy));
        }
      }
);
    }
  }
  Position delta=position.subtract(old);
  if (delta.getX() != 0 || delta.getY() != 0 || delta.getZ() != 0) {
    if (Double.compare(old.getYaw(),position.getYaw()) == 0 && Double.compare(old.getPitch(),position.getPitch()) == 0) {
      PlayOutEntityRelativeMove packet=new PlayOutEntityRelativeMove(this,delta);
      RecipientSelector.whoCanSee(destChunk,packet,this);
    }
 else {
      PlayOutEntityLookAndRelativeMove lookAndRelativeMove=new PlayOutEntityLookAndRelativeMove(this,delta);
      RecipientSelector.whoCanSee(destChunk,lookAndRelativeMove,this);
      PlayOutEntityHeadLook look=new PlayOutEntityHeadLook(this);
      RecipientSelector.whoCanSee(destChunk,look,this);
    }
  }
 else   if (old.getYaw() != position.getYaw() || old.getPitch() != position.getPitch()) {
    PlayOutEntityLookAndRelativeMove lookAndRelativeMove=new PlayOutEntityLookAndRelativeMove(this,delta);
    RecipientSelector.whoCanSee(destChunk,lookAndRelativeMove,this);
    PlayOutEntityHeadLook look=new PlayOutEntityHeadLook(this);
    RecipientSelector.whoCanSee(destChunk,look,this);
  }
}","@Override public final void setPosition(Position position){
  Position old=this.position;
  this.position=position;
  TridentWorld fromWorld=(TridentWorld)old.getWorld();
  TridentWorld destWorld=(TridentWorld)position.getWorld();
  if (!destWorld.equals(fromWorld)) {
    if (this instanceof Player) {
      fromWorld.getOccupants().remove(this);
      destWorld.getOccupants().add((TridentPlayer)this);
    }
 else {
      fromWorld.getEntitySet().remove(this);
      destWorld.getEntitySet().add(this);
    }
  }
  int destCX=position.getChunkX();
  int destCZ=position.getChunkZ();
  TridentChunk destChunk=destWorld.getChunkAt(destCX,destCZ);
  int fromCX=old.getChunkX();
  int fromCZ=old.getChunkZ();
  if (fromCX != destCX || fromCZ != destCZ) {
    TridentChunk fromChunk=fromWorld.getChunkAt(fromCX,fromCZ,false);
    List<Entity> destroy=Collections.singletonList(this);
    PacketOut spawnThis=this.getSpawnPacket();
    if (this instanceof Player) {
      TridentPlayer player=(TridentPlayer)this;
      if (fromChunk != null) {
        fromChunk.getOccupants().remove(player);
      }
      destChunk.getOccupants().add(player);
      Stream.concat(fromChunk == null ? Stream.empty() : fromChunk.getHolders().stream(),destChunk.getHolders().stream()).distinct().forEach(p -> {
        if (fromChunk == null || !fromChunk.getHolders().contains(p)) {
          if (p.equals(this)) {
            return;
          }
          p.net().sendPacket(spawnThis);
        }
        if (!destChunk.getHolders().contains(p)) {
          p.net().sendPacket(new PlayOutDestroyEntities(destroy));
        }
      }
);
      player.updateChunks();
    }
 else {
      if (fromChunk != null) {
        fromChunk.getEntitySet().remove(this);
      }
      destChunk.getEntitySet().add(this);
      Stream.concat(fromChunk == null ? Stream.empty() : fromChunk.getHolders().stream(),destChunk.getHolders().stream()).distinct().forEach(p -> {
        if (fromChunk == null || !fromChunk.getHolders().contains(p)) {
          if (p.equals(this)) {
            return;
          }
          p.net().sendPacket(spawnThis);
        }
        if (!destChunk.getHolders().contains(p)) {
          p.net().sendPacket(new PlayOutDestroyEntities(destroy));
        }
      }
);
    }
  }
  Position delta=position.subtract(old);
  if (delta.getX() != 0 || delta.getY() != 0 || delta.getZ() != 0) {
    if (old.distanceSquared(position) > 16) {
      PlayOutTeleport packet=new PlayOutTeleport(this);
      RecipientSelector.whoCanSee(destChunk,null,packet);
    }
 else {
      if (Double.compare(old.getYaw(),position.getYaw()) == 0 && Double.compare(old.getPitch(),position.getPitch()) == 0) {
        PlayOutEntityRelativeMove packet=new PlayOutEntityRelativeMove(this,delta);
        RecipientSelector.whoCanSee(destChunk,this,packet);
      }
 else {
        PlayOutEntityLookAndRelativeMove lookAndRelativeMove=new PlayOutEntityLookAndRelativeMove(this,delta);
        PlayOutEntityHeadLook look=new PlayOutEntityHeadLook(this);
        RecipientSelector.whoCanSee(destChunk,this,lookAndRelativeMove,look);
      }
    }
  }
 else   if (Float.compare(old.getYaw(),position.getYaw()) != 0 || Float.compare(old.getPitch(),position.getPitch()) != 0) {
    PlayOutEntityLookAndRelativeMove lookAndRelativeMove=new PlayOutEntityLookAndRelativeMove(this,delta);
    PlayOutEntityHeadLook look=new PlayOutEntityHeadLook(this);
    RecipientSelector.whoCanSee(destChunk,this,lookAndRelativeMove,look);
  }
}"
11678,"@Override public final void remove(){
  TridentWorld world=(TridentWorld)this.position.getWorld();
  TridentChunk chunk=world.getChunkAt(this.position.getChunkX(),this.position.getChunkZ(),false);
  if (chunk != null) {
    if (this instanceof Player) {
      chunk.getOccupants().remove(this);
    }
 else {
      chunk.getEntitySet().remove(this);
    }
  }
  if (this instanceof Player) {
    world.getOccupants().remove(this);
  }
 else {
    world.getEntitySet().remove(this);
  }
  this.doRemove();
  PlayOutDestroyEntities destroyEntities=new PlayOutDestroyEntities(Collections.singletonList(this));
  TridentPlayer.getPlayers().values().stream().filter(player -> !player.equals(this)).forEach(p -> p.net().sendPacket(destroyEntities));
}","@Override public final void remove(){
  TridentWorld world=(TridentWorld)this.position.getWorld();
  world.getEntitySet().remove(this);
  world.getOccupants().remove(this);
  TridentChunk chunk=world.getChunkAt(this.position.getChunkX(),this.position.getChunkZ(),false);
  if (chunk != null) {
    if (this instanceof Player) {
      chunk.getOccupants().remove(this);
    }
 else {
      chunk.getEntitySet().remove(this);
    }
  }
  if (this instanceof Player) {
    world.getOccupants().remove(this);
  }
 else {
    world.getEntitySet().remove(this);
  }
  this.doRemove();
  PlayOutDestroyEntities destroyEntities=new PlayOutDestroyEntities(Collections.singletonList(this));
  TridentPlayer.getPlayers().values().stream().filter(player -> !player.equals(this)).forEach(p -> p.net().sendPacket(destroyEntities));
}"
11679,"@Override public Item get(int slot){
  if (slot < 0 || slot >= this.size) {
    throw new IllegalArgumentException(""String_Node_Str"" + slot);
  }
  Item item=this.contents.get(slot);
  return item == null ? TridentItem.EMPTY : item;
}","@Nonnull @Override public Item get(int slot){
  if (slot < 0 || slot >= this.size) {
    throw new IllegalArgumentException(""String_Node_Str"" + slot);
  }
  Item item=this.contents.get(slot);
  return item == null ? TridentItem.EMPTY : item;
}"
11680,"@Nullable @Override public Item remove(int slot,int quantity){
  if (quantity < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (slot < 0 || slot >= this.size) {
    throw new IllegalArgumentException(""String_Node_Str"" + slot);
  }
  Item computed=this.contents.compute(slot,(k,v) -> {
    if (v == null) {
      return null;
    }
 else {
      int left=Math.max(0,v.getCount() - quantity);
      if (left == 0) {
        this.sendViewers(new PlayOutSlot(this.id,slot,Slot.EMPTY));
        return null;
      }
 else {
        TridentItem item=new TridentItem(v.getSubstance(),left,v.getDamage(),v.getMeta());
        PacketOut packetOut=new PlayOutSlot(this.id,slot,Slot.newSlot(item));
        this.sendViewers(packetOut);
        return item;
      }
    }
  }
);
  return computed == null ? TridentItem.EMPTY : computed;
}","@Nonnull @Override public Item remove(int slot,int quantity){
  if (quantity < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (slot < 0 || slot >= this.size) {
    throw new IllegalArgumentException(""String_Node_Str"" + slot);
  }
  Item computed=this.contents.compute(slot,(k,v) -> {
    if (v == null) {
      return null;
    }
 else {
      int left=Math.max(0,v.getCount() - quantity);
      if (left == 0) {
        this.sendViewers(new PlayOutSlot(this.id,slot,Slot.EMPTY));
        return null;
      }
 else {
        TridentItem item=new TridentItem(v.getSubstance(),left,v.getDamage(),v.getMeta());
        PacketOut packetOut=new PlayOutSlot(this.id,slot,Slot.newSlot(item));
        this.sendViewers(packetOut);
        return item;
      }
    }
  }
);
  return computed == null ? TridentItem.EMPTY : computed;
}"
11681,"/** 
 * Creates a new slot using the given byte buffer to read encoded values of the slot.
 * @param buf the buffer which to read
 */
public static Slot read(ByteBuf buf){
  short id=buf.readShort();
  if (id != -1) {
    byte count=buf.readByte();
    short dmg=buf.readShort();
    Tag.Compound nbt=Tag.decode(new DataInputStream(new ByteBufInputStream(buf)));
    buf.readBytes(buf.readableBytes());
    if (id == Substance.AIR.getId()) {
      return EMPTY;
    }
 else {
      return new Slot(id,count,dmg,new ItemMeta(nbt));
    }
  }
 else {
    return EMPTY;
  }
}","/** 
 * Creates a new slot using the given byte buffer to read encoded values of the slot.
 * @param buf the buffer which to read
 */
public static Slot read(ByteBuf buf){
  short id=buf.readShort();
  if (id != -1) {
    byte count=buf.readByte();
    short dmg=buf.readShort();
    Tag.Compound nbt=Tag.decode(new DataInputStream(new ByteBufInputStream(buf)));
    buf.readBytes(buf.readableBytes());
    if (id == Substance.AIR.getId()) {
      return EMPTY;
    }
 else {
      return new Slot(id,count,dmg,nbt == null ? new ItemMeta() : new ItemMeta(nbt));
    }
  }
 else {
    return EMPTY;
  }
}"
11682,"/** 
 * Creates a new slot using the information wrapped by the given item. <p>This method automatically checks whether the item is   {@code null} and in which case, it returns{@link #EMPTY}.</p>
 * @param item the item which to send in slot format
 * @return the new slot
 */
public static Slot newSlot(Item item){
  if (item.getSubstance() == Substance.AIR) {
    return EMPTY;
  }
  return new Slot((short)item.getSubstance().getId(),(byte)item.getCount(),item.getDamage(),item.getMeta());
}","/** 
 * Creates a new slot using the information wrapped by the given item. <p>This method automatically checks whether the item is   {@code null} and in which case, it returns{@link #EMPTY}.</p>
 * @param item the item which to send in slot format
 * @return the new slot
 */
public static Slot newSlot(Item item){
  if (item.isEmpty()) {
    return EMPTY;
  }
  return new Slot((short)item.getSubstance().getId(),(byte)item.getCount(),item.getDamage(),item.getMeta());
}"
11683,"/** 
 * Init code for server startup
 */
public static TridentServer init(ServerConfig config,Logger console,NetServer net) throws IllegalStateException {
  TridentServer server=new TridentServer(config,console,net);
  if (TridentServer.instance == null) {
    TridentServer.instance=server;
    return server;
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Init code for server startup
 */
public static TridentServer init(ServerConfig config,Logger console,NetServer net) throws IllegalStateException {
  TridentServer server=new TridentServer(config,console,net);
  if (TridentServer.instance == null) {
    TridentServer.instance=server;
    server.tick.start();
    return server;
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
11684,"/** 
 * Creates a new server instance
 * @param config the config to initialize the server
 * @param console the logger to which the server logs
 */
private TridentServer(ServerConfig config,Logger console,NetServer server){
  this.config=config;
  this.logger=console;
  this.server=server;
  this.tick=new TridentTick(console);
  this.tick.start();
}","/** 
 * Creates a new server instance
 * @param config the config to initialize the server
 * @param console the logger to which the server logs
 */
private TridentServer(ServerConfig config,Logger console,NetServer server){
  this.config=config;
  this.logger=console;
  this.server=server;
  this.tick=new TridentTick(console);
}"
11685,"@Override public LogMessageImpl handle(LogMessageImpl msg){
  Writer out=this.check();
  try {
    out.write(msg.format(0));
    out.write(LINE_SEP);
    out.flush();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return msg;
}","@Override public LogMessageImpl handle(LogMessageImpl msg){
  try (Writer out=this.check()){
    out.write(msg.format(0));
    out.write(LINE_SEP);
    out.flush();
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return msg;
}"
11686,"/** 
 * Writes the memory configuration object to the config located at the given path.
 * @param path the config to write
 * @param object the memory representation of theconfig
 */
public static void writeConfig(Path path,JsonObject object) throws IOException {
  String json=GSON.toJson(object);
  try {
    if (!Files.exists(path)) {
      Files.createFile(path);
    }
    FileOutputStream stream=new FileOutputStream(path.toFile());
    stream.write(json.getBytes());
    stream.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * Writes the memory configuration object to the config located at the given path.
 * @param path the config to write
 * @param object the memory representation of theconfig
 */
public static void writeConfig(Path path,JsonObject object) throws IOException {
  String json=GSON.toJson(object);
  try (FileOutputStream stream=new FileOutputStream(path.toFile())){
    stream.write(json.getBytes());
  }
 }"
11687,"/** 
 * Iterates over the elements in this config section, performing the given operations in order to append the elements to the given collection.
 * @param base the base string key
 * @param col the collection to append entries
 * @param function extracts the entry value
 * @param deep {@code true} to get children elements
 * @param < T > the type appended to the collection
 */
private <T>void iterate(String base,Collection<T> col,BiFunction<String,Map.Entry<String,Object>,T> function,boolean deep){
  this.elements.entrySet().stream().forEach(e -> {
    Object val=e.getValue();
    if (deep) {
      if (val instanceof ConfigSection) {
        TridentConfigSection section=(TridentConfigSection)val;
        section.iterate(this.handlePath(base,section.name),col,function,true);
        return;
      }
    }
    col.add(function.apply(base,e));
  }
);
}","/** 
 * Iterates over the elements in this config section, performing the given operations in order to append the elements to the given collection.
 * @param base the base string key
 * @param col the collection to append entries
 * @param function extracts the entry value
 * @param deep {@code true} to get children elements
 * @param < T > the type appended to the collection
 */
private <T>void iterate(String base,Collection<T> col,BiFunction<String,Map.Entry<String,Object>,T> function,boolean deep){
  this.elements.entrySet().forEach(e -> {
    Object val=e.getValue();
    if (deep) {
      if (val instanceof ConfigSection) {
        TridentConfigSection section=(TridentConfigSection)val;
        section.iterate(this.handlePath(base,section.name),col,function,true);
        return;
      }
    }
    col.add(function.apply(base,e));
  }
);
}"
11688,"/** 
 * Loads the json from file into memory
 * @param object the file json
 */
public void read(JsonObject object){
  object.entrySet().stream().forEach(e -> {
    String key=e.getKey();
    JsonElement value=e.getValue();
    if (value.isJsonObject()) {
      TridentConfigSection section=this.createChild0(key,object);
      section.read(value.getAsJsonObject());
    }
 else {
      this.elements.put(key,ConfigIo.asObj(value,TridentAdapter.class));
    }
  }
);
}","/** 
 * Loads the json from file into memory
 * @param object the file json
 */
public void read(JsonObject object){
  object.entrySet().forEach(e -> {
    String key=e.getKey();
    JsonElement value=e.getValue();
    if (value.isJsonObject()) {
      TridentConfigSection section=this.createChild0(key,object);
      section.read(value.getAsJsonObject());
    }
 else {
      this.elements.put(key,ConfigIo.asObj(value,TridentAdapter.class));
    }
  }
);
}"
11689,"/** 
 * Initializer code for server startup.
 * @param ip the IP address of the interface to bind
 * @param port the port which to bind the interface
 * @return the new server net handler
 * @throws InterruptedException if something wenthorribly wrong
 */
public static NetServer init(String ip,int port,boolean useNative) throws InterruptedException {
  boolean nativeCompat=System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"");
  return nativeCompat && useNative ? new NetEpollServer(ip,port) : new NetNioServer(ip,port);
}","/** 
 * Initializer code for server startup.
 * @param ip the IP address of the interface to bind
 * @param port the port which to bind the interface
 * @return the new server net handler
 */
public static NetServer init(String ip,int port,boolean useNative){
  boolean nativeCompat=System.getProperty(""String_Node_Str"").toLowerCase().contains(""String_Node_Str"");
  return nativeCompat && useNative ? new NetEpollServer(ip,port) : new NetNioServer(ip,port);
}"
11690,"/** 
 * Sets up the server.
 * @throws InterruptedException no
 */
public abstract void setup() throws InterruptedException ;","/** 
 * Sets up the server.
 */
public abstract void setup();"
11691,"/** 
 * Writes a compressed packet that is deflated using zlib.
 * @param payload the payload to write
 * @param out the output buffer
 * @param len the length
 * @throws IOException if something goes wrong
 */
private void writeDeflated(ByteBuf payload,ByteBuf out,int len) throws IOException {
  payload.markReaderIndex();
  byte[] input=arr(payload,len);
  Deflater deflater=DEFLATER.get();
  deflater.setInput(input);
  deflater.finish();
  byte[] buffer=new byte[NetClient.BUFFER_SIZE];
  ByteBuf result=payload.alloc().buffer();
  while (!deflater.finished()) {
    int deflated=deflater.deflate(buffer);
    result.writeBytes(buffer,0,deflated);
  }
  deflater.reset();
  int resultLen=result.readableBytes();
  if (resultLen >= len) {
    payload.resetReaderIndex();
    this.writeCompressed(payload,out);
  }
 else {
    wvint(out,resultLen + BigInteger.valueOf(len).toByteArray().length);
    wvint(out,len);
    out.writeBytes(result);
  }
  result.release();
}","/** 
 * Writes a compressed packet that is deflated using zlib.
 * @param payload the payload to write
 * @param out the output buffer
 * @param len the length
 */
private void writeDeflated(ByteBuf payload,ByteBuf out,int len){
  payload.markReaderIndex();
  byte[] input=arr(payload,len);
  Deflater deflater=DEFLATER.get();
  deflater.setInput(input);
  deflater.finish();
  byte[] buffer=new byte[NetClient.BUFFER_SIZE];
  ByteBuf result=payload.alloc().buffer();
  while (!deflater.finished()) {
    int deflated=deflater.deflate(buffer);
    result.writeBytes(buffer,0,deflated);
  }
  deflater.reset();
  int resultLen=result.readableBytes();
  if (resultLen >= len) {
    payload.resetReaderIndex();
    this.writeCompressed(payload,out);
  }
 else {
    wvint(out,resultLen + BigInteger.valueOf(len).toByteArray().length);
    wvint(out,len);
    out.writeBytes(result);
  }
  result.release();
}"
11692,"/** 
 * Performs an HTTP(s) POST to the mojang server.
 * @param element the JSON object to POST
 */
public Future<T> post(JsonElement element){
  Callable<T> post=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      this.c.getOutputStream().write(ConfigIo.GSON.toJson(element).getBytes(NetData.NET_CHARSET));
      this.c.getOutputStream().close();
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()));
      return this.callback.apply(ConfigIo.PARSER.parse(reader));
    }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return SCHEDULER.submit(post);
}","/** 
 * Performs an HTTP(s) POST to the mojang server.
 * @param element the JSON object to POST
 */
public Future<T> post(JsonElement element){
  Callable<T> post=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      try (OutputStream out=this.c.getOutputStream()){
        out.write(ConfigIo.GSON.toJson(element).getBytes(NetData.NET_CHARSET));
      }
       int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      try (BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()))){
        return this.callback.apply(ConfigIo.PARSER.parse(reader));
      }
     }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return SCHEDULER.submit(post);
}"
11693,"/** 
 * Performs an HTTP(s) GET to the server.
 */
public Future<T> get(){
  Callable<T> get=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()));
      return this.callback.apply(ConfigIo.PARSER.parse(reader));
    }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return SCHEDULER.submit(get);
}","/** 
 * Performs an HTTP(s) GET to the server.
 */
public Future<T> get(){
  Callable<T> get=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      try (BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()))){
        return this.callback.apply(ConfigIo.PARSER.parse(reader));
      }
     }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return SCHEDULER.submit(get);
}"
11694,"@Override public void sendTitle(Title title){
  if (!title.isDefaultFadeTimes()) {
    this.net().sendPacket(new PlayOutTitle.SetTiming(title));
  }
  ChatComponent mainTitle=title.getHeader();
  ChatComponent subtitle=title.getSubtitle();
  this.net().sendPacket(new PlayOutTitle.SetTitle(mainTitle));
  this.net().sendPacket(new PlayOutTitle.SetSubtitle(subtitle));
}","@Override public void sendTitle(Title title){
  if (!title.isDefaultFadeTimes()) {
    this.net().sendPacket(new PlayOutTitle.SetTiming(title));
  }
  ChatComponent mainTitle=title.getHeader();
  ChatComponent subtitle=title.getSubtitle();
  this.net().sendPacket(new PlayOutTitle.SetSubtitle(subtitle));
  this.net().sendPacket(new PlayOutTitle.SetTitle(mainTitle));
}"
11695,"@Override public void resetTitle(){
  this.net().sendPacket(new PlayOutTitle.Hide());
}","@Override public void resetTitle(){
  this.net().sendPacket(new PlayOutTitle.Reset());
}"
11696,"@Override public void run(){
  while (true) {
    try {
      long start=System.currentTimeMillis();
      for (      TridentWorld world : TridentWorldLoader.getInstance().worlds()) {
        world.tick();
      }
      for (      TridentPlayer player : TridentPlayer.getPlayers().values()) {
        player.tick();
      }
      long end=System.currentTimeMillis();
      long elapsed=end - start;
      long waitTime=TICK_MILLIS - elapsed;
      if (waitTime <= 0) {
        this.logger.debug(""String_Node_Str"" + -waitTime + ""String_Node_Str""+ (-waitTime / TICK_MILLIS)+ ""String_Node_Str"");
      }
 else {
        Thread.sleep(waitTime);
      }
    }
 catch (    InterruptedException e) {
      break;
    }
catch (    Exception e) {
      JiraExceptionCatcher.serverException(e);
      break;
    }
  }
}","@Override public void run(){
  while (true) {
    try {
      long start=System.currentTimeMillis();
      for (      TridentWorld world : TridentWorldLoader.getInstance().worlds()) {
        world.tick();
      }
      for (      TridentPlayer player : TridentPlayer.getPlayers().values()) {
        player.tick();
      }
      TridentScheduler.getInstance().tick();
      long end=System.currentTimeMillis();
      long elapsed=end - start;
      long waitTime=TICK_MILLIS - elapsed;
      if (waitTime < 0) {
        this.logger.debug(""String_Node_Str"" + -waitTime + ""String_Node_Str""+ (-waitTime / TICK_MILLIS)+ ""String_Node_Str"");
      }
 else {
        Thread.sleep(waitTime);
      }
    }
 catch (    InterruptedException e) {
      break;
    }
catch (    Exception e) {
      JiraExceptionCatcher.serverException(e);
      break;
    }
  }
}"
11697,"@Override public void read(ByteBuf buf,NetClient client){
  int id=rvint(buf);
  Integer localId=TELEPORT_ID.getIfPresent(client);
  if (localId != null && localId == id) {
  }
 else {
    Logger.get(PlayInTeleportConfirm.class).error(""String_Node_Str"" + localId + ""String_Node_Str""+ id);
  }
}","@Override public void read(ByteBuf buf,NetClient client){
  int id=rvint(buf);
  Integer localId=TELEPORT_ID.get(client);
  if (localId != null && localId == id) {
  }
 else {
    Logger.get(PlayInTeleportConfirm.class).error(""String_Node_Str"" + localId + ""String_Node_Str""+ id);
  }
}"
11698,"/** 
 * Performs an HTTP(s) POST to the mojang server.
 * @param element the JSON object to POST
 */
public Future<T> post(JsonElement element){
  Callable<T> post=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      this.c.getOutputStream().write(ConfigIo.GSON.toJson(element).getBytes(NetData.NET_CHARSET));
      this.c.getOutputStream().close();
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()));
      return this.callback.apply(ConfigIo.PARSER.parse(reader));
    }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return ServerThreadPool.forSpec(PoolSpec.SCHEDULER).submit(post);
}","/** 
 * Performs an HTTP(s) POST to the mojang server.
 * @param element the JSON object to POST
 */
public Future<T> post(JsonElement element){
  Callable<T> post=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      this.c.getOutputStream().write(ConfigIo.GSON.toJson(element).getBytes(NetData.NET_CHARSET));
      this.c.getOutputStream().close();
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()));
      return this.callback.apply(ConfigIo.PARSER.parse(reader));
    }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return SCHEDULER.submit(post);
}"
11699,"/** 
 * Performs an HTTP(s) GET to the server.
 */
public Future<T> get(){
  Callable<T> get=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()));
      return this.callback.apply(ConfigIo.PARSER.parse(reader));
    }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return ServerThreadPool.forSpec(PoolSpec.SCHEDULER).submit(get);
}","/** 
 * Performs an HTTP(s) GET to the server.
 */
public Future<T> get(){
  Callable<T> get=() -> {
    try {
      this.c.setRequestMethod(""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      this.c.setDoOutput(true);
      this.c.setDoInput(true);
      int code=this.c.getResponseCode();
      if (code != 200) {
        return this.exception.apply(String.valueOf(code));
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(this.c.getInputStream()));
      return this.callback.apply(ConfigIo.PARSER.parse(reader));
    }
 catch (    IOException e) {
      return this.exception.apply(e.getMessage());
    }
  }
;
  return SCHEDULER.submit(get);
}"
11700,"@Override public Object read(JsonReader in) throws IOException {
  JsonToken token=in.peek();
switch (token) {
case BEGIN_ARRAY:
    List<Object> list=new ArrayList<>();
  in.beginArray();
while (in.hasNext()) {
  list.add(this.read(in));
}
in.endArray();
return list;
case BEGIN_OBJECT:
Map<String,Object> map=new LinkedTreeMap<>();
in.beginObject();
while (in.hasNext()) {
String key=in.nextName();
Object value=this.read(in);
if (key.equals(""String_Node_Str"")) {
try {
return this.gson.getAdapter(Class.forName((String)value)).read(in);
}
 catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
map.put(key,value);
}
in.endObject();
return map;
case STRING:
return in.nextString();
case NUMBER:
double d=in.nextDouble();
if (DoubleMath.isMathematicalInteger(d)) {
return (int)d;
}
return d;
case BOOLEAN:
return in.nextBoolean();
case NULL:
in.nextNull();
return null;
default :
throw new IllegalStateException();
}
}","@Override public Object read(JsonReader in) throws IOException {
  JsonToken token=in.peek();
switch (token) {
case BEGIN_ARRAY:
    List<Object> list=new ArrayList<>();
  in.beginArray();
while (in.hasNext()) {
  list.add(this.read(in));
}
in.endArray();
return list;
case BEGIN_OBJECT:
Map<String,Object> map=new LinkedTreeMap<>();
in.beginObject();
while (in.hasNext()) {
String key=in.nextName();
Object value=this.read(in);
if (key.equals(""String_Node_Str"")) {
try {
return this.gson.getAdapter(Class.forName((String)value)).read(in);
}
 catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
map.put(key,value);
}
in.endObject();
return map;
case STRING:
return in.nextString();
case NUMBER:
return in.nextDouble();
case BOOLEAN:
return in.nextBoolean();
case NULL:
in.nextNull();
return null;
default :
throw new IllegalStateException();
}
}"
11701,"/** 
 * Constructs a new player.
 */
private TridentPlayer(NetClient client,World world,String name,UUID uuid,String textures){
  super(world);
  this.client=client;
  this.name=name;
  this.uuid=uuid;
  this.gameMode=world.opts().gameMode();
  this.textures=textures;
  this.renderDistance=7;
}","/** 
 * Constructs a new player.
 */
private TridentPlayer(NetClient client,World world,String name,UUID uuid,String textures){
  super(world,PoolSpec.PLAYERS);
  this.client=client;
  this.name=name;
  this.uuid=uuid;
  this.gameMode=world.opts().gameMode();
  this.textures=textures;
  this.renderDistance=7;
}"
11702,"public void read(ByteBuf buf){
  List<EntityMetadataItem> items=new LinkedList<>();
  short id;
  while ((id=buf.readUnsignedByte()) != 0xFF) {
    EntityMetadataType type=EntityMetadataType.values()[id];
    Object value=null;
switch (type) {
case BYTE:
      value=buf.readByte();
    break;
case VARINT:
  value=NetData.rvint(buf);
break;
case FLOAT:
value=buf.readFloat();
break;
case STRING:
value=NetData.rstr(buf);
break;
case CHAT:
value=ChatComponent.fromJson(new Gson().fromJson(NetData.rstr(buf),JsonObject.class));
break;
case SLOT:
break;
case BOOLEAN:
value=buf.readBoolean();
break;
case ROTATION:
float[] rd=new float[3];
for (int i=0; i < 3; i++) rd[i]=buf.readFloat();
value=new Vector(rd[0],rd[1],rd[2]);
break;
case POSITION:
{
long val=buf.readLong();
int x=(int)(val >> 38);
int y=(int)((val >> 26) & 0xFFF);
int z=(int)(val << 38 >> 38);
value=new Vector(x,y,z);
break;
}
case OPTPOSITION:
{
if (buf.readBoolean()) {
long val=buf.readLong();
int x=(int)(val >> 38);
int y=(int)((val >> 26) & 0xFFF);
int z=(int)(val << 38 >> 38);
value=new Vector(x,y,z);
}
 else {
value=null;
}
break;
}
case DIRECTION:
value=Direction.values()[NetData.rvint(buf)];
break;
case OPTUUID:
if (buf.readBoolean()) {
value=new UUID(buf.readLong(),buf.readLong());
}
 else {
value=null;
}
break;
case BLOCKID:
int bid=NetData.rvint(buf);
value=new int[]{(bid >> 4) & 0xF,bid & 0xF};
break;
}
if (value != null) {
items.add(new EntityMetadataItem(id,type,value));
}
}
this.items.clear();
this.items.addAll(items);
}","public void read(ByteBuf buf){
  List<EntityMetadataItem> items=new LinkedList<>();
  short id;
  while ((id=buf.readUnsignedByte()) != 0xFF) {
    EntityMetadataType type=EntityMetadataType.values()[id];
    Object value=null;
switch (type) {
case BYTE:
      value=buf.readByte();
    break;
case VARINT:
  value=NetData.rvint(buf);
break;
case FLOAT:
value=buf.readFloat();
break;
case STRING:
value=NetData.rstr(buf);
break;
case CHAT:
value=ChatComponent.fromJson(new Gson().fromJson(NetData.rstr(buf),JsonObject.class));
break;
case SLOT:
break;
case BOOLEAN:
value=buf.readBoolean();
break;
case ROTATION:
float[] rd=new float[3];
for (int i=0; i < 3; i++) {
rd[i]=buf.readFloat();
}
value=new Vector(rd[0],rd[1],rd[2]);
break;
case POSITION:
{
long val=buf.readLong();
int x=(int)(val >> 38);
int y=(int)((val >> 26) & 0xFFF);
int z=(int)(val << 38 >> 38);
value=new Vector(x,y,z);
break;
}
case OPTPOSITION:
{
if (buf.readBoolean()) {
long val=buf.readLong();
int x=(int)(val >> 38);
int y=(int)((val >> 26) & 0xFFF);
int z=(int)(val << 38 >> 38);
value=new Vector(x,y,z);
}
 else {
value=null;
}
break;
}
case DIRECTION:
value=Direction.values()[NetData.rvint(buf)];
break;
case OPTUUID:
if (buf.readBoolean()) {
value=new UUID(buf.readLong(),buf.readLong());
}
 else {
value=null;
}
break;
case BLOCKID:
int bid=NetData.rvint(buf);
value=new int[]{(bid >> 4) & 0xF,bid & 0xF};
break;
}
if (value != null) {
items.add(new EntityMetadataItem(id,type,value));
}
}
this.items.clear();
this.items.addAll(items);
}"
11703,"/** 
 * Obtains the net state which the packet is registered to be present in.
 * @param cls the packet class
 * @return the state of the packet
 */
public static int packetInfo(Class<? extends Packet> cls){
  int identifier=PACKETS.get(cls);
  if (identifier != -1) {
    return identifier;
  }
  throw new IllegalArgumentException(cls.getSimpleName() + ""String_Node_Str"");
}","/** 
 * Obtains the net state which the packet is registered to be present in.
 * @param cls the packet class
 * @return the state of the packet
 */
public static int packetInfo(Class<? extends Packet> cls){
  int identifier=PACKET_IDS.getInt(cls);
  if (identifier != -1) {
    return identifier;
  }
  throw new IllegalArgumentException(cls.getSimpleName() + ""String_Node_Str"");
}"
11704,"/** 
 * Obtains the class of the packet containing the given ID, bound, and the given state.
 * @param state the packet's network state
 * @param bound the packet bound
 * @param id the packet ID
 * @return the packet class
 */
public static Class<? extends Packet> byId(NetState state,Bound bound,int id){
  int identifier=shift(state,bound,id);
  Class<? extends Packet> packet=PACKET_IDS.get(identifier);
  if (packet != null) {
    return packet;
  }
  String paddedHex=String.format(""String_Node_Str"",Integer.toHexString(id).toUpperCase()).replace(' ','0');
  throw new IllegalArgumentException(state + ""String_Node_Str"" + bound+ ""String_Node_Str""+ id+ ""String_Node_Str""+ paddedHex+ ""String_Node_Str"");
}","/** 
 * Obtains the class of the packet containing the given ID, bound, and the given state.
 * @param state the packet's network state
 * @param bound the packet bound
 * @param id the packet ID
 * @return the packet class
 */
public static Class<? extends Packet> byId(NetState state,Bound bound,int id){
  int identifier=shift(state,bound,id);
  Class<? extends Packet> packet=PACKETS.get(identifier);
  if (packet != null) {
    return packet;
  }
  String paddedHex=String.format(""String_Node_Str"",Integer.toHexString(id).toUpperCase()).replace(' ','0');
  throw new IllegalArgumentException(state + ""String_Node_Str"" + bound+ ""String_Node_Str""+ id+ ""String_Node_Str""+ paddedHex+ ""String_Node_Str"");
}"
11705,"/** 
 * Puts the given packet class into the map with the given ID, and also inserts the constructor into the CTOR cache.
 * @param cls the class
 * @param id the ID
 */
private static void put(Class<? extends Packet> cls,NetState state,Bound bound,int id){
  int identifier=shift(state,bound,id);
  PACKETS.put(cls,identifier);
  PACKET_IDS.put(identifier,cls);
  if (bound == Bound.SERVER) {
    CTORS.put(cls,ConstructorAccess.get(cls));
  }
}","/** 
 * Puts the given packet class into the map with the given ID, and also inserts the constructor into the CTOR cache.
 * @param cls the class
 * @param id the ID
 */
private static void put(Class<? extends Packet> cls,NetState state,Bound bound,int id){
  int identifier=shift(state,bound,id);
  PACKET_IDS.put(cls,identifier);
  if (bound == Bound.SERVER) {
    PACKETS.put(identifier,cls);
    CTORS.put(cls,ConstructorAccess.get(cls));
  }
}"
11706,"@Override protected void decode(ChannelHandlerContext ctx,ByteBuf buf,List<Object> list) throws Exception {
  NetCrypto crypto=this.client.cryptoModule();
  ByteBuf decrypt=buf;
  if (crypto != null) {
    decrypt=ctx.alloc().buffer();
    crypto.decrypt(buf,decrypt);
  }
  ByteBuf decompressed=decrypt;
  boolean deflated=false;
  if (this.client.doCompression()) {
    rvint(decrypt);
    int compressedLen=rvint(decrypt);
    if (compressedLen > COMPRESSION_THRESH) {
      decompressed=ctx.alloc().buffer();
      deflated=true;
      byte[] in=arr(decrypt);
      Inflater inflater=INFLATER.get();
      inflater.setInput(in);
      byte[] buffer=new byte[NetClient.BUFFER_SIZE];
      while (!inflater.finished()) {
        int bytes=inflater.inflate(buffer);
        decompressed.writeBytes(buffer,0,bytes);
      }
      inflater.reset();
    }
  }
 else {
    rvint(decompressed);
  }
  int id=rvint(decompressed);
  Class<? extends Packet> cls=PacketRegistry.byId(this.client.state(),Packet.Bound.SERVER,id);
  PacketIn packet=PacketRegistry.make(cls);
  LOGGER.debug(""String_Node_Str"" + packet.getClass().getSimpleName());
  packet.read(decompressed,this.client);
  if (deflated) {
    decompressed.release();
  }
}","@Override protected void decode(ChannelHandlerContext ctx,ByteBuf buf,List<Object> list) throws Exception {
  NetCrypto crypto=this.client.cryptoModule();
  ByteBuf decrypt=buf;
  if (crypto != null) {
    decrypt=ctx.alloc().buffer();
    crypto.decrypt(buf,decrypt);
  }
  ByteBuf decompressed=decrypt;
  boolean deflated=false;
  if (this.client.doCompression()) {
    rvint(decrypt);
    int compressedLen=rvint(decrypt);
    if (compressedLen > COMPRESSION_THRESH) {
      decompressed=ctx.alloc().buffer();
      deflated=true;
      byte[] in=arr(decrypt);
      Inflater inflater=INFLATER.get();
      inflater.setInput(in);
      byte[] buffer=new byte[NetClient.BUFFER_SIZE];
      while (!inflater.finished()) {
        int bytes=inflater.inflate(buffer);
        decompressed.writeBytes(buffer,0,bytes);
      }
      inflater.reset();
    }
  }
 else {
    rvint(decompressed);
  }
  int id=rvint(decompressed);
  Class<? extends Packet> cls=PacketRegistry.byId(this.client.state(),Packet.Bound.SERVER,id);
  PacketIn packet=PacketRegistry.make(cls);
  LOGGER.debug(""String_Node_Str"" + packet.getClass().getSimpleName());
  packet.read(decompressed,this.client);
  if (deflated) {
    decompressed.release();
  }
  if (crypto != null) {
    decrypt.release();
  }
}"
11707,"/** 
 * Writes the section data to the given byte stream.
 * @param buf the buffer to write the section data
 */
public void write(ByteBuf buf){
  buf.writeByte(this.bitsPerBlock);
  wvint(buf,this.palette.size());
  for (  short s : this.palette) {
    wvint(buf,s);
  }
  wvint(buf,this.data.length);
  for (  long l : this.data) {
    buf.writeLong(l);
  }
  buf.writeBytes(this.blockLight);
  buf.writeBytes(this.skyLight);
}","/** 
 * Writes the section data to the given byte stream.
 * @param buf the buffer to write the section data
 */
public void write(ByteBuf buf){
  buf.writeByte(this.bitsPerBlock);
  wvint(buf,this.palette.size());
  ShortArrayList palette;
synchronized (this.palette) {
    palette=this.palette;
  }
  for (int i=0; i < palette.size(); i++) {
    wvint(buf,palette.getShort(i));
  }
  wvint(buf,this.data.length);
  for (  long l : this.data) {
    buf.writeLong(l);
  }
  buf.writeBytes(this.blockLight);
  buf.writeBytes(this.skyLight);
}"
11708,"/** 
 * Initializes the files and directories, attempts to find the last log file.
 */
public static FileLogger init(Logger next) throws Exception {
  FileLogger logger=new FileLogger(next);
  if (!Files.exists(DIR)) {
    Files.createDirectory(DIR);
  }
  File[] files=DIR.toFile().listFiles();
  if (files != null && files.length > 0) {
    int idx=0;
    File f=null;
    for (    File file : files) {
      String[] split=file.getName().split(IDX_SEPARATOR);
      int i=Integer.parseInt(split[1]);
      if (i > idx) {
        idx=i;
        f=file;
      }
    }
    if (f == null)     throw new RuntimeException();
synchronized (logger.lock) {
      logger.makeNewLog(f.toPath());
    }
  }
 else {
synchronized (logger.lock) {
      logger.makeNewLog(0);
    }
  }
  return logger;
}","/** 
 * Initializes the files and directories, attempts to find the last log file.
 */
public static FileLogger init(Logger next) throws Exception {
  FileLogger logger=new FileLogger(next);
  if (!Files.exists(DIR)) {
    Files.createDirectory(DIR);
  }
  File[] files=DIR.toFile().listFiles();
  if (files != null && files.length > 0) {
    int idx=-1;
    File f=null;
    for (    File file : files) {
      String[] split=file.getName().split(IDX_SEPARATOR);
      int i=Integer.parseInt(split[1]);
      if (i > idx) {
        idx=i;
        f=file;
      }
    }
    if (f == null)     throw new RuntimeException();
synchronized (logger.lock) {
      logger.makeNewLog(f.toPath());
    }
  }
 else {
synchronized (logger.lock) {
      logger.makeNewLog(0);
    }
  }
  return logger;
}"
11709,"@Override public Collection<Object> values(boolean deep){
  return elements.values().stream().filter(o -> !(o instanceof ConfigSection)).collect(Collectors.toList());
}","@Override public Collection<Object> values(boolean deep){
  LinkedList<Object> set=Lists.newLinkedList();
  elements.values().stream().forEach(o -> {
    if (deep) {
      if (o instanceof ConfigSection) {
        ConfigSection section=(ConfigSection)o;
        set.addAll(section.values(true));
      }
    }
    set.add(o);
  }
);
  return set;
}"
11710,"@Override public Set<ConfigSection> children(boolean deep){
  return elements.values().stream().filter(o -> o instanceof ConfigSection).map(o -> (ConfigSection)o).collect(Collectors.toSet());
}","@Override public Set<ConfigSection> children(boolean deep){
  HashSet<ConfigSection> set=Sets.newLinkedHashSet();
  elements.values().stream().filter(o -> o instanceof ConfigSection).map(o -> (TridentConfigSection)o).forEach(cs -> {
    set.add(cs);
    if (deep) {
      set.addAll(cs.children(true));
    }
  }
);
  return set;
}"
11711,"/** 
 * Obtains the chunk at the given location and determines whether a chunk will be generated if it does not exist yet.
 * @param x the x coordinate
 * @param z the z coordinate
 * @param gen {@code true} to generate if non-existant
 * @return the chunk, or {@code null}
 */
public TridentChunk get(int x,int z,boolean gen){
  System.out.printf(""String_Node_Str"",x,z);
  long key=(long)x << 32 | (long)z;
synchronized (this.lock) {
    TridentChunk chunk=this.chunks.get(key);
    if (chunk == null && gen) {
      chunk=new TridentChunk(this.world,x,z);
      chunk.generate();
      this.chunks.put(key,chunk);
    }
    return chunk;
  }
}","/** 
 * Obtains the chunk at the given location and determines whether a chunk will be generated if it does not exist yet.
 * @param x the x coordinate
 * @param z the z coordinate
 * @param gen {@code true} to generate if non-existant
 * @return the chunk, or {@code null}
 */
public TridentChunk get(int x,int z,boolean gen){
  long key=z >= 0 ? ((long)x << 32) | z : (long)1 << 31 | (((long)x << 32) | 0x7FFFFFFF & z);
synchronized (this.lock) {
    TridentChunk chunk=this.chunks.get(key);
    if (chunk == null && gen) {
      chunk=new TridentChunk(this.world,x,z);
      chunk.generate();
      this.chunks.put(key,chunk);
    }
    return chunk;
  }
}"
11712,"public void tick(){
  ThreadsHandler.worldExecutor().execute(() -> {
    redstoneTick=!redstoneTick;
    long currentTime=time.get();
    rainTime.getAndDecrement();
    thunderTime.getAndDecrement();
    if (rainTime.get() <= 0) {
      raining=!raining;
      if (raining) {
        RainEvent e=EventProcessor.fire(new RainEvent(this));
        if (e.isIgnored()) {
          raining=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          raining=true;
        }
      }
      rainTime.set(ThreadLocalRandom.current().nextInt());
    }
    if (thunderTime.get() <= 0) {
      thundering=!thundering;
      if (thundering) {
        ThunderEvent e=EventProcessor.fire(new ThunderEvent(this));
        if (e.isIgnored()) {
          thundering=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          thundering=true;
        }
      }
      thunderTime.set(ThreadLocalRandom.current().nextInt());
    }
    boolean updateTime=(currentTime & 40) == 0;
    for (    Entity entity : entities) {
      TickSync.increment(""String_Node_Str"" + entity.uniqueId().toString() + ""String_Node_Str""+ entity.entityId()+ ""String_Node_Str""+ entity.type());
      ((TridentEntity)entity).tick();
      if (entity instanceof Player) {
        TridentPlayer player=(TridentPlayer)entity;
        if (updateTime) {
          player.connection().sendPacket(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed.get()).set(""String_Node_Str"",currentTime));
        }
      }
    }
    if ((currentTime & CHUNK_EVICTION_TIME) == 0) {
      for (      ChunkLocation chunk : loadedChunks.keys()) {
        loadedChunks.tryRemove(chunk);
      }
    }
    if (currentTime >= 24000)     time.set(0);
 else     time.getAndIncrement();
    existed.getAndIncrement();
    TickSync.complete(""String_Node_Str"" + name());
  }
);
}","public void tick(){
  ThreadsHandler.worldExecutor().execute(() -> {
    redstoneTick=!redstoneTick;
    long currentTime=time.get();
    rainTime.getAndDecrement();
    thunderTime.getAndDecrement();
    if (rainTime.get() <= 0) {
      raining=!raining;
      if (raining) {
        RainEvent e=EventProcessor.fire(new RainEvent(this));
        if (e.isIgnored()) {
          raining=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          raining=true;
        }
      }
      rainTime.set(ThreadLocalRandom.current().nextInt());
    }
    if (thunderTime.get() <= 0) {
      thundering=!thundering;
      if (thundering) {
        ThunderEvent e=EventProcessor.fire(new ThunderEvent(this));
        if (e.isIgnored()) {
          thundering=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          thundering=true;
        }
      }
      thunderTime.set(ThreadLocalRandom.current().nextInt());
    }
    boolean updateTime=(currentTime & 40) == 0;
    for (    Entity entity : entities) {
      TickSync.increment(""String_Node_Str"" + entity.uniqueId().toString() + ""String_Node_Str""+ entity.entityId()+ ""String_Node_Str""+ entity.type());
      ((TridentEntity)entity).tick();
      if (entity instanceof Player) {
        TridentPlayer player=(TridentPlayer)entity;
        if (updateTime) {
          player.connection().sendPacket(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed.get()).set(""String_Node_Str"",currentTime));
        }
      }
    }
    if ((currentTime & CHUNK_EVICTION_TIME) == 0) {
      UnmodifiableIterator<List<ChunkLocation>> list=Iterators.partition(loadedChunks.keys().iterator(),Math.max(TridentPlayer.players().size(),1));
      for (; list.hasNext(); ) {
        List<ChunkLocation> chunks=list.next();
        ThreadsHandler.chunkExecutor().execute(() -> chunks.forEach(loadedChunks::tryRemove));
      }
    }
    if (currentTime >= 24000)     time.set(0);
 else     time.getAndIncrement();
    existed.getAndIncrement();
    TickSync.complete(""String_Node_Str"" + name());
  }
);
}"
11713,"public int size(){
  return counters.size();
}","/** 
 * Obtains the amount of loaded chunks
 * @return the amount of loaded chunks
 */
public int size(){
  return counters.size();
}"
11714,"public boolean apply(ChunkLocation location,Consumer<CRefCounter> consumer){
  CRefCounter chunk=counters.get(location);
  if (chunk != null) {
    consumer.accept(chunk);
    return true;
  }
  return false;
}","/** 
 * Obtains the chunk reference counter and applies a transformation function
 * @param location the location or obtain the chunk reference counter
 * @param consumer the transformation function
 * @return {@code true} to indicate that the chunk was successfully retrieved and transformed
 */
public boolean apply(ChunkLocation location,Consumer<CRefCounter> consumer){
  CRefCounter chunk=counters.get(location);
  if (chunk != null) {
    consumer.accept(chunk);
    return true;
  }
  return false;
}"
11715,"public boolean tryRemove(ChunkLocation location){
  if (location.x() < 7 && location.z() < 7) {
    return true;
  }
  CRefCounter chunk=counters.get(location);
  if (chunk == null) {
    return false;
  }
  if (!chunk.hasStrongRefs()) {
    TridentChunk c=chunk.unwrap();
    if (chunk.hasWeakRefs()) {
    }
    remove(location);
    c.unload();
  }
  return false;
}","/** 
 * Attempts to remove the chunk from memory and save it <p>This method returns   {@code false} if:<ul> <li>The chunk is not loaded</li> <li>The chunk still has strong references</li> </ul></p>
 * @param location the location to remove the chunk
 * @return {@code true} to signify that the collection was modified as a result of this operation
 */
public boolean tryRemove(ChunkLocation location){
  if (location.x() < 7 && location.z() < 7) {
    return true;
  }
  CRefCounter chunk=counters.get(location);
  if (chunk == null) {
    return false;
  }
  if (!chunk.hasStrongRefs()) {
    TridentChunk c=chunk.unwrap();
    if (chunk.hasWeakRefs()) {
    }
    remove(location);
    c.unload();
    return true;
  }
  return false;
}"
11716,"public Set<ChunkLocation> keys(){
  return counters.keySet();
}","/** 
 * Obtains the set of chunk locations that have already been loaded
 * @return the set of loaded chunk locations
 */
public Set<ChunkLocation> keys(){
  return counters.keySet();
}"
11717,"public TridentChunk get(ChunkLocation location,boolean gen){
  if (gen) {
    return counters.computeIfAbsent(location,k -> CRefCounter.wrap(world.generateChunk(k))).unwrap();
  }
 else {
    CRefCounter refCounter=counters.get(location);
    return refCounter == null ? null : refCounter.unwrap();
  }
}","/** 
 * Obtains the chunk at the given location in the world, generating if given to do so
 * @param location the location to obtain the chunk
 * @param gen      {@code true} to generate a new chunk if no chunk exists
 * @return the chunk at the given location, or {@code null} if it doesn't exist and {@code gen} is false
 */
public TridentChunk get(ChunkLocation location,boolean gen){
  if (gen) {
    return counters.computeIfAbsent(location,k -> CRefCounter.wrap(world.generateChunk(k))).unwrap();
  }
 else {
    CRefCounter refCounter=counters.get(location);
    return refCounter == null ? null : refCounter.unwrap();
  }
}"
11718,"public Collection<TridentChunk> values(){
  Collection<TridentChunk> chunks=Lists.newArrayList();
  counters.values().stream().forEach(c -> chunks.add(c.unwrap()));
  return chunks;
}","/** 
 * Obtains the chunks that have been loaded into memory
 * @return the collection of loaded in-memory chunks
 */
public Collection<TridentChunk> values(){
  Collection<TridentChunk> chunks=Lists.newArrayList();
  counters.values().stream().forEach(c -> chunks.add(c.unwrap()));
  return chunks;
}"
11719,"public ChunkHandler(TridentWorld world){
  this.world=world;
}","/** 
 * Creates a new chunk handler to manage the chunks of the provided world
 * @param world the world to manage chunks for
 */
public ChunkHandler(TridentWorld world){
  this.world=world;
}"
11720,"public void put(TridentChunk chunk){
  counters.put(chunk.location(),CRefCounter.wrap(chunk));
}","/** 
 * Places a chunk into the collection of in-memory chunks
 * @param chunk the chunk to add
 */
public void put(TridentChunk chunk){
  counters.put(chunk.location(),CRefCounter.wrap(chunk));
}"
11721,"public void remove(ChunkLocation location){
  counters.remove(location);
}","/** 
 * Manually removes the chunk from the collection without running any cleanup code
 * @param location the location to remove the chunk from
 */
public void remove(ChunkLocation location){
  counters.remove(location);
}"
11722,"@Policy(""String_Node_Str"") private void clean0(int viewDist,int size){
  Position pos=player.position();
  int x=(int)pos.x() / 16;
  int z=(int)pos.z() / 16;
  int removed=0;
  for (  ChunkLocation location : knownChunks) {
    if (MAX_CHUNKS > (size - removed))     return;
    int cx=location.x();
    int cz=location.z();
    int abs=Math.max(cx,x) - Math.min(cx,x);
    int abs1=Math.max(cz,z) - Math.min(cz,z);
    if (abs >= viewDist || abs1 >= viewDist) {
      player.connection().sendPacket(new PacketPlayOutChunkData(new byte[0],location,true,(short)0));
      knownChunks.remove(location);
      removed++;
    }
  }
}","@Policy(""String_Node_Str"") private void clean0(int viewDist,int size){
  Position pos=player.position();
  int x=(int)pos.x() / 16;
  int z=(int)pos.z() / 16;
  int removed=0;
  for (  ChunkLocation location : knownChunks) {
    if (MAX_CHUNKS > size - removed)     return;
    int cx=location.x();
    int cz=location.z();
    int abs=Math.max(cx,x) - Math.min(cx,x);
    int abs1=Math.max(cz,z) - Math.min(cz,z);
    if (abs >= viewDist || abs1 >= viewDist) {
      player.connection().sendPacket(new PacketPlayOutChunkData(new byte[0],location,true,(short)0));
      knownChunks.remove(location);
      removed++;
    }
  }
}"
11723,"public void update(int viewDistance){
  int centX=((int)Math.floor(player.position().x())) >> 4;
  int centZ=((int)Math.floor(player.position().z())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  HashSet<TridentChunk> set=new HashSet<>();
synchronized (knownChunks) {
    for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
      for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
        for (int i=x - 1; i <= x + 1; i++) {
          for (int j=z - 1; j <= z + 1; j++) {
            ChunkLocation loc=ChunkLocation.create(i,j);
            if (knownChunks.contains(loc))             continue;
            TridentChunk chunk=world.chunkAt(loc,true);
            if (i == x && j == z) {
              set.add(chunk);
            }
          }
        }
      }
    }
    for (    TridentChunk chunk : set) {
      if (knownChunks.add(chunk.location())) {
        bulk.addEntry(chunk.asPacket());
      }
      if (bulk.size() >= 1845152) {
        player.connection().sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
      }
    }
    if (bulk.hasEntries()) {
      player.connection().sendPacket(bulk);
    }
  }
}","public void update(int viewDistance){
  int centX=(int)Math.floor(player.position().x()) >> 4;
  int centZ=(int)Math.floor(player.position().z()) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  HashSet<TridentChunk> set=new HashSet<>();
synchronized (knownChunks) {
    for (int x=centX - viewDistance / 2; x <= centX + viewDistance / 2; x+=1) {
      for (int z=centZ - viewDistance / 2; z <= centZ + viewDistance / 2; z+=1) {
        for (int i=x - 1; i <= x + 1; i++) {
          for (int j=z - 1; j <= z + 1; j++) {
            ChunkLocation loc=ChunkLocation.create(i,j);
            if (knownChunks.contains(loc))             continue;
            TridentChunk chunk=world.chunkAt(loc,true);
            if (i == x && j == z) {
              set.add(chunk);
            }
          }
        }
      }
    }
    for (    TridentChunk chunk : set) {
      if (knownChunks.add(chunk.location())) {
        bulk.addEntry(chunk.asPacket());
      }
      if (bulk.size() >= 1845152) {
        player.connection().sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
      }
    }
    if (bulk.hasEntries()) {
      player.connection().sendPacket(bulk);
    }
  }
}"
11724,"public ChunkLocationSet(TridentPlayer player){
  this.player=player;
  this.world=((TridentWorld)player.world());
}","public ChunkLocationSet(TridentPlayer player){
  this.player=player;
  this.world=(TridentWorld)player.world();
}"
11725,"@Override public void load(){
  ((TridentChunk)world().chunkAt(location(),true)).load(tag);
}","@Override public boolean load(){
  return false;
}"
11726,"@Override public void generate(){
  load();
}","@Override public void generate(){
  apply();
}"
11727,"@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn) {
    ThreadsHandler.chunkExecutor().execute(() -> {
      for (int i=0; i < CLEAN_ITERATIONS; i++) {
        if (knownChunks.size() > MAX_CHUNKS)         cleanChunks(distance - i);
      }
    }
);
    if (ticksExisted.get() % 20 == 0) {
      ThreadsHandler.chunkExecutor().execute(() -> sendChunks(distance));
    }
  }
  connection.tick();
}","@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn) {
    ThreadsHandler.chunkExecutor().execute(() -> {
      for (int i=0; i < CLEAN_ITERATIONS; i++) {
        int size=knownChunks.size();
        if (size > MAX_CHUNKS)         cleanChunks(distance - i,size);
      }
    }
);
    if (ticksExisted.get() % 20 == 0) {
      ThreadsHandler.chunkExecutor().execute(() -> sendChunks(distance));
    }
  }
  connection.tick();
}"
11728,"public void cleanChunks(int viewDist){
  Position pos=position();
  int x=(int)pos.x() / 16;
  int z=(int)pos.z() / 16;
  int count=counter.getAndIncrement();
  int size=knownChunks.size();
  if (count >= size / MAX_PARTITION_SIZE) {
    count=0;
    counter.set(0);
  }
  List<ChunkLocation> partition=Iterators.get(Iterators.partition(knownChunks.iterator(),MAX_PARTITION_SIZE),count);
  for (  ChunkLocation location : partition) {
    int cx=location.x();
    int cz=location.z();
    int abs=Math.max(cx,x) - Math.min(cx,x);
    int abs1=Math.max(cz,z) - Math.min(cz,z);
    if (abs >= viewDist || abs1 >= viewDist) {
      removeChunk(location,true);
    }
  }
}","public void cleanChunks(int viewDist,int size){
  Position pos=position();
  int x=(int)pos.x() / 16;
  int z=(int)pos.z() / 16;
  int removed=0;
  for (  ChunkLocation location : knownChunks) {
    if (MAX_CHUNKS > (size - removed))     return;
    int cx=location.x();
    int cz=location.z();
    int abs=Math.max(cx,x) - Math.min(cx,x);
    int abs1=Math.max(cz,z) - Math.min(cz,z);
    if (abs >= viewDist || abs1 >= viewDist) {
      removeChunk(location,true);
      removed++;
    }
  }
}"
11729,"@Override public char[][] generateChunkBlocks(final ChunkLocation location,AtomicReferenceArray<Integer> heights){
  final char[][] data=new char[16][ChunkSection.LENGTH];
  final CountDownLatch release=new CountDownLatch(16);
  for (int x=0; x < 16; x++) {
    final int finalX=x;
    executor.execute(() -> {
      for (int z=0; z < 16; z++) {
        final int i=WorldUtils.intScale(0,140,generator.noise(finalX + (location.x() << 4),z + (location.z() << 4))) - 20;
        heights.set(WorldUtils.heightIndex(finalX,z),i - 1);
        for (int y=0; y < i; y++) {
          if (i < 40 && y == (i - 1)) {
            for (int rev=40; rev > i; rev--) {
              data[rev / 16][WorldUtils.blockArrayIndex(finalX,rev % 16,z)]=Substance.WATER.asExtended();
            }
            data[i / 16][WorldUtils.blockArrayIndex(finalX,i % 16,z)]=Substance.CLAY.asExtended();
            continue;
          }
          if (y < i - 1) {
            data[y / 16][WorldUtils.blockArrayIndex(finalX,y % 16,z)]=Substance.DIRT.asExtended();
          }
 else {
            data[y / 16][WorldUtils.blockArrayIndex(finalX,y % 16,z)]=Substance.GRASS.asExtended();
          }
        }
      }
      release.countDown();
    }
);
  }
  try {
    release.await();
  }
 catch (  InterruptedException e) {
    TridentLogger.get().error(e);
    return null;
  }
  return data;
}","@Override public char[][] generateChunkBlocks(final ChunkLocation location,AtomicReferenceArray<Integer> heights){
  final char[][] data=new char[16][ChunkSection.LENGTH];
  final CountDownLatch release=new CountDownLatch(16);
  for (int x=0; x < 16; x++) {
    final int finalX=x;
    executor.execute(() -> {
      for (int z=0; z < 16; z++) {
        final int i=WorldUtils.intScale(0,140,generator.noise(finalX + (location.x() << 4),z + (location.z() << 4))) - 20;
        heights.set(WorldUtils.heightIndex(finalX,z),i);
        if (i < 40) {
          for (int j=i; j <= 40; j++) {
            data[j / 16][WorldUtils.blockArrayIndex(finalX,j % 16,z)]=Substance.WATER.asExtended();
          }
        }
        for (int y=0; y <= i; y++) {
          if (i < 40) {
            if (y == i) {
              data[y / 16][WorldUtils.blockArrayIndex(finalX,y % 16,z)]=Substance.SAND.asExtended();
              continue;
            }
          }
          if (y == i) {
            data[y / 16][WorldUtils.blockArrayIndex(finalX,i % 16,z)]=Substance.GRASS.asExtended();
          }
 else           data[y / 16][WorldUtils.blockArrayIndex(finalX,y % 16,z)]=Substance.DIRT.asExtended();
        }
      }
      release.countDown();
    }
);
  }
  try {
    release.await();
  }
 catch (  InterruptedException e) {
    TridentLogger.get().error(e);
    return null;
  }
  return data;
}"
11730,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  World world=player.world();
  StatusType type=StatusType.getStatus((int)this.actionId);
switch (type) {
case RESPAWN:
    PacketPlayOutPlayerRespawn respawn=new PacketPlayOutPlayerRespawn();
  respawn.set(""String_Node_Str"",(int)world.dimension().asByte()).set(""String_Node_Str"",(int)world.difficulty().asByte()).set(""String_Node_Str"",(int)world.defaultGameMode().asByte());
connection.sendPacket(respawn);
break;
case STATISTICS_REQUEST:
PacketPlayOutStatistics statistics=new PacketPlayOutStatistics();
statistics.set(""String_Node_Str"",null);
connection.sendPacket(statistics);
break;
case OPEN_INVENTORY_ACHEIVEMENT:
break;
default :
TridentLogger.get().error(new IllegalArgumentException(""String_Node_Str""));
}
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  World world=player.world();
  StatusType type=StatusType.getStatus((int)this.actionId);
switch (type) {
case RESPAWN:
    PacketPlayOutPlayerRespawn respawn=new PacketPlayOutPlayerRespawn();
  respawn.set(""String_Node_Str"",(int)world.settings().dimension().asByte()).set(""String_Node_Str"",(int)world.settings().difficulty().asByte()).set(""String_Node_Str"",(int)world.settings().defaultGameMode().asByte());
connection.sendPacket(respawn);
break;
case STATISTICS_REQUEST:
PacketPlayOutStatistics statistics=new PacketPlayOutStatistics();
statistics.set(""String_Node_Str"",null);
connection.sendPacket(statistics);
break;
case OPEN_INVENTORY_ACHEIVEMENT:
break;
default :
TridentLogger.get().error(new IllegalArgumentException(""String_Node_Str""));
}
}"
11731,"public static TridentPlayer spawnPlayer(ClientConnection connection,UUID id,String name){
  CompoundTag playerTag=OfflinePlayer.getOfflinePlayer(id) == null ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (playerTag == null) {
    playerTag=OfflinePlayer.generatePlayer(id);
  }
  TridentPlayer p=new TridentPlayer(id,playerTag,TridentServer.WORLD,connection);
  p.executor=ThreadsHandler.playerExecutor();
  ONLINE_PLAYERS.put(id,p);
  p.name=name;
  p.gameMode=GameMode.CREATIVE;
  p.executor.execute(() -> {
    p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.entityId()).set(""String_Node_Str"",p.gameMode).set(""String_Node_Str"",p.world().dimension()).set(""String_Node_Str"",p.world().difficulty()).set(""String_Node_Str"",(short)Trident.config().getInt(""String_Node_Str"")).set(""String_Node_Str"",LevelType.DEFAULT));
    p.abilities.creative=1;
    p.abilities.flySpeed=0.135F;
    p.abilities.canFly=1;
    p.spawnPosition=TridentServer.WORLD.spawnPosition();
    p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
    p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.world().difficulty()));
    p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.spawnLocation()));
    p.connection.sendPacket(p.abilities.asPacket());
    p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.spawnLocation()).set(""String_Node_Str"",(byte)0));
    sendAll(new PacketPlayOutPlayerListItem().set(""String_Node_Str"",0).set(""String_Node_Str"",new PlayerListDataBuilder[]{p.listData()}));
    List<PlayerListDataBuilder> builders=new ArrayList<>();
    players().stream().filter(player -> !player.equals(p)).forEach(player -> builders.add(((TridentPlayer)player).listData()));
    TridentLogger.get().log(p.name + ""String_Node_Str"");
    p.connection.sendPacket(new PacketPlayOutPlayerListItem().set(""String_Node_Str"",0).set(""String_Node_Str"",builders.stream().toArray(value -> new PlayerListDataBuilder[value])));
  }
);
  return p;
}","public static TridentPlayer spawnPlayer(ClientConnection connection,UUID id,String name){
  CompoundTag playerTag=OfflinePlayer.getOfflinePlayer(id) == null ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (playerTag == null) {
    playerTag=OfflinePlayer.generatePlayer(id);
  }
  TridentPlayer p=new TridentPlayer(id,playerTag,TridentServer.WORLD,connection);
  p.executor=ThreadsHandler.playerExecutor();
  ONLINE_PLAYERS.put(id,p);
  p.name=name;
  p.gameMode=GameMode.CREATIVE;
  p.executor.execute(() -> {
    p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.entityId()).set(""String_Node_Str"",p.gameMode).set(""String_Node_Str"",p.world().settings().dimension()).set(""String_Node_Str"",p.world().settings().difficulty()).set(""String_Node_Str"",(short)Trident.config().getInt(""String_Node_Str"")).set(""String_Node_Str"",LevelType.DEFAULT));
    p.abilities.creative=1;
    p.abilities.flySpeed=0.135F;
    p.abilities.canFly=1;
    p.spawnPosition=TridentServer.WORLD.spawnPosition();
    p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
    p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.world().settings().difficulty()));
    p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.spawnLocation()));
    p.connection.sendPacket(p.abilities.asPacket());
    p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.spawnLocation()).set(""String_Node_Str"",(byte)0));
    sendAll(new PacketPlayOutPlayerListItem().set(""String_Node_Str"",0).set(""String_Node_Str"",new PlayerListDataBuilder[]{p.listData()}));
    List<PlayerListDataBuilder> builders=new ArrayList<>();
    players().stream().filter(player -> !player.equals(p)).forEach(player -> builders.add(((TridentPlayer)player).listData()));
    TridentLogger.get().log(p.name + ""String_Node_Str"");
    p.connection.sendPacket(new PacketPlayOutPlayerListItem().set(""String_Node_Str"",0).set(""String_Node_Str"",builders.stream().toArray(value -> new PlayerListDataBuilder[value])));
  }
);
  return p;
}"
11732,"TridentWorld(String name,WorldLoader loader){
  ((TridentWorldLoader)loader).world=this;
  this.name=name;
  this.loader=loader;
  this.spawnPosition=Position.create(this,0,0,0);
  TridentLogger.get().log(""String_Node_Str"" + name + ""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  InputStream fis=null;
  try {
    fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    CompoundTag level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    spawnPosition.setX(((IntTag)level.getTag(""String_Node_Str"")).value());
    spawnPosition.setY(((IntTag)level.getTag(""String_Node_Str"")).value() + 5);
    spawnPosition.setZ(((IntTag)level.getTag(""String_Node_Str"")).value());
    dimension=Dimension.OVERWORLD;
    difficulty=Difficulty.NORMAL;
    defaultGamemode=GameMode.of(((IntTag)level.getTag(""String_Node_Str"")).value());
    type=LevelType.of(((StringTag)level.getTag(""String_Node_Str"")).value());
    seed=((LongTag)level.getTag(""String_Node_Str"")).value();
    ((TridentWorldLoader)loader).setGenerator(seed);
    random=new GeneratorRandom(seed);
    borderSize=level.containsTag(""String_Node_Str"") ? ((DoubleTag)level.getTag(""String_Node_Str"")).value() : 6000;
    time.set(((LongTag)level.getTag(""String_Node_Str"")).value());
    existed.set(((LongTag)level.getTag(""String_Node_Str"")).value());
    raining=((ByteTag)level.getTag(""String_Node_Str"")).value() == 1;
    rainTime.set(((IntTag)level.getTag(""String_Node_Str"")).value());
    thundering=((ByteTag)level.getTag(""String_Node_Str"")).value() == 1;
    thunderTime.set(((IntTag)level.getTag(""String_Node_Str"")).value());
    difficultyLocked=level.containsTag(""String_Node_Str"") && ((ByteTag)level.getTag(""String_Node_Str"")).value() == 1;
    WorldCreateOptions options=loader.options();
    options.dimension(dimension).difficulty(difficulty).gameMode(defaultGamemode).level(type).rule(gameRules).generator(null).structures(generateStructures).pvp(true).seed(String.valueOf(seed));
    TridentLogger.get().success(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    TridentLogger.get().error(new IllegalArgumentException(""String_Node_Str"" + name));
    return;
  }
catch (  Exception ex) {
    TridentLogger.get().error(""String_Node_Str"");
    TridentLogger.get().error(ex);
    return;
  }
 finally {
    settings=TridentWorldSettings.load(this,loader.options());
    try {
      if (fis != null) {
        fis.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    TridentLogger.get().error(new IllegalStateException(""String_Node_Str""));
    return;
  }
  TridentLogger.get().success(""String_Node_Str"");
  TridentLogger.get().log(""String_Node_Str"");
  int centX=((int)Math.floor(spawnPosition.x())) >> 4;
  int centZ=((int)Math.floor(spawnPosition.z())) >> 4;
  for (  ChunkLocation location : new ChunkAxisAlignedBoundingBox(ChunkLocation.create(centX - 3,centZ - 3),ChunkLocation.create(centX + 3,centZ + 3))) {
    chunkAt(location,true);
  }
  TridentLogger.get().success(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    TridentLogger.get().warn(""String_Node_Str"");
    playerData.mkdir();
  }
}","TridentWorld(String name,WorldLoader loader){
  ((TridentWorldLoader)loader).world=this;
  this.name=name;
  this.loader=loader;
  this.spawnPosition=Position.create(this,0,0,0);
  TridentLogger.get().log(""String_Node_Str"" + name + ""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  InputStream fis=null;
  try {
    fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    CompoundTag level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    spawnPosition.setX(((IntTag)level.getTag(""String_Node_Str"")).value());
    spawnPosition.setY(((IntTag)level.getTag(""String_Node_Str"")).value() + 5);
    spawnPosition.setZ(((IntTag)level.getTag(""String_Node_Str"")).value());
    dimension=Dimension.OVERWORLD;
    difficulty=Difficulty.NORMAL;
    defaultGamemode=GameMode.of(((IntTag)level.getTag(""String_Node_Str"")).value());
    type=LevelType.of(((StringTag)level.getTag(""String_Node_Str"")).value());
    seed=((LongTag)level.getTag(""String_Node_Str"")).value();
    ((TridentWorldLoader)loader).setGenerator(seed);
    random=new GeneratorRandom(seed);
    borderSize=level.containsTag(""String_Node_Str"") ? ((DoubleTag)level.getTag(""String_Node_Str"")).value() : 6000;
    time.set(((LongTag)level.getTag(""String_Node_Str"")).value());
    existed.set(((LongTag)level.getTag(""String_Node_Str"")).value());
    raining=((ByteTag)level.getTag(""String_Node_Str"")).value() == 1;
    rainTime.set(((IntTag)level.getTag(""String_Node_Str"")).value());
    thundering=((ByteTag)level.getTag(""String_Node_Str"")).value() == 1;
    thunderTime.set(((IntTag)level.getTag(""String_Node_Str"")).value());
    difficultyLocked=level.containsTag(""String_Node_Str"") && ((ByteTag)level.getTag(""String_Node_Str"")).value() == 1;
    WorldCreateOptions options=loader.options();
    options.dimension(dimension).difficulty(difficulty).gameMode(defaultGamemode).level(type).generator(null).structures(generateStructures).pvp(true).seed(String.valueOf(seed));
    gameRules.forEach(options::rule);
    TridentLogger.get().success(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    TridentLogger.get().error(new IllegalArgumentException(""String_Node_Str"" + name));
    return;
  }
catch (  Exception ex) {
    TridentLogger.get().error(""String_Node_Str"");
    TridentLogger.get().error(ex);
    return;
  }
 finally {
    settings=TridentWorldSettings.load(this,loader.options());
    try {
      if (fis != null) {
        fis.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    TridentLogger.get().error(new IllegalStateException(""String_Node_Str""));
    return;
  }
  TridentLogger.get().success(""String_Node_Str"");
  TridentLogger.get().log(""String_Node_Str"");
  int centX=((int)Math.floor(spawnPosition.x())) >> 4;
  int centZ=((int)Math.floor(spawnPosition.z())) >> 4;
  for (  ChunkLocation location : new ChunkAxisAlignedBoundingBox(ChunkLocation.create(centX - 3,centZ - 3),ChunkLocation.create(centX + 3,centZ + 3))) {
    chunkAt(location,true);
  }
  TridentLogger.get().success(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    TridentLogger.get().warn(""String_Node_Str"");
    playerData.mkdir();
  }
}"
11733,"public TridentWorldLoader(){
  this.opt=new WorldCreateOptions();
}","public TridentWorldLoader(){
  this.opt=new WorldCreateOptions();
  this.opt.generator(DefaultWorldGen.class);
}"
11734,"@Override public WorldCreateOptions options(){
  return null;
}","@Override public WorldCreateOptions options(){
  return opt;
}"
11735,"@Override public long seed(){
  return 0;
}","@Override public long seed(){
  return seed;
}"
11736,"@Override public Difficulty difficulty(){
  return null;
}","@Override public Difficulty difficulty(){
  return difficulty;
}"
11737,"@Override public LevelType levelType(){
  return null;
}","@Override public LevelType levelType(){
  return levelType;
}"
11738,"@Override public Dimension dimension(){
  return null;
}","@Override public Dimension dimension(){
  return dimension;
}"
11739,"public void releaseStrong(){
  strongRefs.decrement();
  if (strongRefs.sum() < 0L)   throw new IllegalStateException(""String_Node_Str"");
}","public void releaseStrong(){
  strongRefs.decrement();
  wrapped.world().chunkHandler().tryRemove(wrapped.location());
  if (strongRefs.sum() < 0L)   throw new IllegalStateException(""String_Node_Str"");
}"
11740,"/** 
 * Obtains the amount of loaded chunks
 * @return the amount of loaded chunks
 */
public int size(){
  return counters.size();
}","/** 
 * Obtains the amount of loaded chunks
 * @return the amount of loaded chunks
 */
public int size(){
synchronized (counters) {
    return counters.size();
  }
}"
11741,"/** 
 * Obtains the chunk reference counter and applies a transformation function
 * @param location the location or obtain the chunk reference counter
 * @param consumer the transformation function
 * @return {@code true} to indicate that the chunk was successfully retrieved and transformed
 */
public boolean apply(ChunkLocation location,Consumer<CRefCounter> consumer){
  CRefCounter chunk=counters.get(location);
  if (chunk != null) {
    consumer.accept(chunk);
    return true;
  }
  return false;
}","/** 
 * Obtains the chunk reference counter and applies a transformation function
 * @param location the location or obtain the chunk reference counter
 * @param consumer the transformation function
 * @return {@code true} to indicate that the chunk was successfully retrieved and transformed
 */
public boolean apply(ChunkLocation location,Consumer<CRefCounter> consumer){
  CRefCounter chunk=get(location);
  if (chunk != null) {
    consumer.accept(chunk);
    return true;
  }
  return false;
}"
11742,"/** 
 * Attempts to remove the chunk from memory and save it <p>This method returns   {@code false} if:<ul> <li>The chunk is not loaded</li> <li>The chunk still has strong references</li> </ul></p>
 * @param location the location to remove the chunk
 * @return {@code true} to signify that the collection was modified as a result of this operation
 */
public boolean tryRemove(ChunkLocation location){
  if (location.x() < 7 && location.z() < 7) {
    return true;
  }
  CRefCounter chunk=counters.get(location);
  if (chunk == null) {
    return false;
  }
  if (!chunk.hasStrongRefs()) {
    TridentChunk c=chunk.unwrap();
    if (chunk.hasWeakRefs()) {
    }
    remove(location);
    c.unload();
    return true;
  }
  return false;
}","/** 
 * Attempts to remove the chunk from memory and save it <p>This method returns   {@code false} if:<ul> <li>The chunk is not loaded</li> <li>The chunk still has strong references</li> </ul></p>
 * @param location the location to remove the chunk
 * @return {@code true} to signify that the collection was modified as a result of this operation
 */
public boolean tryRemove(ChunkLocation location){
  if (location.x() < 7 && location.z() < 7) {
    return true;
  }
  CRefCounter chunk=get(location);
  if (chunk == null) {
    return false;
  }
  if (!chunk.hasStrongRefs()) {
    TridentChunk c=chunk.unwrap();
    if (chunk.hasWeakRefs()) {
    }
    c.unload();
    remove(location);
    return true;
  }
  return false;
}"
11743,"/** 
 * Obtains the set of chunk locations that have already been loaded
 * @return the set of loaded chunk locations
 */
public Set<ChunkLocation> keys(){
  return counters.keySet();
}","/** 
 * Obtains the set of chunk locations that have already been loaded
 * @return the set of loaded chunk locations
 */
public Set<ChunkLocation> keys(){
synchronized (counters) {
    return counters.keySet();
  }
}"
11744,"/** 
 * Obtains the chunk at the given location in the world, generating if given to do so
 * @param location the location to obtain the chunk
 * @param gen      {@code true} to generate a new chunk if no chunk exists
 * @return the chunk at the given location, or {@code null} if it doesn't exist and {@code gen} is false
 */
public TridentChunk get(ChunkLocation location,boolean gen){
  if (gen) {
    return counters.computeIfAbsent(location,k -> CRefCounter.wrap(world.generateChunk(k))).unwrap();
  }
 else {
    CRefCounter refCounter=counters.get(location);
    return refCounter == null ? null : refCounter.unwrap();
  }
}","/** 
 * Obtains the chunk reference counter at the specified location
 * @param location the location to obtain the counter
 * @return the counter at the location, or {@code null} if it doesn't exist
 */
public CRefCounter get(ChunkLocation location){
synchronized (counters) {
    return counters.get(location);
  }
}"
11745,"/** 
 * Obtains the chunks that have been loaded into memory
 * @return the collection of loaded in-memory chunks
 */
public Collection<TridentChunk> values(){
  Collection<TridentChunk> chunks=Lists.newArrayList();
  counters.values().stream().forEach(c -> chunks.add(c.unwrap()));
  return chunks;
}","/** 
 * Obtains the chunks that have been loaded into memory
 * @return the collection of loaded in-memory chunks
 */
public Collection<TridentChunk> values(){
  Collection<TridentChunk> chunks=Lists.newArrayList();
synchronized (counters) {
    counters.values().stream().forEach(c -> chunks.add(c.unwrap()));
  }
  return chunks;
}"
11746,"/** 
 * Places a chunk into the collection of in-memory chunks
 * @param chunk the chunk to add
 */
public void put(TridentChunk chunk){
  counters.put(chunk.location(),CRefCounter.wrap(chunk));
}","/** 
 * Places a chunk into the collection of in-memory chunks
 * @param chunk the chunk to add
 */
public void put(TridentChunk chunk){
synchronized (counters) {
    counters.put(chunk.location(),CRefCounter.wrap(chunk));
  }
}"
11747,"/** 
 * Manually removes the chunk from the collection without running any cleanup code
 * @param location the location to remove the chunk from
 */
public void remove(ChunkLocation location){
  counters.remove(location);
}","/** 
 * Manually removes the chunk from the collection without running any cleanup code
 * @param location the location to remove the chunk from
 */
public void remove(ChunkLocation location){
synchronized (counters) {
    counters.remove(location);
  }
}"
11748,"@Policy(""String_Node_Str"") private void clean0(int viewDist,int size){
  Position pos=player.position();
  int x=(int)pos.x() / 16;
  int z=(int)pos.z() / 16;
  int removed=0;
  for (  ChunkLocation location : knownChunks) {
    if (MAX_CHUNKS > size - removed)     return;
    int cx=location.x();
    int cz=location.z();
    int abs=Math.max(cx,x) - Math.min(cx,x);
    int abs1=Math.max(cz,z) - Math.min(cz,z);
    if (abs >= viewDist || abs1 >= viewDist) {
      player.connection().sendPacket(new PacketPlayOutChunkData(new byte[0],location,true,(short)0));
      knownChunks.remove(location);
      removed++;
    }
  }
}","@Policy(""String_Node_Str"") private void clean0(int viewDist){
  Position pos=player.position();
  int x=(int)pos.x() / 16;
  int z=(int)pos.z() / 16;
  for (Iterator<ChunkLocation> locs=knownChunks.iterator(); locs.hasNext(); ) {
    ChunkLocation location=locs.next();
    int cx=location.x();
    int cz=location.z();
    int abs=Math.max(cx,x) - Math.min(cx,x);
    int abs1=Math.max(cz,z) - Math.min(cz,z);
    if (abs >= viewDist || abs1 >= viewDist) {
      player.connection().sendPacket(new PacketPlayOutChunkData(new byte[0],location,true,(short)0));
      locs.remove();
      world.chunkHandler().apply(location,CRefCounter::releaseStrong);
    }
  }
}"
11749,"public void update(int viewDistance){
  int centX=(int)Math.floor(player.position().x()) >> 4;
  int centZ=(int)Math.floor(player.position().z()) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  HashSet<TridentChunk> set=new HashSet<>();
synchronized (knownChunks) {
    for (int x=centX - viewDistance / 2; x <= centX + viewDistance / 2; x+=1) {
      for (int z=centZ - viewDistance / 2; z <= centZ + viewDistance / 2; z+=1) {
        for (int i=x - 1; i <= x + 1; i++) {
          for (int j=z - 1; j <= z + 1; j++) {
            ChunkLocation loc=ChunkLocation.create(i,j);
            if (knownChunks.contains(loc))             continue;
            TridentChunk chunk=world.chunkAt(loc,true);
            if (i == x && j == z) {
              set.add(chunk);
            }
          }
        }
      }
    }
    for (    TridentChunk chunk : set) {
      if (knownChunks.add(chunk.location())) {
        bulk.addEntry(chunk.asPacket());
      }
      if (bulk.size() >= 1845152) {
        player.connection().sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
      }
    }
    if (bulk.hasEntries()) {
      player.connection().sendPacket(bulk);
    }
  }
}","public void update(int viewDistance){
  int centX=(int)Math.floor(player.position().x()) >> 4;
  int centZ=(int)Math.floor(player.position().z()) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
synchronized (knownChunks) {
    for (int x=centX - viewDistance / 2; x <= centX + viewDistance / 2; x+=1) {
      for (int z=centZ - viewDistance / 2; z <= centZ + viewDistance / 2; z+=1) {
        TridentChunk center=null;
        for (int i=x - 1; i <= x + 1; i++) {
          for (int j=z - 1; j <= z + 1; j++) {
            ChunkLocation loc=ChunkLocation.create(i,j);
            if (knownChunks.contains(loc))             continue;
            TridentChunk chunk=world.chunkAt(loc,true);
            if (i == x && j == z) {
              center=chunk;
            }
          }
        }
        if (center != null) {
          ChunkLocation location=center.location();
          if (!knownChunks.add(location))           continue;
          world.chunkHandler().apply(location,CRefCounter::refStrong);
          bulk.addEntry(center.asPacket());
          if (bulk.size() >= 1845152) {
            player.connection().sendPacket(bulk);
            bulk=new PacketPlayOutMapChunkBulk();
          }
        }
      }
    }
    if (bulk.hasEntries()) {
      player.connection().sendPacket(bulk);
    }
  }
}"
11750,"public void clean(int distance){
synchronized (knownChunks) {
    for (int i=0; i < CLEAN_ITERATIONS; i++) {
      int size=knownChunks.size();
      if (size > MAX_CHUNKS) {
        clean0(distance,size);
      }
    }
  }
}","public void clean(int distance){
synchronized (knownChunks) {
    for (int i=0; i < CLEAN_ITERATIONS; i++) {
      int size=knownChunks.size();
      if (size > MAX_CHUNKS) {
        clean0(distance);
      }
    }
  }
}"
11751,"@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn) {
    ThreadsHandler.chunkExecutor().execute(() -> {
      knownChunks.clean(distance);
      knownChunks.update(distance);
    }
);
  }
  connection.tick();
}","@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn) {
    ThreadsHandler.chunkExecutor().execute(() -> {
      if (ticksExisted.get() % 20 == 0) {
        knownChunks.update(distance);
        return;
      }
      knownChunks.clean(distance);
      knownChunks.update(distance);
    }
);
  }
  connection.tick();
}"
11752,"@Override public void unload(){
  sections.lockFully();
  try {
    world.loader().saveChunk(this);
    world.chunkHandler().remove(location);
  }
  finally {
    sections.release();
  }
}","@Override public void unload(){
  sections.lockFully();
  try {
    ChunkHandler chunkHandler=world.chunkHandler();
    if (chunkHandler.get(location).hasStrongRefs()) {
      return;
    }
    world.loader().saveChunk(this);
    chunkHandler.remove(location);
  }
  finally {
    sections.release();
  }
}"
11753,"public void tick(){
  ThreadsHandler.worldExecutor().execute(() -> {
    redstoneTick=!redstoneTick;
    long currentTime=time.get();
    rainTime.getAndDecrement();
    thunderTime.getAndDecrement();
    if (rainTime.get() <= 0) {
      raining=!raining;
      if (raining) {
        RainEvent e=EventProcessor.fire(new RainEvent(this));
        if (e.isIgnored()) {
          raining=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          raining=true;
        }
      }
      rainTime.set(ThreadLocalRandom.current().nextInt());
    }
    if (thunderTime.get() <= 0) {
      thundering=!thundering;
      if (thundering) {
        ThunderEvent e=EventProcessor.fire(new ThunderEvent(this));
        if (e.isIgnored()) {
          thundering=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          thundering=true;
        }
      }
      thunderTime.set(ThreadLocalRandom.current().nextInt());
    }
    boolean updateTime=(currentTime & 40) == 0;
    for (    Entity entity : entities) {
      TickSync.increment(""String_Node_Str"" + entity.uniqueId().toString() + ""String_Node_Str""+ entity.entityId()+ ""String_Node_Str""+ entity.type());
      ((TridentEntity)entity).tick();
      if (entity instanceof Player) {
        TridentPlayer player=(TridentPlayer)entity;
        if (updateTime) {
          player.connection().sendPacket(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed.get()).set(""String_Node_Str"",currentTime));
        }
      }
    }
    if ((currentTime & CHUNK_EVICTION_TIME) == 0) {
      UnmodifiableIterator<List<ChunkLocation>> list=Iterators.partition(chunkHandler.keys().iterator(),Math.max(TridentPlayer.players().size(),1));
      for (; list.hasNext(); ) {
        List<ChunkLocation> chunks=list.next();
        ThreadsHandler.chunkExecutor().execute(() -> chunks.forEach(chunkHandler::tryRemove));
      }
    }
    if (currentTime >= 24000)     time.set(0);
 else     time.getAndIncrement();
    existed.getAndIncrement();
    TickSync.complete(""String_Node_Str"" + name());
  }
);
}","public void tick(){
  ThreadsHandler.worldExecutor().execute(() -> {
    redstoneTick=!redstoneTick;
    long currentTime=time.get();
    rainTime.getAndDecrement();
    thunderTime.getAndDecrement();
    if (rainTime.get() <= 0) {
      raining=!raining;
      if (raining) {
        RainEvent e=EventProcessor.fire(new RainEvent(this));
        if (e.isIgnored()) {
          raining=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          raining=true;
        }
      }
      rainTime.set(ThreadLocalRandom.current().nextInt());
    }
    if (thunderTime.get() <= 0) {
      thundering=!thundering;
      if (thundering) {
        ThunderEvent e=EventProcessor.fire(new ThunderEvent(this));
        if (e.isIgnored()) {
          thundering=false;
        }
      }
 else {
        SunEvent event=EventProcessor.fire(new SunEvent(this));
        if (event.isIgnored()) {
          thundering=true;
        }
      }
      thunderTime.set(ThreadLocalRandom.current().nextInt());
    }
    boolean updateTime=(currentTime & 40) == 0;
    for (    Entity entity : entities) {
      TickSync.increment(""String_Node_Str"" + entity.uniqueId().toString() + ""String_Node_Str""+ entity.entityId()+ ""String_Node_Str""+ entity.type());
      ((TridentEntity)entity).tick();
      if (entity instanceof Player) {
        TridentPlayer player=(TridentPlayer)entity;
        if (updateTime) {
          player.connection().sendPacket(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed.get()).set(""String_Node_Str"",currentTime));
        }
      }
    }
    if (currentTime >= 24000)     time.set(0);
 else     time.getAndIncrement();
    existed.getAndIncrement();
    TickSync.complete(""String_Node_Str"" + name());
  }
);
}"
11754,"public void doRun() throws InterruptedException {
  long startTime=System.currentTimeMillis();
  this.ticksElapsed.getAndIncrement();
  if (this.pausedTicking) {
    this.calcAndWait(0);
    return;
  }
  if (this.ticksToWait.get() > 0) {
    this.ticksToWait.getAndDecrement();
    this.calcAndWait(0);
    return;
  }
  this.notLostTicksElapsed.getAndIncrement();
  for (  World world : Registered.worlds().values()) {
    TickSync.increment(""String_Node_Str"" + world.name());
    ((TridentWorld)world).tick();
  }
  ((TridentTaskScheduler)Registered.tasks()).tick();
  TickSync.awaitSync();
  long time;
  while ((time=System.currentTimeMillis() - startTime) < tickLength) {
    Runnable next=TickSync.waitForTask(TimeUnit.NANOSECONDS.convert(time,TimeUnit.NANOSECONDS));
    if (next != null) {
      Registered.plugins().executor().execute(next);
    }
  }
  if (!FINISH_TASKS_LEFT) {
    int left=TickSync.left();
    if (left > 0) {
      TridentLogger.get().warn(""String_Node_Str"" + left + ""String_Node_Str"");
    }
  }
 else {
    while (TickSync.left() > 0) {
      Runnable runnable=TickSync.next();
      if (runnable != null)       runnable.run();
    }
  }
  TickSync.reset();
  recentTickLength.add((int)(System.currentTimeMillis() - startTime));
}","public void doRun() throws InterruptedException {
  long startTime=System.currentTimeMillis();
  this.ticksElapsed.getAndIncrement();
  if (this.pausedTicking) {
    this.calcAndWait(0);
    return;
  }
  if (this.ticksToWait.get() > 0) {
    this.ticksToWait.getAndDecrement();
    this.calcAndWait(0);
    return;
  }
  this.notLostTicksElapsed.getAndIncrement();
  for (  World world : TridentWorldLoader.WORLDS.values()) {
    TickSync.increment(""String_Node_Str"" + world.name());
    ((TridentWorld)world).tick();
  }
  ((TridentTaskScheduler)Registered.tasks()).tick();
  TickSync.awaitSync();
  long time;
  while ((time=System.currentTimeMillis() - startTime) < tickLength) {
    Runnable next=TickSync.waitForTask(TimeUnit.NANOSECONDS.convert(time,TimeUnit.NANOSECONDS));
    if (next != null) {
      Registered.plugins().executor().execute(next);
    }
  }
  if (!FINISH_TASKS_LEFT) {
    int left=TickSync.left();
    if (left > 0) {
      TridentLogger.get().warn(""String_Node_Str"" + left + ""String_Node_Str"");
    }
  }
 else {
    while (TickSync.left() > 0) {
      Runnable runnable=TickSync.next();
      if (runnable != null)       runnable.run();
    }
  }
  TickSync.reset();
  recentTickLength.add((int)(System.currentTimeMillis() - startTime));
}"
11755,"public boolean initLogin(InetSocketAddress address,String name){
synchronized (this) {
    if (loginNames.size() + Registered.players().size() >= Trident.info().maxPlayers()) {
      return false;
    }
    loginNames.put(address,name);
    return true;
  }
}","public boolean initLogin(InetSocketAddress address,String name){
synchronized (this) {
    return loginNames.size() + Registered.players().size() < Trident.info().maxPlayers() && loginNames.put(address,name) == null;
  }
}"
11756,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  location.setWorld(player.world());
  Block clickAt=location.block();
  if (location.y() < 255 && location.block() != null && clickAt.substance().isFunctional() && !player.isCrouching()) {
switch (clickAt.substance()) {
case FURNACE:
case BURNING_FURNACE:
      ((FurnaceMetaImpl)clickAt.obtainMeta(FurnaceMeta.class)).furnaceInventory().sendTo(player);
    break;
case CHEST:
  ((TridentInventory)clickAt.obtainMeta(ChestMeta.class).inventory()).sendTo(player);
break;
}
}
 else if (player.heldItem() != null && player.heldItem().type() != Substance.AIR) {
Substance substance=player.heldItem().type();
Vector vector=determineOffset();
if (!substance.isBlock()) {
return;
}
if (location.y() + vector.y() > 255 || location.y() + vector.y() < 0) {
return;
}
Position position=clickAt.substance().canBeReplaced() ? location : location.relative(vector);
Block block=new OwnedTridentBlock(player,position.block());
short yaw=(short)(player.position().yaw() * 10);
short meta=player.heldItem().damageValue();
Value<Byte> result=Value.of((byte)0);
Value<Substance> substanceValue=Value.of(substance);
boolean allow=MetaFactory.decode(block,substanceValue,new byte[]{writeFirst(yaw),writeSecond(yaw),direction,((byte)cursorPosition.x()),((byte)cursorPosition.y()),((byte)cursorPosition.z()),writeFirst(meta),writeSecond(meta)},result);
if (allow) {
block.setSubstanceAndMeta(substanceValue.get(),result.get());
SoundEffectType soundEffectType=substanceValue.get().placeSound();
if (soundEffectType != null) {
SoundEffect sound=location.world().playSound(soundEffectType);
sound.setPosition(location);
sound.apply();
}
}
}
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  location.setWorld(player.world());
  Substance substance=player.heldItem().type();
  Vector vector=determineOffset();
  if (!substance.isBlock()) {
    return;
  }
  if (location.y() + vector.y() > 255 || location.y() + vector.y() < 0) {
    return;
  }
  Position position=location.block().substance().canBeReplaced() ? location : location.relative(vector);
  Block block=new OwnedTridentBlock(player,position.block());
  if (location.y() < 255 && location.block() != null && block.substance().isFunctional() && !player.isCrouching()) {
switch (block.substance()) {
case FURNACE:
case BURNING_FURNACE:
      ((FurnaceMetaImpl)block.obtainMeta(FurnaceMeta.class)).furnaceInventory().sendTo(player);
    break;
case CHEST:
  ((TridentInventory)block.obtainMeta(ChestMeta.class).inventory()).sendTo(player);
break;
}
}
 else if (player.heldItem() != null && player.heldItem().type() != Substance.AIR) {
System.out.println(position);
short yaw=(short)(player.position().yaw() * 10);
short meta=player.heldItem().damageValue();
Value<Byte> result=Value.of((byte)0);
Value<Substance> substanceValue=Value.of(substance);
boolean allow=MetaFactory.decode(block,substanceValue,new byte[]{writeFirst(yaw),writeSecond(yaw),direction,((byte)cursorPosition.x()),((byte)cursorPosition.y()),((byte)cursorPosition.z()),writeFirst(meta),writeSecond(meta)},result);
if (allow) {
block.setSubstanceAndMeta(substanceValue.get(),result.get());
SoundEffectType soundEffectType=substanceValue.get().placeSound();
if (soundEffectType != null) {
SoundEffect sound=location.world().playSound(soundEffectType);
sound.setPosition(location);
sound.apply();
}
}
}
}"
11757,"@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn)   ThreadsHandler.chunkExecutor().execute(() -> {
    sendChunks(distance);
    for (int i=0; i < CLEAN_ITERATIONS; i++) {
      if (knownChunks.size() > MAX_CHUNKS)       cleanChunks(distance - i);
    }
  }
);
  connection.tick();
  ticksExisted.incrementAndGet();
}","@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn)   ThreadsHandler.chunkExecutor().execute(() -> {
    sendChunks(distance);
    for (int i=0; i < CLEAN_ITERATIONS; i++) {
      if (knownChunks.size() > MAX_CHUNKS)       cleanChunks(distance - i);
    }
  }
);
  if (ticksExisted.get() % 20 == 0) {
    System.out.println(position().block().substance());
  }
  connection.tick();
}"
11758,"public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.x())) >> 4;
  int centZ=((int)Math.floor(loc.z())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (!knownChunks.add(location))       continue;
      bulk.addEntry(((TridentChunk)world().chunkAt(location,true)).asPacket());
      if (bulk.size() >= 1845152) {
        connection().sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
      }
    }
  }
  if (bulk.hasEntries()) {
    connection().sendPacket(bulk);
  }
}","public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.x())) >> 4;
  int centZ=((int)Math.floor(loc.z())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  HashSet<TridentChunk> set=new HashSet<>();
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (!knownChunks.add(location))       continue;
      for (int i=x - 1; i <= x + 1; i++) {
        for (int j=z - 1; j <= z + 1; j++) {
          if (knownChunks.add(location)) {
            set.add(((TridentChunk)world().chunkAt(i,j,true)));
          }
        }
      }
      set.add(((TridentChunk)world().chunkAt(location,true)));
    }
  }
  for (  TridentChunk chunk : set) {
    while (!chunk.isGen())     ;
  }
  for (  TridentChunk chunk : set) {
    bulk.addEntry(chunk.asPacket());
    if (bulk.size() >= 1845152) {
      connection().sendPacket(bulk);
      bulk=new PacketPlayOutMapChunkBulk();
    }
  }
  if (bulk.hasEntries()) {
    connection().sendPacket(bulk);
  }
}"
11759,"private TridentChunk rawChunk(ChunkLocation location){
  TridentChunk chunk=world.chunkAt(location,false);
  if (chunk == null) {
    chunk=new TridentChunk(world,location);
    world.addChunkAt(location,chunk);
  }
  while (chunk.lightPopulated.get() != 0x01)   chunk.generate();
  return chunk;
}","private TridentChunk rawChunk(ChunkLocation location){
  TridentChunk chunk=world.chunkAt(location,false);
  if (chunk == null) {
    chunk=new TridentChunk(world,location);
    world.addChunkAt(location,chunk);
  }
  chunk.generate();
  return chunk;
}"
11760,"@Override public Block blockAt(Position location){
  if (!location.world().name().equals(this.name()))   throw new IllegalArgumentException(""String_Node_Str"");
  int x=(int)Math.round(location.x());
  int y=(int)Math.round(location.y());
  int z=(int)Math.round(location.z());
  return this.chunkAt(WorldUtils.chunkLocation(x,z),true).blockAt(x & 15,y,z & 15);
}","@Override public Block blockAt(Position location){
  if (!location.world().name().equals(this.name()))   throw new IllegalArgumentException(""String_Node_Str"");
  int x=(int)Math.floor(location.x());
  int y=(int)Math.floor(location.y());
  int z=(int)Math.floor(location.z());
  return this.chunkAt(WorldUtils.chunkLocation(x,z),true).blockAt(x & 15,y,z & 15);
}"
11761,"/** 
 * Performs the shutdown procedure on the server, ending with the exit of the JVM
 */
@Override public void shutdown(){
  TridentLogger.get().log(""String_Node_Str"");
  try {
    ((Statuses)Registered.statuses()).saveAll();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  TridentLogger.get().log(""String_Node_Str"");
  ConcurrentTaskExecutor.executors().forEach(ConcurrentTaskExecutor::shutdown);
  TridentLogger.get().log(""String_Node_Str"");
  for (  Player player : TridentPlayer.players()) {
    ((TridentPlayer)player).kickPlayer(""String_Node_Str"");
    ((TridentPlayer)player).connection().logout();
  }
  TridentLogger.get().log(""String_Node_Str"");
  for (  World world : rootWorldLoader.worlds())   ((TridentWorld)world).save();
  TridentLogger.get().log(""String_Node_Str"");
  ((TridentTaskScheduler)Registered.tasks()).shutdown();
  TridentLogger.get().log(""String_Node_Str"");
  ThreadsHandler.shutdownAll();
  TridentLogger.get().log(""String_Node_Str"");
  for (  Plugin plugin : Registered.plugins())   Registered.plugins().disable(plugin);
  TridentLogger.get().log(""String_Node_Str"");
  TridentStart.close();
  TridentLogger.get().log(""String_Node_Str"");
}","/** 
 * Performs the shutdown procedure on the server, ending with the exit of the JVM
 */
@Override public void shutdown(){
  TridentLogger.get().log(""String_Node_Str"");
  try {
    ((Statuses)Registered.statuses()).saveAll();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  TridentLogger.get().log(""String_Node_Str"");
  for (  World world : rootWorldLoader.worlds())   ((TridentWorld)world).save();
  TridentLogger.get().log(""String_Node_Str"");
  ConcurrentTaskExecutor.executors().forEach(ConcurrentTaskExecutor::shutdown);
  TridentLogger.get().log(""String_Node_Str"");
  for (  Player player : TridentPlayer.players()) {
    ((TridentPlayer)player).kickPlayer(""String_Node_Str"");
    ((TridentPlayer)player).connection().logout();
  }
  TridentLogger.get().log(""String_Node_Str"");
  ((TridentTaskScheduler)Registered.tasks()).shutdown();
  TridentLogger.get().log(""String_Node_Str"");
  ThreadsHandler.shutdownAll();
  TridentLogger.get().log(""String_Node_Str"");
  for (  Plugin plugin : Registered.plugins())   Registered.plugins().disable(plugin);
  TridentLogger.get().log(""String_Node_Str"");
  TridentStart.close();
  TridentLogger.get().log(""String_Node_Str"");
}"
11762,"private HashMultimap<Class<? extends Event>,ReflectNotifier> reflectorsFrom(Plugin plugin,Listener listener,final Class<?> c){
  MethodAccess access=accessors.computeIfAbsent(c,(k) -> MethodAccess.get(c));
  Method[] methods=c.getDeclaredMethods();
  HashMultimap<Class<? extends Event>,ReflectNotifier> map=HashMultimap.create(11,11);
  for (int i=0, n=methods.length; i < n; i++) {
    Method method=methods[i];
    Class<?>[] parameterTypes=method.getParameterTypes();
    if (parameterTypes.length != 1)     continue;
    Class<?> type=parameterTypes[0];
    if (!Event.class.isAssignableFrom(type))     continue;
    Class<? extends Event> eventClass=type.asSubclass(Event.class);
    ListenerOpts handler=method.getAnnotation(ListenerOpts.class);
    Importance importance=handler == null ? Importance.MEDIUM : handler.importance();
    ReflectNotifier registeredListener=new ReflectNotifier(access,plugin,access.getIndex(method.getName()),listener,eventClass,importance);
    map.get(eventClass).add(registeredListener);
  }
  return map;
}","private HashMultimap<Class<? extends Event>,ReflectNotifier> reflectorsFrom(Plugin plugin,Listener listener,final Class<?> c){
  MethodAccess access=accessors.computeIfAbsent(c,(k) -> MethodAccess.get(c));
  Method[] methods=c.getDeclaredMethods();
  HashMultimap<Class<? extends Event>,ReflectNotifier> map=HashMultimap.create(11,11);
  for (  Method method : methods) {
    Class<?>[] parameterTypes=method.getParameterTypes();
    if (parameterTypes.length != 1)     continue;
    Class<?> type=parameterTypes[0];
    if (!Event.class.isAssignableFrom(type) || !method.isAnnotationPresent(IgnoreRegistration.class))     continue;
    Class<? extends Event> eventClass=type.asSubclass(Event.class);
    ListenerOpts handler=method.getAnnotation(ListenerOpts.class);
    Importance importance=handler == null ? Importance.MEDIUM : handler.importance();
    ReflectNotifier registeredListener=new ReflectNotifier(access,plugin,access.getIndex(method.getName()),listener,eventClass,importance);
    map.get(eventClass).add(registeredListener);
  }
  return map;
}"
11763,"@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn)   sendChunks(distance);
  ThreadsHandler.chunkExecutor().execute(() -> {
    PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
    boolean reached=false;
    for (int i=0; bulk.size() < 1845152; i++) {
      ChunkLocation location=chunkQueue.poll();
      if (location == null)       continue;
      bulk.addEntry(((TridentChunk)world().chunkAt(location,true)).asPacket());
      if (i == 16) {
        reached=true;
        break;
      }
    }
    if (bulk.hasEntries() && !reached) {
      connection().sendPacket(bulk);
    }
    for (int i=0; i < CLEAN_ITERATIONS; i++) {
      if (knownChunks.size() > MAX_CHUNKS)       cleanChunks(distance - i);
    }
  }
);
  connection.tick();
  ticksExisted.incrementAndGet();
}","@Override protected void doTick(){
  int distance=viewDistance();
  if (!loggingIn)   ThreadsHandler.chunkExecutor().execute(() -> {
    sendChunks(distance);
    for (int i=0; i < CLEAN_ITERATIONS; i++) {
      if (knownChunks.size() > MAX_CHUNKS)       cleanChunks(distance - i);
    }
  }
);
  connection.tick();
  ticksExisted.incrementAndGet();
}"
11764,"private void removeChunk(ChunkLocation location){
  chunkQueue.remove(location);
  ((TridentWorld)world()).loadedChunks.tryRemove(location);
  connection.sendPacket(new PacketPlayOutChunkData(new byte[0],location,true,(short)0));
  knownChunks.remove(location);
}","private void removeChunk(ChunkLocation location){
  ((TridentWorld)world()).loadedChunks.tryRemove(location);
  connection.sendPacket(new PacketPlayOutChunkData(new byte[0],location,true,(short)0));
  knownChunks.remove(location);
}"
11765,"public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.x())) >> 4;
  int centZ=((int)Math.floor(loc.z())) >> 4;
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (!knownChunks.add(location))       continue;
      chunkQueue.offer(location);
    }
  }
}","public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.x())) >> 4;
  int centZ=((int)Math.floor(loc.z())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (!knownChunks.add(location))       continue;
      bulk.addEntry(((TridentChunk)world().chunkAt(location,true)).asPacket());
      if (bulk.size() >= 1845152) {
        connection().sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
      }
    }
  }
  if (bulk.hasEntries()) {
    connection().sendPacket(bulk);
  }
}"
11766,"public void paint(){
  if (terrainPopulated == 0x01) {
    return;
  }
  List<AbstractOverlayBrush> brushes=world.loader().brushes();
  AbstractOverlayBrush.ChunkManipulator manipulator=new AbstractOverlayBrush.ChunkManipulator(){
    @Override public void manipulate(    int relX,    int y,    int relZ,    Substance substance,    byte data){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
        return;
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      chunk.setAt(newX,y,newZ,substance,data,(byte)255,(byte)15);
    }
    @Override public Block blockAt(    int relX,    int y,    int relZ){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        return TridentChunk.this.blockAt(relX,y,relZ);
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      return chunk.blockAt(newX,y,newZ);
    }
  }
;
  for (int i=0; i < 16; i++) {
    for (int j=0; j < 16; j++) {
      for (      AbstractOverlayBrush brush : brushes) {
        brush.brush(location,i,j,world.random(),heights,manipulator);
      }
    }
  }
  terrainPopulated=0x01;
}","public void paint(){
  if (terrainPopulated == 0x01) {
    return;
  }
  List<AbstractOverlayBrush> brushes=world.loader().brushes();
  AbstractOverlayBrush.ChunkManipulator manipulator=new AbstractOverlayBrush.ChunkManipulator(){
    @Override public void manipulate(    int relX,    int y,    int relZ,    Substance substance,    byte data){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
        return;
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      chunk.setAt(newX,y,newZ,substance,data,(byte)255,(byte)15);
    }
    @Override public Block blockAt(    int relX,    int y,    int relZ){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        return TridentChunk.this.blockAt(relX,y,relZ);
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      return chunk.blockAt(newX,y,newZ);
    }
  }
;
  executor.execute(() -> {
    for (int i=0; i < 16; i++) {
      for (int j=0; j < 16; j++) {
        for (        AbstractOverlayBrush brush : brushes) {
          brush.brush(location,i,j,world.random(),heights,manipulator);
        }
      }
    }
  }
);
  terrainPopulated=0x01;
}"
11767,"@Override public void handleReceived(ClientConnection connection){
  if (mode == null) {
    return;
  }
  TridentPlayer player=((PlayerConnection)connection).player();
  Inventory window=Registered.inventories().fromId(this.windowId);
  Inventory originalWindow=window;
  int originalSlot=clickedSlot;
  if (clickedSlot >= window.length()) {
    clickedSlot+=(9 - window.length());
    window=player.window();
  }
  PlayerClickItemEvent clickEvent=EventProcessor.fire(new PlayerClickItemEvent(window,this.clickedSlot,(int)this.actionNumber));
  if (clickEvent.isIgnored()) {
    return;
  }
switch (mode) {
case LEFT_CLICK:
case RIGHT_CLICK:
    if (player.pickedItem() == null) {
      if (window.itemAt(clickedSlot) != null && window.itemAt(clickedSlot).type() != Substance.AIR) {
        if (window.itemAt(clickedSlot).isSimilar(clickedItem.item())) {
          if (mode == ClickAction.LEFT_CLICK) {
            player.setPickedItem(clickedItem.item());
            window.setSlot(clickedSlot,null);
          }
 else {
            Item cursor=clickedItem.item().clone();
            cursor.setQuantity((short)Math.ceil((cursor.quantity() / 2)));
            player.setPickedItem(cursor);
            window.itemAt(clickedSlot).setQuantity((short)(window.itemAt(clickedSlot).quantity() - cursor.quantity()));
            window.setSlot(clickedSlot,window.itemAt(clickedSlot));
          }
        }
 else {
          TridentLogger.get().warn(player.name() + ""String_Node_Str"");
        }
      }
    }
 else {
      Item temp=window.itemAt(clickedSlot);
      if (mode == ClickAction.LEFT_CLICK) {
        window.setSlot(clickedSlot,player.pickedItem());
        if (temp != null && temp.type() != Substance.AIR) {
          player.setPickedItem(temp);
        }
 else {
          player.setPickedItem(null);
        }
      }
 else {
        if (temp == null || temp.type() == Substance.AIR) {
          Item single=player.pickedItem().clone();
          single.setQuantity((short)1);
          window.setSlot(clickedSlot,single);
          if (player.pickedItem().quantity() > 1) {
            player.pickedItem().setQuantity((short)(player.pickedItem().quantity() - 1));
          }
 else {
            player.setPickedItem(null);
          }
        }
 else {
          window.setSlot(clickedSlot,player.pickedItem());
          if (temp.type() != Substance.AIR) {
            player.setPickedItem(temp);
          }
 else {
            player.setPickedItem(null);
          }
        }
      }
    }
  break;
case SHIFT_LEFT_CLICK:
break;
case SHIFT_RIGHT_CLICK:
break;
case NUMBER_KEY:
break;
case MIDDLE_CLICK:
break;
case DROP_KEY_ONE:
break;
case DROP_KEY_STACK:
break;
case LEFT_CLICK_OUTSIDE:
break;
case RIGHT_CLICK_OUTSIDE:
break;
case START_LEFT_CLICK_DRAG:
case START_RIGHT_CLICK_DRAG:
if (player.drag() != null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
player.setDrag(mode);
break;
case ADD_SLOT_LEFT_CLICK_DRAG:
case ADD_SLOT_RIGHT_CLICK_DRAG:
if (player.drag() == null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
 else {
if ((mode == ClickAction.ADD_SLOT_LEFT_CLICK_DRAG && player.drag() == ClickAction.START_RIGHT_CLICK_DRAG) || (mode == ClickAction.ADD_SLOT_RIGHT_CLICK_DRAG && player.drag() == ClickAction.START_LEFT_CLICK_DRAG)) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
}
player.dragSlots().add((int)originalSlot);
break;
case END_LEFT_CLICK_DRAG:
if (player.drag() == null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
 else if (player.drag() == ClickAction.START_RIGHT_CLICK_DRAG) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
int available=player.pickedItem().quantity();
int split=(int)Math.floor(available / player.dragSlots().size());
for (Integer i : player.dragSlots()) {
if (available == 0) {
break;
}
Inventory using=originalWindow;
if (i >= originalWindow.length()) {
using=player.window();
}
Item current=using.itemAt(i);
if (current == null || current.type() == Substance.AIR) {
current=player.pickedItem().clone();
current.setQuantity((short)split);
using.setSlot(i,current);
available-=split;
}
 else if (current.isSimilarIgnoreQuantity(player.pickedItem()) && current.quantity() < current.type().maxStackSize()) {
int canAdd=Math.min(split,current.type().maxStackSize() - current.quantity());
current.setQuantity((short)(current.quantity() + canAdd));
using.setSlot(i,current);
available-=canAdd;
}
}
if (available == 0) {
player.setPickedItem(null);
}
 else {
player.pickedItem().setQuantity((short)available);
}
player.dragSlots().clear();
player.setDrag(null);
break;
case END_RIGHT_CLICK_DRAG:
if (player.drag() == null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
 else if (player.drag() == ClickAction.START_LEFT_CLICK_DRAG) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
available=player.pickedItem().quantity();
for (Integer i : player.dragSlots()) {
if (available == 0) {
break;
}
Inventory using=originalWindow;
if (i >= originalWindow.length()) {
using=player.window();
}
Item current=using.itemAt(i);
if (current == null || current.type() == Substance.AIR) {
current=player.pickedItem().clone();
current.setQuantity((short)1);
using.setSlot(i,current);
available--;
}
 else if (current.isSimilarIgnoreQuantity(player.pickedItem()) && current.quantity() < current.type().maxStackSize()) {
current.setQuantity((short)(current.quantity() + 1));
using.setSlot(i,current);
available--;
}
}
if (available == 0) {
player.setPickedItem(null);
}
 else {
player.pickedItem().setQuantity((short)available);
}
player.dragSlots().clear();
player.setDrag(null);
break;
case DOUBLE_CLICK:
Item picking=window.itemAt(clickedSlot);
if (player.pickedItem() != null) {
picking=player.pickedItem();
}
int count=picking.quantity();
int slot=0;
if (window.id() != windowId) {
window=originalWindow;
}
while (count <= picking.type().maxStackSize() && slot < window.length()) {
if (window.itemAt(slot) != null && window.itemAt(slot).isSimilarIgnoreQuantity(picking)) {
if (count + window.itemAt(slot).quantity() <= picking.type().maxStackSize()) {
count+=window.itemAt(slot).quantity();
window.setSlot(slot,null);
}
 else {
window.itemAt(slot).setQuantity((short)(window.itemAt(slot).quantity() - (picking.type().maxStackSize() - count)));
window.setSlot(slot,window.itemAt(slot));
count=picking.type().maxStackSize();
break;
}
}
slot++;
}
if (count < picking.type().maxStackSize() && windowId > 0) {
slot=0;
Inventory pW=player.window();
while (count <= picking.type().maxStackSize() && slot < pW.length()) {
if (pW.itemAt(slot) != null && pW.itemAt(slot).isSimilarIgnoreQuantity(picking)) {
if (count + pW.itemAt(slot).quantity() <= picking.type().maxStackSize()) {
count+=pW.itemAt(slot).quantity();
pW.setSlot(slot,null);
}
 else {
pW.itemAt(slot).setQuantity((short)(pW.itemAt(slot).quantity() - (picking.type().maxStackSize() - count)));
pW.setSlot(slot,pW.itemAt(slot));
count=picking.type().maxStackSize();
break;
}
}
slot++;
}
}
picking.setQuantity((short)count);
player.setPickedItem(picking);
break;
}
}","@Override public void handleReceived(ClientConnection connection){
  if (mode == null) {
    return;
  }
  TridentPlayer player=((PlayerConnection)connection).player();
  Inventory window=Registered.inventories().fromId(this.windowId);
  Inventory originalWindow=window;
  int originalSlot=clickedSlot;
  if (clickedSlot >= window.length()) {
    clickedSlot+=(9 - window.length());
    window=player.window();
  }
  PlayerClickItemEvent clickEvent=EventProcessor.fire(new PlayerClickItemEvent(window,this.clickedSlot,(int)this.actionNumber));
  if (clickEvent.isIgnored()) {
    return;
  }
switch (mode) {
case LEFT_CLICK:
case RIGHT_CLICK:
    if (player.pickedItem() == null) {
      if (window.itemAt(clickedSlot) != null && window.itemAt(clickedSlot).type() != Substance.AIR) {
        if (window.itemAt(clickedSlot).isSimilar(clickedItem.item())) {
          if (mode == ClickAction.LEFT_CLICK) {
            player.setPickedItem(clickedItem.item());
            window.setSlot(clickedSlot,null);
          }
 else {
            Item cursor=clickedItem.item().clone();
            cursor.setQuantity((short)Math.ceil((cursor.quantity() / 2)));
            player.setPickedItem(cursor);
            window.itemAt(clickedSlot).setQuantity((short)(window.itemAt(clickedSlot).quantity() - cursor.quantity()));
            window.setSlot(clickedSlot,window.itemAt(clickedSlot));
          }
        }
 else {
          TridentLogger.get().warn(player.name() + ""String_Node_Str"");
        }
      }
    }
 else {
      Item temp=window.itemAt(clickedSlot);
      if (mode == ClickAction.LEFT_CLICK) {
        window.setSlot(clickedSlot,player.pickedItem());
        if (temp != null && temp.type() != Substance.AIR) {
          player.setPickedItem(temp);
        }
 else {
          player.setPickedItem(null);
        }
      }
 else {
        if (temp == null || temp.type() == Substance.AIR) {
          Item single=player.pickedItem().clone();
          single.setQuantity((short)1);
          window.setSlot(clickedSlot,single);
          if (player.pickedItem().quantity() > 1) {
            player.pickedItem().setQuantity((short)(player.pickedItem().quantity() - 1));
          }
 else {
            player.setPickedItem(null);
          }
        }
 else {
          window.setSlot(clickedSlot,player.pickedItem());
          if (temp.type() != Substance.AIR) {
            player.setPickedItem(temp);
          }
 else {
            player.setPickedItem(null);
          }
        }
      }
    }
  break;
case SHIFT_LEFT_CLICK:
break;
case SHIFT_RIGHT_CLICK:
break;
case NUMBER_KEY:
break;
case MIDDLE_CLICK:
break;
case DROP_KEY_ONE:
break;
case DROP_KEY_STACK:
break;
case LEFT_CLICK_OUTSIDE:
break;
case RIGHT_CLICK_OUTSIDE:
break;
case START_LEFT_CLICK_DRAG:
case START_RIGHT_CLICK_DRAG:
if (player.drag() != null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
player.setDrag(mode);
break;
case ADD_SLOT_LEFT_CLICK_DRAG:
case ADD_SLOT_RIGHT_CLICK_DRAG:
if (player.drag() == null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
 else {
if ((mode == ClickAction.ADD_SLOT_LEFT_CLICK_DRAG && player.drag() == ClickAction.START_RIGHT_CLICK_DRAG) || (mode == ClickAction.ADD_SLOT_RIGHT_CLICK_DRAG && player.drag() == ClickAction.START_LEFT_CLICK_DRAG)) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
}
player.dragSlots().add((int)originalSlot);
break;
case END_LEFT_CLICK_DRAG:
if (player.drag() == null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
 else if (player.drag() == ClickAction.START_RIGHT_CLICK_DRAG) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
int available=player.pickedItem().quantity();
int split=(int)Math.floor(available / player.dragSlots().size());
for (Integer i : player.dragSlots()) {
if (available == 0) {
break;
}
Inventory using=originalWindow;
if (i >= originalWindow.length()) {
using=player.window();
}
Item current=using.itemAt(i);
if (current == null || current.type() == Substance.AIR) {
current=player.pickedItem().clone();
current.setQuantity((short)split);
using.setSlot(i,current);
available-=split;
}
 else if (current.isSimilarIgnoreQuantity(player.pickedItem()) && current.quantity() < current.type().maxStackSize()) {
int canAdd=Math.min(split,current.type().maxStackSize() - current.quantity());
current.setQuantity((short)(current.quantity() + canAdd));
using.setSlot(i,current);
available-=canAdd;
}
}
if (available == 0) {
player.setPickedItem(null);
}
 else {
player.pickedItem().setQuantity((short)available);
}
player.dragSlots().clear();
player.setDrag(null);
break;
case END_RIGHT_CLICK_DRAG:
if (player.drag() == null) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
 else if (player.drag() == ClickAction.START_LEFT_CLICK_DRAG) {
TridentLogger.get().warn(player.name() + ""String_Node_Str"");
break;
}
System.out.println(player.pickedItem());
available=player.pickedItem().quantity();
for (Integer i : player.dragSlots()) {
if (available == 0) {
break;
}
Inventory using=originalWindow;
if (i >= originalWindow.length()) {
using=player.window();
}
Item current=using.itemAt(i);
if (current == null || current.type() == Substance.AIR) {
current=player.pickedItem().clone();
current.setQuantity((short)1);
using.setSlot(i,current);
available--;
}
 else if (current.isSimilarIgnoreQuantity(player.pickedItem()) && current.quantity() < current.type().maxStackSize()) {
current.setQuantity((short)(current.quantity() + 1));
using.setSlot(i,current);
available--;
}
}
if (available == 0) {
player.setPickedItem(null);
}
 else {
player.pickedItem().setQuantity((short)available);
}
player.dragSlots().clear();
player.setDrag(null);
break;
case DOUBLE_CLICK:
Item picking=window.itemAt(clickedSlot);
if (player.pickedItem() != null) {
picking=player.pickedItem();
}
int count=picking.quantity();
int slot=0;
if (window.id() != windowId) {
window=originalWindow;
}
while (count <= picking.type().maxStackSize() && slot < window.length()) {
if (window.itemAt(slot) != null && window.itemAt(slot).isSimilarIgnoreQuantity(picking)) {
if (count + window.itemAt(slot).quantity() <= picking.type().maxStackSize()) {
count+=window.itemAt(slot).quantity();
window.setSlot(slot,null);
}
 else {
window.itemAt(slot).setQuantity((short)(window.itemAt(slot).quantity() - (picking.type().maxStackSize() - count)));
window.setSlot(slot,window.itemAt(slot));
count=picking.type().maxStackSize();
break;
}
}
slot++;
}
if (count < picking.type().maxStackSize() && windowId > 0) {
slot=0;
Inventory pW=player.window();
while (count <= picking.type().maxStackSize() && slot < pW.length()) {
if (pW.itemAt(slot) != null && pW.itemAt(slot).isSimilarIgnoreQuantity(picking)) {
if (count + pW.itemAt(slot).quantity() <= picking.type().maxStackSize()) {
count+=pW.itemAt(slot).quantity();
pW.setSlot(slot,null);
}
 else {
pW.itemAt(slot).setQuantity((short)(pW.itemAt(slot).quantity() - (picking.type().maxStackSize() - count)));
pW.setSlot(slot,pW.itemAt(slot));
count=picking.type().maxStackSize();
break;
}
}
slot++;
}
}
picking.setQuantity((short)count);
player.setPickedItem(picking);
break;
}
}"
11768,"@Override public Packet decode(ByteBuf buf){
  this.windowId=(int)buf.readByte();
  this.clickedSlot=buf.readShort();
  this.clickedButton=(int)buf.readByte();
  this.actionNumber=buf.readShort();
  short mode=buf.readShort();
  this.mode=ClickAction.getAction(mode,clickedButton,clickedSlot);
  this.clickedItem=new Slot(buf);
  return this;
}","@Override public Packet decode(ByteBuf buf){
  this.windowId=(int)buf.readByte();
  this.clickedSlot=buf.readShort();
  this.clickedButton=(int)buf.readByte();
  this.actionNumber=buf.readShort();
  this.modeId=buf.readByte();
  this.mode=ClickAction.getAction(modeId,clickedButton,clickedSlot);
  this.clickedItem=new Slot(buf);
  return this;
}"
11769,"/** 
 * Initializes the server with the configuration file
 * @param config the configuration to use for option lookup
 */
@Volatile(policy=""String_Node_Str"",reason=""String_Node_Str"",fix=""String_Node_Str"") private static void init(final Config config) throws InterruptedException {
  bossGroup=new NioEventLoopGroup(4,Defaults.ERROR_HANDLED);
  workerGroup=new NioEventLoopGroup(4,Defaults.ERROR_HANDLED);
  try {
    TridentLogger.get().log(""String_Node_Str"");
    TridentServer.createServer(config);
    TridentLogger.get().success(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    File fi=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
    if (!fi.exists())     fi.mkdir();
    for (    File file : new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"").listFiles())     Registered.plugins().load(file);
    TridentLogger.get().success(""String_Node_Str"");
    TridentWorldLoader.loadAll();
    TridentServer.WORLD=(TridentWorld)Registered.worlds().get(""String_Node_Str"");
    if (TridentServer.WORLD == null) {
      World world=TridentServer.instance().rootWorldLoader.createWorld(""String_Node_Str"");
      TridentServer.WORLD=(TridentWorld)world;
    }
    TridentLogger.get().log(""String_Node_Str"");
    ServerCommandRegistrar.registerAll();
    TridentLogger.get().success(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    Plugins handler=Registered.plugins();
    handler.forEach(handler::enable);
    TridentLogger.get().success(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    String ip=config.getString(""String_Node_Str"",Defaults.ADDRESS);
    int port=config.getInt(""String_Node_Str"",Defaults.PORT);
    TridentLogger.get().log(""String_Node_Str"" + ip + ""String_Node_Str""+ port);
    new ServerBootstrap().group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ClientChannelInitializer()).option(ChannelOption.TCP_NODELAY,true).bind(new InetSocketAddress(ip,port)).sync();
    TridentLogger.get().success(""String_Node_Str"");
    Thread thread=new Thread(() -> {
      Scanner scanner=new Scanner(System.in);
      while (true) {
        String command=scanner.nextLine();
        System.out.print(""String_Node_Str"");
        Trident.console().invokeCommand(command);
      }
    }
);
    thread.setDaemon(true);
    thread.start();
  }
 catch (  InterruptedException e) {
  }
catch (  NoSuchElementException e) {
  }
catch (  Exception e) {
    TridentLogger.get().error(""String_Node_Str"");
    TridentLogger.get().error(e);
    Trident.shutdown();
  }
}","/** 
 * Initializes the server with the configuration file
 * @param config the configuration to use for option lookup
 */
@Volatile(policy=""String_Node_Str"",reason=""String_Node_Str"",fix=""String_Node_Str"") private static void init(final Config config) throws InterruptedException {
  bossGroup=new NioEventLoopGroup(4,Defaults.ERROR_HANDLED);
  workerGroup=new NioEventLoopGroup(4,Defaults.ERROR_HANDLED);
  try {
    TridentLogger.get().log(""String_Node_Str"");
    TridentServer.createServer(config);
    TridentLogger.get().success(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    File fi=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
    if (!fi.exists())     fi.mkdir();
    for (    File file : new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"").listFiles((dir,name) -> name.endsWith(""String_Node_Str"")))     Registered.plugins().load(file);
    TridentLogger.get().success(""String_Node_Str"");
    TridentWorldLoader.loadAll();
    TridentServer.WORLD=(TridentWorld)Registered.worlds().get(""String_Node_Str"");
    if (TridentServer.WORLD == null) {
      World world=TridentServer.instance().rootWorldLoader.createWorld(""String_Node_Str"");
      TridentServer.WORLD=(TridentWorld)world;
    }
    TridentLogger.get().log(""String_Node_Str"");
    ServerCommandRegistrar.registerAll();
    TridentLogger.get().success(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    Plugins handler=Registered.plugins();
    handler.forEach(handler::enable);
    TridentLogger.get().success(""String_Node_Str"");
    TridentLogger.get().log(""String_Node_Str"");
    String ip=config.getString(""String_Node_Str"",Defaults.ADDRESS);
    int port=config.getInt(""String_Node_Str"",Defaults.PORT);
    TridentLogger.get().log(""String_Node_Str"" + ip + ""String_Node_Str""+ port);
    new ServerBootstrap().group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ClientChannelInitializer()).option(ChannelOption.TCP_NODELAY,true).bind(new InetSocketAddress(ip,port)).sync();
    TridentLogger.get().success(""String_Node_Str"");
    Thread thread=new Thread(() -> {
      Scanner scanner=new Scanner(System.in);
      while (true) {
        String command=scanner.nextLine();
        System.out.print(""String_Node_Str"");
        Trident.console().invokeCommand(command);
      }
    }
);
    thread.setDaemon(true);
    thread.start();
  }
 catch (  InterruptedException e) {
  }
catch (  NoSuchElementException e) {
  }
catch (  Exception e) {
    TridentLogger.get().error(""String_Node_Str"");
    TridentLogger.get().error(e);
    Trident.shutdown();
  }
}"
11770,"public void paint(){
  if (terrainPopulated == 0x01) {
    return;
  }
  for (int i=location.x() - 1; i <= location.x() + 1; i++) {
    for (int j=location.z() - 1; j <= location.z() + 1; j++) {
      rawChunk(ChunkLocation.create(i,j));
    }
  }
  List<AbstractOverlayBrush> brushes=world.loader().brushes();
  AbstractOverlayBrush.ChunkManipulator manipulator=new AbstractOverlayBrush.ChunkManipulator(){
    private final MassChange change=new ThreadSafeChange(world);
    @Override public void manipulate(    int relX,    int y,    int relZ,    Substance substance,    byte data){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
        return;
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ newX+ ""String_Node_Str""+ newZ);
      chunk.setAndSend(newX,y,newZ,substance,data,(byte)255,(byte)15,change);
    }
    @Override public Block blockAt(    int relX,    int y,    int relZ){
      if (y == Integer.MAX_VALUE) {
        change.commitChanges();
        return null;
      }
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        return TridentChunk.this.blockAt(relX,y,relZ);
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      return chunk.blockAt(newX,y,newZ);
    }
  }
;
  CountDownLatch latch=new CountDownLatch(256);
  for (int i=0; i < 16; i++) {
    final int finalI=i;
    executor.execute(() -> {
      for (int j=0; j < 16; j++) {
        for (        AbstractOverlayBrush brush : brushes) {
          brush.brush(location,finalI,j,world.random(),heights,manipulator);
          latch.countDown();
        }
      }
    }
);
  }
  manipulator.blockAt(0,Integer.MAX_VALUE,0);
  terrainPopulated=0x01;
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void paint(){
  if (terrainPopulated == 0x01) {
    return;
  }
  for (int i=location.x() - 1; i <= location.x() + 1; i++) {
    for (int j=location.z() - 1; j <= location.z() + 1; j++) {
      rawChunk(ChunkLocation.create(i,j));
    }
  }
  List<AbstractOverlayBrush> brushes=world.loader().brushes();
  AbstractOverlayBrush.ChunkManipulator manipulator=new AbstractOverlayBrush.ChunkManipulator(){
    private final MassChange change=new ThreadSafeChange(world);
    @Override public void manipulate(    int relX,    int y,    int relZ,    Substance substance,    byte data){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        setAndSend(relX,y,relZ,substance,data,(byte)255,(byte)15,change);
        return;
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ newX+ ""String_Node_Str""+ newZ);
      chunk.setAndSend(newX,y,newZ,substance,data,(byte)255,(byte)15,change);
    }
    @Override public Block blockAt(    int relX,    int y,    int relZ){
      if (y == Integer.MAX_VALUE) {
        change.commitChanges();
        return null;
      }
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        return TridentChunk.this.blockAt(relX,y,relZ);
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      return chunk.blockAt(newX,y,newZ);
    }
  }
;
  CountDownLatch latch=new CountDownLatch(256);
  for (int i=0; i < 16; i++) {
    final int finalI=i;
    executor.execute(() -> {
      for (int j=0; j < 16; j++) {
        for (        AbstractOverlayBrush brush : brushes) {
          brush.brush(location,finalI,j,world.random(),heights,manipulator);
          latch.countDown();
        }
      }
    }
);
  }
  manipulator.blockAt(0,Integer.MAX_VALUE,0);
  terrainPopulated=0x01;
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
11771,"@Override public void manipulate(int relX,int y,int relZ,Substance substance,byte data){
  if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
    setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
    return;
  }
  int cx=location.x();
  int cz=location.z();
  int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
  int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
  int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
  int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
  int chunkX=location.x();
  int chunkZ=location.z();
  int newX=relX;
  int newZ=relZ;
  if (relX < 0) {
    newX=16 - xMinDiff;
    chunkX=cx - up(xMinDiff / 16) - 1;
  }
 else   if (relX > 15) {
    newX=xMaxDiff - 1;
    chunkX=cx + up(xMaxDiff / 16) + 1;
  }
  if (relZ < 0) {
    newZ=16 - zMinDiff;
    chunkZ=cz - up(zMinDiff / 16) - 1;
  }
 else   if (relZ > 15) {
    newZ=zMaxDiff - 1;
    chunkZ=cz + up(zMaxDiff / 16) + 1;
  }
  ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
  TridentChunk chunk=rawChunk(loc);
  TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ newX+ ""String_Node_Str""+ newZ);
  chunk.setAndSend(newX,y,newZ,substance,data,(byte)255,(byte)15,change);
}","@Override public void manipulate(int relX,int y,int relZ,Substance substance,byte data){
  if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
    setAndSend(relX,y,relZ,substance,data,(byte)255,(byte)15,change);
    return;
  }
  int cx=location.x();
  int cz=location.z();
  int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
  int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
  int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
  int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
  int chunkX=location.x();
  int chunkZ=location.z();
  int newX=relX;
  int newZ=relZ;
  if (relX < 0) {
    newX=16 - xMinDiff;
    chunkX=cx - up(xMinDiff / 16) - 1;
  }
 else   if (relX > 15) {
    newX=xMaxDiff - 1;
    chunkX=cx + up(xMaxDiff / 16) + 1;
  }
  if (relZ < 0) {
    newZ=16 - zMinDiff;
    chunkZ=cz - up(zMinDiff / 16) - 1;
  }
 else   if (relZ > 15) {
    newZ=zMaxDiff - 1;
    chunkZ=cz + up(zMaxDiff / 16) + 1;
  }
  ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
  TridentChunk chunk=rawChunk(loc);
  TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ newX+ ""String_Node_Str""+ newZ);
  chunk.setAndSend(newX,y,newZ,substance,data,(byte)255,(byte)15,change);
}"
11772,"/** 
 * Performs the shutdown procedure on the server, ending with the exit of the JVM
 */
@Override public void shutdown(){
  TridentLogger.get().log(""String_Node_Str"");
  try {
    ((Statuses)Registered.statuses()).saveAll();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  TridentLogger.get().log(""String_Node_Str"");
  for (  Plugin plugin : Registered.plugins())   Registered.plugins().disable(plugin);
  TridentLogger.get().log(""String_Node_Str"");
  for (  Player player : TridentPlayer.players()) {
    ((TridentPlayer)player).kickPlayer(""String_Node_Str"");
    ((TridentPlayer)player).connection().logout();
  }
  TridentLogger.get().log(""String_Node_Str"");
  for (  World world : rootWorldLoader.worlds())   ((TridentWorld)world).save();
  TridentLogger.get().log(""String_Node_Str"");
  ((TridentTaskScheduler)Registered.tasks()).shutdown();
  TridentLogger.get().log(""String_Node_Str"");
  ThreadsHandler.shutdownAll();
  TridentLogger.get().log(""String_Node_Str"");
  ConcurrentTaskExecutor.executors().forEach(ConcurrentTaskExecutor::shutdown);
  TridentLogger.get().log(""String_Node_Str"");
  TridentStart.close();
  TridentLogger.get().log(""String_Node_Str"");
}","/** 
 * Performs the shutdown procedure on the server, ending with the exit of the JVM
 */
@Override public void shutdown(){
  TridentLogger.get().log(""String_Node_Str"");
  try {
    ((Statuses)Registered.statuses()).saveAll();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  TridentLogger.get().log(""String_Node_Str"");
  ConcurrentTaskExecutor.executors().forEach(ConcurrentTaskExecutor::shutdown);
  TridentLogger.get().log(""String_Node_Str"");
  for (  Player player : TridentPlayer.players()) {
    ((TridentPlayer)player).kickPlayer(""String_Node_Str"");
    ((TridentPlayer)player).connection().logout();
  }
  TridentLogger.get().log(""String_Node_Str"");
  for (  World world : rootWorldLoader.worlds())   ((TridentWorld)world).save();
  TridentLogger.get().log(""String_Node_Str"");
  ((TridentTaskScheduler)Registered.tasks()).shutdown();
  TridentLogger.get().log(""String_Node_Str"");
  ThreadsHandler.shutdownAll();
  TridentLogger.get().log(""String_Node_Str"");
  for (  Plugin plugin : Registered.plugins())   Registered.plugins().disable(plugin);
  TridentLogger.get().log(""String_Node_Str"");
  TridentStart.close();
  TridentLogger.get().log(""String_Node_Str"");
}"
11773,"@Override public TridentChunk chunkAt(ChunkLocation location,boolean generateIfNotFound){
  if (location == null) {
    return null;
  }
  TridentChunk chunk=this.loadedChunks.get(location,generateIfNotFound);
  if (chunk != null)   chunk.paint();
  return chunk;
}","@Override public TridentChunk chunkAt(ChunkLocation location,boolean generateIfNotFound){
  if (location == null) {
    return null;
  }
  TridentChunk chunk=this.loadedChunks.get(location,generateIfNotFound);
  if (chunk != null && generateIfNotFound)   chunk.paint();
  return chunk;
}"
11774,"public void paint(){
  if (terrainPopulated == 0x01) {
    return;
  }
  for (int i=location.x() - 1; i < location.x() + 1; i++) {
    for (int j=location.z() - 1; j < location.z() + 1; j++) {
      rawChunk(ChunkLocation.create(i,j));
    }
  }
  List<AbstractOverlayBrush> brushes=world.loader().brushes();
  AbstractOverlayBrush.ChunkManipulator manipulator=new AbstractOverlayBrush.ChunkManipulator(){
    private final MassChange change=new ThreadSafeChange(world);
    @Override public void manipulate(    int relX,    int y,    int relZ,    Substance substance,    byte data){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
        return;
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      if (relX < 0 && relZ > 15) {
        ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz + up(zMaxDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (16 - xMinDiff)+ ""String_Node_Str""+ (zMaxDiff - 1));
        chunk.setAndSend(16 - xMinDiff,y,zMaxDiff - 1,substance,data,(byte)255,(byte)15,change);
      }
 else       if (relX > 15 && relZ > 15) {
        ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz + up(zMaxDiff / 16));
        TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (xMaxDiff - 1)+ ""String_Node_Str""+ (zMaxDiff - 1));
        TridentChunk chunk=rawChunk(loc);
        chunk.setAndSend(xMaxDiff - 1,y,zMaxDiff - 1,substance,data,(byte)255,(byte)15,change);
      }
 else       if (relX < 0 && relZ < 0) {
        ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz - up(zMinDiff / 16));
        TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (16 - xMinDiff)+ ""String_Node_Str""+ (16 - zMinDiff));
        TridentChunk chunk=rawChunk(loc);
        chunk.setAndSend(16 - xMinDiff,y,16 - zMinDiff,substance,data,(byte)255,(byte)15,change);
      }
 else       if (relX > 15 && relZ < 0) {
        ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz - up(zMinDiff / 16));
        TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (xMaxDiff - 1)+ ""String_Node_Str""+ (16 - zMinDiff));
        TridentChunk chunk=rawChunk(loc);
        chunk.setAndSend(xMaxDiff - 1,y,16 - zMinDiff,substance,data,(byte)255,(byte)15,change);
      }
    }
    @Override public Block blockAt(    int relX,    int y,    int relZ){
      if (y == Integer.MAX_VALUE) {
        change.commitChanges();
        return null;
      }
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        return TridentChunk.this.blockAt(relX,y,relZ);
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      if (relX < 0 && relZ > 15) {
        ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz + up(zMaxDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(16 - xMinDiff,y,zMaxDiff - 1);
      }
 else       if (relX > 15 && relZ > 15) {
        ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz + up(zMaxDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(xMaxDiff - 1,y,zMaxDiff - 1);
      }
 else       if (relX < 0 && relZ < 0) {
        ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz - up(zMinDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(16 - xMinDiff,y,16 - zMinDiff);
      }
 else       if (relX > 15 && relZ < 0) {
        ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz - up(zMinDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(xMaxDiff - 1,y,16 - zMinDiff);
      }
      return null;
    }
  }
;
  CountDownLatch latch=new CountDownLatch(256);
  for (int i=0; i < 16; i++) {
    final int finalI=i;
    executor.execute(() -> {
      for (int j=0; j < 16; j++) {
        for (        AbstractOverlayBrush brush : brushes) {
          brush.brush(location,finalI,j,world.random(),heights,manipulator);
          latch.countDown();
        }
      }
    }
);
  }
  manipulator.blockAt(0,Integer.MAX_VALUE,0);
  terrainPopulated=0x01;
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void paint(){
  if (terrainPopulated == 0x01) {
    return;
  }
  for (int i=location.x() - 1; i <= location.x() + 1; i++) {
    for (int j=location.z() - 1; j <= location.z() + 1; j++) {
      rawChunk(ChunkLocation.create(i,j));
    }
  }
  List<AbstractOverlayBrush> brushes=world.loader().brushes();
  AbstractOverlayBrush.ChunkManipulator manipulator=new AbstractOverlayBrush.ChunkManipulator(){
    private final MassChange change=new ThreadSafeChange(world);
    @Override public void manipulate(    int relX,    int y,    int relZ,    Substance substance,    byte data){
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
        return;
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      int chunkX=location.x();
      int chunkZ=location.z();
      int newX=relX;
      int newZ=relZ;
      if (relX < 0) {
        newX=16 - xMinDiff;
        chunkX=cx - up(xMinDiff / 16) - 1;
      }
 else       if (relX > 15) {
        newX=xMaxDiff - 1;
        chunkX=cx + up(xMaxDiff / 16) + 1;
      }
      if (relZ < 0) {
        newZ=16 - zMinDiff;
        chunkZ=cz - up(zMinDiff / 16) - 1;
      }
 else       if (relZ > 15) {
        newZ=zMaxDiff - 1;
        chunkZ=cz + up(zMaxDiff / 16) + 1;
      }
      ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
      TridentChunk chunk=rawChunk(loc);
      TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ newX+ ""String_Node_Str""+ newZ);
      chunk.setAndSend(newX,y,newZ,substance,data,(byte)255,(byte)15,change);
    }
    @Override public Block blockAt(    int relX,    int y,    int relZ){
      if (y == Integer.MAX_VALUE) {
        change.commitChanges();
        return null;
      }
      if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
        return TridentChunk.this.blockAt(relX,y,relZ);
      }
      int cx=location.x();
      int cz=location.z();
      int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
      int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
      int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
      int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
      if (relX < 0 && relZ > 15) {
        ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz + up(zMaxDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(16 - xMinDiff,y,zMaxDiff - 1);
      }
 else       if (relX > 15 && relZ > 15) {
        ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz + up(zMaxDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(xMaxDiff - 1,y,zMaxDiff - 1);
      }
 else       if (relX < 0 && relZ < 0) {
        ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz - up(zMinDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(16 - xMinDiff,y,16 - zMinDiff);
      }
 else       if (relX > 15 && relZ < 0) {
        ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz - up(zMinDiff / 16));
        TridentChunk chunk=rawChunk(loc);
        return chunk.blockAt(xMaxDiff - 1,y,16 - zMinDiff);
      }
      return null;
    }
  }
;
  CountDownLatch latch=new CountDownLatch(256);
  for (int i=0; i < 16; i++) {
    final int finalI=i;
    executor.execute(() -> {
      for (int j=0; j < 16; j++) {
        for (        AbstractOverlayBrush brush : brushes) {
          brush.brush(location,finalI,j,world.random(),heights,manipulator);
          latch.countDown();
        }
      }
    }
);
  }
  manipulator.blockAt(0,Integer.MAX_VALUE,0);
  terrainPopulated=0x01;
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
11775,"@Override public void manipulate(int relX,int y,int relZ,Substance substance,byte data){
  if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
    setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
    return;
  }
  int cx=location.x();
  int cz=location.z();
  int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
  int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
  int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
  int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
  if (relX < 0 && relZ > 15) {
    ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz + up(zMaxDiff / 16));
    TridentChunk chunk=rawChunk(loc);
    TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (16 - xMinDiff)+ ""String_Node_Str""+ (zMaxDiff - 1));
    chunk.setAndSend(16 - xMinDiff,y,zMaxDiff - 1,substance,data,(byte)255,(byte)15,change);
  }
 else   if (relX > 15 && relZ > 15) {
    ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz + up(zMaxDiff / 16));
    TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (xMaxDiff - 1)+ ""String_Node_Str""+ (zMaxDiff - 1));
    TridentChunk chunk=rawChunk(loc);
    chunk.setAndSend(xMaxDiff - 1,y,zMaxDiff - 1,substance,data,(byte)255,(byte)15,change);
  }
 else   if (relX < 0 && relZ < 0) {
    ChunkLocation loc=ChunkLocation.create(cx - up(xMinDiff / 16),cz - up(zMinDiff / 16));
    TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (16 - xMinDiff)+ ""String_Node_Str""+ (16 - zMinDiff));
    TridentChunk chunk=rawChunk(loc);
    chunk.setAndSend(16 - xMinDiff,y,16 - zMinDiff,substance,data,(byte)255,(byte)15,change);
  }
 else   if (relX > 15 && relZ < 0) {
    ChunkLocation loc=ChunkLocation.create(cx + up(xMaxDiff / 16),cz - up(zMinDiff / 16));
    TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ (xMaxDiff - 1)+ ""String_Node_Str""+ (16 - zMinDiff));
    TridentChunk chunk=rawChunk(loc);
    chunk.setAndSend(xMaxDiff - 1,y,16 - zMinDiff,substance,data,(byte)255,(byte)15,change);
  }
}","@Override public void manipulate(int relX,int y,int relZ,Substance substance,byte data){
  if (relX >= 0 && relX <= 15 && relZ >= 0 && relZ <= 15) {
    setAt(relX,y,relZ,substance,data,(byte)255,(byte)15);
    return;
  }
  int cx=location.x();
  int cz=location.z();
  int xMinDiff=Math.max(relX,0) - Math.min(relX,0);
  int xMaxDiff=Math.max(relX,15) - Math.min(relX,15);
  int zMinDiff=Math.max(relZ,0) - Math.min(relZ,0);
  int zMaxDiff=Math.max(relZ,15) - Math.min(relZ,15);
  int chunkX=location.x();
  int chunkZ=location.z();
  int newX=relX;
  int newZ=relZ;
  if (relX < 0) {
    newX=16 - xMinDiff;
    chunkX=cx - up(xMinDiff / 16) - 1;
  }
 else   if (relX > 15) {
    newX=xMaxDiff - 1;
    chunkX=cx + up(xMaxDiff / 16) + 1;
  }
  if (relZ < 0) {
    newZ=16 - zMinDiff;
    chunkZ=cz - up(zMinDiff / 16) - 1;
  }
 else   if (relZ > 15) {
    newZ=zMaxDiff - 1;
    chunkZ=cz + up(zMaxDiff / 16) + 1;
  }
  ChunkLocation loc=ChunkLocation.create(chunkX,chunkZ);
  TridentChunk chunk=rawChunk(loc);
  TridentLogger.get().debug(relX + ""String_Node_Str"" + relZ+ ""String_Node_Str""+ xMinDiff+ ""String_Node_Str""+ xMaxDiff+ ""String_Node_Str""+ zMinDiff+ ""String_Node_Str""+ zMaxDiff+ ""String_Node_Str""+ newX+ ""String_Node_Str""+ newZ);
  chunk.setAndSend(newX,y,newZ,substance,data,(byte)255,(byte)15,change);
}"
11776,"/** 
 * Blocks the thread until this method is called again by a   {@link #complete(String)} method
 */
public static void awaitSync(){
  boolean b=canProceed();
  if (b)   return;
  try {
    if (!latch.await(200,TimeUnit.MILLISECONDS)) {
      TridentLogger.get().warn(""String_Node_Str"" + complete.sum() + ""String_Node_Str""+ expected.sum()+ ""String_Node_Str""+ b);
      if (DEBUG) {
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"");
        completed.forEach(TridentLogger::warn);
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"");
        expect.forEach(TridentLogger::warn);
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"" + TridentServer.instance().mainThread().getAverageTickLength() + ""String_Node_Str"");
      }
 else {
        TridentLogger.get().warn(""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","/** 
 * Blocks the thread until this method is called again by a   {@link #complete(String)} method
 */
public static void awaitSync(){
  boolean b=canProceed();
  if (b)   return;
  try {
    if (!latch.await(200,TimeUnit.MILLISECONDS)) {
      TridentLogger.get().warn(""String_Node_Str"" + complete.sum() + ""String_Node_Str""+ expected.sum()+ ""String_Node_Str""+ b);
      if (DEBUG) {
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"");
        completed.forEach(s -> TridentLogger.get().warn(s));
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"");
        expect.forEach(s -> TridentLogger.get().warn(s));
        TridentLogger.get().warn(""String_Node_Str"");
        TridentLogger.get().warn(""String_Node_Str"" + TridentServer.instance().mainThread().getAverageTickLength() + ""String_Node_Str"");
      }
 else {
        TridentLogger.get().warn(""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
11777,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  location.setWorld(player.world());
  Substance substance=player.heldItem().type();
  if (substance != Substance.AIR) {
    Vector vector=determineOffset();
    if (!substance.isBlock()) {
    }
    if (location.y() + vector.y() > 255 || location.y() + vector.y() < 0) {
      return;
    }
    Position position=location.relative(vector);
    Block block=new OwnedTridentBlock(player,position.block());
    short yaw=(short)(player.position().yaw() * 10);
    short meta=player.heldItem().damageValue();
    Value<Byte> result=Value.of((byte)0);
    Value<Substance> substanceValue=Value.of(substance);
    boolean allow=MetaFactory.decode(block,substanceValue,new byte[]{writeFirst(yaw),writeSecond(yaw),direction,((byte)cursorPosition.x()),((byte)cursorPosition.y()),((byte)cursorPosition.z()),writeFirst(meta),writeSecond(meta)},result);
    if (allow) {
      block.setSubstanceAndMeta(substanceValue.get(),result.get());
    }
  }
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  location.setWorld(player.world());
  Substance substance=player.heldItem().type();
  if (substance != Substance.AIR) {
    Vector vector=determineOffset();
    if (!substance.isBlock()) {
      return;
    }
    if (substance.isFunctional() && !player.isCrouching()) {
      return;
    }
    if (location.y() + vector.y() > 255 || location.y() + vector.y() < 0) {
      return;
    }
    Position position=location.relative(vector);
    Block block=new OwnedTridentBlock(player,position.block());
    short yaw=(short)(player.position().yaw() * 10);
    short meta=player.heldItem().damageValue();
    Value<Byte> result=Value.of((byte)0);
    Value<Substance> substanceValue=Value.of(substance);
    boolean allow=MetaFactory.decode(block,substanceValue,new byte[]{writeFirst(yaw),writeSecond(yaw),direction,((byte)cursorPosition.x()),((byte)cursorPosition.y()),((byte)cursorPosition.z()),writeFirst(meta),writeSecond(meta)},result);
    if (allow) {
      block.setSubstanceAndMeta(substanceValue.get(),result.get());
      SoundEffectType soundEffectType=substance.placeSound();
      if (soundEffectType != null) {
        SoundEffect sound=location.world().playSound(soundEffectType);
        sound.setPosition(location);
        sound.apply();
      }
    }
  }
}"
11778,"public void save(){
  CompoundTag tag=new CompoundTag(""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"");
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.x()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.y()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.z()));
  tag.addTag(new DoubleTag(""String_Node_Str"").setValue(borderSize));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficulty.asByte()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficultyLocked ? (byte)1 : (byte)0));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(time.get()));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(existed.get()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(raining ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(defaultGamemode.asByte()));
  tag.addTag(new StringTag(""String_Node_Str"").setValue(type.toString()));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(loader.generator().seed()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(rainTime.get()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(thundering ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(thunderTime.get()));
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  try {
    GZIPOutputStream gzip=new GZIPOutputStream(os);
    CompoundTag root=new CompoundTag(""String_Node_Str"");
    root.addTag(tag);
    new NBTEncoder(new DataOutputStream(gzip)).encode(root);
    gzip.close();
    Files.write(Paths.get(name,File.separator,""String_Node_Str""),os.toByteArray());
  }
 catch (  IOException|NBTException ex) {
    TridentLogger.warn(""String_Node_Str"");
    TridentLogger.error(ex);
  }
  for (  TridentChunk chunk : loadedChunks()) {
    chunk.executor.execute(() -> RegionFile.fromPath(name,chunk.location()).saveChunkData(chunk));
  }
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
}","public void save(){
  CompoundTag tag=new CompoundTag(""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"");
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.x()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.y()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.z()));
  tag.addTag(new DoubleTag(""String_Node_Str"").setValue(borderSize));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficulty.asByte()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficultyLocked ? (byte)1 : (byte)0));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(time.get()));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(existed.get()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(raining ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(defaultGamemode.asByte()));
  tag.addTag(new StringTag(""String_Node_Str"").setValue(type.toString()));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(seed));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(rainTime.get()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(thundering ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(thunderTime.get()));
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  try {
    GZIPOutputStream gzip=new GZIPOutputStream(os);
    CompoundTag root=new CompoundTag(""String_Node_Str"");
    root.addTag(tag);
    new NBTEncoder(new DataOutputStream(gzip)).encode(root);
    gzip.close();
    Files.write(Paths.get(name,File.separator,""String_Node_Str""),os.toByteArray());
  }
 catch (  IOException|NBTException ex) {
    TridentLogger.warn(""String_Node_Str"");
    TridentLogger.error(ex);
  }
  for (  TridentChunk chunk : loadedChunks()) {
    chunk.executor.execute(() -> RegionFile.fromPath(name,chunk.location()).saveChunkData(chunk));
  }
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
}"
11779,"/** 
 * Resets the counters and the blocking mechanisms for the next tick iteration
 */
public static void reset(){
  expected.reset();
  complete.reset();
  proceed.reset();
}","/** 
 * Resets the counters and the blocking mechanisms for the next tick iteration
 */
public static void reset(){
  expected.reset();
  complete.reset();
  latch=new CountDownLatch(1);
  Lock lock=taskLock;
  lock.lock();
  try {
    taskLock=new ReentrantLock();
    available=taskLock.newCondition();
  }
  finally {
    lock.unlock();
  }
}"
11780,"/** 
 * Records that an update has occurred <p> <p>Signals the main thread to sync method to continue if the expected and update counters match</p>
 */
public static void complete(){
  complete.increment();
  if (canProceed()) {
    awaitSync();
  }
}","/** 
 * Records that an update has occurred <p> <p>Signals the main thread to sync method to continue if the expected and update counters match</p>
 */
public static void complete(){
  complete.increment();
  if (canProceed()) {
    latch.countDown();
  }
}"
11781,"/** 
 * Blocks the thread until this method is called again by a   {@link #complete()} method
 */
public static void awaitSync(){
  if (canProceed())   return;
  try {
    proceed.await();
  }
 catch (  InterruptedException|BrokenBarrierException e) {
    e.printStackTrace();
  }
}","/** 
 * Blocks the thread until this method is called again by a   {@link #complete()} method
 */
public static void awaitSync(){
  if (canProceed())   return;
  try {
    latch.await();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
11782,"public void populate(Block block){
  Substance substance=block.substance();
  MetaCompiler compiler=metaMap.get(substance);
  if (compiler != null) {
    for (    BlockMeta<Block> meta : compiler.compileBlock(block)) {
      block.commit(meta,false);
    }
  }
}","public void populate(Block block){
  Substance substance=block.substance();
  MetaCompiler compiler=metaMap.get(substance);
  if (compiler != null) {
    for (    BlockMeta<Block> meta : compiler.compileBlock(block)) {
      block.applyMeta(meta,false);
    }
  }
}"
11783,"@Override public void setPosition(Position loc){
  players().stream().filter((p) -> !p.equals(this)).forEach((p) -> {
    ((TridentPlayer)p).connection.sendPacket(new PacketPlayOutEntityTeleport().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",loc).set(""String_Node_Str"",onGround));
  }
);
  super.setPosition(loc);
}","@Override public void setPosition(Position loc){
  double dX=loc.x() - position().x();
  double dY=loc.y() - position().y();
  double dZ=loc.z() - position().z();
  if (dX == 0 && dY == 0 && dZ == 0) {
    sendFiltered(new PacketPlayOutEntityLook().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",loc).set(""String_Node_Str"",onGround),player -> !player.equals(this));
    return;
  }
  if ((dX > 4 || dY > 4 || dZ > 4) || (ticksExisted.get() & 1) == 0) {
    sendFiltered(new PacketPlayOutEntityTeleport().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",loc).set(""String_Node_Str"",onGround),player -> !player.equals(this));
  }
 else {
    for (    Player player : players()) {
      if (player.equals(this))       continue;
      Packet packet=new PacketPlayOutEntityRelativeMove().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",new Vector(dX,dY,dZ)).set(""String_Node_Str"",onGround);
      ((TridentPlayer)player).connection.sendPacket(packet);
    }
  }
  super.setPosition(loc);
}"
11784,"@Override protected void doRemove(){
  ONLINE_PLAYERS.remove(this.uniqueId());
  cleanChunks(0);
  PacketPlayOutPlayerListItem item=new PacketPlayOutPlayerListItem();
  item.set(""String_Node_Str"",4).set(""String_Node_Str"",new PlayerListDataBuilder[]{new PacketPlayOutPlayerListItem.PlayerListDataBuilder().id(uniqueId).values(new Object[0])});
  sendAll(item);
  players().forEach(p -> new MessageBuilder(name + ""String_Node_Str"").color(ChatColor.YELLOW).build().sendTo(p));
  TridentLogger.log(name + ""String_Node_Str"");
}","@Override protected void doRemove(){
  ONLINE_PLAYERS.remove(this.uniqueId());
  PacketPlayOutPlayerListItem item=new PacketPlayOutPlayerListItem();
  item.set(""String_Node_Str"",4).set(""String_Node_Str"",new PlayerListDataBuilder[]{new PacketPlayOutPlayerListItem.PlayerListDataBuilder().id(uniqueId).values(new Object[0])});
  sendAll(item);
  players().forEach(p -> new MessageBuilder(name + ""String_Node_Str"").color(ChatColor.YELLOW).build().sendTo(p));
  TridentLogger.log(name + ""String_Node_Str"");
}"
11785,"@InternalUseOnly public void setCrouching(boolean crouching){
  PacketPlayOutEffect effect=new PacketPlayOutEffect();
  effect.set(""String_Node_Str"",104);
  this.crouching=crouching;
}","@InternalUseOnly public void setCrouching(boolean crouching){
  ProtocolMetadata meta=new ProtocolMetadata();
  encodeMetadata(meta);
  int idx=0;
  int mask=0x02;
  meta.setMeta(idx,MetadataType.BYTE,(byte)(((byte)meta.get(0).value() & ~mask) | (crouching ? mask : 0)));
  sendFiltered(new PacketPlayOutEntityMetadata().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",meta),p -> !p.equals(this));
  this.crouching=crouching;
}"
11786,"@Override public TaskExecutor nextWorker(){
  int count;
  int max=this.count.get();
  long stamp=lock.readLock();
  try {
    count=this.scaleIdx;
  }
  finally {
    lock.unlockRead(stamp);
  }
  if (count >= max) {
    count=0;
    stamp=lock.writeLock();
    try {
      this.scaleIdx=0;
    }
  finally {
      lock.unlockWrite(stamp);
    }
  }
 else {
    stamp=lock.writeLock();
    try {
      scaleIdx++;
    }
  finally {
      lock.unlockWrite(stamp);
    }
  }
  return workerSet.get(count);
}","@Override public TaskExecutor nextWorker(){
  int count;
  int max=this.workerSet.size();
  long stamp=lock.readLock();
  try {
    count=this.scaleIdx;
  }
  finally {
    lock.unlockRead(stamp);
  }
  if (count >= max) {
    count=0;
    stamp=lock.writeLock();
    try {
      this.scaleIdx=0;
    }
  finally {
      lock.unlockWrite(stamp);
    }
  }
 else {
    stamp=lock.writeLock();
    try {
      scaleIdx++;
    }
  finally {
      lock.unlockWrite(stamp);
    }
  }
  return workerSet.get(count);
}"
11787,"@Override public void handleReceived(ClientConnection connection){
  PluginChannel channel=Registered.channels().fromName(this.channel);
  if (channel != null) {
    channel.read(this.data);
  }
}","@Override public void handleReceived(ClientConnection connection){
  PluginChannel channel=Registered.channels().fromName(this.channel);
  if (channel != null) {
    Registered.plugins().executor().execute(() -> channel.read(this.data));
  }
}"
11788,"@Override public Packet decode(ByteBuf buf){
  this.target=Codec.readVarInt32(buf);
  this.type=InteractType.fromId(Codec.readVarInt32(buf));
  double x=(double)buf.readFloat();
  double y=(double)buf.readFloat();
  double z=(double)buf.readFloat();
  this.location=Position.create(null,x,y,z);
  return this;
}","@Override public Packet decode(ByteBuf buf){
  this.target=Codec.readVarInt32(buf);
  this.type=InteractType.fromId(Codec.readVarInt32(buf));
  if (type == InteractType.INTERACT_AT) {
    double x=(double)buf.readFloat();
    double y=(double)buf.readFloat();
    double z=(double)buf.readFloat();
    this.location=Position.create(null,x,y,z);
  }
  return this;
}"
11789,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  if (location.y() >= 4095) {
    return;
  }
  Substance substance=player.heldItem().type();
  if (!substance.isBlock()) {
  }
  if (substance != Substance.AIR) {
    int x=(int)location.x();
    int y=(int)location.y();
    int z=(int)location.z();
switch (blockDirection()) {
case 0:
      y--;
    break;
case 1:
  y++;
break;
case 2:
z--;
break;
case 3:
z++;
break;
case 4:
x--;
break;
case 5:
x++;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
Position position=Position.create(player.world(),x,y,z);
position.block().setSubstance(substance);
}
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  location.setWorld(player.world());
  if (location.y() >= 4095) {
    return;
  }
  Substance substance=player.heldItem().type();
  if (!substance.isBlock()) {
  }
  if (substance != Substance.AIR) {
    int x=0;
    int y=0;
    int z=0;
switch (blockDirection()) {
case 0:
      y--;
    break;
case 1:
  y++;
break;
case 2:
z--;
break;
case 3:
z++;
break;
case 4:
x--;
break;
case 5:
x++;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
Position position=location.relative(new Vector(x,y,z));
position.block().setSubstance(substance);
}
}"
11790,"@Override public Block blockAt(Position location){
  if (!location.world().name().equals(this.name()))   throw new IllegalArgumentException(""String_Node_Str"");
  int x=(int)Math.round(location.x());
  int y=(int)Math.round(location.y());
  int z=(int)Math.round(location.z());
  return this.chunkAt(WorldUtils.chunkLocation(x,z),true).blockAt(x % 16,y,z % 16);
}","@Override public Block blockAt(Position location){
  if (!location.world().name().equals(this.name()))   throw new IllegalArgumentException(""String_Node_Str"");
  int x=(int)Math.round(location.x());
  int y=(int)Math.round(location.y());
  int z=(int)Math.round(location.z());
  return this.chunkAt(WorldUtils.chunkLocation(x,z),true).blockAt(x & 15,y,z & 15);
}"
11791,"/** 
 * Occupies up a certain length of sectors, from a starting point
 * @param start  the sector to start from (inclusive)
 * @param length the amount of sectors to occupy
 */
void addSectors(int start,int length){
  for (int i=start; i < start + length; i++) {
    this.sectorMapping.set(i,true);
  }
}","/** 
 * Occupies up a certain length of sectors, from a starting point
 * @param start  the sector to start from (inclusive)
 * @param length the amount of sectors to occupy
 */
void addSectors(int start,int length){
  for (int i=start; i < start + length; i++) {
    sectorMapping[i]=1;
  }
}"
11792,"private SectorStorage(int... offsets){
  this.offsets=offsets;
  this.sectorMapping=new BitSet(1024);
  this.sectorMapping.set(0);
  this.sectorMapping.set(1);
  for (  int offset : offsets) {
    int loc=offset >> 8;
    int length=offset & 0xFF;
    for (int j=loc; j < loc + length; j++) {
      this.sectorMapping.set(j);
    }
  }
}","private SectorStorage(int... offsets){
  this.offsets=offsets;
  this.sectorMapping=new byte[1024];
  sectorMapping[0]=1;
  sectorMapping[1]=1;
  for (  int offset : offsets) {
    int loc=offset >> 8;
    int length=offset & 0xFF;
    for (int j=loc; j < loc + length; j++) {
      sectorMapping[j]=1;
    }
  }
}"
11793,"/** 
 * Free up a certain length of sectors, from a starting point
 * @param start  the sector to start from (inclusive)
 * @param length the amount of sectors to free up
 */
void freeSectors(int start,int length){
  for (int i=start; i < start + length; i++) {
    this.sectorMapping.set(i,false);
  }
}","/** 
 * Free up a certain length of sectors, from a starting point
 * @param start  the sector to start from (inclusive)
 * @param length the amount of sectors to free up
 */
void freeSectors(int start,int length){
  for (int i=start; i < start + length; i++) {
    sectorMapping[i]=0;
  }
}"
11794,"/** 
 * Finds a section of the file with enough free-space to accomodate 'length' sectors of data
 * @param length the amount of sectors of data
 * @return offset the location of the free space (in sectors)
 */
int findFreeSectors(int length){
  int counter=2;
  int consecutive=0;
  while (true) {
    if (!this.sectorMapping.get(counter)) {
      consecutive++;
      if (consecutive >= length) {
        break;
      }
    }
 else {
      consecutive=0;
    }
  }
  return counter;
}","/** 
 * Finds a section of the file with enough free-space to accomodate 'length' sectors of data
 * @param length the amount of sectors of data
 * @return offset the location of the free space (in sectors)
 */
int findFreeSectors(int length){
  int counter=2;
  int consecutive=0;
  while (consecutive < length) {
    if (sectorMapping[counter] != 1) {
      consecutive++;
      if (consecutive == length) {
        break;
      }
    }
 else {
      consecutive=0;
    }
    counter++;
  }
  return counter;
}"
11795,"/** 
 * Pass in a chunk to save its data to the file
 */
public void saveChunkData(TridentChunk chunk) throws IOException, NBTException {
  ByteArrayOutputStream nbtStream=new ByteArrayOutputStream();
  new NBTEncoder(new DataOutputStream(nbtStream)).encode(chunk.asNbt());
  byte[] uncompressed=nbtStream.toByteArray();
  Deflater deflater=new Deflater();
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  deflater.setInput(uncompressed);
  deflater.finish();
  while (!deflater.finished()) {
    int bytes=deflater.deflate(buffer);
    os.write(buffer,0,bytes);
  }
  byte[] compressed=os.toByteArray();
  int actualLength=compressed.length + 1;
  int sectorLength=IntMath.divide(actualLength,SectorStorage.SECTOR_LENGTH,RoundingMode.CEILING);
  int oldSectorLength=this.sectors.dataSectors(chunk);
  if (sectorLength < oldSectorLength) {
    this.sectors.setDataSectors(chunk,sectors.rawOffset(chunk) | sectorLength);
    this.sectors.freeSectors(this.sectors.sectorOffset(chunk) + sectorLength - 1,oldSectorLength - sectorLength);
  }
 else   if (sectorLength > oldSectorLength) {
    this.sectors.setDataSectors(chunk,sectors.rawOffset(chunk) | sectorLength);
    this.sectors.freeSectors(this.sectors.sectorOffset(chunk),oldSectorLength);
    this.sectors.setSectorOffset(chunk,this.sectors.findFreeSectors(sectorLength));
  }
  this.sectors.addSectors(this.sectors.sectorOffset(chunk),this.sectors.dataSectors(chunk));
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    long dataLoc=(long)this.sectors.dataLoc(chunk);
    access.seek(dataLoc);
    access.writeInt(actualLength);
    access.write((int)(byte)2);
    access.write(compressed);
    int paddingNeeded=actualLength % SectorStorage.SECTOR_LENGTH;
    if (paddingNeeded != 0) {
      byte[] padding=new byte[paddingNeeded];
      access.write(padding);
    }
    access.seek((long)(this.sectors.offsetLoc(chunk)));
    access.write(this.sectors.rawOffset(chunk));
    this.packFile(access);
    access.close();
  }
}","/** 
 * Pass in a chunk to save its data to the file
 */
public void saveChunkData(TridentChunk chunk) throws IOException, NBTException {
  CompoundTag tag=chunk.asNbt();
  ByteArrayOutputStream nbtStream=new ByteArrayOutputStream();
  new NBTEncoder(new DataOutputStream(nbtStream)).encode(tag);
  byte[] uncompressed=nbtStream.toByteArray();
  Deflater deflater=new Deflater();
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  deflater.setInput(uncompressed);
  deflater.finish();
  while (!deflater.finished()) {
    int bytes=deflater.deflate(buffer);
    os.write(buffer,0,bytes);
  }
  byte[] compressed=os.toByteArray();
  int actualLength=compressed.length + 1;
  int sectorLength=IntMath.divide(actualLength,SectorStorage.SECTOR_LENGTH,RoundingMode.CEILING);
  int oldSectorLength=this.sectors.dataSectors(chunk);
  if (sectorLength < oldSectorLength) {
    this.sectors.setDataSectors(chunk,sectors.rawOffset(chunk) | sectorLength);
    this.sectors.freeSectors(this.sectors.sectorOffset(chunk) + sectorLength - 1,oldSectorLength - sectorLength);
  }
 else   if (sectorLength > oldSectorLength) {
    this.sectors.setDataSectors(chunk,sectors.rawOffset(chunk) | sectorLength);
    this.sectors.freeSectors(this.sectors.sectorOffset(chunk),oldSectorLength);
    int newLocation=sectors.findFreeSectors(sectorLength);
    int hashCode=hashCode();
    int offsetLoc=sectors.offsetLoc(chunk);
    sectors.offsets[offsetLoc]=(newLocation << 8);
    sectors.addSectors(newLocation,sectorLength);
  }
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    long dataLoc=(long)this.sectors.dataLoc(chunk);
    access.seek(dataLoc);
    access.writeInt(actualLength);
    access.write((int)(byte)2);
    access.write(compressed);
    int paddingNeeded=actualLength % SectorStorage.SECTOR_LENGTH;
    if (paddingNeeded != 0) {
      byte[] padding=new byte[paddingNeeded];
      access.write(padding);
    }
    access.seek((long)(this.sectors.offsetLoc(chunk)));
    access.write(this.sectors.rawOffset(chunk));
    this.packFile(access);
    access.seek((long)sectors.timeStampLoc(chunk));
    access.writeInt((int)(System.currentTimeMillis() / 1000L));
    access.close();
  }
}"
11796,"public void save(){
  CompoundTag tag=new CompoundTag(""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"");
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.x()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.y()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.z()));
  tag.addTag(new DoubleTag(""String_Node_Str"").setValue(borderSize));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficulty.asByte()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficultyLocked ? (byte)1 : (byte)0));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(time));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(existed));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(raining ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(defaultGamemode.asByte()));
  tag.addTag(new StringTag(""String_Node_Str"").setValue(type.toString()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(rainTime));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(thundering ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(thunderTime));
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  try {
    GZIPOutputStream gzip=new GZIPOutputStream(os);
    CompoundTag root=new CompoundTag(""String_Node_Str"");
    root.addTag(tag);
    new NBTEncoder(new DataOutputStream(gzip)).encode(root);
    gzip.close();
    Files.write(Paths.get(name,File.separator,""String_Node_Str""),os.toByteArray());
  }
 catch (  IOException|NBTException ex) {
    TridentLogger.warn(""String_Node_Str"");
    TridentLogger.error(ex);
  }
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  for (  TridentChunk chunk : loadedChunks()) {
    try {
      RegionFile.fromPath(name,chunk.location()).saveChunkData(chunk);
    }
 catch (    IOException|NBTException ex) {
      TridentLogger.warn(""String_Node_Str"" + chunk.x() + ""String_Node_Str""+ chunk.z()+ ""String_Node_Str"");
      TridentLogger.error(ex);
    }
  }
}","public void save(){
  CompoundTag tag=new CompoundTag(""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  TridentLogger.log(""String_Node_Str"");
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.x()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.y()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnPosition.z()));
  tag.addTag(new DoubleTag(""String_Node_Str"").setValue(borderSize));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficulty.asByte()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(difficultyLocked ? (byte)1 : (byte)0));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(time));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(existed));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(raining ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(defaultGamemode.asByte()));
  tag.addTag(new StringTag(""String_Node_Str"").setValue(type.toString()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(rainTime));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(thundering ? (byte)1 : (byte)0));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(thunderTime));
  ByteArrayOutputStream os=new ByteArrayOutputStream();
  try {
    GZIPOutputStream gzip=new GZIPOutputStream(os);
    CompoundTag root=new CompoundTag(""String_Node_Str"");
    root.addTag(tag);
    new NBTEncoder(new DataOutputStream(gzip)).encode(root);
    gzip.close();
    Files.write(Paths.get(name,File.separator,""String_Node_Str""),os.toByteArray());
  }
 catch (  IOException|NBTException ex) {
    TridentLogger.warn(""String_Node_Str"");
    TridentLogger.error(ex);
  }
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  for (  TridentChunk chunk : loadedChunks()) {
    try {
      RegionFile.fromPath(name,chunk.location()).saveChunkData(chunk);
      System.out.println(""String_Node_Str"" + chunk.x() + ""String_Node_Str""+ chunk.z());
    }
 catch (    IOException|NBTException ex) {
      TridentLogger.warn(""String_Node_Str"" + chunk.x() + ""String_Node_Str""+ chunk.z()+ ""String_Node_Str"");
      TridentLogger.error(ex);
    }
  }
  RegionFile.saveAll();
  System.out.println(""String_Node_Str"");
}"
11797,"/** 
 * Tracks the movement of the entity, not for teleportation
 * @param entity the entity to track
 * @param from   the original location
 * @param to     the new location
 */
public void trackMovement(Entity entity,Position from,Position to){
  tracker.trackMovement(entity,from,to);
}","/** 
 * Tracks the movement of the entity, not for teleportation
 * @param entity the entity to track
 * @param from   the original location
 * @param to     the new location
 */
public void trackMovement(Entity entity,Position from,Position to){
}"
11798,"private PlayerConnection(ClientConnection connection,TridentPlayer player){
  ClientConnection.clientData.remove(connection.address());
  ClientConnection.clientData.retrieve(connection.address(),() -> PlayerConnection.this);
  super.address=connection.address();
  super.channel=connection.channel();
  super.loginKeyPair=connection.loginKeyPair();
  super.sharedSecret=connection.sharedSecret();
  super.stage=Protocol.ClientStage.PLAY;
  super.encryptionEnabled=connection.isEncryptionEnabled();
  super.compressionEnabled=connection.isCompressionEnabled();
  this.player=player;
  PacketHandler handler=channel.pipeline().get(PacketHandler.class);
  if (handler != null) {
    handler.updateConnection(this);
  }
}","private PlayerConnection(ClientConnection connection,TridentPlayer player){
  ClientConnection.clientData.put(connection.address(),connection);
  super.address=connection.address();
  super.channel=connection.channel();
  super.loginKeyPair=connection.loginKeyPair();
  super.sharedSecret=connection.sharedSecret();
  super.stage=Protocol.ClientStage.PLAY;
  super.encryptionEnabled=connection.isEncryptionEnabled();
  super.compressionEnabled=connection.isCompressionEnabled();
  this.player=player;
  PacketHandler handler=channel.pipeline().get(PacketHandler.class);
  if (handler != null) {
    handler.updateConnection(this);
  }
}"
11799,"@Override public void setLocation(Position loc){
  ProtocolMetadata metadata=new ProtocolMetadata();
  encodeMetadata(metadata);
  PacketPlayOutEntityCompleteMove move=new PacketPlayOutEntityCompleteMove();
  move.set(""String_Node_Str"",entityId()).set(""String_Node_Str"",position().asVector().subtract(loc.asVector())).set(""String_Node_Str"",loc.pitch()).set(""String_Node_Str"",loc.yaw()).set(""String_Node_Str"",(byte)0x00);
  sendFiltered(move,(p) -> !p.equals(this));
  super.setLocation(loc);
}","@Override public void setLocation(Position loc){
  ProtocolMetadata metadata=new ProtocolMetadata();
  encodeMetadata(metadata);
  PacketPlayOutEntityCompleteMove move=new PacketPlayOutEntityCompleteMove();
  move.set(""String_Node_Str"",entityId()).set(""String_Node_Str"",loc.pitch()).set(""String_Node_Str"",loc.yaw()).set(""String_Node_Str"",(byte)0x00);
  players().stream().filter((p) -> !p.equals(this)).forEach((p) -> {
    Vector difference=p.position().asVector().subtract(loc.asVector());
    move.set(""String_Node_Str"",difference);
    if (Math.abs(difference.x()) > 4 || Math.abs(difference.y()) > 4 || Math.abs(difference.z()) > 4) {
      ((TridentPlayer)p).connection.sendPacket(new PacketPlayOutEntityTeleport().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",loc).set(""String_Node_Str"",onGround));
      return;
    }
    ((TridentPlayer)p).connection.sendPacket(move);
  }
);
  super.setLocation(loc);
}"
11800,"@Override public TaskExecutor scaledThread(){
  for (  TaskExecutor ex : workers) {
    Worker w=(Worker)ex;
    if (!w.isHeld()) {
      return w;
    }
  }
  return addWorker(true);
}","@Override public TaskExecutor scaledThread(){
  for (  TaskExecutor ex : workerSet) {
    Worker w=(Worker)ex;
    if (!w.isHeld()) {
      return w;
    }
  }
  return addWorker(true);
}"
11801,"public void tick(){
  executor.execute(new Runnable(){
    @Override public void run(){
      ticksExisted.incrementAndGet();
      doTick();
    }
  }
);
}","public void tick(){
  executor.execute(() -> {
    ticksExisted.incrementAndGet();
    doTick();
  }
);
}"
11802,"@Override public Set<Entity> withinRange(double radius){
  double squared=radius * radius;
  Set<Entity> entities=location().world().entities();
  return entities.stream().filter((e) -> e.location().distanceSquared(location()) <= squared).collect(Collectors.toSet());
}","@Override public Set<Entity> withinRange(double radius){
  double squared=radius * radius;
  Set<Entity> entities=position().world().entities();
  return entities.stream().filter((e) -> e.position().distanceSquared(position()) <= squared).collect(Collectors.toSet());
}"
11803,"public void tick(){
  ThreadsHandler.worldExecutor().execute(() -> {
    redstoneTick=!redstoneTick;
    if (time >= 2400)     time=0;
    if (time % 40 == 0)     TridentPlayer.sendAll(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed).set(""String_Node_Str"",time));
    rainTime--;
    thunderTime--;
    if (rainTime <= 0) {
      raining=!raining;
      rainTime=ThreadLocalRandom.current().nextInt();
    }
    if (thunderTime <= 0) {
      thundering=!thundering;
      thunderTime=ThreadLocalRandom.current().nextInt();
    }
    time++;
    existed++;
    if (time % 150 == 0) {
      Set<ChunkLocation> set=Sets.newHashSet();
      for (      Entity entity : entities) {
        if (entity instanceof Player) {
          Position pos=entity.location();
          int x=(int)pos.x() % 16;
          int z=(int)pos.z() % 16;
          int viewDist=Trident.config().getInt(""String_Node_Str"",7);
          for (int i=x - viewDist; i < x + viewDist; i++) {
            for (int j=z - viewDist; j < z + viewDist; j++) {
              set.add(ChunkLocation.create(i,j));
            }
          }
        }
      }
      loadedChunks.retain(set);
      set=null;
    }
  }
);
}","public void tick(){
  ThreadsHandler.worldExecutor().execute(() -> {
    redstoneTick=!redstoneTick;
    if (time >= 2400)     time=0;
    if (time % 40 == 0)     TridentPlayer.sendAll(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed).set(""String_Node_Str"",time));
    rainTime--;
    thunderTime--;
    if (rainTime <= 0) {
      raining=!raining;
      rainTime=ThreadLocalRandom.current().nextInt();
    }
    if (thunderTime <= 0) {
      thundering=!thundering;
      thunderTime=ThreadLocalRandom.current().nextInt();
    }
    time++;
    existed++;
    if (time % 150 == 0) {
      Set<ChunkLocation> set=Sets.newHashSet();
      for (      Entity entity : entities) {
        if (entity instanceof Player) {
          Position pos=entity.position();
          int x=(int)pos.x() % 16;
          int z=(int)pos.z() % 16;
          int viewDist=Trident.config().getInt(""String_Node_Str"",7);
          for (int i=x - viewDist; i < x + viewDist; i++) {
            for (int j=z - viewDist; j < z + viewDist; j++) {
              set.add(ChunkLocation.create(i,j));
            }
          }
        }
      }
      loadedChunks.retain(set);
      set=null;
    }
  }
);
}"
11804,"/** 
 * Inherits constructor from   {@link net.tridentsdk.server.entity.living.TridentLivingEntity}
 */
public TridentInventoryHolder(UUID id,Position spawnLocation){
  super(id,spawnLocation);
  BARRIER=new Object();
}","/** 
 * Inherits constructor from   {@link TridentLivingEntity}
 */
public TridentInventoryHolder(UUID id,Position spawnLocation){
  super(id,spawnLocation);
  BARRIER=new Object();
}"
11805,"@Override public void show(Entity entity){
  PacketPlayOutSpawnMob packet=new PacketPlayOutSpawnMob();
  packet.set(""String_Node_Str"",entity.entityId()).set(""String_Node_Str"",entity).set(""String_Node_Str"",((TridentEntity)entity).protocolMeta);
  if (this instanceof Player) {
    ((TridentPlayer)this).connection().sendPacket(packet);
  }
}","@Override public void show(Entity entity){
  PacketPlayOutSpawnMob packet=new PacketPlayOutSpawnMob();
  ProtocolMetadata protocolMeta=new ProtocolMetadata();
  ((TridentEntity)entity).encodeMetadata(protocolMeta);
  packet.set(""String_Node_Str"",entity.entityId()).set(""String_Node_Str"",entity).set(""String_Node_Str"",protocolMeta);
  if (this instanceof Player) {
    ((TridentPlayer)this).connection().sendPacket(packet);
  }
}"
11806,"@Override public void show(Entity entity){
  PacketPlayOutSpawnMob packet=new PacketPlayOutSpawnMob();
  ProtocolMetadata protocolMeta=new ProtocolMetadata();
  ((TridentEntity)entity).encodeMetadata(protocolMeta);
  packet.set(""String_Node_Str"",entity.entityId()).set(""String_Node_Str"",entity).set(""String_Node_Str"",((TridentEntity)entity).protocolMeta);
  if (this instanceof Player) {
    ((TridentPlayer)this).connection().sendPacket(packet);
  }
}","@Override public void show(Entity entity){
  PacketPlayOutSpawnMob packet=new PacketPlayOutSpawnMob();
  ProtocolMetadata protocolMeta=new ProtocolMetadata();
  ((TridentEntity)entity).encodeMetadata(protocolMeta);
  packet.set(""String_Node_Str"",entity.entityId()).set(""String_Node_Str"",entity).set(""String_Node_Str"",protocolMeta);
  if (this instanceof Player) {
    ((TridentPlayer)this).connection().sendPacket(packet);
  }
}"
11807,"void clear(){
  for (  ChunkSection section : sections) {
    section.clear();
  }
  executor.addTask(new Runnable(){
    @Override public void run(){
      sections=null;
    }
  }
);
  try {
    data.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","void clear(){
  for (  ChunkSection section : sections) {
    section.clear();
  }
  executor.addTask(new Runnable(){
    @Override public void run(){
      sections=null;
    }
  }
);
}"
11808,"public PacketPlayOutChunkData asPacket(){
  try {
    return executor.submitTask(new Callable<PacketPlayOutChunkData>(){
      @Override public PacketPlayOutChunkData call() throws Exception {
        PacketPlayOutChunkData packet=new PacketPlayOutChunkData();
        int bitmask=(1 << sections.length) - 1;
        int count=sections.length;
        int size=0;
        int sectionSize=ChunkSection.LENGTH * 5 / 2;
        if (world.dimension() == Dimension.OVERWORLD)         sectionSize+=ChunkSection.LENGTH / 2;
        size+=count * sectionSize + 256;
        for (        ChunkSection section : sections) {
          if (section == null)           continue;
          for (          char c : section.types()) {
            data.write(c & 0xff);
            data.write(c >> 8);
          }
        }
        for (        ChunkSection section : sections) {
          try {
            data.write(section.blockLight);
          }
 catch (          IOException e) {
            TridentLogger.error(e);
          }
        }
        for (        ChunkSection section : sections) {
          try {
            data.write(section.skyLight);
          }
 catch (          IOException e) {
            TridentLogger.error(e);
          }
        }
        for (int i=0; i < 256; i+=1) {
          data.write(0);
        }
        packet.set(""String_Node_Str"",location);
        packet.set(""String_Node_Str"",(short)bitmask);
        packet.set(""String_Node_Str"",data.toByteArray());
        data.reset();
        return packet;
      }
    }
).get();
  }
 catch (  InterruptedException|ExecutionException e) {
    TridentLogger.error(e);
    return null;
  }
}","public PacketPlayOutChunkData asPacket(){
  try {
    return executor.submitTask(new Callable<PacketPlayOutChunkData>(){
      @Override public PacketPlayOutChunkData call() throws Exception {
        PacketPlayOutChunkData packet=new PacketPlayOutChunkData();
        int bitmask=(1 << sections.length) - 1;
        ByteArrayOutputStream data=new ByteArrayOutputStream();
        for (        ChunkSection section : sections) {
          if (section == null)           continue;
          for (          char c : section.types()) {
            data.write(c & 0xff);
            data.write(c >> 8);
          }
        }
        for (        ChunkSection section : sections) {
          try {
            data.write(section.blockLight);
          }
 catch (          IOException e) {
            TridentLogger.error(e);
          }
        }
        for (        ChunkSection section : sections) {
          try {
            data.write(section.skyLight);
          }
 catch (          IOException e) {
            TridentLogger.error(e);
          }
        }
        for (int i=0; i < 256; i+=1) {
          data.write(0);
        }
        packet.set(""String_Node_Str"",location);
        packet.set(""String_Node_Str"",(short)bitmask);
        packet.set(""String_Node_Str"",data.toByteArray());
        data.reset();
        return packet;
      }
    }
).get();
  }
 catch (  InterruptedException|ExecutionException e) {
    TridentLogger.error(e);
    return null;
  }
}"
11809,"private RegionFile(Path path) throws IOException {
  this.path=path;
synchronized (this.readWriteLock) {
    RandomAccessFile access;
    if (!Files.isRegularFile(path)) {
      Files.deleteIfExists(path);
      Files.createFile(path);
      access=new RandomAccessFile(path.toFile(),""String_Node_Str"");
      this.createNew(access);
    }
 else {
      access=new RandomAccessFile(path.toFile(),""String_Node_Str"");
    }
    if (access.length() < 8192L) {
      access.seek(access.length());
      long diff=8192L - access.length();
      for (long l=0L; l < diff; l++) {
        access.write(0);
      }
    }
    this.packFile(access);
    access.seek(0L);
    int[] offsets=new int[1024];
    for (int i=0; i < offsets.length; i++) {
      offsets[i]=access.readInt();
    }
    this.sectors=new SectorStorage(offsets);
    access.close();
  }
}","private RegionFile(Path path) throws IOException {
  this.path=path;
synchronized (this.readWriteLock) {
    RandomAccessFile access;
    if (!Files.isRegularFile(path) || !path.toFile().exists()) {
      Files.deleteIfExists(path);
      Files.createFile(path);
      access=new RandomAccessFile(path.toFile(),""String_Node_Str"");
      this.createNew(access);
    }
 else {
      access=new RandomAccessFile(path.toFile(),""String_Node_Str"");
    }
    if (access.length() < 8192L) {
      access.seek(access.length());
      long diff=8192L - access.length();
      for (long l=0L; l < diff; l++) {
        access.write(0);
      }
    }
    this.packFile(access);
    access.seek(0L);
    int[] offsets=new int[1024];
    for (int i=0; i < offsets.length; i++) {
      offsets[i]=access.readInt();
    }
    this.sectors=new SectorStorage(offsets);
    access.close();
  }
}"
11810,"@Override public void run(){
  redstoneTick=!redstoneTick;
  if (time >= 2400)   time=0;
  if (time % 40 == 0)   rainTime--;
  thunderTime--;
  if (rainTime <= 0) {
    raining=!raining;
    rainTime=ThreadLocalRandom.current().nextInt();
  }
  if (thunderTime <= 0) {
    thundering=!thundering;
    thunderTime=ThreadLocalRandom.current().nextInt();
  }
  time++;
  existed++;
  if (time % 600 == 0) {
    Set<ChunkLocation> set=Sets.newHashSet();
    for (    Entity entity : entities) {
      if (entity instanceof Player) {
        Position pos=entity.location();
        int x=(int)pos.x() % 16;
        int z=(int)pos.z() % 16;
        int viewDist=Trident.config().getInt(""String_Node_Str"",7);
        for (int i=x - viewDist; i < x + viewDist; i++) {
          for (int j=z - viewDist; j < z + viewDist; j++) {
            set.add(ChunkLocation.create(i,j));
          }
        }
      }
    }
    loadedChunks.retain(set);
    set=null;
  }
}","@Override public void run(){
  redstoneTick=!redstoneTick;
  if (time >= 2400)   time=0;
  if (time % 40 == 0)   TridentPlayer.sendAll(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed).set(""String_Node_Str"",time));
  rainTime--;
  thunderTime--;
  if (rainTime <= 0) {
    raining=!raining;
    rainTime=ThreadLocalRandom.current().nextInt();
  }
  if (thunderTime <= 0) {
    thundering=!thundering;
    thunderTime=ThreadLocalRandom.current().nextInt();
  }
  time++;
  existed++;
  if (time % 600 == 0) {
    Set<ChunkLocation> set=Sets.newHashSet();
    for (    Entity entity : entities) {
      if (entity instanceof Player) {
        Position pos=entity.location();
        int x=(int)pos.x() % 16;
        int z=(int)pos.z() % 16;
        int viewDist=Trident.config().getInt(""String_Node_Str"",7);
        for (int i=x - viewDist; i < x + viewDist; i++) {
          for (int j=z - viewDist; j < z + viewDist; j++) {
            set.add(ChunkLocation.create(i,j));
          }
        }
      }
    }
    loadedChunks.retain(set);
    set=null;
  }
}"
11811,"static TridentWorld createWorld(String name,WorldLoader loader){
  TridentWorld world=null;
  try {
    TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    File directory=new File(name + File.separator);
    File levelFile=new File(directory,""String_Node_Str"");
    File region=new File(directory,""String_Node_Str"" + File.separator);
    File playerData=new File(directory,""String_Node_Str"");
    directory.mkdir();
    levelFile.createNewFile();
    region.mkdir();
    playerData.mkdir();
    world=new TridentWorld(name,loader,false);
    world.dimension=Dimension.OVERWORLD;
    world.difficulty=Difficulty.NORMAL;
    world.defaultGamemode=GameMode.SURVIVAL;
    world.type=LevelType.DEFAULT;
    world.borderSize=60000000;
    world.time=0;
    world.existed=0;
    world.raining=false;
    world.rainTime=0;
    world.thundering=false;
    world.thunderTime=0;
    world.difficultyLocked=false;
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    int centX=((int)Math.floor(world.spawnLocation.x())) >> 4;
    int centZ=((int)Math.floor(world.spawnLocation.z())) >> 4;
    for (    ChunkLocation location : new ChunkAxisAlignedBoundingBox(ChunkLocation.create(centX - 7,centZ - 7),ChunkLocation.create(centX + 7,centZ + 7))) {
      TridentChunk chunk=new TridentChunk(world,location);
      world.addChunkAt(location,chunk);
      chunk.generate();
    }
    TridentLogger.success(""String_Node_Str"");
    world.spawnLocation.setX(0);
    world.spawnLocation.setY(64);
    world.spawnLocation.setZ(0);
  }
 catch (  IOException e) {
    TridentLogger.error(e);
  }
  return world;
}","static TridentWorld createWorld(String name,WorldLoader loader){
  TridentWorld world=null;
  try {
    TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    File directory=new File(name + File.separator);
    File levelFile=new File(directory,""String_Node_Str"");
    File region=new File(directory,""String_Node_Str"" + File.separator);
    File playerData=new File(directory,""String_Node_Str"");
    directory.mkdir();
    levelFile.createNewFile();
    region.mkdir();
    playerData.mkdir();
    world=new TridentWorld(name,loader,false);
    world.dimension=Dimension.OVERWORLD;
    world.difficulty=Difficulty.NORMAL;
    world.defaultGamemode=GameMode.SURVIVAL;
    world.type=LevelType.DEFAULT;
    world.borderSize=60000000;
    world.time=0;
    world.existed=0;
    world.raining=false;
    world.rainTime=0;
    world.thundering=false;
    world.thunderTime=0;
    world.difficultyLocked=false;
    TridentLogger.success(""String_Node_Str"");
    world.spawnLocation.setX(0);
    world.spawnLocation.setY(64);
    world.spawnLocation.setZ(0);
    TridentLogger.log(""String_Node_Str"");
    int centX=((int)Math.floor(world.spawnLocation.x())) >> 4;
    int centZ=((int)Math.floor(world.spawnLocation.z())) >> 4;
    for (    ChunkLocation location : new ChunkAxisAlignedBoundingBox(ChunkLocation.create(centX - 7,centZ - 7),ChunkLocation.create(centX + 7,centZ + 7))) {
      TridentChunk chunk=new TridentChunk(world,location);
      world.addChunkAt(location,chunk);
      chunk.generate();
    }
    TridentLogger.success(""String_Node_Str"");
  }
 catch (  IOException e) {
    TridentLogger.error(e);
  }
  return world;
}"
11812,"public void tick(){
  ThreadsHandler.worldExecutor().execute(new Runnable(){
    @Override public void run(){
      redstoneTick=!redstoneTick;
      if (time >= 2400)       time=0;
      if (time % 40 == 0)       rainTime--;
      thunderTime--;
      if (rainTime <= 0) {
        raining=!raining;
        rainTime=ThreadLocalRandom.current().nextInt();
      }
      if (thunderTime <= 0) {
        thundering=!thundering;
        thunderTime=ThreadLocalRandom.current().nextInt();
      }
      time++;
      existed++;
      if (time % 600 == 0) {
        Set<ChunkLocation> set=Sets.newHashSet();
        for (        Entity entity : entities) {
          if (entity instanceof Player) {
            Position pos=entity.location();
            int x=(int)pos.x() % 16;
            int z=(int)pos.z() % 16;
            int viewDist=Trident.config().getInt(""String_Node_Str"",7);
            for (int i=x - viewDist; i < x + viewDist; i++) {
              for (int j=z - viewDist; j < z + viewDist; j++) {
                set.add(ChunkLocation.create(i,j));
              }
            }
          }
        }
        loadedChunks.retain(set);
        set=null;
      }
    }
  }
);
}","public void tick(){
  ThreadsHandler.worldExecutor().execute(new Runnable(){
    @Override public void run(){
      redstoneTick=!redstoneTick;
      if (time >= 2400)       time=0;
      if (time % 40 == 0)       TridentPlayer.sendAll(new PacketPlayOutTimeUpdate().set(""String_Node_Str"",existed).set(""String_Node_Str"",time));
      rainTime--;
      thunderTime--;
      if (rainTime <= 0) {
        raining=!raining;
        rainTime=ThreadLocalRandom.current().nextInt();
      }
      if (thunderTime <= 0) {
        thundering=!thundering;
        thunderTime=ThreadLocalRandom.current().nextInt();
      }
      time++;
      existed++;
      if (time % 600 == 0) {
        Set<ChunkLocation> set=Sets.newHashSet();
        for (        Entity entity : entities) {
          if (entity instanceof Player) {
            Position pos=entity.location();
            int x=(int)pos.x() % 16;
            int z=(int)pos.z() % 16;
            int viewDist=Trident.config().getInt(""String_Node_Str"",7);
            for (int i=x - viewDist; i < x + viewDist; i++) {
              for (int j=z - viewDist; j < z + viewDist; j++) {
                set.add(ChunkLocation.create(i,j));
              }
            }
          }
        }
        loadedChunks.retain(set);
        set=null;
      }
    }
  }
);
}"
11813,"/** 
 * Initializes the server with the configuration file
 * @param config the configuration to use for option lookup
 */
@Volatile(policy=""String_Node_Str"",reason=""String_Node_Str"",fix=""String_Node_Str"") private static void init(final JsonConfig config) throws InterruptedException {
  try {
    TridentLogger.log(""String_Node_Str"");
    Factories.init(new CollectFactory(){
      @Override public <K,V>ConcurrentMap<K,V> createMap(){
        return new ConcurrentHashMapV8<>();
      }
    }
);
    Factories.init(ThreadsHandler.create());
    Factories.init(TridentScheduler.create());
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    TridentServer.createServer(config);
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    ServerCommandRegistrar.registerAll();
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    File fi=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
    if (!fi.exists())     fi.mkdir();
    for (    File file : new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"").listFiles())     Trident.pluginHandler().load(file);
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    String ip=config.getString(""String_Node_Str"",Defaults.ADDRESS);
    int port=config.getInt(""String_Node_Str"",Defaults.PORT);
    TridentLogger.log(""String_Node_Str"" + ip + ""String_Node_Str""+ port);
    new ServerBootstrap().group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ClientChannelInitializer()).option(ChannelOption.TCP_NODELAY,true).bind(new InetSocketAddress(ip,port)).sync();
    TridentLogger.success(""String_Node_Str"");
    Scanner scanner=new Scanner(System.in);
    while (true) {
      System.out.print(""String_Node_Str"" + PlatformColor.forColor(""String_Node_Str""));
      String command=scanner.next();
      Trident.console().invokeCommand(command);
switch (command) {
case ""String_Node_Str"":
        return;
case ""String_Node_Str"":
      return;
  }
}
}
 catch (InterruptedException e) {
}
catch (Exception e) {
TridentLogger.error(""String_Node_Str"");
TridentLogger.error(e);
Trident.shutdown();
}
}","/** 
 * Initializes the server with the configuration file
 * @param config the configuration to use for option lookup
 */
@Volatile(policy=""String_Node_Str"",reason=""String_Node_Str"",fix=""String_Node_Str"") private static void init(final JsonConfig config) throws InterruptedException {
  try {
    TridentLogger.log(""String_Node_Str"");
    Factories.init(new CollectFactory(){
      @Override public <K,V>ConcurrentMap<K,V> createMap(){
        return new ConcurrentHashMapV8<>();
      }
    }
);
    Factories.init(ThreadsHandler.create());
    Factories.init(TridentScheduler.create());
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    TridentServer.createServer(config);
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    ServerCommandRegistrar.registerAll();
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    File fi=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
    if (!fi.exists())     fi.mkdir();
    for (    File file : new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"").listFiles())     Trident.pluginHandler().load(file);
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    String ip=config.getString(""String_Node_Str"",Defaults.ADDRESS);
    int port=config.getInt(""String_Node_Str"",Defaults.PORT);
    TridentLogger.log(""String_Node_Str"" + ip + ""String_Node_Str""+ port);
    new ServerBootstrap().group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new ClientChannelInitializer()).option(ChannelOption.TCP_NODELAY,true).bind(new InetSocketAddress(ip,port)).sync();
    TridentLogger.success(""String_Node_Str"");
    Scanner scanner=new Scanner(System.in);
    while (true) {
      System.out.print(""String_Node_Str"" + PlatformColor.forColor(""String_Node_Str""));
      String command=scanner.next();
      Trident.console().invokeCommand(command);
switch (command) {
case ""String_Node_Str"":
        return;
case ""String_Node_Str"":
      return;
  }
}
}
 catch (InterruptedException e) {
}
catch (NoSuchElementException e) {
}
catch (Exception e) {
TridentLogger.error(""String_Node_Str"");
TridentLogger.error(e);
Trident.shutdown();
}
}"
11814,"public void load(CompoundTag tag){
  String type=((StringTag)tag.getTag(""String_Node_Str"")).value();
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=(tag.containsTag(""String_Node_Str"")) ? (StringTag)tag.getTag(""String_Node_Str"") : new StringTag(""String_Node_Str"").setValue(""String_Node_Str"");
  ByteTag dnVisible=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  ByteTag silent=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=counter.incrementAndGet();
  loc=Coordinates.create(TridentServer.WORLD,0,0,0);
  velocity=new Vector(0,0,0);
  this.uniqueId=new UUID(uuidMost.value(),uuidLeast.value());
  double[] location=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=pos.get(i);
    if (t instanceof DoubleTag) {
      location[i]=((DoubleTag)t).value();
    }
 else {
      location[i]=((IntTag)t).value();
    }
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  double[] velocity=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=motion.get(i);
    if (t instanceof DoubleTag) {
      velocity[i]=((DoubleTag)t).value();
    }
 else {
      velocity[i]=((IntTag)t).value();
    }
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  if (rotation.get(0) instanceof IntTag) {
    loc.setYaw(((IntTag)rotation.get(0)).value());
  }
 else {
    loc.setYaw(((FloatTag)rotation.get(0)).value());
  }
  if (rotation.get(1) instanceof IntTag) {
    loc.setPitch(((IntTag)rotation.get(1)).value());
  }
 else {
    loc.setPitch(((FloatTag)rotation.get(1)).value());
  }
  this.fallDistance.set((long)fallDistance.value());
  this.fireTicks.set(fireTicks.value());
  this.airTicks.set(airTicks.value());
  this.portalCooldown.set(portalCooldown.value());
  this.onGround=onGround.value() == 1;
  this.godMode=invulnerable.value() == 1;
  this.nameVisible=dnVisible.value() == 1;
  this.silent=silent.value() == 1;
  this.displayName=displayName.value();
}","public void load(CompoundTag tag){
  if (!(tag.getTag(""String_Node_Str"") instanceof NullTag)) {
    String type=((StringTag)tag.getTag(""String_Node_Str"")).value();
  }
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=(tag.containsTag(""String_Node_Str"")) ? (StringTag)tag.getTag(""String_Node_Str"") : new StringTag(""String_Node_Str"").setValue(""String_Node_Str"");
  ByteTag dnVisible=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  ByteTag silent=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=counter.incrementAndGet();
  loc=Coordinates.create(TridentServer.WORLD,0,0,0);
  velocity=new Vector(0,0,0);
  this.uniqueId=new UUID(uuidMost.value(),uuidLeast.value());
  double[] location=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=pos.get(i);
    if (t instanceof DoubleTag) {
      location[i]=((DoubleTag)t).value();
    }
 else {
      location[i]=((IntTag)t).value();
    }
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  double[] velocity=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=motion.get(i);
    if (t instanceof DoubleTag) {
      velocity[i]=((DoubleTag)t).value();
    }
 else {
      velocity[i]=((IntTag)t).value();
    }
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  if (rotation.get(0) instanceof IntTag) {
    loc.setYaw(((IntTag)rotation.get(0)).value());
  }
 else {
    loc.setYaw(((FloatTag)rotation.get(0)).value());
  }
  if (rotation.get(1) instanceof IntTag) {
    loc.setPitch(((IntTag)rotation.get(1)).value());
  }
 else {
    loc.setPitch(((FloatTag)rotation.get(1)).value());
  }
  this.fallDistance.set((long)fallDistance.value());
  this.fireTicks.set(fireTicks.value());
  this.airTicks.set(airTicks.value());
  this.portalCooldown.set(portalCooldown.value());
  this.onGround=onGround.value() == 1;
  this.godMode=invulnerable.value() == 1;
  this.nameVisible=dnVisible.value() == 1;
  this.silent=silent.value() == 1;
  this.displayName=displayName.value();
}"
11815,"public <T extends Entity>T build(Class<T> entityType,ParameterValue<?>... parameterValues){
  int paramLen=parameterValues.length;
  Class[] params=new Class[paramLen];
  Object[] args=new Object[paramLen];
  for (int i=0; i < paramLen; i++) {
    ParameterValue<?> value=parameterValues[i];
    params[i]=value.clazz();
    args[i]=value.value();
  }
  TridentEntity entity=null;
  try {
    Constructor<? extends TridentEntity> constructor=(Constructor<? extends TridentEntity>)entityType.getConstructor(params);
    entity=constructor.newInstance(args);
    entity.executor=executor != null ? executor : ThreadsHandler.entityExecutor();
    entity.godMode=god;
    entity.passenger=passenger;
    entity.displayName=displayName;
    entity.nameVisible=displayName != null;
    entity.silent=silent;
    entity.spawn();
  }
 catch (  NoSuchMethodException|InvocationTargetException|IllegalAccessException|InstantiationException e) {
    TridentLogger.error(e);
  }
  return (T)entity;
}","public <T extends Entity>T build(Class<T> entityType,ParameterValue<?>... parameterValues){
  int paramLen=parameterValues.length;
  Class[] params=new Class[paramLen];
  Object[] args=new Object[paramLen];
  for (int i=0; i < paramLen; i++) {
    ParameterValue<?> value=parameterValues[i];
    params[i]=value.clazz();
    args[i]=value.value();
  }
  TridentEntity entity=null;
  if (entityType == TridentPlayer.class) {
    entity=new TridentPlayer((CompoundTag)parameterValues[0].value(),(TridentWorld)parameterValues[1].value(),(ClientConnection)parameterValues[2].value());
    entity.executor=executor != null ? executor : ThreadsHandler.entityExecutor();
    entity.godMode=god;
    entity.passenger=passenger;
    entity.displayName=displayName;
    entity.nameVisible=displayName != null;
    entity.silent=silent;
    entity.spawn();
    return (T)entity;
  }
  try {
    Constructor<? extends TridentEntity> constructor=(Constructor<? extends TridentEntity>)entityType.getConstructor(params);
    entity=constructor.newInstance(args);
    entity.executor=executor != null ? executor : ThreadsHandler.entityExecutor();
    entity.godMode=god;
    entity.passenger=passenger;
    entity.displayName=displayName;
    entity.nameVisible=displayName != null;
    entity.silent=silent;
    entity.spawn();
  }
 catch (  NoSuchMethodException|InvocationTargetException|IllegalAccessException|InstantiationException e) {
    TridentLogger.error(e);
  }
  return (T)entity;
}"
11816,"/** 
 * Removes the client's server side client handler
 */
public void logout(){
  TridentPlayer player=((PlayerConnection)this).player();
  if (this instanceof PlayerConnection)   ThreadsHandler.remove(player);
  player.remove();
  clientData.remove(this.address);
  this.channel.close();
}","/** 
 * Removes the client's server side client handler
 */
public void logout(){
  if (this instanceof PlayerConnection) {
    TridentPlayer player=((PlayerConnection)this).player();
    ThreadsHandler.remove(player);
    player.remove();
  }
  clientData.remove(this.address);
  this.channel.close();
}"
11817,"@Override public void handleReceived(ClientConnection connection){
  if (connection.getAddress().getHostString().equals(""String_Node_Str"")) {
    UUID id;
    try {
      URL url=new URL(""String_Node_Str"");
      HttpsURLConnection c=(HttpsURLConnection)url.openConnection();
      c.setRequestMethod(""String_Node_Str"");
      c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      c.setDoOutput(true);
      c.setDoInput(true);
      c.getOutputStream().write(String.format(""String_Node_Str"",name()).getBytes());
      c.getOutputStream().close();
      int responseCode=c.getResponseCode();
      if (responseCode != 200) {
        connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
        connection.logout();
        return;
      }
      StringBuilder sb=new StringBuilder();
      BufferedReader reader=new BufferedReader(new InputStreamReader(c.getInputStream()));
      String line;
      while ((line=reader.readLine()) != null) {
        sb.append(line);
        sb.append('\n');
      }
      reader.close();
      JsonArray array=PacketLoginInEncryptionResponse.GSON.fromJson(sb.toString(),JsonArray.class);
      id=UUID.fromString(PacketLoginInEncryptionResponse.idDash.matcher(array.getAsJsonArray().get(0).getAsJsonObject().get(""String_Node_Str"").getAsString()).replaceAll(""String_Node_Str""));
    }
 catch (    Exception e) {
      TridentLogger.error(e);
      return;
    }
    PacketLoginOutSuccess success=new PacketLoginOutSuccess();
    success.uuid=id.toString();
    success.username=name();
    success.connection=connection;
    connection.enableCompression();
    connection.sendPacket(success);
    connection.setStage(Protocol.ClientStage.PLAY);
    TridentPlayer.spawnPlayer(connection,id);
    return;
  }
  LoginHandler.getInstance().initLogin(connection.getAddress(),this.name());
  PacketLoginOutEncryptionRequest p=new PacketLoginOutEncryptionRequest();
  connection.generateToken();
  p.set(""String_Node_Str"",connection.getVerificationToken());
  try {
    KeyPair pair=RSA.generate(1024);
    p.set(""String_Node_Str"",pair.getPublic().getEncoded());
    connection.setLoginKeyPair(pair);
  }
 catch (  NoSuchAlgorithmException ignored) {
  }
  connection.sendPacket(p);
}","@Override public void handleReceived(ClientConnection connection){
  if (connection.getAddress().getHostString().equals(""String_Node_Str"")) {
    UUID id;
    try {
      URL url=new URL(""String_Node_Str"");
      HttpsURLConnection c=(HttpsURLConnection)url.openConnection();
      c.setRequestMethod(""String_Node_Str"");
      c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      c.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
      c.setDoOutput(true);
      c.setDoInput(true);
      c.getOutputStream().write(String.format(""String_Node_Str"",name()).getBytes());
      c.getOutputStream().close();
      int responseCode=c.getResponseCode();
      if (responseCode != 200) {
        connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
        connection.logout();
        return;
      }
      StringBuilder sb=new StringBuilder();
      BufferedReader reader=new BufferedReader(new InputStreamReader(c.getInputStream()));
      String line;
      while ((line=reader.readLine()) != null) {
        sb.append(line);
        sb.append('\n');
      }
      reader.close();
      JsonArray array=PacketLoginInEncryptionResponse.GSON.fromJson(sb.toString(),JsonArray.class);
      id=UUID.fromString(PacketLoginInEncryptionResponse.idDash.matcher(array.getAsJsonArray().get(0).getAsJsonObject().get(""String_Node_Str"").getAsString()).replaceAll(""String_Node_Str""));
    }
 catch (    Exception e) {
      TridentLogger.error(e);
      return;
    }
    if (TridentServer.WORLD == null) {
      connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
      TridentLogger.error(""String_Node_Str"");
      return;
    }
    PacketLoginOutSuccess success=new PacketLoginOutSuccess();
    success.uuid=id.toString();
    success.username=name();
    success.connection=connection;
    connection.enableCompression();
    connection.sendPacket(success);
    connection.setStage(Protocol.ClientStage.PLAY);
    TridentPlayer.spawnPlayer(connection,id);
    return;
  }
  LoginHandler.getInstance().initLogin(connection.getAddress(),this.name());
  PacketLoginOutEncryptionRequest p=new PacketLoginOutEncryptionRequest();
  connection.generateToken();
  p.set(""String_Node_Str"",connection.getVerificationToken());
  try {
    KeyPair pair=RSA.generate(1024);
    p.set(""String_Node_Str"",pair.getPublic().getEncoded());
    connection.setLoginKeyPair(pair);
  }
 catch (  NoSuchAlgorithmException ignored) {
  }
  connection.sendPacket(p);
}"
11818,"public static CompoundTag generatePlayer(UUID id){
  World defaultWorld=TridentServer.WORLD;
  Coordinates spawnLocation=defaultWorld.spawnLocation();
  CompoundTagBuilder<NBTBuilder> builder=NBTBuilder.newBase(id.toString());
  builder.stringTag(""String_Node_Str"",String.valueOf(counter.incrementAndGet()));
  builder.longTag(""String_Node_Str"",id.getMostSignificantBits());
  builder.longTag(""String_Node_Str"",id.getLeastSignificantBits());
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> pos=builder.beginListTag(""String_Node_Str"",TagType.INT);
  pos.tag((int)spawnLocation.x());
  pos.tag((int)spawnLocation.y());
  pos.tag((int)spawnLocation.z());
  builder=pos.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> motion=builder.beginListTag(""String_Node_Str"",TagType.INT);
  motion.tag(0);
  motion.tag(0);
  motion.tag(0);
  builder=motion.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> rotation=builder.beginListTag(""String_Node_Str"",TagType.INT);
  rotation.tag(0);
  rotation.tag(0);
  builder=rotation.endListTag();
  builder.floatTag(""String_Node_Str"",0);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.byteTag(""String_Node_Str"",(byte)1);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.asByte());
  builder.intTag(""String_Node_Str"",900);
  builder.stringTag(""String_Node_Str"",""String_Node_Str"");
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.compoundTag(new CompoundTag(""String_Node_Str""));
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.asByte());
  builder.intTag(""String_Node_Str"",GameMode.SURVIVAL.asByte());
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",20);
  builder.floatTag(""String_Node_Str"",0F);
  builder.floatTag(""String_Node_Str"",0F);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.intTag(""String_Node_Str"",0);
  builder.compoundTag(NBTSerializer.serialize(new PlayerAbilities(),""String_Node_Str""));
  return builder.endCompoundTag().build();
}","public static CompoundTag generatePlayer(UUID id){
  World defaultWorld=TridentServer.WORLD;
  Coordinates spawnLocation=defaultWorld.spawnLocation();
  CompoundTagBuilder<NBTBuilder> builder=NBTBuilder.newBase(id.toString());
  builder.stringTag(""String_Node_Str"",String.valueOf(counter.incrementAndGet()));
  builder.longTag(""String_Node_Str"",id.getMostSignificantBits());
  builder.longTag(""String_Node_Str"",id.getLeastSignificantBits());
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> pos=builder.beginListTag(""String_Node_Str"",TagType.DOUBLE);
  pos.tag(spawnLocation.x());
  pos.tag(spawnLocation.y());
  pos.tag(spawnLocation.z());
  builder=pos.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> motion=builder.beginListTag(""String_Node_Str"",TagType.DOUBLE);
  motion.tag(0d);
  motion.tag(0d);
  motion.tag(0d);
  builder=motion.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> rotation=builder.beginListTag(""String_Node_Str"",TagType.FLOAT);
  rotation.tag(0f);
  rotation.tag(0f);
  builder=rotation.endListTag();
  builder.floatTag(""String_Node_Str"",0);
  builder.shortTag(""String_Node_Str"",(short)-20);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.byteTag(""String_Node_Str"",(byte)1);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.asByte());
  builder.intTag(""String_Node_Str"",900);
  builder.stringTag(""String_Node_Str"",""String_Node_Str"");
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.compoundTag(new CompoundTag(""String_Node_Str""));
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.asByte());
  builder.intTag(""String_Node_Str"",GameMode.SURVIVAL.asByte());
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",20);
  builder.floatTag(""String_Node_Str"",0F);
  builder.floatTag(""String_Node_Str"",0F);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.floatTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.intTag(""String_Node_Str"",0);
  builder.compoundTag(NBTSerializer.serialize(new PlayerAbilities(),""String_Node_Str""));
  return builder.endCompoundTag().build();
}"
11819,"public OfflinePlayer(CompoundTag tag,TridentWorld world){
  super(null,world.spawnLocation());
  load(tag);
  dimension=Dimension.dimension(((IntTag)tag.getTag(""String_Node_Str"")).value());
  gameMode=GameMode.gamemodeOf(((IntTag)tag.getTag(""String_Node_Str"")).value());
  score=((IntTag)tag.getTag(""String_Node_Str"")).value();
  selectedSlot=(short)((IntTag)tag.getTag(""String_Node_Str"")).value();
  if (tag.containsTag(""String_Node_Str"")) {
    spawnLocation=Coordinates.create(world,((IntTag)tag.getTag(""String_Node_Str"")).value(),((IntTag)tag.getTag(""String_Node_Str"")).value(),((IntTag)tag.getTag(""String_Node_Str"")).value());
  }
 else {
    spawnLocation=world.spawnLocation();
  }
  hunger=(short)((IntTag)tag.getTag(""String_Node_Str"")).value();
  exhaustion=((FloatTag)tag.getTag(""String_Node_Str"")).value();
  saturation=((FloatTag)tag.getTag(""String_Node_Str"")).value();
  foodTickTimer=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpLevel=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpPercent=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpTotal=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpSeed=((IntTag)tag.getTag(""String_Node_Str"")).value();
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
  }
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
  }
  NBTSerializer.deserialize(abilities,(CompoundTag)tag.getTag(""String_Node_Str""));
  players.add(this);
}","public OfflinePlayer(CompoundTag tag,TridentWorld world){
  super(null,world.spawnLocation());
  load(tag);
  dimension=Dimension.dimension(((IntTag)tag.getTag(""String_Node_Str"")).value());
  gameMode=GameMode.gamemodeOf(((IntTag)tag.getTag(""String_Node_Str"")).value());
  score=((IntTag)tag.getTag(""String_Node_Str"")).value();
  selectedSlot=(short)((IntTag)tag.getTag(""String_Node_Str"")).value();
  if (tag.containsTag(""String_Node_Str"")) {
    spawnLocation=Coordinates.create(world,((IntTag)tag.getTag(""String_Node_Str"")).value(),((IntTag)tag.getTag(""String_Node_Str"")).value(),((IntTag)tag.getTag(""String_Node_Str"")).value());
  }
 else {
    spawnLocation=world.spawnLocation();
  }
  hunger=(short)((IntTag)tag.getTag(""String_Node_Str"")).value();
  exhaustion=((FloatTag)tag.getTag(""String_Node_Str"")).value();
  saturation=((FloatTag)tag.getTag(""String_Node_Str"")).value();
  foodTickTimer=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpLevel=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpPercent=((FloatTag)tag.getTag(""String_Node_Str"")).value();
  xpTotal=((IntTag)tag.getTag(""String_Node_Str"")).value();
  xpSeed=((IntTag)tag.getTag(""String_Node_Str"")).value();
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
  }
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
  }
  NBTSerializer.deserialize(abilities,(CompoundTag)tag.getTag(""String_Node_Str""));
  players.add(this);
}"
11820,"public CompoundTag asNbt(){
  CompoundTag tag=new CompoundTag(uniqueId().toString());
  tag.addTag(new IntTag(""String_Node_Str"").setValue(dimension.asByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(gameMode.asByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(score));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(selectedSlot));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.x()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.y()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.z()));
  tag.addTag(new ShortTag(""String_Node_Str"").setValue(hunger));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(exhaustion));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(saturation));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(foodTickTimer));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpLevel));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(xpPercent));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpTotal));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpSeed));
  ListTag inventoryTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  tag.addTag(inventoryTag);
  ListTag enderTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  tag.addTag(enderTag);
  tag.addTag(NBTSerializer.serialize(abilities,""String_Node_Str""));
  return tag;
}","public CompoundTag asNbt(){
  CompoundTag tag=new CompoundTag(uniqueId().toString());
  tag.addTag(new LongTag(""String_Node_Str"").setValue(uniqueId.getMostSignificantBits()));
  tag.addTag(new LongTag(""String_Node_Str"").setValue(uniqueId.getLeastSignificantBits()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(dimension.asByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(gameMode.asByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(score));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(selectedSlot));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.x()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.y()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.z()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(hunger));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(exhaustion));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(saturation));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(foodTickTimer));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpLevel));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(xpPercent));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpTotal));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpSeed));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(invulnerable));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(portalCooldown));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(fallDistance.floatValue()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(onGround));
  tag.addTag(new ShortTag(""String_Node_Str"").setValue((short)fireTicks));
  tag.addTag(new ShortTag(""String_Node_Str"").setValue((short)airTicks.get()));
  tag.addTag(new ByteTag(""String_Node_Str"").setValue(silent));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(selectedSlot));
  ListTag position=new ListTag(""String_Node_Str"",TagType.DOUBLE);
  position.addTag(new DoubleTag(""String_Node_Str"").setValue(loc.x()));
  position.addTag(new DoubleTag(""String_Node_Str"").setValue(loc.y()));
  position.addTag(new DoubleTag(""String_Node_Str"").setValue(loc.z()));
  tag.addTag(position);
  ListTag motion=new ListTag(""String_Node_Str"",TagType.DOUBLE);
  motion.addTag(new DoubleTag(""String_Node_Str"").setValue(velocity.x()));
  motion.addTag(new DoubleTag(""String_Node_Str"").setValue(velocity.y()));
  motion.addTag(new DoubleTag(""String_Node_Str"").setValue(velocity.z()));
  tag.addTag(motion);
  ListTag rotation=new ListTag(""String_Node_Str"",TagType.FLOAT);
  rotation.addTag(new FloatTag(""String_Node_Str"").setValue(loc.yaw()));
  rotation.addTag(new FloatTag(""String_Node_Str"").setValue(loc.pitch()));
  tag.addTag(rotation);
  ListTag inventoryTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  tag.addTag(inventoryTag);
  ListTag enderTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  tag.addTag(enderTag);
  tag.addTag(NBTSerializer.serialize(abilities,""String_Node_Str""));
  return tag;
}"
11821,"protected void loadBlocks(World world){
  if (add == null) {
    add=new byte[LENGTH];
  }
  NibbleArray add=new NibbleArray(this.add);
  NibbleArray data=new NibbleArray(this.data);
  types=new byte[rawTypes.length];
  for (int i=0; i < LENGTH; i+=1) {
    Block block;
    byte b;
    byte bData;
    int bAdd;
    b=rawTypes[i];
    bAdd=add.get(i) << 8;
    b+=bAdd;
    bData=data.get(i);
    Substance material=Substance.fromId(b);
    if (material == null) {
      material=Substance.AIR;
    }
    block=new TridentBlock(Coordinates.create(world,0,0,0),material,bData);
switch (block.substance()) {
default :
      break;
  }
  types[i]=(byte)(bAdd | ((b & 0xff) << 4) | bData);
}
}","protected void loadBlocks(World world){
  if (add == null) {
    add=new byte[LENGTH];
  }
  types=new byte[rawTypes.length];
  for (int i=0; i < LENGTH; i+=1) {
    Block block;
    byte b;
    byte bData;
    int bAdd;
    b=rawTypes[i];
    bAdd=NibbleArray.get(this.add,i) << 8;
    b+=bAdd;
    bData=NibbleArray.get(this.data,i);
    Substance material=Substance.fromId(b);
    if (material == null) {
      material=Substance.AIR;
    }
    block=new TridentBlock(Coordinates.create(world,0,0,0),material,bData);
switch (block.substance()) {
default :
      break;
  }
  types[i]=(byte)(bAdd | ((b & 0xff) << 4) | bData);
}
}"
11822,"@Override public Block tileAt(int relX,int y,int relZ){
  int index=WorldUtils.blockArrayIndex(relX,y % 16,relZ);
  ChunkSection section=sections[WorldUtils.section(y)];
  NibbleArray add=new NibbleArray(section.add);
  NibbleArray data=new NibbleArray(section.data);
  byte b=section.rawTypes[index];
  int bAdd=add.get(index) << 8;
  byte meta=data.get(index);
  b+=bAdd;
  Substance material=Substance.fromId(b);
  if (material == null) {
    material=Substance.AIR;
  }
  return new TridentBlock(Coordinates.create(this.world,relX + this.x() * 16,y,relZ + this.z() * 16),material,meta);
}","@Override public Block tileAt(int relX,int y,int relZ){
  int index=WorldUtils.blockArrayIndex(relX,y % 16,relZ);
  ChunkSection section=sections[WorldUtils.section(y)];
  byte b=section.rawTypes[index];
  int bAdd=NibbleArray.get(section.add,index) << 8;
  byte meta=NibbleArray.get(section.data,index);
  b+=bAdd;
  Substance material=Substance.fromId(b);
  if (material == null) {
    material=Substance.AIR;
  }
  return new TridentBlock(Coordinates.create(this.world,relX + this.x() * 16,y,relZ + this.z() * 16),material,meta);
}"
11823,"@InternalUseOnly public void loadAll(){
  TridentLogger.log(""String_Node_Str"");
  for (  File file : Trident.fileContainer().toFile().listFiles()) {
    if (!(file.isDirectory()) || file.getName().contains(""String_Node_Str""))     continue;
    boolean isWorld=false;
    for (    File f : file.listFiles()) {
      if (f.getName().equals(""String_Node_Str"")) {
        isWorld=true;
        continue;
      }
      if (f.getName().equals(""String_Node_Str"")) {
        String className=null;
        try {
          byte[] sig=Files.readAllBytes(Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str""));
          className=new String(sig);
          if (!className.equals(this.getClass().getName())) {
            new TridentWorldLoader(Class.forName(className).asSubclass(AbstractGenerator.class)).load(file.getName());
            isWorld=false;
          }
        }
 catch (        IOException e) {
          TridentLogger.error(e);
          isWorld=true;
        }
catch (        ClassNotFoundException e) {
          TridentLogger.error(""String_Node_Str"" + className + ""String_Node_Str"");
          TridentLogger.error(e);
          isWorld=true;
        }
      }
    }
    if (!(isWorld))     continue;
    Path gensig=Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str"");
    if (!Files.exists(gensig)) {
      try {
        Files.createFile(gensig);
        Files.write(gensig,generator().getClass().getName().getBytes(Charset.defaultCharset()));
      }
 catch (      IOException e) {
        TridentLogger.error(""String_Node_Str"");
        TridentLogger.error(e);
      }
    }
    load(file.getName());
  }
  TridentLogger.log(""String_Node_Str"");
}","@InternalUseOnly public void loadAll(){
  TridentLogger.log(""String_Node_Str"");
  for (  File file : Trident.fileContainer().toFile().listFiles()) {
    if (!(file.isDirectory()) || file.getName().contains(""String_Node_Str""))     continue;
    boolean isWorld=false;
    for (    File f : file.listFiles()) {
      if (f.getName().equals(""String_Node_Str"")) {
        isWorld=true;
        continue;
      }
      if (f.getName().equals(""String_Node_Str"")) {
        String className=null;
        try {
          byte[] sig=Files.readAllBytes(Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str""));
          className=new String(sig);
          if (!className.equals(this.getClass().getName())) {
            new TridentWorldLoader(Class.forName(className).asSubclass(AbstractGenerator.class)).load(file.getName());
            isWorld=false;
          }
        }
 catch (        IOException e) {
          TridentLogger.error(e);
          isWorld=true;
        }
catch (        ClassNotFoundException e) {
          TridentLogger.error(""String_Node_Str"" + className + ""String_Node_Str"");
          TridentLogger.error(e);
          isWorld=true;
        }
      }
    }
    if (!(isWorld))     continue;
    Path gensig=Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str"");
    if (!Files.exists(gensig)) {
      try {
        Files.createFile(gensig);
        Files.write(gensig,generator().getClass().getName().getBytes(Charset.defaultCharset()));
      }
 catch (      IOException e) {
        TridentLogger.error(""String_Node_Str"");
        TridentLogger.error(e);
      }
    }
    load(file.getName());
  }
  if (worlds.size() == 0) {
    TridentLogger.error(""String_Node_Str"");
  }
  TridentLogger.log(""String_Node_Str"");
}"
11824,"/** 
 * Gets the index of a block in a section
 * @param x the specified x
 * @param y the y height specified
 * @param z the specified z
 * @return the index of the block array containing the coordinates given
 */
public static int blockArrayIndex(int x,int y,int z){
  return (y << 8) + (z << 4) + x;
}","/** 
 * Gets the index of a block in a section
 * @param x the specified x
 * @param y the y height specified
 * @param z the specified z
 * @return the index of the block array containing the coordinates given
 */
public static int blockArrayIndex(int x,int y,int z){
  if (x < 0) {
    x++;
    x=-x;
  }
  if (z < 0) {
    z++;
    z=-z;
  }
  return (y << 8) + (z << 4) + x;
}"
11825,"/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client    {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketDirection.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  if (!(packet instanceof PacketPlayInPlayerMove)) {
    TridentLogger.log(""String_Node_Str"" + packet.getClass().getSimpleName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
    if (connection instanceof PlayerConnection) {
      ((PlayerConnection)connection).resetReadCounter();
    }
  }
 catch (  Exception ex) {
    TridentLogger.error(ex);
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",""String_Node_Str"" + ex.getClass().getName() + ((ex.getMessage() != null) ? ""String_Node_Str"" + ex.getMessage() : ""String_Node_Str"")+ ""String_Node_Str"");
this.connection.sendPacket(quit);
this.connection.logout();
default :
break;
}
}
}","/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client    {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketDirection.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
    if (connection instanceof PlayerConnection) {
      ((PlayerConnection)connection).resetReadCounter();
    }
  }
 catch (  Exception ex) {
    TridentLogger.error(ex);
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",""String_Node_Str"" + ex.getClass().getName() + ((ex.getMessage() != null) ? ""String_Node_Str"" + ex.getMessage() : ""String_Node_Str"")+ ""String_Node_Str"");
this.connection.sendPacket(quit);
this.connection.logout();
default :
break;
}
}
}"
11826,"@InternalUseOnly public synchronized void sendKeepAlive(){
  int oldId=keepAliveId;
  if (oldId != -1)   return;
  int id=ThreadLocalRandom.current().nextInt();
  OutPacket packet=new PacketPlayOutKeepAlive();
  packet.set(""String_Node_Str"",id);
  keepAliveId=id;
  sendPacket(packet);
}","@InternalUseOnly public synchronized void sendKeepAlive(){
  int oldId=keepAliveId;
  if (oldId != -1)   return;
  int id=ThreadLocalRandom.current().nextInt(0x230000);
  OutPacket packet=new PacketPlayOutKeepAlive();
  packet.set(""String_Node_Str"",id);
  keepAliveId=id;
  sendPacket(packet);
}"
11827,"@InternalUseOnly public void resumeLogin(){
  if (!loggingIn)   return;
  sendChunks(7);
  connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
  TridentWindow window=new TridentWindow(""String_Node_Str"",9,InventoryType.CHEST);
  window.setSlot(0,new Item(Substance.DIAMOND_PICKAXE));
  window.sendTo(this);
  for (  Entity entity : world().entities()) {
  }
  loggingIn=false;
}","@InternalUseOnly public void resumeLogin(){
  if (!loggingIn)   return;
  connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
  sendChunks(7);
  connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",location()).set(""String_Node_Str"",(byte)0));
  TridentWindow window=new TridentWindow(""String_Node_Str"",9,InventoryType.CHEST);
  window.setSlot(0,new Item(Substance.DIAMOND_PICKAXE));
  window.sendTo(this);
  for (  Entity entity : world().entities()) {
  }
  loggingIn=false;
}"
11828,"@Override public void tick(){
  this.executor.execute(new Runnable(){
    @Override public void run(){
      TridentPlayer.super.tick();
      if (!chunkQueue.isEmpty())       connection.sendPacket(chunkQueue.poll());
      connection.tick();
      ticksExisted.incrementAndGet();
    }
  }
);
}","@Override public void tick(){
  this.executor.execute(new Runnable(){
    @Override public void run(){
      TridentPlayer.super.tick();
      if (!isLoggingIn())       sendChunks(7);
      if (!chunkQueue.isEmpty())       connection.sendPacket(chunkQueue.poll());
      connection.tick();
      ticksExisted.incrementAndGet();
    }
  }
);
}"
11829,"public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=TridentEntityBuilder.create().uuid(id).spawn(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.entityId()).set(""String_Node_Str"",GameMode.CREATIVE).set(""String_Node_Str"",p.world().dimension()).set(""String_Node_Str"",p.world().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.world().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation().add(new Vector(0,80,0))).set(""String_Node_Str"",(byte)0));
    }
  }
);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=TridentEntityBuilder.create().uuid(id).spawn(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.entityId()).set(""String_Node_Str"",GameMode.CREATIVE).set(""String_Node_Str"",p.world().dimension()).set(""String_Node_Str"",p.world().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.world().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
    }
  }
);
  return p;
}"
11830,"public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  int length=0;
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (knownChunks.contains(location))       continue;
      PacketPlayOutChunkData data=((TridentChunk)world().chunkAt(x,z,true)).asPacket();
      length+=(10 + data.getData().length);
      bulk.addEntry(data);
      knownChunks.add(location);
      if (length >= 0x1DAE40) {
        connection.sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
        length=0;
      }
    }
  }
  connection.sendPacket(bulk);
}","public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  int length=0;
  int chunks=0;
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      boolean contains=false;
      for (      ChunkLocation loc : knownChunks) {
        if (loc.equals(location)) {
          contains=true;
          break;
        }
      }
      if (contains) {
        continue;
      }
      PacketPlayOutChunkData data=((TridentChunk)world().chunkAt(x,z,true)).asPacket();
      knownChunks.add(location);
      bulk.addEntry(data);
      length+=(10 + data.getData().length);
      if (length >= 0x1DAE40) {
        connection.sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
        length=0;
      }
      chunks++;
    }
  }
  if (bulk.hasEntries())   connection.sendPacket(bulk);
}"
11831,"TridentWorld(String name,WorldLoader loader){
  this(name,loader,new Random());
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  InputStream fis=null;
  try {
    fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    TridentLogger.error(new IllegalArgumentException(""String_Node_Str"" + name));
    return;
  }
catch (  Exception ex) {
    TridentLogger.error(""String_Node_Str"");
    TridentLogger.error(ex);
    return;
  }
 finally {
    try {
      if (fis != null) {
        fis.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  TridentLogger.log(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue() + 4);
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.NORMAL;
  defaultGamemode=GameMode.gamemodeOf(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.levelTypeOf(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  borderSize=level.containsTag(""String_Node_Str"") ? ((DoubleTag)level.getTag(""String_Node_Str"")).getValue() : 6000;
  time=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  existed=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  raining=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  rainTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  thundering=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  thunderTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  difficultyLocked=level.containsTag(""String_Node_Str"") && ((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  TridentLogger.success(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    TridentLogger.error(new IllegalStateException(""String_Node_Str""));
  }
  TridentLogger.success(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    TridentLogger.warn(""String_Node_Str"");
    playerData.mkdir();
  }
 else {
    TridentLogger.log(""String_Node_Str"");
    for (    File f : playerData.listFiles(new PlayerFilter())) {
      CompoundTag opData;
      InputStream input=null;
      try {
        input=new FileInputStream(levelFile);
        byte[] compressedData=new byte[input.available()];
        input.read(compressedData);
        opData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode();
      }
 catch (      IOException|NBTException ex) {
        TridentLogger.log(""String_Node_Str"" + f.getName() + ""String_Node_Str"");
        TridentLogger.error(ex);
        continue;
      }
 finally {
        try {
          if (input != null) {
            input.close();
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      new OfflinePlayer(opData,this);
    }
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    int centX=((int)Math.floor(spawnLocation.getX())) >> 4;
    int centZ=((int)Math.floor(spawnLocation.getZ())) >> 4;
    for (int x=centX - 3; x <= centX + 3; x++) {
      for (int z=centZ - 3; z <= centZ + 3; z++) {
        chunkAt(x,z,true);
      }
    }
    TridentLogger.success(""String_Node_Str"");
  }
}","TridentWorld(String name,WorldLoader loader){
  this(name,loader,new Random());
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  InputStream fis=null;
  try {
    fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    TridentLogger.error(new IllegalArgumentException(""String_Node_Str"" + name));
    return;
  }
catch (  Exception ex) {
    TridentLogger.error(""String_Node_Str"");
    TridentLogger.error(ex);
    return;
  }
 finally {
    try {
      if (fis != null) {
        fis.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  TridentLogger.log(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue() + 5);
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.NORMAL;
  defaultGamemode=GameMode.gamemodeOf(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.levelTypeOf(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  borderSize=level.containsTag(""String_Node_Str"") ? ((DoubleTag)level.getTag(""String_Node_Str"")).getValue() : 6000;
  time=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  existed=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  raining=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  rainTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  thundering=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  thunderTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  difficultyLocked=level.containsTag(""String_Node_Str"") && ((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  TridentLogger.success(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    TridentLogger.error(new IllegalStateException(""String_Node_Str""));
  }
  TridentLogger.success(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    TridentLogger.warn(""String_Node_Str"");
    playerData.mkdir();
  }
 else {
    TridentLogger.log(""String_Node_Str"");
    for (    File f : playerData.listFiles(new PlayerFilter())) {
      CompoundTag opData;
      InputStream input=null;
      try {
        input=new FileInputStream(levelFile);
        byte[] compressedData=new byte[input.available()];
        input.read(compressedData);
        opData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode();
      }
 catch (      IOException|NBTException ex) {
        TridentLogger.log(""String_Node_Str"" + f.getName() + ""String_Node_Str"");
        TridentLogger.error(ex);
        continue;
      }
 finally {
        try {
          if (input != null) {
            input.close();
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      new OfflinePlayer(opData,this);
    }
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    int centX=((int)Math.floor(spawnLocation.getX())) >> 4;
    int centZ=((int)Math.floor(spawnLocation.getZ())) >> 4;
    for (int x=centX - 3; x <= centX + 3; x++) {
      for (int z=centZ - 3; z <= centZ + 3; z++) {
        chunkAt(x,z,true);
      }
    }
    TridentLogger.success(""String_Node_Str"");
  }
}"
11832,"@Override protected void decode(ChannelHandlerContext context,ByteBuf buf,List<Object> objects) throws Exception {
  boolean compressed=connection.isCompressionEnabled();
  int fullLength=-1;
  if (compressed) {
    fullLength=Codec.readVarInt32(buf);
  }
  this.rawLength=Codec.readVarInt32(buf);
  if (rawLength == 0)   compressed=false;
  if (!(compressed) && rawLength < TridentServer.instance().getCompressionThreshold()) {
    ByteBuf data=buf.readBytes((fullLength == -1) ? rawLength : (fullLength - Codec.sizeOf(0)));
    objects.add(new PacketData(data));
    return;
  }
  byte[] compressedData=new byte[buf.readableBytes()];
  byte[] decompressed=new byte[rawLength];
  buf.readBytes(compressedData);
  inflater.setInput(compressedData);
  inflater.inflate(decompressed);
  objects.add(new PacketData(Unpooled.wrappedBuffer(decompressed)));
  inflater.reset();
}","@Override protected void decode(ChannelHandlerContext context,ByteBuf buf,List<Object> objects) throws Exception {
  boolean compressed=connection.isCompressionEnabled();
  int fullLength=-1;
  if (compressed) {
    fullLength=Codec.readVarInt32(buf);
  }
  this.rawLength=Codec.readVarInt32(buf);
  if (rawLength == 0)   compressed=false;
  if (!(compressed) || rawLength < TridentServer.instance().getCompressionThreshold()) {
    ByteBuf data=buf.readBytes((fullLength == -1) ? rawLength : (fullLength - Codec.sizeOf(0)));
    objects.add(new PacketData(data));
    return;
  }
  byte[] compressedData=new byte[buf.readableBytes()];
  byte[] decompressed=new byte[rawLength];
  buf.readBytes(compressedData);
  inflater.setInput(compressedData);
  inflater.inflate(decompressed);
  objects.add(new PacketData(Unpooled.wrappedBuffer(decompressed)));
  inflater.reset();
}"
11833,"@Override protected void encode(ChannelHandlerContext channelHandlerContext,ByteBuf msg,ByteBuf out) throws Exception {
  int threshold=TridentServer.instance().getCompressionThreshold();
  boolean underThreshold=msg.readableBytes() < threshold && threshold != -1;
  if (underThreshold && connection.isCompressionEnabled()) {
    sendDecompressed(msg,out);
  }
 else   if (!(underThreshold) && connection.isCompressionEnabled()) {
    sendCompressed(msg,out);
  }
 else {
    Codec.writeVarInt32(out,msg.readableBytes());
    out.writeBytes(msg);
  }
  Files.write(Paths.get(""String_Node_Str""),Arrays.asList(DatatypeConverter.printHexBinary(Codec.asArray(out.copy()))),Charset.defaultCharset());
}","@Override protected void encode(ChannelHandlerContext channelHandlerContext,ByteBuf msg,ByteBuf out) throws Exception {
  int threshold=TridentServer.instance().getCompressionThreshold();
  boolean underThreshold=msg.readableBytes() < threshold && threshold != -1;
  if (underThreshold && connection.isCompressionEnabled()) {
    sendDecompressed(msg,out);
  }
 else   if (!(underThreshold) && connection.isCompressionEnabled()) {
    sendCompressed(msg,out);
  }
 else {
    Codec.writeVarInt32(out,msg.readableBytes());
    out.writeBytes(msg);
  }
}"
11834,"/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client    {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketDirection.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  TridentLogger.log(""String_Node_Str"" + packet.getClass().getSimpleName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str""));
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
    if (connection instanceof PlayerConnection) {
      ((PlayerConnection)connection).resetReadCounter();
    }
  }
 catch (  Exception ex) {
    TridentLogger.error(ex);
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",""String_Node_Str"" + ex.getClass().getName() + ((ex.getMessage() != null) ? ""String_Node_Str"" + ex.getMessage() : ""String_Node_Str"")+ ""String_Node_Str"");
this.connection.sendPacket(quit);
this.connection.logout();
default :
break;
}
}
}","/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client    {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketDirection.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  if (!(packet instanceof PacketPlayInPlayerMove)) {
    TridentLogger.log(""String_Node_Str"" + packet.getClass().getSimpleName().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str""));
  }
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
    if (connection instanceof PlayerConnection) {
      ((PlayerConnection)connection).resetReadCounter();
    }
  }
 catch (  Exception ex) {
    TridentLogger.error(ex);
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",""String_Node_Str"" + ex.getClass().getName() + ((ex.getMessage() != null) ? ""String_Node_Str"" + ex.getMessage() : ""String_Node_Str"")+ ""String_Node_Str"");
this.connection.sendPacket(quit);
this.connection.logout();
default :
break;
}
}
}"
11835,"@Override public void tick(){
  this.executor.execute(new Runnable(){
    @Override public void run(){
      TridentPlayer.super.tick();
      sendChunks(TridentServer.instance().viewDistance());
      connection.tick();
      ticksExisted.incrementAndGet();
    }
  }
);
}","@Override public void tick(){
  this.executor.execute(new Runnable(){
    @Override public void run(){
      TridentPlayer.super.tick();
      if (!chunkQueue.isEmpty())       connection.sendPacket(chunkQueue.poll());
      connection.tick();
      ticksExisted.incrementAndGet();
    }
  }
);
}"
11836,"public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  int length=0;
  for (int x=(centX - (int)Math.floor(viewDistance / 2)); x <= (centX + (int)Math.floor(viewDistance / 2)); x+=1) {
    for (int z=(centZ - (int)Math.floor(viewDistance / 2)); z <= (centZ + (int)Math.floor(viewDistance / 2)); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (knownChunks.contains(location))       continue;
      PacketPlayOutChunkData data=((TridentChunk)world().chunkAt(x,z,true)).asPacket();
      length+=(10 + data.getData().length);
      bulk.addEntry(data);
      knownChunks.add(location);
      if (length >= 0x1DAE40) {
        connection.sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
        length=0;
      }
    }
  }
  connection.sendPacket(bulk);
}","public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  int length=0;
  for (int x=(centX - viewDistance / 2); x <= (centX + viewDistance / 2); x+=1) {
    for (int z=(centZ - viewDistance / 2); z <= (centZ + viewDistance / 2); z+=1) {
      ChunkLocation location=ChunkLocation.create(x,z);
      if (knownChunks.contains(location))       continue;
      PacketPlayOutChunkData data=((TridentChunk)world().chunkAt(x,z,true)).asPacket();
      length+=(10 + data.getData().length);
      bulk.addEntry(data);
      knownChunks.add(location);
      if (length >= 0x1DAE40) {
        connection.sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
        length=0;
      }
    }
  }
  connection.sendPacket(bulk);
}"
11837,"/** 
 * Pass in a chunk to load its data from file
 */
public TridentChunk loadChunkData(TridentWorld owner,ChunkLocation location) throws NBTException, IOException, DataFormatException {
  TridentChunk chunk=new TridentChunk(owner,location);
  short compression;
  byte[] compressedData;
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    access.seek((long)this.sectors.getTimeStampLocation(chunk));
    int lastUpdate=access.readInt();
    if (chunk.getLastFileAccess() > lastUpdate) {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
      access.close();
      return chunk;
    }
 else {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
    }
    access.seek((long)this.sectors.getDataLocation(chunk));
    int length=access.readInt();
    compression=(short)access.readByte();
    compressedData=new byte[length - 1];
    access.readFully(compressedData);
    access.close();
  }
  byte[] chunkData;
switch (compression) {
case 0:
case 1:
    GZIPInputStream in=new GZIPInputStream(new ByteArrayInputStream(compressedData));
  chunkData=new byte[in.available()];
in.read(chunkData);
in.close();
break;
case 2:
Inflater inflater=new Inflater();
ByteArrayOutputStream output=new ByteArrayOutputStream();
InflaterOutputStream outputStream=new InflaterOutputStream(output,inflater);
inflater.setInput(compressedData);
while (!(inflater.finished())) {
outputStream.write(buffer);
}
output.close();
chunkData=output.toByteArray();
inflater.end();
break;
default :
TridentLogger.error(new IllegalStateException(""String_Node_Str""));
return null;
}
CompoundTag nbtData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(chunkData))).decode();
chunk.load(nbtData);
return chunk;
}","/** 
 * Pass in a chunk to load its data from file
 */
public TridentChunk loadChunkData(TridentChunk chunk) throws NBTException, IOException, DataFormatException {
  short compression;
  byte[] compressedData;
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    access.seek((long)this.sectors.getTimeStampLocation(chunk));
    int lastUpdate=access.readInt();
    if (chunk.getLastFileAccess() > lastUpdate) {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
      access.close();
      return chunk;
    }
 else {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
    }
    long dataLoc=(long)this.sectors.getDataLocation(chunk);
    access.seek(dataLoc);
    int length=access.readInt();
    compression=(short)access.readByte();
    compressedData=new byte[length - 1];
    access.readFully(compressedData);
    access.close();
  }
  byte[] chunkData;
switch (compression) {
case 0:
case 1:
    GZIPInputStream in=new GZIPInputStream(new ByteArrayInputStream(compressedData));
  chunkData=new byte[in.available()];
in.read(chunkData);
in.close();
break;
case 2:
Inflater inflater=new Inflater();
ByteArrayOutputStream output=new ByteArrayOutputStream();
InflaterOutputStream outputStream=new InflaterOutputStream(output,inflater);
inflater.setInput(compressedData);
while (!(inflater.finished())) {
outputStream.write(buffer);
}
output.close();
chunkData=output.toByteArray();
inflater.end();
break;
default :
TridentLogger.error(new IllegalStateException(""String_Node_Str""));
return null;
}
CompoundTag nbtData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(chunkData))).decode();
chunk.load(nbtData);
return chunk;
}"
11838,"/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return mod(c.getX()) + mod(c.getZ()) * 32;
}","/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return (c.getX() & 31) + (c.getZ() & 31) * 32;
}"
11839,"public PacketPlayOutChunkData asPacket(){
  PacketPlayOutChunkData packet=new PacketPlayOutChunkData();
  int bitmask=(1 << sections.length) - 1;
  int count=sections.length;
  int size=0;
  int sectionSize=ChunkSection.LENGTH * 5 / 2;
  if (world.dimension() == Dimension.OVERWORLD)   sectionSize+=ChunkSection.LENGTH / 2;
  size+=count * sectionSize + 256;
  for (  ChunkSection section : sections) {
    if (section == null)     continue;
    for (    byte b : section.getTypes()) {
      data.write(b & 0xff);
      data.write(b >> 8);
    }
  }
  for (  ChunkSection section : sections) {
    try {
      data.write(section.blockLight);
    }
 catch (    IOException e) {
      TridentLogger.error(e);
    }
  }
  for (  ChunkSection section : sections) {
    try {
      data.write(section.skyLight);
    }
 catch (    IOException e) {
      TridentLogger.error(e);
    }
  }
  for (int i=0; i < 256; i+=1) {
    data.write(0);
  }
  packet.set(""String_Node_Str"",location);
  packet.set(""String_Node_Str"",(short)bitmask);
  packet.set(""String_Node_Str"",data.toByteArray());
  data.reset();
  return packet;
}","public PacketPlayOutChunkData asPacket(){
  PacketPlayOutChunkData packet=new PacketPlayOutChunkData();
  if (sections == null) {
    try {
      RegionFile.fromPath(world.name(),location).loadChunkData(this);
    }
 catch (    Exception e) {
      TridentLogger.error(e);
    }
  }
  int bitmask=(1 << sections.length) - 1;
  int count=sections.length;
  int size=0;
  int sectionSize=ChunkSection.LENGTH * 5 / 2;
  if (world.dimension() == Dimension.OVERWORLD)   sectionSize+=ChunkSection.LENGTH / 2;
  size+=count * sectionSize + 256;
  for (  ChunkSection section : sections) {
    if (section == null)     continue;
    for (    byte b : section.getTypes()) {
      data.write(b & 0xff);
      data.write(b >> 8);
    }
  }
  for (  ChunkSection section : sections) {
    try {
      data.write(section.blockLight);
    }
 catch (    IOException e) {
      TridentLogger.error(e);
    }
  }
  for (  ChunkSection section : sections) {
    try {
      data.write(section.skyLight);
    }
 catch (    IOException e) {
      TridentLogger.error(e);
    }
  }
  for (int i=0; i < 256; i+=1) {
    data.write(0);
  }
  packet.set(""String_Node_Str"",location);
  packet.set(""String_Node_Str"",(short)bitmask);
  packet.set(""String_Node_Str"",data.toByteArray());
  data.reset();
  return packet;
}"
11840,"TridentWorld(String name,WorldLoader loader){
  this(name,loader,new Random());
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  InputStream fis=null;
  try {
    fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    TridentLogger.error(new IllegalArgumentException(""String_Node_Str"" + name));
    return;
  }
catch (  Exception ex) {
    TridentLogger.error(""String_Node_Str"");
    TridentLogger.error(ex);
    return;
  }
 finally {
    try {
      if (fis != null) {
        fis.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  TridentLogger.log(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue() + 4);
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.NORMAL;
  defaultGamemode=GameMode.gamemodeOf(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.levelTypeOf(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  borderSize=((DoubleTag)level.getTag(""String_Node_Str"")).getValue();
  time=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  existed=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  raining=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  rainTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  thundering=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  thunderTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  difficultyLocked=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  TridentLogger.success(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    TridentLogger.error(new IllegalStateException(""String_Node_Str""));
  }
  TridentLogger.success(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    TridentLogger.warn(""String_Node_Str"");
    playerData.mkdir();
  }
 else {
    TridentLogger.log(""String_Node_Str"");
    for (    File f : playerData.listFiles(new PlayerFilter())) {
      CompoundTag opData;
      InputStream input=null;
      try {
        input=new FileInputStream(levelFile);
        byte[] compressedData=new byte[input.available()];
        input.read(compressedData);
        opData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode();
      }
 catch (      IOException|NBTException ex) {
        TridentLogger.log(""String_Node_Str"" + f.getName() + ""String_Node_Str"");
        TridentLogger.error(ex);
        continue;
      }
 finally {
        try {
          if (input != null) {
            input.close();
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      new OfflinePlayer(opData,this);
    }
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    int centX=((int)Math.floor(spawnLocation.getX())) >> 4;
    int centZ=((int)Math.floor(spawnLocation.getZ())) >> 4;
    for (int x=(centX - 7); x <= (centX + 7); x++) {
      for (int z=(centZ - 7); z <= (centZ + 7); z++) {
        chunkAt(x,z,true);
      }
    }
    TridentLogger.success(""String_Node_Str"");
  }
}","TridentWorld(String name,WorldLoader loader){
  this(name,loader,new Random());
  TridentLogger.log(""String_Node_Str"" + name + ""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  InputStream fis=null;
  try {
    fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    TridentLogger.error(new IllegalArgumentException(""String_Node_Str"" + name));
    return;
  }
catch (  Exception ex) {
    TridentLogger.error(""String_Node_Str"");
    TridentLogger.error(ex);
    return;
  }
 finally {
    try {
      if (fis != null) {
        fis.close();
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  TridentLogger.log(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue() + 4);
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.NORMAL;
  defaultGamemode=GameMode.gamemodeOf(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.levelTypeOf(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  borderSize=level.containsTag(""String_Node_Str"") ? ((DoubleTag)level.getTag(""String_Node_Str"")).getValue() : 6000;
  time=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  existed=((LongTag)level.getTag(""String_Node_Str"")).getValue();
  raining=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  rainTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  thundering=((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  thunderTime=((IntTag)level.getTag(""String_Node_Str"")).getValue();
  difficultyLocked=level.containsTag(""String_Node_Str"") && ((ByteTag)level.getTag(""String_Node_Str"")).getValue() == 1;
  TridentLogger.success(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    TridentLogger.error(new IllegalStateException(""String_Node_Str""));
  }
  TridentLogger.success(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    TridentLogger.warn(""String_Node_Str"");
    playerData.mkdir();
  }
 else {
    TridentLogger.log(""String_Node_Str"");
    for (    File f : playerData.listFiles(new PlayerFilter())) {
      CompoundTag opData;
      InputStream input=null;
      try {
        input=new FileInputStream(levelFile);
        byte[] compressedData=new byte[input.available()];
        input.read(compressedData);
        opData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode();
      }
 catch (      IOException|NBTException ex) {
        TridentLogger.log(""String_Node_Str"" + f.getName() + ""String_Node_Str"");
        TridentLogger.error(ex);
        continue;
      }
 finally {
        try {
          if (input != null) {
            input.close();
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
      new OfflinePlayer(opData,this);
    }
    TridentLogger.success(""String_Node_Str"");
    TridentLogger.log(""String_Node_Str"");
    int centX=((int)Math.floor(spawnLocation.getX())) >> 4;
    int centZ=((int)Math.floor(spawnLocation.getZ())) >> 4;
    for (int x=centX - 3; x <= centX + 3; x++) {
      for (int z=centZ - 3; z <= centZ + 3; z++) {
        chunkAt(x,z,true);
      }
    }
    TridentLogger.success(""String_Node_Str"");
  }
}"
11841,"@InternalUseOnly public void loadAll(){
  for (  File file : Trident.fileContainer().toFile().listFiles()) {
    if (!(file.isDirectory()) || file.getName().contains(""String_Node_Str""))     continue;
    boolean isWorld=false;
    for (    File f : file.listFiles()) {
      if (f.getName().equals(""String_Node_Str"")) {
        isWorld=true;
        continue;
      }
      if (f.getName().equals(""String_Node_Str"")) {
        String className=null;
        try {
          byte[] sig=Files.readAllBytes(Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str""));
          className=new String(sig);
          if (!className.equals(this.getClass().getName())) {
            new TridentWorldLoader(Class.forName(className).asSubclass(AbstractGenerator.class));
            isWorld=false;
          }
        }
 catch (        IOException e) {
          TridentLogger.error(e);
          isWorld=true;
        }
catch (        ClassNotFoundException e) {
          TridentLogger.error(""String_Node_Str"" + className + ""String_Node_Str"");
          TridentLogger.error(e);
          isWorld=true;
        }
      }
    }
    if (!(isWorld))     continue;
    Path gensig=Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str"");
    if (!Files.exists(gensig)) {
      try {
        Files.createFile(gensig);
        Files.write(gensig,generator().getClass().getName().getBytes(Charset.defaultCharset()));
      }
 catch (      IOException e) {
        TridentLogger.error(""String_Node_Str"");
        TridentLogger.error(e);
      }
    }
    load(file.getName());
  }
}","@InternalUseOnly public void loadAll(){
  TridentLogger.log(""String_Node_Str"");
  for (  File file : Trident.fileContainer().toFile().listFiles()) {
    if (!(file.isDirectory()) || file.getName().contains(""String_Node_Str""))     continue;
    boolean isWorld=false;
    for (    File f : file.listFiles()) {
      if (f.getName().equals(""String_Node_Str"")) {
        isWorld=true;
        continue;
      }
      if (f.getName().equals(""String_Node_Str"")) {
        String className=null;
        try {
          byte[] sig=Files.readAllBytes(Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str""));
          className=new String(sig);
          if (!className.equals(this.getClass().getName())) {
            new TridentWorldLoader(Class.forName(className).asSubclass(AbstractGenerator.class)).load(file.getName());
            isWorld=false;
          }
        }
 catch (        IOException e) {
          TridentLogger.error(e);
          isWorld=true;
        }
catch (        ClassNotFoundException e) {
          TridentLogger.error(""String_Node_Str"" + className + ""String_Node_Str"");
          TridentLogger.error(e);
          isWorld=true;
        }
      }
    }
    if (!(isWorld))     continue;
    Path gensig=Trident.fileContainer().resolve(file.getName()).resolve(""String_Node_Str"");
    if (!Files.exists(gensig)) {
      try {
        Files.createFile(gensig);
        Files.write(gensig,generator().getClass().getName().getBytes(Charset.defaultCharset()));
      }
 catch (      IOException e) {
        TridentLogger.error(""String_Node_Str"");
        TridentLogger.error(e);
      }
    }
    load(file.getName());
  }
  TridentLogger.log(""String_Node_Str"");
}"
11842,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  DigStatus digStatus=DigStatus.getStatus(this.status);
  BlockOrientation face=null;
  MassChange change=new DefaultMassChange(player.world());
  for (int y=(int)player.location().y() + 2; y < 50; y++) {
    change.setBlock((int)player.location().x(),y,(int)player.location().z(),Substance.DIRT);
  }
  change.commitChanges();
  TridentLogger.log(""String_Node_Str"");
switch (this.blockFace) {
case 0:
    face=BlockOrientation.BOTTOM;
  break;
case 1:
face=BlockOrientation.TOP;
break;
case 2:
break;
case 3:
break;
case 4:
break;
case 5:
break;
default :
TridentLogger.error(new IllegalArgumentException(""String_Node_Str""));
}
Cancellable event=null;
switch (digStatus) {
case DIG_START:
case DIG_CANCEL:
case DIG_FINISH:
event=new PlayerDigEvent(player,face,this.status);
break;
case DROP_ITEMSTACK:
event=new PlayerDropItemEvent(player,null);
break;
case DROP_ITEM:
event=new PlayerDropItemEvent(player,null);
break;
case SHOOT_ARROW:
break;
}
TridentServer.instance().eventHandler().fire((Event)event);
if (event == null || event.isIgnored()) return;
this.location.setWorld(player.world());
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).player();
  DigStatus digStatus=DigStatus.getStatus(this.status);
  BlockOrientation face=null;
switch (this.blockFace) {
case 0:
    face=BlockOrientation.BOTTOM;
  break;
case 1:
face=BlockOrientation.TOP;
break;
case 2:
break;
case 3:
break;
case 4:
break;
case 5:
break;
default :
TridentLogger.error(new IllegalArgumentException(""String_Node_Str""));
}
Cancellable event=null;
switch (digStatus) {
case DIG_START:
case DIG_CANCEL:
case DIG_FINISH:
event=new PlayerDigEvent(player,face,this.status);
break;
case DROP_ITEMSTACK:
event=new PlayerDropItemEvent(player,null);
break;
case DROP_ITEM:
event=new PlayerDropItemEvent(player,null);
break;
case SHOOT_ARROW:
break;
}
TridentServer.instance().eventHandler().fire((Event)event);
if (event == null || event.isIgnored()) return;
this.location.setWorld(player.world());
}"
11843,"@InternalUseOnly public void resumeLogin(){
  if (!loggingIn)   return;
  connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
  sendChunks(TridentServer.instance().viewDistance());
  connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",location()).set(""String_Node_Str"",(byte)0));
  TridentWindow window=new TridentWindow(""String_Node_Str"",9,InventoryType.CHEST);
  window.setSlot(0,new Item(Substance.DIAMOND_PICKAXE));
  window.sendTo(this);
  for (  Entity entity : world().entities()) {
  }
  loggingIn=false;
}","@InternalUseOnly public void resumeLogin(){
  if (!loggingIn)   return;
  connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
  sendChunks(TridentServer.instance().viewDistance());
  connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",location()).set(""String_Node_Str"",(byte)1));
  TridentWindow window=new TridentWindow(""String_Node_Str"",9,InventoryType.CHEST);
  window.setSlot(0,new Item(Substance.DIAMOND_PICKAXE));
  window.sendTo(this);
  for (  Entity entity : world().entities()) {
  }
  loggingIn=false;
  connection.sendPacket(new PacketPlayOutEntityVelocity().set(""String_Node_Str"",entityId()).set(""String_Node_Str"",new Vector(0,-0.1,0)));
}"
11844,"public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=TridentEntityBuilder.create().uuid(id).spawn(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.entityId()).set(""String_Node_Str"",GameMode.CREATIVE).set(""String_Node_Str"",p.world().dimension()).set(""String_Node_Str"",p.world().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.world().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.spawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.spawnLocation()).set(""String_Node_Str"",(byte)0));
    }
  }
);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=TridentEntityBuilder.create().uuid(id).spawn(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.entityId()).set(""String_Node_Str"",GameMode.CREATIVE).set(""String_Node_Str"",p.world().dimension()).set(""String_Node_Str"",p.world().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.world().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.spawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.spawnLocation()).set(""String_Node_Str"",(byte)1));
    }
  }
);
  return p;
}"
11845,"/** 
 * Pass in a chunk to load its data from file
 */
public TridentChunk loadChunkData(TridentChunk chunk) throws NBTException, IOException, DataFormatException {
  short compression;
  byte[] compressedData;
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    access.seek((long)this.sectors.timeStampLoc(chunk));
    int lastUpdate=access.readInt();
    if (chunk.lastFileAccess() > lastUpdate) {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
      access.close();
      return chunk;
    }
 else {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
    }
    long dataLoc=(long)this.sectors.dataLoc(chunk);
    access.seek(dataLoc);
    int length=access.readInt();
    compression=(short)access.readByte();
    compressedData=new byte[length - 1];
    access.readFully(compressedData);
    access.close();
  }
  byte[] chunkData;
switch (compression) {
case 0:
case 1:
    GZIPInputStream in=new GZIPInputStream(new ByteArrayInputStream(compressedData));
  chunkData=new byte[in.available()];
in.read(chunkData);
in.close();
break;
case 2:
Inflater inflater=new Inflater();
ByteArrayOutputStream output=new ByteArrayOutputStream();
InflaterOutputStream outputStream=new InflaterOutputStream(output,inflater);
inflater.setInput(compressedData);
while (!(inflater.finished())) {
outputStream.write(buffer);
}
output.close();
chunkData=output.toByteArray();
inflater.end();
break;
default :
TridentLogger.error(new IllegalStateException(""String_Node_Str""));
return null;
}
CompoundTag nbtData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(chunkData))).decode();
chunk.load(nbtData);
return chunk;
}","/** 
 * Pass in a chunk to load its data from file
 */
public TridentChunk loadChunkData(TridentChunk chunk) throws NBTException, IOException, DataFormatException {
  short compression;
  byte[] compressedData;
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    access.seek((long)this.sectors.timeStampLoc(chunk));
    int lastUpdate=access.readInt();
    if (chunk.lastFileAccess() > lastUpdate) {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
      access.close();
      return chunk;
    }
 else {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
    }
    long dataLoc=(long)this.sectors.dataLoc(chunk);
    access.seek(dataLoc);
    int length=access.readInt();
    compression=(short)access.readByte();
    if (length <= 0) {
      return null;
    }
    compressedData=new byte[length - 1];
    access.readFully(compressedData);
    access.close();
  }
  byte[] chunkData;
switch (compression) {
case 0:
case 1:
    GZIPInputStream in=new GZIPInputStream(new ByteArrayInputStream(compressedData));
  chunkData=new byte[in.available()];
in.read(chunkData);
in.close();
break;
case 2:
Inflater inflater=new Inflater();
ByteArrayOutputStream output=new ByteArrayOutputStream();
InflaterOutputStream outputStream=new InflaterOutputStream(output,inflater);
inflater.setInput(compressedData);
while (!(inflater.finished())) {
outputStream.write(buffer);
}
output.close();
chunkData=output.toByteArray();
inflater.end();
break;
default :
TridentLogger.error(new IllegalStateException(""String_Node_Str""));
return null;
}
CompoundTag nbtData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(chunkData))).decode();
chunk.load(nbtData);
return chunk;
}"
11846,"@Override public TridentChunk generateChunk(ChunkLocation location){
  if (location == null) {
    TridentLogger.error(new NullPointerException(""String_Node_Str""));
    return null;
  }
  int x=location.x();
  int z=location.z();
  if (x > MAX_CHUNKS || x < -MAX_CHUNKS) {
    return null;
  }
  if (z > MAX_CHUNKS || z < -MAX_CHUNKS) {
    return null;
  }
  if (this.chunkAt(location,false) == null) {
    if (this.loader.chunkExists(this,x,z)) {
      this.addChunkAt(location,this.loader.loadChunk(this,x,z));
    }
 else {
      TridentChunk chunk=new TridentChunk(this,x,z);
      this.addChunkAt(location,chunk);
      chunk.generate();
    }
  }
  return this.chunkAt(location,false);
}","@Override public TridentChunk generateChunk(ChunkLocation location){
  if (location == null) {
    TridentLogger.error(new NullPointerException(""String_Node_Str""));
    return null;
  }
  int x=location.x();
  int z=location.z();
  if (x > MAX_CHUNKS || x < -MAX_CHUNKS) {
    return null;
  }
  if (z > MAX_CHUNKS || z < -MAX_CHUNKS) {
    return null;
  }
  if (this.chunkAt(location,false) == null) {
    Chunk c=this.loader.loadChunk(this,x,z);
    if (this.loader.chunkExists(this,x,z) && c != null) {
      this.addChunkAt(location,c);
      return (TridentChunk)c;
    }
 else {
      TridentChunk chunk=new TridentChunk(this,x,z);
      this.addChunkAt(location,chunk);
      chunk.generate();
      TridentLogger.log(""String_Node_Str"" + x + ""String_Node_Str""+ z+ ""String_Node_Str"");
      return chunk;
    }
  }
  return this.chunkAt(location,false);
}"
11847,"public void stop(){
  taskExecutor.shutdown();
}","public void stop(){
  taskExecutor.shutdown();
  taskList.clear();
}"
11848,"public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=EntityBuilder.create().uuid(id).spawnLocation(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().dimension()).set(""String_Node_Str"",p.getWorld().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.getWorld().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
      p.sendChunks(3);
      p.connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
      Slot[] slots=new Slot[44];
      slots[43]=new Slot(new Item(Substance.APPLE));
      for (      Entity entity : p.getWorld().entities()) {
      }
      ThreadsHandler.playerExecutor().assign(p);
    }
  }
);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=EntityBuilder.create().uuid(id).spawnLocation(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().dimension()).set(""String_Node_Str"",p.getWorld().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.getWorld().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
      p.sendChunks(3);
      p.connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
      Slot[] slots=new Slot[44];
      slots[43]=new Slot(new Item(Substance.APPLE));
      p.connection.sendPacket(new PacketPlayOutWindowItems().set(""String_Node_Str"",0).set(""String_Node_Str"",slots));
      for (      Entity entity : p.getWorld().entities()) {
      }
    }
  }
);
  return p;
}"
11849,"private ConcurrentTaskExecutor(int scale){
  this.scale=scale;
  executors=new AtomicReferenceArray<>(scale + EMERGENCY_MARGIN);
  for (int i=0; i < scale; i++) {
    executors.set(i,new ThreadWorker(i).startWorker());
  }
  state=RUNNING;
}","private ConcurrentTaskExecutor(int scale,String name){
  this.scale=scale;
  this.name=name;
  executors=new AtomicReferenceArray<>(scale + EMERGENCY_MARGIN);
  for (int i=0; i < scale; i++) {
    executors.set(i,new ThreadWorker(i,name).startWorker());
  }
  state=RUNNING;
}"
11850,"@Override public void run(){
  while (!isInterrupted()) {
    try {
      Runnable task=tasks.take();
      task.run();
      int cycles=0;
      while (tasks.peek() == null)       if (cycles++ == 1024) {
        interrupt();
        break;
      }
    }
 catch (    InterruptedException e) {
      return;
    }
catch (    Exception e) {
      TridentLogger.error(e);
      handleShutdown(((ThreadWorker)scaledThread()).index,tasks);
      return;
    }
  }
  emergencyScale.decrementAndGet();
}","@Override public void run(){
  while (!isInterrupted()) {
    try {
      Runnable task=tasks.take();
      task.run();
      int cycles=0;
      while (tasks.peek() == null) {
        Thread.yield();
        if (cycles++ == 1024) {
          interrupt();
          break;
        }
      }
    }
 catch (    InterruptedException e) {
      return;
    }
catch (    Exception e) {
      TridentLogger.error(e);
      handleShutdown(((ThreadWorker)scaledThread()).index,tasks);
      return;
    }
  }
  emergencyScale.decrementAndGet();
}"
11851,"private OverflowWorker(int index){
  super(index);
}","private OverflowWorker(int index){
  super(index,name + ""String_Node_Str"");
}"
11852,"/** 
 * Create a new executor using the number of threads to scale
 * @param scale the threads to use
 * @return a new concurrent task executor pool
 */
public static <E>ConcurrentTaskExecutor<E> create(int scale){
  ConcurrentTaskExecutor<E> executor=new ConcurrentTaskExecutor<>(scale);
  EXECUTORS.add(executor);
  return executor;
}","/** 
 * Create a new executor using the number of threads to scale
 * @param scale the threads to use
 * @return a new concurrent task executor pool
 */
public static <E>ConcurrentTaskExecutor<E> create(int scale,String name){
  ConcurrentTaskExecutor<E> executor=new ConcurrentTaskExecutor<>(scale,name);
  EXECUTORS.add(executor);
  return executor;
}"
11853,"private ThreadWorker(int index){
  this.index=index;
}","private ThreadWorker(int index,String name){
  super(""String_Node_Str"" + EXECUTORS.size() + ""String_Node_Str""+ index+ ""String_Node_Str""+ name);
  this.index=index;
}"
11854,"private static int calcTaskLen(){
  int objectSize=4;
  if (ARCH_64)   objectSize=8;
  long max=(Runtime.getRuntime().freeMemory() / objectSize) / 13;
  int len;
  if (max > (long)Integer.MAX_VALUE)   len=Integer.MAX_VALUE - 8;
 else   len=(int)max;
  return len;
}","private static int calcTaskLen(){
  int objectSize=4;
  if (ARCH_64)   objectSize=8;
  long max=(Runtime.getRuntime().freeMemory() / objectSize) / 15;
  int len;
  if (max > (long)Integer.MAX_VALUE)   len=Integer.MAX_VALUE - 8;
 else   len=(int)max;
  return len;
}"
11855,"public void handleShutdown(int index,Queue<Runnable> remaining){
  if (state < SHUTTING_DOWN) {
    if (index > this.scale) {
      executors.set(index,new OverflowWorker(index).startWorker(remaining));
    }
 else     executors.set(index,new ThreadWorker(index).startWorker(remaining));
  }
 else   executors.set(index,null);
  remaining.clear();
}","public void handleShutdown(int index,Queue<Runnable> remaining){
  if (state < SHUTTING_DOWN) {
    if (index > this.scale) {
      executors.set(index,new OverflowWorker(index).startWorker(remaining));
    }
 else     executors.set(index,new ThreadWorker(index,name).startWorker(remaining));
  }
 else   executors.set(index,null);
  remaining.clear();
}"
11856,"/** 
 * Creates the MainThread runner from the amount of heartbeats the server should take per second the server runs
 * @param ticksPerSecond the amount of heartbeats per second
 */
public MainThread(int ticksPerSecond){
  this.zeroBase=System.currentTimeMillis();
  instance=this;
  this.ticksPerSecond=ticksPerSecond;
  this.tickLength=1000 / ticksPerSecond;
}","/** 
 * Creates the MainThread runner from the amount of heartbeats the server should take per second the server runs
 * @param ticksPerSecond the amount of heartbeats per second
 */
public MainThread(int ticksPerSecond){
  super(""String_Node_Str"");
  this.zeroBase=System.currentTimeMillis();
  instance=this;
  this.ticksPerSecond=ticksPerSecond;
  this.tickLength=1000 / ticksPerSecond;
}"
11857,"/** 
 * Stops all the executors and clears all caches of concurrent threads
 */
@InternalUseOnly public static void stopAll(){
  BackgroundTaskExecutor.SERVICE.shutdownNow();
  MainThread.getInstance().interrupt();
  entityExecutor().shutdown();
  playerExecutor().shutdown();
  worldExecutor().shutdown();
}","/** 
 * Stops all the executors and clears all caches of concurrent threads
 */
@InternalUseOnly public static void stopAll(){
  MainThread.getInstance().interrupt();
  entityExecutor().shutdown();
  playerExecutor().shutdown();
  worldExecutor().shutdown();
}"
11858,"@Override public <T>ExecutorFactory<T> executor(int threads){
  return ConcurrentTaskExecutor.create(threads);
}","@Override public <T>ExecutorFactory<T> executor(int threads,String name){
  return ConcurrentTaskExecutor.create(threads,name);
}"
11859,"public PacketPlayOutMapChunkBulk asPacket(){
  PacketPlayOutMapChunkBulk chunkBulk=new PacketPlayOutMapChunkBulk();
  int bitmask=(1 << sections.length) - 1;
  int count=sections.length;
  int size=0;
  int sectionSize=ChunkSection.LENGTH * 5 / 2;
  if (world.dimension() == Dimension.OVERWORLD)   sectionSize+=ChunkSection.LENGTH / 2;
  size+=count * sectionSize + 256;
  byte[] data=new byte[size];
  int pos=0;
  for (  ChunkSection section : sections) {
    for (    byte b : section.getTypes()) {
      data[pos++]=(byte)(b & 0xff);
      data[pos++]=(byte)(b >> 8);
    }
  }
  for (  ChunkSection section : sections) {
    System.arraycopy(section.blockLight,0,data,pos,section.blockLight.length);
    pos+=section.blockLight.length;
  }
  for (int i=0; i < 256; i+=1) {
    data[pos++]=0;
  }
  chunkBulk.set(""String_Node_Str"",new ChunkMetaBuilder().bitmap((short)bitmask).location(location));
  chunkBulk.set(""String_Node_Str"",data);
  chunkBulk.set(""String_Node_Str"",true);
  chunkBulk.set(""String_Node_Str"",sections.length);
  return chunkBulk;
}","public PacketPlayOutMapChunkBulk asPacket(){
  PacketPlayOutMapChunkBulk chunkBulk=new PacketPlayOutMapChunkBulk();
  int bitmask=(1 << sections.length) - 1;
  int count=sections.length;
  int size=0;
  int sectionSize=ChunkSection.LENGTH * 5 / 2;
  if (world.dimension() == Dimension.OVERWORLD)   sectionSize+=ChunkSection.LENGTH / 2;
  size+=count * sectionSize + 256;
  byte[] data=new byte[size];
  int pos=0;
  for (  ChunkSection section : sections) {
    for (    byte b : section.getTypes()) {
      data[pos++]=(byte)(b & 0xff);
      data[pos++]=(byte)(b >> 8);
    }
  }
  for (  ChunkSection section : sections) {
    System.arraycopy(section.blockLight,0,data,pos,section.blockLight.length);
    pos+=section.blockLight.length;
  }
  for (int i=0; i < 256; i+=1) {
    data[pos++]=0;
  }
  if (pos != size) {
    TridentLogger.error(new IllegalArgumentException(""String_Node_Str"" + pos + ""String_Node_Str""+ size));
    return null;
  }
  chunkBulk.set(""String_Node_Str"",new ChunkMetaBuilder().bitmap((short)bitmask).location(location));
  chunkBulk.set(""String_Node_Str"",data);
  chunkBulk.set(""String_Node_Str"",true);
  chunkBulk.set(""String_Node_Str"",sections.length);
  return chunkBulk;
}"
11860,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  super.location.setWorld(player.getWorld());
  Cancellable event=new PlayerMoveEvent(player,player.getLocation(),super.location);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport packet=new PacketPlayOutEntityTeleport();
    packet.set(""String_Node_Str"",player.getId());
    packet.set(""String_Node_Str"",player.getLocation());
    packet.set(""String_Node_Str"",player.isOnGround());
    connection.sendPacket(packet);
  }
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  super.location.setWorld(player.getWorld());
  Cancellable event=new PlayerMoveEvent(player,player.getLocation(),super.location);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport packet=new PacketPlayOutEntityTeleport();
    packet.set(""String_Node_Str"",player.getId());
    packet.set(""String_Node_Str"",player.getLocation());
    packet.set(""String_Node_Str"",player.isOnGround());
    connection.sendPacket(packet);
  }
  if (player.isLoggingIn())   player.resumeLogin();
}"
11861,"public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=EntityBuilder.create().uuid(id).spawnLocation(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().dimension()).set(""String_Node_Str"",p.getWorld().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.getWorld().difficulty()));
      p.sendChunks(7);
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
      p.connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
      for (      Entity entity : p.getWorld().entities()) {
      }
    }
  }
);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=EntityBuilder.create().uuid(id).spawnLocation(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().dimension()).set(""String_Node_Str"",p.getWorld().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.getWorld().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
    }
  }
);
  return p;
}"
11862,"public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  int i=0;
  for (int x=(centX - (viewDistance / 2)); x <= (centX + (viewDistance / 2)); x+=1) {
    for (int z=(centZ - (viewDistance / 2)); z <= (centZ + (viewDistance / 2)); z+=1) {
      bulk.addEntry(((TridentChunk)getWorld().chunkAt(x,z,true)).asPacket());
      ++i;
      if (i >= 30) {
        connection.sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
        i=0;
      }
    }
  }
  connection.sendPacket(bulk);
}","public void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  PacketPlayOutMapChunkBulk bulk=new PacketPlayOutMapChunkBulk();
  int i=0;
  for (int x=(centX - (int)Math.floor(viewDistance / 2)); x <= (centX + (int)Math.floor(viewDistance / 2)); x+=1) {
    for (int z=(centZ - (int)Math.floor(viewDistance / 2)); z <= (centZ + (int)Math.floor(viewDistance / 2)); z+=1) {
      bulk.addEntry(((TridentChunk)getWorld().chunkAt(x,z,true)).asPacket());
      ++i;
      if (i >= 30) {
        connection.sendPacket(bulk);
        bulk=new PacketPlayOutMapChunkBulk();
        i=0;
      }
    }
  }
  connection.sendPacket(bulk);
}"
11863,"/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return c.getX() + c.getZ() * 32;
}","/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return mod(c.getX()) + mod(c.getZ()) * 32;
}"
11864,"@Override public Tile tileAt(int relX,int y,int relZ){
  int index=WorldUtils.getBlockArrayIndex(relX,y,relZ);
  return new TridentTile(Coordinates.create(this.world,relX + this.getX() * 16,y,relZ + this.getZ() * 16),null,(byte)0);
}","@Override public Tile tileAt(int relX,int y,int relZ){
  int index=WorldUtils.getBlockArrayIndex(relX,y,relZ);
  ChunkSection section=sections[WorldUtils.getSection(y)];
  return new TridentTile(Coordinates.create(this.world,relX + this.getX() * 16,y,relZ + this.getZ() * 16),null,(byte)0);
}"
11865,"@Override public void handleReceived(ClientConnection connection){
  Window window=TridentServer.getInstance().getWindow(this.windowId);
  PlayerClickItemEvent clickEvent=new PlayerClickItemEvent(window,this.clickedSlot,(int)this.actionNumber);
  TridentServer.getInstance().getEventHandler().call(clickEvent);
  if (clickEvent.isIgnored()) {
  }
}","@Override public void handleReceived(ClientConnection connection){
  Window window=TridentServer.getInstance().windowBy(this.windowId);
  PlayerClickItemEvent clickEvent=new PlayerClickItemEvent(window,this.clickedSlot,(int)this.actionNumber);
  TridentServer.getInstance().eventHandler().call(clickEvent);
  if (clickEvent.isIgnored()) {
  }
}"
11866,"@Override public void handleReceived(ClientConnection connection){
  PlayerCloseWindowEvent event=new PlayerCloseWindowEvent(TridentServer.getInstance().getWindow(this.id));
  TridentServer.getInstance().getEventHandler().call(event);
  if (event.isIgnored()) {
  }
}","@Override public void handleReceived(ClientConnection connection){
  PlayerCloseWindowEvent event=new PlayerCloseWindowEvent(TridentServer.getInstance().windowBy(this.id));
  TridentServer.getInstance().eventHandler().call(event);
  if (event.isIgnored()) {
  }
}"
11867,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  DigStatus digStatus=DigStatus.getStatus(this.status);
  TileOrientation face=null;
switch (this.blockFace) {
case 0:
    face=TileOrientation.BOTTOM;
  break;
case 1:
face=TileOrientation.TOP;
break;
case 2:
break;
case 3:
break;
case 4:
break;
case 5:
break;
default :
TridentLogger.error(new IllegalArgumentException(""String_Node_Str""));
}
Cancellable event=null;
switch (digStatus) {
case DIG_START:
case DIG_CANCEL:
case DIG_FINISH:
event=new PlayerDigEvent(player,face,this.status);
break;
case DROP_ITEMSTACK:
event=new PlayerDropItemEvent(player,null);
break;
case DROP_ITEM:
event=new PlayerDropItemEvent(player,null);
break;
case SHOOT_ARROW:
break;
}
TridentServer.getInstance().getEventHandler().call((Event)event);
if (event == null || event.isIgnored()) return;
this.location.setWorld(player.getWorld());
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  DigStatus digStatus=DigStatus.getStatus(this.status);
  TileOrientation face=null;
switch (this.blockFace) {
case 0:
    face=TileOrientation.BOTTOM;
  break;
case 1:
face=TileOrientation.TOP;
break;
case 2:
break;
case 3:
break;
case 4:
break;
case 5:
break;
default :
TridentLogger.error(new IllegalArgumentException(""String_Node_Str""));
}
Cancellable event=null;
switch (digStatus) {
case DIG_START:
case DIG_CANCEL:
case DIG_FINISH:
event=new PlayerDigEvent(player,face,this.status);
break;
case DROP_ITEMSTACK:
event=new PlayerDropItemEvent(player,null);
break;
case DROP_ITEM:
event=new PlayerDropItemEvent(player,null);
break;
case SHOOT_ARROW:
break;
}
TridentServer.getInstance().eventHandler().call((Event)event);
if (event == null || event.isIgnored()) return;
this.location.setWorld(player.getWorld());
}"
11868,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  Coordinates from=player.getLocation();
  Coordinates to=player.getLocation();
  to.setYaw(this.newYaw);
  to.setPitch(this.newPitch);
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().getEventHandler().call(event);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  PacketPlayOutEntityLook headMove=new PacketPlayOutEntityLook();
  headMove.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",to).set(""String_Node_Str"",player.isOnGround());
  TridentPlayer.sendAll(headMove);
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  Coordinates from=player.getLocation();
  Coordinates to=player.getLocation();
  to.setYaw(this.newYaw);
  to.setPitch(this.newPitch);
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().eventHandler().call(event);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  PacketPlayOutEntityLook headMove=new PacketPlayOutEntityLook();
  headMove.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",to).set(""String_Node_Str"",player.isOnGround());
  TridentPlayer.sendAll(headMove);
}"
11869,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  this.location.setWorld(player.getWorld());
  Coordinates from=player.getLocation();
  Coordinates to=this.location;
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().getEventHandler().call(event);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  Packet move=new PacketPlayOutEntityCompleteMove();
  TridentPlayer.sendAll(move);
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  this.location.setWorld(player.getWorld());
  Coordinates from=player.getLocation();
  Coordinates to=this.location;
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().eventHandler().call(event);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  Packet move=new PacketPlayOutEntityCompleteMove();
  TridentPlayer.sendAll(move);
}"
11870,"public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=EntityBuilder.create().uuid(id).spawnLocation(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",((TridentWorld)p.getWorld()).getDimesion()).set(""String_Node_Str"",p.getWorld().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",Trident.getServer().getDifficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
      p.connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
      Slot[] slots=new Slot[44];
      slots[43]=new Slot(new Item(Substance.APPLE));
      p.sendChunks(3);
      for (      Entity entity : p.getWorld().entities()) {
      }
    }
  }
);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).asNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(id);
  }
  final TridentPlayer p=EntityBuilder.create().uuid(id).spawnLocation(TridentServer.WORLD.spawnLocation()).executor(ThreadsHandler.playerExecutor()).build(TridentPlayer.class,ParameterValue.from(CompoundTag.class,offlinePlayer),ParameterValue.from(TridentWorld.class,TridentServer.WORLD),ParameterValue.from(ClientConnection.class,connection));
  p.executor.execute(new Runnable(){
    @Override public void run(){
      p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",((TridentWorld)p.getWorld()).getDimesion()).set(""String_Node_Str"",p.getWorld().difficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
      p.connection.sendPacket(PacketPlayOutPluginMessage.VANILLA_CHANNEL);
      p.connection.sendPacket(new PacketPlayOutServerDifficulty().set(""String_Node_Str"",p.getWorld().difficulty()));
      p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
      p.connection.sendPacket(p.abilities.asPacket());
      p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getSpawnLocation()).set(""String_Node_Str"",(byte)0));
      p.connection.sendPacket(PacketPlayOutStatistics.DEFAULT_STATISTIC);
      Slot[] slots=new Slot[44];
      slots[43]=new Slot(new Item(Substance.APPLE));
      p.sendChunks(3);
      for (      Entity entity : p.getWorld().entities()) {
      }
    }
  }
);
  return p;
}"
11871,"@Override public Set<World> worlds(){
  Set<World> worlds=Sets.newHashSet();
  worlds.addAll(worldLoader.getWorlds());
  return worlds;
}","@Override public Map<String,World> worlds(){
  Map<String,World> worlds=Maps.newHashMap();
  for (  World world : worldLoader.getWorlds())   worlds.put(world.name(),world);
  return worlds;
}"
11872,"@Override public World call(){
  for (  World world : Trident.getWorlds()) {
    if (world.name().equals(""String_Node_Str""))     return world;
  }
  return null;
}","@Override public World call(){
  for (  World world : Trident.getWorlds().values()) {
    if (world.name().equals(""String_Node_Str""))     return world;
  }
  return null;
}"
11873,"public void load(CompoundTag tag){
  String id=((StringTag)tag.getTag(""String_Node_Str"")).getValue();
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=(tag.containsTag(""String_Node_Str"")) ? (StringTag)tag.getTag(""String_Node_Str"") : new StringTag(""String_Node_Str"").setValue(""String_Node_Str"");
  ByteTag dnVisible=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  ByteTag silent=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=counter.incrementAndGet();
  loc=Coordinates.create(Trident.getWorlds().iterator().next(),0,0,0);
  velocity=new Vector(0,0,0);
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  double[] location=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=pos.get(i);
    if (t instanceof DoubleTag) {
      location[i]=((DoubleTag)t).getValue();
    }
 else {
      location[i]=((IntTag)t).getValue();
    }
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  double[] velocity=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=motion.get(i);
    if (t instanceof DoubleTag) {
      velocity[i]=((DoubleTag)t).getValue();
    }
 else {
      velocity[i]=((IntTag)t).getValue();
    }
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  if (rotation.get(0) instanceof IntTag) {
    loc.setYaw(((IntTag)rotation.get(0)).getValue());
  }
 else {
    loc.setYaw(((FloatTag)rotation.get(0)).getValue());
  }
  if (rotation.get(1) instanceof IntTag) {
    loc.setPitch(((IntTag)rotation.get(1)).getValue());
  }
 else {
    loc.setPitch(((FloatTag)rotation.get(1)).getValue());
  }
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}","public void load(CompoundTag tag){
  String id=((StringTag)tag.getTag(""String_Node_Str"")).getValue();
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=(tag.containsTag(""String_Node_Str"")) ? (StringTag)tag.getTag(""String_Node_Str"") : new StringTag(""String_Node_Str"").setValue(""String_Node_Str"");
  ByteTag dnVisible=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  ByteTag silent=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=counter.incrementAndGet();
  loc=Coordinates.create(TridentServer.WORLD,0,0,0);
  velocity=new Vector(0,0,0);
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  double[] location=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=pos.get(i);
    if (t instanceof DoubleTag) {
      location[i]=((DoubleTag)t).getValue();
    }
 else {
      location[i]=((IntTag)t).getValue();
    }
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  double[] velocity=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=motion.get(i);
    if (t instanceof DoubleTag) {
      velocity[i]=((DoubleTag)t).getValue();
    }
 else {
      velocity[i]=((IntTag)t).getValue();
    }
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  if (rotation.get(0) instanceof IntTag) {
    loc.setYaw(((IntTag)rotation.get(0)).getValue());
  }
 else {
    loc.setYaw(((FloatTag)rotation.get(0)).getValue());
  }
  if (rotation.get(1) instanceof IntTag) {
    loc.setPitch(((IntTag)rotation.get(1)).getValue());
  }
 else {
    loc.setPitch(((FloatTag)rotation.get(1)).getValue());
  }
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}"
11874,"private PlayerConnection(ClientConnection connection,TridentPlayer player){
  ClientConnection.clientData.remove(connection.getAddress());
  ClientConnection.clientData.put(connection.getAddress(),new AtomicReference<ClientConnection>(this));
  super.address=connection.getAddress();
  super.channel=connection.getChannel();
  super.loginKeyPair=connection.getLoginKeyPair();
  super.sharedSecret=connection.getSharedSecret();
  super.stage=Protocol.ClientStage.PLAY;
  super.encryptionEnabled=connection.isEncryptionEnabled();
  super.compressionEnabled=connection.isCompressionEnabled();
  this.player=player;
  this.keepAliveId=-1;
}","private PlayerConnection(ClientConnection connection,TridentPlayer player){
  ClientConnection.clientData.remove(connection.getAddress());
  ClientConnection.clientData.put(connection.getAddress(),new AtomicReference<ClientConnection>(this));
  super.address=connection.getAddress();
  super.channel=connection.getChannel();
  super.loginKeyPair=connection.getLoginKeyPair();
  super.sharedSecret=connection.getSharedSecret();
  super.stage=Protocol.ClientStage.PLAY;
  super.encryptionEnabled=connection.isEncryptionEnabled();
  super.compressionEnabled=connection.isCompressionEnabled();
  this.player=player;
  this.keepAliveId=-1;
  PacketHandler handler=channel.pipeline().get(PacketHandler.class);
  if (handler != null) {
    handler.updateConnection(this);
  }
}"
11875,"public void doRun(){
  long startTime=System.currentTimeMillis();
  this.ticksElapsed.getAndIncrement();
  if (this.pausedTicking) {
    this.calcAndWait(0);
    return;
  }
  if (this.ticksToWait.get() > 0) {
    this.ticksToWait.getAndDecrement();
    this.calcAndWait(0);
    return;
  }
  this.notLostTicksElapsed.getAndIncrement();
  WorldThreads.notifyTick();
  if (this.redstoneTick) {
    WorldThreads.notifyRedstoneTick();
    this.redstoneTick=false;
  }
 else {
    this.redstoneTick=true;
  }
  this.calcAndWait((int)(System.currentTimeMillis() - startTime));
}","public void doRun(){
  long startTime=System.currentTimeMillis();
  this.ticksElapsed.getAndIncrement();
  if (this.pausedTicking) {
    this.calcAndWait(0);
    return;
  }
  if (this.ticksToWait.get() > 0) {
    this.ticksToWait.getAndDecrement();
    this.calcAndWait(0);
    return;
  }
  this.notLostTicksElapsed.getAndIncrement();
  WorldThreads.notifyTick();
  for (  TridentPlayer player : TridentPlayer.getPlayers()) {
    TaskExecutor executor=ThreadsManager.players.assign(player);
    executor.addTask(new Runnable(){
      @Override public void run(){
        player.tick();
      }
    }
);
  }
  if (this.redstoneTick) {
    WorldThreads.notifyRedstoneTick();
    this.redstoneTick=false;
  }
 else {
    this.redstoneTick=true;
  }
  this.calcAndWait((int)(System.currentTimeMillis() - startTime));
}"
11876,"private void sendCompressed(ByteBuf msg,ByteBuf out) throws IOException {
  int index=msg.readerIndex();
  int length=msg.readableBytes();
  byte[] decompressed=new byte[length];
  msg.readBytes(decompressed);
  deflater.setInput(decompressed);
  deflater.finish();
  ByteArrayOutputStream compressed=new ByteArrayOutputStream();
  int compressedLength=0;
  int readLength;
  while ((readLength=deflater.deflate(buffer)) > 0) {
    compressedLength+=readLength;
    compressed.write(buffer,0,readLength);
  }
  deflater.end();
  deflater.reset();
  if (compressedLength == 0 || compressedLength > length) {
    msg.readerIndex(index);
    sendDecompressed(msg,out);
    return;
  }
  Codec.writeVarInt32(out,compressedLength + BigInteger.valueOf(length).toByteArray().length);
  Codec.writeVarInt32(out,length);
  out.writeBytes(compressed.toByteArray());
}","private void sendCompressed(ByteBuf msg,ByteBuf out) throws IOException {
  int index=msg.readerIndex();
  int length=msg.readableBytes();
  byte[] decompressed=new byte[length];
  msg.readBytes(decompressed);
  deflater.setInput(decompressed);
  deflater.finish();
  ByteArrayOutputStream compressed=new ByteArrayOutputStream();
  int compressedLength=0;
  int readLength;
  while ((readLength=deflater.deflate(buffer)) > 0) {
    compressedLength+=readLength;
    compressed.write(buffer,0,readLength);
  }
  if (compressedLength == 0 || compressedLength > length) {
    msg.readerIndex(index);
    sendDecompressed(msg,out);
    return;
  }
  Codec.writeVarInt32(out,compressedLength + BigInteger.valueOf(length).toByteArray().length);
  Codec.writeVarInt32(out,length);
  out.writeBytes(compressed.toByteArray());
  deflater.reset();
}"
11877,"public void doRun(){
  long startTime=System.currentTimeMillis();
  this.ticksElapsed.getAndIncrement();
  if (this.pausedTicking) {
    this.calcAndWait(0);
    return;
  }
  if (this.ticksToWait.get() > 0) {
    this.ticksToWait.getAndDecrement();
    this.calcAndWait(0);
    return;
  }
  this.notLostTicksElapsed.getAndIncrement();
  WorldThreads.notifyTick();
  for (  TridentPlayer player : TridentPlayer.getPlayers()) {
    TaskExecutor executor=ThreadsManager.players.assign(player);
    executor.addTask(new Runnable(){
      @Override public void run(){
        player.tick();
      }
    }
);
  }
  if (this.redstoneTick) {
    WorldThreads.notifyRedstoneTick();
    this.redstoneTick=false;
  }
 else {
    this.redstoneTick=true;
  }
  this.calcAndWait((int)(System.currentTimeMillis() - startTime));
}","public void doRun(){
  long startTime=System.currentTimeMillis();
  this.ticksElapsed.getAndIncrement();
  if (this.pausedTicking) {
    this.calcAndWait(0);
    return;
  }
  if (this.ticksToWait.get() > 0) {
    this.ticksToWait.getAndDecrement();
    this.calcAndWait(0);
    return;
  }
  this.notLostTicksElapsed.getAndIncrement();
  WorldThreads.notifyTick();
  for (  Player player : TridentPlayer.getPlayers()) {
    TaskExecutor executor=ThreadsManager.players.assign(player);
    executor.addTask(new Runnable(){
      @Override public void run(){
        player.tick();
      }
    }
);
  }
  if (this.redstoneTick) {
    WorldThreads.notifyRedstoneTick();
    this.redstoneTick=false;
  }
 else {
    this.redstoneTick=true;
  }
  this.calcAndWait((int)(System.currentTimeMillis() - startTime));
}"
11878,"@InternalUseOnly protected TridentTile(Coordinates location,boolean createdByServer){
  this.location=location;
}","public TridentTile(Coordinates location,Substance substance,byte meta){
  this.location=location;
  this.material=substance;
  this.data=meta;
}"
11879,"/** 
 * Begin entity management
 * @return the current entity
 */
public TridentEntity spawn(){
  MANAGER.registerEntity(this);
  return this;
}","/** 
 * Begin entity management
 * @return the current entity
 */
public TridentEntity spawn(){
  if (this instanceof TridentPlayer) {
    return this;
  }
  MANAGER.registerEntity(this);
  return this;
}"
11880,"@Override public ItemStack getContent(int slot){
  return this.inventory.getContents()[slot];
}","@Override public Item getContent(int slot){
  return this.inventory.getContents()[slot];
}"
11881,"/** 
 * Inherits UUID and spawnLocation from   {@link TridentEntity}
 * @param source the entity which fired the projectile
 */
public TridentProjectile(UUID uniqueId,Coordinates spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation);
  this.source=new WeakReference<>(source);
}","/** 
 * Inherits UUID and spawnLocation from   {@link TridentEntity}
 * @param source the entity which fired the projectile
 */
public TridentProjectile(UUID uniqueId,Coordinates spawnLocation,ProjectileLauncher source){
  super(uniqueId,spawnLocation);
  this.source=new WeakReference<>(source);
}"
11882,"@Override public void setEquipment(ItemStack[] stack){
}","@Override public void setEquipment(Item[] stack){
}"
11883,"@Override public ItemStack[] getEquipment(){
  return new ItemStack[0];
}","@Override public Item[] getEquipment(){
  return new Item[0];
}"
11884,"@Override public void setEquipment(ItemStack[] stack){
  this.equipment=stack;
}","@Override public void setEquipment(Item[] stack){
  this.equipment=stack;
}"
11885,"public void applyArmorUpdate(){
  for (int i=0; i < equipment.length; i++) {
    ItemStack stack=equipment[i];
    PacketPlayOutEntityEquipment entityEquipment=new PacketPlayOutEntityEquipment();
    entityEquipment.set(""String_Node_Str"",original().getId()).set(""String_Node_Str"",(short)i + 5).set(String.valueOf(i + 5),Long.decode(Integer.toHexString(stack.getId()) + ""String_Node_Str"").longValue());
    TridentPlayer.sendAll(entityEquipment);
  }
}","public void applyArmorUpdate(){
  for (int i=0; i < equipment.length; i++) {
    Item stack=equipment[i];
    PacketPlayOutEntityEquipment entityEquipment=new PacketPlayOutEntityEquipment();
    entityEquipment.set(""String_Node_Str"",original().getId()).set(""String_Node_Str"",(short)i + 5).set(String.valueOf(i + 5),Long.decode(Integer.toHexString(stack.getId()) + ""String_Node_Str"").longValue());
    TridentPlayer.sendAll(entityEquipment);
  }
}"
11886,"@Override public ItemStack[] getEquipment(){
  return equipment;
}","@Override public Item[] getEquipment(){
  return equipment;
}"
11887,"@Override public void setSlot(int index,ItemStack value){
  itemStacks[index]=value;
}","@Override public void setSlot(int index,Item value){
  itemStacks[index]=value;
}"
11888,"protected DecoratedInventoryHolder(Entity entity,final String string,final int size,InventoryType type){
  super(entity);
  inventory=new Inventory(){
    private final int inventoryId=inventoryIds++;
    private final ItemStack[] itemStacks=new ItemStack[size];
    private final String name=string;
    @Override public int getId(){
      return inventoryId;
    }
    @Override public ItemStack[] getContents(){
      return itemStacks;
    }
    @Override public int getLength(){
      return itemStacks.length;
    }
    @Override public void setSlot(    int index,    ItemStack value){
      itemStacks[index]=value;
    }
    @Override public String getName(){
      return name;
    }
  }
;
  this.type=type;
}","protected DecoratedInventoryHolder(Entity entity,final String string,final int size,InventoryType type){
  super(entity);
  inventory=new Inventory(){
    private final int inventoryId=inventoryIds++;
    private final Item[] itemStacks=new Item[size];
    private final String name=string;
    @Override public int getId(){
      return inventoryId;
    }
    @Override public Item[] getContents(){
      return itemStacks;
    }
    @Override public int getLength(){
      return itemStacks.length;
    }
    @Override public void setSlot(    int index,    Item value){
      itemStacks[index]=value;
    }
    @Override public String getName(){
      return name;
    }
  }
;
  this.type=type;
}"
11889,"@Override public ItemStack getContent(int slot){
  return inventory.getContents()[slot];
}","@Override public Item getContent(int slot){
  return inventory.getContents()[slot];
}"
11890,"@Override public ItemStack[] getContents(){
  return itemStacks;
}","@Override public Item[] getContents(){
  return itemStacks;
}"
11891,"public void load(CompoundTag tag){
  String id=((StringTag)tag.getTag(""String_Node_Str"")).getValue();
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=tag.getTagAs(""String_Node_Str"");
  ByteTag dnVisible=tag.getTagAs(""String_Node_Str"");
  ByteTag silent=tag.getTagAs(""String_Node_Str"");
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=Integer.parseInt(id);
  if (this.id >= counter.get()) {
    counter.incrementAndGet();
  }
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  int[] location=new int[3];
  for (int i=0; i < 3; i+=1) {
    location[i]=((IntTag)pos.get(i)).getValue();
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  int[] velocity=new int[3];
  for (int i=0; i < 3; i+=1) {
    velocity[i]=((IntTag)motion.get(i)).getValue();
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  loc.setYaw(((IntTag)rotation.get(0)).getValue());
  loc.setPitch(((IntTag)rotation.get(0)).getValue());
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}","public void load(CompoundTag tag){
  String id=((StringTag)tag.getTag(""String_Node_Str"")).getValue();
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=(tag.containsTag(""String_Node_Str"")) ? (StringTag)tag.getTag(""String_Node_Str"") : new StringTag(""String_Node_Str"").setValue(""String_Node_Str"");
  ByteTag dnVisible=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  ByteTag silent=(tag.containsTag(""String_Node_Str"")) ? (ByteTag)tag.getTag(""String_Node_Str"") : new ByteTag(""String_Node_Str"").setValue((byte)0);
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=counter.incrementAndGet();
  loc=new Location(Trident.getWorlds().iterator().next(),0,0,0);
  velocity=new Vector(0,0,0);
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  double[] location=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=pos.get(i);
    if (t instanceof DoubleTag) {
      location[i]=((DoubleTag)t).getValue();
    }
 else {
      location[i]=((IntTag)t).getValue();
    }
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  double[] velocity=new double[3];
  for (int i=0; i < 3; i+=1) {
    NBTTag t=motion.get(i);
    if (t instanceof DoubleTag) {
      velocity[i]=((DoubleTag)t).getValue();
    }
 else {
      velocity[i]=((IntTag)t).getValue();
    }
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  if (rotation.get(0) instanceof IntTag) {
    loc.setYaw(((IntTag)rotation.get(0)).getValue());
  }
 else {
    loc.setYaw(((FloatTag)rotation.get(0)).getValue());
  }
  if (rotation.get(1) instanceof IntTag) {
    loc.setPitch(((IntTag)rotation.get(1)).getValue());
  }
 else {
    loc.setPitch(((FloatTag)rotation.get(1)).getValue());
  }
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}"
11892,"/** 
 * Pass in a chunk to load its data from file
 */
public TridentChunk loadChunkData(TridentWorld owner,ChunkLocation location) throws NBTException, IOException, DataFormatException {
  TridentChunk chunk=new TridentChunk(owner,location);
  short compression;
  byte[] compressedData;
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    access.seek((long)this.sectors.getTimeStampLocation(chunk));
    int lastUpdate=access.readInt();
    if (chunk.getLastFileAccess() > lastUpdate) {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
      access.close();
      return chunk;
    }
 else {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
    }
    access.seek((long)this.sectors.getDataLocation(chunk));
    int length=access.readInt();
    compression=(short)access.readByte();
    compressedData=new byte[length - 1];
    access.readFully(compressedData);
    access.close();
  }
  byte[] chunkData;
switch (compression) {
case 0:
case 1:
    GZIPInputStream in=new GZIPInputStream(new ByteArrayInputStream(compressedData));
  chunkData=new byte[in.available()];
in.read(chunkData);
in.close();
break;
case 2:
Inflater inflater=new Inflater();
inflater.setInput(compressedData);
chunkData=new byte[inflater.getRemaining()];
inflater.inflate(chunkData);
inflater.end();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
CompoundTag nbtData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(chunkData))).decode();
chunk.load(nbtData);
return chunk;
}","/** 
 * Pass in a chunk to load its data from file
 */
public TridentChunk loadChunkData(TridentWorld owner,ChunkLocation location) throws NBTException, IOException, DataFormatException {
  TridentChunk chunk=new TridentChunk(owner,location);
  short compression;
  byte[] compressedData;
synchronized (this.readWriteLock) {
    RandomAccessFile access=new RandomAccessFile(this.path.toFile(),""String_Node_Str"");
    access.seek((long)this.sectors.getTimeStampLocation(chunk));
    int lastUpdate=access.readInt();
    if (chunk.getLastFileAccess() > lastUpdate) {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
      access.close();
      return chunk;
    }
 else {
      chunk.setLastFileAccess((int)(System.currentTimeMillis() / 1000L));
    }
    access.seek((long)this.sectors.getDataLocation(chunk));
    int length=access.readInt();
    compression=(short)access.readByte();
    compressedData=new byte[length - 1];
    access.readFully(compressedData);
    access.close();
  }
  byte[] chunkData;
switch (compression) {
case 0:
case 1:
    GZIPInputStream in=new GZIPInputStream(new ByteArrayInputStream(compressedData));
  chunkData=new byte[in.available()];
in.read(chunkData);
in.close();
break;
case 2:
Inflater inflater=new Inflater();
ByteArrayOutputStream output=new ByteArrayOutputStream();
inflater.setInput(compressedData);
byte[] buffer=new byte[1024];
while (!(inflater.finished())) {
int count=inflater.inflate(buffer);
output.write(buffer,0,count);
}
output.close();
chunkData=output.toByteArray();
inflater.end();
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
CompoundTag nbtData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(chunkData))).decode();
chunk.load(nbtData);
return chunk;
}"
11893,"/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return IntMath.mod(c.getX(),32) + IntMath.mod(c.getZ(),32) * 32;
}","/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return c.getX() + c.getZ() * 32;
}"
11894,"public void load(CompoundTag tag){
  TridentLogger logger=Trident.getLogger();
  logger.info(""String_Node_Str"");
  IntTag x=tag.getTagAs(""String_Node_Str"");
  IntTag z=tag.getTagAs(""String_Node_Str"");
  LongTag lastModifed=tag.getTagAs(""String_Node_Str"");
  ByteTag lightPopulated=tag.getTagAs(""String_Node_Str"");
  ByteTag terrainPopulated=tag.getTagAs(""String_Node_Str"");
  LongTag inhabitedTime=tag.getTagAs(""String_Node_Str"");
  ByteArrayTag biomes=tag.getTagAs(""String_Node_Str"");
  ListTag sections=tag.getTagAs(""String_Node_Str"");
  ListTag entities=tag.getTagAs(""String_Node_Str"");
  ListTag tileEntities=tag.getTagAs(""String_Node_Str"");
  ListTag tileTicks=tag.getTagAs(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  List<NBTTag> sectionsList=sections.listTags();
  this.sections=new ChunkSection[sectionsList.size()];
  for (int i=0; i <= sectionsList.size(); i+=1) {
    NBTTag t=sections.getTag(i);
    if (t instanceof CompoundTag) {
      CompoundTag ct=(CompoundTag)t;
      this.sections[i]=NBTSerializer.deserialize(ChunkSection.class,ct);
      this.sections[i].loadBlocks();
    }
  }
  logger.info(""String_Node_Str"");
  FastClass entityClass=FastClass.get(TridentEntity.class);
  for (  NBTTag t : entities.listTags()) {
    TridentEntity entity=entityClass.getConstructor().newInstance();
    entity.load((CompoundTag)t);
    this.entities.add(entity);
  }
  logger.info(""String_Node_Str"");
  this.lightPopulated=lightPopulated.getValue();
  this.terrainPopulated=terrainPopulated.getValue();
  this.lastModified=lastModifed.getValue();
  this.inhabitedTime=inhabitedTime.getValue();
  logger.info(""String_Node_Str"");
}","public void load(CompoundTag root){
  CompoundTag tag=root.getTagAs(""String_Node_Str"");
  LongTag lastModifed=tag.getTagAs(""String_Node_Str"");
  ByteTag lightPopulated=tag.getTagAs(""String_Node_Str"");
  ByteTag terrainPopulated=tag.getTagAs(""String_Node_Str"");
  LongTag inhabitedTime=tag.getTagAs(""String_Node_Str"");
  IntArrayTag biomes=tag.getTagAs(""String_Node_Str"");
  ListTag sections=tag.getTagAs(""String_Node_Str"");
  ListTag entities=tag.getTagAs(""String_Node_Str"");
  ListTag tileEntities=tag.getTagAs(""String_Node_Str"");
  ListTag tileTicks=(root.containsTag(""String_Node_Str"")) ? (ListTag)tag.getTag(""String_Node_Str"") : new ListTag(""String_Node_Str"",TagType.COMPOUND);
  List<NBTTag> sectionsList=sections.listTags();
  this.sections=new ChunkSection[sectionsList.size()];
  for (int i=0; i < sectionsList.size(); i+=1) {
    NBTTag t=sections.getTag(i);
    if (t instanceof CompoundTag) {
      CompoundTag ct=(CompoundTag)t;
      this.sections[i]=NBTSerializer.deserialize(ChunkSection.class,ct);
      this.sections[i].loadBlocks(getWorld());
    }
  }
  FastClass entityClass=FastClass.get(TridentEntity.class);
  for (  NBTTag t : entities.listTags()) {
    TridentEntity entity=entityClass.getConstructor().newInstance();
    entity.load((CompoundTag)t);
    this.entities.add(entity);
  }
  this.lightPopulated=lightPopulated.getValue();
  this.terrainPopulated=terrainPopulated.getValue();
  this.lastModified=lastModifed.getValue();
  this.inhabitedTime=inhabitedTime.getValue();
}"
11895,"public void write(PacketPlayOutChunkData packet){
  packet.set(""String_Node_Str"",location);
  int bitmask;
  int count;
  bitmask=(1 << sections.length) - 1;
  count=sections.length;
  int size=0;
  int sectionSize=ChunkSection.LENGTH * 5 / 2;
  if (world.getDimension() == Dimension.OVERWORLD) {
    sectionSize+=ChunkSection.LENGTH / 2;
  }
  size+=count * sectionSize + 256;
  byte[] data=new byte[size];
  int pos=0;
  for (  ChunkSection section : sections) {
    for (    byte b : section.getTypes()) {
      data[pos++]=(byte)(b & 0xff);
      data[pos++]=(byte)(b >> 8);
    }
  }
  for (  ChunkSection section : sections) {
    System.arraycopy(section.blockLight,0,data,pos,section.blockLight.length);
    pos+=section.blockLight.length;
  }
  for (  ChunkSection section : sections) {
    System.arraycopy(section.skyLight,0,data,pos,section.skyLight.length);
    pos+=section.skyLight.length;
  }
  for (int i=0; i < 256; i+=1) {
    data[pos++]=0;
  }
  if (pos != size) {
    throw new IllegalStateException(""String_Node_Str"" + pos + ""String_Node_Str""+ size+ ""String_Node_Str"");
  }
  packet.set(""String_Node_Str"",data);
  packet.set(""String_Node_Str"",true);
  packet.set(""String_Node_Str"",bitmask);
}","public void write(PacketPlayOutChunkData packet){
  packet.set(""String_Node_Str"",location);
  int bitmask;
  int count;
  bitmask=(1 << sections.length) - 1;
  count=sections.length;
  int size=0;
  int sectionSize=ChunkSection.LENGTH * 5 / 2;
  if (world.getDimension() == Dimension.OVERWORLD) {
    sectionSize+=ChunkSection.LENGTH / 2;
  }
  size+=count * sectionSize + 256;
  System.out.println(size);
  byte[] data=new byte[size];
  int pos=0;
  for (  ChunkSection section : sections) {
    for (    byte b : section.getTypes()) {
      data[pos++]=(byte)(b & 0xff);
      data[pos++]=(byte)(b >> 8);
    }
  }
  for (  ChunkSection section : sections) {
    System.arraycopy(section.blockLight,0,data,pos,section.blockLight.length);
    pos+=section.blockLight.length;
  }
  for (int i=0; i < 256; i+=1) {
    data[pos++]=0;
  }
  if (pos != size) {
    throw new IllegalStateException(""String_Node_Str"" + pos + ""String_Node_Str""+ size+ ""String_Node_Str"");
  }
  packet.set(""String_Node_Str"",data);
  packet.set(""String_Node_Str"",true);
  packet.set(""String_Node_Str"",(short)bitmask);
}"
11896,"@Override public void handleReceived(ClientConnection connection){
  Window window=TridentServer.getInstance().getWindow(this.windowId);
  PlayerClickItemEvent clickEvent=new PlayerClickItemEvent(window,this.clickedSlot,(int)this.actionNumber);
  TridentServer.getInstance().getEventManager().call(clickEvent);
  if (clickEvent.isCancelled()) {
  }
}","@Override public void handleReceived(ClientConnection connection){
  Window window=TridentServer.getInstance().getWindow(this.windowId);
  PlayerClickItemEvent clickEvent=new PlayerClickItemEvent(window,this.clickedSlot,(int)this.actionNumber);
  TridentServer.getInstance().getEventManager().call(clickEvent);
  if (clickEvent.isIgnored()) {
  }
}"
11897,"@Override public void handleReceived(ClientConnection connection){
  PlayerCloseWindowEvent event=new PlayerCloseWindowEvent(TridentServer.getInstance().getWindow(this.id));
  TridentServer.getInstance().getEventManager().call(event);
  if (event.isCancelled()) {
  }
}","@Override public void handleReceived(ClientConnection connection){
  PlayerCloseWindowEvent event=new PlayerCloseWindowEvent(TridentServer.getInstance().getWindow(this.id));
  TridentServer.getInstance().getEventManager().call(event);
  if (event.isIgnored()) {
  }
}"
11898,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  Location from=player.getLocation();
  Location to=player.getLocation();
  to.setYaw(this.newYaw);
  to.setPitch(this.newPitch);
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().getEventManager().call(event);
  if (event.isCancelled()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  PacketPlayOutEntityLook headMove=new PacketPlayOutEntityLook();
  headMove.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",to).set(""String_Node_Str"",player.isOnGround());
  TridentPlayer.sendAll(headMove);
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  Location from=player.getLocation();
  Location to=player.getLocation();
  to.setYaw(this.newYaw);
  to.setPitch(this.newPitch);
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().getEventManager().call(event);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  PacketPlayOutEntityLook headMove=new PacketPlayOutEntityLook();
  headMove.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",to).set(""String_Node_Str"",player.isOnGround());
  TridentPlayer.sendAll(headMove);
}"
11899,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  this.location.setWorld(player.getWorld());
  Location from=player.getLocation();
  Location to=this.location;
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().getEventManager().call(event);
  if (event.isCancelled()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  Packet move=new PacketPlayOutEntityCompleteMove();
  TridentPlayer.sendAll(move);
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  this.location.setWorld(player.getWorld());
  Location from=player.getLocation();
  Location to=this.location;
  PlayerMoveEvent event=new PlayerMoveEvent(player,from,to);
  TridentServer.getInstance().getEventManager().call(event);
  if (event.isIgnored()) {
    PacketPlayOutEntityTeleport cancel=new PacketPlayOutEntityTeleport();
    cancel.set(""String_Node_Str"",player.getId()).set(""String_Node_Str"",from).set(""String_Node_Str"",player.isOnGround());
    TridentPlayer.sendAll(cancel);
    return;
  }
  player.setLocation(to);
  Packet move=new PacketPlayOutEntityCompleteMove();
  TridentPlayer.sendAll(move);
}"
11900,"public void load(CompoundTag tag){
  StringTag id=tag.getTagAs(""String_Node_Str"");
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=tag.getTagAs(""String_Node_Str"");
  ByteTag dnVisible=tag.getTagAs(""String_Node_Str"");
  ByteTag silent=tag.getTagAs(""String_Node_Str"");
  CompoundTag riding=tag.getTagAs(""String_Node_Str"");
  CompoundTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=Integer.parseInt(id.getValue());
  if (this.id >= counter.get()) {
    counter.incrementAndGet();
  }
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  int[] location=new int[3];
  for (int i=0; i < 3; i+=1) {
    location[i]=((IntTag)pos.get(i)).getValue();
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  int[] velocity=new int[3];
  for (int i=0; i < 3; i+=1) {
    velocity[i]=((IntTag)motion.get(i)).getValue();
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  loc.setYaw(((IntTag)rotation.get(0)).getValue());
  loc.setPitch(((IntTag)rotation.get(0)).getValue());
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}","public void load(CompoundTag tag){
  String id=((StringTag)tag.getTag(""String_Node_Str"")).getValue();
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=tag.getTagAs(""String_Node_Str"");
  ByteTag dnVisible=tag.getTagAs(""String_Node_Str"");
  ByteTag silent=tag.getTagAs(""String_Node_Str"");
  NBTTag riding=tag.getTagAs(""String_Node_Str"");
  NBTTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=Integer.parseInt(id);
  if (this.id >= counter.get()) {
    counter.incrementAndGet();
  }
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  int[] location=new int[3];
  for (int i=0; i < 3; i+=1) {
    location[i]=((IntTag)pos.get(i)).getValue();
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  int[] velocity=new int[3];
  for (int i=0; i < 3; i+=1) {
    velocity[i]=((IntTag)motion.get(i)).getValue();
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  loc.setYaw(((IntTag)rotation.get(0)).getValue());
  loc.setPitch(((IntTag)rotation.get(0)).getValue());
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}"
11901,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  World world=player.getWorld();
  StatusType type=StatusType.getStatus((int)this.actionId);
switch (type) {
case RESPAWN:
    PacketPlayOutPlayerRespawn respawn=new PacketPlayOutPlayerRespawn();
  respawn.set(""String_Node_Str"",(int)world.getDimesion().toByte()).set(""String_Node_Str"",(int)world.getDifficulty().toByte()).set(""String_Node_Str"",(int)world.getDefaultGamemode().toByte());
connection.sendPacket(respawn);
break;
case STATISTICS_REQUEST:
PacketPlayOutStatistics statistics=new PacketPlayOutStatistics();
statistics.set(""String_Node_Str"",null);
connection.sendPacket(statistics);
break;
case OPEN_INVENTORY_ACHEIVEMENT:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  World world=player.getWorld();
  StatusType type=StatusType.getStatus((int)this.actionId);
switch (type) {
case RESPAWN:
    PacketPlayOutPlayerRespawn respawn=new PacketPlayOutPlayerRespawn();
  respawn.set(""String_Node_Str"",(int)((TridentWorld)world).getDimesion().toByte()).set(""String_Node_Str"",(int)world.getDifficulty().toByte()).set(""String_Node_Str"",(int)world.getDefaultGamemode().toByte());
connection.sendPacket(respawn);
break;
case STATISTICS_REQUEST:
PacketPlayOutStatistics statistics=new PacketPlayOutStatistics();
statistics.set(""String_Node_Str"",null);
connection.sendPacket(statistics);
break;
case OPEN_INVENTORY_ACHEIVEMENT:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}"
11902,"public CompoundTag toNbt(){
  CompoundTag tag=new CompoundTag(getUniqueId().toString());
  tag.addTag(new IntTag(""String_Node_Str"").setValue(dimesion.toByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(gameMode.toByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(score));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(selectedSlot));
  tag.addTag(NBTSerializer.serialize(new Slot(getItemInHand())));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getX()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getY()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getZ()));
  tag.addTag(new ShortTag(""String_Node_Str"").setValue(hunger));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(exhaustion));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(saturation));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(foodTickTimer));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpLevel));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(xpPercent));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpTotal));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpSeed));
  ListTag inventoryTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  for (  ItemStack is : inventory.getContents()) {
    inventoryTag.addTag(NBTSerializer.serialize(new Slot(is)));
  }
  tag.addTag(inventoryTag);
  ListTag enderTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  for (  ItemStack is : enderChest.getContents()) {
    enderTag.addTag(NBTSerializer.serialize(new Slot(is)));
  }
  tag.addTag(enderTag);
  tag.addTag(NBTSerializer.serialize(abilities,""String_Node_Str""));
  return tag;
}","public CompoundTag toNbt(){
  CompoundTag tag=new CompoundTag(getUniqueId().toString());
  tag.addTag(new IntTag(""String_Node_Str"").setValue(dimesion.toByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(gameMode.toByte()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(score));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(selectedSlot));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getX()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getY()));
  tag.addTag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getZ()));
  tag.addTag(new ShortTag(""String_Node_Str"").setValue(hunger));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(exhaustion));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(saturation));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(foodTickTimer));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpLevel));
  tag.addTag(new FloatTag(""String_Node_Str"").setValue(xpPercent));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpTotal));
  tag.addTag(new IntTag(""String_Node_Str"").setValue(xpSeed));
  ListTag inventoryTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  tag.addTag(inventoryTag);
  ListTag enderTag=new ListTag(""String_Node_Str"",TagType.COMPOUND);
  tag.addTag(enderTag);
  tag.addTag(NBTSerializer.serialize(abilities,""String_Node_Str""));
  return tag;
}"
11903,"public static OfflinePlayer generatePlayer(String name,UUID id){
  World defaultWorld=Trident.getServer().getWorlds().iterator().next();
  Location spawnLocation=defaultWorld.getSpawnLocation();
  CompoundTagBuilder<NBTBuilder> builder=TridentFactory.createNbtBuilder(""String_Node_Str"");
  builder.stringTag(""String_Node_Str"",String.valueOf(counter.get() + 1));
  builder.longTag(""String_Node_Str"",id.getMostSignificantBits());
  builder.longTag(""String_Node_Str"",id.getLeastSignificantBits());
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> pos=builder.beginListTag(""String_Node_Str"",TagType.INT);
  pos.tag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getX()));
  pos.tag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getY()));
  pos.tag(new IntTag(""String_Node_Str"").setValue((int)spawnLocation.getZ()));
  builder=pos.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> motion=builder.beginListTag(""String_Node_Str"",TagType.INT);
  motion.tag(new IntTag(""String_Node_Str"").setValue(0));
  motion.tag(new IntTag(""String_Node_Str"").setValue(0));
  motion.tag(new IntTag(""String_Node_Str"").setValue(0));
  builder=motion.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> rotation=builder.beginListTag(""String_Node_Str"",TagType.INT);
  rotation.tag(new IntTag(""String_Node_Str"").setValue(0));
  rotation.tag(new IntTag(""String_Node_Str"").setValue(0));
  builder=rotation.endListTag();
  builder.floatTag(""String_Node_Str"",0);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.byteTag(""String_Node_Str"",(byte)1);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.stringTag(""String_Node_Str"",""String_Node_Str"");
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.toByte());
  builder.intTag(""String_Node_Str"",GameMode.SURVIVAL.toByte());
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",20);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.compoundTag(NBTSerializer.serialize(new PlayerAbilities(),""String_Node_Str""));
  OfflinePlayer generatedPlayer=new OfflinePlayer(builder.endCompoundTag().build(),(TridentWorld)defaultWorld);
  generatedPlayer.name=name;
  return generatedPlayer;
}","public static CompoundTag generatePlayer(String name,UUID id){
  World defaultWorld=Trident.getServer().getWorlds().iterator().next();
  Location spawnLocation=defaultWorld.getSpawnLocation();
  CompoundTagBuilder<NBTBuilder> builder=TridentFactory.createNbtBuilder(""String_Node_Str"");
  builder.stringTag(""String_Node_Str"",String.valueOf(counter.incrementAndGet()));
  builder.longTag(""String_Node_Str"",id.getMostSignificantBits());
  builder.longTag(""String_Node_Str"",id.getLeastSignificantBits());
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> pos=builder.beginListTag(""String_Node_Str"",TagType.INT);
  pos.tag((int)spawnLocation.getX());
  pos.tag((int)spawnLocation.getY());
  pos.tag((int)spawnLocation.getZ());
  builder=pos.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> motion=builder.beginListTag(""String_Node_Str"",TagType.INT);
  motion.tag(0);
  motion.tag(0);
  motion.tag(0);
  builder=motion.endListTag();
  ListTagBuilder<CompoundTagBuilder<NBTBuilder>> rotation=builder.beginListTag(""String_Node_Str"",TagType.INT);
  rotation.tag(0);
  rotation.tag(0);
  builder=rotation.endListTag();
  builder.floatTag(""String_Node_Str"",0);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.shortTag(""String_Node_Str"",(short)0);
  builder.byteTag(""String_Node_Str"",(byte)1);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.toByte());
  builder.intTag(""String_Node_Str"",900);
  builder.stringTag(""String_Node_Str"",""String_Node_Str"");
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.byteTag(""String_Node_Str"",(byte)0);
  builder.compoundTag(new CompoundTag(""String_Node_Str""));
  builder.intTag(""String_Node_Str"",Dimension.OVERWORLD.toByte());
  builder.intTag(""String_Node_Str"",GameMode.SURVIVAL.toByte());
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",20);
  builder.floatTag(""String_Node_Str"",0F);
  builder.floatTag(""String_Node_Str"",0F);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.intTag(""String_Node_Str"",0);
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.listTag(new ListTag(""String_Node_Str"",TagType.COMPOUND));
  builder.intTag(""String_Node_Str"",0);
  builder.compoundTag(NBTSerializer.serialize(new PlayerAbilities(),""String_Node_Str""));
  return builder.endCompoundTag().build();
}"
11904,"public static Player spawnPlayer(ClientConnection connection,UUID id,String name){
  OfflinePlayer offlinePlayer=OfflinePlayer.getOfflinePlayer(id);
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(name,id);
  }
  TridentPlayer p=new TridentPlayer(offlinePlayer.toNbt(),(TridentWorld)offlinePlayer.getWorld(),connection);
  p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().getDimesion()).set(""String_Node_Str"",p.getWorld().getDifficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
  p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
  p.connection.sendPacket(p.abilities.toPacket());
  p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getLocation()).set(""String_Node_Str"",(byte)0));
  p.sendChunks(7);
  players.add(p);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id,String name){
  CompoundTag offlinePlayer=(OfflinePlayer.getOfflinePlayer(id) == null) ? null : OfflinePlayer.getOfflinePlayer(id).toNbt();
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(name,id);
  }
  TridentPlayer p=new TridentPlayer(offlinePlayer,(TridentWorld)Trident.getWorlds().iterator().next(),connection);
  p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",((TridentWorld)p.getWorld()).getDimesion()).set(""String_Node_Str"",p.getWorld().getDifficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
  p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
  p.connection.sendPacket(p.abilities.toPacket());
  p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getLocation()).set(""String_Node_Str"",(byte)0));
  p.sendChunks(7);
  players.add(p);
  return p;
}"
11905,"private void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  for (int x=(centX - viewDistance); x <= (centX + viewDistance); x+=1) {
    for (int z=(centZ - viewDistance); z <= (centZ + viewDistance); z+=1) {
      PacketPlayOutChunkData packet=new PacketPlayOutChunkData();
      ((TridentChunk)getWorld().getChunkAt(x,z,false)).write(packet);
      connection.sendPacket(packet);
    }
  }
}","private void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  for (int x=(centX - viewDistance); x <= (centX + viewDistance); x+=1) {
    for (int z=(centZ - viewDistance); z <= (centZ + viewDistance); z+=1) {
      PacketPlayOutChunkData packet=new PacketPlayOutChunkData();
      ((TridentChunk)getWorld().getChunkAt(x,z,true)).write(packet);
      connection.sendPacket(packet);
    }
  }
}"
11906,"/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return IntMath.mod(c.getX(),32) + IntMath.mod(c.getX(),32) * 32;
}","/** 
 * Gets the location of the raw offset of the chunk
 * @param c chunk
 * @return offsetLoc in bytes
 */
private int getOffsetLoc(Chunk c){
  return IntMath.mod(c.getX(),32) + IntMath.mod(c.getZ(),32) * 32;
}"
11907,"@Override public Dimension getDimesion(){
  return dimension;
}","public Dimension getDimesion(){
  return dimension;
}"
11908,"@Override public boolean accept(File file,String s){
  String[] strings=s.split(""String_Node_Str"");
  return s.endsWith(""String_Node_Str"") && s.length() == 3 && strings[0].equals(""String_Node_Str"") && StringUtil.isNumeric(strings[1]) && StringUtil.isNumeric(strings[2]);
}","@Override public boolean accept(File file,String s){
  String[] strings=s.split(""String_Node_Str"");
  return s.endsWith(""String_Node_Str"") && strings.length == 4 && strings[0].equals(""String_Node_Str"");
}"
11909,"TridentWorld(String name,WorldLoader loader){
  this.name=name;
  this.loader=loader;
  this.random=new Random();
  spawnLocation=new Location(this,0d,0d,0d);
  Logger logger=LoggerFactory.getLogger(TridentServer.class);
  logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  try {
    InputStream fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    return;
  }
catch (  Exception ex) {
    logger.info(""String_Node_Str"");
    ex.printStackTrace();
    return;
  }
  logger.info(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.NORMAL;
  defaultGamemode=GameMode.getGameMode(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.getLevelType(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  logger.info(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  for (  File file : region.listFiles(new ChunkFilter())) {
    String[] strings=file.getName().split(""String_Node_Str"");
    int chunkX=(int)Math.floor(Integer.parseInt(strings[1]) * 32);
    int chunkZ=(int)Math.floor(Integer.parseInt(strings[2]) * 32);
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    RegionFile regionFile;
    try {
      regionFile=new RegionFile(file.toPath());
    }
 catch (    IOException ex) {
      logger.info(""String_Node_Str"");
      ex.printStackTrace();
      continue;
    }
    ChunkLocation location=new ChunkLocation(chunkX,chunkZ);
    TridentChunk chunk;
    try {
      chunk=regionFile.loadChunkData(this,location);
    }
 catch (    NBTException|IOException|DataFormatException e) {
      logger.info(""String_Node_Str"");
      e.printStackTrace();
      continue;
    }
    loadedChunks.put(location,chunk);
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
  logger.info(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    logger.info(""String_Node_Str"");
    playerData.mkdir();
  }
 else {
    logger.info(""String_Node_Str"");
    for (    File f : playerData.listFiles(new PlayerFilter())) {
      CompoundTag opData;
      try {
        InputStream fis=new FileInputStream(levelFile);
        byte[] compressedData=new byte[fis.available()];
        fis.read(compressedData);
        opData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode();
      }
 catch (      IOException|NBTException ex) {
        logger.info(""String_Node_Str"" + f.getName() + ""String_Node_Str"");
        ex.printStackTrace();
        continue;
      }
      new OfflinePlayer(opData,this);
    }
    logger.info(""String_Node_Str"");
  }
}","TridentWorld(String name,WorldLoader loader){
  this.name=name;
  this.loader=loader;
  this.random=new Random();
  spawnLocation=new Location(this,0d,0d,0d);
  Logger logger=LoggerFactory.getLogger(TridentServer.class);
  logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  try {
    InputStream fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    return;
  }
catch (  Exception ex) {
    logger.info(""String_Node_Str"");
    ex.printStackTrace();
    return;
  }
  logger.info(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.NORMAL;
  defaultGamemode=GameMode.getGameMode(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.getLevelType(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  logger.info(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  logger.info(""String_Node_Str"");
  File playerData=new File(directory,""String_Node_Str"");
  if (!(playerData.exists()) || !(playerData.isDirectory())) {
    logger.info(""String_Node_Str"");
    playerData.mkdir();
  }
 else {
    logger.info(""String_Node_Str"");
    for (    File f : playerData.listFiles(new PlayerFilter())) {
      CompoundTag opData;
      try {
        InputStream fis=new FileInputStream(levelFile);
        byte[] compressedData=new byte[fis.available()];
        fis.read(compressedData);
        opData=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(ByteStreams.toByteArray(new GZIPInputStream(new ByteArrayInputStream(compressedData)))))).decode();
      }
 catch (      IOException|NBTException ex) {
        logger.info(""String_Node_Str"" + f.getName() + ""String_Node_Str"");
        ex.printStackTrace();
        continue;
      }
      new OfflinePlayer(opData,this);
    }
    logger.info(""String_Node_Str"");
  }
}"
11910,"@Override public void handleReceived(ClientConnection connection){
  byte[] sharedSecret=null;
  byte[] token=null;
  try {
    sharedSecret=RSA.decrypt(this.encryptedSecret,connection.getLoginKeyPair().getPrivate());
    token=RSA.decrypt(this.encryptedToken,connection.getLoginKeyPair().getPrivate());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (!Arrays.equals(connection.getVerificationToken(),token)) {
    System.out.println(""String_Node_Str"" + connection.getAddress().getHostName() + ""String_Node_Str"");
    connection.logout();
    return;
  }
  String name=LoginManager.getInstance().getName(connection.getAddress());
  StringBuilder sb=new StringBuilder();
  try {
    URL url=new URL(""String_Node_Str"" + URLEncoder.encode(name,""String_Node_Str"") + ""String_Node_Str""+ new BigInteger(HashGenerator.getHash(connection,sharedSecret)).toString(16));
    HttpsURLConnection c=(HttpsURLConnection)url.openConnection();
    int code=c.getResponseCode();
    if (code != 200) {
      connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
      connection.logout();
      return;
    }
    BufferedReader reader=new BufferedReader(new InputStreamReader(c.getInputStream()));
    String line;
    while ((line=reader.readLine()) != null) {
      sb.append(line);
      sb.append('\n');
    }
    reader.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    connection.logout();
    return;
  }
  connection.enableEncryption(sharedSecret);
  SessionResponse response=GSON.fromJson(sb.toString(),SessionResponse.class);
  PacketLoginOutSuccess packet=new PacketLoginOutSuccess();
  packet.set(""String_Node_Str"",idDash.matcher(response.id).replaceAll(""String_Node_Str""));
  packet.set(""String_Node_Str"",response.name);
  connection.sendPacket(packet);
  connection.setStage(Protocol.ClientStage.PLAY);
  UUID id=UUID.fromString(packet.getUuid());
  LoginManager.getInstance().finish(connection.getAddress());
  TridentPlayer.spawnPlayer(connection,id,name);
}","@Override public void handleReceived(ClientConnection connection){
  byte[] sharedSecret=null;
  byte[] token=null;
  try {
    sharedSecret=RSA.decrypt(this.encryptedSecret,connection.getLoginKeyPair().getPrivate());
    token=RSA.decrypt(this.encryptedToken,connection.getLoginKeyPair().getPrivate());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (!Arrays.equals(connection.getVerificationToken(),token)) {
    System.out.println(""String_Node_Str"" + connection.getAddress().getHostName() + ""String_Node_Str"");
    connection.logout();
    return;
  }
  String name=LoginManager.getInstance().getName(connection.getAddress());
  StringBuilder sb=new StringBuilder();
  try {
    URL url=new URL(""String_Node_Str"" + URLEncoder.encode(name,""String_Node_Str"") + ""String_Node_Str""+ new BigInteger(HashGenerator.getHash(connection,sharedSecret)).toString(16));
    HttpsURLConnection c=(HttpsURLConnection)url.openConnection();
    int code=c.getResponseCode();
    if (code != 200) {
      connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
      connection.logout();
      return;
    }
    BufferedReader reader=new BufferedReader(new InputStreamReader(c.getInputStream()));
    String line;
    while ((line=reader.readLine()) != null) {
      sb.append(line);
      sb.append('\n');
    }
    reader.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    connection.logout();
    return;
  }
  connection.enableEncryption(sharedSecret);
  SessionResponse response=GSON.fromJson(sb.toString(),SessionResponse.class);
  PacketLoginOutSuccess packet=new PacketLoginOutSuccess();
  packet.set(""String_Node_Str"",idDash.matcher(response.id).replaceAll(""String_Node_Str""));
  packet.set(""String_Node_Str"",response.name);
  connection.sendPacket(packet);
  connection.enableCompression();
  connection.setStage(Protocol.ClientStage.PLAY);
  UUID id=UUID.fromString(packet.getUuid());
  LoginManager.getInstance().finish(connection.getAddress());
  TridentPlayer.spawnPlayer(connection,id,name);
}"
11911,"@Override public void handleReceived(ClientConnection connection){
  LoginManager.getInstance().initLogin(connection.getAddress(),this.getName());
  PacketLoginOutEncryptionRequest p=new PacketLoginOutEncryptionRequest();
  connection.generateToken();
  p.set(""String_Node_Str"",connection.getVerificationToken());
  try {
    KeyPair pair=RSA.generate(1024);
    p.set(""String_Node_Str"",pair.getPublic().getEncoded());
    connection.setLoginKeyPair(pair);
  }
 catch (  NoSuchAlgorithmException ignored) {
  }
  connection.enableCompression();
  connection.sendPacket(p);
}","@Override public void handleReceived(ClientConnection connection){
  LoginManager.getInstance().initLogin(connection.getAddress(),this.getName());
  PacketLoginOutEncryptionRequest p=new PacketLoginOutEncryptionRequest();
  connection.generateToken();
  p.set(""String_Node_Str"",connection.getVerificationToken());
  try {
    KeyPair pair=RSA.generate(1024);
    p.set(""String_Node_Str"",pair.getPublic().getEncoded());
    connection.setLoginKeyPair(pair);
  }
 catch (  NoSuchAlgorithmException ignored) {
  }
  connection.sendPacket(p);
}"
11912,"private void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  System.out.println(""String_Node_Str"" + centX + ""String_Node_Str""+ centZ);
  for (int x=(centX - viewDistance); x <= (centX + viewDistance); x+=1) {
    for (int z=(centZ - viewDistance); z <= (centZ + viewDistance); z+=1) {
      System.out.println(x + ""String_Node_Str"" + z);
      connection.sendPacket(((TridentChunk)getWorld().getChunkAt(x,z,true)).toPacket());
    }
  }
}","private void sendChunks(int viewDistance){
  int centX=((int)Math.floor(loc.getX())) >> 4;
  int centZ=((int)Math.floor(loc.getZ())) >> 4;
  for (int x=(centX - viewDistance); x <= (centX + viewDistance); x+=1) {
    for (int z=(centZ - viewDistance); z <= (centZ + viewDistance); z+=1) {
      connection.sendPacket(((TridentChunk)getWorld().getChunkAt(x,z,true)).toPacket());
    }
  }
}"
11913,"@Override protected void decode(ChannelHandlerContext context,ByteBuf buf,List<Object> objects) throws Exception {
  boolean compressed=connection.isCompressionEnabled();
  if (compressed)   Codec.readVarInt32(buf);
  this.rawLength=Codec.readVarInt32(buf);
  if (!(compressed) || rawLength < TridentServer.getInstance().getCompressionThreshold()) {
    ByteBuf data=buf.readBytes(this.rawLength);
    objects.add(new PacketData(data));
    return;
  }
  byte[] compressedData=new byte[buf.readableBytes()];
  byte[] decompressed=new byte[rawLength];
  buf.readBytes(compressedData);
  inflater.setInput(compressedData);
  inflater.inflate(decompressed);
  objects.add(new PacketData(Unpooled.wrappedBuffer(decompressed)));
  inflater.reset();
}","@Override protected void decode(ChannelHandlerContext context,ByteBuf buf,List<Object> objects) throws Exception {
  boolean compressed=connection.isCompressionEnabled();
  this.rawLength=Codec.readVarInt32(buf);
  if (!(compressed) || rawLength < TridentServer.getInstance().getCompressionThreshold()) {
    ByteBuf data=buf.readBytes(this.rawLength);
    objects.add(new PacketData(data));
    return;
  }
  byte[] compressedData=new byte[buf.readableBytes()];
  byte[] decompressed=new byte[rawLength];
  buf.readBytes(compressedData);
  inflater.setInput(compressedData);
  inflater.inflate(decompressed);
  objects.add(new PacketData(Unpooled.wrappedBuffer(decompressed)));
  inflater.reset();
}"
11914,"@Override protected void encode(ChannelHandlerContext channelHandlerContext,ByteBuf msg,ByteBuf out) throws Exception {
  boolean underThreshold=msg.readableBytes() < TridentServer.getInstance().getCompressionThreshold();
  if (underThreshold && connection.isCompressionEnabled()) {
    sendUncompressed(msg,out);
  }
 else   if (!(underThreshold) && connection.isCompressionEnabled()) {
    sendCompressed(msg,out);
  }
 else {
    Codec.writeVarInt32(out,msg.readableBytes());
    out.writeBytes(msg);
  }
}","@Override protected void encode(ChannelHandlerContext channelHandlerContext,ByteBuf msg,ByteBuf out) throws Exception {
  boolean underThreshold=msg.readableBytes() < TridentServer.getInstance().getCompressionThreshold();
  if (underThreshold && connection.isCompressionEnabled()) {
    sendDecompressed(msg,out);
  }
 else   if (!(underThreshold) && connection.isCompressionEnabled()) {
    sendCompressed(msg,out);
  }
 else {
    Codec.writeVarInt32(out,msg.readableBytes());
    out.writeBytes(msg);
  }
}"
11915,"private void sendCompressed(ByteBuf msg,ByteBuf out){
  int index=msg.readerIndex();
  int length=msg.readableBytes();
  byte[] decompressed=new byte[length];
  msg.readBytes(decompressed);
  deflater.setInput(decompressed);
  deflater.finish();
  ByteBuf compressed=Unpooled.buffer();
  int compressedLength=0;
  while (!(deflater.finished())) {
    int readLength=deflater.deflate(buffer);
    compressedLength+=readLength;
    compressed.writeBytes(buffer);
  }
  if (compressedLength == 0 || compressedLength >= length) {
    Codec.writeVarInt32(out,0);
    msg.readerIndex(index);
    out.writeBytes(msg);
    return;
  }
  Codec.writeVarInt32(out,compressedLength + BigInteger.valueOf(length).toByteArray().length);
  Codec.writeVarInt32(out,length);
  msg.writeBytes(compressed);
}","private void sendCompressed(ByteBuf msg,ByteBuf out){
  int index=msg.readerIndex();
  int length=msg.readableBytes();
  byte[] decompressed=new byte[length];
  msg.readBytes(decompressed);
  deflater.setInput(decompressed);
  deflater.finish();
  ByteBuf compressed=Unpooled.buffer();
  int compressedLength=0;
  int readLength;
  while ((readLength=deflater.deflate(buffer)) > 0) {
    compressedLength+=readLength;
    compressed.writeBytes(buffer,0,readLength);
  }
  deflater.reset();
  System.out.println(""String_Node_Str"" + compressedLength + ""String_Node_Str""+ length);
  if (compressedLength == 0 || compressedLength > length) {
    msg.readerIndex(index);
    sendDecompressed(msg,out);
    return;
  }
  Codec.writeVarInt32(out,compressedLength + BigInteger.valueOf(length).toByteArray().length);
  Codec.writeVarInt32(out,length);
  out.writeBytes(compressed);
}"
11916,"TridentWorld(String name,WorldLoader loader){
  this.name=name;
  this.loader=loader;
  this.random=new Random();
  spawnLocation=new Location(this,0d,0d,0d);
  TridentLogger logger=Trident.getLogger();
  logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  try {
    level=new NBTDecoder(new DataInputStream(new FileInputStream(levelFile))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    return;
  }
catch (  NBTException ex) {
    logger.info(""String_Node_Str"");
    ex.printStackTrace();
    return;
  }
  logger.info(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.getDifficulty(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  defaultGamemode=GameMode.getGameMode(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.getLevelType(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  logger.info(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  for (  File file : region.listFiles()) {
    String[] strings=file.getName().split(""String_Node_Str"");
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    if (strings.length != 3 && !(strings[0].equals(""String_Node_Str"")) && !(file.getName().endsWith(""String_Node_Str""))) {
      continue;
    }
    int chunkX;
    int chunkZ;
    try {
      chunkX=(int)Math.floor(Integer.parseInt(strings[1]) * 32);
      chunkZ=(int)Math.floor(Integer.parseInt(strings[2]) * 32);
    }
 catch (    NumberFormatException ex) {
      continue;
    }
    for (    ChunkLocation loc : loadedChunks.keySet()) {
      if (loc.getX() == chunkX && loc.getZ() == chunkZ)       continue;
    }
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    RegionFile regionFile;
    try {
      regionFile=new RegionFile(file.toPath());
    }
 catch (    IOException ex) {
      logger.info(""String_Node_Str"");
      ex.printStackTrace();
      continue;
    }
    ChunkLocation location=new ChunkLocation(chunkX,chunkZ);
    TridentChunk chunk;
    try {
      chunk=regionFile.loadChunkData(this);
    }
 catch (    NBTException|IOException|DataFormatException e) {
      logger.info(""String_Node_Str"");
      e.printStackTrace();
      continue;
    }
    loadedChunks.put(location,chunk);
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
}","TridentWorld(String name,WorldLoader loader){
  this.name=name;
  this.loader=loader;
  this.random=new Random();
  spawnLocation=new Location(this,0d,0d,0d);
  Logger logger=LoggerFactory.getLogger(TridentServer.class);
  logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  try {
    InputStream fis=new FileInputStream(levelFile);
    byte[] compressedData=new byte[fis.available()];
    fis.read(compressedData);
    GZIPInputStream gzis=new GZIPInputStream(new ByteArrayInputStream(compressedData));
    byte[] decompressed=new byte[gzis.available()];
    gzis.read(decompressed);
    level=new NBTDecoder(new DataInputStream(new ByteArrayInputStream(decompressed))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    return;
  }
catch (  Exception ex) {
    logger.info(""String_Node_Str"");
    ex.printStackTrace();
    return;
  }
  logger.info(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.getDifficulty(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  defaultGamemode=GameMode.getGameMode(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.getLevelType(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  logger.info(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  for (  File file : region.listFiles()) {
    String[] strings=file.getName().split(""String_Node_Str"");
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    if (strings.length != 3 && !(strings[0].equals(""String_Node_Str"")) && !(file.getName().endsWith(""String_Node_Str""))) {
      continue;
    }
    int chunkX;
    int chunkZ;
    try {
      chunkX=(int)Math.floor(Integer.parseInt(strings[1]) * 32);
      chunkZ=(int)Math.floor(Integer.parseInt(strings[2]) * 32);
    }
 catch (    NumberFormatException ex) {
      continue;
    }
    for (    ChunkLocation loc : loadedChunks.keySet()) {
      if (loc.getX() == chunkX && loc.getZ() == chunkZ)       continue;
    }
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    RegionFile regionFile;
    try {
      regionFile=new RegionFile(file.toPath());
    }
 catch (    IOException ex) {
      logger.info(""String_Node_Str"");
      ex.printStackTrace();
      continue;
    }
    ChunkLocation location=new ChunkLocation(chunkX,chunkZ);
    TridentChunk chunk;
    try {
      chunk=regionFile.loadChunkData(this);
    }
 catch (    NBTException|IOException|DataFormatException e) {
      logger.info(""String_Node_Str"");
      e.printStackTrace();
      continue;
    }
    loadedChunks.put(location,chunk);
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
}"
11917,"public TridentWorldLoader(){
  for (  File file : new File(""String_Node_Str"").listFiles()) {
    if (!(file.isDirectory()) || file.getName().contains(""String_Node_Str"")) {
      continue;
    }
    boolean isWorld=false;
    for (    File f : file.listFiles()) {
      if (f.getName().equals(""String_Node_Str"")) {
        isWorld=true;
      }
    }
    if (!(isWorld)) {
      continue;
    }
    load(file.getName());
  }
}","public TridentWorldLoader(){
  for (  File file : getWorldContainer().listFiles()) {
    if (!(file.isDirectory()) || file.getName().contains(""String_Node_Str"")) {
      continue;
    }
    boolean isWorld=false;
    for (    File f : file.listFiles()) {
      if (f.getName().equals(""String_Node_Str"")) {
        isWorld=true;
      }
    }
    if (!(isWorld)) {
      continue;
    }
    load(file.getName());
  }
}"
11918,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  player.setLocale(this.locale);
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  player.setLocale(locale);
}"
11919,"public void load(CompoundTag tag){
  IntTag x=tag.getTagAs(""String_Node_Str"");
  IntTag z=tag.getTagAs(""String_Node_Str"");
  LongTag lastModifed=tag.getTagAs(""String_Node_Str"");
  ByteTag lightPopulated=tag.getTagAs(""String_Node_Str"");
  ByteTag terrainPopulated=tag.getTagAs(""String_Node_Str"");
  LongTag inhabitedTime=tag.getTagAs(""String_Node_Str"");
  ByteArrayTag biomes=tag.getTagAs(""String_Node_Str"");
  ListTag sections=tag.getTagAs(""String_Node_Str"");
  ListTag entities=tag.getTagAs(""String_Node_Str"");
  ListTag tileEntities=tag.getTagAs(""String_Node_Str"");
  ListTag tileTicks=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> sectionsList=sections.listTags();
  this.sections=new ChunkSection[sectionsList.size()];
  for (int i=0; i <= sectionsList.size(); i+=1) {
    NBTTag t=sections.getTag(i);
    if (t instanceof CompoundTag) {
      CompoundTag ct=(CompoundTag)t;
      this.sections[i]=NBTSerializer.deserialize(ChunkSection.class,ct);
      this.sections[i].loadBlocks();
    }
  }
  FastClass entityClass=FastClass.get(TridentEntity.class);
  for (  NBTTag t : entities.listTags()) {
    TridentEntity entity=entityClass.getConstructor().newInstance();
    entity.load((CompoundTag)t);
    this.entities.add(entity);
  }
  this.lightPopulated=lightPopulated.getValue();
  this.terrainPopulated=terrainPopulated.getValue();
  this.lastModified=lastModifed.getValue();
  this.inhabitedTime=inhabitedTime.getValue();
}","public void load(CompoundTag tag){
  TridentLogger logger=Trident.getLogger();
  logger.info(""String_Node_Str"");
  IntTag x=tag.getTagAs(""String_Node_Str"");
  IntTag z=tag.getTagAs(""String_Node_Str"");
  LongTag lastModifed=tag.getTagAs(""String_Node_Str"");
  ByteTag lightPopulated=tag.getTagAs(""String_Node_Str"");
  ByteTag terrainPopulated=tag.getTagAs(""String_Node_Str"");
  LongTag inhabitedTime=tag.getTagAs(""String_Node_Str"");
  ByteArrayTag biomes=tag.getTagAs(""String_Node_Str"");
  ListTag sections=tag.getTagAs(""String_Node_Str"");
  ListTag entities=tag.getTagAs(""String_Node_Str"");
  ListTag tileEntities=tag.getTagAs(""String_Node_Str"");
  ListTag tileTicks=tag.getTagAs(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  List<NBTTag> sectionsList=sections.listTags();
  this.sections=new ChunkSection[sectionsList.size()];
  for (int i=0; i <= sectionsList.size(); i+=1) {
    NBTTag t=sections.getTag(i);
    if (t instanceof CompoundTag) {
      CompoundTag ct=(CompoundTag)t;
      this.sections[i]=NBTSerializer.deserialize(ChunkSection.class,ct);
      this.sections[i].loadBlocks();
    }
  }
  logger.info(""String_Node_Str"");
  FastClass entityClass=FastClass.get(TridentEntity.class);
  for (  NBTTag t : entities.listTags()) {
    TridentEntity entity=entityClass.getConstructor().newInstance();
    entity.load((CompoundTag)t);
    this.entities.add(entity);
  }
  logger.info(""String_Node_Str"");
  this.lightPopulated=lightPopulated.getValue();
  this.terrainPopulated=terrainPopulated.getValue();
  this.lastModified=lastModifed.getValue();
  this.inhabitedTime=inhabitedTime.getValue();
  logger.info(""String_Node_Str"");
}"
11920,"TridentWorld(String name,WorldLoader loader){
  this.name=name;
  this.loader=loader;
  this.random=new Random();
}","TridentWorld(String name,WorldLoader loader){
  this.name=name;
  this.loader=loader;
  this.random=new Random();
  spawnLocation=new Location(this,0d,0d,0d);
  TridentLogger logger=Trident.getLogger();
  logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  File directory=new File(name + File.separator);
  File levelFile=new File(directory,""String_Node_Str"");
  CompoundTag level;
  try {
    level=new NBTDecoder(new DataInputStream(new FileInputStream(levelFile))).decode().getTagAs(""String_Node_Str"");
  }
 catch (  FileNotFoundException ignored) {
    return;
  }
catch (  NBTException ex) {
    logger.info(""String_Node_Str"");
    ex.printStackTrace();
    return;
  }
  logger.info(""String_Node_Str"");
  spawnLocation.setX(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setY(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  spawnLocation.setZ(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  dimension=Dimension.OVERWORLD;
  difficulty=Difficulty.getDifficulty(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  defaultGamemode=GameMode.getGameMode(((IntTag)level.getTag(""String_Node_Str"")).getValue());
  type=LevelType.getLevelType(((StringTag)level.getTag(""String_Node_Str"")).getValue());
  logger.info(""String_Node_Str"");
  File region=new File(directory,""String_Node_Str"" + File.separator);
  if (!(region.exists()) || !(region.isDirectory())) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  for (  File file : region.listFiles()) {
    String[] strings=file.getName().split(""String_Node_Str"");
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    if (strings.length != 3 && !(strings[0].equals(""String_Node_Str"")) && !(file.getName().endsWith(""String_Node_Str""))) {
      continue;
    }
    int chunkX;
    int chunkZ;
    try {
      chunkX=(int)Math.floor(Integer.parseInt(strings[1]) * 32);
      chunkZ=(int)Math.floor(Integer.parseInt(strings[2]) * 32);
    }
 catch (    NumberFormatException ex) {
      continue;
    }
    for (    ChunkLocation loc : loadedChunks.keySet()) {
      if (loc.getX() == chunkX && loc.getZ() == chunkZ)       continue;
    }
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    RegionFile regionFile;
    try {
      regionFile=new RegionFile(file.toPath());
    }
 catch (    IOException ex) {
      logger.info(""String_Node_Str"");
      ex.printStackTrace();
      continue;
    }
    ChunkLocation location=new ChunkLocation(chunkX,chunkZ);
    TridentChunk chunk;
    try {
      chunk=regionFile.loadChunkData(this);
    }
 catch (    NBTException|IOException|DataFormatException e) {
      logger.info(""String_Node_Str"");
      e.printStackTrace();
      continue;
    }
    loadedChunks.put(location,chunk);
    logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
  }
}"
11921,"@Override public GameMode getDefaultGamemode(){
  return GameMode.SURVIVAL;
}","@Override public GameMode getDefaultGamemode(){
  return defaultGamemode;
}"
11922,"@Override public Dimension getDimesion(){
  return Dimension.OVERWORLD;
}","@Override public Dimension getDimesion(){
  return dimension;
}"
11923,"@Override public Difficulty getDifficulty(){
  return Difficulty.NORMAL;
}","@Override public Difficulty getDifficulty(){
  return difficulty;
}"
11924,"@Override public LevelType getLevelType(){
  return LevelType.DEFAULT;
}","@Override public LevelType getLevelType(){
  return type;
}"
11925,"public void load(CompoundTag tag){
  StringTag id=tag.getTagAs(""String_Node_Str"");
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=tag.getTagAs(""String_Node_Str"");
  ByteTag dnVisible=tag.getTagAs(""String_Node_Str"");
  ByteTag silent=tag.getTagAs(""String_Node_Str"");
  CompoundTag riding=tag.getTagAs(""String_Node_Str"");
  CompoundTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=Integer.parseInt(id.getValue());
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  int[] location=new int[3];
  for (int i=0; i < 3; i+=1) {
    location[i]=((IntTag)pos.get(i)).getValue();
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  int[] velocity=new int[3];
  for (int i=0; i < 3; i+=1) {
    velocity[i]=((IntTag)motion.get(i)).getValue();
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  loc.setYaw(((IntTag)rotation.get(0)).getValue());
  loc.setPitch(((IntTag)rotation.get(0)).getValue());
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
}","public void load(CompoundTag tag){
  StringTag id=tag.getTagAs(""String_Node_Str"");
  LongTag uuidMost=tag.getTagAs(""String_Node_Str"");
  LongTag uuidLeast=tag.getTagAs(""String_Node_Str"");
  List<NBTTag> pos=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> motion=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  List<NBTTag> rotation=((ListTag)tag.getTagAs(""String_Node_Str"")).listTags();
  FloatTag fallDistance=tag.getTagAs(""String_Node_Str"");
  ShortTag fireTicks=tag.getTagAs(""String_Node_Str"");
  ShortTag airTicks=tag.getTagAs(""String_Node_Str"");
  ByteTag onGround=tag.getTagAs(""String_Node_Str"");
  ByteTag invulnerable=tag.getTagAs(""String_Node_Str"");
  IntTag dimension=tag.getTagAs(""String_Node_Str"");
  IntTag portalCooldown=tag.getTagAs(""String_Node_Str"");
  StringTag displayName=tag.getTagAs(""String_Node_Str"");
  ByteTag dnVisible=tag.getTagAs(""String_Node_Str"");
  ByteTag silent=tag.getTagAs(""String_Node_Str"");
  CompoundTag riding=tag.getTagAs(""String_Node_Str"");
  CompoundTag commandStats=tag.getTagAs(""String_Node_Str"");
  this.id=Integer.parseInt(id.getValue());
  if (this.id >= counter.get()) {
    counter.incrementAndGet();
  }
  this.uniqueId=new UUID(uuidMost.getValue(),uuidLeast.getValue());
  int[] location=new int[3];
  for (int i=0; i < 3; i+=1) {
    location[i]=((IntTag)pos.get(i)).getValue();
  }
  loc.setX(location[0]);
  loc.setY(location[1]);
  loc.setZ(location[2]);
  int[] velocity=new int[3];
  for (int i=0; i < 3; i+=1) {
    velocity[i]=((IntTag)motion.get(i)).getValue();
  }
  this.velocity.setX(velocity[0]);
  this.velocity.setY(velocity[1]);
  this.velocity.setZ(velocity[2]);
  loc.setYaw(((IntTag)rotation.get(0)).getValue());
  loc.setPitch(((IntTag)rotation.get(0)).getValue());
  this.fallDistance.set((long)fallDistance.getValue());
  this.fireTicks.set(fireTicks.getValue());
  this.airTicks.set(airTicks.getValue());
  this.portalCooldown.set(portalCooldown.getValue());
  this.onGround=onGround.getValue() == 1;
  this.godMode=invulnerable.getValue() == 1;
  this.nameVisible=dnVisible.getValue() == 1;
  this.silent=silent.getValue() == 1;
  this.displayName=displayName.getValue();
}"
11926,"@Override public void handleReceived(ClientConnection connection){
  byte[] sharedSecret=null;
  byte[] token=null;
  try {
    sharedSecret=RSA.decrypt(this.encryptedSecret,connection.getLoginKeyPair().getPrivate());
    token=RSA.decrypt(this.encryptedToken,connection.getLoginKeyPair().getPrivate());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (!Arrays.equals(connection.getVerificationToken(),token)) {
    System.out.println(""String_Node_Str"" + connection.getAddress().getHostName() + ""String_Node_Str"");
    connection.logout();
    return;
  }
  String name=LoginManager.getInstance().getName(connection.getAddress());
  StringBuilder sb=new StringBuilder();
  try {
    URL url=new URL(""String_Node_Str"" + URLEncoder.encode(name,""String_Node_Str"") + ""String_Node_Str""+ new BigInteger(HashGenerator.getHash(connection,sharedSecret)).toString(16));
    HttpsURLConnection c=(HttpsURLConnection)url.openConnection();
    int code=c.getResponseCode();
    if (code != 200) {
      connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
      connection.logout();
      return;
    }
    BufferedReader reader=new BufferedReader(new InputStreamReader(c.getInputStream()));
    String line;
    while ((line=reader.readLine()) != null) {
      sb.append(line);
      sb.append('\n');
    }
    reader.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    connection.logout();
    return;
  }
  connection.enableEncryption(sharedSecret);
  SessionResponse response=GSON.fromJson(sb.toString(),SessionResponse.class);
  PacketLoginOutSuccess packet=new PacketLoginOutSuccess();
  packet.set(""String_Node_Str"",idDash.matcher(response.id).replaceAll(""String_Node_Str""));
  packet.set(""String_Node_Str"",response.name);
  connection.sendPacket(packet);
  connection.setStage(Protocol.ClientStage.PLAY);
  UUID id=UUID.fromString(packet.getUuid());
  LoginManager.getInstance().finish(connection.getAddress());
  TridentPlayer.spawnPlayer(connection,id);
}","@Override public void handleReceived(ClientConnection connection){
  byte[] sharedSecret=null;
  byte[] token=null;
  try {
    sharedSecret=RSA.decrypt(this.encryptedSecret,connection.getLoginKeyPair().getPrivate());
    token=RSA.decrypt(this.encryptedToken,connection.getLoginKeyPair().getPrivate());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (!Arrays.equals(connection.getVerificationToken(),token)) {
    System.out.println(""String_Node_Str"" + connection.getAddress().getHostName() + ""String_Node_Str"");
    connection.logout();
    return;
  }
  String name=LoginManager.getInstance().getName(connection.getAddress());
  StringBuilder sb=new StringBuilder();
  try {
    URL url=new URL(""String_Node_Str"" + URLEncoder.encode(name,""String_Node_Str"") + ""String_Node_Str""+ new BigInteger(HashGenerator.getHash(connection,sharedSecret)).toString(16));
    HttpsURLConnection c=(HttpsURLConnection)url.openConnection();
    int code=c.getResponseCode();
    if (code != 200) {
      connection.sendPacket(new PacketLoginOutDisconnect().setJsonMessage(""String_Node_Str""));
      connection.logout();
      return;
    }
    BufferedReader reader=new BufferedReader(new InputStreamReader(c.getInputStream()));
    String line;
    while ((line=reader.readLine()) != null) {
      sb.append(line);
      sb.append('\n');
    }
    reader.close();
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    connection.logout();
    return;
  }
  connection.enableEncryption(sharedSecret);
  SessionResponse response=GSON.fromJson(sb.toString(),SessionResponse.class);
  PacketLoginOutSuccess packet=new PacketLoginOutSuccess();
  packet.set(""String_Node_Str"",idDash.matcher(response.id).replaceAll(""String_Node_Str""));
  packet.set(""String_Node_Str"",response.name);
  connection.sendPacket(packet);
  connection.setStage(Protocol.ClientStage.PLAY);
  UUID id=UUID.fromString(packet.getUuid());
  LoginManager.getInstance().finish(connection.getAddress());
  TridentPlayer.spawnPlayer(connection,id,name);
}"
11927,"public OfflinePlayer(CompoundTag tag,TridentWorld world){
  super(null,null);
  load(tag);
  dimesion=Dimension.getDimension(((IntTag)tag.getTag(""String_Node_Str"")).getValue());
  gameMode=GameMode.getGameMode(((IntTag)tag.getTag(""String_Node_Str"")).getValue());
  score=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  selectedSlot=(short)((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  if (tag.containsTag(""String_Node_Str"")) {
    spawnLocation=new Location(world,((IntTag)tag.getTag(""String_Node_Str"")).getValue(),((IntTag)tag.getTag(""String_Node_Str"")).getValue(),((IntTag)tag.getTag(""String_Node_Str"")).getValue());
  }
 else {
    spawnLocation=null;
  }
  hunger=(short)((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  exhaustion=((FloatTag)tag.getTag(""String_Node_Str"")).getValue();
  saturation=((FloatTag)tag.getTag(""String_Node_Str"")).getValue();
  foodTickTimer=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpLevel=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpPercent=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpTotal=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpSeed=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
    inventory.setSlot(slot.getSlot(),slot.toItemStack());
  }
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
    enderChest.setSlot(slot.getSlot(),slot.toItemStack());
  }
  NBTSerializer.deserialize(abilities,(CompoundTag)tag.getTag(""String_Node_Str""));
  players.add(this);
}","public OfflinePlayer(CompoundTag tag,TridentWorld world){
  super(null,world.getSpawnLocation());
  load(tag);
  dimesion=Dimension.getDimension(((IntTag)tag.getTag(""String_Node_Str"")).getValue());
  gameMode=GameMode.getGameMode(((IntTag)tag.getTag(""String_Node_Str"")).getValue());
  score=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  selectedSlot=(short)((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  if (tag.containsTag(""String_Node_Str"")) {
    spawnLocation=new Location(world,((IntTag)tag.getTag(""String_Node_Str"")).getValue(),((IntTag)tag.getTag(""String_Node_Str"")).getValue(),((IntTag)tag.getTag(""String_Node_Str"")).getValue());
  }
 else {
    spawnLocation=world.getSpawnLocation();
  }
  hunger=(short)((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  exhaustion=((FloatTag)tag.getTag(""String_Node_Str"")).getValue();
  saturation=((FloatTag)tag.getTag(""String_Node_Str"")).getValue();
  foodTickTimer=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpLevel=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpPercent=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpTotal=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  xpSeed=((IntTag)tag.getTag(""String_Node_Str"")).getValue();
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
  }
  for (  NBTTag t : ((ListTag)tag.getTag(""String_Node_Str"")).listTags()) {
    Slot slot=NBTSerializer.deserialize(Slot.class,(CompoundTag)t);
  }
  NBTSerializer.deserialize(abilities,(CompoundTag)tag.getTag(""String_Node_Str""));
  players.add(this);
}"
11928,"public static Player spawnPlayer(ClientConnection connection,UUID id){
  OfflinePlayer offlinePlayer=OfflinePlayer.getOfflinePlayer(id);
  TridentPlayer p=new TridentPlayer(offlinePlayer.toNbt(),(TridentWorld)offlinePlayer.getWorld(),connection);
  p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().getDimesion()).set(""String_Node_Str"",p.getWorld().getDifficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
  p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
  p.connection.sendPacket(p.abilities.toPacket());
  p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getLocation()).set(""String_Node_Str"",(byte)0));
  p.sendChunks(7);
  players.add(p);
  return p;
}","public static Player spawnPlayer(ClientConnection connection,UUID id,String name){
  OfflinePlayer offlinePlayer=OfflinePlayer.getOfflinePlayer(id);
  if (offlinePlayer == null) {
    offlinePlayer=OfflinePlayer.generatePlayer(name,id);
  }
  TridentPlayer p=new TridentPlayer(offlinePlayer.toNbt(),(TridentWorld)offlinePlayer.getWorld(),connection);
  p.connection.sendPacket(new PacketPlayOutJoinGame().set(""String_Node_Str"",p.getId()).set(""String_Node_Str"",p.getGameMode()).set(""String_Node_Str"",p.getWorld().getDimesion()).set(""String_Node_Str"",p.getWorld().getDifficulty()).set(""String_Node_Str"",(short)10).set(""String_Node_Str"",LevelType.DEFAULT));
  p.connection.sendPacket(new PacketPlayOutSpawnPosition().set(""String_Node_Str"",p.getSpawnLocation()));
  p.connection.sendPacket(p.abilities.toPacket());
  p.connection.sendPacket(new PacketPlayOutPlayerCompleteMove().set(""String_Node_Str"",p.getLocation()).set(""String_Node_Str"",(byte)0));
  p.sendChunks(7);
  players.add(p);
  return p;
}"
11929,"/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client <p/>   {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketType.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  System.out.println(""String_Node_Str"" + packet.getClass().getSimpleName());
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
  }
 catch (  Exception ex) {
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
break;
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",ex.getMessage());
this.connection.sendPacket(quit);
this.connection.logout();
break;
default :
ex.printStackTrace();
break;
}
}
}","/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client <p/>   {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketType.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  System.out.println(""String_Node_Str"" + packet.getClass().getSimpleName());
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",ex.getMessage());
this.connection.sendPacket(quit);
this.connection.logout();
default :
break;
}
}
}"
11930,"@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  World world=player.getWorld();
  StatusType type=StatusType.getStatus((int)this.actionId);
switch (type) {
case RESPAWN:
    PacketPlayOutPlayerRespawn respawn=new PacketPlayOutPlayerRespawn();
  respawn.set(""String_Node_Str"",(int)world.getDimesion().toByte()).set(""String_Node_Str"",(int)world.getDifficulity().toByte()).set(""String_Node_Str"",(int)world.getDefaultGamemode().toByte());
connection.sendPacket(respawn);
break;
case STATISTICS_REQUEST:
PacketPlayOutStatistics statistics=new PacketPlayOutStatistics();
statistics.set(""String_Node_Str"",null);
connection.sendPacket(statistics);
break;
case OPEN_INVENTORY_ACHEIVEMENT:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","@Override public void handleReceived(ClientConnection connection){
  TridentPlayer player=((PlayerConnection)connection).getPlayer();
  World world=player.getWorld();
  StatusType type=StatusType.getStatus((int)this.actionId);
switch (type) {
case RESPAWN:
    PacketPlayOutPlayerRespawn respawn=new PacketPlayOutPlayerRespawn();
  respawn.set(""String_Node_Str"",(int)world.getDimesion().toByte()).set(""String_Node_Str"",(int)world.getDifficulty().toByte()).set(""String_Node_Str"",(int)world.getDefaultGamemode().toByte());
connection.sendPacket(respawn);
break;
case STATISTICS_REQUEST:
PacketPlayOutStatistics statistics=new PacketPlayOutStatistics();
statistics.set(""String_Node_Str"",null);
connection.sendPacket(statistics);
break;
case OPEN_INVENTORY_ACHEIVEMENT:
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}"
11931,"/** 
 * Inherits constructor from   {@link net.tridentsdk.entity.TridentProjectile}
 */
public TridentEgg(UUID uniqueId,Location spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation,source);
}","/** 
 * Inherits constructor from   {@link net.tridentsdk.entity.TridentProjectile}
 */
public TridentEgg(UUID uniqueId,Location spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation,source,false);
}"
11932,"/** 
 * Inherits from   {@link net.tridentsdk.entity.TridentProjectile}
 */
public TridentSnowball(UUID uniqueId,Location spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation,source);
}","/** 
 * Inherits from   {@link net.tridentsdk.entity.TridentProjectile}
 */
public TridentSnowball(UUID uniqueId,Location spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation,source,false);
}"
11933,"public TridentWitherSkull(UUID uniqueId,Location spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation,source);
}","public TridentWitherSkull(UUID uniqueId,Location spawnLocation,ProjectileSource source){
  super(uniqueId,spawnLocation,source,false);
}"
11934,"/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client <p/>   {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketType.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  System.out.println(""String_Node_Str"" + packet.getClass().getSimpleName());
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
  }
 catch (  Exception ex) {
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
break;
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",ex.getMessage());
this.connection.sendPacket(quit);
this.connection.logout();
break;
default :
ex.printStackTrace();
break;
}
}
final ClientConnection finalConnection=this.connection;
BackgroundTaskExecutor.execute(new Runnable(){
@Override public void run(){
PlayerThreads.clientThreadHandle(finalConnection);
}
}
);
}","/** 
 * Converts the PacketData to a Packet depending on the ConnectionStage of the Client <p/>   {@inheritDoc}
 */
@Override protected void messageReceived(ChannelHandlerContext context,PacketData data) throws Exception {
  if (this.connection.isEncryptionEnabled()) {
    data.decrypt(this.connection);
  }
  Packet packet=this.protocol.getPacket(data.getId(),this.connection.getStage(),PacketType.IN);
  if (packet.getId() == -1) {
    this.connection.logout();
    return;
  }
  System.out.println(""String_Node_Str"" + packet.getClass().getSimpleName());
  packet.decode(data.getData());
  try {
    packet.handleReceived(this.connection);
  }
 catch (  Exception ex) {
switch (this.connection.getStage()) {
case LOGIN:
      PacketLoginOutDisconnect disconnect=new PacketLoginOutDisconnect();
    disconnect.setJsonMessage(ex.getMessage());
  this.connection.sendPacket(disconnect);
this.connection.logout();
break;
case PLAY:
PacketPlayOutDisconnect quit=new PacketPlayOutDisconnect();
quit.set(""String_Node_Str"",ex.getMessage());
this.connection.sendPacket(quit);
this.connection.logout();
break;
default :
ex.printStackTrace();
break;
}
}
}"
11935,"@Benchmark public void put(Blackhole blackhole){
  blackhole.consume(PlayerThreads.clientThreadHandle(TestPlayerThreads.CLIENT_CONNECTION));
}","@Benchmark public void put(Blackhole blackhole){
  blackhole.consume(PlayerThreads.clientThreadHandle(TestPlayerThreads.PLAYER));
}"
11936,"@Benchmark public void remove(Blackhole blackhole){
  PlayerThreads.remove(TestPlayerThreads.CLIENT_CONNECTION);
}","@Benchmark public void remove(Blackhole blackhole){
  PlayerThreads.remove(TestPlayerThreads.PLAYER);
}"
11937,"public String getVersion(){
  return ""String_Node_Str"";
}","@Override public String getVersion(){
  return ""String_Node_Str"";
}"
11938,"/** 
 * Creates the server access base, distributing information to the fields available
 * @param config the configuration to use for option lookup
 */
public static TridentServer createServer(JsonConfig config){
  TridentServer server=new TridentServer(config);
  Trident.setServer(server);
  server.SERVER_THREAD.set(server.taskExecutor.getScaledThread().asThread());
  return server;
}","/** 
 * Creates the server access base, distributing information to the fields available
 * @param config the configuration to use for option lookup
 */
public static TridentServer createServer(JsonConfig config,ConcurrentTaskExecutor<?> taskExecutor){
  TridentServer server=new TridentServer(config,taskExecutor);
  Trident.setServer(server);
  server.SERVER_THREAD.set(server.taskExecutor.getScaledThread().asThread());
  return server;
}"
11939,"public int getMaxPlayers(){
  return getConfig().getInt(""String_Node_Str"",Defaults.MAX_PLAYERS);
}","@Override public int getMaxPlayers(){
  return this.getConfig().getInt(""String_Node_Str"",Defaults.MAX_PLAYERS);
}"
11940,"public String getMotd(){
  return getConfig().getString(""String_Node_Str"",Defaults.MOTD);
}","@Override public String getMotd(){
  return this.getConfig().getString(""String_Node_Str"",Defaults.MOTD);
}"
11941,"public JsonConfig getConfig(){
  return config;
}","public JsonConfig getConfig(){
  return this.config;
}"
11942,"/** 
 * Puts a task into the execution queue
 */
public void addTask(Runnable task){
  this.taskExecutor.getScaledThread().addTask(task);
}","/** 
 * Puts a task into the execution queue
 */
@Override public void addTask(Runnable task){
  this.taskExecutor.getScaledThread().addTask(task);
}"
11943,"public int setMotdImage(Image image){
  return -1;
}","@Override public int setMotdImage(Image image){
  return -1;
}"
11944,"public File getMotdImage(){
  return new File(getConfig().getString(""String_Node_Str"",Defaults.MOTD_IMAGE_LOCATION));
}","public File getMotdImage(){
  return new File(this.getConfig().getString(""String_Node_Str"",Defaults.MOTD_IMAGE_LOCATION));
}"
11945,"public void setMotd(String motd){
  getConfig().setString(""String_Node_Str"",motd);
}","public void setMotd(String motd){
  this.getConfig().setString(""String_Node_Str"",motd);
}"
11946,"public BufferedImage getMotdPictureImage(){
  BufferedImage img=null;
  try {
    img=ImageIO.read(new File(getConfig().getString(""String_Node_Str"",Defaults.MOTD_IMAGE_LOCATION)));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
  return img;
}","@Override public BufferedImage getMotdPictureImage(){
  BufferedImage img=null;
  try {
    img=ImageIO.read(new File(this.getConfig().getString(""String_Node_Str"",Defaults.MOTD_IMAGE_LOCATION)));
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
  return img;
}"
11947,"public Difficulty getDifficulty(){
  byte difficulty=getConfig().getByte(""String_Node_Str"",Defaults.DIFFICULTY.toByte());
switch (difficulty) {
case 0:
    return Difficulty.PEACEFUL;
case 1:
  return Difficulty.EASY;
case 2:
return Difficulty.NORMAL;
case 3:
return Difficulty.HARD;
}
return null;
}","@Override public Difficulty getDifficulty(){
  byte difficulty=this.getConfig().getByte(""String_Node_Str"",Defaults.DIFFICULTY.toByte());
switch (difficulty) {
case 0:
    return Difficulty.PEACEFUL;
case 1:
  return Difficulty.EASY;
case 2:
return Difficulty.NORMAL;
case 3:
return Difficulty.HARD;
}
return null;
}"
11948,"/** 
 * Initializes the server with the configuration file
 * @param config the configuration to use for option lookup
 */
private static void init(JsonConfig config){
  final ConcurrentTaskExecutor<?> taskExecutor=new ConcurrentTaskExecutor<>(1);
  final JsonConfig innerConfig=config;
  taskExecutor.getScaledThread().addTask(new Runnable(){
    @Override public void run(){
      TridentServer.createServer(innerConfig);
    }
  }
);
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(TridentStart.bossGroup,TridentStart.workerGroup).channel(NioServerSocketChannel.class).childHandler(new ClientChannelInitializer()).option(ChannelOption.TCP_NODELAY,true);
    ChannelFuture f=b.bind(new InetSocketAddress(config.getString(""String_Node_Str"",""String_Node_Str""),config.getInt(""String_Node_Str"",25565))).sync();
    f.channel().closeFuture().sync();
  }
 catch (  InterruptedException e) {
  }
catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    TridentServer.getInstance().shutdown();
  }
}","/** 
 * Initializes the server with the configuration file
 * @param config the configuration to use for option lookup
 */
private static void init(JsonConfig config){
  final ConcurrentTaskExecutor<?> taskExecutor=new ConcurrentTaskExecutor<>(1);
  final JsonConfig innerConfig=config;
  taskExecutor.getScaledThread().addTask(new Runnable(){
    @Override public void run(){
      TridentServer.createServer(innerConfig,taskExecutor);
    }
  }
);
  try {
    ServerBootstrap b=new ServerBootstrap();
    b.group(TridentStart.bossGroup,TridentStart.workerGroup).channel(NioServerSocketChannel.class).childHandler(new ClientChannelInitializer()).option(ChannelOption.TCP_NODELAY,true);
    ChannelFuture f=b.bind(new InetSocketAddress(config.getString(""String_Node_Str"",""String_Node_Str""),config.getInt(""String_Node_Str"",25565))).sync();
    f.channel().closeFuture().sync();
  }
 catch (  InterruptedException e) {
  }
catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    TridentServer.getInstance().shutdown();
  }
}"
11949,"/** 
 * Starts the server up when the jarfile is run
 * @param args the command line arguments
 */
public static void main(String... args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.acceptsAll(TridentStart.asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").forHelp();
  OptionSpec<Boolean> append=parser.acceptsAll(TridentStart.asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Boolean.class).defaultsTo(true).describedAs(""String_Node_Str"");
  OptionSpec<File> properties=parser.acceptsAll(TridentStart.asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(File.class).defaultsTo(new File(""String_Node_Str"")).describedAs(""String_Node_Str"");
  OptionSet options=null;
  File f;
  try {
    options=parser.parse(args);
  }
 catch (  OptionException ex) {
    ex.printStackTrace();
    return;
  }
  if (!((f=properties.value(options)).exists())) {
    InputStream link=(TridentServer.class.getResourceAsStream(""String_Node_Str""));
    Files.copy(link,f.getAbsoluteFile().toPath());
  }
  TridentStart.init(new JsonConfig(f));
}","/** 
 * Starts the server up when the jarfile is run
 * @param args the command line arguments
 */
public static void main(String... args) throws Exception {
  OptionParser parser=new OptionParser();
  parser.acceptsAll(TridentStart.asList(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"").forHelp();
  OptionSpec<Boolean> append=parser.acceptsAll(TridentStart.asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(Boolean.class).defaultsTo(true).describedAs(""String_Node_Str"");
  OptionSpec<File> properties=parser.acceptsAll(TridentStart.asList(""String_Node_Str""),""String_Node_Str"").withRequiredArg().ofType(File.class).defaultsTo(new File(""String_Node_Str"")).describedAs(""String_Node_Str"");
  OptionSet options=null;
  try {
    options=parser.parse(args);
  }
 catch (  OptionException ex) {
    ex.printStackTrace();
    return;
  }
  File f;
  if (!(f=properties.value(options)).exists()) {
    InputStream link=TridentServer.class.getResourceAsStream(""String_Node_Str"");
    Files.copy(link,f.getAbsoluteFile().toPath());
  }
  TridentStart.init(new JsonConfig(f));
}"
11950,"@Override public void run(){
  TridentServer.createServer(innerConfig);
}","@Override public void run(){
  TridentServer.createServer(innerConfig,taskExecutor);
}"
11951,"@Override public void handleReceived(ClientConnection connection){
  PacketStatusOutResponse packet=new PacketStatusOutResponse();
  PacketStatusOutResponse.Response response=packet.getResponse();
  response.description.text=TridentServer.getInstance().getConfig().getString(""String_Node_Str"",""String_Node_Str"");
  response.players.max=TridentServer.getInstance().getConfig().getInt(""String_Node_Str"",10);
  packet.set(""String_Node_Str"",response);
  connection.sendPacket(packet);
}","@Override public void handleReceived(ClientConnection connection){
  PacketStatusOutResponse packet=new PacketStatusOutResponse();
  PacketStatusOutResponse.Response response=packet.getResponse();
  response.description.text=TridentServer.getInstance().getConfig().getString(""String_Node_Str"",""String_Node_Str"");
  response.players.max=TridentServer.getInstance().getConfig().getInt(""String_Node_Str"",10);
  packet.response=response;
  connection.sendPacket(packet);
}"
11952,"public RegionFile getRegionFile(File serverDirectory,int chunkX,int chunkZ){
  int actualX=chunkX >> 5;
  int actualZ=chunkZ >> 5;
  File regionDir=new File(serverDirectory,""String_Node_Str"");
  File actualFile=new File(regionDir,""String_Node_Str"" + actualX + ""String_Node_Str""+ actualZ+ ""String_Node_Str"");
  RegionFile file=this.regionFiles.get(actualFile);
  if (file == null) {
    if (!regionDir.exists()) {
      regionDir.mkdirs();
    }
    try {
      file=new RegionFile(actualFile);
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
    this.regionFiles.put(actualFile,file);
  }
  return file;
}","public RegionFile getRegionFile(File serverDirectory,int chunkX,int chunkZ){
  int actualX=chunkX >> 5;
  int actualZ=chunkZ >> 5;
  File regionDir=new File(serverDirectory,""String_Node_Str"");
  File actualFile=new File(regionDir,""String_Node_Str"" + actualX + ""String_Node_Str""+ actualZ+ ""String_Node_Str"");
  RegionFile file=this.regionFiles.get(actualFile);
  if (file == null) {
    if (!regionDir.exists()) {
      regionDir.mkdirs();
    }
    try {
      file=new RegionFile(actualFile);
    }
 catch (    IOException|DataFormatException|NBTException e) {
      e.printStackTrace();
    }
    this.regionFiles.put(actualFile,file);
  }
  return file;
}"
11953,"public void setName(String name){
  this.name=name;
  this.id=((TridentServer)Trident.getServer()).getProfileRepository().findProfilesByNames(name)[0].getId();
}","public void setName(String name){
  this.name=name;
  this.id=null;
}"
11954,"@Override public void update(){
  super.update();
  Sample.INSTANCE.play(Assets.SND_CLICK,1,1,1.2f);
}","@Override public void update(){
  super.update();
  if (brightness < 1.0f && brightness > MIN_BRIGHTNESS) {
    if ((brightness-=Game.elapsed) <= MIN_BRIGHTNESS) {
      brightness=MIN_BRIGHTNESS;
    }
    updateBrightness();
  }
}"
11955,"public WndSettings(boolean inGame){
  super();
  if (inGame) {
    int w=BTN_HEIGHT;
    btnZoomOut=new RedButton(TXT_ZOOM_OUT){
      @Override protected void onClick(){
        zoom(Camera.main.zoom - 1);
      }
    }
;
    add(btnZoomOut.setRect(0,0,w,BTN_HEIGHT));
    btnZoomIn=new RedButton(TXT_ZOOM_IN){
      @Override protected void onClick(){
        zoom(Camera.main.zoom + 1);
      }
    }
;
    add(btnZoomIn.setRect(WIDTH - w,0,w,BTN_HEIGHT));
    add(new RedButton(TXT_ZOOM_DEFAULT){
      @Override protected void onClick(){
        zoom(PixelScene.defaultZoom);
      }
    }
.setRect(btnZoomOut.right(),0,WIDTH - btnZoomIn.width() - btnZoomOut.width(),BTN_HEIGHT));
    updateEnabled();
  }
 else {
    CheckBox btnScaleUp=new CheckBox(TXT_SCALE_UP){
      @Override protected void onClick(){
        super.onClick();
        PixelDungeon.scaleUp(checked());
      }
    }
;
    btnScaleUp.setRect(0,0,WIDTH,BTN_HEIGHT);
    btnScaleUp.checked(PixelDungeon.scaleUp());
    add(btnScaleUp);
  }
  CheckBox btnMusic=new CheckBox(TXT_MUSIC){
    @Override protected void onClick(){
      super.onClick();
      PixelDungeon.music(checked());
    }
  }
;
  btnMusic.checked(PixelDungeon.music());
  add(btnMusic);
  CheckBox btnSound=new CheckBox(TXT_SOUND){
    @Override protected void onClick(){
      super.onClick();
      PixelDungeon.soundFx(checked());
      Sample.INSTANCE.play(Assets.SND_CLICK);
    }
  }
;
  btnSound.setRect(0,btnMusic.bottom() + GAP,WIDTH,BTN_HEIGHT);
  btnSound.checked(PixelDungeon.soundFx());
  add(btnSound);
  Button lastBtn=btnSound;
  if (!inGame) {
    Application.ApplicationType type=Gdx.app.getType();
    if (type == Application.ApplicationType.Android || type == Application.ApplicationType.iOS) {
      RedButton btnOrientation=new RedButton(orientationText()){
        @Override protected void onClick(){
          PixelDungeon.landscape(!PixelDungeon.landscape());
        }
      }
;
      btnOrientation.setRect(0,btnSound.bottom() + GAP,WIDTH,BTN_HEIGHT);
      add(btnOrientation);
      lastBtn=btnOrientation;
    }
 else     if (type == Application.ApplicationType.Desktop) {
      RedButton btnKeymap=new RedButton(TXT_BINDINGS){
        @Override protected void onClick(){
          parent.add(new WndKeymap());
        }
      }
;
      btnKeymap.setRect(0,btnSound.bottom() + GAP,WIDTH,BTN_HEIGHT);
      add(btnKeymap);
      RedButton btnResolution=new RedButton(resolutionText()){
        @Override protected void onClick(){
          PixelDungeon.fullscreen(!PixelDungeon.fullscreen());
        }
      }
;
      btnResolution.enable(PixelDungeon.instance.getPlatformSupport().isFullscreenEnabled());
      btnResolution.setRect(0,btnKeymap.bottom() + GAP,WIDTH,BTN_HEIGHT);
      add(btnResolution);
      lastBtn=btnResolution;
    }
  }
 else {
    CheckBox btnBrightness=new CheckBox(TXT_BRIGHTNESS){
      @Override protected void onClick(){
        super.onClick();
        PixelDungeon.brightness(checked());
      }
    }
;
    btnBrightness.setRect(0,btnSound.bottom() + GAP,WIDTH,BTN_HEIGHT);
    btnBrightness.checked(PixelDungeon.brightness());
    add(btnBrightness);
    lastBtn=btnBrightness;
  }
  resize(WIDTH,(int)lastBtn.bottom());
}","public WndSettings(boolean inGame){
  super();
  if (inGame) {
    int w=BTN_HEIGHT;
    btnZoomOut=new RedButton(TXT_ZOOM_OUT){
      @Override protected void onClick(){
        zoom(Camera.main.zoom - 1);
      }
    }
;
    add(btnZoomOut.setRect(0,0,w,BTN_HEIGHT));
    btnZoomIn=new RedButton(TXT_ZOOM_IN){
      @Override protected void onClick(){
        zoom(Camera.main.zoom + 1);
      }
    }
;
    add(btnZoomIn.setRect(WIDTH - w,0,w,BTN_HEIGHT));
    add(new RedButton(TXT_ZOOM_DEFAULT){
      @Override protected void onClick(){
        zoom(PixelScene.defaultZoom);
      }
    }
.setRect(btnZoomOut.right(),0,WIDTH - btnZoomIn.width() - btnZoomOut.width(),BTN_HEIGHT));
    updateEnabled();
  }
 else {
    CheckBox btnScaleUp=new CheckBox(TXT_SCALE_UP){
      @Override protected void onClick(){
        super.onClick();
        PixelDungeon.scaleUp(checked());
      }
    }
;
    btnScaleUp.setRect(0,0,WIDTH,BTN_HEIGHT);
    btnScaleUp.checked(PixelDungeon.scaleUp());
    add(btnScaleUp);
  }
  CheckBox btnMusic=new CheckBox(TXT_MUSIC){
    @Override protected void onClick(){
      super.onClick();
      PixelDungeon.music(checked());
    }
  }
;
  btnMusic.setRect(0,BTN_HEIGHT + GAP,WIDTH,BTN_HEIGHT);
  btnMusic.checked(PixelDungeon.music());
  add(btnMusic);
  CheckBox btnSound=new CheckBox(TXT_SOUND){
    @Override protected void onClick(){
      super.onClick();
      PixelDungeon.soundFx(checked());
      Sample.INSTANCE.play(Assets.SND_CLICK);
    }
  }
;
  btnSound.setRect(0,btnMusic.bottom() + GAP,WIDTH,BTN_HEIGHT);
  btnSound.checked(PixelDungeon.soundFx());
  add(btnSound);
  Button lastBtn=btnSound;
  if (!inGame) {
    Application.ApplicationType type=Gdx.app.getType();
    if (type == Application.ApplicationType.Android || type == Application.ApplicationType.iOS) {
      RedButton btnOrientation=new RedButton(orientationText()){
        @Override protected void onClick(){
          PixelDungeon.landscape(!PixelDungeon.landscape());
        }
      }
;
      btnOrientation.setRect(0,btnSound.bottom() + GAP,WIDTH,BTN_HEIGHT);
      add(btnOrientation);
      lastBtn=btnOrientation;
    }
 else     if (type == Application.ApplicationType.Desktop) {
      RedButton btnKeymap=new RedButton(TXT_BINDINGS){
        @Override protected void onClick(){
          parent.add(new WndKeymap());
        }
      }
;
      btnKeymap.setRect(0,btnSound.bottom() + GAP,WIDTH,BTN_HEIGHT);
      add(btnKeymap);
      RedButton btnResolution=new RedButton(resolutionText()){
        @Override protected void onClick(){
          PixelDungeon.fullscreen(!PixelDungeon.fullscreen());
        }
      }
;
      btnResolution.enable(PixelDungeon.instance.getPlatformSupport().isFullscreenEnabled());
      btnResolution.setRect(0,btnKeymap.bottom() + GAP,WIDTH,BTN_HEIGHT);
      add(btnResolution);
      lastBtn=btnResolution;
    }
  }
 else {
    CheckBox btnBrightness=new CheckBox(TXT_BRIGHTNESS){
      @Override protected void onClick(){
        super.onClick();
        PixelDungeon.brightness(checked());
      }
    }
;
    btnBrightness.setRect(0,btnSound.bottom() + GAP,WIDTH,BTN_HEIGHT);
    btnBrightness.checked(PixelDungeon.brightness());
    add(btnBrightness);
    lastBtn=btnBrightness;
  }
  resize(WIDTH,(int)lastBtn.bottom());
}"
11956,"@Override public boolean touchUp(int screenX,int screenY,int pointer,int button){
  eventTouch.dispatch(pointers.remove(button).up());
  return true;
}","@Override public boolean touchUp(int screenX,int screenY,int pointer,int button){
  Touch touch=pointers.remove(button);
  if (touch != null) {
    eventTouch.dispatch(touch.up());
    return true;
  }
  return false;
}"
11957,"private void populateList(){
  listContent.clear();
  tempPos=0;
  final PDInputProcessor inputProcessor=(PDInputProcessor)Game.instance.getInputProcessor();
  final Map<Integer,PDInputProcessor.GameActionWrapper> keyMappings=inputProcessor.getKeyMappings();
  final Map<GameAction,KeyPair> mappings=new TreeMap<>();
  for (  Map.Entry<Integer,PDInputProcessor.GameActionWrapper> entry : keyMappings.entrySet()) {
    final Integer key=entry.getKey();
    final PDInputProcessor.GameActionWrapper value=entry.getValue();
    final GameAction action=value.gameAction;
    KeyPair keyPair=mappings.get(action);
    if (keyPair == null) {
      mappings.put(action,keyPair=new KeyPair());
    }
    if (value.defaultKey) {
      keyPair.key1=key;
    }
 else {
      keyPair.key2=key;
    }
  }
  for (  Map.Entry<GameAction,KeyPair> entry : mappings.entrySet()) {
    addKey(listContent,width,entry);
  }
  listContent.setSize(0,tempPos);
}","private void populateList(){
  listContent.clear();
  tempPos=0;
  final PDInputProcessor inputProcessor=(PDInputProcessor)Game.instance.getInputProcessor();
  final Map<Integer,PDInputProcessor.GameActionWrapper> keyMappings=inputProcessor.getKeyMappings();
  final Map<GameAction,KeyPair> mappings=new TreeMap<>();
  for (  GameAction action : GameAction.values()) {
    if (action.getDescription() != null) {
      mappings.put(action,new KeyPair());
    }
  }
  for (  Map.Entry<Integer,PDInputProcessor.GameActionWrapper> entry : keyMappings.entrySet()) {
    final Integer key=entry.getKey();
    final PDInputProcessor.GameActionWrapper value=entry.getValue();
    final GameAction action=value.gameAction;
    KeyPair keyPair=mappings.get(action);
    if (keyPair == null) {
      mappings.put(action,keyPair=new KeyPair());
    }
    if (value.defaultKey) {
      keyPair.key1=key;
    }
 else {
      keyPair.key2=key;
    }
  }
  for (  Map.Entry<GameAction,KeyPair> entry : mappings.entrySet()) {
    addKey(listContent,width,entry);
  }
  listContent.setSize(0,tempPos);
}"
11958,"private void fetchNewRequests(FreenetURI uri){
  FetchResult fetchResult=null;
  if (!uri.hasMetaStrings()) {
    uri=uri.addMetaStrings(new String[]{""String_Node_Str""});
  }
  try {
    fetchResult=CENOClient.nodeInterface.fetchURI(uri);
  }
 catch (  FetchException e) {
switch (e.getMode()) {
case PERMANENT_REDIRECT:
      fetchNewRequests(e.newURI);
    break;
case ALL_DATA_NOT_FOUND:
case DATA_NOT_FOUND:
  Logger.warning(Channel.class,""String_Node_Str"" + uri);
break;
case RECENTLY_FAILED:
try {
Thread.sleep(TimeUnit.MINUTES.toMillis(10));
}
 catch (InterruptedException e1) {
}
 finally {
fetchNewRequests(uri);
}
return;
default :
Logger.warning(Channel.class,""String_Node_Str"" + uri + ""String_Node_Str""+ e.getMessage());
break;
}
if (e.isDefinitelyFatal()) {
Logger.error(Channel.class,""String_Node_Str"" + uri + ""String_Node_Str""+ e.getMessage());
return;
}
}
try {
String fetchedString=fetchResult.toString();
RequestReceiver.signalReceived(fetchedString.split(""String_Node_Str""));
}
 catch (NullPointerException e) {
Logger.warning(this,""String_Node_Str"");
}
return;
}","private void fetchNewRequests(FreenetURI uri){
  FetchResult fetchResult=null;
  try {
    fetchResult=CENOBridge.nodeInterface.fetchURI(uri);
  }
 catch (  FetchException e) {
switch (e.getMode()) {
case PERMANENT_REDIRECT:
      fetchNewRequests(e.newURI);
    break;
case ALL_DATA_NOT_FOUND:
case DATA_NOT_FOUND:
  Logger.warning(Channel.class,""String_Node_Str"" + uri);
break;
case RECENTLY_FAILED:
try {
Thread.sleep(TimeUnit.MINUTES.toMillis(10));
}
 catch (InterruptedException e1) {
}
 finally {
fetchNewRequests(uri);
}
return;
default :
Logger.warning(Channel.class,""String_Node_Str"" + uri + ""String_Node_Str""+ e.getMessage());
break;
}
if (e.isDefinitelyFatal()) {
Logger.error(Channel.class,""String_Node_Str"" + uri + ""String_Node_Str""+ e.getMessage());
return;
}
}
try {
String fetchedString=fetchResult.toString();
RequestReceiver.signalReceived(fetchedString.split(""String_Node_Str""));
}
 catch (NullPointerException e) {
Logger.warning(this,""String_Node_Str"");
}
return;
}"
11959,"public void runPlugin(PluginRespirator pr){
}","public void runPlugin(PluginRespirator pr){
  pluginRespirator=pr;
  client=new HighLevelSimpleClientInterface(pluginRespirator.getNode(),pluginRespirator.getHLSimpleClient());
  nodeInterface=new NodeInterface(pluginRespirator.getNode(),pluginRespirator);
  nodeInterface.initFetchContexts();
  CENOL10n.getInstance().setLanguageFromEnvVar(""String_Node_Str"");
  initConfig=new Configuration(CONFIGPATH);
  initConfig.readProperties();
  if (initConfig.getProperty(""String_Node_Str"") == null || initConfig.getProperty(""String_Node_Str"").isEmpty()) {
    Logger.warning(this,""String_Node_Str"");
    FreenetURI[] keyPair=nodeInterface.generateKeyPair();
    initConfig.setProperty(""String_Node_Str"",keyPair[0].toString());
    initConfig.setProperty(""String_Node_Str"",keyPair[1].toString());
    initConfig.storeProperties();
  }
  AsymmetricCipherKeyPair asymKeyPair;
  if (initConfig.getProperty(""String_Node_Str"") == null || initConfig.getProperty(""String_Node_Str"") == null || initConfig.getProperty(""String_Node_Str"") == null) {
    Logger.warning(this,""String_Node_Str"");
    asymKeyPair=Crypto.generateAsymKey();
    initConfig.setProperty(""String_Node_Str"",((RSAKeyParameters)asymKeyPair.getPrivate()).getExponent().toString(23));
    initConfig.setProperty(""String_Node_Str"",((RSAKeyParameters)asymKeyPair.getPublic()).getModulus().toString(32));
    initConfig.setProperty(""String_Node_Str"",((RSAKeyParameters)asymKeyPair.getPublic()).getExponent().toString(32));
    initConfig.storeProperties();
  }
 else {
    asymKeyPair=new AsymmetricCipherKeyPair(new RSAKeyParameters(false,new BigInteger(initConfig.getProperty(""String_Node_Str""),32),new BigInteger(initConfig.getProperty(""String_Node_Str""),32)),new RSAKeyParameters(true,new BigInteger(initConfig.getProperty(""String_Node_Str""),32),new BigInteger(initConfig.getProperty(""String_Node_Str""),32)));
  }
  try {
    channelMaker=new ChannelMaker(initConfig.getProperty(""String_Node_Str""),asymKeyPair);
  }
 catch (  CENOException e) {
    Logger.error(this,""String_Node_Str"");
    terminate();
  }
  String confIsMasterBridge=initConfig.getProperty(""String_Node_Str"");
  if (confIsMasterBridge != null && confIsMasterBridge.equals(""String_Node_Str"")) {
    isMasterBridge=true;
  }
  String confIsSingalBridge=initConfig.getProperty(""String_Node_Str"");
  if (confIsSingalBridge != null && confIsSingalBridge.equals(""String_Node_Str"")) {
    isSignalBridge=true;
  }
  cenoHttpServer=new Server();
  configHttpServer(cenoHttpServer);
  try {
    cenoHttpServer.start();
    cenoHttpServer.join();
  }
 catch (  InterruptedException interruptedEx) {
    Logger.normal(this,""String_Node_Str"");
    terminate();
    return;
  }
catch (  Exception ex) {
    Logger.error(this,""String_Node_Str"");
    Logger.error(this,ex.getMessage());
    terminate();
    return;
  }
}"
11960,"public static FreenetURI insertSingleChunk(FreenetURI uri,String content,ClientPutCallback cb) throws InsertException, PersistenceDisabledException, UnsupportedEncodingException {
}","public static FreenetURI insertSingleChunk(FreenetURI uri,String content,ClientPutCallback cb) throws InsertException, PersistenceDisabledException, UnsupportedEncodingException {
  RandomAccessBucket b=new SimpleReadOnlyArrayBucket(content.getBytes(""String_Node_Str""));
  InsertContext ctx=node.clientCore.makeClient((short)0,true,false).getInsertContext(true);
  ClientPutter clientPutter=new ClientPutter(cb,b,uri,null,ctx,RequestStarter.INTERACTIVE_PRIORITY_CLASS,false,null,false,node.clientCore.clientContext,null,-1L);
  node.clientCore.clientContext.start(clientPutter);
  return uri;
}"
11961,"@Override public FreenetURI insertBundleManifest(FreenetURI insertURI,String content,String defaultName,ClientPutCallback insertCb) throws IOException, InsertException {
  String defName;
  if (defaultName == null || defaultName.isEmpty()) {
    defName=""String_Node_Str"";
  }
 else {
    defName=defaultName;
  }
  Bucket bucket=node.clientCore.tempBucketFactory.makeBucket(content.length());
  BucketTools.copyFrom(bucket,new ByteArrayInputStream(content.getBytes(StandardCharsets.UTF_8),0,content.length()),content.length());
  HashMap<String,Object> bucketsByName=new HashMap<String,Object>();
  bucketsByName.put(defName,bucket);
  FreenetURI requestURI=HighLevelSimpleClientInterface.insertManifestCb(insertURI,bucketsByName,defName,RequestStarter.INTERACTIVE_PRIORITY_CLASS,null,insertCb);
  return requestURI;
}","@Override public FreenetURI insertBundleManifest(FreenetURI insertURI,String content,String defaultName,ClientPutCallback insertCb) throws IOException, InsertException {
  String defName;
  if (defaultName == null || defaultName.isEmpty()) {
    defName=""String_Node_Str"";
  }
 else {
    defName=defaultName;
  }
  Bucket bucket=node.clientCore.tempBucketFactory.makeBucket(content.getBytes().length);
  BucketTools.copyFrom(bucket,new ByteArrayInputStream(content.getBytes()),content.getBytes().length);
  HashMap<String,Object> bucketsByName=new HashMap<String,Object>();
  bucketsByName.put(defName,bucket);
  FreenetURI requestURI=HighLevelSimpleClientInterface.insertManifestCb(insertURI,bucketsByName,defName,RequestStarter.INTERACTIVE_PRIORITY_CLASS,null,insertCb);
  return requestURI;
}"
11962,"public LANGUAGE getLanguageFromEnvVar(String envVar){
  String envVal=System.getenv(envVar);
  if (envVal != null && !envVal.isEmpty()) {
    envVal=envVal.split(""String_Node_Str"")[0];
  }
  LANGUAGE lang=LANGUAGE.mapToLanguage(envVal);
  if (lang == null) {
    lang=LANGUAGE.ENGLISH;
  }
  return lang;
}","public LANGUAGE getLanguageFromEnvVar(String envVar){
  String envVal=System.getenv(envVar);
  if (envVal != null && !envVal.isEmpty()) {
    envVal=envVal.split(""String_Node_Str"")[0];
  }
 else {
    envVal=""String_Node_Str"";
  }
  LANGUAGE lang=LANGUAGE.mapToLanguage(envVal);
  return lang;
}"
11963,"public static FreenetURI insertManifestCb(FreenetURI insertURI,HashMap<String,Object> bucketsByName,String defaultName,short priorityClass,byte[] forceCryptoKey,ClientPutCallback insertCb) throws InsertException {
  DefaultManifestPutter putter;
  try {
    putter=new DefaultManifestPutter(insertCb,BaseManifestPutter.bucketsByNameToManifestEntries(bucketsByName),priorityClass,insertURI,defaultName,getInsertContext(true),false,forceCryptoKey,null);
  }
 catch (  TooManyFilesInsertException e) {
    Logger.warning(HighLevelSimpleClientInterface.class,""String_Node_Str"" + insertURI.toASCIIString());
    return null;
  }
  try {
    HLSCInterface.node.clientCore.clientContext.start(putter);
  }
 catch (  PersistenceDisabledException e) {
    Logger.warning(HighLevelSimpleClientInterface.class,""String_Node_Str"" + insertURI.toASCIIString() + ""String_Node_Str""+ e.getMessage());
    return null;
  }
  return insertURI;
}","public static FreenetURI insertManifestCb(FreenetURI insertURI,HashMap<String,Object> bucketsByName,String defaultName,short priorityClass,byte[] forceCryptoKey,ClientPutCallback insertCb) throws InsertException {
  DefaultManifestPutter putter;
  try {
    putter=new DefaultManifestPutter(insertCb,BaseManifestPutter.bucketsByNameToManifestEntries(bucketsByName),priorityClass,insertURI,defaultName,getInsertContext(true),false,forceCryptoKey,node.clientCore.clientContext);
  }
 catch (  TooManyFilesInsertException e) {
    Logger.warning(HighLevelSimpleClientInterface.class,""String_Node_Str"" + insertURI.toASCIIString());
    return null;
  }
  try {
    HLSCInterface.node.clientCore.clientContext.start(putter);
  }
 catch (  PersistenceDisabledException e) {
    Logger.warning(HighLevelSimpleClientInterface.class,""String_Node_Str"" + insertURI.toASCIIString() + ""String_Node_Str""+ e.getMessage());
    return null;
  }
  return insertURI;
}"
11964,"public static void insertBundle(String url,Bundle bundle,ClientPutCallback insertCallback) throws IOException, InsertException {
  if (bundle.getContent().isEmpty()) {
    throw new IOException();
  }
  Map<String,String> splitMap=URLtoUSKTools.splitURL(url);
  FreenetURI insertKey=URLtoUSKTools.computeInsertURI(splitMap.get(""String_Node_Str""),CENOBridge.initConfig.getProperty(""String_Node_Str""));
  insertFreesite(insertKey,splitMap.get(""String_Node_Str""),bundle.getContent(),insertCallback);
}","public static void insertBundle(String url,Bundle bundle,ClientPutCallback insertCallback) throws IOException, InsertException {
  if (bundle.getContent().isEmpty()) {
    throw new IOException();
  }
  Map<String,String> splitMap=URLtoUSKTools.splitURL(url);
  if (splitMap.get(""String_Node_Str"").isEmpty()) {
    splitMap.put(""String_Node_Str"",""String_Node_Str"");
  }
  FreenetURI insertKey=URLtoUSKTools.computeInsertURI(splitMap.get(""String_Node_Str""),CENOBridge.initConfig.getProperty(""String_Node_Str""));
  insertFreesite(insertKey,splitMap.get(""String_Node_Str""),bundle.getContent(),insertCallback);
}"
11965,"/** 
 * RequestReceiver constructor that follows the singleton pattern.
 * @param freemailBoxesArray an array of freemail boxes the requestreceiver will poll for freemails
 */
public RequestReceiver(String[] freemailBoxesArray){
synchronized (RequestReceiver.class) {
    if (requestReceiver == null) {
      requestReceiver.freemailBoxes=new LinkedList<String>();
      for (      String freemailBox : freemailBoxesArray) {
        addFreemailBox(freemailBox);
      }
    }
  }
}","/** 
 * RequestReceiver constructor that follows the singleton pattern.
 * @param freemailBoxesArray an array of freemail boxes the requestreceiver will poll for freemails
 */
public RequestReceiver(String[] freemailBoxesArray){
synchronized (RequestReceiver.class) {
    if (requestReceiver == null) {
      requestReceiver=new RequestReceiver();
      requestReceiver.freemailBoxes=new LinkedList<String>();
      for (      String freemailBox : freemailBoxesArray) {
        addFreemailBox(freemailBox);
      }
    }
  }
}"
11966,"/** 
 * Starts a thread that polls freemail boxes
 */
public void loopFreemailBoxes(){
  if (requestReceiver.fmBoxLooper != null) {
    requestReceiver.fmBoxLooper=new FreemailBoxLooper();
    requestReceiver.looperThread=new Thread(fmBoxLooper);
    requestReceiver.looperThread.start();
  }
}","/** 
 * Starts a thread that polls freemail boxes
 */
public void loopFreemailBoxes(){
  if (requestReceiver.fmBoxLooper == null) {
    requestReceiver.fmBoxLooper=new FreemailBoxLooper();
    requestReceiver.looperThread=new Thread(requestReceiver.fmBoxLooper);
    requestReceiver.looperThread.start();
  }
}"
11967,"public CENOException(CENOErrCode errCode){
  super(errCode.toString());
  this.errCode=errCode;
}","/** 
 * Constructs a CENO exception with an error code from the errorConditions doc file.
 * @param errCode the {@link CENOErrCode} correspondingto this exception
 */
public CENOException(CENOErrCode errCode){
  super(errCode.toString());
  this.errCode=errCode;
}"
11968,"protected String printStaticHTML(String filename){
  InputStream is=AbstractCENOClientHandler.class.getResourceAsStream(filename);
  if (is == null) {
    return ""String_Node_Str"";
  }
  BufferedReader br=new BufferedReader(new InputStreamReader(is));
  String line=""String_Node_Str"";
  StringBuilder htmlContent=new StringBuilder();
  try {
    while ((line=br.readLine()) != null) {
      htmlContent.append(line);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return ""String_Node_Str"";
  }
  return htmlContent.toString();
}","protected String printStaticHTML(String filename){
  InputStream is=AbstractCENOClientHandler.class.getResourceAsStream(filename);
  if (is == null) {
    return returnErrorJSON(new CENOException(CENOErrCode.LCS_HANDLER_STATIC_NOT_FOUND));
  }
  BufferedReader br=new BufferedReader(new InputStreamReader(is));
  String line=""String_Node_Str"";
  StringBuilder htmlContent=new StringBuilder();
  try {
    while ((line=br.readLine()) != null) {
      htmlContent.append(line);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return returnErrorJSON(new CENOException(CENOErrCode.LCS_HANDLER_STATIC_IO));
  }
  return htmlContent.toString();
}"
11969,"public String handleHTTPGet(HTTPRequest request) throws PluginHTTPException {
  boolean clientIsHtml=isClientHtml(request);
  String urlParam=request.getParam(""String_Node_Str"",""String_Node_Str"");
  if (urlParam.isEmpty()) {
    return ""String_Node_Str"";
  }
 else   if (Pattern.matches(""String_Node_Str"",urlParam)) {
    return ""String_Node_Str"";
  }
  FreenetURI calculatedUSK=null;
  try {
    calculatedUSK=URLtoUSKTools.computeUSKfromURL(urlParam,CENOClient.bridgeKey);
  }
 catch (  Exception e) {
    return ""String_Node_Str"";
  }
  String localFetchResult=null;
  ClientGetSyncCallback getSyncCallback=new ClientGetSyncCallback();
  try {
    CENOClient.nodeInterface.localFetchURI(calculatedUSK,getSyncCallback);
  }
 catch (  FetchException e) {
    e.printStackTrace();
  }
  localFetchResult=getSyncCallback.getResult(5L,TimeUnit.SECONDS);
  if (localFetchResult == null) {
    ulprStatus urlULPRStatus=ULPRManager.lookupULPR(urlParam);
    if (urlULPRStatus == ulprStatus.failed) {
      RequestSender.requestFromBridge(urlParam);
      if (clientIsHtml) {
        return printStaticHTMLReplace(""String_Node_Str"",""String_Node_Str"",urlParam);
      }
 else {
        JSONObject jsonResponse=new JSONObject();
        jsonResponse.put(""String_Node_Str"",true);
        jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
        return jsonResponse.toJSONString();
      }
    }
 else {
      if (clientIsHtml) {
        return printStaticHTMLReplace(""String_Node_Str"",""String_Node_Str"",urlParam);
      }
 else {
        JSONObject jsonResponse=new JSONObject();
        jsonResponse.put(""String_Node_Str"",false);
        return jsonResponse.toJSONString();
      }
    }
  }
 else {
    if (clientIsHtml) {
      return localFetchResult;
    }
 else {
      JSONObject jsonResponse=new JSONObject();
      jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
      jsonResponse.put(""String_Node_Str"",true);
      jsonResponse.put(""String_Node_Str"",localFetchResult);
      return jsonResponse.toJSONString();
    }
  }
}","public String handleHTTPGet(HTTPRequest request) throws PluginHTTPException {
  boolean clientIsHtml=isClientHtml(request);
  String urlParam=request.getParam(""String_Node_Str"",""String_Node_Str"");
  if (urlParam.isEmpty()) {
    return returnErrorJSON(new CENOException(CENOErrCode.LCS_HANDLER_INVALID_URL));
  }
 else   if (urlParam.startsWith(""String_Node_Str"")) {
    urlParam=urlParam.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (Pattern.matches(""String_Node_Str"",urlParam)) {
    return returnErrorJSON(new CENOException(CENOErrCode.LCS_HANDLER_INVALID_URL));
  }
  FreenetURI calculatedUSK=null;
  try {
    calculatedUSK=URLtoUSKTools.computeUSKfromURL(urlParam,CENOClient.bridgeKey);
  }
 catch (  Exception e) {
    return returnErrorJSON(new CENOException(CENOErrCode.LCS_HANDLER_INVALID_URL));
  }
  String localFetchResult=null;
  ClientGetSyncCallback getSyncCallback=new ClientGetSyncCallback();
  try {
    CENOClient.nodeInterface.localFetchURI(calculatedUSK,getSyncCallback);
  }
 catch (  FetchException e) {
    e.printStackTrace();
  }
  localFetchResult=getSyncCallback.getResult(5L,TimeUnit.SECONDS);
  if (localFetchResult == null) {
    ulprStatus urlULPRStatus=ULPRManager.lookupULPR(urlParam);
    RequestSender.requestFromBridge(urlParam);
    if (urlULPRStatus == ulprStatus.failed) {
      if (clientIsHtml) {
        return printStaticHTMLReplace(""String_Node_Str"",""String_Node_Str"",urlParam);
      }
 else {
        JSONObject jsonResponse=new JSONObject();
        jsonResponse.put(""String_Node_Str"",true);
        jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
        return jsonResponse.toJSONString();
      }
    }
 else {
      if (clientIsHtml) {
        return printStaticHTMLReplace(""String_Node_Str"",""String_Node_Str"",urlParam);
      }
 else {
        JSONObject jsonResponse=new JSONObject();
        jsonResponse.put(""String_Node_Str"",false);
        return jsonResponse.toJSONString();
      }
    }
  }
 else {
    if (clientIsHtml) {
      return localFetchResult;
    }
 else {
      JSONObject jsonResponse=new JSONObject();
      jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
      jsonResponse.put(""String_Node_Str"",true);
      jsonResponse.put(""String_Node_Str"",localFetchResult);
      return jsonResponse.toJSONString();
    }
  }
}"
11970,"public void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  String requestPath=request.getPathInfo().substring(1);
  String urlParam=(request.getParameter(""String_Node_Str"") != null) ? request.getParameter(""String_Node_Str"") : requestPath;
  if (urlParam.isEmpty() && requestPath.isEmpty()) {
    writeWelcome(baseRequest,response,requestPath);
    return;
  }
 else   if (requestPath.startsWith(""String_Node_Str"") || requestPath.startsWith(""String_Node_Str"")) {
    FetchResult result=null;
    try {
      result=HighLevelSimpleClientInterface.fetchURI(new FreenetURI(requestPath));
    }
 catch (    MalformedURLException e) {
      writeError(baseRequest,response,requestPath);
      return;
    }
catch (    FetchException e) {
      if (e.getMode() == FetchExceptionMode.PERMANENT_REDIRECT) {
        String newURI=""String_Node_Str"".concat(e.newURI.toString());
        response.sendRedirect(newURI);
      }
 else       if (e.isDNF()) {
        JSONObject jsonResponse=new JSONObject();
        response.setStatus(HttpServletResponse.SC_NOT_FOUND);
        jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
        response.setContentType(""String_Node_Str"");
        response.getOutputStream().println(jsonResponse.toJSONString());
        baseRequest.setHandled(true);
        return;
      }
 else {
        e.printStackTrace();
        writeError(baseRequest,response,requestPath);
        return;
      }
    }
    if (result != null) {
      Bundle bundle=new Bundle(urlParam);
      bundle.setContent(result.asByteArray());
      response.setContentType(result.getMimeType());
      response.setStatus(HttpServletResponse.SC_OK);
      response.setContentType(""String_Node_Str"");
      JSONObject jsonResponse=new JSONObject();
      jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
      jsonResponse.put(""String_Node_Str"",bundle.getContent());
      response.getOutputStream().println(jsonResponse.toJSONString());
    }
 else {
      writeError(baseRequest,response,requestPath);
    }
  }
 else {
    FreenetURI calculatedUSK=null;
    try {
      calculatedUSK=computeUSKfromURL(urlParam);
    }
 catch (    Exception e) {
      writeError(baseRequest,response,requestPath);
      return;
    }
    response.sendRedirect(""String_Node_Str"" + calculatedUSK.toString());
    baseRequest.setHandled(true);
  }
}","public void handle(String target,Request baseRequest,HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  String requestPath=request.getPathInfo().substring(1);
  String urlParam=(request.getParameter(""String_Node_Str"") != null) ? request.getParameter(""String_Node_Str"") : requestPath;
  if (urlParam.isEmpty() && requestPath.isEmpty()) {
    writeWelcome(baseRequest,response,requestPath);
  }
 else   if (requestPath.startsWith(""String_Node_Str"") || requestPath.startsWith(""String_Node_Str"")) {
    FetchResult result=null;
    try {
      result=HighLevelSimpleClientInterface.fetchURI(new FreenetURI(requestPath));
    }
 catch (    MalformedURLException e) {
      writeError(baseRequest,response,requestPath);
      return;
    }
catch (    FetchException e) {
      if (e.getMode() == FetchExceptionMode.PERMANENT_REDIRECT) {
        String newURI=""String_Node_Str"".concat(e.newURI.toString());
        response.sendRedirect(newURI);
      }
 else       if (e.isDNF()) {
        JSONObject jsonResponse=new JSONObject();
        jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
        response.setStatus(HttpServletResponse.SC_NOT_FOUND);
        response.setContentType(""String_Node_Str"");
        response.getWriter().print(jsonResponse.toJSONString());
        baseRequest.setHandled(true);
        return;
      }
 else {
        e.printStackTrace();
        writeError(baseRequest,response,requestPath);
        return;
      }
    }
    if (result != null) {
      Bundle bundle=new Bundle(urlParam);
      bundle.setContent(result.asByteArray());
      response.setContentType(result.getMimeType());
      response.setStatus(HttpServletResponse.SC_OK);
      response.setContentType(""String_Node_Str"");
      JSONObject jsonResponse=new JSONObject();
      jsonResponse.put(""String_Node_Str"",""String_Node_Str"");
      jsonResponse.put(""String_Node_Str"",bundle.getContent());
      response.getWriter().print(jsonResponse.toJSONString());
      baseRequest.setHandled(true);
      return;
    }
 else {
      writeError(baseRequest,response,requestPath);
    }
  }
 else   if (requestPath.equals(""String_Node_Str"")) {
    writeNotFound(baseRequest,response,requestPath);
  }
 else {
    FreenetURI calculatedUSK=null;
    try {
      calculatedUSK=computeUSKfromURL(urlParam);
    }
 catch (    Exception e) {
      writeError(baseRequest,response,requestPath);
      return;
    }
    response.sendRedirect(""String_Node_Str"" + calculatedUSK.toString());
    baseRequest.setHandled(true);
  }
}"
11971,"protected void writeWelcome(Request baseRequest,HttpServletResponse response,String requestPath) throws IOException {
  response.setContentType(""String_Node_Str"");
  response.setStatus(HttpServletResponse.SC_OK);
  response.getWriter().println(""String_Node_Str"");
  baseRequest.setHandled(true);
}","protected void writeWelcome(Request baseRequest,HttpServletResponse response,String requestPath) throws IOException {
  response.setContentType(""String_Node_Str"");
  response.setStatus(HttpServletResponse.SC_OK);
  response.getWriter().print(""String_Node_Str"");
  baseRequest.setHandled(true);
}"
11972,"protected void writeError(Request baseRequest,HttpServletResponse response,String requestPath) throws IOException {
  response.setContentType(""String_Node_Str"");
  response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  response.getWriter().println(""String_Node_Str"" + requestPath);
  baseRequest.setHandled(true);
}","protected void writeError(Request baseRequest,HttpServletResponse response,String requestPath) throws IOException {
  response.setContentType(""String_Node_Str"");
  response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
  response.getWriter().print(""String_Node_Str"" + requestPath);
  baseRequest.setHandled(true);
}"
11973,"/** 
 * This method provide dcos and sso token to be used to generate client cookie
 * @return cookieToken list of token generated
 * @throws Exception exception
 */
public HashMap<String,String> ssoTokenGenerator() throws Exception {
  String protocol=""String_Node_Str"";
  HashMap<String,String> cookieToken=new HashMap<>();
  SSLContext sslContext=SSLContext.getInstance(""String_Node_Str"");
  sslContext.init(null,ALL_TRUSTING_TRUST_MANAGER,new SecureRandom());
  HttpClientContext context=HttpClientContext.create();
  HttpGet httpGet=new HttpGet(protocol + ssoHost + ""String_Node_Str"");
  HttpClient client=HttpClientBuilder.create().setSslcontext(sslContext).setRedirectStrategy(new LaxRedirectStrategy()).setDefaultRequestConfig(RequestConfig.custom().setCircularRedirectsAllowed(true).build()).build();
  try {
    HttpResponse firstResponse=client.execute(httpGet,context);
    logger.debug(firstResponse.getStatusLine().toString());
    Document doc=Jsoup.parse(getStringFromIS(firstResponse.getEntity().getContent()));
    Elements code=doc.select(""String_Node_Str"");
    String loginCode=code.attr(""String_Node_Str"");
    String executionCode=doc.select(""String_Node_Str"").attr(""String_Node_Str"");
    for (    Header oneHeader : firstResponse.getAllHeaders()) {
      logger.debug(oneHeader.getName() + ""String_Node_Str"" + oneHeader.getValue());
    }
    URI redirect=context.getRedirectLocations().get(context.getRedirectLocations().size() - 1);
    List<NameValuePair> params=new ArrayList<>();
    params.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
    params.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
    params.add(new BasicNameValuePair(""String_Node_Str"",userName));
    params.add(new BasicNameValuePair(""String_Node_Str"",passWord));
    if (!tenant.isEmpty()) {
      params.add(new BasicNameValuePair(""String_Node_Str"",tenant));
    }
    params.add(new BasicNameValuePair(""String_Node_Str"",loginCode));
    params.add(new BasicNameValuePair(""String_Node_Str"",executionCode));
    HttpPost httpPost=new HttpPost(redirect);
    httpPost.setEntity(new UrlEncodedFormEntity(params));
    HttpResponse secondResponse=client.execute(httpPost,context);
    for (    Header oneHeader : secondResponse.getAllHeaders()) {
      logger.debug(oneHeader.getName() + ""String_Node_Str"" + oneHeader.getValue());
    }
    HttpGet managementGet=new HttpGet(protocol + ssoHost + managementHost);
    client.execute(managementGet,context);
    for (    Cookie oneCookie : context.getCookieStore().getCookies()) {
      logger.debug(oneCookie.getName() + ""String_Node_Str"" + oneCookie.getValue());
      cookieToken.put(oneCookie.getName(),oneCookie.getValue());
    }
  }
 catch (  Exception e) {
    e.getStackTrace();
  }
  return cookieToken;
}","/** 
 * This method provide dcos and sso token to be used to generate client cookie
 * @return cookieToken list of token generated
 * @throws Exception exception
 */
public HashMap<String,String> ssoTokenGenerator() throws Exception {
  String protocol=""String_Node_Str"";
  HashMap<String,String> cookieToken=new HashMap<>();
  SSLContext sslContext=SSLContext.getInstance(""String_Node_Str"");
  sslContext.init(null,ALL_TRUSTING_TRUST_MANAGER,new SecureRandom());
  HttpClientContext context=HttpClientContext.create();
  HttpGet httpGet=new HttpGet(protocol + ssoHost + ""String_Node_Str"");
  HttpClient client=HttpClientBuilder.create().setSslcontext(sslContext).setRedirectStrategy(new LaxRedirectStrategy()).setDefaultRequestConfig(RequestConfig.custom().setCircularRedirectsAllowed(true).build()).build();
  try {
    HttpResponse firstResponse=client.execute(httpGet,context);
    logger.debug(firstResponse.getStatusLine().toString());
    Document doc=Jsoup.parse(getStringFromIS(firstResponse.getEntity().getContent()));
    Elements code=doc.select(""String_Node_Str"");
    String loginCode=code.attr(""String_Node_Str"");
    String executionCode=doc.select(""String_Node_Str"").attr(""String_Node_Str"");
    for (    Header oneHeader : firstResponse.getAllHeaders()) {
      logger.debug(oneHeader.getName() + ""String_Node_Str"" + oneHeader.getValue());
    }
    URI redirect=context.getRedirectLocations().get(context.getRedirectLocations().size() - 1);
    List<NameValuePair> params=new ArrayList<>();
    params.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
    params.add(new BasicNameValuePair(""String_Node_Str"",""String_Node_Str""));
    params.add(new BasicNameValuePair(""String_Node_Str"",userName));
    params.add(new BasicNameValuePair(""String_Node_Str"",passWord));
    if (tenant != null) {
      params.add(new BasicNameValuePair(""String_Node_Str"",tenant));
    }
    params.add(new BasicNameValuePair(""String_Node_Str"",loginCode));
    params.add(new BasicNameValuePair(""String_Node_Str"",executionCode));
    HttpPost httpPost=new HttpPost(redirect);
    httpPost.setEntity(new UrlEncodedFormEntity(params));
    HttpResponse secondResponse=client.execute(httpPost,context);
    for (    Header oneHeader : secondResponse.getAllHeaders()) {
      logger.debug(oneHeader.getName() + ""String_Node_Str"" + oneHeader.getValue());
    }
    HttpGet managementGet=new HttpGet(protocol + ssoHost + managementHost);
    client.execute(managementGet,context);
    for (    Cookie oneCookie : context.getCookieStore().getCookies()) {
      logger.debug(oneCookie.getName() + ""String_Node_Str"" + oneCookie.getValue());
      cookieToken.put(oneCookie.getName(),oneCookie.getValue());
    }
  }
 catch (  Exception e) {
    e.getStackTrace();
  }
  return cookieToken;
}"
11974,"/** 
 * Execute the command in the session created
 * @param command
 */
public void runCommand(String command) throws Exception {
  String result=""String_Node_Str"";
  Channel channel=session.openChannel(""String_Node_Str"");
  ((ChannelExec)channel).setCommand(command);
  channel.setInputStream(null);
  ((ChannelExec)channel).setErrStream(System.err);
  InputStream in=channel.getInputStream();
  ((ChannelExec)channel).setPty(true);
  channel.connect();
  byte[] tmp=new byte[1024];
  while (true) {
    while (in.available() > 0) {
      int i=in.read(tmp,0,1024);
      if (i < 0) {
        break;
      }
      result=result + new String(tmp,0,i);
    }
    this.result=result;
    this.setResult(result);
    if (channel.isClosed()) {
      if (in.available() > 0) {
        continue;
      }
      this.exitStatus=channel.getExitStatus();
      break;
    }
    try {
      Thread.sleep(1000);
    }
 catch (    Exception ee) {
    }
  }
  channel.disconnect();
}","/** 
 * Execute the command in the session created
 * @param command
 */
public void runCommand(String command) throws Exception {
  String result=""String_Node_Str"";
  String extras=""String_Node_Str"";
  Channel channel=session.openChannel(""String_Node_Str"");
  ((ChannelExec)channel).setCommand(extras + command);
  channel.setInputStream(null);
  ((ChannelExec)channel).setErrStream(System.err);
  InputStream in=channel.getInputStream();
  ((ChannelExec)channel).setPty(true);
  channel.connect();
  byte[] tmp=new byte[1024];
  while (true) {
    while (in.available() > 0) {
      int i=in.read(tmp,0,1024);
      if (i < 0) {
        break;
      }
      result=result + new String(tmp,0,i);
    }
    this.result=result;
    this.setResult(result);
    if (channel.isClosed()) {
      if (in.available() > 0) {
        continue;
      }
      this.exitStatus=channel.getExitStatus();
      break;
    }
    try {
      Thread.sleep(1000);
    }
 catch (    Exception ee) {
    }
  }
  channel.disconnect();
}"
11975,"/** 
 * Finish.
 * @param doc
 * @param element
 * @param position
 * @param tags
 */
public void finish(Document doc,Element element,Integer position,List<Tag> tags,Document docJunit,Element Junit) throws ExecutionException, InterruptedException, IOException {
  Junit.setAttribute(""String_Node_Str"",String.valueOf(calculateTotalDurationString() / 1000));
  element.setAttribute(""String_Node_Str"",String.valueOf(calculateTotalDurationString()));
  element.setAttribute(""String_Node_Str"",DATE_FORMAT.format(new Date()));
  StringBuilder stringBuilder=new StringBuilder();
  List<Step> mergedsteps=new ArrayList<Step>();
  if (stepsbg != null) {
    mergedsteps.addAll(stepsbg);
    mergedsteps.addAll(steps);
  }
 else {
    mergedsteps.addAll(steps);
  }
  addStepAndResultListing(stringBuilder,mergedsteps);
  Result skipped=null;
  Result failed=null;
  Boolean ignored=false;
  Boolean ignoreReason=false;
  String exceptionmsg=""String_Node_Str"";
  AsyncHttpClient client=new AsyncHttpClient();
  Future<Response> response=null;
  Boolean isJiraTicketDone=false;
  Boolean isWrongTicket=false;
  CommonG comm=new CommonG();
  String userJira=System.getProperty(""String_Node_Str"");
  String passJira=System.getProperty(""String_Node_Str"");
  Logger logger=LoggerFactory.getLogger(ThreadProperty.get(""String_Node_Str""));
  String value=""String_Node_Str"";
  for (  Tag tag : tags) {
    if (""String_Node_Str"".equals(tag.getName())) {
      ignored=true;
      for (      Tag tagNs : tags) {
        if (!(tagNs.getName().equals(""String_Node_Str""))) {
          String tillFix=tagNs.getName();
          if (tillFix.startsWith(""String_Node_Str"")) {
            Pattern pattern=Pattern.compile(""String_Node_Str"");
            Matcher matcher=pattern.matcher(tillFix);
            String issue=""String_Node_Str"";
            if (matcher.find()) {
              issue=matcher.group(2);
            }
 else {
              isWrongTicket=true;
            }
            if (((userJira != null) || (passJira != null)) && (issue != ""String_Node_Str"")) {
              byte[] encodedBytes=Base64.encodeBase64(userJira.getBytes());
              byte[] encodedBytes2=Base64.encodeBase64(passJira.getBytes());
              String codeBase64=""String_Node_Str"" + encodedBytes + ""String_Node_Str""+ encodedBytes2;
              comm.setRestHost(""String_Node_Str"");
              comm.setRestPort(""String_Node_Str"");
              comm.setClient(client);
              String endpoint=""String_Node_Str"" + issue;
              try {
                response=comm.generateRequest(""String_Node_Str"",true,endpoint,""String_Node_Str"",""String_Node_Str"",codeBase64);
                comm.setResponse(endpoint,response.get());
              }
 catch (              Exception e) {
                logger.error(""String_Node_Str"" + String.valueOf(comm.getResponse().getStatusCode()));
              }
              String json=comm.getResponse().getResponse();
              try {
                value=JsonPath.read(json,""String_Node_Str"");
              }
 catch (              PathNotFoundException pe) {
                logger.error(""String_Node_Str"");
              }
              if (value.equals(""String_Node_Str"")) {
                isWrongTicket=true;
              }
 else               if (""String_Node_Str"".equals(value.toLowerCase()) || ""String_Node_Str"".equals(value.toLowerCase())) {
                isJiraTicketDone=true;
              }
            }
            exceptionmsg=""String_Node_Str"" + issue;
            ignoreReason=true;
            break;
          }
          if (tagNs.getName().matches(""String_Node_Str"")) {
            exceptionmsg=""String_Node_Str"";
            ignoreReason=true;
            break;
          }
          if (tagNs.getName().matches(""String_Node_Str"")) {
            ignoreReason=true;
            exceptionmsg=""String_Node_Str"";
            break;
          }
          if (tagNs.getName().matches(""String_Node_Str"")) {
            exceptionmsg=""String_Node_Str"";
            ignoreReason=true;
            break;
          }
        }
      }
    }
    String msg1=null;
    String msg2=null;
    if (ignored && (!ignoreReason || (ignoreReason && isJiraTicketDone) || (ignoreReason && isWrongTicket))) {
      element.setAttribute(STATUS,""String_Node_Str"");
      if (isJiraTicketDone) {
        msg1=""String_Node_Str"";
        msg2=""String_Node_Str"";
      }
 else       if (isWrongTicket) {
        msg1=""String_Node_Str"";
        msg2=""String_Node_Str"";
      }
 else {
        msg1=""String_Node_Str"";
        msg2=""String_Node_Str"";
      }
      Element exception=createException(doc,msg1,msg1,msg2);
      element.appendChild(exception);
      Element systemOut=createExceptionJunit(docJunit,msg1,msg1,msg2);
      Junit.appendChild(systemOut);
    }
 else     if (ignored && ignoreReason) {
      element.setAttribute(STATUS,""String_Node_Str"");
      Element exception=createException(doc,""String_Node_Str"",exceptionmsg,""String_Node_Str"");
      element.appendChild(exception);
      Element skippedElementJunit=docJunit.createElement(""String_Node_Str"");
      Junit.appendChild(skippedElementJunit);
      Element systemOut=systemOutPrintJunit(docJunit,exceptionmsg);
      Junit.appendChild(systemOut);
    }
 else {
      for (      Result result : results) {
        if (""String_Node_Str"".equals(result.getStatus())) {
          failed=result;
        }
 else         if (""String_Node_Str"".equals(result.getStatus()) || ""String_Node_Str"".equals(result.getStatus())) {
          skipped=result;
        }
      }
      for (      Result result : hooks) {
        if (failed == null && ""String_Node_Str"".equals(result.getStatus())) {
          failed=result;
        }
      }
      if (failed != null) {
        element.setAttribute(STATUS,""String_Node_Str"");
        StringWriter stringWriter=new StringWriter();
        failed.getError().printStackTrace(new PrintWriter(stringWriter));
        Element exception=createException(doc,failed.getError().getClass().getName(),stringBuilder.toString(),stringWriter.toString());
        element.appendChild(exception);
        Element exceptionJunit=createExceptionJunit(docJunit,failed.getError().getClass().getName(),stringBuilder.toString(),stringWriter.toString());
        Junit.appendChild(exceptionJunit);
      }
 else       if (skipped != null) {
        if (treatSkippedAsFailure) {
          element.setAttribute(STATUS,""String_Node_Str"");
          Element exception=createException(doc,""String_Node_Str"",stringBuilder.toString(),""String_Node_Str"");
          element.appendChild(exception);
          Element exceptionJunit=createExceptionJunit(docJunit,""String_Node_Str"",stringBuilder.toString(),""String_Node_Str"");
          Junit.appendChild(exceptionJunit);
        }
 else {
          element.setAttribute(STATUS,""String_Node_Str"");
          Element skippedElementJunit=docJunit.createElement(""String_Node_Str"");
          Junit.appendChild(skippedElementJunit);
          Element systemOut=systemOutPrintJunit(docJunit,stringBuilder.toString());
          Junit.appendChild(systemOut);
        }
      }
 else {
        element.setAttribute(STATUS,""String_Node_Str"");
        Element exception=createException(doc,""String_Node_Str"",stringBuilder.toString(),""String_Node_Str"");
        element.appendChild(exception);
        Element systemOut=systemOutPrintJunit(docJunit,stringBuilder.toString());
        Junit.appendChild(systemOut);
      }
    }
  }
}","/** 
 * Finish.
 * @param doc
 * @param element
 * @param position
 * @param tags
 */
public void finish(Document doc,Element element,Integer position,List<Tag> tags,Document docJunit,Element Junit) throws ExecutionException, InterruptedException, IOException {
  Junit.setAttribute(""String_Node_Str"",String.valueOf(calculateTotalDurationString() / 1000));
  element.setAttribute(""String_Node_Str"",String.valueOf(calculateTotalDurationString()));
  element.setAttribute(""String_Node_Str"",DATE_FORMAT.format(new Date()));
  StringBuilder stringBuilder=new StringBuilder();
  List<Step> mergedsteps=new ArrayList<Step>();
  if (stepsbg != null) {
    mergedsteps.addAll(stepsbg);
    mergedsteps.addAll(steps);
  }
 else {
    mergedsteps.addAll(steps);
  }
  addStepAndResultListing(stringBuilder,mergedsteps);
  Result skipped=null;
  Result failed=null;
  Boolean ignored=false;
  Boolean ignoreReason=false;
  String exceptionmsg=""String_Node_Str"";
  AsyncHttpClient client=new AsyncHttpClient();
  Future<Response> response=null;
  Boolean isJiraTicketDone=false;
  Boolean isWrongTicket=false;
  CommonG comm=new CommonG();
  String userJira=System.getProperty(""String_Node_Str"");
  String passJira=System.getProperty(""String_Node_Str"");
  Logger logger=LoggerFactory.getLogger(ThreadProperty.get(""String_Node_Str""));
  String value=""String_Node_Str"";
  for (  Tag tag : tags) {
    if (""String_Node_Str"".equals(tag.getName())) {
      ignored=true;
      for (      Tag tagNs : tags) {
        if (!(tagNs.getName().equals(""String_Node_Str""))) {
          String tillFix=tagNs.getName();
          if (tillFix.startsWith(""String_Node_Str"")) {
            Pattern pattern=Pattern.compile(""String_Node_Str"");
            Matcher matcher=pattern.matcher(tillFix);
            String issue=""String_Node_Str"";
            if (matcher.find()) {
              issue=matcher.group(2);
            }
 else {
              isWrongTicket=true;
            }
            if (((userJira != null) || (passJira != null)) && (issue != ""String_Node_Str"")) {
              String data=userJira + ""String_Node_Str"" + passJira;
              byte[] encodedBytes=Base64.encodeBase64(data.getBytes());
              String encodedString=new String(encodedBytes);
              String codeBase64=""String_Node_Str"" + encodedString;
              comm.setRestHost(""String_Node_Str"");
              comm.setRestPort(""String_Node_Str"");
              comm.setClient(client);
              String endpoint=""String_Node_Str"" + issue;
              try {
                response=comm.generateRequest(""String_Node_Str"",true,endpoint,""String_Node_Str"",""String_Node_Str"",codeBase64);
                comm.setResponse(endpoint,response.get());
              }
 catch (              Exception e) {
                logger.error(""String_Node_Str"" + String.valueOf(comm.getResponse().getStatusCode()));
              }
              String json=comm.getResponse().getResponse();
              try {
                value=JsonPath.read(json,""String_Node_Str"");
              }
 catch (              PathNotFoundException pe) {
                logger.error(""String_Node_Str"");
              }
              if (value.equals(""String_Node_Str"")) {
                isWrongTicket=true;
              }
 else               if (""String_Node_Str"".equals(value.toLowerCase()) || ""String_Node_Str"".equals(value.toLowerCase())) {
                isJiraTicketDone=true;
              }
            }
            exceptionmsg=""String_Node_Str"" + issue;
            ignoreReason=true;
            break;
          }
          if (tagNs.getName().matches(""String_Node_Str"")) {
            exceptionmsg=""String_Node_Str"";
            ignoreReason=true;
            break;
          }
          if (tagNs.getName().matches(""String_Node_Str"")) {
            ignoreReason=true;
            exceptionmsg=""String_Node_Str"";
            break;
          }
          if (tagNs.getName().matches(""String_Node_Str"")) {
            exceptionmsg=""String_Node_Str"";
            ignoreReason=true;
            break;
          }
        }
      }
    }
    String msg1=null;
    String msg2=null;
    if (ignored && (!ignoreReason || (ignoreReason && isJiraTicketDone) || (ignoreReason && isWrongTicket))) {
      element.setAttribute(STATUS,""String_Node_Str"");
      if (isJiraTicketDone) {
        msg1=""String_Node_Str"";
        msg2=""String_Node_Str"";
      }
 else       if (isWrongTicket) {
        msg1=""String_Node_Str"";
        msg2=""String_Node_Str"";
      }
 else {
        msg1=""String_Node_Str"";
        msg2=""String_Node_Str"";
      }
      Element exception=createException(doc,msg1,msg1,msg2);
      element.appendChild(exception);
      Element systemOut=createExceptionJunit(docJunit,msg1,msg1,msg2);
      Junit.appendChild(systemOut);
    }
 else     if (ignored && ignoreReason) {
      element.setAttribute(STATUS,""String_Node_Str"");
      Element exception=createException(doc,""String_Node_Str"",exceptionmsg,""String_Node_Str"");
      element.appendChild(exception);
      Element skippedElementJunit=docJunit.createElement(""String_Node_Str"");
      Junit.appendChild(skippedElementJunit);
      Element systemOut=systemOutPrintJunit(docJunit,exceptionmsg);
      Junit.appendChild(systemOut);
    }
 else {
      for (      Result result : results) {
        if (""String_Node_Str"".equals(result.getStatus())) {
          failed=result;
        }
 else         if (""String_Node_Str"".equals(result.getStatus()) || ""String_Node_Str"".equals(result.getStatus())) {
          skipped=result;
        }
      }
      for (      Result result : hooks) {
        if (failed == null && ""String_Node_Str"".equals(result.getStatus())) {
          failed=result;
        }
      }
      if (failed != null) {
        element.setAttribute(STATUS,""String_Node_Str"");
        StringWriter stringWriter=new StringWriter();
        failed.getError().printStackTrace(new PrintWriter(stringWriter));
        Element exception=createException(doc,failed.getError().getClass().getName(),stringBuilder.toString(),stringWriter.toString());
        element.appendChild(exception);
        Element exceptionJunit=createExceptionJunit(docJunit,failed.getError().getClass().getName(),stringBuilder.toString(),stringWriter.toString());
        Junit.appendChild(exceptionJunit);
      }
 else       if (skipped != null) {
        if (treatSkippedAsFailure) {
          element.setAttribute(STATUS,""String_Node_Str"");
          Element exception=createException(doc,""String_Node_Str"",stringBuilder.toString(),""String_Node_Str"");
          element.appendChild(exception);
          Element exceptionJunit=createExceptionJunit(docJunit,""String_Node_Str"",stringBuilder.toString(),""String_Node_Str"");
          Junit.appendChild(exceptionJunit);
        }
 else {
          element.setAttribute(STATUS,""String_Node_Str"");
          Element skippedElementJunit=docJunit.createElement(""String_Node_Str"");
          Junit.appendChild(skippedElementJunit);
          Element systemOut=systemOutPrintJunit(docJunit,stringBuilder.toString());
          Junit.appendChild(systemOut);
        }
      }
 else {
        element.setAttribute(STATUS,""String_Node_Str"");
        Element exception=createException(doc,""String_Node_Str"",stringBuilder.toString(),""String_Node_Str"");
        element.appendChild(exception);
        Element systemOut=systemOutPrintJunit(docJunit,stringBuilder.toString());
        Junit.appendChild(systemOut);
      }
    }
  }
}"
11976,"public boolean dropAllIndexes(){
  ImmutableOpenMap<String,ImmutableOpenMap<String,AliasMetaData>> indexes=this.client.admin().cluster().prepareState().execute().actionGet().getState().getMetaData().aliases();
  return false;
}","public boolean dropAllIndexes(){
  boolean result=true;
  ImmutableOpenMap<String,IndexMetaData> indexes=this.client.admin().cluster().prepareState().execute().actionGet().getState().getMetaData().getIndices();
  for (  String indexName : indexes.keys().toArray(String.class)) {
    DeleteIndexRequest deleteIndexRequest=new DeleteIndexRequest(indexName);
    DeleteIndexResponse res=this.client.admin().indices().delete(deleteIndexRequest).actionGet();
    result=indexExists(indexName);
  }
  return result;
}"
11977,"/** 
 * Checks the different results of a previous query
 * @param expectedResults: A DataTable Object with all data needed for check the results. The DataTable must contains at least 2 columns:a) A field column from the result b) Occurrences column (Integer type) Example: |latitude| longitude|place     |occurrences| |12.5    |12.7      |Valencia  |1           | |2.5     | 2.6      |Stratio   |0           | |12.5    |13.7      |Sevilla   |1           | IMPORTANT: There no should be no existing columns 
 * @throws Exception
 */
@Then(""String_Node_Str"") public void resultsMustBe(DataTable expectedResults) throws Exception {
  String type=commonspec.getResultsType();
  assertThat(type).isNotEqualTo(""String_Node_Str"").overridingErrorMessage(""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
    if (commonspec.getResults() != null) {
      ColumnDefinitions columns=commonspec.getResults().getColumnDefinitions();
      List<Row> rows=commonspec.getResults().all();
      List<Map<String,Object>> resultsListObtained=new ArrayList<Map<String,Object>>();
      Map<String,Object> results;
      for (int i=0; i < rows.size(); i++) {
        results=new HashMap<String,Object>();
        for (int e=0; e < columns.size(); e++) {
          results.put(columns.getName(e),rows.get(i).getObject(e));
        }
        resultsListObtained.add(results);
      }
      List<Map<String,Object>> resultsListExpected=new ArrayList<Map<String,Object>>();
      Map<String,Object> resultsCucumber;
      for (int e=1; e < expectedResults.getGherkinRows().size(); e++) {
        resultsCucumber=new HashMap<String,Object>();
        for (int i=0; i < expectedResults.getGherkinRows().get(0).getCells().size(); i++) {
          resultsCucumber.put(expectedResults.getGherkinRows().get(0).getCells().get(i),expectedResults.getGherkinRows().get(e).getCells().get(i));
        }
        resultsListExpected.add(resultsCucumber);
      }
      int occurrencesObtained=0;
      int iterations=0;
      int occurrencesExpected=0;
      String nextKey;
      for (int e=0; e < resultsListExpected.size(); e++) {
        iterations=0;
        occurrencesObtained=0;
        occurrencesExpected=Integer.parseInt(resultsListExpected.get(e).get(""String_Node_Str"").toString());
        for (int i=0; i < resultsListObtained.size(); i++) {
          Iterator<String> it=resultsListExpected.get(0).keySet().iterator();
          while (it.hasNext()) {
            nextKey=it.next();
            if (!nextKey.equals(""String_Node_Str"")) {
              if (resultsListObtained.get(i).get(nextKey).toString().equals(resultsListExpected.get(e).get(nextKey).toString())) {
                iterations++;
              }
            }
            if (iterations == resultsListExpected.get(0).keySet().size() - 1) {
              occurrencesObtained++;
            }
          }
          iterations=0;
        }
        assertThat(occurrencesExpected).overridingErrorMessage(""String_Node_Str"" + e + ""String_Node_Str""+ occurrencesObtained+ ""String_Node_Str""+ occurrencesExpected+ ""String_Node_Str"").isEqualTo(occurrencesObtained);
      }
    }
 else {
      throw new Exception(""String_Node_Str"");
    }
  break;
}
}","/** 
 * Checks the different results of a previous query
 * @param expectedResults: A DataTable Object with all data needed for check the results. The DataTable must contains at least 2 columns:a) A field column from the result b) Occurrences column (Integer type) Example: |latitude| longitude|place     |occurrences| |12.5    |12.7      |Valencia  |1           | |2.5     | 2.6      |Stratio   |0           | |12.5    |13.7      |Sevilla   |1           | IMPORTANT: There no should be no existing columns 
 * @throws Exception
 */
@Then(""String_Node_Str"") public void resultsMustBe(DataTable expectedResults) throws Exception {
  String type=commonspec.getResultsType();
  assertThat(type).isNotEqualTo(""String_Node_Str"").overridingErrorMessage(""String_Node_Str"");
switch (type) {
case ""String_Node_Str"":
    if (commonspec.getResults() != null) {
      ColumnDefinitions columns=commonspec.getResults().getColumnDefinitions();
      List<Row> rows=commonspec.getResults().all();
      List<Map<String,Object>> resultsListObtained=new ArrayList<Map<String,Object>>();
      Map<String,Object> results;
      for (int i=0; i < rows.size(); i++) {
        results=new HashMap<String,Object>();
        for (int e=0; e < columns.size(); e++) {
          results.put(columns.getName(e),rows.get(i).getObject(e));
        }
        resultsListObtained.add(results);
      }
      commonspec.getLogger().info(""String_Node_Str"" + resultsListObtained.toString());
      List<Map<String,Object>> resultsListExpected=new ArrayList<Map<String,Object>>();
      Map<String,Object> resultsCucumber;
      for (int e=1; e < expectedResults.getGherkinRows().size(); e++) {
        resultsCucumber=new HashMap<String,Object>();
        for (int i=0; i < expectedResults.getGherkinRows().get(0).getCells().size(); i++) {
          resultsCucumber.put(expectedResults.getGherkinRows().get(0).getCells().get(i),expectedResults.getGherkinRows().get(e).getCells().get(i));
        }
        resultsListExpected.add(resultsCucumber);
      }
      commonspec.getLogger().info(""String_Node_Str"" + resultsListExpected.toString());
      int occurrencesObtained=0;
      int iterations=0;
      int occurrencesExpected=0;
      String nextKey;
      for (int e=0; e < resultsListExpected.size(); e++) {
        iterations=0;
        occurrencesObtained=0;
        occurrencesExpected=Integer.parseInt(resultsListExpected.get(e).get(""String_Node_Str"").toString());
        for (int i=0; i < resultsListObtained.size(); i++) {
          Iterator<String> it=resultsListExpected.get(0).keySet().iterator();
          while (it.hasNext()) {
            nextKey=it.next();
            if (!nextKey.equals(""String_Node_Str"")) {
              if (resultsListObtained.get(i).get(nextKey).toString().equals(resultsListExpected.get(e).get(nextKey).toString())) {
                iterations++;
              }
            }
            if (iterations == resultsListExpected.get(0).keySet().size() - 1) {
              occurrencesObtained++;
              iterations=0;
            }
          }
          iterations=0;
        }
        assertThat(occurrencesExpected).overridingErrorMessage(""String_Node_Str"" + e + ""String_Node_Str""+ occurrencesObtained+ ""String_Node_Str""+ occurrencesExpected+ ""String_Node_Str"").isEqualTo(occurrencesObtained);
      }
    }
 else {
      throw new Exception(""String_Node_Str"");
    }
  break;
}
}"
11978,"/** 
 * Checks the number of results after a query execution
 * @param resultNumber: number of rows obtained after a query execution
 * @throws Exception
 */
@Given(""String_Node_Str"") public void resultsMustBe(String resultNumber) throws Exception {
  if (this.results != null) {
    List<Row> rows=this.results.all();
    assertThat(Integer.parseInt(resultNumber)).isEqualTo(rows.size()).overridingErrorMessage(""String_Node_Str"" + resultNumber + ""String_Node_Str""+ ""String_Node_Str""+ rows.size());
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
}","/** 
 * Checks the number of results after a query execution
 * @param resultNumber: number of rows obtained after a query execution
 * @throws Exception
 */
@Given(""String_Node_Str"") public void resultsMustBe(String resultNumber) throws Exception {
  if (commonspec.getResults() != null) {
    List<Row> rows=commonspec.getResults().all();
    assertThat(Integer.parseInt(resultNumber)).isEqualTo(rows.size()).overridingErrorMessage(""String_Node_Str"" + resultNumber + ""String_Node_Str""+ ""String_Node_Str""+ rows.size());
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
}"
11979,"/** 
 * Execute a query with scheme over a cluster
 * @param scheme: the file of configuration (.conf) with the options of mappin
 * @param type: type of the changes in scheme (string or json)
 * @param table: table for create the index
 * @param magic_column: magic column where index will be saved
 * @param keyspace: keyspace used
 * @param modifications: query fields on scheme
 * @throws Exception
 */
@Given(""String_Node_Str"") public void sendQueryOfType(String scheme,String type,String magic_column,String table,String keyspace,DataTable modifications) throws Exception {
  commonspec.getCassandraClient().useKeyspace(keyspace);
  commonspec.getLogger().info(""String_Node_Str"",""String_Node_Str"");
  String retrievedData=commonspec.retrieveData(scheme,type);
  String modifiedData=commonspec.modifyData(retrievedData,type,modifications).toString();
  String query=""String_Node_Str"" + table + ""String_Node_Str""+ magic_column+ ""String_Node_Str""+ modifiedData+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + query);
  this.results=commonspec.getCassandraClient().executeQuery(query);
}","/** 
 * Execute a query with scheme over a cluster
 * @param scheme: the file of configuration (.conf) with the options of mappin
 * @param type: type of the changes in scheme (string or json)
 * @param table: table for create the index
 * @param magic_column: magic column where index will be saved
 * @param keyspace: keyspace used
 * @param modifications: query fields on scheme
 * @throws Exception
 */
@Given(""String_Node_Str"") public void sendQueryOfType(String scheme,String type,String magic_column,String table,String keyspace,DataTable modifications) throws Exception {
  commonspec.getCassandraClient().useKeyspace(keyspace);
  commonspec.getLogger().info(""String_Node_Str"",""String_Node_Str"");
  String retrievedData=commonspec.retrieveData(scheme,type);
  String modifiedData=commonspec.modifyData(retrievedData,type,modifications).toString();
  String query=""String_Node_Str"" + table + ""String_Node_Str""+ magic_column+ ""String_Node_Str""+ modifiedData+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + query);
  commonspec.setResults(commonspec.getCassandraClient().executeQuery(query));
}"
11980,"/** 
 * Generic constructor.
 * @param spec
 */
public GivenGSpec(CommonG spec){
  this.commonspec=spec;
  this.results=null;
}","/** 
 * Generic constructor.
 * @param spec
 */
public GivenGSpec(CommonG spec){
  this.commonspec=spec;
}"
11981,"/** 
 * Drop a keyspace in Cassandra.
 * @param ifExists
 * @param keyspace
 */
public void dropKeyspace(boolean ifExists,String keyspace){
  executeQuery(this.queryUtils.dropKeyspaceQuery(ifExists,keyspace));
}","/** 
 * Drop a keyspace in Cassandra.
 * @param ifExists
 * @param keyspace
 */
public void dropKeyspace(boolean ifExists,String keyspace){
  executeQuery(this.CassandraqueryUtils.dropKeyspaceQuery(ifExists,keyspace));
}"
11982,"/** 
 * Create a keyspace in Cassandra.
 * @param keyspace
 */
public void createKeyspace(String keyspace){
  Map<String,String> replicationSimpleOneExtra=new Hashtable<String,String>();
  replicationSimpleOneExtra.put(""String_Node_Str"",""String_Node_Str"");
  replicationSimpleOneExtra.put(""String_Node_Str"",""String_Node_Str"");
  String query=this.queryUtils.createKeyspaceQuery(true,keyspace,queryUtils.createKeyspaceReplication(replicationSimpleOneExtra),""String_Node_Str"");
  LOGGER.debug(query);
  executeQuery(query);
}","/** 
 * Create a keyspace in Cassandra.
 * @param keyspace
 */
public void createKeyspace(String keyspace){
  Map<String,String> replicationSimpleOneExtra=new HashMap<>();
  replicationSimpleOneExtra.put(""String_Node_Str"",""String_Node_Str"");
  replicationSimpleOneExtra.put(""String_Node_Str"",""String_Node_Str"");
  String query=this.CassandraqueryUtils.createKeyspaceQuery(true,keyspace,this.CassandraqueryUtils.createKeyspaceReplication(replicationSimpleOneExtra),""String_Node_Str"");
  LOGGER.debug(query);
  executeQuery(query);
}"
11983,"/** 
 * Use a keyspace in Cassandra.
 * @param keyspace
 */
public void useKeyspace(String keyspace){
  executeQuery(this.queryUtils.useQuery(keyspace));
}","/** 
 * Use a keyspace in Cassandra.
 * @param keyspace
 */
public void useKeyspace(String keyspace){
  executeQuery(this.CassandraqueryUtils.useQuery(keyspace));
}"
11984,"/** 
 * Connect to Cassandra host.
 */
public void connect(){
  buildCluster();
  this.queryUtils=new QueryUtils();
  this.metadata=this.cluster.getMetadata();
  LOGGER.debug(""String_Node_Str"" + host + ""String_Node_Str""+ metadata.getClusterName()+ ""String_Node_Str"");
  this.session=this.cluster.connect();
}","/** 
 * Connect to Cassandra host.
 */
public void connect(){
  buildCluster();
  this.CassandraqueryUtils=new CassandraQueryUtils();
  this.metadata=this.cluster.getMetadata();
  LOGGER.debug(""String_Node_Str"" + host + ""String_Node_Str""+ metadata.getClusterName()+ ""String_Node_Str"");
  this.session=this.cluster.connect();
}"
11985,"/** 
 * Drop a table of a keyspace.
 * @param keyspace
 * @param table
 */
public void dropTable(String keyspace,String table){
  executeQuery(this.queryUtils.dropTableQuery(false,table));
}","/** 
 * Drop a table of a keyspace.
 * @param keyspace
 * @param table
 */
public void dropTable(String keyspace,String table){
  executeQuery(this.CassandraqueryUtils.dropTableQuery(false,table));
}"
11986,"public static SeleniumAssert assertThat(WebDriver actual){
  return new SeleniumAssert(actual);
}","/** 
 * Check if two WebDrivers are equals.
 * @param actual
 * @return
 */
public static SeleniumAssert assertThat(WebDriver actual){
  return new SeleniumAssert(actual);
}"
11987,"public HttpResponseAssert hasStatusCode(Integer status){
  if (actual.getStatusCode() != status) {
    failWithMessage(""String_Node_Str"",status,actual.getStatusCode());
  }
  return this;
}","/** 
 * Checks if a HttpResponse has an specific status.
 * @param status
 * @return HttpResponseAssert
 */
public HttpResponseAssert hasStatusCode(Integer status){
  if (actual.getStatusCode() != status) {
    failWithMessage(""String_Node_Str"",status,actual.getStatusCode());
  }
  return this;
}"
11988,"public HttpResponseAssert hasMessage(String message){
  if (!actual.getResponse().contains(message)) {
    failWithMessage(""String_Node_Str"",message,actual.getResponse());
  }
  return this;
}","/** 
 * Checks if a HttpResponse has a specific message.
 * @param message
 * @return HttpResponseAssert
 */
public HttpResponseAssert hasMessage(String message){
  if (!actual.getResponse().contains(message)) {
    failWithMessage(""String_Node_Str"",message,actual.getResponse());
  }
  return this;
}"
11989,"public HttpResponseAssert hasStatusCodeAndMessage(Integer status,String message){
  String msg=""String_Node_Str"";
  if (actual.getStatusCode() != status) {
    msg+=String.format(""String_Node_Str"",status,actual.getStatusCode());
  }
  if (!actual.getResponse().contains(message)) {
    String nl=""String_Node_Str"";
    if (!""String_Node_Str"".equals(msg)) {
      nl=String.format(""String_Node_Str"",System.lineSeparator(),""String_Node_Str"");
    }
    msg+=String.format(""String_Node_Str"",nl,message,actual.getResponse());
  }
  if (!""String_Node_Str"".equals(msg)) {
    failWithMessage(msg);
  }
  return this;
}","/** 
 * Checks if a HttpResponse has a specific message and has a specific status.
 * @param status
 * @param message
 * @return HttpResponseAssert
 */
public HttpResponseAssert hasStatusCodeAndMessage(Integer status,String message){
  String msg=""String_Node_Str"";
  if (actual.getStatusCode() != status) {
    msg+=String.format(""String_Node_Str"",status,actual.getStatusCode());
  }
  if (!actual.getResponse().contains(message)) {
    String nl=""String_Node_Str"";
    if (!""String_Node_Str"".equals(msg)) {
      nl=String.format(""String_Node_Str"",System.lineSeparator(),""String_Node_Str"");
    }
    msg+=String.format(""String_Node_Str"",nl,message,actual.getResponse());
  }
  if (!""String_Node_Str"".equals(msg)) {
    failWithMessage(msg);
  }
  return this;
}"
11990,"public HttpResponseAssert doesNotHaveMessage(String message){
  if (actual.getResponse().contains(message)) {
    failWithMessage(""String_Node_Str"",message,actual.getResponse());
  }
  return this;
}","/** 
 * Checks if a HttpResponse has not a specific message.
 * @param message
 * @return HttpResponseAssert
 */
public HttpResponseAssert doesNotHaveMessage(String message){
  if (actual.getResponse().contains(message)) {
    failWithMessage(""String_Node_Str"",message,actual.getResponse());
  }
  return this;
}"
11991,"public static HttpResponseAssert assertThat(HttpResponse actual){
  return new HttpResponseAssert(actual);
}","/** 
 * Checks the actual ""http"" response.
 * @param actual
 * @return HttpResponseAssert
 */
public static HttpResponseAssert assertThat(HttpResponse actual){
  return new HttpResponseAssert(actual);
}"
11992,"public HttpResponseAssert doesNotHaveStatusCode(Integer status){
  if (actual.getStatusCode() == status) {
    failWithMessage(""String_Node_Str"",status,actual.getStatusCode());
  }
  return this;
}","/** 
 * Checks if a HttpResponse has not an specific status.
 * @param status
 * @return
 */
public HttpResponseAssert doesNotHaveStatusCode(Integer status){
  if (actual.getStatusCode() == status) {
    failWithMessage(""String_Node_Str"",status,actual.getStatusCode());
  }
  return this;
}"
11993,"public HttpResponseAssert doesNotHaveStatusCodeNorMessage(Integer status,String message){
  String msg=""String_Node_Str"";
  if (actual.getStatusCode() == status) {
    msg+=String.format(""String_Node_Str"",status,actual.getStatusCode());
  }
  if (actual.getResponse().contains(message)) {
    String nl=""String_Node_Str"";
    if (!""String_Node_Str"".equals(msg)) {
      nl=String.format(""String_Node_Str"",System.lineSeparator(),""String_Node_Str"");
    }
    msg+=String.format(""String_Node_Str"",nl,message,actual.getResponse());
  }
  if (!""String_Node_Str"".equals(msg)) {
    failWithMessage(msg);
  }
  return this;
}","/** 
 * Checks if a HttpResponse has not a specific message and has not a specific status.
 * @param status
 * @param message
 * @return HttpResponseAssert
 */
public HttpResponseAssert doesNotHaveStatusCodeNorMessage(Integer status,String message){
  String msg=""String_Node_Str"";
  if (actual.getStatusCode() == status) {
    msg+=String.format(""String_Node_Str"",status,actual.getStatusCode());
  }
  if (actual.getResponse().contains(message)) {
    String nl=""String_Node_Str"";
    if (!""String_Node_Str"".equals(msg)) {
      nl=String.format(""String_Node_Str"",System.lineSeparator(),""String_Node_Str"");
    }
    msg+=String.format(""String_Node_Str"",nl,message,actual.getResponse());
  }
  if (!""String_Node_Str"".equals(msg)) {
    failWithMessage(msg);
  }
  return this;
}"
11994,"public HttpResponseAssert(HttpResponse actual){
  super(actual,HttpResponseAssert.class);
}","/** 
 * Generic constructor.
 * @param actual
 */
public HttpResponseAssert(HttpResponse actual){
  super(actual,HttpResponseAssert.class);
}"
11995,"public SeleniumAssert contains(CharSequence... values){
  if (actual instanceof WebDriver) {
    Strings.instance().assertContains(info,((WebDriver)actual).getPageSource(),values);
  }
 else   if (actual instanceof WebElement) {
    Strings.instance().assertContains(info,((WebElement)actual).getText(),values);
  }
  return this;
}","/** 
 * Checks if a webDriver or WebElement has values.
 * @param values
 * @return
 */
public SeleniumAssert contains(CharSequence... values){
  if (actual instanceof WebDriver) {
    Strings.instance().assertContains(info,((WebDriver)actual).getPageSource(),values);
  }
 else   if (actual instanceof WebElement) {
    Strings.instance().assertContains(info,((WebElement)actual).getText(),values);
  }
  return this;
}"
11996,"public SeleniumAssert(WebDriver actual){
  super(actual,SeleniumAssert.class);
}","/** 
 * Constructor with WebDriver.
 * @param actual
 */
public SeleniumAssert(WebDriver actual){
  super(actual,SeleniumAssert.class);
}"
11997,"public static SeleniumAssert assertThat(WebDriver actual){
  return new SeleniumAssert(actual);
}","/** 
 * Checks a selenium WebDriver.
 * @param actual
 * @return
 */
public static SeleniumAssert assertThat(WebDriver actual){
  return new SeleniumAssert(actual);
}"
11998,"public static Extractor<WebElement,String> linkText(){
  return new SeleniumExtractor();
}","/** 
 * Get selenium extractor
 * @return
 */
public static Extractor<WebElement,String> linkText(){
  return new SeleniumExtractor();
}"
11999,"@Around(value=""String_Node_Str"") public void aroundLogAssertFailurePointcut(ProceedingJoinPoint pjp,String reason,Object actual,Matcher<?> matcher) throws Throwable {
  try {
    pjp.proceed();
  }
 catch (  AssertionError e) {
    logger.error(""String_Node_Str"",reason);
    if ((actual instanceof ArrayList) && (matcher.getClass().toString().endsWith(""String_Node_Str""))) {
      List<?> actualList=(ArrayList<?>)actual;
      if (actualList.size() > 0) {
        Object el=actualList.get(actualList.size() - 1);
        if (el != null && (el instanceof Exception)) {
          logger.error(""String_Node_Str"",((Exception)el).getClass().getSimpleName(),((Exception)el).getMessage());
        }
      }
    }
    throw e;
  }
}","/** 
 * @param pjp
 * @param reason
 * @param actual
 * @param matcher
 * @throws Throwable
 */
@Around(value=""String_Node_Str"") public void aroundLogAssertFailurePointcut(ProceedingJoinPoint pjp,String reason,Object actual,Matcher<?> matcher) throws Throwable {
  try {
    pjp.proceed();
  }
 catch (  AssertionError e) {
    logger.error(""String_Node_Str"",reason);
    if ((actual instanceof ArrayList) && (matcher.getClass().toString().endsWith(""String_Node_Str""))) {
      List<?> actualList=(ArrayList<?>)actual;
      if (actualList.size() > 0) {
        Object el=actualList.get(actualList.size() - 1);
        if (el != null && (el instanceof Exception)) {
          logger.error(""String_Node_Str"",((Exception)el).getClass().getSimpleName(),((Exception)el).getMessage());
        }
      }
    }
    throw e;
  }
}"
12000,"@Around(""String_Node_Str"") public AssertionError aroundLogAssertJFailurePointcut(ProceedingJoinPoint pjp) throws Throwable {
  AssertionError ae=(AssertionError)pjp.proceed();
  logger.error(""String_Node_Str"",ae.getMessage());
  return ae;
}","/** 
 * @param pjp
 * @return
 * @throws Throwable
 */
@Around(""String_Node_Str"") public AssertionError aroundLogAssertJFailurePointcut(ProceedingJoinPoint pjp) throws Throwable {
  AssertionError ae=(AssertionError)pjp.proceed();
  logger.error(""String_Node_Str"",ae.getMessage());
  return ae;
}"
