record_number,buggy_code,fixed_code
3001,"private void removeViewInternal(int index,View view){
  if (mTransition != null) {
    mTransition.removeChild(this,view);
  }
  boolean clearChildFocus=false;
  if (view == mFocused) {
    view.unFocus();
    clearChildFocus=true;
  }
  view.clearAccessibilityFocus();
  cancelTouchTarget(view);
  cancelHoverTarget(view);
  if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
    addDisappearingView(view);
  }
 else   if (view.mAttachInfo != null) {
    view.dispatchDetachedFromWindow();
  }
  if (view.hasTransientState()) {
    childHasTransientStateChanged(view,false);
  }
  needGlobalAttributesUpdate(false);
  removeFromArray(index);
  if (clearChildFocus) {
    clearChildFocus(view);
    ensureInputFocusOnFirstFocusable();
  }
  if (view.isAccessibilityFocused()) {
    view.clearAccessibilityFocus();
  }
  onViewRemoved(view);
}","private void removeViewInternal(int index,View view){
  if (mTransition != null) {
    mTransition.removeChild(this,view);
  }
  boolean clearChildFocus=false;
  if (view == mFocused) {
    view.unFocus();
    clearChildFocus=true;
  }
  if (view.isAccessibilityFocused()) {
    view.clearAccessibilityFocus();
  }
  cancelTouchTarget(view);
  cancelHoverTarget(view);
  if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
    addDisappearingView(view);
  }
 else   if (view.mAttachInfo != null) {
    view.dispatchDetachedFromWindow();
  }
  if (view.hasTransientState()) {
    childHasTransientStateChanged(view,false);
  }
  needGlobalAttributesUpdate(false);
  removeFromArray(index);
  if (clearChildFocus) {
    clearChildFocus(view);
    if (!rootViewRequestFocus()) {
      notifyGlobalFocusCleared(this);
    }
  }
  onViewRemoved(view);
}"
3002,"/** 
 * Called by a ViewGroup subclass to remove child views from itself, when it must first know its size on screen before it can calculate how many child views it will render. An example is a Gallery or a ListView, which may ""have"" 50 children, but actually only render the number of children that can currently fit inside the object on screen. Do not call this method unless you are extending ViewGroup and understand the view measuring and layout pipeline. <p><strong>Note:</strong> do not invoke this method from  {@link #draw(android.graphics.Canvas)},   {@link #onDraw(android.graphics.Canvas)},  {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
public void removeAllViewsInLayout(){
  final int count=mChildrenCount;
  if (count <= 0) {
    return;
  }
  final View[] children=mChildren;
  mChildrenCount=0;
  final View focused=mFocused;
  final boolean detach=mAttachInfo != null;
  View clearChildFocus=null;
  needGlobalAttributesUpdate(false);
  for (int i=count - 1; i >= 0; i--) {
    final View view=children[i];
    if (mTransition != null) {
      mTransition.removeChild(this,view);
    }
    if (view == focused) {
      view.unFocus();
      clearChildFocus=view;
    }
    view.clearAccessibilityFocus();
    cancelTouchTarget(view);
    cancelHoverTarget(view);
    if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
      addDisappearingView(view);
    }
 else     if (detach) {
      view.dispatchDetachedFromWindow();
    }
    if (view.hasTransientState()) {
      childHasTransientStateChanged(view,false);
    }
    onViewRemoved(view);
    view.mParent=null;
    children[i]=null;
  }
  if (clearChildFocus != null) {
    clearChildFocus(clearChildFocus);
    ensureInputFocusOnFirstFocusable();
  }
}","/** 
 * Called by a ViewGroup subclass to remove child views from itself, when it must first know its size on screen before it can calculate how many child views it will render. An example is a Gallery or a ListView, which may ""have"" 50 children, but actually only render the number of children that can currently fit inside the object on screen. Do not call this method unless you are extending ViewGroup and understand the view measuring and layout pipeline. <p><strong>Note:</strong> do not invoke this method from  {@link #draw(android.graphics.Canvas)},   {@link #onDraw(android.graphics.Canvas)},  {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */
public void removeAllViewsInLayout(){
  final int count=mChildrenCount;
  if (count <= 0) {
    return;
  }
  final View[] children=mChildren;
  mChildrenCount=0;
  final View focused=mFocused;
  final boolean detach=mAttachInfo != null;
  boolean clearChildFocus=false;
  needGlobalAttributesUpdate(false);
  for (int i=count - 1; i >= 0; i--) {
    final View view=children[i];
    if (mTransition != null) {
      mTransition.removeChild(this,view);
    }
    if (view == focused) {
      view.unFocus();
      clearChildFocus=true;
    }
    if (view.isAccessibilityFocused()) {
      view.clearAccessibilityFocus();
    }
    cancelTouchTarget(view);
    cancelHoverTarget(view);
    if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
      addDisappearingView(view);
    }
 else     if (detach) {
      view.dispatchDetachedFromWindow();
    }
    if (view.hasTransientState()) {
      childHasTransientStateChanged(view,false);
    }
    onViewRemoved(view);
    view.mParent=null;
    children[i]=null;
  }
  if (clearChildFocus) {
    clearChildFocus(focused);
    if (!rootViewRequestFocus()) {
      notifyGlobalFocusCleared(focused);
    }
  }
}"
3003,"private void removeViewsInternal(int start,int count){
  final View focused=mFocused;
  final boolean detach=mAttachInfo != null;
  View clearChildFocus=null;
  final View[] children=mChildren;
  final int end=start + count;
  for (int i=start; i < end; i++) {
    final View view=children[i];
    if (mTransition != null) {
      mTransition.removeChild(this,view);
    }
    if (view == focused) {
      view.unFocus();
      clearChildFocus=view;
    }
    view.clearAccessibilityFocus();
    cancelTouchTarget(view);
    cancelHoverTarget(view);
    if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
      addDisappearingView(view);
    }
 else     if (detach) {
      view.dispatchDetachedFromWindow();
    }
    if (view.hasTransientState()) {
      childHasTransientStateChanged(view,false);
    }
    needGlobalAttributesUpdate(false);
    onViewRemoved(view);
  }
  removeFromArray(start,count);
  if (clearChildFocus != null) {
    clearChildFocus(clearChildFocus);
    ensureInputFocusOnFirstFocusable();
  }
}","private void removeViewsInternal(int start,int count){
  final View focused=mFocused;
  final boolean detach=mAttachInfo != null;
  boolean clearChildFocus=false;
  final View[] children=mChildren;
  final int end=start + count;
  for (int i=start; i < end; i++) {
    final View view=children[i];
    if (mTransition != null) {
      mTransition.removeChild(this,view);
    }
    if (view == focused) {
      view.unFocus();
      clearChildFocus=true;
    }
    if (view.isAccessibilityFocused()) {
      view.clearAccessibilityFocus();
    }
    cancelTouchTarget(view);
    cancelHoverTarget(view);
    if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
      addDisappearingView(view);
    }
 else     if (detach) {
      view.dispatchDetachedFromWindow();
    }
    if (view.hasTransientState()) {
      childHasTransientStateChanged(view,false);
    }
    needGlobalAttributesUpdate(false);
    onViewRemoved(view);
  }
  removeFromArray(start,count);
  if (clearChildFocus) {
    clearChildFocus(focused);
    if (!rootViewRequestFocus()) {
      notifyGlobalFocusCleared(focused);
    }
  }
}"
3004,"public void clearChildFocus(View child){
  checkThread();
  if (DEBUG_INPUT_RESIZE) {
    Log.v(TAG,""String_Node_Str"");
  }
  mOldFocusedView=mFocusedView;
  if (focusSearch(null,View.FOCUS_FORWARD) == null) {
    mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(mOldFocusedView,null);
  }
  mFocusedView=mRealFocusedView=null;
}","public void clearChildFocus(View child){
  if (DEBUG_INPUT_RESIZE) {
    Log.v(TAG,""String_Node_Str"");
  }
  checkThread();
  scheduleTraversals();
}"
3005,"public void focusableViewAvailable(View v){
  checkThread();
  if (mView != null) {
    if (!mView.hasFocus()) {
      v.requestFocus();
    }
 else {
      mFocusedView=mView.findFocus();
      boolean descendantsHaveDibsOnFocus=(mFocusedView instanceof ViewGroup) && (((ViewGroup)mFocusedView).getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS);
      if (descendantsHaveDibsOnFocus && isViewDescendantOf(v,mFocusedView)) {
        v.requestFocus();
      }
    }
  }
}","public void focusableViewAvailable(View v){
  checkThread();
  if (mView != null) {
    if (!mView.hasFocus()) {
      v.requestFocus();
    }
 else {
      View focused=mView.findFocus();
      if (focused instanceof ViewGroup) {
        ViewGroup group=(ViewGroup)focused;
        if (group.getDescendantFocusability() == ViewGroup.FOCUS_AFTER_DESCENDANTS && isViewDescendantOf(v,focused)) {
          v.requestFocus();
        }
      }
    }
  }
}"
3006,"private boolean enterTouchMode(){
  if (mView != null) {
    if (mView.hasFocus()) {
      final View focused=mView.findFocus();
      if (focused != null && !focused.isFocusableInTouchMode()) {
        final ViewGroup ancestorToTakeFocus=findAncestorToTakeFocusInTouchMode(focused);
        if (ancestorToTakeFocus != null) {
          return ancestorToTakeFocus.requestFocus();
        }
 else {
          mView.unFocus();
          mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(focused,null);
          mFocusedView=null;
          mOldFocusedView=null;
          return true;
        }
      }
    }
  }
  return false;
}","private boolean enterTouchMode(){
  if (mView != null) {
    if (mView.hasFocus()) {
      final View focused=mView.findFocus();
      if (focused != null && !focused.isFocusableInTouchMode()) {
        final ViewGroup ancestorToTakeFocus=findAncestorToTakeFocusInTouchMode(focused);
        if (ancestorToTakeFocus != null) {
          return ancestorToTakeFocus.requestFocus();
        }
 else {
          focused.unFocus();
          return true;
        }
      }
    }
  }
  return false;
}"
3007,"private boolean leaveTouchMode(){
  if (mView != null) {
    if (mView.hasFocus()) {
      mFocusedView=mView.findFocus();
      if (!(mFocusedView instanceof ViewGroup)) {
        return false;
      }
 else       if (((ViewGroup)mFocusedView).getDescendantFocusability() != ViewGroup.FOCUS_AFTER_DESCENDANTS) {
        return false;
      }
    }
    final View focused=focusSearch(null,View.FOCUS_DOWN);
    if (focused != null) {
      return focused.requestFocus(View.FOCUS_DOWN);
    }
  }
  return false;
}","private boolean leaveTouchMode(){
  if (mView != null) {
    if (mView.hasFocus()) {
      View focusedView=mView.findFocus();
      if (!(focusedView instanceof ViewGroup)) {
        return false;
      }
 else       if (((ViewGroup)focusedView).getDescendantFocusability() != ViewGroup.FOCUS_AFTER_DESCENDANTS) {
        return false;
      }
    }
    final View focused=focusSearch(null,View.FOCUS_DOWN);
    if (focused != null) {
      return focused.requestFocus(View.FOCUS_DOWN);
    }
  }
  return false;
}"
3008,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            layerCanvas.setViewport(mWidth,mHeight);
            layerCanvas.onPreDraw(null);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (layerCanvas != null) {
              layerCanvas.onPostDraw();
            }
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              Log.e(TAG,""String_Node_Str"",e);
              try {
                if (!mWindowSession.outOfMemory(mWindow) && Process.myUid() != Process.SYSTEM_UID) {
                  Slog.w(TAG,""String_Node_Str"");
                  Process.killProcess(Process.myPid());
                }
              }
 catch (              RemoteException ex) {
              }
              mLayoutRequested=true;
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        mLastScrolledFocus=null;
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          Log.e(TAG,""String_Node_Str"",e);
          try {
            if (!mWindowSession.outOfMemory(mWindow)) {
              Slog.w(TAG,""String_Node_Str"");
              Process.killProcess(Process.myPid());
            }
          }
 catch (          RemoteException ex) {
          }
          mLayoutRequested=true;
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        mFocusedView=mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mFocusedView);
      }
 else {
        mRealFocusedView=mView.findFocus();
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mRealFocusedView);
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final View.AttachInfo attachInfo=mAttachInfo;
  final int viewVisibility=getHostVisibility();
  boolean viewVisibilityChanged=mViewVisibility != viewVisibility || mNewSurfaceNeeded;
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mCompatibilityInfo.get();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.flags&=~WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.flags|=WindowManager.LayoutParams.FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      DisplayMetrics packageMetrics=mView.getContext().getResources().getDisplayMetrics();
      desiredWindowWidth=packageMetrics.widthPixels;
      desiredWindowHeight=packageMetrics.heightPixels;
    }
    attachInfo.mSurface=mSurface;
    attachInfo.mUse32BitDrawingCache=true;
    attachInfo.mHasWindowFocus=false;
    attachInfo.mWindowVisibility=viewVisibility;
    attachInfo.mRecomputeGlobalAttributes=false;
    viewVisibilityChanged=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(attachInfo,0);
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    attachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  getRunQueue().executeActions(attachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && !mStopped;
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          DisplayMetrics packageMetrics=res.getDisplayMetrics();
          desiredWindowWidth=packageMetrics.widthPixels;
          desiredWindowHeight=packageMetrics.heightPixels;
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (attachInfo.mForceReportNewAttributes) {
    attachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || attachInfo.mViewVisibilityChanged) {
    attachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=attachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (attachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
    if (!PixelFormat.formatHasAlpha(params.format)) {
      params.format=PixelFormat.TRANSLUCENT;
    }
  }
  if (mFitSystemWindowsRequested) {
    mFitSystemWindowsRequested=false;
    mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
    host.fitSystemWindows(mFitSystemWindowsInsets);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  final boolean computesInternalInsets=attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();
  boolean insetsPending=false;
  int relayoutResult=0;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null) {
    if (viewVisibility == View.VISIBLE) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean visibleInsetsChanged;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(TAG,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(TAG,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(TAG,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(mPendingConfiguration,!mFirst);
        mPendingConfiguration.seq=0;
      }
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      if (contentInsetsChanged) {
        if (mWidth > 0 && mHeight > 0 && lp != null && ((lp.systemUiVisibility | lp.subtreeSystemUiVisibility) & View.SYSTEM_UI_LAYOUT_FLAGS) == 0 && mSurface != null && mSurface.isValid() && !mAttachInfo.mTurnOffWindowResizeAnim && mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled() && mAttachInfo.mHardwareRenderer.validate() && lp != null && !PixelFormat.formatHasAlpha(lp.format)) {
          disposeResizeBuffer();
          boolean completed=false;
          HardwareCanvas hwRendererCanvas=mAttachInfo.mHardwareRenderer.getCanvas();
          HardwareCanvas layerCanvas=null;
          try {
            if (mResizeBuffer == null) {
              mResizeBuffer=mAttachInfo.mHardwareRenderer.createHardwareLayer(mWidth,mHeight,false);
            }
 else             if (mResizeBuffer.getWidth() != mWidth || mResizeBuffer.getHeight() != mHeight) {
              mResizeBuffer.resize(mWidth,mHeight);
            }
            layerCanvas=mResizeBuffer.start(hwRendererCanvas);
            layerCanvas.setViewport(mWidth,mHeight);
            layerCanvas.onPreDraw(null);
            final int restoreCount=layerCanvas.save();
            int yoff;
            final boolean scrolling=mScroller != null && mScroller.computeScrollOffset();
            if (scrolling) {
              yoff=mScroller.getCurrY();
              mScroller.abortAnimation();
            }
 else {
              yoff=mScrollY;
            }
            layerCanvas.translate(0,-yoff);
            if (mTranslator != null) {
              mTranslator.translateCanvas(layerCanvas);
            }
            DisplayList displayList=mView.mDisplayList;
            if (displayList != null) {
              layerCanvas.drawDisplayList(displayList,null,DisplayList.FLAG_CLIP_CHILDREN);
            }
 else {
              mView.draw(layerCanvas);
            }
            drawAccessibilityFocusedDrawableIfNeeded(layerCanvas);
            mResizeBufferStartTime=SystemClock.uptimeMillis();
            mResizeBufferDuration=mView.getResources().getInteger(com.android.internal.R.integer.config_mediumAnimTime);
            completed=true;
            layerCanvas.restoreToCount(restoreCount);
          }
 catch (          OutOfMemoryError e) {
            Log.w(TAG,""String_Node_Str"",e);
          }
 finally {
            if (layerCanvas != null) {
              layerCanvas.onPostDraw();
            }
            if (mResizeBuffer != null) {
              mResizeBuffer.end(hwRendererCanvas);
              if (!completed) {
                mResizeBuffer.destroy();
                mResizeBuffer=null;
              }
            }
          }
        }
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mFitSystemWindowsRequested) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mFitSystemWindowsRequested=false;
        mFitSystemWindowsInsets.set(mAttachInfo.mContentInsets);
        host.fitSystemWindows(mFitSystemWindowsInsets);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mHolder.getSurface());
            }
 catch (            Surface.OutOfResourcesException e) {
              Log.e(TAG,""String_Node_Str"",e);
              try {
                if (!mWindowSession.outOfMemory(mWindow) && Process.myUid() != Process.SYSTEM_UID) {
                  Slog.w(TAG,""String_Node_Str"");
                  Process.killProcess(Process.myPid());
                }
              }
 catch (              RemoteException ex) {
              }
              mLayoutRequested=true;
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        disposeResizeBuffer();
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy(true);
        }
      }
 else       if (surfaceGenerationId != mSurface.getGenerationId() && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mHolder.getSurface());
        }
 catch (        Surface.OutOfResourcesException e) {
          Log.e(TAG,""String_Node_Str"",e);
          try {
            if (!mWindowSession.outOfMemory(mWindow)) {
              Slog.w(TAG,""String_Node_Str"");
              Process.killProcess(Process.myPid());
            }
          }
 catch (          RemoteException ex) {
          }
          mLayoutRequested=true;
          return;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    attachInfo.mWindowLeft=frame.left;
    attachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
      if (hwInitialized || windowShouldResize || mWidth != mAttachInfo.mHardwareRenderer.getWidth() || mHeight != mAttachInfo.mHardwareRenderer.getHeight()) {
        mAttachInfo.mHardwareRenderer.setup(mWidth,mHeight);
        if (!hwInitialized) {
          mAttachInfo.mHardwareRenderer.invalidate(mHolder.getSurface());
          mFullRedrawNeeded=true;
        }
      }
    }
    if (!mStopped) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(TAG,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(TAG,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    final boolean windowMoved=(attachInfo.mWindowLeft != frame.left || attachInfo.mWindowTop != frame.top);
    if (windowMoved) {
      if (mTranslator != null) {
        mTranslator.translateRectInScreenToAppWinFrame(frame);
      }
      attachInfo.mWindowLeft=frame.left;
      attachInfo.mWindowTop=frame.top;
    }
  }
  final boolean didLayout=layoutRequested && !mStopped;
  boolean triggerGlobalLayoutListener=didLayout || attachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    attachInfo.mRecomputeGlobalAttributes=false;
    attachInfo.mTreeObserver.dispatchOnGlobalLayout();
    if (AccessibilityManager.getInstance(host.mContext).isEnabled()) {
      postSendWindowContentChangedCallback(mView);
    }
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=attachInfo.mGivenInternalInsets;
    insets.reset();
    attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  boolean skipDraw=false;
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.findFocus());
      }
    }
    if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_ANIMATING) != 0) {
      mWindowsAnimating=true;
    }
  }
 else   if (mWindowsAnimating) {
    skipDraw=true;
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mViewVisibility=viewVisibility;
  if (mAttachInfo.mHasWindowFocus) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.startGettingWindowFocus(mView);
        imm.onWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=attachInfo.mTreeObserver.dispatchOnPreDraw() || viewVisibility != View.VISIBLE;
  if (!cancelDraw && !newSurface) {
    if (!skipDraw || mReportNextDraw) {
      if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
        for (int i=0; i < mPendingTransitions.size(); ++i) {
          mPendingTransitions.get(i).startChangingAnimations();
        }
        mPendingTransitions.clear();
      }
      performDraw();
    }
  }
 else {
    if (viewVisibility == View.VISIBLE) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}"
3009,"boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mRealFocusedView;
    if (focus == null || focus.mAttachInfo != mAttachInfo) {
      mRealFocusedView=null;
      return false;
    }
    if (focus != mLastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == mLastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=focus;
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          if (mView instanceof ViewGroup) {
            ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          }
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate && mResizeBuffer == null) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}","boolean scrollToRectOrFocus(Rect rectangle,boolean immediate){
  final View.AttachInfo attachInfo=mAttachInfo;
  final Rect ci=attachInfo.mContentInsets;
  final Rect vi=attachInfo.mVisibleInsets;
  int scrollY=0;
  boolean handled=false;
  if (vi.left > ci.left || vi.top > ci.top || vi.right > ci.right || vi.bottom > ci.bottom) {
    scrollY=mScrollY;
    View focus=mView.findFocus();
    if (focus == null) {
      return false;
    }
    View lastScrolledFocus=(mLastScrolledFocus != null) ? mLastScrolledFocus.get() : null;
    if (lastScrolledFocus != null && focus != lastScrolledFocus) {
      rectangle=null;
    }
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ rectangle+ ""String_Node_Str""+ ci+ ""String_Node_Str""+ vi);
    if (focus == lastScrolledFocus && !mScrollMayChange && rectangle == null) {
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ vi.toShortString());
    }
 else     if (focus != null) {
      mLastScrolledFocus=new WeakReference<View>(focus);
      mScrollMayChange=false;
      if (DEBUG_INPUT_RESIZE)       Log.v(TAG,""String_Node_Str"");
      if (focus.getGlobalVisibleRect(mVisRect,null)) {
        if (DEBUG_INPUT_RESIZE)         Log.v(TAG,""String_Node_Str"" + mView.getWidth() + ""String_Node_Str""+ mView.getHeight()+ ""String_Node_Str""+ ci.toShortString()+ ""String_Node_Str""+ vi.toShortString());
        if (rectangle == null) {
          focus.getFocusedRect(mTempRect);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + focus + ""String_Node_Str""+ mTempRect.toShortString());
          if (mView instanceof ViewGroup) {
            ((ViewGroup)mView).offsetDescendantRectToMyCoords(focus,mTempRect);
          }
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
 else {
          mTempRect.set(rectangle);
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString() + ""String_Node_Str""+ mVisRect.toShortString());
        }
        if (mTempRect.intersect(mVisRect)) {
          if (DEBUG_INPUT_RESIZE)           Log.v(TAG,""String_Node_Str"" + mTempRect.toShortString());
          if (mTempRect.height() > (mView.getHeight() - vi.top - vi.bottom)) {
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.top - scrollY) < vi.top) {
            scrollY-=vi.top - (mTempRect.top - scrollY);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
 else           if ((mTempRect.bottom - scrollY) > (mView.getHeight() - vi.bottom)) {
            scrollY+=(mTempRect.bottom - scrollY) - (mView.getHeight() - vi.bottom);
            if (DEBUG_INPUT_RESIZE)             Log.v(TAG,""String_Node_Str"" + scrollY);
          }
          handled=true;
        }
      }
    }
  }
  if (scrollY != mScrollY) {
    if (DEBUG_INPUT_RESIZE)     Log.v(TAG,""String_Node_Str"" + mScrollY + ""String_Node_Str""+ scrollY);
    if (!immediate && mResizeBuffer == null) {
      if (mScroller == null) {
        mScroller=new Scroller(mView.getContext());
      }
      mScroller.startScroll(0,mScrollY,0,scrollY - mScrollY);
    }
 else     if (mScroller != null) {
      mScroller.abortAnimation();
    }
    mScrollY=scrollY;
  }
  return handled;
}"
3010,"public void requestChildFocus(View child,View focused){
  checkThread();
  if (DEBUG_INPUT_RESIZE) {
    Log.v(TAG,""String_Node_Str"" + focused);
  }
  mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(mOldFocusedView,focused);
  scheduleTraversals();
  mFocusedView=mRealFocusedView=focused;
}","public void requestChildFocus(View child,View focused){
  if (DEBUG_INPUT_RESIZE) {
    Log.v(TAG,""String_Node_Str"" + focused);
  }
  checkThread();
  scheduleTraversals();
}"
3011,"@Override boolean loadSystemProperties(Surface surface){
  boolean value;
  boolean changed=false;
  String profiling=SystemProperties.get(PROFILE_PROPERTY);
  value=PROFILE_PROPERTY_VISUALIZE.equalsIgnoreCase(profiling);
  if (value != mProfileVisualizerEnabled) {
    changed=true;
    mProfileVisualizerEnabled=value;
    mProfileRects=null;
    mProfilePaint=null;
  }
  if (!value) {
    value=Boolean.parseBoolean(profiling);
  }
  if (value != mProfileEnabled) {
    changed=true;
    mProfileEnabled=value;
    if (mProfileEnabled) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
    if (mProfileEnabled) {
      int maxProfileFrames=SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY,PROFILE_MAX_FRAMES);
      mProfileData=new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
      for (int i=0; i < mProfileData.length; i+=PROFILE_FRAME_DATA_COUNT) {
        mProfileData[i]=mProfileData[i + 1]=mProfileData[i + 2]=-1;
      }
      mProfileLock=new ReentrantLock();
    }
 else {
      mProfileData=null;
      mProfileLock=null;
    }
    mProfileRects=null;
    mProfilePaint=null;
  }
  value=SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY,false);
  if (value != mDebugDirtyRegions) {
    changed=true;
    mDebugDirtyRegions=value;
    if (mDebugDirtyRegions) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
  }
  value=SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY,false);
  if (value != mShowOverdraw) {
    changed=true;
    mShowOverdraw=value;
    if (surface != null && isEnabled()) {
      if (validate()) {
        sEglConfig=loadEglConfig();
        invalidate(surface);
      }
    }
  }
  if (nLoadProperties()) {
    changed=true;
  }
  return changed;
}","@Override boolean loadSystemProperties(Surface surface){
  boolean value;
  boolean changed=false;
  String profiling=SystemProperties.get(PROFILE_PROPERTY);
  value=PROFILE_PROPERTY_VISUALIZE.equalsIgnoreCase(profiling);
  if (value != mProfileVisualizerEnabled) {
    changed=true;
    mProfileVisualizerEnabled=value;
    mProfileRects=null;
    mProfilePaint=null;
  }
  if (!value) {
    value=Boolean.parseBoolean(profiling);
  }
  if (value != mProfileEnabled) {
    changed=true;
    mProfileEnabled=value;
    if (mProfileEnabled) {
      Log.d(LOG_TAG,""String_Node_Str"");
      int maxProfileFrames=SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY,PROFILE_MAX_FRAMES);
      mProfileData=new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
      for (int i=0; i < mProfileData.length; i+=PROFILE_FRAME_DATA_COUNT) {
        mProfileData[i]=mProfileData[i + 1]=mProfileData[i + 2]=-1;
      }
      mProfileLock=new ReentrantLock();
    }
 else {
      mProfileData=null;
      mProfileLock=null;
    }
    mProfileCurrentFrame=-PROFILE_FRAME_DATA_COUNT;
  }
  value=SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY,false);
  if (value != mDebugDirtyRegions) {
    changed=true;
    mDebugDirtyRegions=value;
    if (mDebugDirtyRegions) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
  }
  value=SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY,false);
  if (value != mShowOverdraw) {
    changed=true;
    mShowOverdraw=value;
    if (surface != null && isEnabled()) {
      if (validate()) {
        sEglConfig=loadEglConfig();
        invalidate(surface);
      }
    }
  }
  if (nLoadProperties()) {
    changed=true;
  }
  return changed;
}"
3012,"@Override boolean loadSystemProperties(Surface surface){
  boolean value;
  boolean changed=false;
  String profiling=SystemProperties.get(PROFILE_PROPERTY);
  value=PROFILE_PROPERTY_VISUALIZE.equalsIgnoreCase(profiling);
  if (value != mProfileVisualizerEnabled) {
    changed=true;
    mProfileVisualizerEnabled=value;
    mProfileRects=null;
    mProfilePaint=null;
  }
  if (!value) {
    value=Boolean.parseBoolean(profiling);
  }
  if (value != mProfileEnabled) {
    changed=true;
    mProfileEnabled=value;
    if (mProfileEnabled) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
    if (mProfileEnabled) {
      int maxProfileFrames=SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY,PROFILE_MAX_FRAMES);
      mProfileData=new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
      for (int i=0; i < mProfileData.length; i+=PROFILE_FRAME_DATA_COUNT) {
        mProfileData[i]=mProfileData[i + 1]=mProfileData[i + 2]=-1;
      }
      mProfileLock=new ReentrantLock();
    }
 else {
      mProfileData=null;
      mProfileLock=null;
    }
    mProfileRects=null;
    mProfilePaint=null;
  }
  value=SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY,false);
  if (value != mDebugDirtyRegions) {
    changed=true;
    mDebugDirtyRegions=value;
    if (mDebugDirtyRegions) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
  }
  value=SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY,false);
  if (value != mShowOverdraw) {
    changed=true;
    mShowOverdraw=value;
    if (surface != null && isEnabled()) {
      if (validate()) {
        sEglConfig=loadEglConfig();
        invalidate(surface);
      }
    }
  }
  if (nLoadProperties()) {
    changed=true;
  }
  return changed;
}","@Override boolean loadSystemProperties(Surface surface){
  boolean value;
  boolean changed=false;
  String profiling=SystemProperties.get(PROFILE_PROPERTY);
  value=PROFILE_PROPERTY_VISUALIZE.equalsIgnoreCase(profiling);
  if (value != mProfileVisualizerEnabled) {
    changed=true;
    mProfileVisualizerEnabled=value;
    mProfileRects=null;
    mProfilePaint=null;
  }
  if (!value) {
    value=Boolean.parseBoolean(profiling);
  }
  if (value != mProfileEnabled) {
    changed=true;
    mProfileEnabled=value;
    if (mProfileEnabled) {
      Log.d(LOG_TAG,""String_Node_Str"");
      int maxProfileFrames=SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY,PROFILE_MAX_FRAMES);
      mProfileData=new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
      for (int i=0; i < mProfileData.length; i+=PROFILE_FRAME_DATA_COUNT) {
        mProfileData[i]=mProfileData[i + 1]=mProfileData[i + 2]=-1;
      }
      mProfileLock=new ReentrantLock();
    }
 else {
      mProfileData=null;
      mProfileLock=null;
    }
    mProfileCurrentFrame=-PROFILE_FRAME_DATA_COUNT;
  }
  value=SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY,false);
  if (value != mDebugDirtyRegions) {
    changed=true;
    mDebugDirtyRegions=value;
    if (mDebugDirtyRegions) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
  }
  value=SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY,false);
  if (value != mShowOverdraw) {
    changed=true;
    mShowOverdraw=value;
    if (surface != null && isEnabled()) {
      if (validate()) {
        sEglConfig=loadEglConfig();
        invalidate(surface);
      }
    }
  }
  if (nLoadProperties()) {
    changed=true;
  }
  return changed;
}"
3013,"@Override boolean loadSystemProperties(Surface surface){
  boolean value;
  boolean changed=false;
  String profiling=SystemProperties.get(PROFILE_PROPERTY);
  value=PROFILE_PROPERTY_VISUALIZE.equalsIgnoreCase(profiling);
  if (value != mProfileVisualizerEnabled) {
    changed=true;
    mProfileVisualizerEnabled=value;
    mProfileRects=null;
    mProfilePaint=null;
  }
  if (!value) {
    value=Boolean.parseBoolean(profiling);
  }
  if (value != mProfileEnabled) {
    changed=true;
    mProfileEnabled=value;
    if (mProfileEnabled) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
    if (mProfileEnabled) {
      int maxProfileFrames=SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY,PROFILE_MAX_FRAMES);
      mProfileData=new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
      for (int i=0; i < mProfileData.length; i+=PROFILE_FRAME_DATA_COUNT) {
        mProfileData[i]=mProfileData[i + 1]=mProfileData[i + 2]=-1;
      }
      mProfileLock=new ReentrantLock();
    }
 else {
      mProfileData=null;
      mProfileLock=null;
    }
    mProfileRects=null;
    mProfilePaint=null;
  }
  value=SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY,false);
  if (value != mDebugDirtyRegions) {
    changed=true;
    mDebugDirtyRegions=value;
    if (mDebugDirtyRegions) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
  }
  value=SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY,false);
  if (value != mShowOverdraw) {
    changed=true;
    mShowOverdraw=value;
    if (surface != null && isEnabled()) {
      if (validate()) {
        sEglConfig=loadEglConfig();
        invalidate(surface);
      }
    }
  }
  if (nLoadProperties()) {
    changed=true;
  }
  return changed;
}","@Override boolean loadSystemProperties(Surface surface){
  boolean value;
  boolean changed=false;
  String profiling=SystemProperties.get(PROFILE_PROPERTY);
  value=PROFILE_PROPERTY_VISUALIZE.equalsIgnoreCase(profiling);
  if (value != mProfileVisualizerEnabled) {
    changed=true;
    mProfileVisualizerEnabled=value;
    mProfileRects=null;
    mProfilePaint=null;
  }
  if (!value) {
    value=Boolean.parseBoolean(profiling);
  }
  if (value != mProfileEnabled) {
    changed=true;
    mProfileEnabled=value;
    if (mProfileEnabled) {
      Log.d(LOG_TAG,""String_Node_Str"");
      int maxProfileFrames=SystemProperties.getInt(PROFILE_MAXFRAMES_PROPERTY,PROFILE_MAX_FRAMES);
      mProfileData=new float[maxProfileFrames * PROFILE_FRAME_DATA_COUNT];
      for (int i=0; i < mProfileData.length; i+=PROFILE_FRAME_DATA_COUNT) {
        mProfileData[i]=mProfileData[i + 1]=mProfileData[i + 2]=-1;
      }
      mProfileLock=new ReentrantLock();
    }
 else {
      mProfileData=null;
      mProfileLock=null;
    }
    mProfileCurrentFrame=-PROFILE_FRAME_DATA_COUNT;
  }
  value=SystemProperties.getBoolean(DEBUG_DIRTY_REGIONS_PROPERTY,false);
  if (value != mDebugDirtyRegions) {
    changed=true;
    mDebugDirtyRegions=value;
    if (mDebugDirtyRegions) {
      Log.d(LOG_TAG,""String_Node_Str"");
    }
  }
  value=SystemProperties.getBoolean(HardwareRenderer.DEBUG_SHOW_OVERDRAW_PROPERTY,false);
  if (value != mShowOverdraw) {
    changed=true;
    mShowOverdraw=value;
    if (surface != null && isEnabled()) {
      if (validate()) {
        sEglConfig=loadEglConfig();
        invalidate(surface);
      }
    }
  }
  if (nLoadProperties()) {
    changed=true;
  }
  return changed;
}"
3014,"/** 
 * Default implementation of  {@link android.view.Window.Callback#onMenuItemSelected}for activities.  This calls through to the new  {@link #onOptionsItemSelected} method for the{@link android.view.Window#FEATURE_OPTIONS_PANEL}panel, so that subclasses of Activity don't need to deal with feature codes.
 */
public boolean onMenuItemSelected(int featureId,MenuItem item){
switch (featureId) {
case Window.FEATURE_OPTIONS_PANEL:
    EventLog.writeEvent(50000,0,item.getTitleCondensed().toString());
  if (onOptionsItemSelected(item)) {
    return true;
  }
if (mFragments.dispatchOptionsItemSelected(item)) {
  return true;
}
if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
if (mParent == null) {
  return onNavigateUp();
}
 else {
  return mParent.onNavigateUpFromChild(this);
}
}
return false;
case Window.FEATURE_CONTEXT_MENU:
EventLog.writeEvent(50000,1,item.getTitleCondensed().toString());
if (onContextItemSelected(item)) {
return true;
}
return mFragments.dispatchContextItemSelected(item);
default :
return false;
}
}","/** 
 * Default implementation of  {@link android.view.Window.Callback#onMenuItemSelected}for activities.  This calls through to the new  {@link #onOptionsItemSelected} method for the{@link android.view.Window#FEATURE_OPTIONS_PANEL}panel, so that subclasses of Activity don't need to deal with feature codes.
 */
public boolean onMenuItemSelected(int featureId,MenuItem item){
  CharSequence titleCondensed=item.getTitleCondensed();
switch (featureId) {
case Window.FEATURE_OPTIONS_PANEL:
    if (titleCondensed != null) {
      EventLog.writeEvent(50000,0,titleCondensed.toString());
    }
  if (onOptionsItemSelected(item)) {
    return true;
  }
if (mFragments.dispatchOptionsItemSelected(item)) {
  return true;
}
if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
if (mParent == null) {
  return onNavigateUp();
}
 else {
  return mParent.onNavigateUpFromChild(this);
}
}
return false;
case Window.FEATURE_CONTEXT_MENU:
if (titleCondensed != null) {
EventLog.writeEvent(50000,1,titleCondensed.toString());
}
if (onContextItemSelected(item)) {
return true;
}
return mFragments.dispatchContextItemSelected(item);
default :
return false;
}
}"
3015,"/** 
 * Default implementation of  {@link android.view.Window.Callback#onMenuItemSelected}for activities.  This calls through to the new  {@link #onOptionsItemSelected} method for the{@link android.view.Window#FEATURE_OPTIONS_PANEL}panel, so that subclasses of Activity don't need to deal with feature codes.
 */
public boolean onMenuItemSelected(int featureId,MenuItem item){
switch (featureId) {
case Window.FEATURE_OPTIONS_PANEL:
    EventLog.writeEvent(50000,0,item.getTitleCondensed().toString());
  if (onOptionsItemSelected(item)) {
    return true;
  }
if (mFragments.dispatchOptionsItemSelected(item)) {
  return true;
}
if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
if (mParent == null) {
  return onNavigateUp();
}
 else {
  return mParent.onNavigateUpFromChild(this);
}
}
return false;
case Window.FEATURE_CONTEXT_MENU:
EventLog.writeEvent(50000,1,item.getTitleCondensed().toString());
if (onContextItemSelected(item)) {
return true;
}
return mFragments.dispatchContextItemSelected(item);
default :
return false;
}
}","/** 
 * Default implementation of  {@link android.view.Window.Callback#onMenuItemSelected}for activities.  This calls through to the new  {@link #onOptionsItemSelected} method for the{@link android.view.Window#FEATURE_OPTIONS_PANEL}panel, so that subclasses of Activity don't need to deal with feature codes.
 */
public boolean onMenuItemSelected(int featureId,MenuItem item){
  CharSequence titleCondensed=item.getTitleCondensed();
switch (featureId) {
case Window.FEATURE_OPTIONS_PANEL:
    if (titleCondensed != null) {
      EventLog.writeEvent(50000,0,titleCondensed.toString());
    }
  if (onOptionsItemSelected(item)) {
    return true;
  }
if (mFragments.dispatchOptionsItemSelected(item)) {
  return true;
}
if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
if (mParent == null) {
  return onNavigateUp();
}
 else {
  return mParent.onNavigateUpFromChild(this);
}
}
return false;
case Window.FEATURE_CONTEXT_MENU:
if (titleCondensed != null) {
EventLog.writeEvent(50000,1,titleCondensed.toString());
}
if (onContextItemSelected(item)) {
return true;
}
return mFragments.dispatchContextItemSelected(item);
default :
return false;
}
}"
3016,"/** 
 * Default implementation of  {@link android.view.Window.Callback#onMenuItemSelected}for activities.  This calls through to the new  {@link #onOptionsItemSelected} method for the{@link android.view.Window#FEATURE_OPTIONS_PANEL}panel, so that subclasses of Activity don't need to deal with feature codes.
 */
public boolean onMenuItemSelected(int featureId,MenuItem item){
switch (featureId) {
case Window.FEATURE_OPTIONS_PANEL:
    EventLog.writeEvent(50000,0,item.getTitleCondensed().toString());
  if (onOptionsItemSelected(item)) {
    return true;
  }
if (mFragments.dispatchOptionsItemSelected(item)) {
  return true;
}
if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
if (mParent == null) {
  return onNavigateUp();
}
 else {
  return mParent.onNavigateUpFromChild(this);
}
}
return false;
case Window.FEATURE_CONTEXT_MENU:
EventLog.writeEvent(50000,1,item.getTitleCondensed().toString());
if (onContextItemSelected(item)) {
return true;
}
return mFragments.dispatchContextItemSelected(item);
default :
return false;
}
}","/** 
 * Default implementation of  {@link android.view.Window.Callback#onMenuItemSelected}for activities.  This calls through to the new  {@link #onOptionsItemSelected} method for the{@link android.view.Window#FEATURE_OPTIONS_PANEL}panel, so that subclasses of Activity don't need to deal with feature codes.
 */
public boolean onMenuItemSelected(int featureId,MenuItem item){
  CharSequence titleCondensed=item.getTitleCondensed();
switch (featureId) {
case Window.FEATURE_OPTIONS_PANEL:
    if (titleCondensed != null) {
      EventLog.writeEvent(50000,0,titleCondensed.toString());
    }
  if (onOptionsItemSelected(item)) {
    return true;
  }
if (mFragments.dispatchOptionsItemSelected(item)) {
  return true;
}
if (item.getItemId() == android.R.id.home && mActionBar != null && (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
if (mParent == null) {
  return onNavigateUp();
}
 else {
  return mParent.onNavigateUpFromChild(this);
}
}
return false;
case Window.FEATURE_CONTEXT_MENU:
if (titleCondensed != null) {
EventLog.writeEvent(50000,1,titleCondensed.toString());
}
if (onContextItemSelected(item)) {
return true;
}
return mFragments.dispatchContextItemSelected(item);
default :
return false;
}
}"
3017,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
3018,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
3019,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
3020,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
3021,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
3022,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
3023,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
3024,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
3025,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
3026,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
3027,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
3028,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
3029,"private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}","private boolean isValidSystemDefaultIme(InputMethodInfo imi,Context context){
  if (!mSystemReady) {
    return false;
  }
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  if (imi.getIsDefaultResourceId() != 0) {
    try {
      Resources res=context.createPackageContext(imi.getPackageName(),0).getResources();
      if (res.getBoolean(imi.getIsDefaultResourceId()) && containsSubtypeOf(imi,context.getResources().getConfiguration().locale.getLanguage())) {
        return true;
      }
    }
 catch (    PackageManager.NameNotFoundException ex) {
    }
catch (    Resources.NotFoundException ex) {
    }
  }
  if (imi.getSubtypeCount() == 0) {
    Slog.w(TAG,""String_Node_Str"" + imi.getPackageName());
  }
  return false;
}"
3030,"boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}","boolean setInputMethodEnabledLocked(String id,boolean enabled){
  InputMethodInfo imm=mMethodMap.get(id);
  if (imm == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  List<Pair<String,ArrayList<String>>> enabledInputMethodsList=mSettings.getEnabledInputMethodsAndSubtypeListLocked();
  if (DEBUG) {
    Slog.d(TAG,(enabled ? ""String_Node_Str"" : ""String_Node_Str"") + id);
  }
  if (enabled) {
    for (    Pair<String,ArrayList<String>> pair : enabledInputMethodsList) {
      if (pair.first.equals(id)) {
        return true;
      }
    }
    mSettings.appendAndPutEnabledInputMethodLocked(id,false);
    return false;
  }
 else {
    StringBuilder builder=new StringBuilder();
    if (mSettings.buildAndPutEnabledInputMethodsStrRemovingIdLocked(builder,enabledInputMethodsList,id)) {
      final String selId=mSettings.getSelectedInputMethod();
      if (id.equals(selId) && !chooseNewDefaultIMELocked()) {
        Slog.i(TAG,""String_Node_Str"");
        resetSelectedInputMethodAndSubtypeLocked(""String_Node_Str"");
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
3031,"private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}","private static boolean isSystemImeThatHasEnglishSubtype(InputMethodInfo imi){
  if (!isSystemIme(imi)) {
    return false;
  }
  if (imi.isAuxiliaryIme()) {
    return false;
  }
  return containsSubtypeOf(imi,ENGLISH_LOCALE.getLanguage());
}"
3032,"static void notifyScreenshotError(Context context,NotificationManager nManager){
  Resources r=context.getResources();
  Notification n=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true).getNotification();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}","static void notifyScreenshotError(Context context,NotificationManager nManager){
  Resources r=context.getResources();
  Notification.Builder b=new Notification.Builder(context).setTicker(r.getString(R.string.screenshot_failed_title)).setContentTitle(r.getString(R.string.screenshot_failed_title)).setContentText(r.getString(R.string.screenshot_failed_text)).setSmallIcon(R.drawable.stat_notify_image_error).setWhen(System.currentTimeMillis()).setAutoCancel(true);
  Notification n=new Notification.BigTextStyle(b).bigText(r.getString(R.string.screenshot_failed_text)).build();
  nManager.notify(SCREENSHOT_NOTIFICATION_ID,n);
}"
3033,"@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].result=1;
  }
  return params[0];
}","@Override protected SaveImageInBackgroundData doInBackground(SaveImageInBackgroundData... params){
  if (params.length != 1)   return null;
  Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
  Context context=params[0].context;
  Bitmap image=params[0].image;
  Resources r=context.getResources();
  try {
    ContentValues values=new ContentValues();
    ContentResolver resolver=context.getContentResolver();
    values.put(MediaStore.Images.ImageColumns.DATA,mImageFilePath);
    values.put(MediaStore.Images.ImageColumns.TITLE,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DISPLAY_NAME,mImageFileName);
    values.put(MediaStore.Images.ImageColumns.DATE_TAKEN,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_ADDED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.DATE_MODIFIED,mImageTime);
    values.put(MediaStore.Images.ImageColumns.MIME_TYPE,""String_Node_Str"");
    Uri uri=resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,values);
    String subjectDate=new SimpleDateFormat(""String_Node_Str"").format(new Date(mImageTime));
    String subject=String.format(SCREENSHOT_SHARE_SUBJECT_TEMPLATE,subjectDate);
    Intent sharingIntent=new Intent(Intent.ACTION_SEND);
    sharingIntent.setType(""String_Node_Str"");
    sharingIntent.putExtra(Intent.EXTRA_STREAM,uri);
    sharingIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    Intent chooserIntent=Intent.createChooser(sharingIntent,null);
    chooserIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
    mNotificationBuilder.addAction(R.drawable.ic_menu_share,r.getString(com.android.internal.R.string.share),PendingIntent.getActivity(context,0,chooserIntent,PendingIntent.FLAG_CANCEL_CURRENT));
    OutputStream out=resolver.openOutputStream(uri);
    image.compress(Bitmap.CompressFormat.PNG,100,out);
    out.flush();
    out.close();
    values.clear();
    values.put(MediaStore.Images.ImageColumns.SIZE,new File(mImageFilePath).length());
    resolver.update(uri,values,null,null);
    params[0].imageUri=uri;
    params[0].result=0;
  }
 catch (  Exception e) {
    params[0].result=1;
  }
  return params[0];
}"
3034,"private void startBlurImageDisappearAnimator(){
  if (!enableBlurBackground)   return;
  AnimatorSet set=new AnimatorSet();
  if (enableBackgroundZoom)   set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,0.8f),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",mZoomRatio,1f),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",mZoomRatio,1f));
 else   set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,0f));
  set.addListener(mGlobalListener);
  set.addListener(mGlobalDisappearAnimators);
  set.setDuration(mBlurDuration);
  set.start();
}","private void startBlurImageDisappearAnimator(){
  if (!enableBlurBackground || mBlurImage == null)   return;
  AnimatorSet set=new AnimatorSet();
  if (enableBackgroundZoom)   set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,0.8f),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",mZoomRatio,1f),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",mZoomRatio,1f));
 else   set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,0f));
  set.addListener(mGlobalListener);
  set.addListener(mGlobalDisappearAnimators);
  set.setDuration(mBlurDuration);
  set.start();
}"
3035,"private void addBlurImage(){
  Bitmap bm=Blur.apply(getContext(),Util.getViewBitmap(this),mBlurRadius);
  ImageView im=new ImageView(getContext());
  im.setImageBitmap(bm);
  mBlurImage=im;
  this.addView(im);
}","private void addBlurImage(){
  Bitmap b=Util.getViewBitmap(this);
  if (b == null)   return;
  Bitmap bm=Blur.apply(getContext(),b);
  ImageView im=new ImageView(getContext());
  im.setImageBitmap(bm);
  mBlurImage=im;
  this.addView(im);
}"
3036,"private void startBlurImageAppearAnimator(){
  if (!enableBlurBackground)   return;
  AnimatorSet set=new AnimatorSet();
  if (enableBackgroundZoom) {
    set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",0.8f,1f),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,mZoomRatio),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,mZoomRatio));
  }
 else {
    set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",0f,1f));
  }
  set.addListener(mGlobalListener);
  set.addListener(mGlobalAppearingAnimators);
  set.setDuration(mBlurDuration);
  set.start();
}","private void startBlurImageAppearAnimator(){
  if (!enableBlurBackground || mBlurImage == null)   return;
  AnimatorSet set=new AnimatorSet();
  if (enableBackgroundZoom) {
    set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",0.8f,1f),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,mZoomRatio),ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",1f,mZoomRatio));
  }
 else {
    set.playTogether(ObjectAnimator.ofFloat(mBlurImage,""String_Node_Str"",0f,1f));
  }
  set.addListener(mGlobalListener);
  set.addListener(mGlobalAppearingAnimators);
  set.setDuration(mBlurDuration);
  set.start();
}"
3037,"public static Bitmap getViewBitmap(View v){
  v.clearFocus();
  v.setPressed(false);
  boolean willNotCache=v.willNotCacheDrawing();
  v.setWillNotCacheDrawing(false);
  int color=v.getDrawingCacheBackgroundColor();
  v.setDrawingCacheBackgroundColor(0);
  if (color != 0) {
    v.destroyDrawingCache();
  }
  v.buildDrawingCache();
  Bitmap cacheBitmap=v.getDrawingCache();
  if (cacheBitmap == null) {
    return null;
  }
  Bitmap bitmap=Bitmap.createBitmap(cacheBitmap);
  v.destroyDrawingCache();
  v.setWillNotCacheDrawing(willNotCache);
  v.setDrawingCacheBackgroundColor(color);
  return bitmap;
}","public static Bitmap getViewBitmap(View v){
  if (v.getWidth() == 0 || v.getHeight() == 0)   return null;
  Bitmap b=Bitmap.createBitmap(v.getWidth(),v.getHeight(),Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  v.draw(c);
  return b;
}"
3038,"/** 
 * Checks that element annotated with   {@link StorIOColumnMeta} satisfies all required conditions.
 * @param annotatedElement an annotated field
 * @throws SkipNotAnnotatedClassWithAnnotatedParentException
 */
protected void validateAnnotatedFieldOrMethod(@NotNull final Element annotatedElement) throws SkipNotAnnotatedClassWithAnnotatedParentException {
  final Element enclosingElement=annotatedElement.getEnclosingElement();
  if (enclosingElement.getKind() != CLASS) {
    throw new ProcessingException(annotatedElement,""String_Node_Str"" + getColumnAnnotationClass().getSimpleName() + ""String_Node_Str""+ annotatedElement.getSimpleName());
  }
  if (enclosingElement.getAnnotation(getTypeAnnotationClass()) == null) {
    Element superClass=typeUtils.asElement(((TypeElement)enclosingElement).getSuperclass());
    if (superClass.getAnnotation(getTypeAnnotationClass()) != null) {
      throw new SkipNotAnnotatedClassWithAnnotatedParentException(""String_Node_Str"" + getTypeAnnotationClass().getSimpleName() + ""String_Node_Str""+ getTypeAnnotationClass().getSimpleName()+ ""String_Node_Str"");
    }
 else {
      throw new ProcessingException(annotatedElement,""String_Node_Str"" + enclosingElement.getSimpleName() + ""String_Node_Str""+ getTypeAnnotationClass().getSimpleName());
    }
  }
  if (annotatedElement.getKind() == FIELD && annotatedElement.getModifiers().contains(PRIVATE)) {
    throw new ProcessingException(annotatedElement,getColumnAnnotationClass().getSimpleName() + ""String_Node_Str"" + annotatedElement.getSimpleName());
  }
  if (annotatedElement.getKind() == FIELD && annotatedElement.getModifiers().contains(FINAL)) {
    throw new ProcessingException(annotatedElement,getColumnAnnotationClass().getSimpleName() + ""String_Node_Str"" + annotatedElement.getSimpleName());
  }
  if (annotatedElement.getKind() == METHOD && !((ExecutableElement)annotatedElement).getParameters().isEmpty()) {
    throw new ProcessingException(annotatedElement,getColumnAnnotationClass().getSimpleName() + ""String_Node_Str"" + annotatedElement.getSimpleName());
  }
}","/** 
 * Checks that element annotated with   {@link StorIOColumnMeta} satisfies all required conditions.
 * @param annotatedElement an annotated field
 * @throws SkipNotAnnotatedClassWithAnnotatedParentException
 */
protected void validateAnnotatedFieldOrMethod(@NotNull final Element annotatedElement) throws SkipNotAnnotatedClassWithAnnotatedParentException {
  final Element enclosingElement=annotatedElement.getEnclosingElement();
  if (enclosingElement.getKind() != CLASS) {
    throw new ProcessingException(annotatedElement,""String_Node_Str"" + getColumnAnnotationClass().getSimpleName() + ""String_Node_Str""+ annotatedElement.getSimpleName());
  }
  if (enclosingElement.getAnnotation(getTypeAnnotationClass()) == null) {
    Element superClass=typeUtils.asElement(((TypeElement)enclosingElement).getSuperclass());
    if (superClass.getAnnotation(getTypeAnnotationClass()) != null) {
      throw new SkipNotAnnotatedClassWithAnnotatedParentException(""String_Node_Str"" + getTypeAnnotationClass().getSimpleName() + ""String_Node_Str""+ getTypeAnnotationClass().getSimpleName()+ ""String_Node_Str"");
    }
 else {
      throw new ProcessingException(annotatedElement,""String_Node_Str"" + enclosingElement.getSimpleName() + ""String_Node_Str""+ getTypeAnnotationClass().getSimpleName());
    }
  }
  if (annotatedElement.getModifiers().contains(PRIVATE)) {
    throw new ProcessingException(annotatedElement,getColumnAnnotationClass().getSimpleName() + ""String_Node_Str"" + annotatedElement.getSimpleName());
  }
  if (annotatedElement.getKind() == FIELD && annotatedElement.getModifiers().contains(FINAL)) {
    throw new ProcessingException(annotatedElement,getColumnAnnotationClass().getSimpleName() + ""String_Node_Str"" + annotatedElement.getSimpleName());
  }
  if (annotatedElement.getKind() == METHOD && !((ExecutableElement)annotatedElement).getParameters().isEmpty()) {
    throw new ProcessingException(annotatedElement,getColumnAnnotationClass().getSimpleName() + ""String_Node_Str"" + annotatedElement.getSimpleName());
  }
}"
3039,"@NonNull public static String getCreateTableQuery(){
  return ""String_Node_Str"" + TABLE + ""String_Node_Str""+ COLUMN_ID+ ""String_Node_Str""+ COLUMN_AUTHOR+ ""String_Node_Str""+ COLUMN_CONTENT+ ""String_Node_Str""+ ""String_Node_Str"";
}","@NonNull public static String getCreateTableQuery(){
  return ""String_Node_Str"" + TABLE + ""String_Node_Str""+ COLUMN_ID+ ""String_Node_Str""+ COLUMN_AUTHOR+ ""String_Node_Str""+ COLUMN_CONTENT+ ""String_Node_Str""+ COLUMN_SOME_BYTES+ ""String_Node_Str""+ ""String_Node_Str"";
}"
3040,"@Override public WxMpPayResult getJSSDKPayResult(String transactionId,String outTradeNo){
  String nonce_str=System.currentTimeMillis() + ""String_Node_Str"";
  SortedMap<String,String> packageParams=new TreeMap<String,String>();
  packageParams.put(""String_Node_Str"",wxMpConfigStorage.getAppId());
  packageParams.put(""String_Node_Str"",wxMpConfigStorage.getPartnerId());
  packageParams.put(""String_Node_Str"",transactionId);
  packageParams.put(""String_Node_Str"",outTradeNo);
  packageParams.put(""String_Node_Str"",nonce_str);
  String sign=WxCryptUtil.createSign(packageParams,wxMpConfigStorage.getPartnerKey());
  String xml=""String_Node_Str"" + ""String_Node_Str"" + wxMpConfigStorage.getAppId() + ""String_Node_Str""+ ""String_Node_Str""+ wxMpConfigStorage.getPartnerId()+ ""String_Node_Str""+ ""String_Node_Str""+ transactionId+ ""String_Node_Str""+ ""String_Node_Str""+ outTradeNo+ ""String_Node_Str""+ ""String_Node_Str""+ nonce_str+ ""String_Node_Str""+ ""String_Node_Str""+ sign+ ""String_Node_Str""+ ""String_Node_Str"";
  HttpPost httpPost=new HttpPost(""String_Node_Str"");
  if (httpProxy != null) {
    RequestConfig config=RequestConfig.custom().setProxy(httpProxy).build();
    httpPost.setConfig(config);
  }
  StringEntity entity=new StringEntity(xml,Consts.UTF_8);
  httpPost.setEntity(entity);
  try {
    CloseableHttpResponse response=httpClient.execute(httpPost);
    String responseContent=Utf8ResponseHandler.INSTANCE.handleResponse(response);
    XStream xstream=XStreamInitializer.getInstance();
    xstream.alias(""String_Node_Str"",WxMpPayResult.class);
    WxMpPayResult wxMpPayResult=(WxMpPayResult)xstream.fromXML(responseContent);
    return wxMpPayResult;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  return new WxMpPayResult();
}","@Override public WxMpPayResult getJSSDKPayResult(String transactionId,String outTradeNo){
  String nonce_str=System.currentTimeMillis() + ""String_Node_Str"";
  SortedMap<String,String> packageParams=new TreeMap<String,String>();
  packageParams.put(""String_Node_Str"",wxMpConfigStorage.getAppId());
  packageParams.put(""String_Node_Str"",wxMpConfigStorage.getPartnerId());
  if (transactionId != null && !""String_Node_Str"".equals(transactionId.trim()))   packageParams.put(""String_Node_Str"",transactionId);
 else   if (outTradeNo != null && !""String_Node_Str"".equals(outTradeNo.trim()))   packageParams.put(""String_Node_Str"",outTradeNo);
 else   throw new IllegalArgumentException(""String_Node_Str"");
  packageParams.put(""String_Node_Str"",nonce_str);
  packageParams.put(""String_Node_Str"",WxCryptUtil.createSign(packageParams,wxMpConfigStorage.getPartnerKey()));
  StringBuilder request=new StringBuilder(""String_Node_Str"");
  for (  Entry<String,String> para : packageParams.entrySet()) {
    request.append(String.format(""String_Node_Str"",para.getKey(),para.getValue(),para.getKey()));
  }
  request.append(""String_Node_Str"");
  HttpPost httpPost=new HttpPost(""String_Node_Str"");
  if (httpProxy != null) {
    RequestConfig config=RequestConfig.custom().setProxy(httpProxy).build();
    httpPost.setConfig(config);
  }
  StringEntity entity=new StringEntity(request.toString(),Consts.UTF_8);
  httpPost.setEntity(entity);
  try {
    CloseableHttpResponse response=httpClient.execute(httpPost);
    String responseContent=Utf8ResponseHandler.INSTANCE.handleResponse(response);
    XStream xstream=XStreamInitializer.getInstance();
    xstream.alias(""String_Node_Str"",WxMpPayResult.class);
    WxMpPayResult wxMpPayResult=(WxMpPayResult)xstream.fromXML(responseContent);
    return wxMpPayResult;
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
3041,"protected <T,E>T executeInternal(RequestExecutor<T,E> executor,String uri,E data) throws WxErrorException {
  String accessToken=getAccessToken(false);
  String uriWithAccessToken=uri;
  uriWithAccessToken+=uri.indexOf('?') == -1 ? ""String_Node_Str"" + accessToken : ""String_Node_Str"" + accessToken;
  try {
    return executor.execute(getHttpclient(),httpProxy,uriWithAccessToken,data);
  }
 catch (  WxErrorException e) {
    WxError error=e.getError();
    if (error.getErrorCode() == 42001 || error.getErrorCode() == 40001) {
      wxCpConfigStorage.expireAccessToken();
      return execute(executor,uri,data);
    }
    if (error.getErrorCode() != 0) {
      throw new WxErrorException(error);
    }
    return null;
  }
catch (  ClientProtocolException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","protected <T,E>T executeInternal(RequestExecutor<T,E> executor,String uri,E data) throws WxErrorException {
  if (uri.indexOf(""String_Node_Str"") != -1) {
    throw new IllegalArgumentException(""String_Node_Str"" + uri);
  }
  String accessToken=getAccessToken(false);
  String uriWithAccessToken=uri;
  uriWithAccessToken+=uri.indexOf('?') == -1 ? ""String_Node_Str"" + accessToken : ""String_Node_Str"" + accessToken;
  try {
    return executor.execute(getHttpclient(),httpProxy,uriWithAccessToken,data);
  }
 catch (  WxErrorException e) {
    WxError error=e.getError();
    if (error.getErrorCode() == 42001 || error.getErrorCode() == 40001) {
      wxCpConfigStorage.expireAccessToken();
      return execute(executor,uri,data);
    }
    if (error.getErrorCode() != 0) {
      throw new WxErrorException(error);
    }
    return null;
  }
catch (  ClientProtocolException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
3042,"protected <T,E>T executeInternal(RequestExecutor<T,E> executor,String uri,E data) throws WxErrorException {
  String accessToken=getAccessToken(false);
  String uriWithAccessToken=uri;
  uriWithAccessToken+=uri.indexOf('?') == -1 ? ""String_Node_Str"" + accessToken : ""String_Node_Str"" + accessToken;
  try {
    return executor.execute(getHttpclient(),httpProxy,uriWithAccessToken,data);
  }
 catch (  WxErrorException e) {
    WxError error=e.getError();
    if (error.getErrorCode() == 42001 || error.getErrorCode() == 40001) {
      wxMpConfigStorage.expireAccessToken();
      return execute(executor,uri,data);
    }
    if (error.getErrorCode() != 0) {
      throw new WxErrorException(error);
    }
    return null;
  }
catch (  ClientProtocolException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","protected <T,E>T executeInternal(RequestExecutor<T,E> executor,String uri,E data) throws WxErrorException {
  if (uri.indexOf(""String_Node_Str"") != -1) {
    throw new IllegalArgumentException(""String_Node_Str"" + uri);
  }
  String accessToken=getAccessToken(false);
  String uriWithAccessToken=uri;
  uriWithAccessToken+=uri.indexOf('?') == -1 ? ""String_Node_Str"" + accessToken : ""String_Node_Str"" + accessToken;
  try {
    return executor.execute(getHttpclient(),httpProxy,uriWithAccessToken,data);
  }
 catch (  WxErrorException e) {
    WxError error=e.getError();
    if (error.getErrorCode() == 42001 || error.getErrorCode() == 40001) {
      wxMpConfigStorage.expireAccessToken();
      return execute(executor,uri,data);
    }
    if (error.getErrorCode() != 0) {
      throw new WxErrorException(error);
    }
    return null;
  }
catch (  ClientProtocolException e) {
    throw new RuntimeException(e);
  }
catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
3043,"@Override public File getTmpDirFile(){
  return this.getTmpDirFile();
}","@Override public File getTmpDirFile(){
  return this.tmpDirFile;
}"
3044,"@Test(dependsOnMethods=""String_Node_Str"") public void testTagAddUsers() throws Exception {
  List<String> userIds=new ArrayList<String>();
  userIds.add(((ApiTestModule.WxXmlCpInMemoryConfigStorage)configStorage).getUserId());
  wxService.tagAddUsers(tagId,userIds);
}","@Test(dependsOnMethods=""String_Node_Str"") public void testTagAddUsers() throws Exception {
  List<String> userIds=new ArrayList<String>();
  userIds.add(((ApiTestModule.WxXmlCpInMemoryConfigStorage)configStorage).getUserId());
  wxService.tagAddUsers(tagId,userIds,null);
}"
3045,"public JsonElement serialize(WxCpMessage message,Type typeOfSrc,JsonSerializationContext context){
  JsonObject messageJson=new JsonObject();
  messageJson.addProperty(""String_Node_Str"",message.getAgentId());
  if (StringUtils.isNotBlank(message.getToUser())) {
    messageJson.addProperty(""String_Node_Str"",message.getToUser());
  }
  messageJson.addProperty(""String_Node_Str"",message.getMsgType());
  if (StringUtils.isNotBlank(message.getToParty())) {
    messageJson.addProperty(""String_Node_Str"",message.getToParty());
  }
  if (StringUtils.isNotBlank(message.getToTag())) {
    messageJson.addProperty(""String_Node_Str"",message.getToUser());
  }
  if (WxConsts.CUSTOM_MSG_TEXT.equals(message.getMsgType())) {
    JsonObject text=new JsonObject();
    text.addProperty(""String_Node_Str"",message.getContent());
    messageJson.add(""String_Node_Str"",text);
  }
  if (WxConsts.CUSTOM_MSG_IMAGE.equals(message.getMsgType())) {
    JsonObject image=new JsonObject();
    image.addProperty(""String_Node_Str"",message.getMediaId());
    messageJson.add(""String_Node_Str"",image);
  }
  if (WxConsts.CUSTOM_MSG_FILE.equals(message.getMsgType())) {
    JsonObject image=new JsonObject();
    image.addProperty(""String_Node_Str"",message.getMediaId());
    messageJson.add(""String_Node_Str"",image);
  }
  if (WxConsts.CUSTOM_MSG_VOICE.equals(message.getMsgType())) {
    JsonObject voice=new JsonObject();
    voice.addProperty(""String_Node_Str"",message.getMediaId());
    messageJson.add(""String_Node_Str"",voice);
  }
  if (WxConsts.CUSTOM_MSG_VIDEO.equals(message.getMsgType())) {
    JsonObject video=new JsonObject();
    video.addProperty(""String_Node_Str"",message.getMediaId());
    video.addProperty(""String_Node_Str"",message.getThumbMediaId());
    video.addProperty(""String_Node_Str"",message.getTitle());
    video.addProperty(""String_Node_Str"",message.getDescription());
    messageJson.add(""String_Node_Str"",video);
  }
  if (WxConsts.CUSTOM_MSG_NEWS.equals(message.getMsgType())) {
    JsonObject newsJsonObject=new JsonObject();
    JsonArray articleJsonArray=new JsonArray();
    for (    WxCpMessage.WxArticle article : message.getArticles()) {
      JsonObject articleJson=new JsonObject();
      articleJson.addProperty(""String_Node_Str"",article.getTitle());
      articleJson.addProperty(""String_Node_Str"",article.getDescription());
      articleJson.addProperty(""String_Node_Str"",article.getUrl());
      articleJson.addProperty(""String_Node_Str"",article.getPicUrl());
      articleJsonArray.add(articleJson);
    }
    newsJsonObject.add(""String_Node_Str"",articleJsonArray);
    messageJson.add(""String_Node_Str"",newsJsonObject);
  }
  return messageJson;
}","public JsonElement serialize(WxCpMessage message,Type typeOfSrc,JsonSerializationContext context){
  JsonObject messageJson=new JsonObject();
  messageJson.addProperty(""String_Node_Str"",message.getAgentId());
  if (StringUtils.isNotBlank(message.getToUser())) {
    messageJson.addProperty(""String_Node_Str"",message.getToUser());
  }
  messageJson.addProperty(""String_Node_Str"",message.getMsgType());
  if (StringUtils.isNotBlank(message.getToParty())) {
    messageJson.addProperty(""String_Node_Str"",message.getToParty());
  }
  if (StringUtils.isNotBlank(message.getToTag())) {
    messageJson.addProperty(""String_Node_Str"",message.getToTag());
  }
  if (WxConsts.CUSTOM_MSG_TEXT.equals(message.getMsgType())) {
    JsonObject text=new JsonObject();
    text.addProperty(""String_Node_Str"",message.getContent());
    messageJson.add(""String_Node_Str"",text);
  }
  if (WxConsts.CUSTOM_MSG_IMAGE.equals(message.getMsgType())) {
    JsonObject image=new JsonObject();
    image.addProperty(""String_Node_Str"",message.getMediaId());
    messageJson.add(""String_Node_Str"",image);
  }
  if (WxConsts.CUSTOM_MSG_FILE.equals(message.getMsgType())) {
    JsonObject image=new JsonObject();
    image.addProperty(""String_Node_Str"",message.getMediaId());
    messageJson.add(""String_Node_Str"",image);
  }
  if (WxConsts.CUSTOM_MSG_VOICE.equals(message.getMsgType())) {
    JsonObject voice=new JsonObject();
    voice.addProperty(""String_Node_Str"",message.getMediaId());
    messageJson.add(""String_Node_Str"",voice);
  }
  if (WxConsts.CUSTOM_MSG_VIDEO.equals(message.getMsgType())) {
    JsonObject video=new JsonObject();
    video.addProperty(""String_Node_Str"",message.getMediaId());
    video.addProperty(""String_Node_Str"",message.getThumbMediaId());
    video.addProperty(""String_Node_Str"",message.getTitle());
    video.addProperty(""String_Node_Str"",message.getDescription());
    messageJson.add(""String_Node_Str"",video);
  }
  if (WxConsts.CUSTOM_MSG_NEWS.equals(message.getMsgType())) {
    JsonObject newsJsonObject=new JsonObject();
    JsonArray articleJsonArray=new JsonArray();
    for (    WxCpMessage.WxArticle article : message.getArticles()) {
      JsonObject articleJson=new JsonObject();
      articleJson.addProperty(""String_Node_Str"",article.getTitle());
      articleJson.addProperty(""String_Node_Str"",article.getDescription());
      articleJson.addProperty(""String_Node_Str"",article.getUrl());
      articleJson.addProperty(""String_Node_Str"",article.getPicUrl());
      articleJsonArray.add(articleJson);
    }
    newsJsonObject.add(""String_Node_Str"",articleJsonArray);
    messageJson.add(""String_Node_Str"",newsJsonObject);
  }
  return messageJson;
}"
3046,"@Test(dependsOnMethods={""String_Node_Str""},dataProvider=""String_Node_Str"",enabled=true) public void testUploadMedia1(String mediaType,String fileType,String fileName) throws WxErrorException, IOException {
  InputStream inputStream=ClassLoader.getSystemResourceAsStream(fileName);
  WxUploadResult res=wxService.uploadMedia(mediaType,fileType,inputStream);
  System.out.println(res.toString());
}","@Test(dependsOnMethods={""String_Node_Str""},dataProvider=""String_Node_Str"",enabled=true) public void testUploadMedia1(String mediaType,String fileType,String fileName) throws WxErrorException, IOException {
  InputStream inputStream=ClassLoader.getSystemResourceAsStream(fileName);
  WxUploadResult res=wxService.uploadMedia(mediaType,fileType,inputStream);
  Assert.assertNotNull(res.getType());
  Assert.assertNotNull(res.getCreated_at());
  Assert.assertTrue(res.getMedia_id() != null || res.getThumb_media_id() != null);
}"
3047,"@Test(enabled=false) public void testCheckSignature() throws WxErrorException {
  String timestamp=""String_Node_Str"";
  String nonce=""String_Node_Str"";
  String signature=""String_Node_Str"";
  Assert.assertTrue(wxService.checkSignature(timestamp,nonce,signature));
}","@Test(enabled=true) public void testCheckSignature() throws WxErrorException {
  String timestamp=""String_Node_Str"";
  String nonce=""String_Node_Str"";
  String signature=""String_Node_Str"";
  Assert.assertTrue(wxService.checkSignature(timestamp,nonce,signature));
}"
3048,"@Test(dataProvider=""String_Node_Str"",dependsOnMethods=""String_Node_Str"",enabled=false) public void testCreateMenu(WxMenu wxMenu) throws WxErrorException {
  wxService.createMenu(wxMenu);
}","@Test(dataProvider=""String_Node_Str"",dependsOnMethods=""String_Node_Str"",enabled=true) public void testCreateMenu(WxMenu wxMenu) throws WxErrorException {
  wxService.createMenu(wxMenu);
}"
3049,"@Test(dependsOnMethods={""String_Node_Str"",""String_Node_Str""},enabled=false) public void testDeleteMenu() throws WxErrorException {
  wxService.deleteMenu();
}","@Test(dependsOnMethods={""String_Node_Str"",""String_Node_Str""},enabled=true) public void testDeleteMenu() throws WxErrorException {
  wxService.deleteMenu();
}"
3050,"@Test(dependsOnMethods={""String_Node_Str"",""String_Node_Str""},enabled=false) public void testGetMenu() throws WxErrorException {
  Assert.assertNotNull(wxService.getMenu());
}","@Test(dependsOnMethods={""String_Node_Str"",""String_Node_Str""},enabled=true) public void testGetMenu() throws WxErrorException {
  Assert.assertNotNull(wxService.getMenu());
}"
3051,"@Test(dependsOnMethods=""String_Node_Str"",enabled=false) public void sendCustomMessage() throws WxErrorException {
  WxXmlConfigStorage configProvider=(WxXmlConfigStorage)wxService.wxConfigStorage;
  WxCustomMessage message=new WxCustomMessage();
  message.setMsgtype(WxConsts.MSG_TEXT);
  message.setTouser(configProvider.getOpenId());
  message.setContent(""String_Node_Str"");
  wxService.sendCustomMessage(message);
}","@Test(dependsOnMethods=""String_Node_Str"",enabled=true) public void sendCustomMessage() throws WxErrorException {
  WxXmlConfigStorage configProvider=(WxXmlConfigStorage)wxService.wxConfigStorage;
  WxCustomMessage message=new WxCustomMessage();
  message.setMsgtype(WxConsts.MSG_TEXT);
  message.setTouser(configProvider.getOpenId());
  message.setContent(""String_Node_Str"");
  wxService.sendCustomMessage(message);
}"
3052,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  final int width=getWidth();
  final int height=getHeight();
  radius=Math.min(width,height) * 0.5f;
  centerY=radius;
  startX=radius;
  endX=width - radius;
  spotMinX=startX + borderWidth;
  spotMaxX=endX - borderWidth;
  spotSize=height - 4 * borderWidth;
  spotX=spotMinX;
  offLineWidth=0;
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  final int width=getWidth();
  final int height=getHeight();
  radius=Math.min(width,height) * 0.5f;
  centerY=radius;
  startX=radius;
  endX=width - radius;
  spotMinX=startX + borderWidth;
  spotMaxX=endX - borderWidth;
  spotSize=height - 4 * borderWidth;
  spotX=toggleOn ? spotMaxX : spotMinX;
  offLineWidth=0;
}"
3053,"/** 
 * This class requires that the input reader be a BufferedReader so it can do line-oriented operations. 
 */
public ConcatenatingReader(BufferedReader in){
  super(in);
  this.in=in;
}","/** 
 * This class requires that the input reader be a BufferedReader so it can do line-oriented operations. 
 */
public ConcatenatingReader(BufferedReader in){
  super(in);
  this.inReader=in;
}"
3054,"private void nextLine() throws IOException {
  String cur=in.readLine();
  if (cur == null) {
    curBuf=null;
    return;
  }
  int numChars=cur.length();
  boolean needNewline=true;
  if ((numChars > 0) && (cur.charAt(cur.length() - 1) == '\\')) {
    --numChars;
    needNewline=false;
  }
  char[] buf=new char[numChars + (needNewline ? newline.length() : 0)];
  cur.getChars(0,numChars,buf,0);
  if (needNewline) {
    newline.getChars(0,newline.length(),buf,numChars);
  }
  curBuf=buf;
  curPos=0;
}","private void nextLine() throws IOException {
  String cur=inReader.readLine();
  if (cur == null) {
    curBuf=null;
    return;
  }
  int numChars=cur.length();
  boolean needNewline=true;
  if ((numChars > 0) && (cur.charAt(cur.length() - 1) == '\\')) {
    --numChars;
    needNewline=false;
  }
  char[] buf=new char[numChars + (needNewline ? NEW_LINE.length() : 0)];
  cur.getChars(0,numChars,buf,0);
  if (needNewline) {
    NEW_LINE.getChars(0,NEW_LINE.length(),buf,numChars);
  }
  curBuf=buf;
  curPos=0;
}"
3055,"@Override public boolean ready() throws IOException {
  return curBuf != null || in.ready();
}","@Override public boolean ready() throws IOException {
  return curBuf != null || inReader.ready();
}"
3056,"/** 
 * Return whether given Class <i>typeA</i> is subtype of any of the given type names.
 * @param typeA the type to check
 * @param loader the classloader for loading the type (my be null)
 * @param types any requested supertypes
 */
public static boolean isSubTypeOf(String typeA,ClassLoader loader,String... types){
  if (typeA == null || typeA.equals(Constants.OBJECT_INTERNAL)) {
    return false;
  }
  if (types.length == 0) {
    return false;
  }
  boolean internal=types[0].contains(""String_Node_Str"");
  loader=(loader != null ? loader : ClassLoader.getSystemClassLoader());
  if (internal) {
    typeA=typeA.replace('.','/');
  }
 else {
    typeA=typeA.replace('/','.');
  }
  Set<String> typeSet=new HashSet<>(Arrays.asList(types));
  if (typeSet.contains(typeA)) {
    return true;
  }
  ClassInfo ci=ClassCache.getInstance().get(loader,typeA);
  Collection<String> sTypes=new LinkedList<>();
  for (  ClassInfo sCi : ci.getSupertypes(false)) {
    sTypes.add(internal ? sCi.getClassName() : sCi.getJavaClassName());
  }
  sTypes.retainAll(typeSet);
  return !sTypes.isEmpty();
}","/** 
 * Return whether given Class <i>typeA</i> is subtype of any of the given type names.
 * @param typeA the type to check
 * @param loader the classloader for loading the type (my be null)
 * @param types any requested supertypes
 */
public static boolean isSubTypeOf(String typeA,ClassLoader loader,String... types){
  if (typeA == null || typeA.equals(Constants.OBJECT_INTERNAL)) {
    return false;
  }
  if (types.length == 0) {
    return false;
  }
  boolean internal=types[0].contains(""String_Node_Str"");
  loader=(loader != null ? loader : ClassLoader.getSystemClassLoader());
  if (internal) {
    typeA=typeA.replace('.','/');
  }
 else {
    typeA=typeA.replace('/','.');
  }
  Set<String> typeSet=new HashSet<>(Arrays.asList(types));
  if (typeSet.contains(typeA)) {
    return true;
  }
  ClassInfo ci=ClassCache.getInstance().get(loader,typeA);
  Collection<ClassInfo> sTypesInfo=ci.getSupertypes(false);
  if (sTypesInfo != null) {
    Collection<String> sTypes=new ArrayList<>(sTypesInfo.size());
    for (    ClassInfo sCi : sTypesInfo) {
      sTypes.add(internal ? sCi.getClassName() : sCi.getJavaClassName());
    }
    sTypes.retainAll(typeSet);
    return !sTypes.isEmpty();
  }
 else {
    return false;
  }
}"
3057,"public MethodInstrumentorHelper methodHelper(){
  return helper;
}","@Override public MethodInstrumentorHelper methodHelper(){
  return helper;
}"
3058,"private void checkAugmentedReturn(MethodNode mn){
  if (isUnannotated(mn))   return;
  Type retType=Type.getReturnType(mn.desc);
  if (retType.getSort() != Type.VOID) {
    if (getReturnMethodParameter(mn) == Integer.MIN_VALUE) {
      String oldDesc=mn.desc;
      Type[] args=Type.getArgumentTypes(mn.desc);
      args=Arrays.copyOf(args,args.length + 1);
      args[args.length - 1]=retType;
      List<AnnotationNode> annots=new LinkedList<>();
      AnnotationNode an=new AnnotationNode(Type.getDescriptor(Return.class));
      annots.add(an);
      mn.visibleParameterAnnotations=mn.visibleParameterAnnotations != null ? Arrays.copyOf(mn.visibleParameterAnnotations,args.length) : new List[args.length];
      mn.visibleParameterAnnotations[args.length - 1]=annots;
      mn.desc=Type.getMethodDescriptor(retType,args);
      if (mn instanceof BTraceMethodNode) {
        BTraceMethodNode bmn=(BTraceMethodNode)mn;
        OnMethod om=bmn.getOnMethod();
        if (om != null && om.getTargetName().equals(mn.name) && om.getTargetDescriptor().equals(oldDesc)) {
          om.setReturnParameter(getReturnMethodParameter(mn));
          om.setTargetDescriptor(mn.desc);
        }
      }
    }
  }
}","private void checkAugmentedReturn(MethodNode mn){
  if (isUnannotated(mn))   return;
  Type retType=Type.getReturnType(mn.desc);
  if (retType.getSort() != Type.VOID) {
    if (getReturnMethodParameter(mn) == Integer.MIN_VALUE) {
      String oldDesc=mn.desc;
      Type[] args=Type.getArgumentTypes(mn.desc);
      args=Arrays.copyOf(args,args.length + 1);
      args[args.length - 1]=retType;
      List<AnnotationNode> annots=new ArrayList<>();
      AnnotationNode an=new AnnotationNode(Type.getDescriptor(Return.class));
      annots.add(an);
      mn.visibleParameterAnnotations=mn.visibleParameterAnnotations != null ? Arrays.copyOf(mn.visibleParameterAnnotations,args.length) : new List[args.length];
      mn.visibleParameterAnnotations[args.length - 1]=annots;
      mn.desc=Type.getMethodDescriptor(retType,args);
      if (mn instanceof BTraceMethodNode) {
        BTraceMethodNode bmn=(BTraceMethodNode)mn;
        OnMethod om=bmn.getOnMethod();
        if (om != null && om.getTargetName().equals(mn.name) && om.getTargetDescriptor().equals(oldDesc)) {
          om.setReturnParameter(getReturnMethodParameter(mn));
          om.setTargetDescriptor(mn.desc);
        }
      }
    }
  }
}"
3059,"private void addLevelField(ClassNode cn){
  if (cn.fields == null) {
    cn.fields=new LinkedList();
  }
  cn.fields.add(new FieldNode(Opcodes.ASM5,Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE,BTRACE_LEVEL_FLD,INT_DESC,null,0));
}","private void addLevelField(ClassNode cn){
  if (cn.fields == null) {
    cn.fields=new ArrayList();
  }
  cn.fields.add(new FieldNode(Opcodes.ASM5,Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE,BTRACE_LEVEL_FLD,INT_DESC,null,0));
}"
3060,"@Override public void run(){
  DatagramSocket ds=null;
  boolean entered=BTraceRuntime.enter();
  try {
    ds=new DatagramSocket();
    DatagramPacket dp=new DatagramPacket(new byte[0],0);
    try {
      dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));
    }
 catch (    UnknownHostException e) {
      System.err.println(""String_Node_Str"" + SharedSettings.GLOBAL.getStatsdHost());
      dp.setAddress(InetAddress.getLoopbackAddress());
    }
catch (    SecurityException e) {
      dp.setAddress(InetAddress.getLoopbackAddress());
    }
    dp.setPort(SharedSettings.GLOBAL.getStatsdPort());
    while (true) {
      Collection<String> msgs=new LinkedList<>();
      msgs.add(q.take());
      q.drainTo(msgs);
      StringBuilder sb=new StringBuilder();
      for (      String m : msgs) {
        if (sb.length() + m.length() < 511) {
          sb.append(m).append('\n');
        }
 else {
          dp.setData(sb.toString().getBytes(CHARSET));
          ds.send(dp);
          sb.setLength(0);
        }
      }
      if (sb.length() > 0) {
        dp.setData(sb.toString().getBytes(CHARSET));
        ds.send(dp);
      }
    }
  }
 catch (  IOException|InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    if (entered) {
      BTraceRuntime.leave();
    }
  }
}","@Override public void run(){
  DatagramSocket ds=null;
  boolean entered=BTraceRuntime.enter();
  try {
    ds=new DatagramSocket();
    DatagramPacket dp=new DatagramPacket(new byte[0],0);
    try {
      dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));
    }
 catch (    UnknownHostException e) {
      System.err.println(""String_Node_Str"" + SharedSettings.GLOBAL.getStatsdHost());
      dp.setAddress(InetAddress.getLoopbackAddress());
    }
catch (    SecurityException e) {
      dp.setAddress(InetAddress.getLoopbackAddress());
    }
    dp.setPort(SharedSettings.GLOBAL.getStatsdPort());
    while (true) {
      Collection<String> msgs=new ArrayList<>();
      msgs.add(q.take());
      q.drainTo(msgs);
      StringBuilder sb=new StringBuilder();
      for (      String m : msgs) {
        if (sb.length() + m.length() < 511) {
          sb.append(m).append('\n');
        }
 else {
          dp.setData(sb.toString().getBytes(CHARSET));
          ds.send(dp);
          sb.setLength(0);
        }
      }
      if (sb.length() > 0) {
        dp.setData(sb.toString().getBytes(CHARSET));
        ds.send(dp);
      }
    }
  }
 catch (  IOException|InterruptedException e) {
    e.printStackTrace();
  }
 finally {
    if (entered) {
      BTraceRuntime.leave();
    }
  }
}"
3061,"@SuppressWarnings(""String_Node_Str"") private Statsd(){
  e.submit(new Runnable(){
    @Override public void run(){
      DatagramSocket ds=null;
      boolean entered=BTraceRuntime.enter();
      try {
        ds=new DatagramSocket();
        DatagramPacket dp=new DatagramPacket(new byte[0],0);
        try {
          dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));
        }
 catch (        UnknownHostException e) {
          System.err.println(""String_Node_Str"" + SharedSettings.GLOBAL.getStatsdHost());
          dp.setAddress(InetAddress.getLoopbackAddress());
        }
catch (        SecurityException e) {
          dp.setAddress(InetAddress.getLoopbackAddress());
        }
        dp.setPort(SharedSettings.GLOBAL.getStatsdPort());
        while (true) {
          Collection<String> msgs=new LinkedList<>();
          msgs.add(q.take());
          q.drainTo(msgs);
          StringBuilder sb=new StringBuilder();
          for (          String m : msgs) {
            if (sb.length() + m.length() < 511) {
              sb.append(m).append('\n');
            }
 else {
              dp.setData(sb.toString().getBytes(CHARSET));
              ds.send(dp);
              sb.setLength(0);
            }
          }
          if (sb.length() > 0) {
            dp.setData(sb.toString().getBytes(CHARSET));
            ds.send(dp);
          }
        }
      }
 catch (      IOException|InterruptedException e) {
        e.printStackTrace();
      }
 finally {
        if (entered) {
          BTraceRuntime.leave();
        }
      }
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") private Statsd(){
  e.submit(new Runnable(){
    @Override public void run(){
      DatagramSocket ds=null;
      boolean entered=BTraceRuntime.enter();
      try {
        ds=new DatagramSocket();
        DatagramPacket dp=new DatagramPacket(new byte[0],0);
        try {
          dp.setAddress(InetAddress.getByName(SharedSettings.GLOBAL.getStatsdHost()));
        }
 catch (        UnknownHostException e) {
          System.err.println(""String_Node_Str"" + SharedSettings.GLOBAL.getStatsdHost());
          dp.setAddress(InetAddress.getLoopbackAddress());
        }
catch (        SecurityException e) {
          dp.setAddress(InetAddress.getLoopbackAddress());
        }
        dp.setPort(SharedSettings.GLOBAL.getStatsdPort());
        while (true) {
          Collection<String> msgs=new ArrayList<>();
          msgs.add(q.take());
          q.drainTo(msgs);
          StringBuilder sb=new StringBuilder();
          for (          String m : msgs) {
            if (sb.length() + m.length() < 511) {
              sb.append(m).append('\n');
            }
 else {
              dp.setData(sb.toString().getBytes(CHARSET));
              ds.send(dp);
              sb.setLength(0);
            }
          }
          if (sb.length() > 0) {
            dp.setData(sb.toString().getBytes(CHARSET));
            ds.send(dp);
          }
        }
      }
 catch (      IOException|InterruptedException e) {
        e.printStackTrace();
      }
 finally {
        if (entered) {
          BTraceRuntime.leave();
        }
      }
    }
  }
);
}"
3062,"public static List<Interval> invert(Collection<Interval> intervals){
  Interval remainder=new Interval(Integer.MIN_VALUE,Integer.MAX_VALUE);
  Set<Interval> sorted=new TreeSet(union(intervals));
  List<Interval> result=new LinkedList<>();
  for (  Interval i : sorted) {
    if (i.isAll()) {
      return Collections.singletonList(Interval.none());
    }
    if (i.a <= remainder.a) {
      if (i.b > remainder.a)       remainder.a=i.b != Integer.MAX_VALUE ? i.b + 1 : i.b;
    }
 else {
      result.add(new Interval(remainder.a,i.a - 1));
      if (i.b < remainder.b) {
        remainder.a=i.b != Integer.MAX_VALUE ? i.b + 1 : i.b;
      }
 else {
        remainder=null;
        break;
      }
    }
  }
  if (remainder != null) {
    result.add(remainder);
  }
  return result;
}","public static List<Interval> invert(Collection<Interval> intervals){
  Interval remainder=new Interval(Integer.MIN_VALUE,Integer.MAX_VALUE);
  Set<Interval> sorted=new TreeSet(union(intervals));
  List<Interval> result=new ArrayList<>();
  for (  Interval i : sorted) {
    if (i.isAll()) {
      return Collections.singletonList(Interval.none());
    }
    if (i.a <= remainder.a) {
      if (i.b > remainder.a)       remainder.a=i.b != Integer.MAX_VALUE ? i.b + 1 : i.b;
    }
 else {
      result.add(new Interval(remainder.a,i.a - 1));
      if (i.b < remainder.b) {
        remainder.a=i.b != Integer.MAX_VALUE ? i.b + 1 : i.b;
      }
 else {
        remainder=null;
        break;
      }
    }
  }
  if (remainder != null) {
    result.add(remainder);
  }
  return result;
}"
3063,"public static List<Interval> union(Collection<Interval> intervals){
  Set<Interval> itvSet=new TreeSet<>();
  itvSet.addAll(intervals);
  Iterator<Interval> iter=itvSet.iterator();
  Interval previous=null;
  while (iter.hasNext()) {
    if (previous == null) {
      previous=iter.next();
      continue;
    }
    Interval current=iter.next();
    if (current.a <= (previous.b != Integer.MAX_VALUE ? previous.b + 1 : Integer.MAX_VALUE)) {
      previous.b=current.b;
      iter.remove();
    }
 else {
      previous=current;
    }
  }
  return new LinkedList<>(itvSet);
}","public static List<Interval> union(Collection<Interval> intervals){
  Set<Interval> itvSet=new TreeSet<>();
  itvSet.addAll(intervals);
  Iterator<Interval> iter=itvSet.iterator();
  Interval previous=null;
  while (iter.hasNext()) {
    if (previous == null) {
      previous=iter.next();
      continue;
    }
    Interval current=iter.next();
    if (current.a <= (previous.b != Integer.MAX_VALUE ? previous.b + 1 : Integer.MAX_VALUE)) {
      previous.b=current.b;
      iter.remove();
    }
 else {
      previous=current;
    }
  }
  return new ArrayList<>(itvSet);
}"
3064,"@Override protected void visitMethodPrologue(){
  visitTryCatchBlock(start,end,end,THROWABLE_INTERNAL);
  visitLabel(start);
  super.visitMethodPrologue();
}","@Override protected void visitMethodPrologue(){
  addTryCatchHandler(start,end);
  visitLabel(start);
  super.visitMethodPrologue();
}"
3065,"@Override public void visitMaxs(int maxStack,int maxLocals){
  visitLabel(end);
  insertFrameReplaceStack(end,THROWABLE_TYPE);
  onErrorReturn();
  visitInsn(ATHROW);
  super.visitMaxs(maxStack,maxLocals);
}","@Override public void visitMaxs(int maxStack,int maxLocals){
  visitTryCatchBlock(start,end,end,THROWABLE_INTERNAL);
  visitLabel(end);
  insertFrameReplaceStack(end,THROWABLE_TYPE);
  onErrorReturn();
  visitInsn(ATHROW);
  super.visitMaxs(maxStack,maxLocals);
}"
3066,"@Test public void bytecodeValidation() throws Exception {
  originalBC=loadTargetClass(""String_Node_Str"");
  transform(""String_Node_Str"");
  checkTransformation(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","@Test public void bytecodeValidation() throws Exception {
  originalBC=loadTargetClass(""String_Node_Str"");
  transform(""String_Node_Str"");
  checkTransformation(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
3067,"@OnMethod(clazz=""String_Node_Str"",method=""String_Node_Str"") public static void onExecute(@Self Object currentStatement,AnyType[] args){
  if (args.length == 0) {
    executingStatement=Collections.get(preparedStatementDescriptions,currentStatement);
  }
 else {
    executingStatement=useStackTrace ? Threads.jstackStr() : str(args[0]);
  }
}","@OnMethod(clazz=""String_Node_Str"",method=""String_Node_Str"") public static void onExecute(@Self Statement currentStatement,AnyType[] args){
  if (args.length == 0) {
    executingStatement=Collections.get(preparedStatementDescriptions,currentStatement);
  }
 else {
    executingStatement=useStackTrace ? Threads.jstackStr() : str(args[0]);
  }
}"
3068,"@OnMethod(clazz=""String_Node_Str"",method=""String_Node_Str"") public static void onExecute(@Self Object currentStatement,AnyType[] args){
  if (args.length == 0) {
    executingStatement=Collections.get(preparedStatementDescriptions,currentStatement);
  }
 else {
    executingStatement=useStackTrace ? Threads.jstackStr() : str(args[0]);
  }
}","@OnMethod(clazz=""String_Node_Str"",method=""String_Node_Str"") public static void onExecute(@Self Statement currentStatement,AnyType[] args){
  if (args.length == 0) {
    executingStatement=Collections.get(preparedStatementDescriptions,currentStatement);
  }
 else {
    executingStatement=useStackTrace ? Threads.jstackStr() : str(args[0]);
  }
}"
3069,"private static void parseArgs(){
  String p=argMap.get(""String_Node_Str"");
  if (p != null) {
    usage();
  }
  processClasspaths();
  p=argMap.get(""String_Node_Str"");
  settings.setDebug(p != null && !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isDebug());
  }
  p=argMap.get(""String_Node_Str"");
  settings.setRetransformStartup(p == null || !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isRetransformStartup());
  }
  p=argMap.get(""String_Node_Str"");
  boolean dumpClasses=p != null && !""String_Node_Str"".equals(p);
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + dumpClasses);
  }
  if (dumpClasses) {
    String dumpDir=argMap.get(""String_Node_Str"");
    settings.setDumpDir(dumpDir != null ? dumpDir : ""String_Node_Str"");
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + dumpDir);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null) {
    debugPrint(""String_Node_Str"" + p);
    System.setProperty(BTraceRuntime.CMD_QUEUE_LIMIT_KEY,p);
  }
  p=argMap.get(""String_Node_Str"");
  settings.setTrackRetransforms(p != null && !""String_Node_Str"".equals(p));
  if (settings.isTrackRetransforms()) {
    debugPrint(""String_Node_Str"" + settings.isTrackRetransforms());
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputFile(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputDir(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Long msParsed=null;
    try {
      msParsed=Long.parseLong(p);
      fileRollMilliseconds=msParsed;
    }
 catch (    NumberFormatException nfe) {
      fileRollMilliseconds=null;
    }
    if (fileRollMilliseconds != null) {
      debugPrint(""String_Node_Str"" + settings.isUnsafe());
      settings.setFileRollMilliseconds(fileRollMilliseconds.intValue());
      if (isDebug()) {
        debugPrint(""String_Node_Str"" + fileRollMilliseconds);
      }
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Integer rolls=null;
    try {
      rolls=Integer.parseInt(p);
    }
 catch (    NumberFormatException nfe) {
      rolls=null;
    }
    if (rolls != null) {
      settings.setFileRollMaxRolls(rolls);
    }
  }
  p=argMap.get(""String_Node_Str"");
  settings.setUnsafe(p != null && ""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isUnsafe());
  }
  String statsdDef=argMap.get(""String_Node_Str"");
  if (statsdDef != null) {
    String[] parts=statsdDef.split(""String_Node_Str"");
    if (parts.length == 2) {
      settings.setStatsdHost(parts[0].trim());
      try {
        settings.setStatsdPort(Integer.parseInt(parts[1].trim()));
      }
 catch (      NumberFormatException e) {
        debug.warning(""String_Node_Str"" + parts[1]);
      }
    }
 else     if (parts.length == 1) {
      settings.setStatsdHost(parts[0].trim());
    }
  }
  String probeDescPath=argMap.get(""String_Node_Str"");
  settings.setProbeDescPath(probeDescPath != null ? probeDescPath : ""String_Node_Str"");
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.getProbeDescPath());
  }
}","private static void parseArgs(){
  String p=argMap.get(""String_Node_Str"");
  if (p != null) {
    usage();
  }
  processClasspaths();
  p=argMap.get(""String_Node_Str"");
  settings.setDebug(p != null && !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isDebug());
  }
  p=argMap.get(""String_Node_Str"");
  settings.setRetransformStartup(p == null || !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isRetransformStartup());
  }
  p=argMap.get(""String_Node_Str"");
  boolean dumpClasses=p != null && !""String_Node_Str"".equals(p);
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + dumpClasses);
  }
  if (dumpClasses) {
    String dumpDir=argMap.get(""String_Node_Str"");
    settings.setDumpDir(dumpDir != null ? dumpDir : ""String_Node_Str"");
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + dumpDir);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null) {
    debugPrint(""String_Node_Str"" + p);
    System.setProperty(BTraceRuntime.CMD_QUEUE_LIMIT_KEY,p);
  }
  p=argMap.get(""String_Node_Str"");
  settings.setTrackRetransforms(p != null && !""String_Node_Str"".equals(p));
  if (settings.isTrackRetransforms()) {
    debugPrint(""String_Node_Str"" + settings.isTrackRetransforms());
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputFile(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputDir(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Long msParsed=null;
    try {
      msParsed=Long.parseLong(p);
      fileRollMilliseconds=msParsed;
    }
 catch (    NumberFormatException nfe) {
      fileRollMilliseconds=null;
    }
    if (fileRollMilliseconds != null) {
      settings.setFileRollMilliseconds(fileRollMilliseconds.intValue());
      if (isDebug()) {
        debugPrint(""String_Node_Str"" + fileRollMilliseconds);
      }
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Integer rolls=null;
    try {
      rolls=Integer.parseInt(p);
    }
 catch (    NumberFormatException nfe) {
      rolls=null;
    }
    if (rolls != null) {
      settings.setFileRollMaxRolls(rolls);
    }
  }
  p=argMap.get(""String_Node_Str"");
  settings.setUnsafe(p != null && ""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isUnsafe());
  }
  String statsdDef=argMap.get(""String_Node_Str"");
  if (statsdDef != null) {
    String[] parts=statsdDef.split(""String_Node_Str"");
    if (parts.length == 2) {
      settings.setStatsdHost(parts[0].trim());
      try {
        settings.setStatsdPort(Integer.parseInt(parts[1].trim()));
      }
 catch (      NumberFormatException e) {
        debug.warning(""String_Node_Str"" + parts[1]);
      }
    }
 else     if (parts.length == 1) {
      settings.setStatsdHost(parts[0].trim());
    }
  }
  String probeDescPath=argMap.get(""String_Node_Str"");
  settings.setProbeDescPath(probeDescPath != null ? probeDescPath : ""String_Node_Str"");
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.getProbeDescPath());
  }
}"
3070,"private FileWriter getNextWriter() throws IOException {
  currentFileWriter.close();
  File scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  File scriptOutputFile_renameTo=new File(path + File.separator + baseName.substring(0,baseName.indexOf(""String_Node_Str""))+ ""String_Node_Str""+ (counter++));
  if (scriptOutputFile_renameTo.exists()) {
    scriptOutputFile_renameTo.delete();
  }
  scriptOutputFile_renameFrom.renameTo(scriptOutputFile_renameTo);
  scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  if (counter > settings.getFileRollMaxRolls()) {
    counter=1;
  }
  return new FileWriter(scriptOutputFile_renameFrom);
}","private FileWriter getNextWriter() throws IOException {
  currentFileWriter.close();
  File scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  File scriptOutputFile_renameTo=new File(path + File.separator + baseName+ ""String_Node_Str""+ (counter++));
  if (scriptOutputFile_renameTo.exists()) {
    scriptOutputFile_renameTo.delete();
  }
  scriptOutputFile_renameFrom.renameTo(scriptOutputFile_renameTo);
  scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  if (counter > settings.getFileRollMaxRolls()) {
    counter=1;
  }
  return new FileWriter(scriptOutputFile_renameFrom);
}"
3071,"private static void parseArgs(){
  String p=argMap.get(""String_Node_Str"");
  if (p != null) {
    usage();
  }
  processClasspaths();
  p=argMap.get(""String_Node_Str"");
  settings.setDebug(p != null && !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isDebug());
  }
  p=argMap.get(""String_Node_Str"");
  settings.setRetransformStartup(p == null || !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isRetransformStartup());
  }
  p=argMap.get(""String_Node_Str"");
  boolean dumpClasses=p != null && !""String_Node_Str"".equals(p);
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + dumpClasses);
  }
  if (dumpClasses) {
    String dumpDir=argMap.get(""String_Node_Str"");
    settings.setDumpDir(dumpDir != null ? dumpDir : ""String_Node_Str"");
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + dumpDir);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null) {
    debugPrint(""String_Node_Str"" + p);
    System.setProperty(BTraceRuntime.CMD_QUEUE_LIMIT_KEY,p);
  }
  p=argMap.get(""String_Node_Str"");
  settings.setTrackRetransforms(p != null && !""String_Node_Str"".equals(p));
  if (settings.isTrackRetransforms()) {
    debugPrint(""String_Node_Str"" + settings.isTrackRetransforms());
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputFile(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputDir(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Long msParsed=null;
    try {
      msParsed=Long.parseLong(p);
      fileRollMilliseconds=msParsed;
    }
 catch (    NumberFormatException nfe) {
      fileRollMilliseconds=null;
    }
    if (fileRollMilliseconds != null) {
      debugPrint(""String_Node_Str"" + settings.isUnsafe());
      settings.setFileRollMilliseconds(fileRollMilliseconds.intValue());
      if (isDebug()) {
        debugPrint(""String_Node_Str"" + fileRollMilliseconds);
      }
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Integer rolls=null;
    try {
      rolls=Integer.parseInt(p);
    }
 catch (    NumberFormatException nfe) {
      rolls=null;
    }
    if (rolls != null) {
      settings.setFileRollMaxRolls(rolls);
    }
  }
  p=argMap.get(""String_Node_Str"");
  settings.setUnsafe(p != null && ""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isUnsafe());
  }
  String statsdDef=argMap.get(""String_Node_Str"");
  if (statsdDef != null) {
    String[] parts=statsdDef.split(""String_Node_Str"");
    if (parts.length == 2) {
      settings.setStatsdHost(parts[0].trim());
      try {
        settings.setStatsdPort(Integer.parseInt(parts[1].trim()));
      }
 catch (      NumberFormatException e) {
        debug.warning(""String_Node_Str"" + parts[1]);
      }
    }
 else     if (parts.length == 1) {
      settings.setStatsdHost(parts[0].trim());
    }
  }
  String probeDescPath=argMap.get(""String_Node_Str"");
  settings.setProbeDescPath(probeDescPath != null ? probeDescPath : ""String_Node_Str"");
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.getProbeDescPath());
  }
}","private static void parseArgs(){
  String p=argMap.get(""String_Node_Str"");
  if (p != null) {
    usage();
  }
  processClasspaths();
  p=argMap.get(""String_Node_Str"");
  settings.setDebug(p != null && !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isDebug());
  }
  p=argMap.get(""String_Node_Str"");
  settings.setRetransformStartup(p == null || !""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isRetransformStartup());
  }
  p=argMap.get(""String_Node_Str"");
  boolean dumpClasses=p != null && !""String_Node_Str"".equals(p);
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + dumpClasses);
  }
  if (dumpClasses) {
    String dumpDir=argMap.get(""String_Node_Str"");
    settings.setDumpDir(dumpDir != null ? dumpDir : ""String_Node_Str"");
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + dumpDir);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null) {
    debugPrint(""String_Node_Str"" + p);
    System.setProperty(BTraceRuntime.CMD_QUEUE_LIMIT_KEY,p);
  }
  p=argMap.get(""String_Node_Str"");
  settings.setTrackRetransforms(p != null && !""String_Node_Str"".equals(p));
  if (settings.isTrackRetransforms()) {
    debugPrint(""String_Node_Str"" + settings.isTrackRetransforms());
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputFile(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    settings.setOutputDir(p);
    if (isDebug()) {
      debugPrint(""String_Node_Str"" + p);
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Long msParsed=null;
    try {
      msParsed=Long.parseLong(p);
      fileRollMilliseconds=msParsed;
    }
 catch (    NumberFormatException nfe) {
      fileRollMilliseconds=null;
    }
    if (fileRollMilliseconds != null) {
      settings.setFileRollMilliseconds(fileRollMilliseconds.intValue());
      if (isDebug()) {
        debugPrint(""String_Node_Str"" + fileRollMilliseconds);
      }
    }
  }
  p=argMap.get(""String_Node_Str"");
  if (p != null && p.length() > 0) {
    Integer rolls=null;
    try {
      rolls=Integer.parseInt(p);
    }
 catch (    NumberFormatException nfe) {
      rolls=null;
    }
    if (rolls != null) {
      settings.setFileRollMaxRolls(rolls);
    }
  }
  p=argMap.get(""String_Node_Str"");
  settings.setUnsafe(p != null && ""String_Node_Str"".equals(p));
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.isUnsafe());
  }
  String statsdDef=argMap.get(""String_Node_Str"");
  if (statsdDef != null) {
    String[] parts=statsdDef.split(""String_Node_Str"");
    if (parts.length == 2) {
      settings.setStatsdHost(parts[0].trim());
      try {
        settings.setStatsdPort(Integer.parseInt(parts[1].trim()));
      }
 catch (      NumberFormatException e) {
        debug.warning(""String_Node_Str"" + parts[1]);
      }
    }
 else     if (parts.length == 1) {
      settings.setStatsdHost(parts[0].trim());
    }
  }
  String probeDescPath=argMap.get(""String_Node_Str"");
  settings.setProbeDescPath(probeDescPath != null ? probeDescPath : ""String_Node_Str"");
  if (isDebug()) {
    debugPrint(""String_Node_Str"" + settings.getProbeDescPath());
  }
}"
3072,"private FileWriter getNextWriter() throws IOException {
  currentFileWriter.close();
  File scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  File scriptOutputFile_renameTo=new File(path + File.separator + baseName.substring(0,baseName.indexOf(""String_Node_Str""))+ ""String_Node_Str""+ (counter++));
  if (scriptOutputFile_renameTo.exists()) {
    scriptOutputFile_renameTo.delete();
  }
  scriptOutputFile_renameFrom.renameTo(scriptOutputFile_renameTo);
  scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  if (counter > settings.getFileRollMaxRolls()) {
    counter=1;
  }
  return new FileWriter(scriptOutputFile_renameFrom);
}","private FileWriter getNextWriter() throws IOException {
  currentFileWriter.close();
  File scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  File scriptOutputFile_renameTo=new File(path + File.separator + baseName+ ""String_Node_Str""+ (counter++));
  if (scriptOutputFile_renameTo.exists()) {
    scriptOutputFile_renameTo.delete();
  }
  scriptOutputFile_renameFrom.renameTo(scriptOutputFile_renameTo);
  scriptOutputFile_renameFrom=new File(path + File.separator + baseName);
  if (counter > settings.getFileRollMaxRolls()) {
    counter=1;
  }
  return new FileWriter(scriptOutputFile_renameFrom);
}"
3073,"@Override public void run(){
  boolean entered=BTraceRuntime.enter(rt);
  try {
    if (this.runtime != null)     this.runtime.handleExit(0);
  }
  finally {
    if (entered) {
      BTraceRuntime.leave();
    }
  }
}","@Override public void run(){
  boolean entered=BTraceRuntime.enter(runtime);
  try {
    if (runtime != null)     runtime.handleExit(0);
  }
  finally {
    if (entered) {
      BTraceRuntime.leave();
    }
  }
}"
3074,"protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className + ""String_Node_Str"",className + ""String_Node_Str"",btraceCode);
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter(btraceCode);
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      boolean entered=BTraceRuntime.enter(rt);
      try {
        if (this.runtime != null)         this.runtime.handleExit(0);
      }
  finally {
        if (entered) {
          BTraceRuntime.leave();
        }
      }
    }
  }
));
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  onCommand(new OkayCommand());
  boolean enteredHere=BTraceRuntime.enter();
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    if (!enteredHere)     BTraceRuntime.enter();
  }
  return this.btraceClazz;
}","protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className + ""String_Node_Str"",className + ""String_Node_Str"",btraceCode);
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter(btraceCode);
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      boolean entered=BTraceRuntime.enter(runtime);
      try {
        if (runtime != null)         runtime.handleExit(0);
      }
  finally {
        if (entered) {
          BTraceRuntime.leave();
        }
      }
    }
  }
));
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  onCommand(new OkayCommand());
  boolean enteredHere=BTraceRuntime.enter();
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    if (!enteredHere)     BTraceRuntime.enter();
  }
  return this.btraceClazz;
}"
3075,"public static <V>V removeFirst(Deque<V> queue){
  if (queue instanceof BTraceDeque || queue.getClass().getClassLoader() == null) {
    return queue.removeLast();
  }
 else {
    throw new IllegalArgumentException();
  }
}","public static <V>V removeFirst(Deque<V> queue){
  if (queue instanceof BTraceDeque || queue.getClass().getClassLoader() == null) {
    return queue.removeFirst();
  }
 else {
    throw new IllegalArgumentException();
  }
}"
3076,"protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter(btraceCode);
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  runtime.send(new OkayCommand());
  boolean enteredHere=BTraceRuntime.enter();
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    if (!enteredHere)     BTraceRuntime.enter();
  }
  return this.btraceClazz;
}","protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter(btraceCode);
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className + ""String_Node_Str"",className + ""String_Node_Str"",btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  Main.dumpClass(className,className,codeBuf);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  runtime.send(new OkayCommand());
  boolean enteredHere=BTraceRuntime.enter();
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    if (!enteredHere)     BTraceRuntime.enter();
  }
  return this.btraceClazz;
}"
3077,"private Map<String,byte[]> compile(MemoryJavaFileManager manager,Iterable<? extends JavaFileObject> compUnits,Writer err,String sourcePath,String classPath){
  DiagnosticCollector<JavaFileObject> diagnostics=new DiagnosticCollector<JavaFileObject>();
  List<String> options=new ArrayList<String>();
  options.add(""String_Node_Str"");
  options.add(""String_Node_Str"");
  options.add(""String_Node_Str"");
  if (sourcePath != null) {
    options.add(""String_Node_Str"");
    options.add(sourcePath);
  }
  if (classPath != null) {
    options.add(""String_Node_Str"");
    options.add(classPath);
  }
  JavacTask task=(JavacTask)compiler.getTask(err,manager,diagnostics,options,null,compUnits);
  Verifier btraceVerifier=new Verifier(unsafe);
  task.setTaskListener(btraceVerifier);
  List<Processor> processors=new ArrayList<Processor>(1);
  processors.add(btraceVerifier);
  task.setProcessors(processors);
  PrintWriter perr;
  if (err instanceof PrintWriter) {
    perr=(PrintWriter)err;
  }
 else {
    perr=new PrintWriter(err);
  }
  if (task.call() == false) {
    for (    Diagnostic diagnostic : diagnostics.getDiagnostics()) {
      perr.println(diagnostic.getMessage(null));
    }
    perr.flush();
    return null;
  }
  try {
    Map<String,byte[]> classBytes=manager.getClassBytes();
    List<String> classNames=btraceVerifier.getClassNames();
    Map<String,byte[]> result=new HashMap<String,byte[]>();
    for (    String name : classNames) {
      if (classBytes.containsKey(name)) {
        dump(name + ""String_Node_Str"",classBytes.get(name));
        ClassReader cr=new ClassReader(classBytes.get(name));
        ClassWriter cw=new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        cr.accept(new Postprocessor(cw),ClassReader.EXPAND_FRAMES + ClassReader.SKIP_DEBUG);
        result.put(name,cw.toByteArray());
        dump(name,cw.toByteArray());
      }
    }
    return result;
  }
  finally {
    try {
      manager.close();
    }
 catch (    IOException exp) {
    }
  }
}","private Map<String,byte[]> compile(MemoryJavaFileManager manager,Iterable<? extends JavaFileObject> compUnits,Writer err,String sourcePath,String classPath){
  DiagnosticCollector<JavaFileObject> diagnostics=new DiagnosticCollector<JavaFileObject>();
  List<String> options=new ArrayList<String>();
  options.add(""String_Node_Str"");
  options.add(""String_Node_Str"");
  options.add(""String_Node_Str"");
  if (sourcePath != null) {
    options.add(""String_Node_Str"");
    options.add(sourcePath);
  }
  if (classPath != null) {
    options.add(""String_Node_Str"");
    options.add(classPath);
  }
  JavacTask task=(JavacTask)compiler.getTask(err,manager,diagnostics,options,null,compUnits);
  Verifier btraceVerifier=new Verifier(unsafe);
  task.setTaskListener(btraceVerifier);
  List<Processor> processors=new ArrayList<Processor>(1);
  processors.add(btraceVerifier);
  task.setProcessors(processors);
  PrintWriter perr;
  if (err instanceof PrintWriter) {
    perr=(PrintWriter)err;
  }
 else {
    perr=new PrintWriter(err);
  }
  if (task.call() == false) {
    for (    Diagnostic diagnostic : diagnostics.getDiagnostics()) {
      perr.println(diagnostic.getMessage(null));
    }
    perr.flush();
    return null;
  }
  try {
    Map<String,byte[]> classBytes=manager.getClassBytes();
    List<String> classNames=btraceVerifier.getClassNames();
    Map<String,byte[]> result=new HashMap<String,byte[]>();
    for (    String name : classNames) {
      if (classBytes.containsKey(name)) {
        dump(name + ""String_Node_Str"",classBytes.get(name));
        ClassReader cr=new ClassReader(classBytes.get(name));
        ClassWriter cw=new ClassWriter(ClassWriter.COMPUTE_FRAMES);
        cr.accept(new Postprocessor(cw),ClassReader.EXPAND_FRAMES + ClassReader.SKIP_DEBUG);
        result.put(name,cw.toByteArray());
        dump(name + ""String_Node_Str"",cw.toByteArray());
      }
    }
    return result;
  }
  finally {
    try {
      manager.close();
    }
 catch (    IOException exp) {
    }
  }
}"
3078,"public void visitJumpInsn(int opcode,Label label){
  if (include) {
    adaptee.visitJumpInsn(opcode,label);
  }
}","public void visitJumpInsn(int opcode,Label label){
  if (include) {
    getAdaptee().visitJumpInsn(opcode,label);
  }
}"
3079,"public void visitAttribute(Attribute attr){
  if (include) {
    adaptee.visitAttribute(attr);
  }
}","public void visitAttribute(Attribute attr){
  if (include) {
    getAdaptee().visitAttribute(attr);
  }
}"
3080,"public void visitMethodInsn(int opcode,String owner,String name,String desc){
  if (include) {
    adaptee.visitMethodInsn(opcode,owner,name,desc);
  }
}","public void visitMethodInsn(int opcode,String owner,String name,String desc){
  if (include) {
    getAdaptee().visitMethodInsn(opcode,owner,name,desc);
  }
}"
3081,"public void visitTryCatchBlock(Label start,Label end,Label handler,String type){
  if (include) {
    adaptee.visitTryCatchBlock(start,end,handler,type);
  }
}","public void visitTryCatchBlock(Label start,Label end,Label handler,String type){
  if (include) {
    getAdaptee().visitTryCatchBlock(start,end,handler,type);
  }
}"
3082,"public void visitTableSwitchInsn(int min,int max,Label dflt,Label[] labels){
  if (include) {
    adaptee.visitTableSwitchInsn(min,max,dflt,labels);
  }
}","public void visitTableSwitchInsn(int min,int max,Label dflt,Label[] labels){
  if (include) {
    getAdaptee().visitTableSwitchInsn(min,max,dflt,labels);
  }
}"
3083,"public AnnotationVisitor visitAnnotation(String annoDesc,boolean visible){
  if (annoDesc.equals(ONMETHOD_DESC)) {
    include=false;
    return new NullVisitor();
  }
 else   if (annoDesc.equals(ONPROBE_DESC)) {
    include=false;
    return new NullVisitor();
  }
 else {
    return adaptee.visitAnnotation(annoDesc,visible);
  }
}","public AnnotationVisitor visitAnnotation(String annoDesc,boolean visible){
  if (annoDesc.equals(ONMETHOD_DESC)) {
    include=false;
    return new NullVisitor();
  }
 else   if (annoDesc.equals(ONPROBE_DESC)) {
    include=false;
    return new NullVisitor();
  }
 else {
    return getAdaptee().visitAnnotation(annoDesc,visible);
  }
}"
3084,"public void visitMultiANewArrayInsn(String desc,int dims){
  if (include) {
    adaptee.visitMultiANewArrayInsn(desc,dims);
  }
}","public void visitMultiANewArrayInsn(String desc,int dims){
  if (include) {
    getAdaptee().visitMultiANewArrayInsn(desc,dims);
  }
}"
3085,"public void visitCode(){
  if (include) {
    adaptee.visitCode();
  }
}","public void visitCode(){
  if (include) {
    getAdaptee().visitCode();
  }
}"
3086,"public void visitLdcInsn(Object cst){
  if (include) {
    adaptee.visitLdcInsn(cst);
  }
}","public void visitLdcInsn(Object cst){
  if (include) {
    getAdaptee().visitLdcInsn(cst);
  }
}"
3087,"public void visitTypeInsn(int opcode,String desc){
  if (include) {
    adaptee.visitTypeInsn(opcode,desc);
  }
}","public void visitTypeInsn(int opcode,String desc){
  if (include) {
    getAdaptee().visitTypeInsn(opcode,desc);
  }
}"
3088,"public void visitFrame(int type,int nLocal,Object[] local,int nStack,Object[] stack){
  if (include) {
    adaptee.visitFrame(type,nLocal,local,nStack,stack);
  }
}","public void visitFrame(int type,int nLocal,Object[] local,int nStack,Object[] stack){
  if (include) {
    getAdaptee().visitFrame(type,nLocal,local,nStack,stack);
  }
}"
3089,"public void visitLocalVariable(String name,String desc,String signature,Label start,Label end,int index){
  if (include) {
    adaptee.visitLocalVariable(name,desc,signature,start,end,index);
  }
}","public void visitLocalVariable(String name,String desc,String signature,Label start,Label end,int index){
  if (include) {
    getAdaptee().visitLocalVariable(name,desc,signature,start,end,index);
  }
}"
3090,"public void visitEnd(){
  if (include) {
    adaptee.visitEnd();
  }
}","public void visitEnd(){
  if (include) {
    getAdaptee().visitEnd();
  }
}"
3091,"public void visitLabel(Label label){
  if (include) {
    adaptee.visitLabel(label);
  }
}","public void visitLabel(Label label){
  if (include) {
    getAdaptee().visitLabel(label);
  }
}"
3092,"public void visitLookupSwitchInsn(Label dflt,int[] keys,Label[] labels){
  if (include) {
    adaptee.visitLookupSwitchInsn(dflt,keys,labels);
  }
}","public void visitLookupSwitchInsn(Label dflt,int[] keys,Label[] labels){
  if (include) {
    getAdaptee().visitLookupSwitchInsn(dflt,keys,labels);
  }
}"
3093,"public MethodVisitor visitMethod(final int access,final String name,final String desc,final String signature,final String[] exceptions){
  if (name.equals(CONSTRUCTOR) || name.equals(CLASS_INITIALIZER)) {
    return super.visitMethod(access,name,desc,signature,exceptions);
  }
 else {
    return new MethodAdapter(new NullVisitor()){
      private boolean include=true;
      private MethodVisitor adaptee=addMethod(access,name,desc,signature,exceptions);
      public AnnotationVisitor visitAnnotation(      String annoDesc,      boolean visible){
        if (annoDesc.equals(ONMETHOD_DESC)) {
          include=false;
          return new NullVisitor();
        }
 else         if (annoDesc.equals(ONPROBE_DESC)) {
          include=false;
          return new NullVisitor();
        }
 else {
          return adaptee.visitAnnotation(annoDesc,visible);
        }
      }
      public void visitAttribute(      Attribute attr){
        if (include) {
          adaptee.visitAttribute(attr);
        }
      }
      public void visitCode(){
        if (include) {
          adaptee.visitCode();
        }
      }
      public void visitFrame(      int type,      int nLocal,      Object[] local,      int nStack,      Object[] stack){
        if (include) {
          adaptee.visitFrame(type,nLocal,local,nStack,stack);
        }
      }
      public void visitInsn(      int opcode){
        if (include) {
          adaptee.visitInsn(opcode);
        }
      }
      public void visitIntInsn(      int opcode,      int operand){
        if (include) {
          adaptee.visitIntInsn(opcode,operand);
        }
      }
      public void visitVarInsn(      int opcode,      int var){
        if (include) {
          adaptee.visitVarInsn(opcode,var);
        }
      }
      public void visitTypeInsn(      int opcode,      String desc){
        if (include) {
          adaptee.visitTypeInsn(opcode,desc);
        }
      }
      public void visitFieldInsn(      int opcode,      String owner,      String name,      String desc){
        if (include) {
          adaptee.visitFieldInsn(opcode,owner,name,desc);
        }
      }
      public void visitMethodInsn(      int opcode,      String owner,      String name,      String desc){
        if (include) {
          adaptee.visitMethodInsn(opcode,owner,name,desc);
        }
      }
      public void visitJumpInsn(      int opcode,      Label label){
        if (include) {
          adaptee.visitJumpInsn(opcode,label);
        }
      }
      public void visitLabel(      Label label){
        if (include) {
          adaptee.visitLabel(label);
        }
      }
      public void visitLdcInsn(      Object cst){
        if (include) {
          adaptee.visitLdcInsn(cst);
        }
      }
      public void visitIincInsn(      int var,      int increment){
        if (include) {
          adaptee.visitIincInsn(var,increment);
        }
      }
      public void visitTableSwitchInsn(      int min,      int max,      Label dflt,      Label[] labels){
        if (include) {
          adaptee.visitTableSwitchInsn(min,max,dflt,labels);
        }
      }
      public void visitLookupSwitchInsn(      Label dflt,      int[] keys,      Label[] labels){
        if (include) {
          adaptee.visitLookupSwitchInsn(dflt,keys,labels);
        }
      }
      public void visitMultiANewArrayInsn(      String desc,      int dims){
        if (include) {
          adaptee.visitMultiANewArrayInsn(desc,dims);
        }
      }
      public void visitTryCatchBlock(      Label start,      Label end,      Label handler,      String type){
        if (include) {
          adaptee.visitTryCatchBlock(start,end,handler,type);
        }
      }
      public void visitLocalVariable(      String name,      String desc,      String signature,      Label start,      Label end,      int index){
        if (include) {
          adaptee.visitLocalVariable(name,desc,signature,start,end,index);
        }
      }
      public void visitLineNumber(      int line,      Label start){
        if (include) {
          adaptee.visitLineNumber(line,start);
        }
      }
      public void visitMaxs(      int maxStack,      int maxLocals){
        if (include) {
          adaptee.visitMaxs(maxStack,maxLocals);
        }
      }
      public void visitEnd(){
        if (include) {
          adaptee.visitEnd();
        }
      }
    }
;
  }
}","public MethodVisitor visitMethod(final int access,final String name,final String desc,final String signature,final String[] exceptions){
  if (name.equals(CONSTRUCTOR) || name.equals(CLASS_INITIALIZER)) {
    return super.visitMethod(access,name,desc,signature,exceptions);
  }
 else {
    return new MethodAdapter(new NullVisitor()){
      private boolean include=true;
      private MethodVisitor adaptee=null;
      private MethodVisitor getAdaptee(){
        if (include && adaptee == null) {
          adaptee=addMethod(access,name,desc,signature,exceptions);
        }
        return adaptee;
      }
      public AnnotationVisitor visitAnnotation(      String annoDesc,      boolean visible){
        if (annoDesc.equals(ONMETHOD_DESC)) {
          include=false;
          return new NullVisitor();
        }
 else         if (annoDesc.equals(ONPROBE_DESC)) {
          include=false;
          return new NullVisitor();
        }
 else {
          return getAdaptee().visitAnnotation(annoDesc,visible);
        }
      }
      public void visitAttribute(      Attribute attr){
        if (include) {
          getAdaptee().visitAttribute(attr);
        }
      }
      public void visitCode(){
        if (include) {
          getAdaptee().visitCode();
        }
      }
      public void visitFrame(      int type,      int nLocal,      Object[] local,      int nStack,      Object[] stack){
        if (include) {
          getAdaptee().visitFrame(type,nLocal,local,nStack,stack);
        }
      }
      public void visitInsn(      int opcode){
        if (include) {
          getAdaptee().visitInsn(opcode);
        }
      }
      public void visitIntInsn(      int opcode,      int operand){
        if (include) {
          getAdaptee().visitIntInsn(opcode,operand);
        }
      }
      public void visitVarInsn(      int opcode,      int var){
        if (include) {
          getAdaptee().visitVarInsn(opcode,var);
        }
      }
      public void visitTypeInsn(      int opcode,      String desc){
        if (include) {
          getAdaptee().visitTypeInsn(opcode,desc);
        }
      }
      public void visitFieldInsn(      int opcode,      String owner,      String name,      String desc){
        if (include) {
          getAdaptee().visitFieldInsn(opcode,owner,name,desc);
        }
      }
      public void visitMethodInsn(      int opcode,      String owner,      String name,      String desc){
        if (include) {
          getAdaptee().visitMethodInsn(opcode,owner,name,desc);
        }
      }
      public void visitJumpInsn(      int opcode,      Label label){
        if (include) {
          getAdaptee().visitJumpInsn(opcode,label);
        }
      }
      public void visitLabel(      Label label){
        if (include) {
          getAdaptee().visitLabel(label);
        }
      }
      public void visitLdcInsn(      Object cst){
        if (include) {
          getAdaptee().visitLdcInsn(cst);
        }
      }
      public void visitIincInsn(      int var,      int increment){
        if (include) {
          getAdaptee().visitIincInsn(var,increment);
        }
      }
      public void visitTableSwitchInsn(      int min,      int max,      Label dflt,      Label[] labels){
        if (include) {
          getAdaptee().visitTableSwitchInsn(min,max,dflt,labels);
        }
      }
      public void visitLookupSwitchInsn(      Label dflt,      int[] keys,      Label[] labels){
        if (include) {
          getAdaptee().visitLookupSwitchInsn(dflt,keys,labels);
        }
      }
      public void visitMultiANewArrayInsn(      String desc,      int dims){
        if (include) {
          getAdaptee().visitMultiANewArrayInsn(desc,dims);
        }
      }
      public void visitTryCatchBlock(      Label start,      Label end,      Label handler,      String type){
        if (include) {
          getAdaptee().visitTryCatchBlock(start,end,handler,type);
        }
      }
      public void visitLocalVariable(      String name,      String desc,      String signature,      Label start,      Label end,      int index){
        if (include) {
          getAdaptee().visitLocalVariable(name,desc,signature,start,end,index);
        }
      }
      public void visitLineNumber(      int line,      Label start){
        if (include) {
          getAdaptee().visitLineNumber(line,start);
        }
      }
      public void visitMaxs(      int maxStack,      int maxLocals){
        if (include) {
          getAdaptee().visitMaxs(maxStack,maxLocals);
        }
      }
      public void visitEnd(){
        if (include) {
          getAdaptee().visitEnd();
        }
      }
    }
;
  }
}"
3094,"public void visitIntInsn(int opcode,int operand){
  if (include) {
    adaptee.visitIntInsn(opcode,operand);
  }
}","public void visitIntInsn(int opcode,int operand){
  if (include) {
    getAdaptee().visitIntInsn(opcode,operand);
  }
}"
3095,"public void visitInsn(int opcode){
  if (include) {
    adaptee.visitInsn(opcode);
  }
}","public void visitInsn(int opcode){
  if (include) {
    getAdaptee().visitInsn(opcode);
  }
}"
3096,"public void visitIincInsn(int var,int increment){
  if (include) {
    adaptee.visitIincInsn(var,increment);
  }
}","public void visitIincInsn(int var,int increment){
  if (include) {
    getAdaptee().visitIincInsn(var,increment);
  }
}"
3097,"public void visitLineNumber(int line,Label start){
  if (include) {
    adaptee.visitLineNumber(line,start);
  }
}","public void visitLineNumber(int line,Label start){
  if (include) {
    getAdaptee().visitLineNumber(line,start);
  }
}"
3098,"public void visitVarInsn(int opcode,int var){
  if (include) {
    adaptee.visitVarInsn(opcode,var);
  }
}","public void visitVarInsn(int opcode,int var){
  if (include) {
    getAdaptee().visitVarInsn(opcode,var);
  }
}"
3099,"public void visitMaxs(int maxStack,int maxLocals){
  if (include) {
    adaptee.visitMaxs(maxStack,maxLocals);
  }
}","public void visitMaxs(int maxStack,int maxLocals){
  if (include) {
    getAdaptee().visitMaxs(maxStack,maxLocals);
  }
}"
3100,"public void visitFieldInsn(int opcode,String owner,String name,String desc){
  if (include) {
    adaptee.visitFieldInsn(opcode,owner,name,desc);
  }
}","public void visitFieldInsn(int opcode,String owner,String name,String desc){
  if (include) {
    getAdaptee().visitFieldInsn(opcode,owner,name,desc);
  }
}"
3101,"private void init(List<OnMethod> onMethods){
  List<String> strSrcList=new ArrayList<String>();
  List<Pattern> patSrcList=new ArrayList<Pattern>();
  List<String> superTypesList=new ArrayList<String>();
  List<String> superTypesInternalList=new ArrayList<String>();
  List<String> strAnoList=new ArrayList<String>();
  List<Pattern> patAnoList=new ArrayList<Pattern>();
  for (  OnMethod om : onMethods) {
    String className=om.getClazz();
    if (className.length() == 0) {
      continue;
    }
    char firstCh=className.charAt(0);
    if (firstCh == '/' && REGEX_SPECIFIER.matcher(className).matches()) {
      Pattern p=Pattern.compile(className.substring(1,className.length() - 1));
      patSrcList.add(p);
    }
 else     if (firstCh == '@') {
      className=className.substring(1);
      if (REGEX_SPECIFIER.matcher(className).matches()) {
        Pattern p=Pattern.compile(className.substring(1,className.length() - 1));
        patAnoList.add(p);
      }
 else {
        strAnoList.add(className);
      }
    }
 else     if (firstCh == '+') {
      String superType=className.substring(1);
      superTypesList.add(superType);
      superTypesInternalList.add(superType.replace('.','/'));
    }
 else {
      strSrcList.add(className);
    }
  }
  sourceClasses=new String[strSrcList.size()];
  strSrcList.toArray(sourceClasses);
  sourceClassPatterns=new Pattern[patSrcList.size()];
  patSrcList.toArray(sourceClassPatterns);
  superTypes=new String[superTypesList.size()];
  superTypesList.toArray(superTypes);
  superTypesInternal=new String[superTypesInternalList.size()];
  superTypesInternalList.toArray(superTypesInternal);
  annotationClasses=new String[strAnoList.size()];
  strAnoList.toArray(annotationClasses);
  annotationClassPatterns=new Pattern[patAnoList.size()];
  patAnoList.toArray(annotationClassPatterns);
}","private void init(List<OnMethod> onMethods){
  List<String> strSrcList=new ArrayList<String>();
  List<Pattern> patSrcList=new ArrayList<Pattern>();
  List<String> superTypesList=new ArrayList<String>();
  List<String> superTypesInternalList=new ArrayList<String>();
  List<String> strAnoList=new ArrayList<String>();
  List<Pattern> patAnoList=new ArrayList<Pattern>();
  for (  OnMethod om : onMethods) {
    String className=om.getClazz();
    if (className.length() == 0) {
      continue;
    }
    char firstCh=className.charAt(0);
    if (firstCh == '/' && REGEX_SPECIFIER.matcher(className).matches()) {
      Pattern p=Pattern.compile(className.substring(1,className.length() - 1));
      patSrcList.add(p);
    }
 else     if (firstCh == '@') {
      className=className.substring(1);
      if (REGEX_SPECIFIER.matcher(className).matches()) {
        Pattern p=Pattern.compile(className.substring(1,className.length() - 1));
        patAnoList.add(p);
      }
 else {
        strAnoList.add(className);
      }
    }
 else     if (firstCh == '+') {
      String superType=className.substring(1);
      superTypesList.add(superType);
      superTypesInternalList.add(superType.replace('.','/'));
      strSrcList.add(superType);
    }
 else {
      strSrcList.add(className);
    }
  }
  sourceClasses=new String[strSrcList.size()];
  strSrcList.toArray(sourceClasses);
  sourceClassPatterns=new Pattern[patSrcList.size()];
  patSrcList.toArray(sourceClassPatterns);
  superTypes=new String[superTypesList.size()];
  superTypesList.toArray(superTypes);
  superTypesInternal=new String[superTypesInternalList.size()];
  superTypesInternalList.toArray(superTypesInternal);
  annotationClasses=new String[strAnoList.size()];
  strAnoList.toArray(annotationClasses);
  annotationClassPatterns=new Pattern[patAnoList.size()];
  patAnoList.toArray(annotationClassPatterns);
}"
3102,"/** 
 * Prints aggregation using the provided format
 * @param name The name of the aggregation to be used in the textual output
 * @param aggregation The aggregation to print
 * @param format The format to use. It mimics {@linkplain String#format(java.lang.String,java.lang.Object[]) } behaviourwith the addition of the ability to address the key title as a 0-indexed item
 * @see String#format(java.lang.String,java.lang.Object[])
 * @since 1.1
 */
public static void printAggregation(String name,Aggregation aggregation,String format){
  printAggregation(name,aggregation,format);
}","public static void printAggregation(String name,Aggregation aggregation,String format){
  BTraceRuntime.printAggregation(name,aggregation,format);
}"
3103,"/** 
 * Prints aggregation using the provided format
 * @param name The name of the aggregation to be used in the textual output
 * @param aggregation The aggregation to print
 * @param format The format to use. It mimics {@linkplain String#format(java.lang.String,java.lang.Object[]) } behaviourwith the addition of the ability to address the key title as a 0-indexed item
 * @see String#format(java.lang.String,java.lang.Object[])
 * @since 1.1
 */
public static void printAggregation(String name,Aggregation aggregation,String format){
  printAggregation(name,aggregation,format);
}","public static void printAggregation(String name,Aggregation aggregation,String format){
  BTraceRuntime.printAggregation(name,aggregation,format);
}"
3104,"final void endRetransformClasses(){
  try {
    onCommand(new OkayCommand());
    if (Main.isDebug())     Main.debugPrint(""String_Node_Str"");
  }
 catch (  IOException e) {
    Main.debugPrint(e);
  }
}","final void endRetransformClasses(){
  runtime.send(new RetransformationEndNotification());
}"
3105,"protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter(btraceCode);
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  onCommand(new OkayCommand());
  boolean enteredHere=BTraceRuntime.enter();
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    if (!enteredHere)     BTraceRuntime.enter();
  }
  return this.btraceClazz;
}","protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter(btraceCode);
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  runtime.send(new OkayCommand());
  boolean enteredHere=BTraceRuntime.enter();
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    if (!enteredHere)     BTraceRuntime.enter();
  }
  return this.btraceClazz;
}"
3106,"final void startRetransformClasses(int numClasses){
  try {
    onCommand(new RetransformationStartNotification(numClasses));
    if (Main.isDebug())     Main.debugPrint(""String_Node_Str"" + numClasses + ""String_Node_Str"");
  }
 catch (  IOException e) {
    Main.debugPrint(e);
  }
}","final void startRetransformClasses(int numClasses){
  runtime.send(new RetransformationStartNotification(numClasses));
  if (Main.isDebug())   Main.debugPrint(""String_Node_Str"" + numClasses + ""String_Node_Str"");
}"
3107,"public void onCommand(Command cmd) throws IOException {
  LOGGER.log(Level.FINEST,""String_Node_Str"",cmd.toString());
switch (cmd.getType()) {
case Command.SUCCESS:
{
      if (retransforming) {
        clientMap.put(btrace,client);
        result.set(true);
        latch.countDown();
        retransforming=false;
      }
      break;
    }
case Command.EXIT:
{
    latch.countDown();
    stop(btrace);
    break;
  }
case Command.RETRANSFORMATION_START:
{
  int numClasses=((RetransformationStartNotification)cmd).getNumClasses();
  btrace.setInstrClasses(numClasses);
  btrace.setState(BTraceTask.State.INSTRUMENTING);
  retransforming=true;
  break;
}
}
btrace.dispatchCommand(cmd);
}","public void onCommand(Command cmd) throws IOException {
  LOGGER.log(Level.FINEST,""String_Node_Str"",cmd.toString());
switch (cmd.getType()) {
case Command.SUCCESS:
{
      if (!retransforming) {
        result.set(true);
        clientMap.put(btrace,client);
        latch.countDown();
      }
      break;
    }
case Command.EXIT:
{
    latch.countDown();
    stop(btrace);
    break;
  }
case Command.RETRANSFORMATION_START:
{
  int numClasses=((RetransformationStartNotification)cmd).getNumClasses();
  btrace.setInstrClasses(numClasses);
  btrace.setState(BTraceTask.State.INSTRUMENTING);
  retransforming=true;
  break;
}
case Command.RETRANSFORMATION_END:
{
if (retransforming) {
  btrace.setState(BTraceTask.State.RUNNING);
  retransforming=false;
}
break;
}
}
btrace.dispatchCommand(cmd);
}"
3108,"public void run(){
  int port=portLocator.getTaskPort(btrace);
  LOGGER.log(Level.FINEST,""String_Node_Str"",port);
  BTraceSettings settings=settingsProvider.getSettings();
  final Client client=new Client(port,""String_Node_Str"",settings.isDebugMode(),true,btrace.isUnsafe(),settings.isDumpClasses(),settings.getDumpClassPath());
  try {
    client.attach(String.valueOf(btrace.getPid()),compiler.getAgentJarPath(),compiler.getToolsJarPath(),null);
    Thread.sleep(200);
    client.submit(bytecode,new String[]{},new CommandListener(){
      private boolean retransforming=false;
      public void onCommand(      Command cmd) throws IOException {
        LOGGER.log(Level.FINEST,""String_Node_Str"",cmd.toString());
switch (cmd.getType()) {
case Command.SUCCESS:
{
            if (retransforming) {
              clientMap.put(btrace,client);
              result.set(true);
              latch.countDown();
              retransforming=false;
            }
            break;
          }
case Command.EXIT:
{
          latch.countDown();
          stop(btrace);
          break;
        }
case Command.RETRANSFORMATION_START:
{
        int numClasses=((RetransformationStartNotification)cmd).getNumClasses();
        btrace.setInstrClasses(numClasses);
        btrace.setState(BTraceTask.State.INSTRUMENTING);
        retransforming=true;
        break;
      }
  }
  btrace.dispatchCommand(cmd);
}
}
);
}
 catch (Exception e) {
LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
result.set(false);
latch.countDown();
}
}","public void run(){
  int port=portLocator.getTaskPort(btrace);
  LOGGER.log(Level.FINEST,""String_Node_Str"",port);
  BTraceSettings settings=settingsProvider.getSettings();
  final Client client=new Client(port,""String_Node_Str"",settings.isDebugMode(),true,btrace.isUnsafe(),settings.isDumpClasses(),settings.getDumpClassPath());
  try {
    client.attach(String.valueOf(btrace.getPid()),compiler.getAgentJarPath(),compiler.getToolsJarPath(),null);
    Thread.sleep(200);
    client.submit(bytecode,new String[]{},new CommandListener(){
      private boolean retransforming=false;
      public void onCommand(      Command cmd) throws IOException {
        LOGGER.log(Level.FINEST,""String_Node_Str"",cmd.toString());
switch (cmd.getType()) {
case Command.SUCCESS:
{
            if (!retransforming) {
              result.set(true);
              clientMap.put(btrace,client);
              latch.countDown();
            }
            break;
          }
case Command.EXIT:
{
          latch.countDown();
          stop(btrace);
          break;
        }
case Command.RETRANSFORMATION_START:
{
        int numClasses=((RetransformationStartNotification)cmd).getNumClasses();
        btrace.setInstrClasses(numClasses);
        btrace.setState(BTraceTask.State.INSTRUMENTING);
        retransforming=true;
        break;
      }
case Command.RETRANSFORMATION_END:
{
      if (retransforming) {
        btrace.setState(BTraceTask.State.RUNNING);
        retransforming=false;
      }
      break;
    }
}
btrace.dispatchCommand(cmd);
}
}
);
}
 catch (Exception e) {
LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
result.set(false);
latch.countDown();
}
}"
3109,"private boolean doStart(BTraceTask task){
  final AtomicBoolean result=new AtomicBoolean(false);
  final BTraceTaskImpl btrace=(BTraceTaskImpl)task;
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    final BTraceCompiler compiler=compilerFactory.newCompiler(btrace);
    btrace.setState(BTraceTask.State.COMPILING);
    final byte[] bytecode=compiler.compile(btrace.getScript(),task.getClassPath(),outputProvider.getStdErr(task));
    if (bytecode.length == 0) {
      btrace.setState(BTraceTask.State.FAILED);
      return false;
    }
    btrace.setState(BTraceTask.State.COMPILED);
    LOGGER.log(Level.FINEST,""String_Node_Str"",bytecode.length);
    commQueue.submit(new Runnable(){
      public void run(){
        int port=portLocator.getTaskPort(btrace);
        LOGGER.log(Level.FINEST,""String_Node_Str"",port);
        BTraceSettings settings=settingsProvider.getSettings();
        final Client client=new Client(port,""String_Node_Str"",settings.isDebugMode(),true,btrace.isUnsafe(),settings.isDumpClasses(),settings.getDumpClassPath());
        try {
          client.attach(String.valueOf(btrace.getPid()),compiler.getAgentJarPath(),compiler.getToolsJarPath(),null);
          Thread.sleep(200);
          client.submit(bytecode,new String[]{},new CommandListener(){
            private boolean retransforming=false;
            public void onCommand(            Command cmd) throws IOException {
              LOGGER.log(Level.FINEST,""String_Node_Str"",cmd.toString());
switch (cmd.getType()) {
case Command.SUCCESS:
{
                  if (retransforming) {
                    clientMap.put(btrace,client);
                    result.set(true);
                    latch.countDown();
                    retransforming=false;
                  }
                  break;
                }
case Command.EXIT:
{
                latch.countDown();
                stop(btrace);
                break;
              }
case Command.RETRANSFORMATION_START:
{
              int numClasses=((RetransformationStartNotification)cmd).getNumClasses();
              btrace.setInstrClasses(numClasses);
              btrace.setState(BTraceTask.State.INSTRUMENTING);
              retransforming=true;
              break;
            }
        }
        btrace.dispatchCommand(cmd);
      }
    }
);
  }
 catch (  Exception e) {
    LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
    result.set(false);
    latch.countDown();
  }
}
}
);
latch.await();
}
 catch (InterruptedException ex) {
LOGGER.log(Level.WARNING,null,ex);
}
return result.get();
}","private boolean doStart(BTraceTask task){
  final AtomicBoolean result=new AtomicBoolean(false);
  final BTraceTaskImpl btrace=(BTraceTaskImpl)task;
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    final BTraceCompiler compiler=compilerFactory.newCompiler(btrace);
    btrace.setState(BTraceTask.State.COMPILING);
    final byte[] bytecode=compiler.compile(btrace.getScript(),task.getClassPath(),outputProvider.getStdErr(task));
    if (bytecode.length == 0) {
      btrace.setState(BTraceTask.State.FAILED);
      return false;
    }
    btrace.setState(BTraceTask.State.COMPILED);
    LOGGER.log(Level.FINEST,""String_Node_Str"",bytecode.length);
    commQueue.submit(new Runnable(){
      public void run(){
        int port=portLocator.getTaskPort(btrace);
        LOGGER.log(Level.FINEST,""String_Node_Str"",port);
        BTraceSettings settings=settingsProvider.getSettings();
        final Client client=new Client(port,""String_Node_Str"",settings.isDebugMode(),true,btrace.isUnsafe(),settings.isDumpClasses(),settings.getDumpClassPath());
        try {
          client.attach(String.valueOf(btrace.getPid()),compiler.getAgentJarPath(),compiler.getToolsJarPath(),null);
          Thread.sleep(200);
          client.submit(bytecode,new String[]{},new CommandListener(){
            private boolean retransforming=false;
            public void onCommand(            Command cmd) throws IOException {
              LOGGER.log(Level.FINEST,""String_Node_Str"",cmd.toString());
switch (cmd.getType()) {
case Command.SUCCESS:
{
                  if (!retransforming) {
                    result.set(true);
                    clientMap.put(btrace,client);
                    latch.countDown();
                  }
                  break;
                }
case Command.EXIT:
{
                latch.countDown();
                stop(btrace);
                break;
              }
case Command.RETRANSFORMATION_START:
{
              int numClasses=((RetransformationStartNotification)cmd).getNumClasses();
              btrace.setInstrClasses(numClasses);
              btrace.setState(BTraceTask.State.INSTRUMENTING);
              retransforming=true;
              break;
            }
case Command.RETRANSFORMATION_END:
{
            if (retransforming) {
              btrace.setState(BTraceTask.State.RUNNING);
              retransforming=false;
            }
            break;
          }
      }
      btrace.dispatchCommand(cmd);
    }
  }
);
}
 catch (Exception e) {
  LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
  result.set(false);
  latch.countDown();
}
}
}
);
latch.await();
}
 catch (InterruptedException ex) {
LOGGER.log(Level.WARNING,null,ex);
}
return result.get();
}"
3110,"public static Command read(ObjectInput in) throws IOException {
  byte type=in.readByte();
  Command cmd;
switch (type) {
case Command.ERROR:
    cmd=new ErrorCommand();
  break;
case Command.EVENT:
cmd=new EventCommand();
break;
case Command.EXIT:
cmd=new ExitCommand();
break;
case Command.INSTRUMENT:
cmd=new InstrumentCommand();
break;
case Command.MESSAGE:
cmd=new MessageCommand();
break;
case Command.RENAME:
cmd=new RenameCommand();
break;
case Command.SUCCESS:
cmd=new OkayCommand();
break;
case Command.NUMBER_MAP:
cmd=new NumberMapDataCommand();
break;
case Command.STRING_MAP:
cmd=new StringMapDataCommand();
break;
case Command.NUMBER:
cmd=new NumberDataCommand();
break;
case Command.GRID_DATA:
cmd=new GridDataCommand();
break;
case Command.RETRANSFORMATION_START:
cmd=new RetransformationStartNotification();
break;
case Command.RETRANSFORM_CLASS:
cmd=new RetransformClassNotification();
break;
default :
throw new RuntimeException(""String_Node_Str"" + type);
}
try {
cmd.read(in);
}
 catch (ClassNotFoundException cnfe) {
throw new IOException(cnfe);
}
return cmd;
}","public static Command read(ObjectInput in) throws IOException {
  byte type=in.readByte();
  Command cmd;
switch (type) {
case Command.ERROR:
    cmd=new ErrorCommand();
  break;
case Command.EVENT:
cmd=new EventCommand();
break;
case Command.EXIT:
cmd=new ExitCommand();
break;
case Command.INSTRUMENT:
cmd=new InstrumentCommand();
break;
case Command.MESSAGE:
cmd=new MessageCommand();
break;
case Command.RENAME:
cmd=new RenameCommand();
break;
case Command.SUCCESS:
cmd=new OkayCommand();
break;
case Command.NUMBER_MAP:
cmd=new NumberMapDataCommand();
break;
case Command.STRING_MAP:
cmd=new StringMapDataCommand();
break;
case Command.NUMBER:
cmd=new NumberDataCommand();
break;
case Command.GRID_DATA:
cmd=new GridDataCommand();
break;
case Command.RETRANSFORMATION_START:
cmd=new RetransformationStartNotification();
break;
case Command.RETRANSFORMATION_END:
cmd=new RetransformationEndNotification();
break;
case Command.RETRANSFORM_CLASS:
cmd=new RetransformClassNotification();
break;
default :
throw new RuntimeException(""String_Node_Str"" + type);
}
try {
cmd.read(in);
}
 catch (ClassNotFoundException cnfe) {
throw new IOException(cnfe);
}
return cmd;
}"
3111,"public void print(PrintWriter out){
  if (data != null) {
    for (    Object[] dataRow : data) {
      Object[] printRow=dataRow.clone();
      for (int i=0; i < printRow.length; i++) {
        if (printRow[i] == null) {
          printRow[i]=""String_Node_Str"";
        }
        if (printRow[i] instanceof HistogramData) {
          StringWriter buffer=new StringWriter();
          PrintWriter writer=new PrintWriter(buffer);
          ((HistogramData)printRow[i]).print(writer);
          writer.flush();
          printRow[i]=buffer.toString();
        }
        if (printRow[i] instanceof String) {
          String value=(String)printRow[i];
          if (value.contains(""String_Node_Str"")) {
            printRow[i]=reformatMultilineValue(value);
          }
        }
      }
      String usedFormat=this.format;
      if (usedFormat == null) {
        if (name != null && !name.equals(""String_Node_Str"")) {
          out.println(name);
        }
        StringBuilder buffer=new StringBuilder();
        for (int i=0; i < printRow.length; i++) {
          buffer.append(""String_Node_Str"");
          buffer.append(getFormat(printRow[i]));
        }
        usedFormat=buffer.toString();
      }
 else {
        Matcher m=INDEX_PATTERN.matcher(usedFormat);
        int maxIndex=-1;
        int minIndex=Integer.MAX_VALUE;
        while (m.find()) {
          int index=Integer.valueOf(m.group(1)).intValue();
          if (index > maxIndex) {
            maxIndex=index;
          }
          if (index < minIndex) {
            minIndex=index;
          }
        }
        Object[] titledRow=new Object[printRow.length + 1];
        System.arraycopy(printRow,0,titledRow,0,printRow.length);
        titledRow[printRow.length]=name;
        usedFormat=minIndex > 0 ? getFormat(titledRow[printRow.length]).replace(""String_Node_Str"",""String_Node_Str"" + (maxIndex + 1) + ""String_Node_Str"") + ""String_Node_Str"" + usedFormat : usedFormat.replace(""String_Node_Str"",""String_Node_Str"" + titledRow.length + ""String_Node_Str"");
        printRow=titledRow;
      }
      String line=String.format(usedFormat,printRow);
      out.println(line);
    }
  }
}","public void print(PrintWriter out){
  System.err.println(""String_Node_Str"" + (data != null));
  if (data != null) {
    if (name != null && !name.equals(""String_Node_Str"")) {
      out.println(name);
    }
    for (    Object[] dataRow : data) {
      Object[] printRow=dataRow.clone();
      for (int i=0; i < printRow.length; i++) {
        if (printRow[i] == null) {
          printRow[i]=""String_Node_Str"";
        }
        if (printRow[i] instanceof HistogramData) {
          StringWriter buffer=new StringWriter();
          PrintWriter writer=new PrintWriter(buffer);
          ((HistogramData)printRow[i]).print(writer);
          writer.flush();
          printRow[i]=buffer.toString();
        }
        if (printRow[i] instanceof String) {
          String value=(String)printRow[i];
          if (value.contains(""String_Node_Str"")) {
            printRow[i]=reformatMultilineValue(value);
          }
        }
      }
      String usedFormat=this.format;
      System.err.println(""String_Node_Str"" + usedFormat);
      if (usedFormat == null || usedFormat.length() == 0) {
        StringBuilder buffer=new StringBuilder();
        for (int i=0; i < printRow.length; i++) {
          buffer.append(""String_Node_Str"");
          buffer.append(getFormat(printRow[i]));
        }
        usedFormat=buffer.toString();
      }
      String line=String.format(usedFormat,printRow);
      out.println(line);
    }
  }
}"
3112,"public static void handleFlashLightClient(byte[] code){
  try {
    String twn=new String(""String_Node_Str"" + (new Date()).getTime());
    PrintWriter traceWriter=null;
    traceWriter=new PrintWriter(new BufferedWriter(new FileWriter(new File(twn + ""String_Node_Str""))));
    handleNewClient(code,traceWriter);
  }
 catch (  IOException ioexp) {
    if (isDebug()) {
      debugPrint(ioexp);
    }
  }
}","public static void handleFlashLightClient(byte[] code){
  try {
    String twn=new String(""String_Node_Str"" + (new Date()).getTime());
    PrintWriter traceWriter=null;
    traceWriter=new PrintWriter(new BufferedWriter(new FileWriter(new File(twn + ""String_Node_Str""))));
    handleFlashLightClient(code,traceWriter);
  }
 catch (  IOException ioexp) {
    if (isDebug()) {
      debugPrint(ioexp);
    }
  }
}"
3113,"private byte[] instrument(Class clazz,String cname,byte[] target){
  byte[] instrumentedCode;
  try {
    ClassWriter writer=InstrumentUtils.newClassWriter(target);
    ClassReader reader=new ClassReader(target);
    EmptyMethodsEvaluator eme=new EmptyMethodsEvaluator();
    reader.accept(eme,ClassReader.SKIP_DEBUG + ClassReader.SKIP_FRAMES);
    InstrumentUtils.accept(reader,new Instrumentor(clazz,className,btraceCode,onMethods,eme.getEmptyMethods(),writer));
    instrumentedCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    Main.debugPrint(th);
    return null;
  }
  Main.dumpClass(className,cname,instrumentedCode);
  return instrumentedCode;
}","private byte[] instrument(Class clazz,String cname,byte[] target){
  byte[] instrumentedCode;
  try {
    ClassWriter writer=InstrumentUtils.newClassWriter(target);
    ClassReader reader=new ClassReader(target);
    InstrumentUtils.accept(reader,new Instrumentor(clazz,className,btraceCode,onMethods,writer));
    instrumentedCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    Main.debugPrint(th);
    return null;
  }
  Main.dumpClass(className,cname,instrumentedCode);
  return instrumentedCode;
}"
3114,"public Instrumentor(Class clazz,String btraceClassName,byte[] btraceCode,List<OnMethod> onMethods,Set<String> emptyMethods,ClassVisitor cv){
  this(clazz,btraceClassName,new ClassReader(btraceCode),onMethods,emptyMethods,cv);
}","public Instrumentor(Class clazz,String btraceClassName,byte[] btraceCode,List<OnMethod> onMethods,ClassVisitor cv){
  this(clazz,btraceClassName,new ClassReader(btraceCode),onMethods,cv);
}"
3115,"public static void main(String[] args) throws Exception {
  if (args.length != 2) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  String className=args[0].replace('.','/') + ""String_Node_Str"";
  FileInputStream fis=new FileInputStream(className);
  byte[] buf=new byte[(int)new File(className).length()];
  fis.read(buf);
  fis.close();
  ClassWriter writer=InstrumentUtils.newClassWriter();
  Verifier verifier=new Verifier(new Preprocessor(writer));
  InstrumentUtils.accept(new ClassReader(buf),verifier);
  buf=writer.toByteArray();
  FileOutputStream fos=new FileOutputStream(className);
  fos.write(buf);
  fos.close();
  String targetClass=args[1].replace('.','/') + ""String_Node_Str"";
  fis=new FileInputStream(targetClass);
  writer=InstrumentUtils.newClassWriter();
  ClassReader reader=new ClassReader(fis);
  InstrumentUtils.accept(reader,new Instrumentor(null,verifier.getClassName(),buf,verifier.getOnMethods(),Collections.EMPTY_SET,writer));
  fos=new FileOutputStream(targetClass);
  fos.write(writer.toByteArray());
}","public static void main(String[] args) throws Exception {
  if (args.length != 2) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  String className=args[0].replace('.','/') + ""String_Node_Str"";
  FileInputStream fis=new FileInputStream(className);
  byte[] buf=new byte[(int)new File(className).length()];
  fis.read(buf);
  fis.close();
  ClassWriter writer=InstrumentUtils.newClassWriter();
  Verifier verifier=new Verifier(new Preprocessor(writer));
  InstrumentUtils.accept(new ClassReader(buf),verifier);
  buf=writer.toByteArray();
  FileOutputStream fos=new FileOutputStream(className);
  fos.write(buf);
  fos.close();
  String targetClass=args[1].replace('.','/') + ""String_Node_Str"";
  fis=new FileInputStream(targetClass);
  writer=InstrumentUtils.newClassWriter();
  ClassReader reader=new ClassReader(fis);
  InstrumentUtils.accept(reader,new Instrumentor(null,verifier.getClassName(),buf,verifier.getOnMethods(),writer));
  fos=new FileOutputStream(targetClass);
  fos.write(writer.toByteArray());
}"
3116,"public MethodVisitor visitMethod(final int access,final String name,final String desc,String signature,String[] exceptions){
  MethodVisitor methodVisitor=super.visitMethod(access,name,desc,signature,exceptions);
  if (emptyMethods.contains(MethodID.create(name,desc)))   return methodVisitor;
  if (applicableOnMethods.size() == 0 || (access & ACC_ABSTRACT) != 0 || (access & ACC_NATIVE) != 0 || name.startsWith(BTRACE_METHOD_PREFIX)) {
    return methodVisitor;
  }
  for (  OnMethod om : applicableOnMethods) {
    if (om.getLocation().getValue() == Kind.LINE) {
      methodVisitor=instrumentorFor(om,methodVisitor,access,name,desc);
    }
 else {
      String methodName=om.getMethod();
      if (methodName.equals(""String_Node_Str"")) {
        methodName=om.getTargetName();
      }
      if (methodName.equals(name) && typeMatches(om.getType(),desc)) {
        methodVisitor=instrumentorFor(om,methodVisitor,access,name,desc);
      }
 else       if (methodName.charAt(0) == '/' && REGEX_SPECIFIER.matcher(methodName).matches()) {
        methodName=methodName.substring(1,methodName.length() - 1);
        if (name.matches(methodName) && typeMatches(om.getType(),desc)) {
          methodVisitor=instrumentorFor(om,methodVisitor,access,name,desc);
        }
      }
    }
  }
  return new MethodAdapter(methodVisitor){
    public AnnotationVisitor visitAnnotation(    String annoDesc,    boolean visible){
      for (      OnMethod om : applicableOnMethods) {
        String extAnnoName=Type.getType(annoDesc).getClassName();
        String annoName=om.getMethod();
        if (annoName.length() > 0 && annoName.charAt(0) == '@') {
          annoName=annoName.substring(1);
          if (annoName.length() == 0) {
            continue;
          }
          if (REGEX_SPECIFIER.matcher(annoName).matches()) {
            annoName=annoName.substring(1,annoName.length() - 1);
            if (extAnnoName.matches(annoName)) {
              mv=instrumentorFor(om,mv,access,name,desc);
            }
          }
 else           if (annoName.equals(extAnnoName)) {
            mv=instrumentorFor(om,mv,access,name,desc);
          }
        }
      }
      return mv.visitAnnotation(annoDesc,visible);
    }
  }
;
}","public MethodVisitor visitMethod(final int access,final String name,final String desc,String signature,String[] exceptions){
  MethodVisitor methodVisitor=super.visitMethod(access,name,desc,signature,exceptions);
  if (applicableOnMethods.size() == 0 || (access & ACC_ABSTRACT) != 0 || (access & ACC_NATIVE) != 0 || name.startsWith(BTRACE_METHOD_PREFIX)) {
    return methodVisitor;
  }
  for (  OnMethod om : applicableOnMethods) {
    if (om.getLocation().getValue() == Kind.LINE) {
      methodVisitor=instrumentorFor(om,methodVisitor,access,name,desc);
    }
 else {
      String methodName=om.getMethod();
      if (methodName.equals(""String_Node_Str"")) {
        methodName=om.getTargetName();
      }
      if (methodName.equals(name) && typeMatches(om.getType(),desc)) {
        methodVisitor=instrumentorFor(om,methodVisitor,access,name,desc);
      }
 else       if (methodName.charAt(0) == '/' && REGEX_SPECIFIER.matcher(methodName).matches()) {
        methodName=methodName.substring(1,methodName.length() - 1);
        if (name.matches(methodName) && typeMatches(om.getType(),desc)) {
          methodVisitor=instrumentorFor(om,methodVisitor,access,name,desc);
        }
      }
    }
  }
  return new MethodAdapter(methodVisitor){
    public AnnotationVisitor visitAnnotation(    String annoDesc,    boolean visible){
      for (      OnMethod om : applicableOnMethods) {
        String extAnnoName=Type.getType(annoDesc).getClassName();
        String annoName=om.getMethod();
        if (annoName.length() > 0 && annoName.charAt(0) == '@') {
          annoName=annoName.substring(1);
          if (annoName.length() == 0) {
            continue;
          }
          if (REGEX_SPECIFIER.matcher(annoName).matches()) {
            annoName=annoName.substring(1,annoName.length() - 1);
            if (extAnnoName.matches(annoName)) {
              mv=instrumentorFor(om,mv,access,name,desc);
            }
          }
 else           if (annoName.equals(extAnnoName)) {
            mv=instrumentorFor(om,mv,access,name,desc);
          }
        }
      }
      return mv.visitAnnotation(annoDesc,visible);
    }
  }
;
}"
3117,"private static void loadBTraceLibrary(final ClassLoader loader){
  boolean isSolaris=System.getProperty(""String_Node_Str"").equals(""String_Node_Str"");
  if (isSolaris) {
    try {
      System.loadLibrary(""String_Node_Str"");
      dtraceEnabled=true;
    }
 catch (    LinkageError le) {
      String path=loader.getResource(""String_Node_Str"").toString();
      path=path.substring(0,path.indexOf(""String_Node_Str""));
      path=path.substring(""String_Node_Str"".length(),path.lastIndexOf('/'));
      String cpu=System.getProperty(""String_Node_Str"");
      if (cpu.equals(""String_Node_Str"")) {
        cpu=""String_Node_Str"";
      }
      path+=""String_Node_Str"" + cpu + ""String_Node_Str"";
      try {
        path=new File(new URI(path)).getAbsolutePath();
      }
 catch (      RuntimeException re) {
        throw re;
      }
catch (      Exception e) {
        throw new RuntimeException(e);
      }
      try {
        System.load(path);
        dtraceEnabled=true;
      }
 catch (      LinkageError le1) {
        System.err.println(""String_Node_Str"");
      }
    }
  }
}","private static void loadBTraceLibrary(final ClassLoader loader){
  boolean isSolaris=System.getProperty(""String_Node_Str"").equals(""String_Node_Str"");
  if (isSolaris) {
    try {
      System.loadLibrary(""String_Node_Str"");
      dtraceEnabled=true;
    }
 catch (    LinkageError le) {
      if (loader == null || loader.getResource(""String_Node_Str"") == null) {
        System.err.println(""String_Node_Str"");
        return;
      }
      String path=loader.getResource(""String_Node_Str"").toString();
      path=path.substring(0,path.indexOf(""String_Node_Str""));
      path=path.substring(""String_Node_Str"".length(),path.lastIndexOf('/'));
      String cpu=System.getProperty(""String_Node_Str"");
      if (cpu.equals(""String_Node_Str"")) {
        cpu=""String_Node_Str"";
      }
      path+=""String_Node_Str"" + cpu + ""String_Node_Str"";
      try {
        path=new File(new URI(path)).getAbsolutePath();
      }
 catch (      RuntimeException re) {
        throw re;
      }
catch (      Exception e) {
        throw new RuntimeException(e);
      }
      try {
        System.load(path);
        dtraceEnabled=true;
      }
 catch (      LinkageError le1) {
        System.err.println(""String_Node_Str"");
      }
    }
  }
}"
3118,"public long perfLong(String name){
  try {
    Object mon=findByName(name);
    if (mon == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name);
    }
    if (longMonitorClz.isAssignableFrom(mon.getClass())) {
      Method m=mon.getClass().getMethod(""String_Node_Str"");
      Object result=m.invoke(mon);
      return ((Long)result).intValue();
    }
 else {
      throw new IllegalArgumentException(name + ""String_Node_Str"");
    }
  }
 catch (  Exception me) {
    throw new RuntimeException(me);
  }
}","public long perfLong(String name){
  Monitor mon=findByName(name);
  if (mon == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + name);
  }
  if (mon instanceof LongMonitor) {
    return ((LongMonitor)mon).longValue();
  }
 else {
    throw new IllegalArgumentException(name + ""String_Node_Str"");
  }
}"
3119,"public String perfString(String name){
  try {
    Object mon=findByName(name);
    if (mon == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name);
    }
    if (stringMonitorClz.isAssignableFrom(mon.getClass())) {
      Method m=mon.getClass().getMethod(""String_Node_Str"");
      Object result=m.invoke(mon);
      System.err.println(""String_Node_Str"" + result);
      return (String)result;
    }
 else {
      throw new IllegalArgumentException(name + ""String_Node_Str"");
    }
  }
 catch (  Exception me) {
    throw new RuntimeException(me);
  }
}","public String perfString(String name){
  Monitor mon=findByName(name);
  if (mon == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + name);
  }
  if (mon instanceof StringMonitor) {
    return ((StringMonitor)mon).stringValue();
  }
 else {
    throw new IllegalArgumentException(name + ""String_Node_Str"");
  }
}"
3120,"private Object findByName(String name) throws RuntimeException {
  if (!isAvailable) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return findByName.invoke(getThisVm(),name);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","private Monitor findByName(String name){
  try {
    return getThisVm().findByName(name);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
3121,"private Object getThisVm(){
  if (thisVm == null) {
synchronized (this) {
      if (thisVm == null) {
        try {
          Class monitoredHostClz=Class.forName(""String_Node_Str"");
          Class vmIdentifierClz=Class.forName(""String_Node_Str"");
          Method getMonitoredHost=monitoredHostClz.getMethod(""String_Node_Str"",String.class);
          Object monitoredHost=getMonitoredHost.invoke(null,""String_Node_Str"");
          Constructor constructor=vmIdentifierClz.getDeclaredConstructor(String.class);
          Object vmIdentifier=constructor.newInstance(""String_Node_Str"");
          Method getMonitoredVm=monitoredHostClz.getMethod(""String_Node_Str"",vmIdentifier.getClass());
          thisVm=getMonitoredVm.invoke(monitoredHost,vmIdentifier);
        }
 catch (        Exception e) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
  }
  return thisVm;
}","private MonitoredVm getThisVm(){
  if (thisVm == null) {
synchronized (this) {
      if (thisVm == null) {
        try {
          MonitoredHost localHost=MonitoredHost.getMonitoredHost(""String_Node_Str"");
          VmIdentifier vmIdent=new VmIdentifier(""String_Node_Str"");
          thisVm=localHost.getMonitoredVm(vmIdent);
        }
 catch (        MonitorException me) {
          throw new IllegalArgumentException(""String_Node_Str"" + me);
        }
catch (        URISyntaxException use) {
          throw new IllegalArgumentException(""String_Node_Str"" + use);
        }
      }
    }
  }
  return thisVm;
}"
3122,"public int perfInt(String name){
  try {
    Object mon=findByName(name);
    if (mon == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name);
    }
    if (integerMonitorClz.isAssignableFrom(mon.getClass())) {
      Method m=mon.getClass().getMethod(""String_Node_Str"");
      Object result=m.invoke(mon);
      return ((Integer)result).intValue();
    }
 else     if (longMonitorClz.isAssignableFrom(mon.getClass())) {
      Method m=mon.getClass().getMethod(""String_Node_Str"");
      Object result=m.invoke(mon);
      return ((Long)result).intValue();
    }
 else {
      throw new IllegalArgumentException(name + ""String_Node_Str"");
    }
  }
 catch (  Exception me) {
    throw new RuntimeException(me);
  }
}","public int perfInt(String name){
  Monitor mon=findByName(name);
  if (mon == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + name);
  }
  if (mon instanceof IntegerMonitor) {
    return ((IntegerMonitor)mon).intValue();
  }
 else   if (mon instanceof LongMonitor) {
    return (int)((LongMonitor)mon).longValue();
  }
 else {
    throw new IllegalArgumentException(name + ""String_Node_Str"");
  }
}"
3123,"public synchronized Object getAttribute(String name) throws AttributeNotFoundException {
  Field field=attributes.get(name);
  if (field != null) {
    throw new AttributeNotFoundException(""String_Node_Str"" + name);
  }
  return getFieldValue(field);
}","public synchronized Object getAttribute(String name) throws AttributeNotFoundException {
  Field field=attributes.get(name);
  if (field == null) {
    throw new AttributeNotFoundException(""String_Node_Str"" + name);
  }
  return getFieldValue(field);
}"
3124,"ParseState(StreamTokenizer tok,String filename){
  this.tok=tok;
  this.filename=filename;
  lineNumber=1;
  startOfLine=true;
  startOfFile=true;
}","ParseState(StreamTokenizer tok,String filename){
  this.tok=tok;
  this.filename=filename;
  startOfLine=true;
  startOfFile=true;
}"
3125,"private void pushEnableBit(boolean enabled){
  enabledBits.add(new Boolean(enabled));
  ++debugPrintIndentLevel;
}","private void pushEnableBit(boolean enabled){
  enabledBits.add(Boolean.valueOf(enabled));
  ++debugPrintIndentLevel;
}"
3126,"private void print(char c){
  if (enabled()) {
    writer.print(c);
  }
}","private void print(String s){
  if (enabled()) {
    writer.print(s);
  }
}"
3127,"private static boolean isJDK16OrAbove(byte[] code){
  final int majorOffset=4 + 2;
  int major=0x0FFFF & ((code[majorOffset] << 8) | code[majorOffset + 1]);
  return major >= 50;
}","private static boolean isJDK16OrAbove(byte[] code){
  final int majorOffset=4 + 2;
  int major=(((code[majorOffset] << 8) & 0xFF00) | ((code[majorOffset + 1]) & 0xFF));
  return major >= 50;
}"
3128,"/** 
 * Write the value of integer perf. counter of given name.
 */
public static void putPerfInt(int value,String name){
  ByteBuffer b=counters.get(name);
  long l=(long)value;
  putPerfLong(l,name);
}","/** 
 * Write the value of integer perf. counter of given name.
 */
public static void putPerfInt(int value,String name){
  long l=(long)value;
  putPerfLong(l,name);
}"
3129,"static void printMap(Map map){
  if (map instanceof BTraceMap || map.getClass().getClassLoader() == null) {
synchronized (map) {
      Map<String,String> m=new HashMap<String,String>();
      Set keys=map.keySet();
      for (      Object key : keys) {
        m.put(BTraceUtils.str(key),BTraceUtils.str(map.get(key)));
      }
      printStringMap(null,m);
    }
  }
 else {
    print(BTraceUtils.str(map));
  }
}","static void printMap(Map map){
  if (map instanceof BTraceMap || map.getClass().getClassLoader() == null) {
synchronized (map) {
      Map<String,String> m=new HashMap<String,String>();
      Set<Map.Entry<Object,Object>> entries=map.entrySet();
      for (      Map.Entry<Object,Object> e : entries) {
        m.put(BTraceUtils.str(e.getKey()),BTraceUtils.str(e.getValue()));
      }
      printStringMap(null,m);
    }
  }
 else {
    print(BTraceUtils.str(map));
  }
}"
3130,"private void init(Class cl){
  if (this.clazz != null) {
    return;
  }
  this.clazz=cl;
  List<Method> actionsList=new ArrayList<Method>();
  List<Method> timersList=new ArrayList<Method>();
  this.eventHandlers=new HashMap<String,Method>();
  this.lowMemHandlers=new HashMap<String,Method>();
  Method[] methods=clazz.getMethods();
  for (  Method m : methods) {
    int modifiers=m.getModifiers();
    if (!Modifier.isStatic(modifiers)) {
      continue;
    }
    OnEvent oev=m.getAnnotation(OnEvent.class);
    if (oev != null && m.getParameterTypes().length == 0) {
      eventHandlers.put(oev.value(),m);
    }
    OnError oer=m.getAnnotation(OnError.class);
    if (oer != null) {
      Class[] argTypes=m.getParameterTypes();
      if (argTypes.length == 1 && argTypes[0] == Throwable.class) {
        this.exceptionHandler=m;
      }
    }
    OnExit oex=m.getAnnotation(OnExit.class);
    if (oex != null) {
      Class[] argTypes=m.getParameterTypes();
      if (argTypes.length == 1 && argTypes[0] == int.class) {
        this.exitHandler=m;
      }
    }
    OnTimer ot=m.getAnnotation(OnTimer.class);
    if (ot != null && m.getParameterTypes().length == 0) {
      timersList.add(m);
    }
    OnLowMemory olm=m.getAnnotation(OnLowMemory.class);
    if (olm != null) {
      Class[] argTypes=m.getParameterTypes();
      if ((argTypes.length == 0) || (argTypes.length == 1 && argTypes[0] == MemoryUsage.class)) {
        lowMemHandlers.put(olm.pool(),m);
      }
    }
  }
  List<MemoryPoolMXBean> mpools=getMemoryPoolMXBeans();
  for (  MemoryPoolMXBean mpoolBean : mpools) {
    String name=mpoolBean.getName();
    if (lowMemHandlers.containsKey(name)) {
      Method m=lowMemHandlers.get(name);
      OnLowMemory olm=m.getAnnotation(OnLowMemory.class);
      if (mpoolBean.isUsageThresholdSupported()) {
        mpoolBean.setUsageThreshold(olm.threshold());
      }
    }
  }
  timerHandlers=new Method[timersList.size()];
  timersList.toArray(timerHandlers);
}","private void init(Class cl){
  if (this.clazz != null) {
    return;
  }
  this.clazz=cl;
  List<Method> timersList=new ArrayList<Method>();
  this.eventHandlers=new HashMap<String,Method>();
  this.lowMemHandlers=new HashMap<String,Method>();
  Method[] methods=clazz.getMethods();
  for (  Method m : methods) {
    int modifiers=m.getModifiers();
    if (!Modifier.isStatic(modifiers)) {
      continue;
    }
    OnEvent oev=m.getAnnotation(OnEvent.class);
    if (oev != null && m.getParameterTypes().length == 0) {
      eventHandlers.put(oev.value(),m);
    }
    OnError oer=m.getAnnotation(OnError.class);
    if (oer != null) {
      Class[] argTypes=m.getParameterTypes();
      if (argTypes.length == 1 && argTypes[0] == Throwable.class) {
        this.exceptionHandler=m;
      }
    }
    OnExit oex=m.getAnnotation(OnExit.class);
    if (oex != null) {
      Class[] argTypes=m.getParameterTypes();
      if (argTypes.length == 1 && argTypes[0] == int.class) {
        this.exitHandler=m;
      }
    }
    OnTimer ot=m.getAnnotation(OnTimer.class);
    if (ot != null && m.getParameterTypes().length == 0) {
      timersList.add(m);
    }
    OnLowMemory olm=m.getAnnotation(OnLowMemory.class);
    if (olm != null) {
      Class[] argTypes=m.getParameterTypes();
      if ((argTypes.length == 0) || (argTypes.length == 1 && argTypes[0] == MemoryUsage.class)) {
        lowMemHandlers.put(olm.pool(),m);
      }
    }
  }
  List<MemoryPoolMXBean> mpools=getMemoryPoolMXBeans();
  for (  MemoryPoolMXBean mpoolBean : mpools) {
    String name=mpoolBean.getName();
    if (lowMemHandlers.containsKey(name)) {
      Method m=lowMemHandlers.get(name);
      OnLowMemory olm=m.getAnnotation(OnLowMemory.class);
      if (mpoolBean.isUsageThresholdSupported()) {
        mpoolBean.setUsageThreshold(olm.threshold());
      }
    }
  }
  timerHandlers=new Method[timersList.size()];
  timersList.toArray(timerHandlers);
}"
3131,"static String stackTraceAllStr(int numFrames){
  Map<Thread,StackTraceElement[]> traces=Thread.getAllStackTraces();
  StringBuilder buf=new StringBuilder();
  for (  Thread th : traces.keySet()) {
    buf.append(th.toString());
    buf.append(LINE_SEPARATOR);
    buf.append(LINE_SEPARATOR);
    StackTraceElement[] st=traces.get(th);
    buf.append(stackTraceStr(""String_Node_Str"",st,0,numFrames));
    buf.append(LINE_SEPARATOR);
  }
  return buf.toString();
}","static String stackTraceAllStr(int numFrames){
  Set<Map.Entry<Thread,StackTraceElement[]>> traces=Thread.getAllStackTraces().entrySet();
  StringBuilder buf=new StringBuilder();
  for (  Map.Entry<Thread,StackTraceElement[]> t : traces) {
    buf.append(t.getKey().toString());
    buf.append(LINE_SEPARATOR);
    buf.append(LINE_SEPARATOR);
    StackTraceElement[] st=t.getValue();
    buf.append(stackTraceStr(""String_Node_Str"",st,0,numFrames));
    buf.append(LINE_SEPARATOR);
  }
  return buf.toString();
}"
3132,"private static byte[] getStringBytes(String value){
  byte[] v=null;
  try {
    v=value.getBytes(""String_Node_Str"");
  }
 catch (  java.io.UnsupportedEncodingException e) {
  }
  byte[] v1=new byte[v.length + 1];
  System.arraycopy(v,0,v1,0,v.length);
  v1[v.length]='\0';
  return v1;
}","private static byte[] getStringBytes(String value){
  byte[] v=null;
  try {
    v=value.getBytes(""String_Node_Str"");
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
  byte[] v1=new byte[v.length + 1];
  System.arraycopy(v,0,v1,0,v.length);
  v1[v.length]='\0';
  return v1;
}"
3133,"protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter();
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  onCommand(new OkayCommand());
  Class btraceClazz;
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    BTraceRuntime.enter();
  }
  return btraceClazz;
}","protected Class loadClass(InstrumentCommand instr) throws IOException {
  String[] args=instr.getArguments();
  this.btraceCode=instr.getCode();
  try {
    verify(btraceCode);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  this.filter=new ClassFilter(onMethods);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  ClassWriter writer=InstrumentUtils.newClassWriter();
  ClassReader reader=new ClassReader(btraceCode);
  ClassVisitor visitor=new Preprocessor(writer);
  if (BTraceRuntime.classNameExists(className)) {
    className+=""String_Node_Str"" + getCount();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    onCommand(new RenameCommand(className));
    visitor=new ClassRenamer(className,visitor);
  }
  try {
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    InstrumentUtils.accept(reader,visitor);
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    btraceCode=writer.toByteArray();
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
  Main.dumpClass(className,className,btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  this.runtime=new BTraceRuntime(className,args,this,inst);
  if (debug)   Main.debugPrint(""String_Node_Str"" + className);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  byte[] codeBuf=removeMethods(btraceCode);
  if (debug)   Main.debugPrint(""String_Node_Str"");
  if (debug)   Main.debugPrint(""String_Node_Str"");
  onCommand(new OkayCommand());
  try {
    BTraceRuntime.leave();
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
    if (shouldAddTransformer()) {
      this.btraceClazz=runtime.defineClass(codeBuf);
    }
 else {
      this.btraceClazz=runtime.defineClass(codeBuf,false);
    }
    if (debug)     Main.debugPrint(""String_Node_Str"" + className);
  }
 catch (  Throwable th) {
    if (debug)     Main.debugPrint(th);
    errorExit(th);
    return null;
  }
 finally {
    BTraceRuntime.enter();
  }
  return this.btraceClazz;
}"
3134,"private static byte[] readAll(File file) throws IOException {
  int size=(int)file.length();
  FileInputStream fis=new FileInputStream(file);
  byte[] buf=new byte[size];
  fis.read(buf);
  return buf;
}","private static byte[] readAll(File file) throws IOException {
  int size=(int)file.length();
  FileInputStream fis=new FileInputStream(file);
  try {
    byte[] buf=new byte[size];
    fis.read(buf);
    return buf;
  }
  finally {
    fis.close();
  }
}"
3135,"static void dumpClass(String btraceClassName,String targetClassName,byte[] code){
  if (dumpClasses) {
    try {
      targetClassName=targetClassName.replace(""String_Node_Str"",File.separator);
      int index=targetClassName.lastIndexOf(File.separatorChar);
      StringBuilder buf=new StringBuilder();
      buf.append(btraceClassName);
      buf.append(File.separatorChar);
      if (dumpDir.equals(""String_Node_Str"")) {
        buf.append(dumpDir);
        buf.append(File.separatorChar);
      }
      String dir=buf.toString();
      if (index != -1) {
        dir+=targetClassName.substring(0,index);
      }
      new File(dir).mkdirs();
      String file;
      if (index != -1) {
        file=targetClassName.substring(index + 1);
      }
 else {
        file=targetClassName;
      }
      file+=""String_Node_Str"";
      File out=new File(dir,file);
      FileOutputStream fos=new FileOutputStream(out);
      fos.write(code);
    }
 catch (    Exception exp) {
      exp.printStackTrace();
    }
  }
}","static void dumpClass(String btraceClassName,String targetClassName,byte[] code){
  if (dumpClasses) {
    try {
      targetClassName=targetClassName.replace(""String_Node_Str"",File.separator);
      int index=targetClassName.lastIndexOf(File.separatorChar);
      StringBuilder buf=new StringBuilder();
      buf.append(btraceClassName);
      buf.append(File.separatorChar);
      if (dumpDir.equals(""String_Node_Str"")) {
        buf.append(dumpDir);
        buf.append(File.separatorChar);
      }
      String dir=buf.toString();
      if (index != -1) {
        dir+=targetClassName.substring(0,index);
      }
      new File(dir).mkdirs();
      String file;
      if (index != -1) {
        file=targetClassName.substring(index + 1);
      }
 else {
        file=targetClassName;
      }
      file+=""String_Node_Str"";
      File out=new File(dir,file);
      FileOutputStream fos=new FileOutputStream(out);
      try {
        fos.write(code);
      }
  finally {
        fos.close();
      }
    }
 catch (    Exception exp) {
      exp.printStackTrace();
    }
  }
}"
3136,"/** 
 * Compiles given BTrace program using given classpath. Errors and warning are written to given PrintWriter.
 */
public byte[] compile(String fileName,String classPath,PrintWriter err){
  byte[] code=null;
  File file=new File(fileName);
  if (fileName.endsWith(""String_Node_Str"")) {
    Compiler compiler=new Compiler();
    classPath+=File.pathSeparator + System.getProperty(""String_Node_Str"");
    if (debug)     debugPrint(""String_Node_Str"" + fileName);
    Map<String,byte[]> classes=compiler.compile(file,err,""String_Node_Str"",classPath);
    if (classes == null) {
      err.println(""String_Node_Str"");
      return null;
    }
    int size=classes.size();
    if (size != 1) {
      err.println(""String_Node_Str"");
      return null;
    }
    String name=classes.keySet().iterator().next();
    code=classes.get(name);
    if (debug)     debugPrint(""String_Node_Str"" + fileName);
  }
 else   if (fileName.endsWith(""String_Node_Str"")) {
    code=new byte[(int)file.length()];
    try {
      FileInputStream fis=new FileInputStream(file);
      if (debug)       debugPrint(""String_Node_Str"" + fileName);
      fis.read(code);
      if (debug)       debugPrint(""String_Node_Str"" + fileName);
    }
 catch (    IOException exp) {
      err.println(exp.getMessage());
      return null;
    }
  }
 else {
    err.println(""String_Node_Str"");
    return null;
  }
  return code;
}","/** 
 * Compiles given BTrace program using given classpath. Errors and warning are written to given PrintWriter.
 */
public byte[] compile(String fileName,String classPath,PrintWriter err){
  byte[] code=null;
  File file=new File(fileName);
  if (fileName.endsWith(""String_Node_Str"")) {
    Compiler compiler=new Compiler();
    classPath+=File.pathSeparator + System.getProperty(""String_Node_Str"");
    if (debug)     debugPrint(""String_Node_Str"" + fileName);
    Map<String,byte[]> classes=compiler.compile(file,err,""String_Node_Str"",classPath);
    if (classes == null) {
      err.println(""String_Node_Str"");
      return null;
    }
    int size=classes.size();
    if (size != 1) {
      err.println(""String_Node_Str"");
      return null;
    }
    String name=classes.keySet().iterator().next();
    code=classes.get(name);
    if (debug)     debugPrint(""String_Node_Str"" + fileName);
  }
 else   if (fileName.endsWith(""String_Node_Str"")) {
    code=new byte[(int)file.length()];
    try {
      FileInputStream fis=new FileInputStream(file);
      if (debug)       debugPrint(""String_Node_Str"" + fileName);
      try {
        fis.read(code);
      }
  finally {
        fis.close();
      }
      if (debug)       debugPrint(""String_Node_Str"" + fileName);
    }
 catch (    IOException exp) {
      err.println(exp.getMessage());
      return null;
    }
  }
 else {
    err.println(""String_Node_Str"");
    return null;
  }
  return code;
}"
3137,"public static void main(String[] args) throws Exception {
  Compiler compiler=new Compiler();
  if (args.length == 0) {
    usage();
  }
  String classPath=""String_Node_Str"";
  String outputDir=""String_Node_Str"";
  int count=0;
  boolean classPathDefined=false;
  boolean outputDirDefined=false;
  for (; ; ) {
    if (args[count].charAt(0) == '-') {
      if (args.length <= count + 1) {
        usage();
      }
      if ((args[count].equals(""String_Node_Str"") || args[count].equals(""String_Node_Str"")) && !classPathDefined) {
        classPath=args[++count];
        classPathDefined=true;
      }
 else       if (args[count].equals(""String_Node_Str"") && !outputDirDefined) {
        outputDir=args[++count];
        outputDirDefined=true;
      }
 else {
        usage();
      }
      count++;
      if (count >= args.length) {
        break;
      }
    }
 else {
      break;
    }
  }
  if (args.length <= count) {
    usage();
  }
  File[] files=new File[args.length - count];
  for (int i=0; i < files.length; i++) {
    files[i]=new File(args[i + count]);
    if (!files[i].exists()) {
      usage(""String_Node_Str"" + files[i]);
    }
  }
  classPath+=File.pathSeparator + System.getProperty(""String_Node_Str"");
  Map<String,byte[]> classes=compiler.compile(files,new PrintWriter(System.err),""String_Node_Str"",classPath);
  if (classes != null) {
    for (    String c : classes.keySet()) {
      String name=c.replace(""String_Node_Str"",File.separator);
      int index=name.lastIndexOf(File.separatorChar);
      String dir=outputDir + File.separator;
      if (index != -1) {
        dir+=name.substring(0,index);
      }
      new File(dir).mkdirs();
      String file;
      if (index != -1) {
        file=name.substring(index + 1);
      }
 else {
        file=name;
      }
      file+=""String_Node_Str"";
      File out=new File(dir,file);
      FileOutputStream fos=new FileOutputStream(out);
      fos.write(classes.get(c));
      fos.close();
    }
  }
}","public static void main(String[] args) throws Exception {
  Compiler compiler=new Compiler();
  if (args.length == 0) {
    usage();
  }
  String classPath=""String_Node_Str"";
  String outputDir=""String_Node_Str"";
  int count=0;
  boolean classPathDefined=false;
  boolean outputDirDefined=false;
  for (; ; ) {
    if (args[count].charAt(0) == '-') {
      if (args.length <= count + 1) {
        usage();
      }
      if ((args[count].equals(""String_Node_Str"") || args[count].equals(""String_Node_Str"")) && !classPathDefined) {
        classPath=args[++count];
        classPathDefined=true;
      }
 else       if (args[count].equals(""String_Node_Str"") && !outputDirDefined) {
        outputDir=args[++count];
        outputDirDefined=true;
      }
 else {
        usage();
      }
      count++;
      if (count >= args.length) {
        break;
      }
    }
 else {
      break;
    }
  }
  if (args.length <= count) {
    usage();
  }
  File[] files=new File[args.length - count];
  for (int i=0; i < files.length; i++) {
    files[i]=new File(args[i + count]);
    if (!files[i].exists()) {
      usage(""String_Node_Str"" + files[i]);
    }
  }
  classPath+=File.pathSeparator + System.getProperty(""String_Node_Str"");
  Map<String,byte[]> classes=compiler.compile(files,new PrintWriter(System.err),""String_Node_Str"",classPath);
  if (classes != null) {
    for (    Map.Entry<String,byte[]> c : classes.entrySet()) {
      String name=c.getKey().replace(""String_Node_Str"",File.separator);
      int index=name.lastIndexOf(File.separatorChar);
      String dir=outputDir + File.separator;
      if (index != -1) {
        dir+=name.substring(0,index);
      }
      new File(dir).mkdirs();
      String file;
      if (index != -1) {
        file=name.substring(index + 1);
      }
 else {
        file=name;
      }
      file+=""String_Node_Str"";
      File out=new File(dir,file);
      FileOutputStream fos=new FileOutputStream(out);
      fos.write(c.getValue());
      fos.close();
    }
  }
}"
3138,"public void box(String desc){
  int typeCode=desc.charAt(0);
switch (typeCode) {
case '[':
case 'L':
    break;
case 'Z':
  super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_BOOLEAN,BOX_VALUEOF,BOX_BOOLEAN_DESC);
break;
case 'C':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_CHARACTER,BOX_VALUEOF,BOX_CHARACTER_DESC);
case 'B':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_BYTE,BOX_VALUEOF,BOX_BYTE_DESC);
break;
case 'S':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_SHORT,BOX_VALUEOF,BOX_SHORT_DESC);
break;
case 'I':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_INTEGER,BOX_VALUEOF,BOX_INTEGER_DESC);
break;
case 'J':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_LONG,BOX_VALUEOF,BOX_LONG_DESC);
break;
case 'F':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_FLOAT,BOX_VALUEOF,BOX_FLOAT_DESC);
break;
case 'D':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_DOUBLE,BOX_VALUEOF,BOX_DOUBLE_DESC);
break;
}
}","public void box(String desc){
  int typeCode=desc.charAt(0);
switch (typeCode) {
case '[':
case 'L':
    break;
case 'Z':
  super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_BOOLEAN,BOX_VALUEOF,BOX_BOOLEAN_DESC);
break;
case 'C':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_CHARACTER,BOX_VALUEOF,BOX_CHARACTER_DESC);
break;
case 'B':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_BYTE,BOX_VALUEOF,BOX_BYTE_DESC);
break;
case 'S':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_SHORT,BOX_VALUEOF,BOX_SHORT_DESC);
break;
case 'I':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_INTEGER,BOX_VALUEOF,BOX_INTEGER_DESC);
break;
case 'J':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_LONG,BOX_VALUEOF,BOX_LONG_DESC);
break;
case 'F':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_FLOAT,BOX_VALUEOF,BOX_FLOAT_DESC);
break;
case 'D':
super.visitMethodInsn(INVOKESTATIC,JAVA_LANG_DOUBLE,BOX_VALUEOF,BOX_DOUBLE_DESC);
break;
}
}"
3139,"public void push(int value){
  if (value >= -1 && value <= 5) {
    super.visitInsn(ICONST_0 + value);
  }
 else   if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
    super.visitIntInsn(BIPUSH,value);
  }
 else   if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
    super.visitIntInsn(SIPUSH,value);
  }
 else {
    super.visitLdcInsn(new Integer(value));
  }
}","public void push(int value){
  if (value >= -1 && value <= 5) {
    super.visitInsn(ICONST_0 + value);
  }
 else   if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {
    super.visitIntInsn(BIPUSH,value);
  }
 else   if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {
    super.visitIntInsn(SIPUSH,value);
  }
 else {
    super.visitLdcInsn(Integer.valueOf(value));
  }
}"
3140,"private void initThreadPool(){
  if (threadPool == null) {
synchronized (this) {
      if (threadPool == null) {
        threadPool=Executors.newFixedThreadPool(1);
      }
    }
  }
}","private void initThreadPool(){
  if (threadPool == null) {
synchronized (this) {
      if (threadPool == null) {
        threadPool=Executors.newFixedThreadPool(1,new ThreadFactory(){
          @Override public Thread newThread(          Runnable r){
            Thread th=new Thread(r);
            th.setDaemon(true);
            return th;
          }
        }
);
      }
    }
  }
}"
3141,"/** 
 * Retrieve offset introduce by the navigation bar.
 * @return bottom offset due to navigation bar.
 */
private int getNavigationBarOffset(){
  int result=0;
  Resources resources=mHoldingActivity.getResources();
  if (Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP) {
    int resourceId=resources.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (resourceId > 0) {
      result=resources.getDimensionPixelSize(resourceId);
    }
  }
  return result;
}","/** 
 * Retrieve offset introduce by the navigation bar.
 * @return bottom offset due to navigation bar.
 */
private int getNavigationBarOffset(){
  int result=0;
  Resources resources=mHoldingActivity.getResources();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    int resourceId=resources.getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (resourceId > 0) {
      result=resources.getDimensionPixelSize(resourceId);
    }
  }
  return result;
}"
3142,"/** 
 * Enable / disable debug mode. <p/> LogCat and graphical information directly on blurred screen.
 * @param enable true to display log in LogCat.
 */
public void debug(boolean enable){
  mDebudEnable=enable;
}","/** 
 * Enable / disable debug mode. <p/> LogCat and graphical information directly on blurred screen.
 * @param enable true to display log in LogCat.
 */
public void debug(boolean enable){
  mDebugEnable=enable;
}"
3143,"/** 
 * Blur the given bitmap and add it to the activity.
 * @param bkg  should be a bitmap of the background.
 * @param view background view.
 */
private void blur(Bitmap bkg,View view){
  long startMs=System.currentTimeMillis();
  mBlurredBackgroundLayoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT);
  Bitmap overlay=null;
  int actionBarHeight=0;
  try {
    if (mHoldingActivity instanceof ActionBarActivity) {
      ActionBar supportActionBar=((ActionBarActivity)mHoldingActivity).getSupportActionBar();
      if (supportActionBar != null) {
        actionBarHeight=supportActionBar.getHeight();
      }
    }
 else     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
 catch (  NoClassDefFoundError e) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
  int statusBarHeight=0;
  if ((mHoldingActivity.getWindow().getAttributes().flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0) {
    statusBarHeight=getStatusBarHeight();
  }
  final int topOffset=actionBarHeight + statusBarHeight;
  final int bottomOffset=getNavigationBarOffset();
  Rect srcRect=new Rect(0,actionBarHeight + statusBarHeight,bkg.getWidth(),bkg.getHeight() - bottomOffset);
  double height=Math.ceil((view.getMeasuredHeight() - topOffset - bottomOffset) / mDownScaleFactor);
  double width=Math.ceil((view.getWidth() * height / (view.getMeasuredHeight() - topOffset - bottomOffset)));
  overlay=Bitmap.createBitmap((int)width,(int)height,Bitmap.Config.RGB_565);
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB || mHoldingActivity instanceof ActionBarActivity) {
      mBlurredBackgroundLayoutParams.setMargins(0,actionBarHeight,0,0);
      mBlurredBackgroundLayoutParams.gravity=Gravity.TOP;
    }
  }
 catch (  NoClassDefFoundError e) {
    mBlurredBackgroundLayoutParams.setMargins(0,0,0,0);
  }
  Canvas canvas=new Canvas(overlay);
  Paint paint=new Paint();
  paint.setFlags(Paint.FILTER_BITMAP_FLAG);
  final RectF destRect=new RectF(0,0,overlay.getWidth(),overlay.getHeight());
  canvas.drawBitmap(bkg,srcRect,destRect,paint);
  overlay=FastBlurHelper.doBlur(overlay,mBlurRadius,false);
  if (mDebudEnable) {
    String blurTime=(System.currentTimeMillis() - startMs) + ""String_Node_Str"";
    Log.d(TAG,""String_Node_Str"" + mBlurRadius);
    Log.d(TAG,""String_Node_Str"" + mDownScaleFactor);
    Log.d(TAG,""String_Node_Str"" + blurTime);
    Log.d(TAG,""String_Node_Str"" + bkg.getRowBytes() + ""String_Node_Str""+ overlay.getRowBytes()+ ""String_Node_Str"");
    Rect bounds=new Rect();
    Canvas canvas1=new Canvas(overlay);
    paint.setColor(Color.BLACK);
    paint.setAntiAlias(true);
    paint.setTextSize(20.0f);
    paint.getTextBounds(blurTime,0,blurTime.length(),bounds);
    canvas1.drawText(blurTime,2,bounds.height(),paint);
  }
  mBlurredBackgroundView=new ImageView(mHoldingActivity);
  mBlurredBackgroundView.setImageDrawable(new BitmapDrawable(mHoldingActivity.getResources(),overlay));
}","/** 
 * Blur the given bitmap and add it to the activity.
 * @param bkg  should be a bitmap of the background.
 * @param view background view.
 */
private void blur(Bitmap bkg,View view){
  long startMs=System.currentTimeMillis();
  mBlurredBackgroundLayoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT);
  Bitmap overlay=null;
  int actionBarHeight=0;
  try {
    if (mHoldingActivity instanceof ActionBarActivity) {
      ActionBar supportActionBar=((ActionBarActivity)mHoldingActivity).getSupportActionBar();
      if (supportActionBar != null) {
        actionBarHeight=supportActionBar.getHeight();
      }
    }
 else     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
 catch (  NoClassDefFoundError e) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
  int statusBarHeight=0;
  if ((mHoldingActivity.getWindow().getAttributes().flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0) {
    statusBarHeight=getStatusBarHeight();
  }
  final int topOffset=actionBarHeight + statusBarHeight;
  final int bottomOffset=getNavigationBarOffset();
  Rect srcRect=new Rect(0,actionBarHeight + statusBarHeight,bkg.getWidth(),bkg.getHeight() - bottomOffset);
  double height=Math.ceil((view.getMeasuredHeight() - topOffset - bottomOffset) / mDownScaleFactor);
  double width=Math.ceil((view.getWidth() * height / (view.getMeasuredHeight() - topOffset - bottomOffset)));
  overlay=Bitmap.createBitmap((int)width,(int)height,Bitmap.Config.RGB_565);
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB || mHoldingActivity instanceof ActionBarActivity) {
      mBlurredBackgroundLayoutParams.setMargins(0,actionBarHeight,0,0);
      mBlurredBackgroundLayoutParams.gravity=Gravity.TOP;
    }
  }
 catch (  NoClassDefFoundError e) {
    mBlurredBackgroundLayoutParams.setMargins(0,0,0,0);
  }
  Canvas canvas=new Canvas(overlay);
  Paint paint=new Paint();
  paint.setFlags(Paint.FILTER_BITMAP_FLAG);
  final RectF destRect=new RectF(0,0,overlay.getWidth(),overlay.getHeight());
  canvas.drawBitmap(bkg,srcRect,destRect,paint);
  overlay=FastBlurHelper.doBlur(overlay,mBlurRadius,false);
  if (mDebugEnable) {
    String blurTime=(System.currentTimeMillis() - startMs) + ""String_Node_Str"";
    Log.d(TAG,""String_Node_Str"" + mBlurRadius);
    Log.d(TAG,""String_Node_Str"" + mDownScaleFactor);
    Log.d(TAG,""String_Node_Str"" + blurTime);
    Log.d(TAG,""String_Node_Str"" + bkg.getRowBytes() + ""String_Node_Str""+ overlay.getRowBytes()+ ""String_Node_Str"");
    Rect bounds=new Rect();
    Canvas canvas1=new Canvas(overlay);
    paint.setColor(Color.BLACK);
    paint.setAntiAlias(true);
    paint.setTextSize(20.0f);
    paint.getTextBounds(blurTime,0,blurTime.length(),bounds);
    canvas1.drawText(blurTime,2,bounds.height(),paint);
  }
  mBlurredBackgroundView=new ImageView(mHoldingActivity);
  mBlurredBackgroundView.setImageDrawable(new BitmapDrawable(mHoldingActivity.getResources(),overlay));
}"
3144,"/** 
 * Enable / disable debug mode. <p/> LogCat and graphical information directly on blurred screen.
 * @param enable true to display log in LogCat.
 */
public void debug(boolean enable){
  mDebudEnable=enable;
}","/** 
 * Enable / disable debug mode. <p/> LogCat and graphical information directly on blurred screen.
 * @param enable true to display log in LogCat.
 */
public void debug(boolean enable){
  mDebugEnable=enable;
}"
3145,"/** 
 * Blur the given bitmap and add it to the activity.
 * @param bkg  should be a bitmap of the background.
 * @param view background view.
 */
private void blur(Bitmap bkg,View view){
  long startMs=System.currentTimeMillis();
  mBlurredBackgroundLayoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT);
  Bitmap overlay=null;
  int actionBarHeight=0;
  try {
    if (mHoldingActivity instanceof ActionBarActivity) {
      ActionBar supportActionBar=((ActionBarActivity)mHoldingActivity).getSupportActionBar();
      if (supportActionBar != null) {
        actionBarHeight=supportActionBar.getHeight();
      }
    }
 else     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
 catch (  NoClassDefFoundError e) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
  int statusBarHeight=0;
  if ((mHoldingActivity.getWindow().getAttributes().flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0) {
    statusBarHeight=getStatusBarHeight();
  }
  final int topOffset=actionBarHeight + statusBarHeight;
  final int bottomOffset=getNavigationBarOffset();
  Rect srcRect=new Rect(0,actionBarHeight + statusBarHeight,bkg.getWidth(),bkg.getHeight() - bottomOffset);
  double height=Math.ceil((view.getMeasuredHeight() - topOffset - bottomOffset) / mDownScaleFactor);
  double width=Math.ceil((view.getWidth() * height / (view.getMeasuredHeight() - topOffset - bottomOffset)));
  overlay=Bitmap.createBitmap((int)width,(int)height,Bitmap.Config.RGB_565);
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB || mHoldingActivity instanceof ActionBarActivity) {
      mBlurredBackgroundLayoutParams.setMargins(0,actionBarHeight,0,0);
      mBlurredBackgroundLayoutParams.gravity=Gravity.TOP;
    }
  }
 catch (  NoClassDefFoundError e) {
    mBlurredBackgroundLayoutParams.setMargins(0,0,0,0);
  }
  Canvas canvas=new Canvas(overlay);
  Paint paint=new Paint();
  paint.setFlags(Paint.FILTER_BITMAP_FLAG);
  final RectF destRect=new RectF(0,0,overlay.getWidth(),overlay.getHeight());
  canvas.drawBitmap(bkg,srcRect,destRect,paint);
  overlay=FastBlurHelper.doBlur(overlay,mBlurRadius,false);
  if (mDebudEnable) {
    String blurTime=(System.currentTimeMillis() - startMs) + ""String_Node_Str"";
    Log.d(TAG,""String_Node_Str"" + mBlurRadius);
    Log.d(TAG,""String_Node_Str"" + mDownScaleFactor);
    Log.d(TAG,""String_Node_Str"" + blurTime);
    Log.d(TAG,""String_Node_Str"" + bkg.getRowBytes() + ""String_Node_Str""+ overlay.getRowBytes()+ ""String_Node_Str"");
    Rect bounds=new Rect();
    Canvas canvas1=new Canvas(overlay);
    paint.setColor(Color.BLACK);
    paint.setAntiAlias(true);
    paint.setTextSize(20.0f);
    paint.getTextBounds(blurTime,0,blurTime.length(),bounds);
    canvas1.drawText(blurTime,2,bounds.height(),paint);
  }
  mBlurredBackgroundView=new ImageView(mHoldingActivity);
  mBlurredBackgroundView.setImageDrawable(new BitmapDrawable(mHoldingActivity.getResources(),overlay));
}","/** 
 * Blur the given bitmap and add it to the activity.
 * @param bkg  should be a bitmap of the background.
 * @param view background view.
 */
private void blur(Bitmap bkg,View view){
  long startMs=System.currentTimeMillis();
  mBlurredBackgroundLayoutParams=new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,FrameLayout.LayoutParams.MATCH_PARENT);
  Bitmap overlay=null;
  int actionBarHeight=0;
  try {
    if (mHoldingActivity instanceof ActionBarActivity) {
      ActionBar supportActionBar=((ActionBarActivity)mHoldingActivity).getSupportActionBar();
      if (supportActionBar != null) {
        actionBarHeight=supportActionBar.getHeight();
      }
    }
 else     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
 catch (  NoClassDefFoundError e) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      android.app.ActionBar actionBar=mHoldingActivity.getActionBar();
      if (actionBar != null) {
        actionBarHeight=actionBar.getHeight();
      }
    }
  }
  int statusBarHeight=0;
  if ((mHoldingActivity.getWindow().getAttributes().flags & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0) {
    statusBarHeight=getStatusBarHeight();
  }
  final int topOffset=actionBarHeight + statusBarHeight;
  final int bottomOffset=getNavigationBarOffset();
  Rect srcRect=new Rect(0,actionBarHeight + statusBarHeight,bkg.getWidth(),bkg.getHeight() - bottomOffset);
  double height=Math.ceil((view.getMeasuredHeight() - topOffset - bottomOffset) / mDownScaleFactor);
  double width=Math.ceil((view.getWidth() * height / (view.getMeasuredHeight() - topOffset - bottomOffset)));
  overlay=Bitmap.createBitmap((int)width,(int)height,Bitmap.Config.RGB_565);
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB || mHoldingActivity instanceof ActionBarActivity) {
      mBlurredBackgroundLayoutParams.setMargins(0,actionBarHeight,0,0);
      mBlurredBackgroundLayoutParams.gravity=Gravity.TOP;
    }
  }
 catch (  NoClassDefFoundError e) {
    mBlurredBackgroundLayoutParams.setMargins(0,0,0,0);
  }
  Canvas canvas=new Canvas(overlay);
  Paint paint=new Paint();
  paint.setFlags(Paint.FILTER_BITMAP_FLAG);
  final RectF destRect=new RectF(0,0,overlay.getWidth(),overlay.getHeight());
  canvas.drawBitmap(bkg,srcRect,destRect,paint);
  overlay=FastBlurHelper.doBlur(overlay,mBlurRadius,false);
  if (mDebugEnable) {
    String blurTime=(System.currentTimeMillis() - startMs) + ""String_Node_Str"";
    Log.d(TAG,""String_Node_Str"" + mBlurRadius);
    Log.d(TAG,""String_Node_Str"" + mDownScaleFactor);
    Log.d(TAG,""String_Node_Str"" + blurTime);
    Log.d(TAG,""String_Node_Str"" + bkg.getRowBytes() + ""String_Node_Str""+ overlay.getRowBytes()+ ""String_Node_Str"");
    Rect bounds=new Rect();
    Canvas canvas1=new Canvas(overlay);
    paint.setColor(Color.BLACK);
    paint.setAntiAlias(true);
    paint.setTextSize(20.0f);
    paint.getTextBounds(blurTime,0,blurTime.length(),bounds);
    canvas1.drawText(blurTime,2,bounds.height(),paint);
  }
  mBlurredBackgroundView=new ImageView(mHoldingActivity);
  mBlurredBackgroundView.setImageDrawable(new BitmapDrawable(mHoldingActivity.getResources(),overlay));
}"
3146,"public void dismiss(){
  if (mIsDismissing) {
    return;
  }
  mIsDismissing=true;
  if (mEventListener != null && mIsShowing) {
    mEventListener.onDismiss(Snackbar.this);
  }
  if (!mAnimated) {
    finish();
    return;
  }
  final Animation slideOut=AnimationUtils.loadAnimation(getContext(),R.anim.snackbar_out);
  slideOut.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      post(new Runnable(){
        @Override public void run(){
          finish();
        }
      }
);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  startAnimation(slideOut);
}","private void dismiss(boolean animate){
  if (mIsDismissing) {
    return;
  }
  mIsDismissing=true;
  if (mEventListener != null && mIsShowing) {
    mEventListener.onDismiss(Snackbar.this);
  }
  if (!animate) {
    finish();
    return;
  }
  final Animation slideOut=AnimationUtils.loadAnimation(getContext(),R.anim.snackbar_out);
  slideOut.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      post(new Runnable(){
        @Override public void run(){
          finish();
        }
      }
);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
  startAnimation(slideOut);
}"
3147,"@Override public void onDismiss(View view,Object token){
  if (view != null) {
    finish();
  }
}","@Override public void onDismiss(View view,Object token){
  if (view != null) {
    dismiss(false);
  }
}"
3148,"protected INDArray createScalarForIndex(int i,boolean applyOffset){
  return create(data(),new int[]{1,1},new int[]{1,1},applyOffset ? Shape.offset(javaShapeInformation) + i : i);
}","protected INDArray createScalarForIndex(int i,boolean applyOffset){
  if (isVector())   return getScalar(i);
  return create(data(),new int[]{1,1},new int[]{1,1},i);
}"
3149,"/** 
 * @param indexes
 * @return
 */
public boolean tryShortCircuit(INDArrayIndex... indexes){
  int pointIndex=0;
  int interval=0;
  int newAxis=0;
  int numAll=0;
  int numSpecified=0;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i] instanceof PointIndex) {
      pointIndex++;
    }
    if (indexes[i] instanceof SpecifiedIndex)     numSpecified++;
 else     if (indexes[i] instanceof IntervalIndex && !(indexes[i] instanceof NDArrayIndexAll))     interval++;
 else     if (indexes[i] instanceof NewAxis)     newAxis++;
 else     if (indexes[i] instanceof NDArrayIndexAll)     numAll++;
  }
  if (arr.isVector()) {
    if (indexes[0] instanceof NDArrayIndexAll && indexes.length == 1) {
      offset=0;
      this.shapes=LongUtils.toLongs(arr.shape());
      this.strides=LongUtils.toLongs(arr.stride());
      this.offsets=new long[arr.rank()];
      return true;
    }
 else     if (indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll) {
      this.shapes=new long[2];
      this.strides=new long[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=arr.stride(i);
      }
      this.offsets=new long[arr.rank()];
      this.offset=indexes[0].offset() * ArrayUtil.prod(strides);
      return true;
    }
    if (indexes[0] instanceof PointIndex && indexes.length == 1) {
      this.shapes=new long[2];
      this.strides=new long[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=arr.stride(i);
      }
      this.offset=indexes[0].offset() * ArrayUtil.prod(strides);
      return true;
    }
    if (arr.isRowVector()) {
      if (indexes[0] instanceof PointIndex) {
        if (indexes.length > 1 && indexes[1] instanceof IntervalIndex) {
          offset=indexes[1].offset();
          this.shapes=new long[2];
          shapes[0]=1;
          shapes[1]=indexes[1].length();
          this.strides=new long[2];
          strides[0]=0;
          strides[1]=indexes[1].stride();
          this.offsets=new long[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        return false;
      }
    }
 else {
      if (indexes.length > 1 && indexes[1] instanceof PointIndex) {
        if (indexes[0] instanceof IntervalIndex) {
          offset=indexes[0].offset();
          this.shapes=new long[2];
          shapes[1]=1;
          shapes[0]=indexes[1].length();
          this.strides=new long[2];
          strides[1]=0;
          strides[0]=indexes[1].stride();
          this.offsets=new long[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        return false;
      }
    }
  }
  if (numSpecified > 0 && interval < 1 && newAxis < 1 && numAll > 0 && pointIndex < 1 && arr.rank() == 2) {
    shapes=new long[arr.rank()];
    strides=new long[arr.rank()];
    offsets=new long[arr.rank()];
    offset=0;
    boolean allSpecified=true;
    for (int i=0; i < 2; i++) {
      allSpecified=allSpecified && indexes[i] instanceof SpecifiedIndex;
    }
    for (int i=0; i < arr.rank(); i++) {
      if (indexes[i] instanceof SpecifiedIndex) {
        SpecifiedIndex specifiedIndex=(SpecifiedIndex)indexes[i];
        if (specifiedIndex.getIndexes().length >= arr.rank())         return false;
        shapes[i]=indexes[i].length();
        offsets[i]=indexes[i].offset();
        if (!allSpecified || i == 0 && allSpecified)         offset=offsets[i] * arr.stride(i);
        if (indexes[i].length() != 1) {
          strides[i]=arr.stride(i) * specifiedIndex.getIndexes()[i];
        }
 else         strides[i]=1;
      }
 else       if (indexes[i] instanceof NDArrayIndexAll) {
        shapes[i]=arr.size(i);
        strides[i]=arr.tensorAlongDimension(0,i).elementWiseStride();
      }
 else       throw new IllegalArgumentException(""String_Node_Str"" + indexes[i].getClass().getName());
    }
    return true;
  }
  if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex > 0 && numAll > 0) {
    int minDimensions=Math.max(arr.rank() - pointIndex,2);
    long[] shape=new long[minDimensions];
    Arrays.fill(shape,1);
    long[] stride=new long[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    long[] offsets=new long[minDimensions];
    long offset=0;
    int currIndex=0;
    int arrIndex=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[currIndex]=arr.size(arrIndex);
        stride[currIndex]=arr.stride(arrIndex);
        currIndex++;
        arrIndex++;
      }
 else {
        offset+=indexes[i].offset() * arr.stride(i);
        arrIndex++;
      }
    }
    if (arr.isMatrix() && indexes[0] instanceof PointIndex) {
      shape=ArrayUtil.reverseCopy(shape);
      stride=ArrayUtil.reverseCopy(stride);
    }
 else     if (arr.isMatrix() && indexes[0] instanceof PointIndex && indexes[1] instanceof IntervalIndex) {
      shape=new long[2];
      shape[0]=1;
      IntervalIndex idx=(IntervalIndex)indexes[1];
      shape[1]=idx.length();
    }
    this.strides=stride;
    this.shapes=shape;
    this.offsets=offsets;
    this.offset=offset;
    return true;
  }
 else   if (numSpecified < 1 && interval > 0 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2);
    long[] shape=new long[minDimensions];
    Arrays.fill(shape,1);
    long[] stride=new long[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    long[] offsets=new long[minDimensions];
    for (int i=0; i < shape.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[i]=arr.size(i);
        stride[i]=arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
 else       if (indexes[i] instanceof IntervalIndex) {
        shape[i]=indexes[i].length();
        stride[i]=indexes[i].stride() * arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    this.offset=0;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
 else   if (numSpecified < 1 && interval < 1 && newAxis > 0 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2) + newAxis;
    long[] shape=new long[minDimensions];
    Arrays.fill(shape,1);
    long[] stride=new long[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    long[] offsets=new long[minDimensions];
    int prependNewAxes=0;
    boolean allFirst=false;
    int shapeAxis=0;
    int allEncountered=0;
    for (int i=0; i < minDimensions; i++) {
      if (i >= (indexes.length)) {
        shape[i]=arr.size(allEncountered);
        stride[i]=arr.stride(allEncountered);
        allEncountered++;
      }
 else       if (!(indexes[i] instanceof NewAxis) && indexes[i] instanceof NDArrayIndexAll) {
        shape[allEncountered]=arr.size(allEncountered);
        stride[allEncountered]=arr.stride(allEncountered);
        allEncountered++;
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
  return false;
}","/** 
 * @param indexes
 * @return
 */
public boolean tryShortCircuit(INDArrayIndex... indexes){
  int pointIndex=0;
  int interval=0;
  int newAxis=0;
  int numAll=0;
  int numSpecified=0;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i] instanceof PointIndex) {
      pointIndex++;
    }
    if (indexes[i] instanceof SpecifiedIndex)     numSpecified++;
 else     if (indexes[i] instanceof IntervalIndex && !(indexes[i] instanceof NDArrayIndexAll))     interval++;
 else     if (indexes[i] instanceof NewAxis)     newAxis++;
 else     if (indexes[i] instanceof NDArrayIndexAll)     numAll++;
  }
  if (arr.isVector()) {
    if (indexes[0] instanceof NDArrayIndexAll && indexes.length == 1) {
      offset=0;
      this.shapes=LongUtils.toLongs(arr.shape());
      this.strides=LongUtils.toLongs(arr.stride());
      this.offsets=new long[arr.rank()];
      return true;
    }
 else     if (indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll) {
      this.shapes=new long[2];
      this.strides=new long[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=arr.stride(i);
      }
      this.offsets=new long[arr.rank()];
      if (arr.isRowVector())       this.offset=indexes[0].offset() * strides[1];
 else {
        this.offset=indexes[0].offset() * strides[0];
      }
      return true;
    }
    if (indexes[0] instanceof PointIndex && indexes.length == 1) {
      this.shapes=new long[2];
      this.strides=new long[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=arr.stride(i);
      }
      if (arr.isRowVector())       this.offset=indexes[0].offset() * strides[1];
 else {
        this.offset=indexes[0].offset() * strides[0];
      }
      return true;
    }
    if (arr.isRowVector()) {
      if (indexes[0] instanceof PointIndex) {
        if (indexes.length > 1 && indexes[1] instanceof IntervalIndex) {
          offset=indexes[1].offset();
          this.shapes=new long[2];
          shapes[0]=1;
          shapes[1]=indexes[1].length();
          this.strides=new long[2];
          strides[0]=0;
          strides[1]=indexes[1].stride();
          this.offsets=new long[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        return false;
      }
    }
 else {
      if (indexes.length > 1 && indexes[1] instanceof PointIndex) {
        if (indexes[0] instanceof IntervalIndex) {
          offset=indexes[0].offset();
          this.shapes=new long[2];
          shapes[1]=1;
          shapes[0]=indexes[1].length();
          this.strides=new long[2];
          strides[1]=0;
          strides[0]=indexes[1].stride();
          this.offsets=new long[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        return false;
      }
    }
  }
  if (numSpecified > 0 && interval < 1 && newAxis < 1 && numAll > 0 && pointIndex < 1 && arr.rank() == 2) {
    shapes=new long[arr.rank()];
    strides=new long[arr.rank()];
    offsets=new long[arr.rank()];
    offset=0;
    boolean allSpecified=true;
    for (int i=0; i < 2; i++) {
      allSpecified=allSpecified && indexes[i] instanceof SpecifiedIndex;
    }
    for (int i=0; i < arr.rank(); i++) {
      if (indexes[i] instanceof SpecifiedIndex) {
        SpecifiedIndex specifiedIndex=(SpecifiedIndex)indexes[i];
        if (specifiedIndex.getIndexes().length >= arr.rank())         return false;
        shapes[i]=indexes[i].length();
        offsets[i]=indexes[i].offset();
        if (!allSpecified || i == 0 && allSpecified)         offset=offsets[i] * arr.stride(i);
        if (indexes[i].length() != 1) {
          strides[i]=arr.stride(i) * specifiedIndex.getIndexes()[i];
        }
 else         strides[i]=1;
      }
 else       if (indexes[i] instanceof NDArrayIndexAll) {
        shapes[i]=arr.size(i);
        strides[i]=arr.tensorAlongDimension(0,i).elementWiseStride();
      }
 else       throw new IllegalArgumentException(""String_Node_Str"" + indexes[i].getClass().getName());
    }
    return true;
  }
  if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex > 0 && numAll > 0) {
    int minDimensions=Math.max(arr.rank() - pointIndex,2);
    long[] shape=new long[minDimensions];
    Arrays.fill(shape,1);
    long[] stride=new long[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    long[] offsets=new long[minDimensions];
    long offset=0;
    int currIndex=0;
    int arrIndex=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[currIndex]=arr.size(arrIndex);
        stride[currIndex]=arr.stride(arrIndex);
        currIndex++;
        arrIndex++;
      }
 else {
        offset+=indexes[i].offset() * arr.stride(i);
        arrIndex++;
      }
    }
    if (arr.isMatrix() && indexes[0] instanceof PointIndex) {
      shape=ArrayUtil.reverseCopy(shape);
      stride=ArrayUtil.reverseCopy(stride);
    }
 else     if (arr.isMatrix() && indexes[0] instanceof PointIndex && indexes[1] instanceof IntervalIndex) {
      shape=new long[2];
      shape[0]=1;
      IntervalIndex idx=(IntervalIndex)indexes[1];
      shape[1]=idx.length();
    }
    this.strides=stride;
    this.shapes=shape;
    this.offsets=offsets;
    this.offset=offset;
    return true;
  }
 else   if (numSpecified < 1 && interval > 0 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2);
    long[] shape=new long[minDimensions];
    Arrays.fill(shape,1);
    long[] stride=new long[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    long[] offsets=new long[minDimensions];
    for (int i=0; i < shape.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[i]=arr.size(i);
        stride[i]=arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
 else       if (indexes[i] instanceof IntervalIndex) {
        shape[i]=indexes[i].length();
        stride[i]=indexes[i].stride() * arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    this.offset=0;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
 else   if (numSpecified < 1 && interval < 1 && newAxis > 0 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2) + newAxis;
    long[] shape=new long[minDimensions];
    Arrays.fill(shape,1);
    long[] stride=new long[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    long[] offsets=new long[minDimensions];
    int prependNewAxes=0;
    boolean allFirst=false;
    int shapeAxis=0;
    int allEncountered=0;
    for (int i=0; i < minDimensions; i++) {
      if (i >= (indexes.length)) {
        shape[i]=arr.size(allEncountered);
        stride[i]=arr.stride(allEncountered);
        allEncountered++;
      }
 else       if (!(indexes[i] instanceof NewAxis) && indexes[i] instanceof NDArrayIndexAll) {
        shape[allEncountered]=arr.size(allEncountered);
        stride[allEncountered]=arr.stride(allEncountered);
        allEncountered++;
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
  return false;
}"
3150,"private String format(INDArray arr,int offset,boolean summarize){
  int rank=arr.rank();
  if (arr.isScalar() && rank == 0) {
    if (arr instanceof IComplexNDArray) {
      return ((IComplexNDArray)arr).getComplex(0).toString();
    }
    double arrElement=arr.getDouble(0);
    if (!dontOverrideFormat && ((Math.abs(arrElement) < this.minToPrintWithoutSwitching && arrElement != 0) || (Math.abs(arrElement) >= this.maxToPrintWithoutSwitching))) {
      String asString=new DecimalFormat(scientificFormat).format(arrElement);
      asString=asString.replace('E','e');
      return asString;
    }
 else {
      if (arr.getDouble(0) == 0)       return ""String_Node_Str"";
      return decimalFormat.format(arr.getDouble(0));
    }
  }
 else   if (rank == 1) {
    return vectorToString(arr,summarize);
  }
 else   if (arr.isRowVector()) {
    if (offset == 0) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"");
      sb.append(vectorToString(arr,summarize));
      sb.append(""String_Node_Str"");
      return sb.toString();
    }
    return vectorToString(arr,summarize);
  }
 else {
    offset++;
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    for (int i=0; i < arr.slices(); i++) {
      if (summarize && i > 2 && i < arr.slices() - 3) {
        if (i == 3) {
          sb.append(""String_Node_Str"");
          sb.append(newLineSep + ""String_Node_Str"");
          sb.append(StringUtils.repeat(""String_Node_Str"",rank - 2));
          sb.append(StringUtils.repeat(""String_Node_Str"",offset));
        }
      }
 else {
        if (arr.rank() == 3 && arr.slice(i).isRowVector())         sb.append(""String_Node_Str"");
        if (arr.ordering() == 'f' && arr.rank() > 2 && arr.size(arr.rank() - 1) == 1) {
          sb.append(format(arr.dup('c').slice(i),offset,summarize));
        }
 else {
          sb.append(format(arr.slice(i),offset,summarize));
        }
        if (i != arr.slices() - 1) {
          if (arr.rank() == 3 && arr.slice(i).isRowVector())           sb.append(""String_Node_Str"");
          sb.append(newLineSep + ""String_Node_Str"");
          sb.append(StringUtils.repeat(""String_Node_Str"",rank - 2));
          sb.append(StringUtils.repeat(""String_Node_Str"",offset));
        }
 else {
          if (arr.rank() == 3 && arr.slice(i).isRowVector())           sb.append(""String_Node_Str"");
        }
      }
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
}","private String format(INDArray arr,int offset,boolean summarize){
  int rank=arr.rank();
  if (arr.isScalar() && rank == 0) {
    if (arr instanceof IComplexNDArray) {
      return ((IComplexNDArray)arr).getComplex(0).toString();
    }
    double arrElement=arr.getDouble(0);
    if (!dontOverrideFormat && ((Math.abs(arrElement) < this.minToPrintWithoutSwitching && arrElement != 0) || (Math.abs(arrElement) >= this.maxToPrintWithoutSwitching))) {
      String asString=new DecimalFormat(scientificFormat).format(arrElement);
      asString=asString.replace('E','e');
      return asString;
    }
 else {
      if (arr.getDouble(0) == 0)       return ""String_Node_Str"";
      return decimalFormat.format(arr.getDouble(0));
    }
  }
 else   if (rank == 1) {
    return vectorToString(arr,summarize);
  }
 else   if (arr.isRowVector()) {
    if (offset == 0) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"");
      sb.append(vectorToString(arr,summarize));
      sb.append(""String_Node_Str"");
      return sb.toString();
    }
    return vectorToString(arr,summarize);
  }
 else {
    offset++;
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    for (int i=0; i < arr.slices(); i++) {
      if (summarize && i > 2 && i < arr.slices() - 3) {
        if (i == 3) {
          sb.append(""String_Node_Str"");
          sb.append(newLineSep + ""String_Node_Str"");
          sb.append(StringUtils.repeat(""String_Node_Str"",rank - 2));
          sb.append(StringUtils.repeat(""String_Node_Str"",offset));
        }
      }
 else {
        if (arr.rank() == 3 && arr.slice(i).isRowVector())         sb.append(""String_Node_Str"");
        if (arr.ordering() == 'f' && arr.rank() > 2 && arr.size(arr.rank() - 1) == 1) {
          sb.append(format(arr.dup('c').slice(i),offset,summarize));
        }
 else         if (arr.rank() <= 1) {
          sb.append(format(Nd4j.scalar(arr.getDouble(0)),offset,summarize));
        }
 else {
          sb.append(format(arr.slice(i),offset,summarize));
        }
        if (i != arr.slices() - 1) {
          if (arr.rank() == 3 && arr.slice(i).isRowVector())           sb.append(""String_Node_Str"");
          sb.append(newLineSep + ""String_Node_Str"");
          sb.append(StringUtils.repeat(""String_Node_Str"",rank - 2));
          sb.append(StringUtils.repeat(""String_Node_Str"",offset));
        }
 else {
          if (arr.rank() == 3 && arr.slice(i).isRowVector())           sb.append(""String_Node_Str"");
        }
      }
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
}"
3151,"@Test public void testIndexingColVec(){
  int elements=5;
  INDArray rowVector=Nd4j.linspace(1,elements,elements).reshape(1,elements);
  INDArray colVector=rowVector.transpose();
  int j;
  INDArray jj;
  for (int i=0; i < elements; i++) {
    j=i + 1;
    assertEquals(colVector.getRow(i).getInt(0),i + 1);
    assertEquals(rowVector.getColumn(i).getInt(0),i + 1);
    assertEquals(rowVector.get(NDArrayIndex.interval(i,j)).getInt(0),i + 1);
    assertEquals(colVector.get(NDArrayIndex.interval(i,j)).getInt(0),i + 1);
    System.out.println(""String_Node_Str"");
    jj=colVector.get(NDArrayIndex.interval(i,i + 10));
    jj=colVector.get(NDArrayIndex.interval(i,i + 10));
  }
}","@Test public void testIndexingColVec(){
  int elements=5;
  INDArray rowVector=Nd4j.linspace(1,elements,elements).reshape(1,elements);
  INDArray colVector=rowVector.transpose();
  int j;
  INDArray jj;
  for (int i=0; i < elements; i++) {
    j=i + 1;
    assertEquals(i + 1,colVector.getRow(i).getInt(0));
    assertEquals(i + 1,rowVector.getColumn(i).getInt(0));
    assertEquals(i + 1,rowVector.get(NDArrayIndex.interval(i,j)).getInt(0));
    assertEquals(i + 1,colVector.get(NDArrayIndex.interval(i,j)).getInt(0));
    System.out.println(""String_Node_Str"");
    jj=colVector.get(NDArrayIndex.interval(i,i + 10));
    jj=colVector.get(NDArrayIndex.interval(i,i + 10));
  }
}"
3152,"public Gather(SameDiff sameDiff,SDVariable input,int axis,int[] broadcast,boolean inPlace){
  super(null,sameDiff,new SDVariable[]{input},inPlace);
  addIArgument(axis);
  for (  int b : broadcast) {
    addIArgument(b);
  }
}","public Gather(SameDiff sameDiff,SDVariable input,SDVariable indices,int axis,boolean inPlace){
  super(null,sameDiff,new SDVariable[]{input,indices},inPlace);
  addIArgument(axis);
  this.axis=axis;
}"
3153,"@Test public void testGather(){
  SameDiff sameDiff=SameDiff.create();
  INDArray arr=Nd4j.create(new float[]{1,2,3,4},new int[]{2,2});
  SDVariable x=sameDiff.var(""String_Node_Str"",arr);
  SDVariable result1=sameDiff.gather(x,0,new int[]{1,0});
  SDVariable result2=sameDiff.gather(x,1,new int[]{1,0});
  INDArray expected1=Nd4j.create(new float[]{3,4,1,2},new int[]{2,2});
  INDArray expected2=Nd4j.create(new float[]{2,1,4,3},new int[]{2,2});
  assertEquals(expected1,result1.eval());
  assertEquals(expected2,result2.eval());
}","@Test public void testGather(){
  SameDiff sameDiff=SameDiff.create();
  INDArray arr=Nd4j.create(new float[]{1,2,3,4},new int[]{2,2});
  SDVariable x=sameDiff.var(""String_Node_Str"",arr);
  SDVariable result=sameDiff.gather(x,1,new int[]{1,0});
  INDArray expected=Nd4j.create(new float[]{2,1,4,3},new int[]{2,2});
  assertEquals(expected,result.eval());
}"
3154,"/** 
 * This method allows to specify execution model for matrix/blas operations SEQUENTIAL: Issue commands in order Java compiler sees them. ASYNCHRONOUS: Issue commands asynchronously, if that's possible. OPTIMIZED: Not implemented yet. Equals to asynchronous for now. Default value: SEQUENTIAL
 * @param executionModel
 * @return
 */
public Configuration setExecutionModel(@NonNull ExecutionModel executionModel){
  this.executionModel=ExecutionModel.SEQUENTIAL;
  return this;
}","/** 
 * This method allows to specify execution model for matrix/blas operations SEQUENTIAL: Issue commands in order Java compiler sees them. ASYNCHRONOUS: Issue commands asynchronously, if that's possible. OPTIMIZED: Not implemented yet. Equals to asynchronous for now. Default value: SEQUENTIAL
 * @param executionModel
 * @return
 */
public Configuration setExecutionModel(@NonNull ExecutionModel executionModel){
  this.executionModel=executionModel;
  return this;
}"
3155,"@Override public String onnxName(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public String onnxName(){
  throw new NoOpNameFoundException(""String_Node_Str"");
}"
3156,"@Override public String tensorflowName(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public String tensorflowName(){
  throw new NoOpNameFoundException(""String_Node_Str"");
}"
3157,"/** 
 * @param name
 * @param arr
 * @return
 */
public SDVariable var(String name,INDArray arr){
  if (variableMap.containsKey(name) && variableMap.get(name).getArr() != null)   return variableMap.get(name);
  if (name == null || name.length() < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  if (arr == null)   throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
  if (workspace == null)   initWorkspace();
  val arrRef=arr.migrate();
  SDVariable ret=SDVariable.builder().sameDiff(this).shape(arr.shape()).varName(name).weightInitScheme(new NDArraySupplierInitScheme(new NDArraySupplierInitScheme.NDArraySupplier(){
    @Override public INDArray getArr(){
      return arrRef;
    }
  }
)).build();
  associateArrayWithVariable(arr,ret);
  if (ArrayUtil.prod(arr.shape()) == 1)   ret.setScalarValue(arr.getDouble(0));
  addVariable(ret);
  putShapeForVarName(name,arr.shape());
  reverseArrayLookup.put(arr,ret);
  variableMap.put(name,ret);
  return ret;
}","/** 
 * @param name
 * @param arr
 * @return
 */
public SDVariable var(String name,INDArray arr){
  if (variableMap.containsKey(name) && variableMap.get(name).getArr() != null)   return variableMap.get(name);
  if (name == null || name.length() < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  if (arr == null)   throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
  if (workspace == null)   initWorkspace();
  val arrRef=arr.migrate();
  SDVariable ret=SDVariable.builder().sameDiff(this).shape(arr.shape()).varName(name).weightInitScheme(new NDArraySupplierInitScheme(new NDArraySupplierInitScheme.NDArraySupplier(){
    @Override public INDArray getArr(){
      return arrRef;
    }
  }
)).build();
  associateArrayWithVariable(arr,ret);
  if (ArrayUtil.prod(arr.shape()) == 1)   ret.setScalarValue(arr.getDouble(0));
  addVariable(ret);
  if (getShapeForVarName(name) == null)   putShapeForVarName(name,arr.shape());
  reverseArrayLookup.put(arr,ret);
  variableMap.put(name,ret);
  return ret;
}"
3158,"/** 
 * Updates the variable name property on the passed in variable, the reference in samediff, and returns the variable. Note that if null for the new variable is passed in, it will just return the original input variable.
 * @param varToUpdate the variable to update
 * @param newVarName the new variable name
 * @return the passed in variable
 */
public SDVariable updateVariableNameAndReference(SDVariable varToUpdate,String newVarName){
  if (newVarName == null) {
    return varToUpdate;
  }
  if (varToUpdate == null) {
    throw new ND4JIllegalStateException(""String_Node_Str"");
  }
  val oldVarName=varToUpdate.getVarName();
  varToUpdate.setVarName(newVarName);
  updateVariableName(oldVarName,newVarName);
  return varToUpdate;
}","/** 
 * Updates the variable name property on the passed in variable, the reference in samediff, and returns the variable. Note that if null for the new variable is passed in, it will just return the original input variable.
 * @param varToUpdate the variable to update
 * @param newVarName the new variable name
 * @return the passed in variable
 */
public SDVariable updateVariableNameAndReference(SDVariable varToUpdate,String newVarName){
  if (newVarName == null || varToUpdate.getVarName().equals(newVarName)) {
    return varToUpdate;
  }
  if (varToUpdate == null) {
    throw new ND4JIllegalStateException(""String_Node_Str"");
  }
  val oldVarName=varToUpdate.getVarName();
  varToUpdate.setVarName(newVarName);
  updateVariableName(oldVarName,newVarName);
  return varToUpdate;
}"
3159,"/** 
 * Adds incoming args to the graph
 * @param variables
 * @param function
 */
public void addArgsFor(SDVariable[] variables,DifferentialFunction function){
  String[] varNames=new String[variables.length];
  for (int i=0; i < varNames.length; i++)   varNames[i]=variables[i].getVarName();
  addArgsFor(varNames,function);
}","/** 
 * Adds incoming args to the graph
 * @param variables
 * @param function
 */
public void addArgsFor(SDVariable[] variables,DifferentialFunction function){
  String[] varNames=new String[variables.length];
  for (int i=0; i < varNames.length; i++) {
    if (variables[i] == null)     throw new ND4JIllegalStateException(""String_Node_Str"" + i);
    varNames[i]=variables[i].getVarName();
  }
  addArgsFor(varNames,function);
}"
3160,"/** 
 * Get the input variables given a set of ids from   {@link #getInputVariablesForFunction(DifferentialFunction)}
 * @param function the function reference to get the id for
 * @return the output variables for the given function
 */
public SDVariable[] getInputVariablesForFunction(DifferentialFunction function){
  val inputs=getInputsForFunction(function);
  if (inputs == null) {
    throw new ND4JIllegalStateException(""String_Node_Str"" + function);
  }
  val vars=new SDVariable[inputs.length];
  for (int i=0; i < inputs.length; i++) {
    vars[i]=getVariable(inputs[i]);
  }
  return vars;
}","/** 
 * Get the input variables given a set of ids from   {@link #getInputVariablesForFunction(DifferentialFunction)}
 * @param function the function reference to get the id for
 * @return the output variables for the given function
 */
public SDVariable[] getInputVariablesForFunction(DifferentialFunction function){
  val inputs=getInputsForFunction(function);
  if (inputs == null) {
    throw new ND4JIllegalStateException(""String_Node_Str"" + function);
  }
  val vars=new SDVariable[inputs.length];
  for (int i=0; i < inputs.length; i++) {
    vars[i]=getVariable(inputs[i]);
    if (vars[i] == null) {
      throw new ND4JIllegalStateException(""String_Node_Str"" + i);
    }
  }
  return vars;
}"
3161,"@Override public List<int[]> calculateOutputShape(){
  val args=args();
  if (args.length < 2) {
    return Arrays.asList(args[0].getShape());
  }
  val firstArgShape=args[0].getShape();
  val secondArgShape=args[1].getShape();
  if (args[0].getShape() == null) {
    return Collections.emptyList();
  }
  if (args[1].getShape() == null) {
    return Collections.emptyList();
  }
  val firstLength=ArrayUtil.prod(firstArgShape);
  val secondLength=ArrayUtil.prod(secondArgShape);
  if (firstLength > secondLength)   return Arrays.asList(args[0].getShape());
 else   return Arrays.asList(args[1].getShape());
}","@Override public List<int[]> calculateOutputShape(){
  val args=args();
  if (args.length < 2) {
    if (args[0] == null || args[0].getShape() == null) {
      return Collections.emptyList();
    }
    return Arrays.asList(args[0].getShape());
  }
  val firstArgShape=args[0].getShape();
  val secondArgShape=args[1].getShape();
  if (args[0] == null || args[0].getShape() == null) {
    return Collections.emptyList();
  }
  if (args[1] == null || args[1].getShape() == null) {
    return Collections.emptyList();
  }
  val firstLength=ArrayUtil.prod(firstArgShape);
  val secondLength=ArrayUtil.prod(secondArgShape);
  if (firstLength > secondLength)   return Arrays.asList(args[0].getShape());
 else   return Arrays.asList(args[1].getShape());
}"
3162,"/** 
 * This method executes given CustomOp PLEASE NOTE: You're responsible for input/output validation
 * @param op
 */
public void exec(@NonNull CustomOp op){
  if (op.numOutputArguments() == 0 && !op.isInplaceCall())   throw new ND4JIllegalStateException(""String_Node_Str"");
  val hash=op.opHash();
  val inputShapes=new PointerPointer<>(op.numInputArguments());
  val inputBuffers=new PointerPointer<>(op.numInputArguments());
  int cnt=0;
  val inputArgs=op.inputArguments();
  for (  val in : inputArgs) {
    inputBuffers.put(cnt,in.data().addressPointer());
    inputShapes.put(cnt++,in.shapeInfoDataBuffer().addressPointer());
  }
  val outputArgs=op.outputArguments();
  for (int i=0; i < outputArgs.length; i++) {
    if (outputArgs[i] == null)     throw new ND4JIllegalStateException(""String_Node_Str"");
  }
  val outputShapes=new PointerPointer<>(op.numOutputArguments());
  val outputBuffers=new PointerPointer<>(op.numOutputArguments());
  cnt=0;
  for (  val out : outputArgs) {
    outputBuffers.put(cnt,out.data().addressPointer());
    outputShapes.put(cnt++,out.shapeInfoDataBuffer().addressPointer());
  }
  val iArgs=op.numIArguments() > 0 ? new IntPointer(op.numIArguments()) : null;
  cnt=0;
  val iArgs1=op.iArgs();
  for (  val i : iArgs1)   iArgs.put(cnt++,i);
  if (Nd4j.dataType() == DataBuffer.Type.FLOAT) {
    val tArgs=op.numTArguments() > 0 ? new FloatPointer(op.numTArguments()) : null;
    val tArgs1=op.tArgs();
    cnt=0;
    for (    val t : tArgs1)     tArgs.put(cnt++,(float)t);
    val status=OpStatus.byNumber(loop.execCustomOpFloat(null,hash,inputBuffers,inputShapes,op.numInputArguments(),outputBuffers,outputShapes,op.numOutputArguments(),tArgs,op.numTArguments(),iArgs,op.numIArguments(),op.isInplaceCall()));
    if (status != OpStatus.ND4J_STATUS_OK)     throw new ND4JIllegalStateException(""String_Node_Str"" + status);
  }
 else   if (Nd4j.dataType() == DataBuffer.Type.DOUBLE) {
    val tArgs=op.numTArguments() > 0 ? new DoublePointer(op.numTArguments()) : null;
    val tArgs1=op.tArgs();
    cnt=0;
    for (    val t : tArgs1)     tArgs.put(cnt++,t);
    OpStatus status=OpStatus.ND4J_STATUS_OK;
    try {
      status=OpStatus.byNumber(loop.execCustomOpDouble(null,hash,inputBuffers,inputShapes,op.numInputArguments(),outputBuffers,outputShapes,op.numOutputArguments(),tArgs,op.numTArguments(),iArgs,op.numIArguments(),op.isInplaceCall()));
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
 else   if (Nd4j.dataType() == DataBuffer.Type.HALF) {
    val tArgs=op.numTArguments() > 0 ? new ShortPointer(op.numTArguments()) : null;
    cnt=0;
    val tArgs1=op.tArgs();
    for (    val t : tArgs1)     tArgs.put(cnt++,ArrayUtil.toHalf(t));
    val status=OpStatus.byNumber(loop.execCustomOpHalf(null,hash,inputBuffers,inputShapes,op.numInputArguments(),outputBuffers,outputShapes,op.numOutputArguments(),tArgs,op.numTArguments(),iArgs,op.numIArguments(),op.isInplaceCall()));
    if (status != OpStatus.ND4J_STATUS_OK)     throw new ND4JIllegalStateException(""String_Node_Str"" + status);
  }
}","/** 
 * This method executes given CustomOp PLEASE NOTE: You're responsible for input/output validation
 * @param op
 */
public void exec(@NonNull CustomOp op){
  if (op.numOutputArguments() == 0 && !op.isInplaceCall())   throw new ND4JIllegalStateException(""String_Node_Str"");
  val hash=op.opHash();
  val inputShapes=new PointerPointer<>(op.numInputArguments());
  val inputBuffers=new PointerPointer<>(op.numInputArguments());
  int cnt=0;
  val inputArgs=op.inputArguments();
  for (  val in : inputArgs) {
    inputBuffers.put(cnt,in.data().addressPointer());
    inputShapes.put(cnt++,in.shapeInfoDataBuffer().addressPointer());
  }
  val outputArgs=op.outputArguments();
  for (int i=0; i < outputArgs.length; i++) {
    if (outputArgs[i] == null)     throw new ND4JIllegalStateException(""String_Node_Str"");
  }
  val outputShapes=new PointerPointer<>(op.numOutputArguments());
  val outputBuffers=new PointerPointer<>(op.numOutputArguments());
  cnt=0;
  for (  val out : outputArgs) {
    outputBuffers.put(cnt,out.data().addressPointer());
    outputShapes.put(cnt++,out.shapeInfoDataBuffer().addressPointer());
  }
  val iArgs=op.numIArguments() > 0 ? new IntPointer(op.numIArguments()) : null;
  cnt=0;
  val iArgs1=op.iArgs();
  for (  val i : iArgs1)   iArgs.put(cnt++,i);
  if (Nd4j.dataType() == DataBuffer.Type.FLOAT) {
    val tArgs=op.numTArguments() > 0 ? new FloatPointer(op.numTArguments()) : null;
    val tArgs1=op.tArgs();
    cnt=0;
    for (    val t : tArgs1)     tArgs.put(cnt++,(float)t);
    val status=OpStatus.byNumber(loop.execCustomOpFloat(null,hash,inputBuffers,inputShapes,op.numInputArguments(),outputBuffers,outputShapes,op.numOutputArguments(),tArgs,op.numTArguments(),iArgs,op.numIArguments(),op.isInplaceCall()));
    if (status != OpStatus.ND4J_STATUS_OK)     throw new ND4JIllegalStateException(""String_Node_Str"" + status);
  }
 else   if (Nd4j.dataType() == DataBuffer.Type.DOUBLE) {
    val tArgs=op.numTArguments() > 0 ? new DoublePointer(op.numTArguments()) : null;
    val tArgs1=op.tArgs();
    cnt=0;
    for (    val t : tArgs1)     tArgs.put(cnt++,t);
    OpStatus status=OpStatus.ND4J_STATUS_OK;
    try {
      status=OpStatus.byNumber(loop.execCustomOpDouble(null,hash,inputBuffers,inputShapes,op.numInputArguments(),outputBuffers,outputShapes,op.numOutputArguments(),tArgs,op.numTArguments(),iArgs,op.numIArguments(),op.isInplaceCall()));
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"");
      throw e;
    }
  }
 else   if (Nd4j.dataType() == DataBuffer.Type.HALF) {
    val tArgs=op.numTArguments() > 0 ? new ShortPointer(op.numTArguments()) : null;
    cnt=0;
    val tArgs1=op.tArgs();
    for (    val t : tArgs1)     tArgs.put(cnt++,ArrayUtil.toHalf(t));
    val status=OpStatus.byNumber(loop.execCustomOpHalf(null,hash,inputBuffers,inputShapes,op.numInputArguments(),outputBuffers,outputShapes,op.numOutputArguments(),tArgs,op.numTArguments(),iArgs,op.numIArguments(),op.isInplaceCall()));
    if (status != OpStatus.ND4J_STATUS_OK)     throw new ND4JIllegalStateException(""String_Node_Str"" + status);
  }
}"
3163,"@Test public void testMulGradient(){
  INDArray arr1=Nd4j.linspace(1,4,4).reshape(2,2);
  INDArray arr2=Nd4j.linspace(1,4,4).reshape(2,2);
  INDArray gradAssertion=Nd4j.ones(arr1.shape());
  INDArray scalar=Nd4j.scalar(1.0);
  INDArray aGradAssertion=Nd4j.create(new double[][]{{1,4},{9,16}});
  INDArray cGradAssertion=Nd4j.create(new double[][]{{1,2},{3,4}});
  INDArray wGradAssertion=Nd4j.create(new double[][]{{2,8},{18,32}});
  INDArray dGradAssertion=Nd4j.ones(2,2);
  SameDiff sameDiff=SameDiff.create();
  SDVariable sdVariable=sameDiff.var(""String_Node_Str"",arr1);
  SDVariable sdVariable1=sameDiff.var(""String_Node_Str"",arr2);
  SDVariable varMulPre=sdVariable.mul(""String_Node_Str"",sdVariable1);
  SDVariable varMul=varMulPre.mul(""String_Node_Str"",sdVariable1);
  SDVariable sum=sameDiff.sum(""String_Node_Str"",varMul,Integer.MAX_VALUE);
  sameDiff.execBackwards();
  SDVariable finalResult=sameDiff.grad(sum.getVarName());
  SDVariable cGrad=sameDiff.grad(varMulPre.getVarName());
  SDVariable mulGradResult=sameDiff.grad(varMul.getVarName());
  SDVariable aGrad=sameDiff.grad(sdVariable.getVarName());
  SDVariable wGrad=sameDiff.grad(sdVariable1.getVarName());
  SDVariable dGrad=sameDiff.grad(varMul.getVarName());
  INDArray scalarGradTest=finalResult.getArr();
  assertEquals(scalar,scalarGradTest);
  INDArray gradTest=mulGradResult.getArr();
  assertEquals(gradAssertion,gradTest);
  INDArray aGradTest=aGrad.getArr();
  assertEquals(aGradAssertion,aGradTest);
  INDArray cGradTest=cGrad.getArr();
  assertEquals(cGradAssertion,cGradTest);
  INDArray wGradTest=wGrad.getArr();
  assertEquals(wGradAssertion,wGradTest);
  INDArray dGradTest=dGrad.getArr();
  assertEquals(dGradAssertion,dGradTest);
}","@Test public void testMulGradient(){
  INDArray arr1=Nd4j.linspace(1,4,4).reshape(2,2);
  INDArray arr2=Nd4j.linspace(1,4,4).reshape(2,2);
  INDArray gradAssertion=Nd4j.ones(arr1.shape());
  INDArray scalar=Nd4j.scalar(1.0);
  INDArray aGradAssertion=Nd4j.create(new double[][]{{1,4},{9,16}});
  INDArray cGradAssertion=Nd4j.create(new double[][]{{1,2},{3,4}});
  INDArray wGradAssertion=Nd4j.create(new double[][]{{2,8},{18,32}});
  INDArray dGradAssertion=Nd4j.ones(2,2);
  SameDiff sameDiff=SameDiff.create();
  SDVariable sdVariable=sameDiff.var(""String_Node_Str"",arr1);
  SDVariable sdVariable1=sameDiff.var(""String_Node_Str"",arr2);
  SDVariable varMulPre=sdVariable.mul(""String_Node_Str"",sdVariable1);
  SDVariable varMul=varMulPre.mul(""String_Node_Str"",sdVariable1);
  SDVariable sum=sameDiff.sum(""String_Node_Str"",varMul,Integer.MAX_VALUE);
  Pair<Map<SDVariable,Op>,List<Op>> mapListPair=sameDiff.execBackwards();
  SDVariable finalResult=sameDiff.grad(sum.getVarName());
  SDVariable cGrad=sameDiff.grad(varMulPre.getVarName());
  SDVariable mulGradResult=sameDiff.grad(varMul.getVarName());
  SDVariable aGrad=sameDiff.grad(sdVariable.getVarName());
  SDVariable wGrad=sameDiff.grad(sdVariable1.getVarName());
  SDVariable dGrad=sameDiff.grad(varMul.getVarName());
  INDArray scalarGradTest=finalResult.getArr();
  assertEquals(scalar,scalarGradTest);
  INDArray gradTest=mulGradResult.getArr();
  assertEquals(gradAssertion,gradTest);
  INDArray aGradTest=aGrad.getArr();
  assertEquals(aGradAssertion,aGradTest);
  INDArray cGradTest=cGrad.getArr();
  assertEquals(cGradAssertion,cGradTest);
  INDArray wGradTest=wGrad.getArr();
  assertEquals(wGradAssertion,wGradTest);
  INDArray dGradTest=dGrad.getArr();
  assertEquals(dGradAssertion,dGradTest);
}"
3164,"@Override public List<DifferentialFunction<X>> diff(List<DifferentialFunction<X>> i_v){
  validateDifferentialFunctionsameDiff(i_v);
  return new Zero<>(sameDiff,shape);
}","@Override public List<DifferentialFunction<X>> diff(List<DifferentialFunction<X>> i_v){
  validateDifferentialFunctionsameDiff(i_v);
  return Arrays.asList(new Zero<>(sameDiff,shape));
}"
3165,"@Override public DifferentialFunction<X> muli(double i_n){
  PolynomialTerm<X> ret=new PolynomialTerm<>(sameDiff,i_n,this,1,true);
  return ret;
}","@Override public DifferentialFunction<X> muli(double i_n){
  throw new UnsupportedOperationException();
}"
3166,"@Override public DifferentialFunction<X> powi(int i_n){
  PolynomialTerm<X> ret=new PolynomialTerm<>(sameDiff,1L,this,i_n,true);
  return ret;
}","@Override public DifferentialFunction<X> powi(int i_n){
  throw new UnsupportedOperationException();
}"
3167,"@Override public DifferentialFunction<X> inversei(){
  DifferentialFunction<X> ret=new Inverse<>(sameDiff,this,true);
  return ret;
}","@Override public DifferentialFunction<X> inversei(){
  throw new UnsupportedOperationException();
}"
3168,"@Override public DifferentialFunction<X> inverse(){
  DifferentialFunction<X> ret=new Inverse<>(sameDiff,this.mul(1.0));
  return ret;
}","@Override public DifferentialFunction<X> inverse(){
  throw new UnsupportedOperationException();
}"
3169,"@Override public List<DifferentialFunction<X>> diff(List<DifferentialFunction<X>> i_v){
  return (arg().diff(i_v)).negate();
}","@Override public List<DifferentialFunction<X>> diff(List<DifferentialFunction<X>> i_v){
  return Arrays.asList(arg().diff(i_v).get(0).negate());
}"
3170,"@Override public List<DifferentialFunction<X>> diff(List<DifferentialFunction<X>> i_v){
  return (DifferentialFunction<X>)(i_v == this ? sameDiff.getFunctionFactory().one(i_v.getResultShape()) : sameDiff.getFunctionFactory().zero(i_v.getResultShape()));
}","@Override public List<DifferentialFunction<X>> diff(List<DifferentialFunction<X>> i_v){
  List<DifferentialFunction<X>> ret=new ArrayList<>();
  if (i_v == this)   ret.add((DifferentialFunction<X>)sameDiff.getFunctionFactory().one(i_v.get(0).getResultShape()));
 else   ret.add((DifferentialFunction<X>)sameDiff.getFunctionFactory().zero(i_v.get(0).getResultShape()));
  return ret;
}"
3171,"@Override public List<DifferentialFunction<ArrayField>> diff(List<DifferentialFunction<ArrayField>> i_v){
  return sameDiff.getFunctionFactory().zero(getResultShape());
}","@Override public List<DifferentialFunction<ArrayField>> diff(List<DifferentialFunction<ArrayField>> i_v){
  return Arrays.asList(f().zero(getResultShape()));
}"
3172,"@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().hardTanhDerivative(larg().getValue(true),rarg().getValue(true));
}","@Override public ArrayField doGetValue(){
  return a().hardTanhDerivative(larg().getValue(true),rarg().getValue(true));
}"
3173,"@Override public List<DifferentialFunction<ArrayField>> diff(List<DifferentialFunction<ArrayField>> i_v){
  return sameDiff.getFunctionFactory().one(getResultShape()).mul(arg().diff(i_v));
}","@Override public List<DifferentialFunction<ArrayField>> diff(List<DifferentialFunction<ArrayField>> i_v){
  return Arrays.asList(f().one(getResultShape()));
}"
3174,X tanhDerivative(X value);,"X tanhDerivative(X value,X wrt);"
3175,"/** 
 * Leaky relu with an alpha of 0.01
 * @param value the value to transform
 * @return
 */
X leakyReluDerivative(X value);","/** 
 * Leaky relu with an alpha of 0.01
 * @param value the value to transform
 * @param wrt
 * @return
 */
X leakyReluDerivative(X value,X wrt);"
3176,X seluDerivative(X value);,"X seluDerivative(X value,X wrt);"
3177,"@Override public ArrayField tanhDerivative(ArrayField x){
  return x.tanhDerivative();
}","@Override public ArrayField tanhDerivative(ArrayField x,ArrayField wrt){
  return x.tanhDerivative(wrt);
}"
3178,"/** 
 * Leaky relu with an alpha of 0.01
 * @param value the value to transform
 * @return
 */
@Override public ArrayField leakyReluDerivative(ArrayField value){
}","/** 
 * Leaky relu with an alpha of 0.01
 * @param value the value to transform
 * @param wrt
 * @return
 */
@Override public ArrayField leakyReluDerivative(ArrayField value,ArrayField wrt){
  return value.leakyReluDerivative(wrt,0.001);
}"
3179,"@Override public ArrayField seluDerivative(ArrayField value){
  return value.seluDerivative();
}","@Override public ArrayField seluDerivative(ArrayField value,ArrayField wrt){
  return value.seluDerivative(wrt);
}"
3180,"@Override public ArrayField tanhDerivative(){
  return addTransformOp(new TanhDerivative().name());
}","@Override public ArrayField tanhDerivative(ArrayField wrt){
  return addTransformOp(new TanhDerivative().name());
}"
3181,"@Override public ArrayField seluDerivative(){
  return addTransformOp(new SELUDerivative().name());
}","@Override public ArrayField seluDerivative(ArrayField wrt){
  return addTransformOp(new SELUDerivative().name());
}"
3182,X seluDerivative();,X seluDerivative(X wrt);
3183,X tanhDerivative();,X tanhDerivative(X wrt);
3184,"public AbstractBinaryFunction(SameDiff sameDiff){
  this.sameDiff=sameDiff;
}","public AbstractBinaryFunction(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v1,DifferentialFunction<ArrayField> i_v2,OpState.OpType opType,Object[] extraArgs){
  super(sameDiff,extraArgs);
  if (i_v1 != null && i_v2 != null) {
    m_x1=i_v1;
    m_x2=i_v2;
    validateDifferentialFunctionsameDiff(i_v1);
    validateDifferentialFunctionsameDiff(i_v2);
    this.sameDiff=sameDiff;
    addEdges(sameDiff,i_v1,i_v2,functionName(),opType,i_v1.getResultShape(),null);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}"
3185,"@Override public DifferentialFunction<X> tanhDerivative(){
  return null;
}","@Override public DifferentialFunction<X> tanhDerivative(DifferentialFunction<X> wrt){
  return null;
}"
3186,"@Override public DifferentialFunction<X> seluDerivative(){
  return null;
}","@Override public DifferentialFunction<X> seluDerivative(DifferentialFunction<X> wrt){
  return null;
}"
3187,"@Override public DifferentialFunction<ArrayField> leakyReluDerivative(DifferentialFunction<ArrayField> iX,double cutoff){
  return new LeakyReluDerivative(sameDiff,iX,cutoff);
}","@Override public DifferentialFunction<ArrayField> leakyReluDerivative(DifferentialFunction<ArrayField> iX,DifferentialFunction<ArrayField> iY,double cutoff){
  return new LeakyReluDerivative(sameDiff,iX,iY,cutoff);
}"
3188,"DifferentialFunction<X> leakyReluDerivative(DifferentialFunction<X> iX,double cutoff);","DifferentialFunction<X> leakyReluDerivative(DifferentialFunction<X> iX,DifferentialFunction<X> iY,double cutoff);"
3189,"public EluDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,Object[] extraArgs){
  super(sameDiff,i_v,extraArgs);
}","public EluDerivative(SameDiff sameDiff){
  super(sameDiff);
}"
3190,"@Override public ArrayField doGetValue(){
}","@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().eluDerivative(larg().getValue(true),rarg().getValue(true));
}"
3191,"@Override public ArrayField doGetValue(){
}","@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().hardTanhDerivative(larg().getValue(true),rarg().getValue(true));
}"
3192,"public HardTanhDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,Object[] extraArgs){
  super(sameDiff,i_v,extraArgs);
}","public HardTanhDerivative(SameDiff sameDiff){
  super(sameDiff);
}"
3193,"@Override public ArrayField doGetValue(){
}","@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().leakyReluDerivative(larg().getValue(true),rarg().getValue(true),cutoff);
}"
3194,"public LeakyReluDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,double cutoff){
  super(sameDiff,i_v,new Object[]{cutoff});
  this.cutoff=cutoff;
}","public LeakyReluDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,DifferentialFunction<ArrayField> i_v2,double cutoff){
  super(sameDiff,i_v,i_v2,OpState.OpType.GRADIENT,new Object[]{cutoff});
  this.cutoff=cutoff;
}"
3195,"public SELUDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,Object[] extraArgs){
  super(sameDiff,i_v,extraArgs);
}","public SELUDerivative(SameDiff sameDiff){
  super(sameDiff);
}"
3196,"@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().seluDerivative(arg().getValue(true));
}","@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().seluDerivative(larg().getValue(true),rarg().getValue(true));
}"
3197,"@Override public ArrayField doGetValue(){
}","@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().softsignDeriviative(larg().getValue(true),rarg().getValue(true));
}"
3198,"public SoftSignDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,Object[] extraArgs){
  super(sameDiff,i_v,extraArgs);
}","public SoftSignDerivative(SameDiff sameDiff){
  super(sameDiff);
}"
3199,"public TanhDerivative(SameDiff sameDiff,DifferentialFunction<ArrayField> i_v,Object[] extraArgs){
  super(sameDiff,i_v,extraArgs);
}","public TanhDerivative(SameDiff sameDiff){
  super(sameDiff);
}"
3200,"@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().tanhDerivative(arg().getValue(true));
}","@Override public ArrayField doGetValue(){
  return sameDiff.getArrayFactory().tanhDerivative(larg().getValue(true),rarg().getValue(true));
}"
3201,"@Override public DifferentialFunction<ArrayField> diff(DifferentialFunction<ArrayField> i_v){
  return sameDiff.getFunctionFactory().leakyReluDerivative(arg(),cutoff).mul(arg().diff(i_v));
}","@Override public DifferentialFunction<ArrayField> diff(DifferentialFunction<ArrayField> i_v){
  return sameDiff.getFunctionFactory().leakyReluDerivative(arg(),i_v,cutoff);
}"
3202,"@Override public DifferentialFunction<ArrayField> diff(DifferentialFunction<ArrayField> i_v){
  return softsignDerivative().mul(arg().diff(i_v));
}","@Override public DifferentialFunction<ArrayField> diff(DifferentialFunction<ArrayField> i_v){
  return softsignDerivative(i_v);
}"
3203,"/** 
 * Compute the sparse offsets of the view we are getting, for each dimension according to the original ndarray
 * @param offset the offset of the view
 * @return an int array containing the sparse offsets
 */
private int[] createSparseOffsets(int offset,int[] toremove){
  int underlyingRank=(int)sparseOffsets.length();
  int[] newOffsets=new int[rank()];
  List<Integer> shapeList=Ints.asList(shape());
  int penultimate=rank() - 1;
  for (int i=0; i < penultimate; i++) {
    int prod=ArrayUtil.prod(shapeList.subList(i,penultimate));
    newOffsets[i]=offset / prod;
    offset=offset - newOffsets[i] * prod;
  }
  newOffsets[rank() - 1]=offset % underlyingShape.getInt(rank() - 1);
  int[] finalOffsets=new int[underlyingRank];
  int dimNotFixed=0;
  for (int dim=0; dim < underlyingRank; dim++) {
    if (fixed.getInt(dim) == 1) {
      finalOffsets[dim]=sparseOffsets.getInt(dim);
    }
 else {
      finalOffsets[dim]=newOffsets[dimNotFixed] + sparseOffsets.getInt(dim);
      dimNotFixed++;
    }
  }
  return finalOffsets;
}","/** 
 * Compute the sparse offsets of the view we are getting, for each dimension according to the original ndarray
 * @param offset the offset of the view
 * @return an int array containing the sparse offsets
 */
private int[] createSparseOffsets(int offset){
  int underlyingRank=(int)sparseOffsets.length();
  int[] newOffsets=new int[rank()];
  List<Integer> shapeList=Ints.asList(shape());
  int penultimate=rank() - 1;
  for (int i=0; i < penultimate; i++) {
    int prod=ArrayUtil.prod(shapeList.subList(i + 1,rank()));
    newOffsets[i]=offset / prod;
    offset=offset - newOffsets[i] * prod;
  }
  newOffsets[rank() - 1]=offset % shape()[rank() - 1];
  int[] finalOffsets=new int[underlyingRank];
  int dimNotFixed=0;
  for (int dim=0; dim < underlyingRank; dim++) {
    if (fixed.getInt(dim) == 1) {
      finalOffsets[dim]=sparseOffsets.getInt(dim);
    }
 else {
      finalOffsets[dim]=newOffsets[dimNotFixed] + sparseOffsets.getInt(dim);
      dimNotFixed++;
    }
  }
  return finalOffsets;
}"
3204,"public void setFixed(int[] arr){
  if (isScalar() || isRowVector() || isColumnVector()) {
    this.fixed=Nd4j.createBuffer(new int[]{0,0});
  }
 else {
    this.fixed=Nd4j.createBuffer(arr);
  }
}","public void setFixed(int[] arr){
  if (!isView() && (isScalar() || isRowVector() || isColumnVector())) {
    this.fixed=Nd4j.createBuffer(new int[]{0,0});
  }
 else {
    this.fixed=Nd4j.createBuffer(arr);
  }
}"
3205,"public BaseSparseNDArrayCOO(DataBuffer values,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,int[] underlyingShape,char ordering){
  this.values=Nd4j.createBuffer(values,0,values.length());
  this.indices=indices;
  this.sparseOffsets=Nd4j.createBuffer(sparseOffsets);
  setShapeInformation(Nd4j.getShapeInfoProvider().createShapeInformation(shape,ordering));
  this.underlyingShape=Nd4j.createBuffer(underlyingShape);
  init(shape);
  setFixed(fixed);
  this.length=countNNZ();
}","public BaseSparseNDArrayCOO(DataBuffer values,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,char ordering){
  this.values=Nd4j.createBuffer(values,0,values.length());
  this.indices=indices;
  this.sparseOffsets=Nd4j.createBuffer(sparseOffsets);
  setShapeInformation(Nd4j.getShapeInfoProvider().createShapeInformation(shape,ordering));
  init(shape);
  setFixed(fixed);
  this.length=countNNZ();
}"
3206,"public DataBuffer getIndices(){
  if (isScalar()) {
    return Nd4j.createBuffer(new int[]{0,0});
  }
  List<Integer> ind=new ArrayList<>();
  for (int i=0; i < values.length(); i++) {
    boolean isIn=true;
    int idxNotFixed=0;
    int[] idx=getIndicesOf(i).asInt();
    for (int dim=0; dim < idx.length; dim++) {
      if (fixed.getInt(dim) == 1) {
        if (sparseOffsets.getInt(dim) != idx[dim]) {
          isIn=false;
          break;
        }
      }
 else {
        int lowerBound=sparseOffsets.getInt(dim);
        int upperBound=sparseOffsets.getInt(dim) + shape()[idxNotFixed];
        if (!(idx[dim] >= lowerBound && idx[dim] < upperBound)) {
          isIn=false;
          break;
        }
        idxNotFixed++;
      }
    }
    if (isIn) {
      for (int dim=0; dim < idx.length; dim++) {
        if (fixed.getInt(dim) == 0) {
          ind.add(idx[dim] - sparseOffsets.getInt(dim));
        }
      }
    }
  }
  return Nd4j.createBuffer(Ints.toArray(ind));
}","public DataBuffer getIndices(){
  if (isScalar()) {
    return Nd4j.createBuffer(new int[]{0,0});
  }
  List<Integer> ind=new ArrayList<>();
  for (int i=0; i < values.length(); i++) {
    boolean isIn=true;
    int idxNotFixed=0;
    int[] idx=getIndicesOf(i).asInt();
    for (int dim=0; dim < idx.length; dim++) {
      if (fixed.getInt(dim) == 1) {
        if (sparseOffsets.getInt(dim) != idx[dim]) {
          isIn=false;
          break;
        }
      }
 else {
        int lowerBound=sparseOffsets.getInt(dim);
        int upperBound=sparseOffsets.getInt(dim) + shape()[idxNotFixed];
        if (!(idx[dim] >= lowerBound && idx[dim] < upperBound)) {
          isIn=false;
          break;
        }
        idxNotFixed++;
      }
    }
    if (isIn) {
      int notFixedDim=0;
      for (int dim=0; dim < idx.length; dim++) {
        if (fixed.getInt(dim) == 0) {
          if (shape()[notFixedDim] == 1) {
            ind.add(0);
            notFixedDim++;
          }
 else {
            ind.add(idx[dim] - sparseOffsets.getInt(dim));
          }
        }
      }
    }
  }
  return Nd4j.createBuffer(Ints.toArray(ind));
}"
3207,"private INDArray create(DataBuffer values,DataBuffer indices,int[] newShape,int[] sparseOffsets,int[] fixed,char newOrder){
  return Nd4j.createSparseCOO(values,indices,sparseOffsets,fixed,newShape,shape(),newOrder);
}","private INDArray create(DataBuffer values,DataBuffer indices,int[] newShape,int[] sparseOffsets,int[] fixed,char newOrder){
  return Nd4j.createSparseCOO(values,indices,sparseOffsets,fixed,newShape,newOrder);
}"
3208,"public int underlyingRank(){
  return (int)underlyingShape.length();
}","public int underlyingRank(){
  return (int)sparseOffsets.length();
}"
3209,"INDArray createSparseCOO(DataBuffer data,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,int[] underlyingShape,char ordering);","INDArray createSparseCOO(DataBuffer data,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,char ordering);"
3210,"/** 
 * @param values a DataBuffer with the sparse non-null values
 * @param indices a DataBuffer with the indexes of the values
 * @param sparseOffsets the sparse
 * @param fixed
 * @param shape
 * @return ordering
 * @return a INDArray
 */
public static INDArray createSparseCOO(DataBuffer values,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,int[] underlyingShape,char ordering){
  INDArray matrix=SPARSE_INSTANCE.createSparseCOO(values,indices,sparseOffsets,fixed,shape,underlyingShape,ordering);
  return matrix;
}","/** 
 * @param values a DataBuffer with the sparse non-null values
 * @param indices a DataBuffer with the indexes of the values
 * @param sparseOffsets the sparse
 * @param fixed
 * @param shape
 * @return ordering
 * @return a INDArray
 */
public static INDArray createSparseCOO(DataBuffer values,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,char ordering){
  INDArray matrix=SPARSE_INSTANCE.createSparseCOO(values,indices,sparseOffsets,fixed,shape,ordering);
  return matrix;
}"
3211,"@Override public INDArray createSparseCOO(DataBuffer data,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,int[] underlyingShape,char ordering){
  throw new UnsupportedOperationException();
}","@Override public INDArray createSparseCOO(DataBuffer data,DataBuffer indices,int[] sparseOffsets,int[] fixed,int[] shape,char ordering){
  throw new UnsupportedOperationException();
}"
3212,"@Override public INDArray createSparseCOO(DataBuffer data,DataBuffer indices,int[] sparseOffset,int[] fixed,int[] shape,int[] underlyingShape,char ordering){
  return new SparseNDArrayCOO(data,indices,sparseOffset,fixed,shape,underlyingShape,ordering);
}","@Override public INDArray createSparseCOO(DataBuffer data,DataBuffer indices,int[] sparseOffset,int[] fixed,int[] shape,char ordering){
  return new SparseNDArrayCOO(data,indices,sparseOffset,fixed,shape,ordering);
}"
3213,"public SparseNDArrayCOO(DataBuffer values,DataBuffer indices,int[] sparseOffset,int[] fixed,int[] shape,int[] underlyingShape,char ordering){
  super(values,indices,sparseOffset,fixed,shape,underlyingShape,ordering);
}","public SparseNDArrayCOO(DataBuffer values,DataBuffer indices,int[] sparseOffset,int[] fixed,int[] shape,char ordering){
  super(values,indices,sparseOffset,fixed,shape,ordering);
}"
3214,"@Test public void shouldTakeViewOfView2(){
  int[] shape=new int[]{4,2,3};
  double[] values=new double[]{1,2,3,4,5,6,7,8,9};
  int[][] indices=new int[][]{{0,0,2},{0,1,1},{1,0,0},{1,0,1},{1,1,2},{2,0,1},{2,1,2},{3,0,1},{3,1,0}};
  INDArray array=Nd4j.createSparseCOO(values,indices,shape);
  BaseSparseNDArrayCOO baseView=(BaseSparseNDArrayCOO)array.get(NDArrayIndex.interval(1,4),NDArrayIndex.point(1),NDArrayIndex.all());
  BaseSparseNDArrayCOO view=(BaseSparseNDArrayCOO)baseView.get(NDArrayIndex.all(),NDArrayIndex.point(2));
  assertEquals(2,view.nnz());
  assertArrayEquals(new int[]{3,1},view.shape());
  assertArrayEquals(new int[]{0,0,0,1},view.getIndices().asInt());
  assertArrayEquals(new double[]{5,7},view.getValues().asDouble(),1e-1);
}","@Test public void shouldTakeViewOfView2(){
  int[] shape=new int[]{4,2,3};
  double[] values=new double[]{1,2,3,4,5,6,7,8,9};
  int[][] indices=new int[][]{{0,0,2},{0,1,1},{1,0,0},{1,0,1},{1,1,2},{2,0,1},{2,1,2},{3,0,1},{3,1,0}};
  INDArray array=Nd4j.createSparseCOO(values,indices,shape);
  BaseSparseNDArrayCOO baseView=(BaseSparseNDArrayCOO)array.get(NDArrayIndex.interval(1,4),NDArrayIndex.point(1),NDArrayIndex.all());
  BaseSparseNDArrayCOO view=(BaseSparseNDArrayCOO)baseView.get(NDArrayIndex.all(),NDArrayIndex.point(2));
  assertEquals(2,view.nnz());
  assertArrayEquals(new int[]{3,1},view.shape());
  assertArrayEquals(new int[]{0,0,1,0},view.getIndices().asInt());
  assertArrayEquals(new double[]{5,7},view.getValues().asDouble(),1e-1);
}"
3215,"/** 
 * @param wrt
 * @param epsilon
 * @param maxRelError
 * @param minAbsoluteError
 * @param print
 * @param exitOnFirstError
 * @param inputParameters
 * @param rngSeed
 * @return
 */
public static boolean checkGradients(TensorGradVariable wrt,double epsilon,double maxRelError,double minAbsoluteError,boolean print,boolean exitOnFirstError,Map<String,INDArray> inputParameters,int rngSeed){
  if (epsilon <= 0.0 || epsilon > 0.1)   throw new IllegalArgumentException(""String_Node_Str"");
  if (maxRelError <= 0.0 || maxRelError > 0.25)   throw new IllegalArgumentException(""String_Node_Str"" + maxRelError);
  DataBuffer.Type dataType=DataTypeUtil.getDtypeFromContext();
  if (dataType != DataBuffer.Type.DOUBLE) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + dataType + ""String_Node_Str""+ ""String_Node_Str"");
  }
  TensorGrad tensorGrad=wrt.getTensorGrad();
  int totalNFailures=0;
  double maxError=0.0;
  for (  Map.Entry<String,INDArray> entry : inputParameters.entrySet()) {
    int nParams=entry.getValue().length();
    INDArray params=entry.getValue().dup();
    for (int i=0; i < nParams; i++) {
      double origValue=params.getDouble(i);
      params.putScalar(i,origValue + epsilon);
      Map<String,INDArray> evalParams=new HashMap<>();
      for (      Map.Entry<String,INDArray> entry2 : inputParameters.entrySet()) {
        if (!entry2.getKey().equals(entry.getKey())) {
          evalParams.put(entry2.getKey(),entry2.getValue());
        }
 else {
          evalParams.put(entry.getKey(),params);
        }
      }
      INDArray[] plusParams=tensorGrad.eval(evalParams);
      params.putScalar(i,origValue - epsilon);
      INDArray[] minusParams=tensorGrad.eval(evalParams);
      Nd4j.getRandom().setSeed(rngSeed);
      INDArray[] newDifferences=new INDArray[minusParams.length];
      for (int j=0; j < newDifferences.length; j++) {
        newDifferences[i]=plusParams[i].subi(minusParams[i]).divi(epsilon);
      }
      double scoreDelta=0.0;
      for (      INDArray arr : newDifferences)       scoreDelta+=arr.sumNumber().doubleValue();
      params.putScalar(i,origValue);
      double numericalGradient=scoreDelta / (2 * epsilon);
      if (Double.isNaN(numericalGradient))       throw new IllegalStateException(""String_Node_Str"" + i + ""String_Node_Str""+ nParams);
      if (print) {
        int nPass=nParams - totalNFailures;
        log.info(""String_Node_Str"" + nParams + ""String_Node_Str""+ nPass+ ""String_Node_Str""+ totalNFailures+ ""String_Node_Str""+ maxError);
      }
    }
  }
  return totalNFailures == 0;
}","/** 
 * @param wrt
 * @param epsilon
 * @param maxRelError
 * @param minAbsoluteError
 * @param print
 * @param exitOnFirstError
 * @param inputParameters
 * @param rngSeed
 * @return
 */
public static boolean checkGradients(TensorGradVariable wrt,TensorGradVariable function,double epsilon,double maxRelError,double minAbsoluteError,boolean print,boolean exitOnFirstError,Map<String,INDArray> inputParameters,int rngSeed){
  if (epsilon <= 0.0 || epsilon > 0.1)   throw new IllegalArgumentException(""String_Node_Str"");
  if (maxRelError <= 0.0 || maxRelError > 0.25)   throw new IllegalArgumentException(""String_Node_Str"" + maxRelError);
  DataBuffer.Type dataType=DataTypeUtil.getDtypeFromContext();
  if (dataType != DataBuffer.Type.DOUBLE) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + dataType + ""String_Node_Str""+ ""String_Node_Str"");
  }
  TensorGrad tensorGrad=wrt.getTensorGrad();
  TensorGradVariable variable=tensorGrad.grad(function,wrt);
  int totalNFailures=0;
  double maxError=0.0;
  for (  Map.Entry<String,INDArray> entry : inputParameters.entrySet()) {
    int nParams=entry.getValue().length();
    INDArray params=entry.getValue().dup();
    for (int i=0; i < nParams; i++) {
      double origValue=params.getDouble(i);
      params.putScalar(i,origValue + epsilon);
      Map<String,INDArray> evalParams=new HashMap<>();
      for (      Map.Entry<String,INDArray> entry2 : inputParameters.entrySet()) {
        if (!entry2.getKey().equals(entry.getKey())) {
          evalParams.put(entry2.getKey(),entry2.getValue());
        }
 else {
          evalParams.put(entry.getKey(),params);
        }
      }
      INDArray[] plusParams=tensorGrad.eval(evalParams);
      params.putScalar(i,origValue - epsilon);
      INDArray[] minusParams=tensorGrad.eval(evalParams);
      Nd4j.getRandom().setSeed(rngSeed);
      INDArray[] newDifferences=new INDArray[minusParams.length];
      for (int j=0; j < newDifferences.length; j++) {
        newDifferences[i]=plusParams[i].subi(minusParams[i]).divi(epsilon);
      }
      double scoreDelta=0.0;
      for (      INDArray arr : newDifferences)       scoreDelta+=arr.sumNumber().doubleValue();
      params.putScalar(i,origValue);
      double numericalGradient=scoreDelta / (2 * epsilon);
      if (Double.isNaN(numericalGradient))       throw new IllegalStateException(""String_Node_Str"" + i + ""String_Node_Str""+ nParams);
      if (print) {
        int nPass=nParams - totalNFailures;
        log.info(""String_Node_Str"" + nParams + ""String_Node_Str""+ nPass+ ""String_Node_Str""+ totalNFailures+ ""String_Node_Str""+ maxError);
      }
    }
  }
  return totalNFailures == 0;
}"
3216,"/** 
 * Based on the passed in array compute the shape,offsets, and strides for the given indexes
 * @param indexes the indexesto compute this based on
 */
public void exec(INDArrayIndex... indexes){
  int[] shape=arr.shape();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof PointIndex && (arr.isVector() && indexes.length == 1 ? idx.current() >= shape[i + 1] : idx.current() >= shape[i])) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ idx.current()+ ""String_Node_Str"");
    }
  }
  indexes=NDArrayIndex.resolve(arr.shapeInfoDataBuffer(),indexes);
  if (tryShortCircuit(indexes)) {
    return;
  }
  int numIntervals=0;
  int newAxesPrepend=0;
  boolean encounteredAll=false;
  List<Integer> oneDimensionWithAllEncountered=new ArrayList<>();
  List<Integer> accumShape=new ArrayList<>();
  List<Integer> accumStrides=new ArrayList<>();
  List<Integer> accumOffsets=new ArrayList<>();
  List<Integer> intervalStrides=new ArrayList<>();
  List<Integer> pointStrides=new ArrayList<>();
  List<Integer> pointOffsets=new ArrayList<>();
  int numPointIndexes=0;
  int shapeIndex=0;
  int strideIndex=0;
  List<Integer> prependNewAxes=new ArrayList<>();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof NDArrayIndexAll) {
      encounteredAll=true;
      if (i < arr.rank() && arr.size(i) == 1)       oneDimensionWithAllEncountered.add(i);
    }
    if (idx instanceof PointIndex) {
      pointOffsets.add(idx.offset());
      pointStrides.add(arr.stride(strideIndex));
      numPointIndexes++;
      shapeIndex++;
      strideIndex++;
      continue;
    }
 else     if (idx instanceof NewAxis) {
      if (encounteredAll) {
        prependNewAxes.add(i);
      }
 else       newAxesPrepend++;
      continue;
    }
 else     if (idx instanceof IntervalIndex && !(idx instanceof NDArrayIndexAll) || idx instanceof SpecifiedIndex) {
      if (idx instanceof IntervalIndex) {
        accumStrides.add(arr.stride(strideIndex) * idx.stride());
        intervalStrides.add(idx.stride());
        numIntervals++;
      }
 else       accumStrides.add(arr.stride(strideIndex));
      accumShape.add(idx.length());
      if (idx instanceof IntervalIndex) {
        accumOffsets.add(idx.offset());
      }
 else       accumOffsets.add(idx.offset());
      shapeIndex++;
      strideIndex++;
      continue;
    }
    accumShape.add(shape[shapeIndex++]);
    accumStrides.add(arr.stride(strideIndex++));
    accumOffsets.add(idx.offset());
  }
  while (shapeIndex < shape.length) {
    if (Shape.isVector(shape)) {
      accumShape.add(1);
      shapeIndex++;
    }
 else     accumShape.add(shape[shapeIndex++]);
  }
  int delta=(shape.length <= 2 ? shape.length : shape.length - numPointIndexes);
  boolean needsFilledIn=accumShape.size() != accumStrides.size() && accumOffsets.size() != accumShape.size();
  while (accumOffsets.size() < delta && needsFilledIn)   accumOffsets.add(0);
  while (accumShape.size() < 2) {
    if (Shape.isRowVectorShape(arr.shape()))     accumShape.add(0,1);
 else     accumShape.add(1);
  }
  while (strideIndex < accumShape.size()) {
    accumStrides.add(arr.stride(strideIndex++));
  }
  if (newAxesPrepend > 0) {
    for (int i=0; i < newAxesPrepend; i++) {
      accumShape.add(0,1);
      accumStrides.add(0,0);
      accumOffsets.add(0,0);
    }
  }
  int numAdded=0;
  for (int i=0; i < prependNewAxes.size(); i++) {
    accumShape.add(prependNewAxes.get(i) - numAdded,1);
    accumStrides.add(prependNewAxes.get(i) - numAdded,0);
    numAdded++;
  }
  int trailingZeroRemove=accumOffsets.size() - 1;
  while (accumOffsets.size() > accumShape.size()) {
    if (accumOffsets.get(trailingZeroRemove) == 0)     accumOffsets.remove(accumOffsets.size() - 1);
    trailingZeroRemove--;
  }
  if (accumStrides.size() < accumOffsets.size())   accumStrides.addAll(pointStrides);
  while (accumOffsets.size() < accumShape.size()) {
    if (Shape.isRowVectorShape(arr.shape()))     accumOffsets.add(0,0);
 else     accumOffsets.add(0);
  }
  if (Shape.isMatrix(shape) && indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll) {
    Collections.reverse(accumShape);
  }
  if (arr.isMatrix() && indexes[0] instanceof PointIndex && indexes[1] instanceof IntervalIndex) {
    this.shapes=new int[2];
    shapes[0]=1;
    IntervalIndex idx=(IntervalIndex)indexes[1];
    shapes[1]=idx.length();
  }
 else   this.shapes=Ints.toArray(accumShape);
  boolean isColumnVector=Shape.isColumnVectorShape(this.shapes);
  while (accumStrides.size() < accumOffsets.size()) {
    if (!isColumnVector)     accumStrides.add(0,arr.elementStride());
 else     accumStrides.add(arr.elementStride());
  }
  this.strides=Ints.toArray(accumStrides);
  this.offsets=Ints.toArray(accumOffsets);
  if (numPointIndexes > 0 && !pointStrides.isEmpty()) {
    if (newAxesPrepend >= 1) {
      while (pointStrides.size() < accumOffsets.size()) {
        pointStrides.add(1);
      }
      for (int i=0; i < accumStrides.size(); i++) {
        if (accumStrides.get(i) == 0)         pointStrides.set(i,0);
      }
    }
    while (pointOffsets.size() < pointStrides.size()) {
      pointOffsets.add(0);
    }
    if (arr.isRowVector() && !intervalStrides.isEmpty() && pointOffsets.get(0) == 0 && !(indexes[1] instanceof IntervalIndex))     this.offset=indexes[1].offset();
 else     this.offset=ArrayUtil.dotProductLong(pointOffsets,pointStrides);
  }
 else {
    this.offset=0;
  }
  if (numIntervals > 0 && arr.rank() > 2) {
    if (encounteredAll && arr.size(0) != 1)     this.offset+=ArrayUtil.dotProductLong(accumOffsets,accumStrides);
 else     this.offset+=ArrayUtil.dotProductLong(accumOffsets,accumStrides) / Math.max(1,numIntervals);
  }
 else   if (numIntervals > 0 && anyHaveStrideOne(indexes))   this.offset+=ArrayUtil.calcOffsetLong(accumShape,accumOffsets,accumStrides);
 else   this.offset+=ArrayUtil.calcOffsetLong(accumShape,accumOffsets,accumStrides) / Math.max(1,numIntervals);
}","/** 
 * Based on the passed in array compute the shape,offsets, and strides for the given indexes
 * @param indexes the indexesto compute this based on
 */
public void exec(INDArrayIndex... indexes){
  int[] shape=arr.shape();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof PointIndex && (arr.isVector() && indexes.length == 1 ? idx.current() >= shape[i + 1] : idx.current() >= shape[i])) {
      throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ idx.current()+ ""String_Node_Str"");
    }
  }
  indexes=NDArrayIndex.resolve(arr.shapeInfoDataBuffer(),indexes);
  if (tryShortCircuit(indexes)) {
    return;
  }
  int numIntervals=0;
  int newAxesPrepend=0;
  boolean encounteredAll=false;
  List<Integer> oneDimensionWithAllEncountered=new ArrayList<>();
  List<Integer> accumShape=new ArrayList<>();
  List<Integer> accumStrides=new ArrayList<>();
  List<Integer> accumOffsets=new ArrayList<>();
  List<Integer> intervalStrides=new ArrayList<>();
  List<Integer> pointStrides=new ArrayList<>();
  List<Integer> pointOffsets=new ArrayList<>();
  int numPointIndexes=0;
  int shapeIndex=0;
  int strideIndex=0;
  List<Integer> prependNewAxes=new ArrayList<>();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof NDArrayIndexAll) {
      encounteredAll=true;
      if (i < arr.rank() && arr.size(i) == 1)       oneDimensionWithAllEncountered.add(i);
    }
    if (idx instanceof PointIndex) {
      pointOffsets.add(idx.offset());
      pointStrides.add(arr.stride(strideIndex));
      numPointIndexes++;
      shapeIndex++;
      strideIndex++;
      continue;
    }
 else     if (idx instanceof NewAxis) {
      if (encounteredAll) {
        prependNewAxes.add(i);
      }
 else       newAxesPrepend++;
      continue;
    }
 else     if (idx instanceof IntervalIndex && !(idx instanceof NDArrayIndexAll) || idx instanceof SpecifiedIndex) {
      if (idx instanceof IntervalIndex) {
        accumStrides.add(arr.stride(strideIndex) * idx.stride());
        intervalStrides.add(idx.stride());
        numIntervals++;
      }
 else       accumStrides.add(arr.stride(strideIndex));
      accumShape.add(idx.length());
      if (idx instanceof IntervalIndex) {
        accumOffsets.add(idx.offset());
      }
 else       accumOffsets.add(idx.offset());
      shapeIndex++;
      strideIndex++;
      continue;
    }
    accumShape.add(shape[shapeIndex++]);
    accumStrides.add(arr.stride(strideIndex++));
    accumOffsets.add(idx.offset());
  }
  while (shapeIndex < shape.length) {
    if (Shape.isVector(shape)) {
      accumShape.add(1);
      shapeIndex++;
    }
 else     accumShape.add(shape[shapeIndex++]);
  }
  int delta=(shape.length <= 2 ? shape.length : shape.length - numPointIndexes);
  boolean needsFilledIn=accumShape.size() != accumStrides.size() && accumOffsets.size() != accumShape.size();
  while (accumOffsets.size() < delta && needsFilledIn)   accumOffsets.add(0);
  while (accumShape.size() < 2) {
    if (Shape.isRowVectorShape(arr.shape()))     accumShape.add(0,1);
 else     accumShape.add(1);
  }
  while (strideIndex < accumShape.size()) {
    accumStrides.add(arr.stride(strideIndex++));
  }
  if (newAxesPrepend > 0) {
    for (int i=0; i < newAxesPrepend; i++) {
      accumShape.add(0,1);
      accumStrides.add(0,0);
      accumOffsets.add(0,0);
    }
  }
  int numAdded=0;
  for (int i=0; i < prependNewAxes.size(); i++) {
    accumShape.add(prependNewAxes.get(i) - numAdded,1);
    accumStrides.add(prependNewAxes.get(i) - numAdded,0);
    numAdded++;
  }
  int trailingZeroRemove=accumOffsets.size() - 1;
  while (accumOffsets.size() > accumShape.size()) {
    if (accumOffsets.get(trailingZeroRemove) == 0)     accumOffsets.remove(accumOffsets.size() - 1);
    trailingZeroRemove--;
  }
  if (accumStrides.size() < accumOffsets.size())   accumStrides.addAll(pointStrides);
  while (accumOffsets.size() < accumShape.size()) {
    if (Shape.isRowVectorShape(arr.shape()))     accumOffsets.add(0,0);
 else     accumOffsets.add(0);
  }
  if (Shape.isMatrix(shape) && indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll) {
    Collections.reverse(accumShape);
  }
  if (arr.isMatrix() && indexes[0] instanceof PointIndex && indexes[1] instanceof IntervalIndex) {
    this.shapes=new int[2];
    shapes[0]=1;
    IntervalIndex idx=(IntervalIndex)indexes[1];
    shapes[1]=idx.length();
  }
 else   this.shapes=Ints.toArray(accumShape);
  boolean isColumnVector=Shape.isColumnVectorShape(this.shapes);
  while (accumStrides.size() < accumOffsets.size()) {
    if (!isColumnVector)     accumStrides.add(0,arr.elementStride());
 else     accumStrides.add(arr.elementStride());
  }
  this.strides=Ints.toArray(accumStrides);
  this.offsets=Ints.toArray(accumOffsets);
  if (numPointIndexes > 0 && !pointStrides.isEmpty()) {
    if (newAxesPrepend >= 1) {
      while (pointStrides.size() < accumOffsets.size()) {
        pointStrides.add(1);
      }
      for (int i=0; i < accumStrides.size(); i++) {
        if (accumStrides.get(i) == 0)         pointStrides.set(i,0);
      }
    }
    while (pointOffsets.size() < pointStrides.size()) {
      pointOffsets.add(0);
    }
    if (arr.isRowVector() && !intervalStrides.isEmpty() && pointOffsets.get(0) == 0 && !(indexes[1] instanceof IntervalIndex))     this.offset=indexes[1].offset();
 else     this.offset=ArrayUtil.dotProductLong(pointOffsets,pointStrides);
  }
 else {
    this.offset=0;
  }
  if (numIntervals > 0 && arr.rank() > 2) {
    boolean containsOne=false;
    for (int i=0; i < arr.rank(); i++) {
      if (arr.size(i) == 1) {
        containsOne=true;
        break;
      }
    }
    if (encounteredAll && !containsOne || anyHaveStrideOne(indexes))     this.offset+=ArrayUtil.dotProductLong(accumOffsets,accumStrides);
 else     this.offset+=ArrayUtil.dotProductLong(accumOffsets,accumStrides) / Math.max(1,numIntervals);
  }
 else   if (numIntervals > 0 && anyHaveStrideOne(indexes))   this.offset+=ArrayUtil.calcOffsetLong(accumShape,accumOffsets,accumStrides);
 else   this.offset+=ArrayUtil.calcOffsetLong(accumShape,accumOffsets,accumStrides) / Math.max(1,numIntervals);
}"
3217,"@Override public void run(){
  while (true) {
    try {
      Nd4jWorkspace.GarbageWorkspaceReference reference=(Nd4jWorkspace.GarbageWorkspaceReference)queue.remove();
      if (reference != null) {
        PointersPair pair=reference.getPointersPair();
        if (pair != null) {
          if (pair.getDevicePointer() != null) {
            log.info(""String_Node_Str"");
            Nd4j.getMemoryManager().release(pair.getDevicePointer(),MemoryKind.DEVICE);
          }
          if (pair.getHostPointer() != null) {
            referenceMap.remove(reference.getId() + ""String_Node_Str"" + reference.getThreadId());
            Nd4j.getMemoryManager().release(pair.getHostPointer(),MemoryKind.HOST);
          }
        }
        for (        PointersPair pair2 : reference.getExternalPointers()) {
          if (pair2 != null) {
            if (pair2.getHostPointer() != null)             Nd4j.getMemoryManager().release(pair2.getHostPointer(),MemoryKind.HOST);
            if (pair2.getDevicePointer() != null)             Nd4j.getMemoryManager().release(pair2.getDevicePointer(),MemoryKind.DEVICE);
          }
        }
        while ((pair=reference.getPinnedPointers().poll()) != null) {
          if (pair.getHostPointer() != null)           Nd4j.getMemoryManager().release(pair.getHostPointer(),MemoryKind.HOST);
          if (pair.getDevicePointer() != null)           Nd4j.getMemoryManager().release(pair.getDevicePointer(),MemoryKind.DEVICE);
        }
      }
    }
 catch (    Exception e) {
    }
  }
}","@Override public void run(){
  while (true) {
    try {
      Nd4jWorkspace.GarbageWorkspaceReference reference=(Nd4jWorkspace.GarbageWorkspaceReference)queue.remove();
      if (reference != null) {
        PointersPair pair=reference.getPointersPair();
        if (pair != null) {
          if (pair.getDevicePointer() != null) {
            Nd4j.getMemoryManager().release(pair.getDevicePointer(),MemoryKind.DEVICE);
          }
          if (pair.getHostPointer() != null) {
            referenceMap.remove(reference.getId() + ""String_Node_Str"" + reference.getThreadId());
            Nd4j.getMemoryManager().release(pair.getHostPointer(),MemoryKind.HOST);
          }
        }
        for (        PointersPair pair2 : reference.getExternalPointers()) {
          if (pair2 != null) {
            if (pair2.getHostPointer() != null)             Nd4j.getMemoryManager().release(pair2.getHostPointer(),MemoryKind.HOST);
            if (pair2.getDevicePointer() != null)             Nd4j.getMemoryManager().release(pair2.getDevicePointer(),MemoryKind.DEVICE);
          }
        }
        while ((pair=reference.getPinnedPointers().poll()) != null) {
          if (pair.getHostPointer() != null)           Nd4j.getMemoryManager().release(pair.getHostPointer(),MemoryKind.HOST);
          if (pair.getDevicePointer() != null)           Nd4j.getMemoryManager().release(pair.getDevicePointer(),MemoryKind.DEVICE);
        }
      }
    }
 catch (    Exception e) {
    }
  }
}"
3218,"@Override public void setStateViewArray(INDArray viewArray,int[] gradientShape,char gradientOrder,boolean initialize){
  if (!viewArray.isRowVector())   throw new IllegalArgumentException(""String_Node_Str"");
  if (initialize)   viewArray.assign(epsilon);
  this.historicalGradient=viewArray;
  this.historicalGradient=Shape.newShapeNoCopy(this.historicalGradient,gradientShape,gradientOrder == 'f');
  if (historicalGradient == null)   throw new IllegalStateException(""String_Node_Str"");
}","@Override public void setStateViewArray(INDArray viewArray,int[] gradientShape,char gradientOrder,boolean initialize){
  if (!viewArray.isRowVector())   throw new IllegalArgumentException(""String_Node_Str"");
  if (initialize)   viewArray.assign(epsilon);
  this.historicalGradient=viewArray;
  this.historicalGradient=Shape.newShapeNoCopy(this.historicalGradient,gradientShape,gradientOrder == 'f');
  if (historicalGradient == null)   throw new IllegalStateException(""String_Node_Str"");
  this.gradientReshapeOrder=gradientOrder;
}"
3219,"@Override public IComplexNumber op(IComplexNumber origin){
  if (origin.absoluteValue().doubleValue() > complexNumber.absoluteValue().doubleValue())   return origin;
  return complexNumber;
}","@Override public IComplexNumber op(IComplexNumber origin){
  if (origin.absoluteValue().doubleValue() < complexNumber.absoluteValue().doubleValue())   return origin;
  return complexNumber;
}"
3220,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(INDArrayIndex... indexes){
  if (indexes.length == 1 && indexes[0] instanceof NDArrayIndexAll || (indexes.length == 2 && (isRowVector() && indexes[0] instanceof PointIndex && indexes[0].offset() == 0 && indexes[1] instanceof NDArrayIndexAll || isColumnVector() && indexes[1] instanceof PointIndex && indexes[0].offset() == 0 && indexes[0] instanceof NDArrayIndexAll)))   return this;
  indexes=NDArrayIndex.resolve(shapeInfoDataBuffer(),indexes);
  ShapeOffsetResolution resolution=new ShapeOffsetResolution(this);
  resolution.exec(indexes);
  if (indexes.length < 1)   throw new IllegalStateException(""String_Node_Str"");
  int[] shape=resolution.getShapes();
  int numSpecifiedIndex=0;
  for (int i=0; i < indexes.length; i++)   if (indexes[i] instanceof SpecifiedIndex)   numSpecifiedIndex++;
  if (shape != null && numSpecifiedIndex > 0) {
    Generator<List<List<Integer>>> gen=SpecifiedIndex.iterate(indexes);
    INDArray ret=create(shape);
    int count=0;
    while (true) {
      try {
        List<List<Integer>> next=gen.next();
        List<Integer> coordsCombo=new ArrayList<>();
        for (int i=0; i < next.size(); i++) {
          if (next.get(i).size() > 1)           throw new IllegalStateException(""String_Node_Str"");
          coordsCombo.add(next.get(i).get(0));
        }
        ret.putScalar(count++,getDouble(Ints.toArray(coordsCombo)));
      }
 catch (      NoSuchElementException e) {
        break;
      }
      if (count >= ret.length())       break;
    }
    return ret;
  }
  INDArray ret=subArray(resolution);
  return ret;
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(INDArrayIndex... indexes){
  if (indexes.length == 1 && indexes[0] instanceof NDArrayIndexAll || (indexes.length == 2 && (isRowVector() && indexes[0] instanceof PointIndex && indexes[0].offset() == 0 && indexes[1] instanceof NDArrayIndexAll || isColumnVector() && indexes[1] instanceof PointIndex && indexes[0].offset() == 0 && indexes[0] instanceof NDArrayIndexAll)))   return this;
  indexes=NDArrayIndex.resolve(shapeInfoDataBuffer(),indexes);
  ShapeOffsetResolution resolution=new ShapeOffsetResolution(this);
  resolution.exec(indexes);
  if (indexes.length < 1)   throw new IllegalStateException(""String_Node_Str"");
  int[] shape=resolution.getShapes();
  int numSpecifiedIndex=0;
  for (int i=0; i < indexes.length; i++)   if (indexes[i] instanceof SpecifiedIndex)   numSpecifiedIndex++;
  if (shape != null && numSpecifiedIndex > 0) {
    Generator<List<List<Integer>>> gen=SpecifiedIndex.iterate(indexes);
    INDArray ret=Nd4j.create(shape,'c');
    int count=0;
    while (true) {
      try {
        List<List<Integer>> next=gen.next();
        List<Integer> coordsCombo=new ArrayList<>();
        for (int i=0; i < next.size(); i++) {
          if (next.get(i).size() > 1)           throw new IllegalStateException(""String_Node_Str"");
          coordsCombo.add(next.get(i).get(0));
        }
        ret.putScalar(count++,getDouble(Ints.toArray(coordsCombo)));
      }
 catch (      NoSuchElementException e) {
        break;
      }
      if (count >= ret.length())       break;
    }
    return ret;
  }
  INDArray ret=subArray(resolution);
  return ret;
}"
3221,"public boolean tryShortCircuit(INDArrayIndex... indexes){
  int pointIndex=0;
  int interval=0;
  int newAxis=0;
  int numAll=0;
  int numSpecified=0;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i] instanceof PointIndex) {
      pointIndex++;
    }
    if (indexes[i] instanceof SpecifiedIndex)     numSpecified++;
 else     if (indexes[i] instanceof IntervalIndex && !(indexes[i] instanceof NDArrayIndexAll))     interval++;
 else     if (indexes[i] instanceof NewAxis)     newAxis++;
 else     if (indexes[i] instanceof NDArrayIndexAll)     numAll++;
  }
  if (arr.isVector()) {
    if (indexes[0] instanceof NDArrayIndexAll && indexes.length == 1) {
      offset=0;
      this.shapes=arr.shape();
      this.strides=arr.stride();
      this.offsets=new int[arr.rank()];
      return true;
    }
 else     if (indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll) {
      this.shapes=new int[2];
      this.strides=new int[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=1;
      }
      this.offsets=new int[arr.rank()];
      this.offset=indexes[0].offset();
      return true;
    }
    if (indexes[0] instanceof PointIndex && indexes.length == 1) {
      this.shapes=new int[2];
      this.strides=new int[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=1;
      }
      this.offset=indexes[0].offset();
      return true;
    }
    if (arr.isRowVector()) {
      if (indexes[0] instanceof PointIndex) {
        if (indexes.length > 1 && indexes[1] instanceof IntervalIndex) {
          offset=indexes[1].offset();
          this.shapes=new int[2];
          shapes[0]=1;
          shapes[1]=indexes[1].length();
          this.strides=new int[2];
          strides[0]=0;
          strides[1]=indexes[1].stride();
          this.offsets=new int[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
 else {
      if (indexes.length > 1 && indexes[1] instanceof PointIndex) {
        if (indexes[0] instanceof IntervalIndex) {
          offset=indexes[0].offset();
          this.shapes=new int[2];
          shapes[1]=1;
          shapes[0]=indexes[1].length();
          this.strides=new int[2];
          strides[1]=0;
          strides[0]=indexes[1].stride();
          this.offsets=new int[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
  }
  if (numSpecified > 0 && interval < 1 && newAxis < 1 && numAll > 0 && pointIndex < 1 && arr.rank() == 2) {
    shapes=new int[arr.rank()];
    strides=new int[arr.rank()];
    offsets=new int[arr.rank()];
    offset=0;
    boolean allSpecified=true;
    for (int i=0; i < 2; i++) {
      allSpecified=allSpecified && indexes[i] instanceof SpecifiedIndex;
    }
    for (int i=0; i < arr.rank(); i++) {
      if (indexes[i] instanceof SpecifiedIndex) {
        SpecifiedIndex specifiedIndex=(SpecifiedIndex)indexes[i];
        if (specifiedIndex.getIndexes().length >= arr.rank())         return false;
        shapes[i]=indexes[i].length();
        offsets[i]=indexes[i].offset();
        if (!allSpecified || i == 0 && allSpecified)         offset=offsets[i] * arr.stride(i);
        if (indexes[i].length() != 1) {
          strides[i]=arr.stride(i) * specifiedIndex.getIndexes()[i];
        }
 else         strides[i]=1;
      }
 else       if (indexes[i] instanceof NDArrayIndexAll) {
        shapes[i]=arr.size(i);
        strides[i]=arr.tensorAlongDimension(0,i).elementWiseStride();
      }
 else       throw new IllegalArgumentException(""String_Node_Str"" + indexes[i].getClass().getName());
    }
    return true;
  }
  if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex > 0 && numAll > 0) {
    int minDimensions=Math.max(arr.rank() - pointIndex,2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    long offset=0;
    int currIndex=0;
    int arrIndex=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[currIndex]=arr.size(arrIndex);
        stride[currIndex]=arr.stride(arrIndex);
        currIndex++;
        arrIndex++;
      }
 else {
        offset+=indexes[i].offset() * arr.stride(i);
        arrIndex++;
      }
    }
    if (arr.isMatrix() && indexes[0] instanceof PointIndex) {
      shape=ArrayUtil.reverseCopy(shape);
      stride=ArrayUtil.reverseCopy(stride);
    }
 else     if (arr.isMatrix() && indexes[0] instanceof PointIndex && indexes[1] instanceof IntervalIndex) {
      shape=new int[2];
      shape[0]=1;
      IntervalIndex idx=(IntervalIndex)indexes[1];
      shape[1]=idx.length();
    }
    this.strides=stride;
    this.shapes=shape;
    this.offsets=offsets;
    this.offset=offset;
    return true;
  }
 else   if (numSpecified < 1 && interval > 0 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    for (int i=0; i < shape.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[i]=arr.size(i);
        stride[i]=arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
 else       if (indexes[i] instanceof IntervalIndex) {
        shape[i]=indexes[i].length();
        stride[i]=indexes[i].stride() * arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    this.offset=0;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
 else   if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2) + newAxis;
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    int prependNewAxes=0;
    boolean allFirst=false;
    int shapeAxis=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NewAxis) {
        if (allFirst) {
          shape[i]=1;
          stride[i]=0;
        }
 else {
          prependNewAxes++;
        }
      }
 else {
        if (i == 0)         allFirst=true;
        shape[i]=arr.size(shapeAxis + prependNewAxes);
        stride[i]=arr.stride(shapeAxis + prependNewAxes);
        shapeAxis++;
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    return true;
  }
  return false;
}","public boolean tryShortCircuit(INDArrayIndex... indexes){
  int pointIndex=0;
  int interval=0;
  int newAxis=0;
  int numAll=0;
  int numSpecified=0;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i] instanceof PointIndex) {
      pointIndex++;
    }
    if (indexes[i] instanceof SpecifiedIndex)     numSpecified++;
 else     if (indexes[i] instanceof IntervalIndex && !(indexes[i] instanceof NDArrayIndexAll))     interval++;
 else     if (indexes[i] instanceof NewAxis)     newAxis++;
 else     if (indexes[i] instanceof NDArrayIndexAll)     numAll++;
  }
  if (arr.isVector()) {
    if (indexes[0] instanceof NDArrayIndexAll && indexes.length == 1) {
      offset=0;
      this.shapes=arr.shape();
      this.strides=arr.stride();
      this.offsets=new int[arr.rank()];
      return true;
    }
 else     if (indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll) {
      this.shapes=new int[2];
      this.strides=new int[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=1;
      }
      this.offsets=new int[arr.rank()];
      this.offset=indexes[0].offset();
      return true;
    }
    if (indexes[0] instanceof PointIndex && indexes.length == 1) {
      this.shapes=new int[2];
      this.strides=new int[2];
      for (int i=0; i < 2; i++) {
        shapes[i]=1;
        strides[i]=1;
      }
      this.offset=indexes[0].offset();
      return true;
    }
    if (arr.isRowVector()) {
      if (indexes[0] instanceof PointIndex) {
        if (indexes.length > 1 && indexes[1] instanceof IntervalIndex) {
          offset=indexes[1].offset();
          this.shapes=new int[2];
          shapes[0]=1;
          shapes[1]=indexes[1].length();
          this.strides=new int[2];
          strides[0]=0;
          strides[1]=indexes[1].stride();
          this.offsets=new int[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        return false;
      }
    }
 else {
      if (indexes.length > 1 && indexes[1] instanceof PointIndex) {
        if (indexes[0] instanceof IntervalIndex) {
          offset=indexes[0].offset();
          this.shapes=new int[2];
          shapes[1]=1;
          shapes[0]=indexes[1].length();
          this.strides=new int[2];
          strides[1]=0;
          strides[0]=indexes[1].stride();
          this.offsets=new int[2];
          return true;
        }
      }
 else       if (indexes[0] instanceof IntervalIndex) {
      }
 else {
        return false;
      }
    }
  }
  if (numSpecified > 0 && interval < 1 && newAxis < 1 && numAll > 0 && pointIndex < 1 && arr.rank() == 2) {
    shapes=new int[arr.rank()];
    strides=new int[arr.rank()];
    offsets=new int[arr.rank()];
    offset=0;
    boolean allSpecified=true;
    for (int i=0; i < 2; i++) {
      allSpecified=allSpecified && indexes[i] instanceof SpecifiedIndex;
    }
    for (int i=0; i < arr.rank(); i++) {
      if (indexes[i] instanceof SpecifiedIndex) {
        SpecifiedIndex specifiedIndex=(SpecifiedIndex)indexes[i];
        if (specifiedIndex.getIndexes().length >= arr.rank())         return false;
        shapes[i]=indexes[i].length();
        offsets[i]=indexes[i].offset();
        if (!allSpecified || i == 0 && allSpecified)         offset=offsets[i] * arr.stride(i);
        if (indexes[i].length() != 1) {
          strides[i]=arr.stride(i) * specifiedIndex.getIndexes()[i];
        }
 else         strides[i]=1;
      }
 else       if (indexes[i] instanceof NDArrayIndexAll) {
        shapes[i]=arr.size(i);
        strides[i]=arr.tensorAlongDimension(0,i).elementWiseStride();
      }
 else       throw new IllegalArgumentException(""String_Node_Str"" + indexes[i].getClass().getName());
    }
    return true;
  }
  if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex > 0 && numAll > 0) {
    int minDimensions=Math.max(arr.rank() - pointIndex,2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    long offset=0;
    int currIndex=0;
    int arrIndex=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[currIndex]=arr.size(arrIndex);
        stride[currIndex]=arr.stride(arrIndex);
        currIndex++;
        arrIndex++;
      }
 else {
        offset+=indexes[i].offset() * arr.stride(i);
        arrIndex++;
      }
    }
    if (arr.isMatrix() && indexes[0] instanceof PointIndex) {
      shape=ArrayUtil.reverseCopy(shape);
      stride=ArrayUtil.reverseCopy(stride);
    }
 else     if (arr.isMatrix() && indexes[0] instanceof PointIndex && indexes[1] instanceof IntervalIndex) {
      shape=new int[2];
      shape[0]=1;
      IntervalIndex idx=(IntervalIndex)indexes[1];
      shape[1]=idx.length();
    }
    this.strides=stride;
    this.shapes=shape;
    this.offsets=offsets;
    this.offset=offset;
    return true;
  }
 else   if (numSpecified < 1 && interval > 0 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    for (int i=0; i < shape.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[i]=arr.size(i);
        stride[i]=arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
 else       if (indexes[i] instanceof IntervalIndex) {
        shape[i]=indexes[i].length();
        stride[i]=indexes[i].stride() * arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    this.offset=0;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
 else   if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2) + newAxis;
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    int prependNewAxes=0;
    boolean allFirst=false;
    int shapeAxis=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NewAxis) {
        if (allFirst) {
          shape[i]=1;
          stride[i]=0;
        }
 else {
          prependNewAxes++;
        }
      }
 else {
        if (i == 0)         allFirst=true;
        shape[i]=arr.size(shapeAxis + prependNewAxes);
        stride[i]=arr.stride(shapeAxis + prependNewAxes);
        shapeAxis++;
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    return true;
  }
  return false;
}"
3222,"@Test public void testRandomWithOrder(){
  Nd4j.getRandom().setSeed(12345);
  INDArray arr=Nd4j.rand('c',3,4);
  assertArrayEquals(new int[]{3,4},arr.shape());
  assertEquals('c',arr.ordering());
  assertTrue(arr.minNumber().doubleValue() >= 0.0);
  assertTrue(arr.maxNumber().doubleValue() <= 1.0);
  INDArray arr2=Nd4j.rand('f',3,4);
  assertArrayEquals(new int[]{3,4},arr2.shape());
  assertEquals('f',arr2.ordering());
  assertTrue(arr2.minNumber().doubleValue() >= 0.0);
  assertTrue(arr2.maxNumber().doubleValue() <= 1.0);
  INDArray arr3=Nd4j.rand('c',new int[]{3,4,5});
  assertArrayEquals(new int[]{3,4,5},arr3.shape());
  assertEquals('c',arr3.ordering());
  assertTrue(arr3.minNumber().doubleValue() >= 0.0);
  assertTrue(arr3.maxNumber().doubleValue() <= 1.0);
  INDArray arr4=Nd4j.rand('f',new int[]{3,4,5});
  assertArrayEquals(new int[]{3,4,5},arr4.shape());
  assertEquals('f',arr4.ordering());
  assertTrue(arr4.minNumber().doubleValue() >= 0.0);
  assertTrue(arr4.maxNumber().doubleValue() <= 1.0);
  INDArray narr=Nd4j.randn('c',3,4);
  assertArrayEquals(new int[]{3,4},narr.shape());
  assertEquals('c',narr.ordering());
  assertEquals(narr.meanNumber().doubleValue(),0.0,0.5);
  INDArray narr2=Nd4j.randn('f',3,4);
  assertArrayEquals(new int[]{3,4},narr2.shape());
  assertEquals('f',narr2.ordering());
  assertEquals(narr2.meanNumber().doubleValue(),0.0,0.5);
  INDArray narr3=Nd4j.randn('c',new int[]{3,4,5});
  assertArrayEquals(new int[]{3,4,5},narr3.shape());
  assertEquals('c',narr3.ordering());
  assertEquals(narr3.meanNumber().doubleValue(),0.0,0.5);
  INDArray narr4=Nd4j.randn('f',new int[]{3,4,5});
  assertArrayEquals(new int[]{3,4,5},narr4.shape());
  assertEquals('f',narr4.ordering());
  assertEquals(narr4.meanNumber().doubleValue(),0.0,0.5);
}","@Test public void testRandomWithOrder(){
  Nd4j.getRandom().setSeed(12345);
  int rows=10;
  int cols=20;
  int dim2=7;
  INDArray arr=Nd4j.rand('c',rows,cols);
  assertArrayEquals(new int[]{rows,cols},arr.shape());
  assertEquals('c',arr.ordering());
  assertTrue(arr.minNumber().doubleValue() >= 0.0);
  assertTrue(arr.maxNumber().doubleValue() <= 1.0);
  INDArray arr2=Nd4j.rand('f',rows,cols);
  assertArrayEquals(new int[]{rows,cols},arr2.shape());
  assertEquals('f',arr2.ordering());
  assertTrue(arr2.minNumber().doubleValue() >= 0.0);
  assertTrue(arr2.maxNumber().doubleValue() <= 1.0);
  INDArray arr3=Nd4j.rand('c',new int[]{rows,cols,dim2});
  assertArrayEquals(new int[]{rows,cols,dim2},arr3.shape());
  assertEquals('c',arr3.ordering());
  assertTrue(arr3.minNumber().doubleValue() >= 0.0);
  assertTrue(arr3.maxNumber().doubleValue() <= 1.0);
  INDArray arr4=Nd4j.rand('f',new int[]{rows,cols,dim2});
  assertArrayEquals(new int[]{rows,cols,dim2},arr4.shape());
  assertEquals('f',arr4.ordering());
  assertTrue(arr4.minNumber().doubleValue() >= 0.0);
  assertTrue(arr4.maxNumber().doubleValue() <= 1.0);
  INDArray narr=Nd4j.randn('c',rows,cols);
  assertArrayEquals(new int[]{rows,cols},narr.shape());
  assertEquals('c',narr.ordering());
  assertEquals(narr.meanNumber().doubleValue(),0.0,0.05);
  INDArray narr2=Nd4j.randn('f',rows,cols);
  assertArrayEquals(new int[]{rows,cols},narr2.shape());
  assertEquals('f',narr2.ordering());
  assertEquals(narr2.meanNumber().doubleValue(),0.0,0.05);
  INDArray narr3=Nd4j.randn('c',new int[]{rows,cols,dim2});
  assertArrayEquals(new int[]{rows,cols,dim2},narr3.shape());
  assertEquals('c',narr3.ordering());
  assertEquals(narr3.meanNumber().doubleValue(),0.0,0.05);
  INDArray narr4=Nd4j.randn('f',new int[]{rows,cols,dim2});
  assertArrayEquals(new int[]{rows,cols,dim2},narr4.shape());
  assertEquals('f',narr4.ordering());
  assertEquals(narr4.meanNumber().doubleValue(),0.0,0.05);
}"
3223,"@Before public void randomData(){
  batchSize=13;
  batchCount=20;
  lastBatch=batchSize / 2;
  INDArray origFeatures=Nd4j.rand(batchCount * batchSize + lastBatch,10);
  INDArray origLabels=Nd4j.rand(batchCount * batchSize + lastBatch,3);
  data=new DataSet(origFeatures,origLabels);
  stdScaler=new NormalizerStandardize();
  minMaxScaler=new NormalizerMinMaxScaler();
}","@Before public void randomData(){
  Nd4j.getRandom().setSeed(12345);
  batchSize=13;
  batchCount=20;
  lastBatch=batchSize / 2;
  INDArray origFeatures=Nd4j.rand(batchCount * batchSize + lastBatch,10);
  INDArray origLabels=Nd4j.rand(batchCount * batchSize + lastBatch,3);
  data=new DataSet(origFeatures,origLabels);
  stdScaler=new NormalizerStandardize();
  minMaxScaler=new NormalizerMinMaxScaler();
}"
3224,"@Test public void testPreProcessors(){
  System.out.println(""String_Node_Str"");
  assertTrue(testItervsDataset(stdScaler) < thresholdPerc);
  System.out.println(""String_Node_Str"");
  assertTrue(testItervsDataset(minMaxScaler) < thresholdPerc);
}","@Test public void testPreProcessors(){
  System.out.println(""String_Node_Str"");
  double d1=testItervsDataset(stdScaler);
  assertTrue(d1 + ""String_Node_Str"" + thresholdPerc,d1 < thresholdPerc);
  System.out.println(""String_Node_Str"");
  double d2=testItervsDataset(minMaxScaler);
  assertTrue(d2 + ""String_Node_Str"" + thresholdPerc,d2 < thresholdPerc);
}"
3225,"/** 
 * Merge the list of datasets in to one list. All the rows are merged in to one dataset
 * @param data the data to merge
 * @return a single dataset
 */
public static DataSet merge(List<DataSet> data){
  if (data.isEmpty())   throw new IllegalArgumentException(""String_Node_Str"");
  DataSet first=data.get(0);
  int rankFeatures=first.getFeatures().rank();
  int rankLabels=first.getLabels().rank();
  INDArray[] featuresToMerge=new INDArray[data.size()];
  INDArray[] labelsToMerge=new INDArray[data.size()];
  int count=0;
  boolean hasFeaturesMaskArray=false;
  boolean hasLabelsMaskArray=false;
  for (  DataSet ds : data) {
    featuresToMerge[count]=ds.getFeatureMatrix();
    labelsToMerge[count++]=ds.getLabels();
    if (rankFeatures == 3 || rankLabels == 3) {
      hasFeaturesMaskArray=hasFeaturesMaskArray | (ds.getFeaturesMaskArray() != null);
      hasLabelsMaskArray=hasLabelsMaskArray | (ds.getLabelsMaskArray() != null);
    }
  }
  INDArray featuresOut;
  INDArray labelsOut;
  INDArray featuresMaskOut;
  INDArray labelsMaskOut;
switch (rankFeatures) {
case 2:
    featuresOut=merge2d(featuresToMerge);
  featuresMaskOut=null;
break;
case 3:
INDArray[] featuresMasks=null;
if (hasFeaturesMaskArray) {
featuresMasks=new INDArray[featuresToMerge.length];
count=0;
for (DataSet ds : data) {
featuresMasks[count++]=ds.getFeaturesMaskArray();
}
}
INDArray[] temp=mergeTimeSeries(featuresToMerge,featuresMasks);
featuresOut=temp[0];
featuresMaskOut=temp[1];
break;
case 4:
featuresOut=merge4dCnnData(featuresToMerge);
featuresMaskOut=null;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(data.get(0).getFeatureMatrix().shape()));
}
switch (rankLabels) {
case 2:
labelsOut=merge2d(labelsToMerge);
labelsMaskOut=null;
break;
case 3:
INDArray[] labelsMasks=null;
if (hasLabelsMaskArray) {
labelsMasks=new INDArray[labelsToMerge.length];
count=0;
for (DataSet ds : data) {
labelsMasks[count++]=ds.getLabelsMaskArray();
}
}
INDArray[] temp=mergeTimeSeries(labelsToMerge,labelsMasks);
labelsOut=temp[0];
labelsMaskOut=temp[1];
break;
case 4:
labelsOut=merge4dCnnData(featuresToMerge);
labelsMaskOut=null;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(data.get(0).getLabels().shape()));
}
DataSet dataset=new DataSet(featuresOut,labelsOut,featuresMaskOut,labelsMaskOut);
List<Serializable> meta=null;
for (DataSet ds : data) {
if (ds.getExampleMetaData() == null || ds.getExampleMetaData().size() != ds.numExamples()) {
meta=null;
break;
}
if (meta == null) meta=new ArrayList<>();
meta.addAll(ds.getExampleMetaData());
}
if (meta != null) {
dataset.setExampleMetaData(meta);
}
return dataset;
}","/** 
 * Merge the list of datasets in to one list. All the rows are merged in to one dataset
 * @param data the data to merge
 * @return a single dataset
 */
public static DataSet merge(List<DataSet> data){
  if (data.isEmpty())   throw new IllegalArgumentException(""String_Node_Str"");
  DataSet first=data.get(0);
  int rankFeatures=first.getFeatures().rank();
  int rankLabels=first.getLabels().rank();
  INDArray[] featuresToMerge=new INDArray[data.size()];
  INDArray[] labelsToMerge=new INDArray[data.size()];
  int count=0;
  boolean hasFeaturesMaskArray=false;
  boolean hasLabelsMaskArray=false;
  for (  DataSet ds : data) {
    featuresToMerge[count]=ds.getFeatureMatrix();
    labelsToMerge[count++]=ds.getLabels();
    if (rankFeatures == 3 || rankLabels == 3) {
      hasFeaturesMaskArray=hasFeaturesMaskArray | (ds.getFeaturesMaskArray() != null);
      hasLabelsMaskArray=hasLabelsMaskArray | (ds.getLabelsMaskArray() != null);
    }
  }
  INDArray featuresOut;
  INDArray labelsOut;
  INDArray featuresMaskOut;
  INDArray labelsMaskOut;
switch (rankFeatures) {
case 2:
    featuresOut=merge2d(featuresToMerge);
  featuresMaskOut=null;
break;
case 3:
INDArray[] featuresMasks=null;
if (hasFeaturesMaskArray) {
featuresMasks=new INDArray[featuresToMerge.length];
count=0;
for (DataSet ds : data) {
featuresMasks[count++]=ds.getFeaturesMaskArray();
}
}
INDArray[] temp=mergeTimeSeries(featuresToMerge,featuresMasks);
featuresOut=temp[0];
featuresMaskOut=temp[1];
break;
case 4:
featuresOut=merge4dCnnData(featuresToMerge);
featuresMaskOut=null;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(data.get(0).getFeatureMatrix().shape()));
}
switch (rankLabels) {
case 2:
labelsOut=merge2d(labelsToMerge);
labelsMaskOut=null;
break;
case 3:
INDArray[] labelsMasks=null;
if (hasLabelsMaskArray) {
labelsMasks=new INDArray[labelsToMerge.length];
count=0;
for (DataSet ds : data) {
labelsMasks[count++]=ds.getLabelsMaskArray();
}
}
INDArray[] temp=mergeTimeSeries(labelsToMerge,labelsMasks);
labelsOut=temp[0];
labelsMaskOut=temp[1];
break;
case 4:
labelsOut=merge4dCnnData(labelsToMerge);
labelsMaskOut=null;
break;
default :
throw new IllegalStateException(""String_Node_Str"" + Arrays.toString(data.get(0).getLabels().shape()));
}
DataSet dataset=new DataSet(featuresOut,labelsOut,featuresMaskOut,labelsMaskOut);
List<Serializable> meta=null;
for (DataSet ds : data) {
if (ds.getExampleMetaData() == null || ds.getExampleMetaData().size() != ds.numExamples()) {
meta=null;
break;
}
if (meta == null) meta=new ArrayList<>();
meta.addAll(ds.getExampleMetaData());
}
if (meta != null) {
dataset.setExampleMetaData(meta);
}
return dataset;
}"
3226,"/** 
 * Undo (revert) the normalization applied by this normalizer to a specific features array. If labels normalization is disabled (i.e.,   {@link #isFitLabel()} == false) then this is a no-op.Can also be used to undo normalization for network output arrays, in the case of regression.
 * @param features features arrays to revert the normalization on
 * @param input the index of the array to revert
 */
public void revertFeatures(@NonNull INDArray features,int input){
  strategy.revert(features,getFeatureStats(input));
}","/** 
 * Undo (revert) the normalization applied by this normalizer to a specific features array. If labels normalization is disabled (i.e.,   {@link #isFitLabel()} == false) then this is a no-op.Can also be used to undo normalization for network output arrays, in the case of regression.
 * @param features features arrays to revert the normalization on
 * @param input    the index of the array to revert
 */
public void revertFeatures(@NonNull INDArray features,int input){
  strategy.revert(features,getFeatureStats(input));
}"
3227,"private void fitPartial(MultiDataSet dataSet,List<S.Builder> featureStatsBuilders,List<S.Builder> labelStatsBuilders){
  int numInputs=dataSet.getFeatures().length;
  int numOutputs=dataSet.getLabels().length;
  ensureStatsBuilders(featureStatsBuilders,numInputs);
  ensureStatsBuilders(labelStatsBuilders,numOutputs);
  for (int i=0; i < numInputs; i++) {
    featureStatsBuilders.get(i).add(dataSet.getFeatures(i),dataSet.getFeaturesMaskArray(i));
  }
  if (isFitLabel()) {
    for (int i=0; i < numOutputs; i++) {
      labelStatsBuilders.get(i).add(dataSet.getLabels(i),dataSet.getLabelsMaskArray(i));
    }
  }
}","private void fitPartial(MultiDataSet dataSet,List<S.Builder> featureStatsBuilders,List<S.Builder> labelStatsBuilders){
  int numInputs=dataSet.numFeatureArrays();
  int numOutputs=dataSet.numLabelsArrays();
  ensureStatsBuilders(featureStatsBuilders,numInputs);
  ensureStatsBuilders(labelStatsBuilders,numOutputs);
  for (int i=0; i < numInputs; i++) {
    featureStatsBuilders.get(i).add(dataSet.getFeatures(i),dataSet.getFeaturesMaskArray(i));
  }
  if (isFitLabel()) {
    for (int i=0; i < numOutputs; i++) {
      labelStatsBuilders.get(i).add(dataSet.getLabels(i),dataSet.getLabelsMaskArray(i));
    }
  }
}"
3228,"/** 
 * Undo (revert) the normalization applied by this normalizer to a specific features array. If labels normalization is disabled (i.e.,   {@link #isFitLabels()} == false) then this is a no-op.Can also be used to undo normalization for network output arrays, in the case of regression.
 * @param features features arrays to revert the normalization on
 * @param input the index of the array to revert
 */
public void revertFeatures(@NonNull INDArray features,int input){
  strategy.revert(features,getFeatureStats(input));
}","/** 
 * Undo (revert) the normalization applied by this normalizer to a specific features array. If labels normalization is disabled (i.e.,   {@link #isFitLabel()} == false) then this is a no-op.Can also be used to undo normalization for network output arrays, in the case of regression.
 * @param features features arrays to revert the normalization on
 * @param input the index of the array to revert
 */
public void revertFeatures(@NonNull INDArray features,int input){
  strategy.revert(features,getFeatureStats(input));
}"
3229,"/** 
 * Pre process a MultiDataSet
 * @param toPreProcess the data set to pre process
 */
@Override public void preProcess(@NonNull MultiDataSet toPreProcess){
  int numFeatures=toPreProcess.getFeatures().length;
  int numLabels=toPreProcess.getLabels().length;
  for (int i=0; i < numFeatures; i++) {
    strategy.preProcess(toPreProcess.getFeatures(i),getFeatureStats(i));
  }
  if (isFitLabel()) {
    for (int i=0; i < numLabels; i++) {
      strategy.preProcess(toPreProcess.getLabels(i),getLabelStats(i));
    }
  }
}","/** 
 * Pre process a MultiDataSet
 * @param toPreProcess the data set to pre process
 */
@Override public void preProcess(@NonNull MultiDataSet toPreProcess){
  int numFeatures=toPreProcess.numFeatureArrays();
  int numLabels=toPreProcess.numLabelsArrays();
  for (int i=0; i < numFeatures; i++) {
    strategy.preProcess(toPreProcess.getFeatures(i),getFeatureStats(i));
  }
  if (isFitLabel()) {
    for (int i=0; i < numLabels; i++) {
      strategy.preProcess(toPreProcess.getLabels(i),getLabelStats(i));
    }
  }
}"
3230,"/** 
 * Undo (revert) the normalization applied by this normalizer to a specific labels array. If labels normalization is disabled (i.e.,   {@link #isFitLabels()} == false) then this is a no-op.Can also be used to undo normalization for network output arrays, in the case of regression.
 * @param labels Labels arrays to revert the normalization on
 * @param output the index of the array to revert
 */
public void revertLabels(@NonNull INDArray labels,int output){
  if (isFitLabel()) {
    strategy.revert(labels,getLabelStats(output));
  }
}","/** 
 * Undo (revert) the normalization applied by this normalizer to a specific labels array. If labels normalization is disabled (i.e.,   {@link #isFitLabel()} == false) then this is a no-op.Can also be used to undo normalization for network output arrays, in the case of regression.
 * @param labels Labels arrays to revert the normalization on
 * @param output the index of the array to revert
 */
public void revertLabels(@NonNull INDArray labels,int output){
  if (isFitLabel()) {
    strategy.revert(labels,getLabelStats(output));
  }
}"
3231,"/** 
 * Denormalize a data array
 * @param array the data to denormalize
 * @param stats statistics of the data population
 */
@Override public void revert(INDArray array,MinMaxStats stats){
  array.subi(minRange);
  array.divi(maxRange - minRange);
  if (array.rank() <= 2) {
    array.muliRowVector(stats.getRange());
    array.addiRowVector(stats.getLower());
  }
 else {
    Nd4j.getExecutioner().execAndReturn(new BroadcastMulOp(array,stats.getUpper(),array,1));
    Nd4j.getExecutioner().execAndReturn(new BroadcastAddOp(array,stats.getLower(),array,1));
  }
}","/** 
 * Denormalize a data array
 * @param array the data to denormalize
 * @param stats statistics of the data population
 */
@Override public void revert(INDArray array,MinMaxStats stats){
  array.subi(minRange);
  array.divi(maxRange - minRange);
  if (array.rank() <= 2) {
    array.muliRowVector(stats.getRange());
    array.addiRowVector(stats.getLower());
  }
 else {
    Nd4j.getExecutioner().execAndReturn(new BroadcastMulOp(array,stats.getRange(),array,1));
    Nd4j.getExecutioner().execAndReturn(new BroadcastAddOp(array,stats.getLower(),array,1));
  }
}"
3232,"/** 
 * Normalize a data array
 * @param array the data to normalize
 * @param stats statistics of the data population
 */
@Override public void preProcess(INDArray array,MinMaxStats stats){
  if (array.rank() <= 2) {
    array.subiRowVector(stats.getLower());
    array.diviRowVector(stats.getRange());
  }
 else {
    Nd4j.getExecutioner().execAndReturn(new BroadcastSubOp(array,stats.getLower(),array,1));
    Nd4j.getExecutioner().execAndReturn(new BroadcastDivOp(array,stats.getUpper(),array,1));
  }
  array.muli(maxRange - minRange);
  array.addi(minRange);
}","/** 
 * Normalize a data array
 * @param array the data to normalize
 * @param stats statistics of the data population
 */
@Override public void preProcess(INDArray array,MinMaxStats stats){
  if (array.rank() <= 2) {
    array.subiRowVector(stats.getLower());
    array.diviRowVector(stats.getRange());
  }
 else {
    Nd4j.getExecutioner().execAndReturn(new BroadcastSubOp(array,stats.getLower(),array,1));
    Nd4j.getExecutioner().execAndReturn(new BroadcastDivOp(array,stats.getRange(),array,1));
  }
  array.muli(maxRange - minRange);
  array.addi(minRange);
}"
3233,"/** 
 * Add rows of data to the statistics
 * @param data the matrix containing multiple rows of data to include
 * @param mask (optionally) the mask of the data, useful for e.g. time series
 */
public Builder add(@NonNull INDArray data,INDArray mask){
  data=DataSetUtil.tailor2d(data,mask);
  int count=data.size(0);
  if (count == 0) {
    return this;
  }
  INDArray mean=data.mean(0);
  INDArray variance=data.var(false,0);
  if (runningMean == null) {
    runningMean=mean;
    runningVariance=variance;
    runningCount=count;
  }
 else {
    INDArray deltaSquared=Transforms.pow(mean.subRowVector(runningMean),2);
    INDArray mB=variance.muli(count);
    runningVariance.muli(runningCount).addiRowVector(mB).addiRowVector(deltaSquared.muli((float)(runningCount * count) / (runningCount + count))).divi(runningCount + count);
    runningCount+=count;
    INDArray xMinusMean=data.subRowVector(runningMean);
    runningMean.addi(xMinusMean.sum(0).divi(runningCount));
  }
  return this;
}","/** 
 * Add rows of data to the statistics
 * @param data the matrix containing multiple rows of data to include
 * @param mask (optionally) the mask of the data, useful for e.g. time series
 */
public Builder add(@NonNull INDArray data,INDArray mask){
  data=DataSetUtil.tailor2d(data,mask);
  if (data == null) {
    return this;
  }
  INDArray mean=data.mean(0);
  INDArray variance=data.var(false,0);
  int count=data.size(0);
  if (runningMean == null) {
    runningMean=mean;
    runningVariance=variance;
    runningCount=count;
  }
 else {
    INDArray deltaSquared=Transforms.pow(mean.subRowVector(runningMean),2);
    INDArray mB=variance.muli(count);
    runningVariance.muli(runningCount).addiRowVector(mB).addiRowVector(deltaSquared.muli((float)(runningCount * count) / (runningCount + count))).divi(runningCount + count);
    runningCount+=count;
    INDArray xMinusMean=data.subRowVector(runningMean);
    runningMean.addi(xMinusMean.sum(0).divi(runningCount));
  }
  return this;
}"
3234,"/** 
 * Create a DistributionStats object from the data ingested so far. Can be used multiple times when updating online.
 */
public DistributionStats build(){
  return new DistributionStats(runningMean.dup(),Transforms.sqrt(runningVariance,true));
}","/** 
 * Create a DistributionStats object from the data ingested so far. Can be used multiple times when updating online.
 */
public DistributionStats build(){
  if (runningMean == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  return new DistributionStats(runningMean.dup(),Transforms.sqrt(runningVariance,true));
}"
3235,"public static INDArray tailor3d2d(@NonNull INDArray data,INDArray mask){
  int instances=data.size(0);
  int features=data.size(1);
  int timesteps=data.size(2);
  boolean hasMasks=mask != null;
  INDArray in2d=Nd4j.create(features,timesteps * instances);
  int tads=data.tensorssAlongDimension(2,0);
  for (int i=0; i < tads; i++) {
    INDArray thisTAD=data.tensorAlongDimension(i,2,0);
    if (hasMasks)     thisTAD.muli(mask);
    in2d.putRow(i,Nd4j.toFlattened('c',thisTAD));
  }
  in2d=in2d.transpose();
  if (hasMasks) {
    INDArray columnMask=Nd4j.toFlattened('c',mask).transpose();
    int actualSamples=columnMask.sumNumber().intValue();
    INDArray in2dMask=Nd4j.create(actualSamples,features);
    int i=0;
    for (int j=0; j < instances; j++) {
      for (int k=0; k < timesteps; k++) {
        if (columnMask.getInt(j * timesteps + k,0) != 0) {
          in2dMask.putRow(i,in2d.getRow(j * timesteps + k));
          i++;
        }
 else {
          continue;
        }
      }
    }
    return in2dMask;
  }
  return in2d;
}","public static INDArray tailor3d2d(@NonNull INDArray data,INDArray mask){
  int instances=data.size(0);
  int features=data.size(1);
  int timesteps=data.size(2);
  boolean hasMasks=mask != null;
  INDArray in2d=Nd4j.create(features,timesteps * instances);
  int tads=data.tensorssAlongDimension(2,0);
  for (int i=0; i < tads; i++) {
    INDArray thisTAD=data.tensorAlongDimension(i,2,0);
    if (hasMasks)     thisTAD.muli(mask);
    in2d.putRow(i,Nd4j.toFlattened('c',thisTAD));
  }
  in2d=in2d.transpose();
  if (hasMasks) {
    INDArray columnMask=Nd4j.toFlattened('c',mask).transpose();
    int actualSamples=columnMask.sumNumber().intValue();
    if (actualSamples == 0) {
      return null;
    }
    INDArray in2dMask=Nd4j.create(actualSamples,features);
    int i=0;
    for (int j=0; j < instances; j++) {
      for (int k=0; k < timesteps; k++) {
        if (columnMask.getInt(j * timesteps + k,0) != 0) {
          in2dMask.putRow(i,in2d.getRow(j * timesteps + k));
          i++;
        }
 else {
          continue;
        }
      }
    }
    return in2dMask;
  }
  return in2d;
}"
3236,"public TestMultiDataSetIterator(MultiDataSet dataset,int batch){
  list=new ArrayList<>(dataset.asList());
  this.batch=batch;
}","/** 
 * Makes an iterator from the given datasets. DataSets are expected to are batches of exactly 1 example. ONLY for use in tests in nd4j
 */
public TestMultiDataSetIterator(int batch,MultiDataSet... dataset){
  list=Arrays.asList(dataset);
  this.batch=batch;
}"
3237,"@Test public void testFullyMaskedData(){
  data=new MultiDataSet(new INDArray[]{Nd4j.create(new float[]{1,2}).reshape(1,1,2)},new INDArray[]{Nd4j.create(new float[]{2,3}).reshape(1,1,2)},new INDArray[]{Nd4j.create(new float[]{1,1}).reshape(1,2)},new INDArray[]{Nd4j.create(new float[]{0,0}).reshape(1,2)});
  SUT.fit(data);
}","@Test public void testFullyMaskedData(){
  MultiDataSetIterator iter=new TestMultiDataSetIterator(1,new MultiDataSet(new INDArray[]{Nd4j.create(new float[]{1}).reshape(1,1,1)},new INDArray[]{Nd4j.create(new float[]{2}).reshape(1,1,1)}),new MultiDataSet(new INDArray[]{Nd4j.create(new float[]{2}).reshape(1,1,1)},new INDArray[]{Nd4j.create(new float[]{4}).reshape(1,1,1)},null,new INDArray[]{Nd4j.create(new float[]{0}).reshape(1,1)}));
  SUT.fit(iter);
  assertEquals(2f,SUT.getLabelMean(0).getFloat(0),1e-6);
}"
3238,"@Test public void testMultipleInputsAndOutputsWithIterator(){
  MultiDataSetIterator iter=new TestMultiDataSetIterator(data,5);
  SUT.fit(iter);
  assertExpectedMeanStd();
}","@Test public void testMultipleInputsAndOutputsWithIterator(){
  MultiDataSetIterator iter=new TestMultiDataSetIterator(1,data);
  SUT.fit(iter);
  assertExpectedMeanStd();
}"
3239,"/** 
 * Add rows of data to the statistics
 * @param data the matrix containing multiple rows of data to include
 * @param mask (optionally) the mask of the data, useful for e.g. time series
 */
public Builder add(@NonNull INDArray data,INDArray mask){
  data=DataSetUtil.tailor2d(data,mask);
  INDArray mean=data.mean(0);
  INDArray variance=data.var(false,0);
  int count=data.size(0);
  if (runningMean == null) {
    runningMean=mean;
    runningVariance=variance;
    runningCount=count;
  }
 else {
    INDArray deltaSquared=Transforms.pow(mean.subRowVector(runningMean),2);
    INDArray mB=variance.muli(count);
    runningVariance.muli(runningCount).addiRowVector(mB).addiRowVector(deltaSquared.muli((float)(runningCount * count) / (runningCount + count))).divi(runningCount + count);
    runningCount+=count;
    INDArray xMinusMean=data.subRowVector(runningMean);
    runningMean.addi(xMinusMean.sum(0).divi(runningCount));
  }
  return this;
}","/** 
 * Add rows of data to the statistics
 * @param data the matrix containing multiple rows of data to include
 * @param mask (optionally) the mask of the data, useful for e.g. time series
 */
public Builder add(@NonNull INDArray data,INDArray mask){
  data=DataSetUtil.tailor2d(data,mask);
  int count=data.size(0);
  if (count == 0) {
    return this;
  }
  INDArray mean=data.mean(0);
  INDArray variance=data.var(false,0);
  if (runningMean == null) {
    runningMean=mean;
    runningVariance=variance;
    runningCount=count;
  }
 else {
    INDArray deltaSquared=Transforms.pow(mean.subRowVector(runningMean),2);
    INDArray mB=variance.muli(count);
    runningVariance.muli(runningCount).addiRowVector(mB).addiRowVector(deltaSquared.muli((float)(runningCount * count) / (runningCount + count))).divi(runningCount + count);
    runningCount+=count;
    INDArray xMinusMean=data.subRowVector(runningMean);
    runningMean.addi(xMinusMean.sum(0).divi(runningCount));
  }
  return this;
}"
3240,"/** 
 * @param idx the index to pullRows the string label value out of the list if it exists
 * @return the label name
 */
@Override public String getLabelName(int idx){
  return labelNames.get(idx);
}","/** 
 * @param idx the index to pullRows the string label value out of the list if it exists
 * @return the label name
 */
@Override public String getLabelName(int idx){
  if (!labelNames.isEmpty()) {
    if (idx < labelNames.size())     return labelNames.get(idx);
 else     throw new IllegalStateException(""String_Node_Str"");
  }
 else   throw new IllegalStateException(""String_Node_Str"");
}"
3241,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(INDArrayIndex... indexes){
  if (indexes.length == 1 && indexes[0] instanceof NDArrayIndexAll)   return this;
  ShapeOffsetResolution resolution=new ShapeOffsetResolution(this);
  resolution.exec(indexes);
  if (indexes.length < 1)   throw new IllegalStateException(""String_Node_Str"");
  int[] shape=resolution.getShapes();
  if (indexes[0] instanceof SpecifiedIndex) {
    INDArray ret=create(shape);
    int count=0;
    if (isVector()) {
      indexes[0].reset();
      while (indexes[0].hasNext()) {
        ret.putScalar(count++,getDouble(indexes[0].next()));
      }
    }
 else {
      while (indexes[0].hasNext()) {
        int nextIdx=indexes[0].next();
        INDArray next=slice(nextIdx);
        if (indexes.length > 1) {
          INDArray slice=next.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(count++,slice);
        }
 else         if (next.isScalar()) {
          ret.putScalar(count++,next.getDouble(0));
        }
 else         if (next.isVector()) {
          ret.putSlice(count++,next);
        }
 else         ret.putSlice(count++,next.get(indexes));
      }
    }
    return ret;
  }
  INDArray ret=subArray(resolution);
  return ret;
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(INDArrayIndex... indexes){
  if (indexes.length == 1 && indexes[0] instanceof NDArrayIndexAll)   return this;
  ShapeOffsetResolution resolution=new ShapeOffsetResolution(this);
  resolution.exec(indexes);
  if (indexes.length < 1)   throw new IllegalStateException(""String_Node_Str"");
  int[] shape=resolution.getShapes();
  if (shape != null && indexes[0] instanceof SpecifiedIndex) {
    INDArray ret=create(shape);
    int count=0;
    if (isVector()) {
      indexes[0].reset();
      while (indexes[0].hasNext()) {
        ret.putScalar(count++,getDouble(indexes[0].next()));
      }
    }
 else {
      while (indexes[0].hasNext()) {
        int nextIdx=indexes[0].next();
        INDArray next=slice(nextIdx);
        if (indexes.length > 1) {
          INDArray slice=next.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(count++,slice);
        }
 else         if (next.isScalar()) {
          ret.putScalar(count++,next.getDouble(0));
        }
 else         if (next.isVector()) {
          ret.putSlice(count++,next);
        }
 else         ret.putSlice(count++,next.get(indexes));
      }
    }
    return ret;
  }
  INDArray ret=subArray(resolution);
  return ret;
}"
3242,"/** 
 * Drop-in replacement wrapper for BaseDataBuffer.read() method, aware of CompressedDataBuffer
 * @param s
 * @return
 */
public static DataBuffer readUnknown(DataInputStream s,long length){
  DataBuffer buffer=Nd4j.createBuffer(length);
  buffer.read(s);
  if (buffer.dataType() != Type.COMPRESSED)   return buffer;
 else {
    try {
      String compressionAlgorithm=s.readUTF();
      long compressedLength=s.readLong();
      long originalLength=s.readLong();
      long numberOfElements=s.readLong();
      byte[] temp=new byte[(int)compressedLength];
      for (int i=0; i < compressedLength; i++) {
        temp[i]=s.readByte();
      }
      Pointer pointer=new BytePointer(temp);
      CompressionDescriptor descriptor=new CompressionDescriptor();
      descriptor.setCompressedLength(compressedLength);
      descriptor.setCompressionAlgorithm(compressionAlgorithm);
      descriptor.setOriginalLength(originalLength);
      descriptor.setNumberOfElements(numberOfElements);
      CompressedDataBuffer compressedBuffer=new CompressedDataBuffer(pointer,descriptor);
      return Nd4j.getCompressor().decompress(compressedBuffer);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}","/** 
 * Drop-in replacement wrapper for BaseDataBuffer.read() method, aware of CompressedDataBuffer
 * @param s
 * @return
 */
public static DataBuffer readUnknown(DataInputStream s,long length){
  DataBuffer buffer=Nd4j.createBuffer(length);
  buffer.read(s);
  if (buffer.dataType() != Type.COMPRESSED)   return buffer;
 else {
    try {
      String compressionAlgorithm=s.readUTF();
      long compressedLength=s.readLong();
      long originalLength=s.readLong();
      long numberOfElements=s.readLong();
      byte[] temp=new byte[(int)compressedLength];
      for (int i=0; i < compressedLength; i++) {
        temp[i]=s.readByte();
      }
      try (Pointer pointer=new BytePointer(temp)){
        CompressionDescriptor descriptor=new CompressionDescriptor();
        descriptor.setCompressedLength(compressedLength);
        descriptor.setCompressionAlgorithm(compressionAlgorithm);
        descriptor.setOriginalLength(originalLength);
        descriptor.setNumberOfElements(numberOfElements);
        CompressedDataBuffer compressedBuffer=new CompressedDataBuffer(pointer,descriptor);
        return Nd4j.getCompressor().decompress(compressedBuffer);
      }
     }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}"
3243,"private String[] writeData(DataSet write) throws IOException {
  String[] ret=new String[2];
  String dataSetId=UUID.randomUUID().toString();
  BufferedOutputStream dataOut=new BufferedOutputStream(new FileOutputStream(new File(rootDir,dataSetId + ""String_Node_Str"")));
  DataOutputStream dos=new DataOutputStream(dataOut);
  Nd4j.write(write.getFeatureMatrix(),dos);
  dos.flush();
  dos.close();
  BufferedOutputStream dataOutLabels=new BufferedOutputStream(new FileOutputStream(new File(rootDir,dataSetId + ""String_Node_Str"")));
  DataOutputStream dosLabels=new DataOutputStream(dataOutLabels);
  Nd4j.write(write.getLabels(),dosLabels);
  dosLabels.flush();
  dos.close();
  ret[0]=new File(rootDir,dataSetId + ""String_Node_Str"").getAbsolutePath();
  ret[1]=new File(rootDir,dataSetId + ""String_Node_Str"").getAbsolutePath();
  return ret;
}","private String[] writeData(DataSet write) throws IOException {
  String[] ret=new String[2];
  String dataSetId=UUID.randomUUID().toString();
  BufferedOutputStream dataOut=new BufferedOutputStream(new FileOutputStream(new File(rootDir,dataSetId + ""String_Node_Str"")));
  DataOutputStream dos=new DataOutputStream(dataOut);
  Nd4j.write(write.getFeatureMatrix(),dos);
  dos.flush();
  dos.close();
  BufferedOutputStream dataOutLabels=new BufferedOutputStream(new FileOutputStream(new File(rootDir,dataSetId + ""String_Node_Str"")));
  DataOutputStream dosLabels=new DataOutputStream(dataOutLabels);
  Nd4j.write(write.getLabels(),dosLabels);
  dosLabels.flush();
  dosLabels.close();
  ret[0]=new File(rootDir,dataSetId + ""String_Node_Str"").getAbsolutePath();
  ret[1]=new File(rootDir,dataSetId + ""String_Node_Str"").getAbsolutePath();
  return ret;
}"
3244,"@Override public DataSet get(String key){
  DataSet dataSet=null;
  if (memoryCache.contains(key)) {
    dataSet=memoryCache.get(key);
    if (!fileCache.contains(key)) {
      fileCache.put(key,dataSet);
    }
  }
 else   if (fileCache.contains(key)) {
    dataSet=fileCache.get(key);
    if (!memoryCache.contains(key)) {
      memoryCache.put(key,dataSet);
    }
  }
  return dataSet;
}","@Override public DataSet get(String key){
  DataSet dataSet=null;
  if (memoryCache.contains(key)) {
    dataSet=memoryCache.get(key);
    if (!fileCache.contains(key)) {
      fileCache.put(key,dataSet);
    }
  }
 else   if (fileCache.contains(key)) {
    dataSet=fileCache.get(key);
    if (dataSet != null && !memoryCache.contains(key)) {
      memoryCache.put(key,dataSet);
    }
  }
  return dataSet;
}"
3245,"@Test public void testResponse() throws Exception {
  int streamId=10;
  int responderStreamId=11;
  String host=""String_Node_Str"";
  AeronNDArrayResponder responder=AeronNDArrayResponder.startSubscriber(getContext2(),host,40124,null,responderStreamId);
  AtomicInteger count=new AtomicInteger(0);
  AtomicBoolean running=new AtomicBoolean(true);
  AeronNDArraySubscriber subscriber=AeronNDArraySubscriber.startSubscriber(getContext(),host,40123,arr -> count.incrementAndGet(),streamId,running);
  int expectedResponses=10;
  HostPortPublisher publisher=HostPortPublisher.builder().ctx(getContext2()).uriToSend(host + ""String_Node_Str"" + streamId).channel(AeronUtil.aeronChannel(host,40124)).streamId(responderStreamId).build();
  Thread.sleep(10000);
  for (int i=0; i < expectedResponses; i++) {
    publisher.send();
  }
  Thread.sleep(60000);
  publisher.close();
  assertEquals(expectedResponses,count.get());
  System.out.println(""String_Node_Str"");
}","@Test public void testResponse() throws Exception {
  int streamId=10;
  int responderStreamId=11;
  String host=""String_Node_Str"";
  AeronNDArrayResponder responder=AeronNDArrayResponder.startSubscriber(getContext2(),host,40124,new NDArrayHolder(){
    /** 
 * The number of updates that have been sent to this older.
 * @return
 */
    @Override public int totalUpdates(){
      return 1;
    }
    /** 
 * Retrieve an ndarray
 * @return
 */
    @Override public INDArray get(){
      return Nd4j.scalar(1.0);
    }
  }
,responderStreamId);
  AtomicInteger count=new AtomicInteger(0);
  AtomicBoolean running=new AtomicBoolean(true);
  AeronNDArraySubscriber subscriber=AeronNDArraySubscriber.startSubscriber(getContext(),host,40123,arr -> count.incrementAndGet(),streamId,running);
  int expectedResponses=10;
  HostPortPublisher publisher=HostPortPublisher.builder().ctx(getContext2()).uriToSend(host + ""String_Node_Str"" + streamId).channel(AeronUtil.aeronChannel(host,40124)).streamId(responderStreamId).build();
  Thread.sleep(10000);
  for (int i=0; i < expectedResponses; i++) {
    publisher.send();
  }
  Thread.sleep(60000);
  publisher.close();
  assertEquals(expectedResponses,count.get());
  System.out.println(""String_Node_Str"");
}"
3246,"public LossFunctionGradientChecks(Nd4jBackend backend){
  super(backend);
}","public LossFunctionGradientChecks(Nd4jBackend backend){
  super(backend);
  this.initialType=Nd4j.dataType();
}"
3247,"@Override public INDArray computeGradient(INDArray labels,INDArray preOutput,String activationFn,INDArray mask){
  INDArray gradients=super.computeGradient(labels,preOutput,activationFn,mask);
  gradients.muli(1.0 / labels.size(1));
  return gradients;
}","@Override public INDArray computeGradient(INDArray labels,INDArray preOutput,String activationFn,INDArray mask){
  INDArray gradients=super.computeGradient(labels,preOutput,activationFn,mask);
  gradients.divi(labels.size(1));
  return gradients;
}"
3248,"@Override public INDArray computeScoreArray(INDArray labels,INDArray preOutput,String activationFn,INDArray mask){
  INDArray scoreArr=super.computeScoreArray(labels,preOutput,activationFn,mask);
  scoreArr.muli(1 / scoreArr.size(1));
  return scoreArr;
}","@Override public INDArray computeScoreArray(INDArray labels,INDArray preOutput,String activationFn,INDArray mask){
  INDArray scoreArr=super.computeScoreArray(labels,preOutput,activationFn,mask);
  scoreArr.divi(scoreArr.size(1));
  return scoreArr;
}"
3249,"/** 
 * This method frees native system memory referenced by specified tracking id/AllocationPoint
 * @param bucketId
 * @param objectId
 * @param point
 * @param copyback
 */
protected void purgeZeroObject(Long bucketId,Long objectId,AllocationPoint point,boolean copyback){
  allocationsMap.remove(objectId);
  memoryHandler.purgeZeroObject(bucketId,objectId,point,copyback);
}","/** 
 * This method frees native system memory referenced by specified tracking id/AllocationPoint
 * @param bucketId
 * @param objectId
 * @param point
 * @param copyback
 */
protected void purgeZeroObject(Long bucketId,Long objectId,AllocationPoint point,boolean copyback){
  allocationsMap.remove(objectId);
  memoryHandler.purgeZeroObject(bucketId,objectId,point,copyback);
  EventsProvider.getInstance().storeEvent(point.getLastWriteEvent());
  EventsProvider.getInstance().storeEvent(point.getLastReadEvent());
}"
3250,"public synchronized void destroy(){
  if (!isDestroyed()) {
    NativeOpsHolder.getInstance().getDeviceNativeOps().destroyEvent(this);
    markDestoryed();
  }
}","public void destroy(){
  if (!isDestroyed()) {
    NativeOpsHolder.getInstance().getDeviceNativeOps().destroyEvent(this);
    markDestoryed();
  }
}"
3251,"public synchronized void synchronize(){
  if (!isDestroyed()) {
    NativeOpsHolder.getInstance().getDeviceNativeOps().eventSynchronize(this);
  }
}","public void synchronize(){
  if (!isDestroyed()) {
    NativeOpsHolder.getInstance().getDeviceNativeOps().eventSynchronize(this);
  }
}"
3252,"@Override public void waitTillFinished(AllocationPoint point){
  CudaContext context=point.getCurrentContext();
  if (context == null)   context=(CudaContext)allocator.getDeviceContext().getContext();
  context.syncOldStream();
}","@Override public void waitTillFinished(AllocationPoint point){
  if (point.getLastWriteEvent() != null) {
    point.getLastWriteEvent().synchronize();
  }
}"
3253,"@Override public void registerAction(CudaContext context,AllocationPoint result,AllocationPoint... operands){
  context.syncOldStream();
}","public void registerAction(CudaContext context,INDArray result,INDArray... operands){
  if (result == null)   return;
  AllocationPoint point=allocator.getAllocationPoint(result);
  point.tickDeviceWrite();
  EventsProvider.getInstance().storeEvent(point.getLastWriteEvent());
  point.setLastWriteEvent(EventsProvider.getInstance().getEvent());
  point.getLastWriteEvent().register(context.getOldStream());
  for (  INDArray operand : operands) {
    if (operand == null)     continue;
    AllocationPoint pointOperand=allocator.getAllocationPoint(operand);
    EventsProvider.getInstance().storeEvent(pointOperand.getLastReadEvent());
    pointOperand.setLastReadEvent(EventsProvider.getInstance().getEvent());
    pointOperand.getLastReadEvent().register(context.getOldStream());
  }
}"
3254,"@Override public void waitTillReleased(AllocationPoint point){
  waitTillFinished(point);
}","@Override public void waitTillReleased(AllocationPoint point){
  waitTillFinished(point);
  if (point.getLastReadEvent() != null)   point.getLastReadEvent().synchronize();
}"
3255,"@Override public boolean equals(Object o){
  if (o != null)   AtomicAllocator.getInstance().synchronizeHostData((INDArray)o);
  AtomicAllocator.getInstance().synchronizeHostData(this);
  return super.equals(o);
}","@Override public boolean equals(Object o){
  return super.equals(o);
}"
3256,"@Override public DataSet next(){
  String key=makeKey(currentIndex);
  DataSet ds=null;
  if (cache.contains(key)) {
    ds=cache.get(key);
  }
 else {
    ds=sourceIterator.next();
    if (preProcessor != null) {
      preProcessor.preProcess(ds);
    }
    cache.put(key,ds);
  }
  currentIndex+=1;
  return ds;
}","@Override public DataSet next(){
  String key=makeKey(currentIndex);
  DataSet ds;
  if (usingCache) {
    ds=cache.get(key);
  }
 else {
    ds=sourceIterator.next();
    if (preProcessor != null) {
      preProcessor.preProcess(ds);
    }
    cache.put(key,ds);
  }
  currentIndex+=1;
  return ds;
}"
3257,"@Override public boolean hasNext(){
  return sourceIterator.hasNext() || cache.contains(makeKey(currentIndex));
}","@Override public boolean hasNext(){
  if (usingCache) {
    return cache.contains(makeKey(currentIndex));
  }
 else {
    if (sourceIterator.hasNext()) {
      return true;
    }
 else {
      usingCache=true;
      cache.setComplete(namespace,true);
      return false;
    }
  }
}"
3258,"@Override public void put(String key,DataSet dataSet){
  File file=resolveKey(key);
  if (file.exists()) {
    throw new IllegalStateException(""String_Node_Str"" + file + ""String_Node_Str"");
  }
 else {
    File parentDir=file.getParentFile();
    if (!parentDir.exists()) {
      if (!parentDir.mkdirs()) {
        throw new IllegalStateException(""String_Node_Str"" + parentDir);
      }
    }
    dataSet.save(file);
  }
}","@Override public void put(String key,DataSet dataSet){
  File file=resolveKey(key);
  File parentDir=file.getParentFile();
  if (!parentDir.exists()) {
    if (!parentDir.mkdirs()) {
      throw new IllegalStateException(""String_Node_Str"" + parentDir);
    }
  }
  if (file.exists()) {
    file.delete();
  }
  dataSet.save(file);
}"
3259,"private void runDataSetTest(DataSetCache cache){
  DataSet dataSet=new DataSet(Nd4j.ones(500,100),Nd4j.zeros(500,2));
  DataSetIterator it=new SamplingDataSetIterator(dataSet,10,50);
  DataSetIterator cachedIt=new CachingDataSetIterator(it,cache);
  while (cachedIt.hasNext()) {
    cachedIt.next();
  }
  cachedIt.reset();
  it.reset();
  dataSet.setFeatures(Nd4j.zeros(500,100));
  dataSet.setLabels(Nd4j.ones(500,2));
  while (it.hasNext()) {
    assertTrue(cachedIt.hasNext());
    DataSet cachedDs=cachedIt.next();
    assertEquals(1000.0,cachedDs.getFeatureMatrix().sumNumber());
    assertEquals(0.0,cachedDs.getLabels().sumNumber());
    DataSet ds=it.next();
    assertEquals(0.0,ds.getFeatureMatrix().sumNumber());
    assertEquals(20.0,ds.getLabels().sumNumber());
  }
}","private void runDataSetTest(DataSetCache cache){
  DataSet dataSet=new DataSet(Nd4j.ones(500,100),Nd4j.zeros(500,2));
  DataSetIterator it=new SamplingDataSetIterator(dataSet,10,50);
  String namespace=""String_Node_Str"";
  DataSetIterator cachedIt=new CachingDataSetIterator(it,cache,namespace);
  while (cachedIt.hasNext()) {
    assertFalse(cache.isComplete(namespace));
    cachedIt.next();
  }
  assertTrue(cache.isComplete(namespace));
  cachedIt.reset();
  it.reset();
  dataSet.setFeatures(Nd4j.zeros(500,100));
  dataSet.setLabels(Nd4j.ones(500,2));
  while (it.hasNext()) {
    assertTrue(cachedIt.hasNext());
    DataSet cachedDs=cachedIt.next();
    assertEquals(1000.0,cachedDs.getFeatureMatrix().sumNumber());
    assertEquals(0.0,cachedDs.getLabels().sumNumber());
    DataSet ds=it.next();
    assertEquals(0.0,ds.getFeatureMatrix().sumNumber());
    assertEquals(20.0,ds.getLabels().sumNumber());
  }
  assertFalse(cachedIt.hasNext());
  assertFalse(it.hasNext());
}"
3260,"@Test public void testEpsOps(){
  INDArray ones=Nd4j.ones(6);
  double tiny=1.000000000000000000000000000001;
  assertTrue(ones.eps(tiny).sumNumber().doubleValue() == 6);
  INDArray consec=Nd4j.linspace(1,6,6);
  assertTrue(consec.eps(5).sumNumber().doubleValue() == 1);
  assertTrue(consec.sub(1).eps(5).sumNumber().doubleValue() == 1);
  assertTrue(consec.sub(1).eps(5).getDouble(0,5) == 1);
}","@Test public void testEpsOps(){
  INDArray ones=Nd4j.ones(6);
  double tiny=1.000000000000001;
  assertTrue(ones.eps(tiny).sumNumber().doubleValue() == 6);
  INDArray consec=Nd4j.linspace(1,6,6);
  assertTrue(consec.eps(5).sumNumber().doubleValue() == 1);
  assertTrue(consec.sub(1).eps(5).sumNumber().doubleValue() == 1);
  assertTrue(consec.sub(1).eps(5).getDouble(0,5) == 1);
}"
3261,"protected BaseDataBuffer(long length,boolean initialize){
  if (length < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  this.length=length;
  this.underlyingLength=length;
  allocationMode=AllocUtil.getAllocationModeFromContext();
  if (length < 0)   throw new IllegalArgumentException(""String_Node_Str"");
  if (allocationMode == AllocationMode.HEAP) {
    if (length >= Integer.MAX_VALUE)     throw new IllegalArgumentException(""String_Node_Str"");
    if (dataType() == Type.DOUBLE)     doubleData=new double[(int)length];
 else     if (dataType() == Type.FLOAT)     floatData=new float[(int)length];
  }
 else   if (allocationMode == AllocationMode.JAVACPP) {
    if (dataType() == Type.DOUBLE) {
      pointer=new DoublePointer(length());
      indexer=DoubleIndexer.create((DoublePointer)pointer);
      if (initialize)       fillPointerWithZero();
    }
 else     if (dataType() == Type.FLOAT) {
      pointer=new FloatPointer(length());
      indexer=FloatIndexer.create((FloatPointer)pointer);
      if (initialize)       fillPointerWithZero();
    }
 else     if (dataType() == Type.INT) {
      pointer=new IntPointer(length());
      indexer=IntIndexer.create((IntPointer)pointer);
      if (initialize)       fillPointerWithZero();
    }
  }
 else {
    if (length * getElementSize() < 0)     throw new IllegalArgumentException(""String_Node_Str"" + length + ""String_Node_Str"");
    wrappedBuffer=ByteBuffer.allocateDirect((int)(getElementSize() * length)).order(ByteOrder.nativeOrder());
  }
}","protected BaseDataBuffer(long length,boolean initialize){
  if (length < 1)   throw new IllegalArgumentException(""String_Node_Str"");
  initTypeAndSize();
  this.length=length;
  this.underlyingLength=length;
  allocationMode=AllocUtil.getAllocationModeFromContext();
  if (length < 0)   throw new IllegalArgumentException(""String_Node_Str"");
  if (allocationMode == AllocationMode.HEAP) {
    if (length >= Integer.MAX_VALUE)     throw new IllegalArgumentException(""String_Node_Str"");
    if (dataType() == Type.DOUBLE)     doubleData=new double[(int)length];
 else     if (dataType() == Type.FLOAT)     floatData=new float[(int)length];
  }
 else   if (allocationMode == AllocationMode.JAVACPP) {
    if (dataType() == Type.DOUBLE) {
      pointer=new DoublePointer(length());
      indexer=DoubleIndexer.create((DoublePointer)pointer);
      if (initialize)       fillPointerWithZero();
    }
 else     if (dataType() == Type.FLOAT) {
      pointer=new FloatPointer(length());
      indexer=FloatIndexer.create((FloatPointer)pointer);
      if (initialize)       fillPointerWithZero();
    }
 else     if (dataType() == Type.INT) {
      pointer=new IntPointer(length());
      indexer=IntIndexer.create((IntPointer)pointer);
      if (initialize)       fillPointerWithZero();
    }
  }
 else {
    if (length * getElementSize() < 0)     throw new IllegalArgumentException(""String_Node_Str"" + length + ""String_Node_Str"");
    wrappedBuffer=ByteBuffer.allocateDirect((int)(getElementSize() * length)).order(ByteOrder.nativeOrder());
  }
}"
3262,"/** 
 * Get the nesterov update
 * @param gradient the gradient to get the update for
 * @param iteration
 * @return
 */
@Override public INDArray getGradient(INDArray gradient,int iteration){
  if (v == null)   v=Nd4j.zeros(gradient.shape());
  INDArray vPrev=v;
  v=vPrev.mul(momentum).subi(gradient.mul(learningRate));
  Nd4j.getExecutioner().execAndReturn(new AddOp(vPrev.muli(momentum),v.mul(-momentum - 1),gradient));
  return gradient;
}","/** 
 * Get the nesterov update
 * @param gradient the gradient to get the update for
 * @param iteration
 * @return
 */
@Override public INDArray getGradient(INDArray gradient,int iteration){
  if (v == null)   v=Nd4j.zeros(gradient.shape());
  INDArray vPrev=v;
  v=vPrev.mul(momentum).subi(gradient.mul(learningRate));
  INDArray ret=vPrev.muli(momentum).addi(v.mul(-momentum - 1));
  gradient.assign(ret);
  return gradient;
}"
3263,"/** 
 * Fit the given model
 * @param iterator the data to iterate oer
 */
public void fit(DataSetIterator iterator){
  while (iterator.hasNext()) {
    DataSet next=iterator.next();
    if (mean == null) {
      mean=next.getFeatureMatrix().mean(0);
      std=Nd4j.zeros(mean.shape());
    }
 else {
      INDArray xMinusMean=next.getFeatureMatrix().subRowVector(mean);
      INDArray newMean=mean.add(xMinusMean.sum(0).divi(runningTotal));
      std.addi(xMinusMean.muli(next.getFeatureMatrix().subRowVector(newMean)).sum(0).divi(runningTotal));
      mean=newMean;
    }
    runningTotal+=next.numExamples();
  }
  iterator.reset();
}","/** 
 * Fit the given model
 * @param iterator the data to iterate oer
 */
public void fit(DataSetIterator iterator){
  while (iterator.hasNext()) {
    DataSet next=iterator.next();
    runningTotal+=next.numExamples();
    if (mean == null) {
      mean=next.getFeatureMatrix().mean(0);
      std=(iterator.batch() == 1) ? Nd4j.zeros(mean.shape()) : Transforms.pow(next.getFeatureMatrix().std(0),2);
      std.muli(iterator.batch());
    }
 else {
      INDArray xMinusMean=next.getFeatureMatrix().subRowVector(mean);
      INDArray newMean=mean.add(xMinusMean.sum(0).divi(runningTotal));
      INDArray meanB=next.getFeatureMatrix().mean(0);
      INDArray deltaSq=Transforms.pow(meanB.subRowVector(mean),2);
      INDArray deltaSqScaled=deltaSq.mul(((float)runningTotal - iterator.batch()) * iterator.batch() / iterator.totalExamples());
      INDArray mtwoB=Transforms.pow(next.getFeatureMatrix().std(0),2);
      mtwoB.muli(iterator.batch());
      std=std.add(mtwoB);
      std=std.add(deltaSqScaled);
      mean=newMean;
    }
  }
  std.divi(runningTotal);
  std=Transforms.sqrt(std);
  iterator.reset();
}"
3264,"/** 
 * Returns the stride(indices along the linear index for which each slice is accessed) of this array
 * @return the stride of this array
 */
@Override public int[] stride(){
  int[] ret=new int[Shape.rank(shapeInformation.asNioInt())];
  IntBuffer buffer=Shape.stride(shapeInformation.asNioInt());
  for (int i=0; i < ret.length; i++)   ret[i]=buffer.get(i);
  return ret;
}","/** 
 * Returns the stride(indices along the linear index for which each slice is accessed) of this array
 * @return the stride of this array
 */
@Override public int[] stride(){
  int[] ret=new int[Shape.rank(shapeInformation)];
  DataBuffer buffer=Shape.stride(shapeInformation);
  for (int i=0; i < ret.length; i++)   ret[i]=buffer.getInt(i);
  return ret;
}"
3265,"/** 
 * Dimshuffle: an extension of permute that adds the ability to broadcast various dimensions. <p/> See theano for more examples. This will only accept integers and xs. <p/> An x indicates a dimension should be broadcasted rather than permuted.
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray dimShuffle(Object[] rearrange,int[] newOrder,boolean[] broadCastable){
  if (broadCastable.length != Shape.rank(shapeInformation.asNioInt()))   throw new IllegalArgumentException(""String_Node_Str"");
  boolean broadcast=false;
  Set<Object> set=new HashSet<>();
  for (int i=0; i < rearrange.length; i++) {
    set.add(rearrange[i]);
    if (rearrange[i] instanceof Integer) {
      Integer j=(Integer)rearrange[i];
      if (j >= broadCastable.length)       throw new IllegalArgumentException(""String_Node_Str"");
    }
 else     if (rearrange[i] instanceof Character) {
      Character c=(Character)rearrange[i];
      if (c != 'x')       throw new IllegalArgumentException(""String_Node_Str"");
      broadcast=true;
    }
 else     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!broadcast) {
    int[] ret=new int[rearrange.length];
    for (int i=0; i < ret.length; i++)     ret[i]=(Integer)rearrange[i];
    return permute(ret);
  }
 else {
    List<Integer> drop=new ArrayList<>();
    for (int i=0; i < broadCastable.length; i++) {
      if (!set.contains(i)) {
        if (broadCastable[i])         drop.add(i);
 else         throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    int[] shuffle=new int[broadCastable.length];
    int count=0;
    for (int i=0; i < rearrange.length; i++) {
      if (rearrange[i] instanceof Integer) {
        shuffle[count++]=(Integer)rearrange[i];
      }
    }
    List<Integer> augment=new ArrayList<>();
    for (int i=0; i < rearrange.length; i++) {
      if (rearrange[i] instanceof Character)       augment.add(i);
    }
    Integer[] augmentDims=augment.toArray(new Integer[1]);
    count=0;
    int dropIdx=0;
    int[] newShape=new int[shuffle.length + drop.size()];
    for (int i=0; i < newShape.length; i++) {
      if (i < shuffle.length) {
        newShape[count++]=shuffle[i];
      }
 else       newShape[count++]=drop.get(dropIdx++);
    }
    INDArray ret=permute(newShape);
    List<Integer> newDims=new ArrayList<>();
    int[] shape=Arrays.copyOfRange(ret.shape(),0,shuffle.length);
    for (int i=0; i < shape.length; i++) {
      newDims.add(shape[i]);
    }
    for (int i=0; i < augmentDims.length; i++) {
      newDims.add(augmentDims[i],1);
    }
    int[] toReshape=ArrayUtil.toArray(newDims);
    ret=ret.reshape(toReshape);
    return ret;
  }
}","/** 
 * Dimshuffle: an extension of permute that adds the ability to broadcast various dimensions. <p/> See theano for more examples. This will only accept integers and xs. <p/> An x indicates a dimension should be broadcasted rather than permuted.
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray dimShuffle(Object[] rearrange,int[] newOrder,boolean[] broadCastable){
  if (broadCastable.length != Shape.rank(shapeInformation))   throw new IllegalArgumentException(""String_Node_Str"");
  boolean broadcast=false;
  Set<Object> set=new HashSet<>();
  for (int i=0; i < rearrange.length; i++) {
    set.add(rearrange[i]);
    if (rearrange[i] instanceof Integer) {
      Integer j=(Integer)rearrange[i];
      if (j >= broadCastable.length)       throw new IllegalArgumentException(""String_Node_Str"");
    }
 else     if (rearrange[i] instanceof Character) {
      Character c=(Character)rearrange[i];
      if (c != 'x')       throw new IllegalArgumentException(""String_Node_Str"");
      broadcast=true;
    }
 else     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!broadcast) {
    int[] ret=new int[rearrange.length];
    for (int i=0; i < ret.length; i++)     ret[i]=(Integer)rearrange[i];
    return permute(ret);
  }
 else {
    List<Integer> drop=new ArrayList<>();
    for (int i=0; i < broadCastable.length; i++) {
      if (!set.contains(i)) {
        if (broadCastable[i])         drop.add(i);
 else         throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    int[] shuffle=new int[broadCastable.length];
    int count=0;
    for (int i=0; i < rearrange.length; i++) {
      if (rearrange[i] instanceof Integer) {
        shuffle[count++]=(Integer)rearrange[i];
      }
    }
    List<Integer> augment=new ArrayList<>();
    for (int i=0; i < rearrange.length; i++) {
      if (rearrange[i] instanceof Character)       augment.add(i);
    }
    Integer[] augmentDims=augment.toArray(new Integer[1]);
    count=0;
    int dropIdx=0;
    int[] newShape=new int[shuffle.length + drop.size()];
    for (int i=0; i < newShape.length; i++) {
      if (i < shuffle.length) {
        newShape[count++]=shuffle[i];
      }
 else       newShape[count++]=drop.get(dropIdx++);
    }
    INDArray ret=permute(newShape);
    List<Integer> newDims=new ArrayList<>();
    int[] shape=Arrays.copyOfRange(ret.shape(),0,shuffle.length);
    for (int i=0; i < shape.length; i++) {
      newDims.add(shape[i]);
    }
    for (int i=0; i < augmentDims.length; i++) {
      newDims.add(augmentDims[i],1);
    }
    int[] toReshape=ArrayUtil.toArray(newDims);
    ret=ret.reshape(toReshape);
    return ret;
  }
}"
3266,"/** 
 * Returns the slice of this from the specified dimension
 * @param slice     the dimension to return from
 * @param dimension the dimension of the slice to return
 * @return the slice of this matrix from the specified dimensionand dimension
 */
@Override public INDArray slice(int slice,int dimension){
  int slices=size(dimension);
  if (slice >= slices)   throw new IllegalArgumentException(""String_Node_Str"" + slice);
  if (Shape.rank(shapeInformation.asNioInt()) == 0) {
    if (slice == 0)     return createScalarForIndex(slice,true);
 else     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (slice < 0)   slice+=rank();
  INDArrayIndex[] indexes=new INDArrayIndex[rank()];
  indexes[dimension]=NDArrayIndex.point(slice);
  for (int i=0; i < rank(); i++) {
    if (i != dimension)     indexes[i]=NDArrayIndex.all();
  }
  return get(indexes);
}","/** 
 * Returns the slice of this from the specified dimension
 * @param slice     the dimension to return from
 * @param dimension the dimension of the slice to return
 * @return the slice of this matrix from the specified dimensionand dimension
 */
@Override public INDArray slice(int slice,int dimension){
  int slices=size(dimension);
  if (slice >= slices)   throw new IllegalArgumentException(""String_Node_Str"" + slice);
  if (Shape.rank(shapeInformation) == 0) {
    if (slice == 0)     return createScalarForIndex(slice,true);
 else     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (slice < 0)   slice+=rank();
  INDArrayIndex[] indexes=new INDArrayIndex[rank()];
  indexes[dimension]=NDArrayIndex.point(slice);
  for (int i=0; i < rank(); i++) {
    if (i != dimension)     indexes[i]=NDArrayIndex.all();
  }
  return get(indexes);
}"
3267,"/** 
 * Returns the number of possible vectors for a given dimension
 * @param dimension the dimension to calculate the number of vectors for
 * @return the number of possible vectors along a dimension
 */
@Override public int vectorsAlongDimension(int dimension){
  if (dimension == 0 && isVector() || isRowVector())   return 1;
  if (size(dimension) == 1 && !isVector()) {
    for (int i=dimension; i < rank(); i++) {
      if (size(i) != 1)       return vectorsAlongDimension(i);
    }
    return length();
  }
 else   if (size(0) == 1 && !isVector()) {
    int realDimension=rank() - getLeadingOnes();
    if (length / size(realDimension) >= Integer.MAX_VALUE)     throw new IllegalArgumentException(""String_Node_Str"");
    return (int)(length / size(realDimension));
  }
  if (dimension >= Shape.rank(shapeInformation.asNioInt())) {
    if (length / size(Shape.rank(shapeInformation.asNioInt()) - 1) >= Integer.MAX_VALUE)     throw new IllegalArgumentException(""String_Node_Str"");
    return (int)(length / size(Shape.rank(shapeInformation.asNioInt()) - 1));
  }
  if (length / size(dimension) >= Integer.MAX_VALUE)   throw new IllegalArgumentException(""String_Node_Str"");
  return (int)(length / size(dimension));
}","/** 
 * Returns the number of possible vectors for a given dimension
 * @param dimension the dimension to calculate the number of vectors for
 * @return the number of possible vectors along a dimension
 */
@Override public int vectorsAlongDimension(int dimension){
  if (dimension == 0 && isVector() || isRowVector())   return 1;
  if (size(dimension) == 1 && !isVector()) {
    for (int i=dimension; i < rank(); i++) {
      if (size(i) != 1)       return vectorsAlongDimension(i);
    }
    return length();
  }
 else   if (size(0) == 1 && !isVector()) {
    int realDimension=rank() - getLeadingOnes();
    if (length / size(realDimension) >= Integer.MAX_VALUE)     throw new IllegalArgumentException(""String_Node_Str"");
    return (int)(length / size(realDimension));
  }
  if (dimension >= Shape.rank(shapeInformation)) {
    if (length / size(Shape.rank(shapeInformation) - 1) >= Integer.MAX_VALUE)     throw new IllegalArgumentException(""String_Node_Str"");
    return (int)(length / size(Shape.rank(shapeInformation) - 1));
  }
  if (length / size(dimension) >= Integer.MAX_VALUE)   throw new IllegalArgumentException(""String_Node_Str"");
  return (int)(length / size(dimension));
}"
3268,"/** 
 * Returns the shape(dimensions) of this array
 * @return the shape of this matrix
 */
public int[] shape(){
  int[] ret=new int[rank()];
  IntBuffer buffer=Shape.shapeOf(shapeInformation.asNioInt());
  for (int i=0; i < ret.length; i++)   ret[i]=buffer.get(i);
  return ret;
}","/** 
 * Returns the shape(dimensions) of this array
 * @return the shape of this matrix
 */
public int[] shape(){
  int[] ret=new int[rank()];
  DataBuffer buffer=Shape.shapeOf(shapeInformation);
  for (int i=0; i < ret.length; i++)   ret[i]=buffer.getInt(i);
  return ret;
}"
3269,"/** 
 * Returns the size of this array along a particular dimension
 * @param dimension the dimension to return from
 * @return the shape of the specified dimension
 */
@Override public int size(int dimension){
  if (isScalar()) {
    if (dimension == 0 || dimension == 1 || dimension < 0)     return (int)length;
 else     throw new IllegalArgumentException(""String_Node_Str"" + dimension);
  }
  if (dimension < 0) {
    return Shape.shapeOf(shapeInformation.asNioInt()).get(dimension + Shape.rank(shapeInformation.asNioInt()));
  }
  return Shape.shapeOf(shapeInformation.asNioInt()).get(dimension);
}","/** 
 * Returns the size of this array along a particular dimension
 * @param dimension the dimension to return from
 * @return the shape of the specified dimension
 */
@Override public int size(int dimension){
  if (isScalar()) {
    if (dimension == 0 || dimension == 1 || dimension < 0)     return (int)length;
 else     throw new IllegalArgumentException(""String_Node_Str"" + dimension);
  }
  if (dimension < 0) {
    return Shape.shapeOf(shapeInformation).getInt(dimension + Shape.rank(shapeInformation));
  }
  return Shape.shapeOf(shapeInformation).getInt(dimension);
}"
3270,"/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.html
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray permute(int... rearrange){
  if (rearrange.length != rank())   return dup();
  boolean alreadyInOrder=true;
  for (int i=0; i < Shape.rank(shapeInfo()); i++) {
    if (rearrange[i] != i) {
      alreadyInOrder=false;
      break;
    }
  }
  if (alreadyInOrder)   return this;
  checkArrangeArray(rearrange);
  int[] newShape=doPermuteSwap(Shape.shapeOf(shapeInformation.asNioInt()),rearrange);
  int[] newStride=doPermuteSwap(Shape.stride(shapeInformation.asNioInt()),rearrange);
  char newOrder=Shape.getOrder(newShape,newStride,elementStride());
  INDArray value=create(data(),newShape,newStride,offset(),newOrder);
  return value;
}","/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.html
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray permute(int... rearrange){
  if (rearrange.length != rank())   return dup();
  boolean alreadyInOrder=true;
  for (int i=0; i < Shape.rank(shapeInfo()); i++) {
    if (rearrange[i] != i) {
      alreadyInOrder=false;
      break;
    }
  }
  if (alreadyInOrder)   return this;
  checkArrangeArray(rearrange);
  int[] newShape=doPermuteSwap(Shape.shapeOf(shapeInformation),rearrange);
  int[] newStride=doPermuteSwap(Shape.stride(shapeInformation),rearrange);
  char newOrder=Shape.getOrder(newShape,newStride,elementStride());
  INDArray value=create(data(),newShape,newStride,offset(),newOrder);
  return value;
}"
3271,"protected int[] doPermuteSwap(IntBuffer shape,int[] rearrange){
  int[] ret=new int[rearrange.length];
  for (int i=0; i < rearrange.length; i++) {
    ret[i]=shape.get(rearrange[i]);
  }
  return ret;
}","protected int[] doPermuteSwap(DataBuffer shape,int[] rearrange){
  int[] ret=new int[rearrange.length];
  for (int i=0; i < rearrange.length; i++) {
    ret[i]=shape.getInt(rearrange[i]);
  }
  return ret;
}"
3272,"/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public INDArray broadcast(int... shape){
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=Shape.rank(shapeInformation.asNioInt()) - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  int[] retShape=new int[shape.length];
  List<Integer> broadCastDimensions=new ArrayList<>();
  List<Integer> nonBroadCastDimensions=new ArrayList<>();
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(1,shape[i]);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],size(i));
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < rank() && size(i) == 1)       broadCastDimensions.add(i);
 else       nonBroadCastDimensions.add(i);
      if (i < shape().length)       retShape[i]=Math.max(shape[i],size(i));
 else       retShape[i]=shape[i];
    }
  }
  INDArray ret=create(retShape,ordering());
  if (isRowVector()) {
    for (int i=0; i < ret.slices(); i++) {
      ret.putSlice(i,this);
    }
  }
 else {
    int repeatDelta=ArrayUtil.prod(retShape) / length();
    for (int i=0; i < slices(); i++) {
      INDArray thisTensor=slice(i);
      INDArray retTensor=ret.slice(i);
      int retIdx=0;
      int tensorLen=thisTensor.rank();
      outer:       for (int k=0; k < tensorLen; k++) {
        for (int j=0; j < repeatDelta; j++) {
          if (retIdx >= retTensor.length())           break outer;
          retTensor.putScalar(retIdx++,thisTensor.getDouble(k));
        }
      }
    }
  }
  return ret;
}","/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public INDArray broadcast(int... shape){
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=Shape.rank(shapeInformation) - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  int[] retShape=new int[shape.length];
  List<Integer> broadCastDimensions=new ArrayList<>();
  List<Integer> nonBroadCastDimensions=new ArrayList<>();
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(1,shape[i]);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],size(i));
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < rank() && size(i) == 1)       broadCastDimensions.add(i);
 else       nonBroadCastDimensions.add(i);
      if (i < shape().length)       retShape[i]=Math.max(shape[i],size(i));
 else       retShape[i]=shape[i];
    }
  }
  INDArray ret=create(retShape,ordering());
  if (isRowVector()) {
    for (int i=0; i < ret.slices(); i++) {
      ret.putSlice(i,this);
    }
  }
 else {
    int repeatDelta=ArrayUtil.prod(retShape) / length();
    for (int i=0; i < slices(); i++) {
      INDArray thisTensor=slice(i);
      INDArray retTensor=ret.slice(i);
      int retIdx=0;
      int tensorLen=thisTensor.rank();
      outer:       for (int k=0; k < tensorLen; k++) {
        for (int j=0; j < repeatDelta; j++) {
          if (retIdx >= retTensor.length())           break outer;
          retTensor.putScalar(retIdx++,thisTensor.getDouble(k));
        }
      }
    }
  }
  return ret;
}"
3273,"/** 
 * Number of columns (shape[1]), throws an exception when called when not 2d
 * @return the number of columns in the array (only 2d)
 */
@Override public int columns(){
  if (isMatrix()) {
    if (shape().length == 2)     return size(1);
  }
  if (isVector()) {
    if (isColumnVector())     return 1;
 else     if (isRowVector() && Shape.rank(shapeInformation.asNioInt()) > 1)     return size(1);
 else     return size(0);
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Number of columns (shape[1]), throws an exception when called when not 2d
 * @return the number of columns in the array (only 2d)
 */
@Override public int columns(){
  if (isMatrix()) {
    if (shape().length == 2)     return size(1);
  }
  if (isVector()) {
    if (isColumnVector())     return 1;
 else     if (isRowVector() && Shape.rank(shapeInformation) > 1)     return size(1);
 else     return size(0);
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
3274,"/** 
 * Get the vector along a particular dimension
 * @param index     the index of the vector to get
 * @param dimension the dimension to get the vector from
 * @return the vector along a particular dimension
 */
@Override public INDArray vectorAlongDimension(int index,int dimension){
  if (dimension < 0)   dimension=Shape.rank(shapeInformation.asNioInt()) + dimension;
  if (dimension == Shape.rank(shapeInformation.asNioInt()) - 1 && size(dimension) == 1 && rank() > 2 || rank() > 2 && dimension == 0 && size(dimension) == 1) {
    return this;
  }
  INDArray ret=tensorAlongDimension(index,dimension);
  if (isMatrix() && ret.isVector() && dimension == 1 && !ret.isRowVector())   return ret.reshape(ArrayUtil.reverseCopy(ret.shape()));
 else   if (isMatrix() && ret.isVector() && dimension == 0 && !ret.isColumnVector())   return ret.reshape(ArrayUtil.reverseCopy(ret.shape()));
  return ret;
}","/** 
 * Get the vector along a particular dimension
 * @param index     the index of the vector to get
 * @param dimension the dimension to get the vector from
 * @return the vector along a particular dimension
 */
@Override public INDArray vectorAlongDimension(int index,int dimension){
  if (dimension < 0)   dimension=Shape.rank(shapeInformation) + dimension;
  if (dimension == Shape.rank(shapeInformation) - 1 && size(dimension) == 1 && rank() > 2 || rank() > 2 && dimension == 0 && size(dimension) == 1) {
    return this;
  }
  INDArray ret=tensorAlongDimension(index,dimension);
  if (isMatrix() && ret.isVector() && dimension == 1 && !ret.isRowVector())   return ret.reshape(ArrayUtil.reverseCopy(ret.shape()));
 else   if (isMatrix() && ret.isVector() && dimension == 0 && !ret.isColumnVector())   return ret.reshape(ArrayUtil.reverseCopy(ret.shape()));
  return ret;
}"
3275,"@Override public int linearIndex(int i){
  setLinearStride();
  int idx=i;
  for (int j=0; j < Shape.rank(shapeInformation.asNioInt()) - 1; j++) {
    if (size(i) == 1)     continue;
    idx+=i * stride(j);
  }
  return Shape.offset(shapeInfo()) + (idx);
}","@Override public int linearIndex(int i){
  setLinearStride();
  int idx=i;
  for (int j=0; j < Shape.rank(shapeInformation) - 1; j++) {
    if (size(i) == 1)     continue;
    idx+=i * stride(j);
  }
  return Shape.offset(shapeInfo()) + (idx);
}"
3276,"@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (stride.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(stride));
  if (Shape.contentEquals(shape,Shape.shapeOf(shapeInformation.asNioInt()))) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int[] dotProductOffsets=offsets;
  int[] dotProductStride=stride;
  int offset=Shape.offset(shapeInfo()) + NDArrayIndex.offset(dotProductStride,dotProductOffsets);
  if (offset >= data().length())   offset=ArrayUtil.sum(offsets);
  return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering());
}","@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (stride.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(stride));
  if (Shape.contentEquals(shape,Shape.shapeOf(shapeInformation))) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int[] dotProductOffsets=offsets;
  int[] dotProductStride=stride;
  int offset=Shape.offset(shapeInfo()) + NDArrayIndex.offset(dotProductStride,dotProductOffsets);
  if (offset >= data().length())   offset=ArrayUtil.sum(offsets);
  return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering());
}"
3277,"/** 
 * Test whether a matrix is scalar.
 */
@Override public boolean isScalar(){
  if (isScalar != null)   return isScalar;
  if (Shape.rank(shapeInfo()) > 2) {
    isScalar=false;
  }
 else   if (Shape.rank(shapeInformation.asNioInt()) == 1) {
    isScalar=Shape.shapeOf(shapeInformation.asNioInt()).get(0) == 1;
  }
 else   if (Shape.rank(shapeInformation.asNioInt()) == 2) {
    isScalar=Shape.shapeOf(shapeInformation.asNioInt()).get(0) == 1 && Shape.shapeOf(shapeInformation.asNioInt()).get(1) == 1;
  }
 else   isScalar=false;
  return isScalar;
}","/** 
 * Test whether a matrix is scalar.
 */
@Override public boolean isScalar(){
  if (isScalar != null)   return isScalar;
  if (Shape.rank(shapeInfo()) > 2) {
    isScalar=false;
  }
 else   if (Shape.rank(shapeInformation) == 1) {
    isScalar=Shape.shapeOf(shapeInformation).getInt(0) == 1;
  }
 else   if (Shape.rank(shapeInformation) == 2) {
    isScalar=Shape.shapeOf(shapeInformation).getInt(0) == 1 && Shape.shapeOf(shapeInformation).getInt(1) == 1;
  }
 else   isScalar=false;
  return isScalar;
}"
3278,"@Override public void setShape(int... shape){
  IntBuffer shapeView=Shape.shapeOf(shapeInformation.asNioInt());
  for (int i=0; i < shape.length; i++) {
    shapeView.put(i,shape[i]);
  }
}","@Override public void setShape(int... shape){
  DataBuffer shapeView=Shape.shapeOf(shapeInformation);
  for (int i=0; i < shape.length; i++) {
    shapeView.put(i,shape[i]);
  }
}"
3279,"@Override public void setStride(int[] stride){
  IntBuffer strideView=Shape.stride(shapeInformation.asNioInt());
  for (int i=0; i < stride.length; i++)   strideView.put(i,stride[i]);
}","@Override public void setStride(int[] stride){
  DataBuffer strideView=Shape.stride(shapeInformation);
  for (int i=0; i < stride.length; i++)   strideView.put(i,stride[i]);
}"
3280,"protected void write(DataOutputStream out) throws IOException {
  out.writeUTF(allocationMode.name());
  out.writeInt(length());
  out.writeUTF(dataType().name());
  if (dataType() == Type.DOUBLE) {
    for (int i=0; i < length(); i++)     out.writeDouble(getDouble(i));
  }
 else {
    for (int i=0; i < length(); i++)     out.writeFloat(getFloat(i));
  }
}","@Override public void write(DataOutputStream out) throws IOException {
  out.writeUTF(allocationMode.name());
  out.writeInt(length());
  out.writeUTF(dataType().name());
  if (dataType() == Type.DOUBLE) {
    for (int i=0; i < length(); i++)     out.writeDouble(getDouble(i));
  }
 else   if (dataType() == Type.INT) {
    for (int i=0; i < length(); i++)     out.writeInt(getInt(i));
  }
 else {
    for (int i=0; i < length(); i++)     out.writeFloat(getFloat(i));
  }
}"
3281,"protected void read(DataInputStream s){
  try {
    referencing=Collections.synchronizedSet(new HashSet<String>());
    dirty=new AtomicBoolean(false);
    allocationMode=AllocationMode.valueOf(s.readUTF());
    length=s.readInt();
    Type t=Type.valueOf(s.readUTF());
    if (t == Type.DOUBLE) {
      if (allocationMode == AllocationMode.HEAP) {
        if (this.dataType() == Type.FLOAT) {
          floatData=new float[length()];
        }
 else         if (this.dataType() == Type.DOUBLE) {
          doubleData=new double[length()];
        }
 else {
          intData=new int[length()];
        }
        for (int i=0; i < length(); i++) {
          put(i,s.readDouble());
        }
      }
 else {
        wrappedBuffer=ByteBuffer.allocateDirect(length() * getElementSize());
        wrappedBuffer.order(ByteOrder.nativeOrder());
        for (int i=0; i < length(); i++) {
          put(i,s.readDouble());
        }
      }
    }
 else {
      if (allocationMode == AllocationMode.HEAP) {
        if (this.dataType() == Type.FLOAT) {
          floatData=new float[length()];
        }
 else         if (this.dataType() == Type.DOUBLE) {
          doubleData=new double[length()];
        }
 else {
          intData=new int[length()];
        }
        for (int i=0; i < length(); i++) {
          put(i,s.readFloat());
        }
      }
 else {
        wrappedBuffer=ByteBuffer.allocateDirect(length() * getElementSize());
        wrappedBuffer.order(ByteOrder.nativeOrder());
        for (int i=0; i < length(); i++) {
          put(i,s.readFloat());
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override public void read(DataInputStream s){
  try {
    referencing=Collections.synchronizedSet(new HashSet<String>());
    dirty=new AtomicBoolean(false);
    allocationMode=AllocationMode.valueOf(s.readUTF());
    length=s.readInt();
    Type t=Type.valueOf(s.readUTF());
    if (t == Type.DOUBLE) {
      if (allocationMode == AllocationMode.HEAP) {
        if (this.dataType() == Type.FLOAT) {
          floatData=new float[length()];
        }
 else         if (this.dataType() == Type.DOUBLE) {
          doubleData=new double[length()];
        }
 else {
          intData=new int[length()];
        }
        for (int i=0; i < length(); i++) {
          put(i,s.readDouble());
        }
      }
 else {
        wrappedBuffer=ByteBuffer.allocateDirect(length() * getElementSize());
        wrappedBuffer.order(ByteOrder.nativeOrder());
        for (int i=0; i < length(); i++) {
          put(i,s.readDouble());
        }
      }
    }
 else     if (t == Type.FLOAT) {
      if (allocationMode == AllocationMode.HEAP) {
        if (this.dataType() == Type.FLOAT) {
          floatData=new float[length()];
        }
 else         if (this.dataType() == Type.DOUBLE) {
          doubleData=new double[length()];
        }
 else {
          intData=new int[length()];
        }
        for (int i=0; i < length(); i++) {
          put(i,s.readFloat());
        }
      }
 else {
        wrappedBuffer=ByteBuffer.allocateDirect(length() * getElementSize());
        wrappedBuffer.order(ByteOrder.nativeOrder());
        for (int i=0; i < length(); i++) {
          put(i,s.readFloat());
        }
      }
    }
 else {
      if (allocationMode == AllocationMode.HEAP) {
        if (this.dataType() == Type.FLOAT) {
          floatData=new float[length()];
        }
 else         if (this.dataType() == Type.DOUBLE) {
          doubleData=new double[length()];
        }
 else {
          intData=new int[length()];
        }
        for (int i=0; i < length(); i++) {
          put(i,s.readInt());
        }
      }
 else {
        wrappedBuffer=ByteBuffer.allocateDirect(length() * getElementSize());
        wrappedBuffer.order(ByteOrder.nativeOrder());
        for (int i=0; i < length(); i++) {
          put(i,s.readInt());
        }
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
3282,"@Test public void testSerialization2() throws Exception {
  INDArray[] arr=new INDArray[]{Nd4j.ones(1,10),Nd4j.ones(5,10).getRow(2)};
  for (  INDArray a : arr) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    try (ObjectOutputStream oos=new ObjectOutputStream(baos)){
      oos.writeObject(a);
    }
     byte[] bytes=baos.toByteArray();
    ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
    ObjectInputStream ois=new ObjectInputStream(bais);
    INDArray aDeserialized=(INDArray)ois.readObject();
    System.out.println(aDeserialized);
    assertEquals(Nd4j.ones(1,10),aDeserialized);
  }
}","@Test public void testSerialization2() throws Exception {
  INDArray[] arr=new INDArray[]{Nd4j.ones(1,10),Nd4j.ones(5,10).getRow(2)};
  for (  INDArray a : arr) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    try (ObjectOutputStream oos=new ObjectOutputStream(baos)){
      oos.writeObject(a);
      oos.flush();
    }
     byte[] bytes=baos.toByteArray();
    ByteArrayInputStream bais=new ByteArrayInputStream(bytes);
    ObjectInputStream ois=new ObjectInputStream(bais);
    INDArray aDeserialized=(INDArray)ois.readObject();
    System.out.println(aDeserialized);
    assertEquals(Nd4j.ones(1,10),aDeserialized);
  }
}"
3283,"@Test public void testNettyCopy(){
  DataBuffer db=Nd4j.createBuffer(new double[]{1,2,3,4});
  if (db.allocationMode() == DataBuffer.AllocationMode.HEAP)   return;
  ByteBuf buf=db.asNetty();
  ByteBuf copy=buf.copy(0,buf.capacity());
  for (int i=0; i < db.length(); i++) {
    assertEquals(db.getDouble(i),copy.getDouble(i * 8));
  }
}","@Test public void testNettyCopy(){
  DataBuffer db=Nd4j.createBuffer(new double[]{1,2,3,4});
  if (db.allocationMode() == DataBuffer.AllocationMode.HEAP)   return;
  ByteBuf buf=db.asNetty();
  ByteBuf copy=buf.copy(0,buf.capacity());
  for (int i=0; i < db.length(); i++) {
    assertEquals(db.getDouble(i),copy.getDouble(i * 8),1e-1);
  }
}"
3284,"@Test public void testReadWrite(){
  DataBuffer assertion=Nd4j.createBuffer(new double[]{1,2,3});
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  assertion.write(dos);
  DataBuffer clone=assertion.dup();
  assertion.read(new DataInputStream(new ByteArrayInputStream(bos.toByteArray())));
  assertEquals(assertion,clone);
}","@Test public void testReadWrite() throws Exception {
  DataBuffer assertion=Nd4j.createBuffer(new double[]{1,2,3});
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  DataOutputStream dos=new DataOutputStream(bos);
  assertion.write(dos);
  DataBuffer clone=assertion.dup();
  assertion.read(new DataInputStream(new ByteArrayInputStream(bos.toByteArray())));
  assertEquals(assertion,clone);
}"
3285,"/** 
 * Create an n x (shape) ndarray where the ndarray is repeated num times
 * @param n   the ndarray to replicate
 * @param num the number of copies to repeat
 * @return the repeated ndarray
 */
public static INDArray repeat(INDArray n,int num){
  List<INDArray> list=new ArrayList<>();
  for (int i=0; i < num; i++)   list.add(n.dup());
  int[] shape=n.isColumnVector() ? new int[]{n.shape()[0]} : n.shape();
  int[] retShape=Ints.concat(new int[]{num},shape);
  return Nd4j.create(list,retShape);
}","/** 
 * Create an n x (shape) ndarray where the ndarray is repeated num times
 * @param n   the ndarray to replicate
 * @param num the number of copies to repeat
 * @return the repeated ndarray
 */
public static INDArray repeat(INDArray n,int num){
  List<INDArray> list=new ArrayList<>();
  for (int i=0; i < num; i++)   list.add(n.dup());
  int[] nShape=n.shape();
  int[] shape=n.isColumnVector() ? new int[]{n.shape()[0]} : nShape;
  int[] retShape=Ints.concat(new int[]{num},shape);
  return Nd4j.create(list,retShape);
}"
3286,"/** 
 * Returns true if this ndarray is 2d or 3d with a singleton element
 * @return true if the element is a matrix, false otherwise
 */
public boolean isMatrix(){
  return (shape().length == 2 && (size(0) != 1 && size(1) != 1));
}","/** 
 * Returns true if this ndarray is 2d or 3d with a singleton element
 * @return true if the element is a matrix, false otherwise
 */
public boolean isMatrix(){
  if (isMatrix != null)   return isMatrix;
  isMatrix=(Shape.rank(shapeInfo()) == 2 && (size(0) != 1 && size(1) != 1));
  return isMatrix;
}"
3287,"/** 
 * Test whether a matrix is scalar.
 */
@Override public boolean isScalar(){
  if (isScalar != null)   return isScalar;
  if (Shape.rank(shapeInformation) > 2)   return false;
  if (Shape.rank(shapeInformation) == 1)   return Shape.shapeOf(shapeInformation).get(0) == 1;
 else   if (Shape.rank(shapeInformation) == 2) {
    return Shape.shapeOf(shapeInformation).get(0) == 1 && Shape.shapeOf(shapeInformation).get(1) == 1;
  }
  isScalar=true;
  return isScalar;
}","/** 
 * Test whether a matrix is scalar.
 */
@Override public boolean isScalar(){
  if (isScalar != null)   return isScalar;
  if (Shape.rank(shapeInfo()) > 2) {
    isScalar=false;
  }
 else   if (Shape.rank(shapeInformation) == 1) {
    isScalar=Shape.shapeOf(shapeInformation).get(0) == 1;
  }
 else   if (Shape.rank(shapeInformation) == 2) {
    isScalar=Shape.shapeOf(shapeInformation).get(0) == 1 && Shape.shapeOf(shapeInformation).get(1) == 1;
  }
  isScalar=false;
  return isScalar;
}"
3288,"private String format(INDArray arr,int rank){
  StringBuffer sb=new StringBuffer();
  if (arr.isScalar()) {
    if (arr instanceof IComplexNDArray)     return ((IComplexNDArray)arr).getComplex(0).toString();
    return decimalFormat.format(arr.getDouble(0));
  }
 else   if (arr.isVector()) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < arr.length(); i++) {
      sb.append(StringUtils.repeat(""String_Node_Str"",rank - 1));
      if (arr instanceof IComplexNDArray)       sb.append(((IComplexNDArray)arr).getComplex(i).toString());
 else       sb.append(decimalFormat.format(arr.getDouble(i)));
      if (i < arr.length() - 1)       sb.append(sep);
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
 else {
    sb.append(""String_Node_Str"");
    for (int i=0; i < arr.slices(); i++) {
      sb.append(format(arr.slice(i),rank - 1));
      if (i < arr.slices() - 1) {
        sb.append(""String_Node_Str"");
        sb.append(StringUtils.repeat(""String_Node_Str"",rank - 1));
      }
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
}","private String format(INDArray arr,int rank){
  if (rank < 1)   return ""String_Node_Str"";
  StringBuffer sb=new StringBuffer();
  if (arr.isScalar()) {
    if (arr instanceof IComplexNDArray)     return ((IComplexNDArray)arr).getComplex(0).toString();
    return decimalFormat.format(arr.getDouble(0));
  }
 else   if (arr.isVector()) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < arr.length(); i++) {
      sb.append(StringUtils.repeat(""String_Node_Str"",rank - 1));
      if (arr instanceof IComplexNDArray)       sb.append(((IComplexNDArray)arr).getComplex(i).toString());
 else       sb.append(decimalFormat.format(arr.getDouble(i)));
      if (i < arr.length() - 1)       sb.append(sep);
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
 else {
    sb.append(""String_Node_Str"");
    for (int i=0; i < arr.slices(); i++) {
      sb.append(format(arr.slice(i),rank - 1));
      if (i < arr.slices() - 1) {
        sb.append(""String_Node_Str"");
        sb.append(StringUtils.repeat(""String_Node_Str"",rank - 1));
      }
    }
    sb.append(""String_Node_Str"");
    return sb.toString();
  }
}"
3289,"/** 
 * Set the value of the ndarray to the specified value
 * @param value the value to assign
 * @return the ndarray with the values
 */
@Override public INDArray assign(Number value){
  data().assign(value,offset());
  return this;
}","/** 
 * Set the value of the ndarray to the specified value
 * @param value the value to assign
 * @return the ndarray with the values
 */
@Override public INDArray assign(Number value){
  Nd4j.getExecutioner().exec(new ScalarSet(this,value));
  return this;
}"
3290,"@Test public void testNdVectorOp(){
  Nd4j.getRandom().setSeed(12345);
  int[] maxShape=new int[]{5,7,9,11,13,15};
  for (int opNum=0; opNum < 6; opNum++) {
    for (int rank=2; rank < maxShape.length; rank++) {
      int[] shape=Arrays.copyOfRange(maxShape,0,rank);
      INDArray orig=Nd4j.rand(shape);
      for (int i=0; i < rank; i++) {
        INDArray arr=orig.dup();
        int eleStride=arr.tensorAlongDimension(0,i).elementWiseStride();
        INDArray vector=i == 0 ? Nd4j.rand(1,shape[i]) : Nd4j.rand(shape[i],1);
        System.out.println(""String_Node_Str"" + rank + ""String_Node_Str""+ i+ ""String_Node_Str""+ vector+ ""String_Node_Str""+ Arrays.toString(arr.shape()));
        BroadcastOp op;
switch (opNum) {
case 0:
          op=new BroadcastAddOp(arr,vector,arr.dup(),i);
        break;
case 1:
      op=new BroadcastCopyOp(arr,vector,arr,i);
    break;
case 2:
  op=new BroadcastDivOp(arr,vector,arr.dup(),i);
break;
case 3:
op=new BroadcastMulOp(arr,vector,arr.dup(),i);
break;
case 4:
op=new BroadcastRDivOp(arr,vector,arr.dup(),i);
break;
case 5:
op=new BroadcastRSubOp(arr,vector,arr.dup(),i);
break;
case 6:
op=new BroadcastSubOp(arr,vector,arr.dup(),i);
break;
default :
throw new RuntimeException();
}
StopWatch watch=new StopWatch();
watch.start();
System.out.println(""String_Node_Str"" + op.name());
Nd4j.getExecutioner().exec(op);
watch.stop();
System.out.println(""String_Node_Str"" + watch.getNanoTime() + ""String_Node_Str""+ op.x().tensorssAlongDimension(i));
INDArray assertion=arr.dup();
for (int j=0; j < arr.tensorssAlongDimension(i); j++) {
switch (opNum) {
case 0:
assertion.tensorAlongDimension(j,i).addi(vector);
break;
case 1:
assertion.tensorAlongDimension(j,i).assign(vector);
break;
case 2:
assertion.tensorAlongDimension(j,i).divi(vector);
break;
case 3:
assertion.tensorAlongDimension(j,i).muli(vector);
break;
case 4:
assertion.tensorAlongDimension(j,i).rdivi(vector);
break;
case 5:
assertion.tensorAlongDimension(j,i).rsubi(vector);
break;
case 6:
assertion.tensorAlongDimension(j,i).subi(vector);
break;
default :
throw new RuntimeException();
}
}
assertEquals(assertion,op.z());
}
}
}
}","@Test public void testNdVectorOp(){
  Nd4j.getRandom().setSeed(12345);
  int[] maxShape=new int[]{5,7,9,11,13,15};
  for (int opNum=0; opNum < 6; opNum++) {
    for (int rank=2; rank < maxShape.length; rank++) {
      int[] shape=Arrays.copyOfRange(maxShape,0,rank);
      INDArray orig=Nd4j.rand(shape);
      for (int i=0; i < rank; i++) {
        INDArray arr=orig.dup();
        INDArray vector=i == 0 ? Nd4j.rand(1,shape[i]) : Nd4j.rand(shape[i],1);
        System.out.println(""String_Node_Str"" + rank + ""String_Node_Str""+ i+ ""String_Node_Str""+ vector+ ""String_Node_Str""+ Arrays.toString(arr.shape()));
        BroadcastOp op;
switch (opNum) {
case 0:
          op=new BroadcastAddOp(arr,vector,arr.dup(),i);
        break;
case 1:
      op=new BroadcastCopyOp(arr,vector,arr,i);
    break;
case 2:
  op=new BroadcastDivOp(arr,vector,arr.dup(),i);
break;
case 3:
op=new BroadcastMulOp(arr,vector,arr.dup(),i);
break;
case 4:
op=new BroadcastRDivOp(arr,vector,arr.dup(),i);
break;
case 5:
op=new BroadcastRSubOp(arr,vector,arr.dup(),i);
break;
case 6:
op=new BroadcastSubOp(arr,vector,arr.dup(),i);
break;
default :
throw new RuntimeException();
}
StopWatch watch=new StopWatch();
watch.start();
System.out.println(""String_Node_Str"" + op.name());
Nd4j.getExecutioner().exec(op);
watch.stop();
System.out.println(""String_Node_Str"" + watch.getNanoTime() + ""String_Node_Str""+ op.x().tensorssAlongDimension(i));
INDArray assertion=arr.dup();
for (int j=0; j < arr.tensorssAlongDimension(i); j++) {
switch (opNum) {
case 0:
assertion.tensorAlongDimension(j,i).addi(vector);
break;
case 1:
assertion.tensorAlongDimension(j,i).assign(vector);
break;
case 2:
assertion.tensorAlongDimension(j,i).divi(vector);
break;
case 3:
assertion.tensorAlongDimension(j,i).muli(vector);
break;
case 4:
assertion.tensorAlongDimension(j,i).rdivi(vector);
break;
case 5:
assertion.tensorAlongDimension(j,i).rsubi(vector);
break;
case 6:
assertion.tensorAlongDimension(j,i).subi(vector);
break;
default :
throw new RuntimeException();
}
}
assertEquals(assertion,op.z());
}
}
}
}"
3291,"@Override public IComplexNumber op(IComplexNumber origin){
  return origin;
}","@Override public IComplexNumber op(IComplexNumber origin){
  return Nd4j.createComplexNumber(origin.absoluteValue(),0);
}"
3292,"@Override public INDArray blockUntilComplete(){
  if (subTasks == null) {
    invokeAsync();
  }
  int[] retShape=ArrayUtil.removeIndex(op.x().shape(),dimensions);
  INDArray out=Nd4j.create(retShape);
  int i=0;
  for (  Task<Double> task : subTasks) {
    out.putScalar(i++,task.blockUntilComplete());
  }
  return out;
}","@Override public INDArray blockUntilComplete(){
  if (subTasks == null) {
    invokeAsync();
  }
  int[] retShape=ArrayUtil.removeIndex(op.x().shape(),dimensions);
  INDArray out=Nd4j.create(retShape);
  int i=0;
  for (  Task<Double> task : subTasks) {
    out.putScalar(i++,task.blockUntilComplete());
  }
  op.setZ(out);
  return out;
}"
3293,"@Override public INDArray blockUntilComplete(){
  if (subTasks == null) {
    invokeAsync();
  }
  int[] retShape=ArrayUtil.removeIndex(op.x().shape(),dimensions);
  INDArray out=Nd4j.create(retShape);
  int i=0;
  for (  Task<Pair<Double,Integer>> task : subTasks) {
    Pair<Double,Integer> result=task.blockUntilComplete();
    out.putScalar(i++,result.getSecond());
  }
  return out;
}","@Override public INDArray blockUntilComplete(){
  if (subTasks == null) {
    invokeAsync();
  }
  int[] retShape=ArrayUtil.removeIndex(op.x().shape(),dimensions);
  INDArray out=Nd4j.create(retShape);
  int i=0;
  for (  Task<Pair<Double,Integer>> task : subTasks) {
    Pair<Double,Integer> result=task.blockUntilComplete();
    out.putScalar(i++,result.getSecond());
  }
  op.setZ(out);
  return out;
}"
3294,"@Override public void invokeAsync(){
  if (n > threshold) {
    int nSubTasks=1 + n / threshold;
    subTasks=new ArrayList<>(nSubTasks);
    int taskSize=n / nSubTasks;
    int soFar=0;
    for (int i=0; i < nSubTasks; i++) {
      int nInTask;
      if (i == nSubTasks - 1) {
        nInTask=n - soFar;
      }
 else {
        nInTask=taskSize;
      }
      int offsetXNew=offsetX + soFar * incrX;
      int offsetYNew=offsetY + soFar * incrY;
      Task<Pair<Double,Integer>> t=new CPUIndexAccumulationTask(op,threshold,nInTask,offsetXNew,offsetYNew,incrX,incrY,soFar,false);
      t.invokeAsync();
      subTasks.add(t);
      soFar+=nInTask;
    }
  }
 else {
    future=TaskExecutorProvider.getTaskExecutor().executeAsync(this);
  }
}","@Override public void invokeAsync(){
  if (n > threshold) {
    int nSubTasks=1 + n / threshold;
    subTasks=new ArrayList<>(nSubTasks);
    int taskSize=n / nSubTasks;
    int soFar=0;
    for (int i=0; i < nSubTasks; i++) {
      int nInTask;
      if (i == nSubTasks - 1) {
        nInTask=n - soFar;
      }
 else {
        nInTask=taskSize;
      }
      int offsetXNew=offsetX + soFar * incrX;
      int offsetYNew=offsetY + soFar * incrY;
      Task<Pair<Double,Integer>> t=new CPUIndexAccumulationTask(op,threshold,nInTask,offsetXNew,offsetYNew,incrX,incrY,elementOffset + soFar,false);
      t.invokeAsync();
      subTasks.add(t);
      soFar+=nInTask;
    }
  }
 else {
    future=TaskExecutorProvider.getTaskExecutor().executeAsync(this);
  }
}"
3295,"@Override public void invokeAsync(){
  INDArray x=op.x();
  INDArray y=op.y();
  int tensorDim;
  if (y == null)   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x);
 else   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x,y);
  int nTensors=x.tensorssAlongDimension(tensorDim);
  subTasks=new ArrayList<>(nTensors);
  if (nTensors == 1) {
    Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,false);
    task.invokeAsync();
    subTasks.add(task);
  }
 else {
    if (x.rank() == 2) {
      OpExecutionerUtil.Tensor1DStats tsx=OpExecutionerUtil.get1DTensorStats(x,tensorDim);
      int n=tsx.getTensorLength();
      int incrX=tsx.getElementWiseStride();
      DataBuffer dx=x.data();
      if (y == null) {
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          int elementOffset=i * tsx.getTensorLength();
          Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,n,offsetX,0,incrX,0,elementOffset,false);
          task.invokeAsync();
          subTasks.add(task);
        }
      }
 else {
        DataBuffer dy=y.data();
        OpExecutionerUtil.Tensor1DStats tsy=OpExecutionerUtil.get1DTensorStats(y,tensorDim);
        int incrY=tsy.getElementWiseStride();
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          int offsetY=tsy.getFirstTensorOffset() + i * tsy.getTensorStartSeparation();
          int elementOffset=i * tsx.getTensorLength();
          Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,n,offsetX,offsetY,incrX,incrY,elementOffset,false);
          task.invokeAsync();
          subTasks.add(task);
        }
      }
    }
 else {
      for (int i=0; i < nTensors; i++) {
        Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,i,tensorDim,false);
        task.invokeAsync();
        subTasks.add(task);
      }
    }
  }
}","@Override public void invokeAsync(){
  INDArray x=op.x();
  INDArray y=op.y();
  int tensorDim=1;
  int nTensors=x.tensorssAlongDimension(tensorDim);
  subTasks=new ArrayList<>(nTensors);
  if (nTensors == 1) {
    Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,false);
    task.invokeAsync();
    subTasks.add(task);
  }
 else {
    if (x.rank() == 2) {
      OpExecutionerUtil.Tensor1DStats tsx=OpExecutionerUtil.get1DTensorStats(x,tensorDim);
      int n=tsx.getTensorLength();
      int incrX=tsx.getElementWiseStride();
      DataBuffer dx=x.data();
      if (y == null) {
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          int elementOffset=i * tsx.getTensorLength();
          Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,n,offsetX,0,incrX,0,elementOffset,false);
          task.invokeAsync();
          subTasks.add(task);
        }
      }
 else {
        DataBuffer dy=y.data();
        OpExecutionerUtil.Tensor1DStats tsy=OpExecutionerUtil.get1DTensorStats(y,tensorDim);
        int incrY=tsy.getElementWiseStride();
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          int offsetY=tsy.getFirstTensorOffset() + i * tsy.getTensorStartSeparation();
          int elementOffset=i * tsx.getTensorLength();
          Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,n,offsetX,offsetY,incrX,incrY,elementOffset,false);
          task.invokeAsync();
          subTasks.add(task);
        }
      }
    }
 else {
      for (int i=0; i < nTensors; i++) {
        Task<Pair<Double,Integer>> task=new CPUIndexAccumulationTask(op,threshold,i,tensorDim,false);
        task.invokeAsync();
        subTasks.add(task);
      }
    }
  }
}"
3296,"public JCudaExecutioner(){
  try {
    SimpleJCublas.init();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  dummyFloatPointer=KernelFunctions.alloc(new float[]{1});
  dummyDoublePointer=KernelFunctions.alloc(new double[]{1});
  parallelExecutioner().setParallelEnabled(false);
}","public JCudaExecutioner(){
  try {
    SimpleJCublas.init();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  dummyFloatPointer=KernelFunctions.alloc(new float[]{1});
  dummyDoublePointer=KernelFunctions.alloc(new double[]{1});
}"
3297,"private void applyVectorOp(INDArray vector,final char operation){
  if (this instanceof IComplexNDArray) {
    IComplexNDArray complexThis=(IComplexNDArray)this;
    IComplexNDArray row=(IComplexNDArray)vector;
    Iterator<int[]> shapes=Shape.isRowVectorShape(vector.shape()) ? new NdIndexIterator('c',shape()) : new NdIndexIterator('f',shape());
    int currVectorPosition=0;
    while (shapes.hasNext()) {
      int[] position=shapes.next();
switch (operation) {
case 'a':
        complexThis.putScalar(position,complexThis.getComplex(position).addi(row.getComplex(currVectorPosition++)));
      break;
case 's':
    complexThis.putScalar(position,complexThis.getComplex(position).subi(row.getComplex(currVectorPosition++)));
  break;
case 'm':
complexThis.putScalar(position,complexThis.getComplex(position).muli(row.getComplex(currVectorPosition++)));
break;
case 'd':
complexThis.putScalar(position,complexThis.getComplex(position).divi(row.getComplex(currVectorPosition++)));
break;
case 'h':
complexThis.putScalar(position,complexThis.getComplex(position).rsubi(row.getComplex(currVectorPosition++)));
break;
case 't':
complexThis.putScalar(position,complexThis.getComplex(position).rdivi(row.getComplex(currVectorPosition++)));
break;
}
if (currVectorPosition >= vector.length()) currVectorPosition=0;
}
}
 else {
int dimension=Shape.isRowVectorShape(vector.shape()) ? 0 : 1;
final INDArray op;
if (vector.data() == data()) op=vector.dup();
 else op=vector;
throw new UnsupportedOperationException(""String_Node_Str"");
}
}","private void applyVectorOp(INDArray vector,final char operation){
  int alongDimension=Shape.isRowVectorShape(vector.shape()) ? 1 : 0;
  if (this.data() == vector.data())   vector=vector.dup();
switch (operation) {
case 'a':
    Nd4j.getExecutioner().exec(new VectorAddOp(this,vector,this,alongDimension));
  return;
case 's':
Nd4j.getExecutioner().exec(new VectorSubOp(this,vector,this,alongDimension));
return;
case 'm':
Nd4j.getExecutioner().exec(new VectorMulOp(this,vector,this,alongDimension));
return;
case 'd':
Nd4j.getExecutioner().exec(new VectorDivOp(this,vector,this,alongDimension));
return;
case 'h':
Nd4j.getExecutioner().exec(new VectorRSubOp(this,vector,this,alongDimension));
return;
case 't':
Nd4j.getExecutioner().exec(new VectorRDivOp(this,vector,this,alongDimension));
return;
case 'p':
Nd4j.getExecutioner().exec(new VectorCopyOp(this,vector,this,alongDimension));
return;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + operation);
}
}"
3298,"public DefaultOpExecutioner(){
  taskFactory=TaskFactoryProvider.getTaskFactory();
}","public DefaultOpExecutioner(){
  taskFactory=Nd4j.getTaskFactory();
}"
3299,"/** 
 * Can we do the transform op (Z = Op(X,Y)) directly on the arrays without breaking them up into 1d tensors first? 
 */
public static boolean canDoOpDirectly(INDArray x,INDArray y,INDArray z){
  if (x.isVector())   return true;
  int l1=x.length();
  int dl1=x.data().length();
  int l2=y.length();
  int dl2=y.data().length();
  int l3=z.length();
  int dl3=z.data().length();
  int[] strides1=x.stride();
  int[] strides2=y.stride();
  int[] strides3=z.stride();
  boolean equalStrides=Arrays.equals(strides1,strides2) && Arrays.equals(strides1,strides3);
  if (l1 == dl1 && l2 == dl2 && l3 == dl3 && equalStrides)   return true;
  if (equalStrides) {
    int[] shape1=x.shape();
    int[] stridesAsInit=(x.ordering() == 'c' ? ArrayUtil.calcStrides(shape1) : ArrayUtil.calcStridesFortran(shape1));
    boolean stridesSameAsInit=Arrays.equals(strides1,stridesAsInit);
    return stridesSameAsInit;
  }
  return false;
}","/** 
 * Can we do the transform op (Z = Op(X,Y)) directly on the arrays without breaking them up into 1d tensors first? 
 */
public static boolean canDoOpDirectly(INDArray x,INDArray y,INDArray z){
  if (x.isVector())   return true;
  if (x.ordering() != y.ordering() || x.ordering() != z.ordering())   return false;
  int l1=x.length();
  int dl1=x.data().length();
  int l2=y.length();
  int dl2=y.data().length();
  int l3=z.length();
  int dl3=z.data().length();
  int[] strides1=x.stride();
  int[] strides2=y.stride();
  int[] strides3=z.stride();
  boolean equalStrides=Arrays.equals(strides1,strides2) && Arrays.equals(strides1,strides3);
  if (l1 == dl1 && l2 == dl2 && l3 == dl3 && equalStrides)   return true;
  if (equalStrides) {
    int[] shape1=x.shape();
    int[] stridesAsInit=(x.ordering() == 'c' ? ArrayUtil.calcStrides(shape1) : ArrayUtil.calcStridesFortran(shape1));
    boolean stridesSameAsInit=Arrays.equals(strides1,stridesAsInit);
    return stridesSameAsInit;
  }
  return false;
}"
3300,"/** 
 * Tensor1DStats, used to efficiently iterate through tensors on a matrix (2d NDArray) for element-wise ops For example, the offset of each 1d tensor can be calculated using only a single tensorAlongDimension method call, hence is potentially faster than approaches requiring multiple tensorAlongDimension calls.<br> Note that this can only (generally) be used for 2d NDArrays. For certain 3+d NDArrays, the tensor starts may not be in increasing order
 */
public static Tensor1DStats get1DTensorStats(INDArray array,int dimension){
  int tensorLength=ArrayUtil.prod(ArrayUtil.removeIndex(array.shape(),dimension));
  int numTensors=array.length() / tensorLength;
  int firstTensorOffset=array.offset();
  int tensorStartSeparation;
  int elementWiseStride;
  if (numTensors == 1) {
    tensorStartSeparation=-1;
    elementWiseStride=array.elementWiseStride();
  }
 else {
    INDArray secondTensor=array.tensorAlongDimension(1,dimension);
    tensorStartSeparation=secondTensor.offset() - firstTensorOffset;
    elementWiseStride=secondTensor.elementWiseStride();
  }
  return new Tensor1DStats(firstTensorOffset,tensorStartSeparation,numTensors,tensorLength,elementWiseStride);
}","/** 
 * Tensor1DStats, used to efficiently iterate through tensors on a matrix (2d NDArray) for element-wise ops For example, the offset of each 1d tensor can be calculated using only a single tensorAlongDimension method call, hence is potentially faster than approaches requiring multiple tensorAlongDimension calls.<br> Note that this can only (generally) be used for 2d NDArrays. For certain 3+d NDArrays, the tensor starts may not be in increasing order
 */
public static Tensor1DStats get1DTensorStats(INDArray array,int dimension){
  int tensorLength=array.size(dimension);
  int numTensors=array.length() / tensorLength;
  int firstTensorOffset=array.offset();
  int tensorStartSeparation;
  int elementWiseStride;
  if (numTensors == 1) {
    tensorStartSeparation=-1;
    elementWiseStride=array.elementWiseStride();
  }
 else {
    INDArray secondTensor=array.tensorAlongDimension(1,dimension);
    tensorStartSeparation=secondTensor.offset() - firstTensorOffset;
    elementWiseStride=secondTensor.elementWiseStride();
  }
  return new Tensor1DStats(firstTensorOffset,tensorStartSeparation,numTensors,tensorLength,elementWiseStride);
}"
3301,"public AddOp(INDArray x,INDArray xDup,INDArray z){
  super(x,xDup,z,x.length());
}","public AddOp(INDArray x,INDArray y,INDArray z){
  super(x,y,z,x.length());
}"
3302,"public DivOp(INDArray x,INDArray z,int n){
  super(x,z,n);
}","public DivOp(INDArray x,INDArray y,INDArray z){
  super(x,y,z,x.length());
}"
3303,"public MulOp(INDArray x,INDArray xDup,INDArray x1){
  super(x,xDup,x1,x.length());
}","public MulOp(INDArray x,INDArray y,INDArray z){
  super(x,y,z,x.length());
}"
3304,"public RDivOp(INDArray x,INDArray z,int n){
  super(x,z,n);
}","public RDivOp(INDArray x,INDArray y,INDArray z){
  super(x,y,z,x.length());
}"
3305,"public RSubOp(INDArray x,INDArray z,int n){
  super(x,z,n);
}","public RSubOp(INDArray x,INDArray y,INDArray z){
  super(x,y,z,x.length());
}"
3306,"public SubOp(INDArray x,INDArray z,int n){
  super(x,z,n);
}","public SubOp(INDArray x,INDArray y,INDArray z){
  super(x,y,z,x.length());
}"
3307,"@Override protected Double compute(){
  int tensorDim;
  if (y == null)   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x);
 else   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x,y);
  int nTensors=x.tensorssAlongDimension(tensorDim);
  if (nTensors == 1) {
    INDArray tx=x.tensorAlongDimension(0,tensorDim);
    INDArray ty=(y != null ? y.tensorAlongDimension(0,tensorDim) : null);
    int offsetX=tx.offset();
    int offsetY=(y != null ? ty.offset() : 0);
    int incrX=tx.elementWiseStride();
    int incrY=(y != null ? ty.elementWiseStride() : 0);
    return op.getAccumulationOpDataBufferTask(threshold,tx.length(),x.data(),(y != null ? y.data() : null),offsetX,offsetY,incrX,incrY,true).invoke();
  }
 else {
    List<AccumulationDataBufferTask> blockList=new ArrayList<>(nTensors);
    if (x.rank() == 2) {
      OpExecutionerUtil.Tensor1DStats tsx=OpExecutionerUtil.get1DTensorStats(x,tensorDim);
      int n=tsx.getTensorLength();
      int incrX=tsx.getElementWiseStride();
      DataBuffer dx=x.data();
      if (y == null) {
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          AccumulationDataBufferTask task=op.getAccumulationOpDataBufferTask(threshold,n,dx,null,offsetX,0,incrX,0,false);
          task.fork();
          blockList.add(task);
        }
      }
 else {
        DataBuffer dy=y.data();
        OpExecutionerUtil.Tensor1DStats tsy=OpExecutionerUtil.get1DTensorStats(y,tensorDim);
        int incrY=tsy.getElementWiseStride();
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          int offsetY=tsy.getFirstTensorOffset() + i * tsy.getTensorStartSeparation();
          AccumulationDataBufferTask task=op.getAccumulationOpDataBufferTask(threshold,n,dx,dy,offsetX,offsetY,incrX,incrY,false);
          task.fork();
          blockList.add(task);
        }
      }
    }
 else {
      for (int i=0; i < nTensors; i++) {
        AccumulationDataBufferTask task=op.getAccumulationOpDataBufferTask(i,tensorDim,threshold,x,y,false);
        task.fork();
        blockList.add(task);
      }
    }
    double accum=op.zeroDouble();
    for (    AccumulationDataBufferTask task : blockList) {
      double subAccum=task.join();
      accum=op.combineSubResults(accum,subAccum);
    }
    return op.getAndSetFinalResult(accum);
  }
}","@Override protected Double compute(){
  int tensorDim;
  if (y == null)   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x);
 else   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x,y);
  int nTensors=x.tensorssAlongDimension(tensorDim);
  if (nTensors == 1) {
    INDArray tx=x.tensorAlongDimension(0,tensorDim);
    INDArray ty=(y != null ? y.tensorAlongDimension(0,tensorDim) : null);
    int offsetX=tx.offset();
    int offsetY=(y != null ? ty.offset() : 0);
    int incrX=tx.elementWiseStride();
    int incrY=(y != null ? ty.elementWiseStride() : 0);
    double accum=op.getAccumulationOpDataBufferTask(threshold,tx.length(),x.data(),(y != null ? y.data() : null),offsetX,offsetY,incrX,incrY,true).invoke();
    return op.getAndSetFinalResult(accum);
  }
 else {
    List<AccumulationDataBufferTask> blockList=new ArrayList<>(nTensors);
    if (x.rank() == 2) {
      OpExecutionerUtil.Tensor1DStats tsx=OpExecutionerUtil.get1DTensorStats(x,tensorDim);
      int n=tsx.getTensorLength();
      int incrX=tsx.getElementWiseStride();
      DataBuffer dx=x.data();
      if (y == null) {
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          AccumulationDataBufferTask task=op.getAccumulationOpDataBufferTask(threshold,n,dx,null,offsetX,0,incrX,0,false);
          task.fork();
          blockList.add(task);
        }
      }
 else {
        DataBuffer dy=y.data();
        OpExecutionerUtil.Tensor1DStats tsy=OpExecutionerUtil.get1DTensorStats(y,tensorDim);
        int incrY=tsy.getElementWiseStride();
        for (int i=0; i < nTensors; i++) {
          int offsetX=tsx.getFirstTensorOffset() + i * tsx.getTensorStartSeparation();
          int offsetY=tsy.getFirstTensorOffset() + i * tsy.getTensorStartSeparation();
          AccumulationDataBufferTask task=op.getAccumulationOpDataBufferTask(threshold,n,dx,dy,offsetX,offsetY,incrX,incrY,false);
          task.fork();
          blockList.add(task);
        }
      }
    }
 else {
      for (int i=0; i < nTensors; i++) {
        AccumulationDataBufferTask task=op.getAccumulationOpDataBufferTask(i,tensorDim,threshold,x,y,false);
        task.fork();
        blockList.add(task);
      }
    }
    double accum=op.zeroDouble();
    for (    AccumulationDataBufferTask task : blockList) {
      double subAccum=task.join();
      accum=op.combineSubResults(accum,subAccum);
    }
    return op.getAndSetFinalResult(accum);
  }
}"
3308,"@Override public double doTask(){
  if (y != null) {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float[] yf=(float[])y.array();
        float accum=op.zeroFloat();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i],yf[offsetY + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i * incrX],yf[offsetY + i * incrY]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        double[] xd=(double[])x.array();
        double[] yd=(double[])y.array();
        double accum=op.zeroDouble();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i],yd[offsetY + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i * incrX],yd[offsetY + i * incrY]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        float accum=op.zeroFloat();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i),nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i * incrX),nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        double accum=op.zeroDouble();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i),nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i * incrX),nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
  }
 else {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float accum=op.zeroFloat();
        if (incrX == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i * incrX]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        double[] xd=(double[])x.array();
        double accum=op.zeroDouble();
        if (incrX == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i * incrX]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        float accum=op.zeroFloat();
        if (incrX == 1) {
          for (int i=0; i < n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i));
          }
        }
 else {
          for (int i=0; i < n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i * incrX));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        int byteOffsetX=8 * offsetX;
        double accum=op.zeroDouble();
        if (incrX == 1) {
          for (int i=0; i < n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i));
          }
        }
 else {
          for (int i=0; i < n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i * incrX));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
  }
}","@Override public double doTask(){
  if (y != null) {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float[] yf=(float[])y.array();
        float accum=op.zeroFloat();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i],yf[offsetY + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i * incrX],yf[offsetY + i * incrY]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        double[] xd=(double[])x.array();
        double[] yd=(double[])y.array();
        double accum=op.zeroDouble();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i],yd[offsetY + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i * incrX],yd[offsetY + i * incrY]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        float accum=op.zeroFloat();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i),nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i * incrX),nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        double accum=op.zeroDouble();
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i),nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i * incrX),nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
  }
 else {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float accum=op.zeroFloat();
        if (incrX == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xf[offsetX + i * incrX]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        double[] xd=(double[])x.array();
        double accum=op.zeroDouble();
        if (incrX == 1) {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i]);
          }
        }
 else {
          for (int i=0; i < n; i++) {
            accum=op.update(accum,xd[offsetX + i * incrX]);
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        float accum=op.zeroFloat();
        if (incrX == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            accum=op.update(accum,nbbx.getFloat(byteOffsetX + i * incrX));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
 else {
        int byteOffsetX=8 * offsetX;
        double accum=op.zeroDouble();
        if (incrX == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            accum=op.update(accum,nbbx.getDouble(byteOffsetX + i * incrX));
          }
        }
        return (outerTask ? op.getAndSetFinalResult(accum) : accum);
      }
    }
  }
}"
3309,"@Override public double doTask(){
  return Nd4j.getBlasWrapper().level1().dot(n,x,offsetX,incrX,y,offsetY,incrY);
}","@Override public double doTask(){
  if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
    double accum=Nd4j.getBlasWrapper().level1().dot(n,x,offsetX,incrX,y,offsetY,incrY);
    if (outerTask)     return op.getAndSetFinalResult(accum);
    return accum;
  }
 else {
    ByteBuf nbbx=x.asNetty();
    ByteBuf nbby=y.asNetty();
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float accum=op.zeroFloat();
      int byteOffsetX=4 * offsetX;
      int byteOffsetY=4 * offsetY;
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < 4 * n; i+=4) {
          accum=op.update(accum,nbbx.getFloat(byteOffsetX + i),nbby.getFloat(byteOffsetY + i));
        }
      }
 else {
        for (int i=0; i < 4 * n; i+=4) {
          accum=op.update(accum,nbbx.getFloat(byteOffsetX + i * incrX),nbby.getFloat(byteOffsetY + i * incrY));
        }
      }
      if (outerTask)       return op.getAndSetFinalResult(accum);
      return accum;
    }
 else {
      double accum=op.zeroDouble();
      int byteOffsetX=8 * offsetX;
      int byteOffsetY=8 * offsetY;
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < 8 * n; i+=8) {
          accum=op.update(accum,nbbx.getDouble(byteOffsetX + i),nbby.getDouble(byteOffsetY + i));
        }
      }
 else {
        for (int i=0; i < 8 * n; i+=8) {
          accum=op.update(accum,nbbx.getDouble(byteOffsetX + i * incrX),nbby.getDouble(byteOffsetY + i * incrY));
        }
      }
      if (outerTask)       return op.getAndSetFinalResult(accum);
      return accum;
    }
  }
}"
3310,"@Override public double doTask(){
  double sum=op.zeroDouble();
  if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      if (incrX == 1) {
        for (int i=0; i < n; i++) {
          sum+=xf[offsetX + i];
        }
      }
 else {
        for (int i=0; i < n; i++) {
          sum+=xf[offsetX + i * incrX];
        }
      }
    }
 else {
      double[] xd=(double[])x.array();
      if (incrX == 1) {
        for (int i=0; i < n; i++) {
          sum+=xd[offsetX + i];
        }
      }
 else {
        for (int i=0; i < n; i++) {
          sum+=xd[offsetX + i * incrX];
        }
      }
    }
  }
 else {
    ByteBuf nbbx=x.asNetty();
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      int byteOffsetX=4 * offsetX;
      if (incrX == 1) {
        for (int i=0; i < n; i+=4) {
          sum+=nbbx.getFloat(byteOffsetX + i);
        }
      }
 else {
        for (int i=0; i < n; i+=4) {
          sum+=nbbx.getFloat(byteOffsetX + i * incrX);
        }
      }
    }
 else {
      int byteOffsetX=8 * offsetX;
      if (incrX == 1) {
        for (int i=0; i < n; i+=8) {
          sum+=nbbx.getDouble(byteOffsetX + i);
        }
      }
 else {
        for (int i=0; i < n; i+=8) {
          sum+=nbbx.getDouble(byteOffsetX + i * incrX);
        }
      }
    }
  }
  return (outerTask ? op.getAndSetFinalResult(sum) : sum);
}","@Override public double doTask(){
  double sum=op.zeroDouble();
  if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      if (incrX == 1) {
        for (int i=0; i < n; i++) {
          sum+=xf[offsetX + i];
        }
      }
 else {
        for (int i=0; i < n; i++) {
          sum+=xf[offsetX + i * incrX];
        }
      }
    }
 else {
      double[] xd=(double[])x.array();
      if (incrX == 1) {
        for (int i=0; i < n; i++) {
          sum+=xd[offsetX + i];
        }
      }
 else {
        for (int i=0; i < n; i++) {
          sum+=xd[offsetX + i * incrX];
        }
      }
    }
  }
 else {
    ByteBuf nbbx=x.asNetty();
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      int byteOffsetX=4 * offsetX;
      if (incrX == 1) {
        for (int i=0; i < 4 * n; i+=4) {
          sum+=nbbx.getFloat(byteOffsetX + i);
        }
      }
 else {
        for (int i=0; i < 4 * n; i+=4) {
          sum+=nbbx.getFloat(byteOffsetX + i * incrX);
        }
      }
    }
 else {
      int byteOffsetX=8 * offsetX;
      if (incrX == 1) {
        for (int i=0; i < 8 * n; i+=8) {
          sum+=nbbx.getDouble(byteOffsetX + i);
        }
      }
 else {
        for (int i=0; i < 8 * n; i+=8) {
          sum+=nbbx.getDouble(byteOffsetX + i * incrX);
        }
      }
    }
  }
  return (outerTask ? op.getAndSetFinalResult(sum) : sum);
}"
3311,"private void doTransformOp(TransformOp op){
  INDArray x=op.x();
  INDArray y=op.y();
  INDArray z=op.z();
  if (y != null) {
    if (!(x instanceof IComplexNDArray) && !(z instanceof IComplexNDArray)) {
      boolean canDoDirectly;
      if (x == z) {
        if (y == null)         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x);
 else         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,y);
      }
 else {
        if (y == null)         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,z);
 else         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,y,z);
      }
      if (canDoDirectly) {
        op.getTransformOpDataBufferAction(PARALLEL_THRESHOLD,op.n(),x.data(),y.data(),z.data(),x.offset(),y.offset(),z.offset(),x.elementWiseStride(),y.elementWiseStride(),z.elementWiseStride()).invoke();
      }
 else {
        new TransformViaTensorDataBufferTask(op,PARALLEL_THRESHOLD,x,y,z).invoke();
      }
    }
 else {
      if (z instanceof IComplexNDArray) {
        IComplexNDArray cz=(IComplexNDArray)z;
        if (x instanceof IComplexNDArray) {
          IComplexNDArray cx=(IComplexNDArray)x;
          if (y instanceof IComplexNDArray) {
            IComplexNDArray cy=(IComplexNDArray)y;
            for (int i=0; i < op.n(); i++) {
              cz.putScalar(i,op.op(cx.getComplex(i),cy.getComplex(i)));
            }
          }
 else {
            for (int i=0; i < op.n(); i++) {
              cz.putScalar(i,op.op(cx.getComplex(i),y.getDouble(i)));
            }
          }
        }
      }
 else {
        throw new UnsupportedOperationException(""String_Node_Str"" + x.getClass().getName() + ""String_Node_Str""+ y.getClass().getName());
      }
    }
  }
 else {
    if (!(x instanceof IComplexNDArray) && !(z instanceof IComplexNDArray)) {
      boolean canDoDirectly;
      if (x == z)       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x);
 else       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,z);
      if (canDoDirectly) {
        op.getTransformOpDataBufferAction(PARALLEL_THRESHOLD,x.length(),x.data(),null,z.data(),x.offset(),0,z.offset(),x.elementWiseStride(),0,z.elementWiseStride()).invoke();
        return;
      }
 else {
        new TransformViaTensorDataBufferTask(op,PARALLEL_THRESHOLD,x,null,z).invoke();
        return;
      }
    }
 else {
      if (z instanceof IComplexNDArray) {
        IComplexNDArray cz=(IComplexNDArray)z;
        if (x instanceof IComplexNDArray) {
          IComplexNDArray cx=(IComplexNDArray)x;
          for (int i=0; i < op.n(); i++) {
            cz.putScalar(i,op.op(cx.getComplex(i)));
          }
        }
 else {
          for (int i=0; i < op.n(); i++) {
            cz.putScalar(i,op.op(x.getDouble(i)));
          }
        }
      }
    }
  }
}","private void doTransformOp(TransformOp op){
  INDArray x=op.x();
  INDArray y=op.y();
  INDArray z=op.z();
  if (y != null) {
    if (!(x instanceof IComplexNDArray) && !(z instanceof IComplexNDArray)) {
      boolean canDoDirectly;
      if (x == z) {
        if (y == null)         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x);
 else         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,y);
      }
 else {
        if (y == null)         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,z);
 else         canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,y,z);
      }
      if (canDoDirectly) {
        op.getTransformOpDataBufferAction(PARALLEL_THRESHOLD,op.n(),x.data(),y.data(),z.data(),x.offset(),y.offset(),z.offset(),x.elementWiseStride(),y.elementWiseStride(),z.elementWiseStride()).invoke();
      }
 else {
        new TransformViaTensorDataBufferAction(op,PARALLEL_THRESHOLD,x,y,z).invoke();
      }
    }
 else {
      if (z instanceof IComplexNDArray) {
        IComplexNDArray cz=(IComplexNDArray)z;
        if (x instanceof IComplexNDArray) {
          IComplexNDArray cx=(IComplexNDArray)x;
          if (y instanceof IComplexNDArray) {
            IComplexNDArray cy=(IComplexNDArray)y;
            for (int i=0; i < op.n(); i++) {
              cz.putScalar(i,op.op(cx.getComplex(i),cy.getComplex(i)));
            }
          }
 else {
            for (int i=0; i < op.n(); i++) {
              cz.putScalar(i,op.op(cx.getComplex(i),y.getDouble(i)));
            }
          }
        }
      }
 else {
        throw new UnsupportedOperationException(""String_Node_Str"" + x.getClass().getName() + ""String_Node_Str""+ y.getClass().getName());
      }
    }
  }
 else {
    if (!(x instanceof IComplexNDArray) && !(z instanceof IComplexNDArray)) {
      boolean canDoDirectly;
      if (x == z)       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x);
 else       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,z);
      if (canDoDirectly) {
        op.getTransformOpDataBufferAction(PARALLEL_THRESHOLD,x.length(),x.data(),null,z.data(),x.offset(),0,z.offset(),x.elementWiseStride(),0,z.elementWiseStride()).invoke();
        return;
      }
 else {
        new TransformViaTensorDataBufferAction(op,PARALLEL_THRESHOLD,x,null,z).invoke();
        return;
      }
    }
 else {
      if (z instanceof IComplexNDArray) {
        IComplexNDArray cz=(IComplexNDArray)z;
        if (x instanceof IComplexNDArray) {
          IComplexNDArray cx=(IComplexNDArray)x;
          for (int i=0; i < op.n(); i++) {
            cz.putScalar(i,op.op(cx.getComplex(i)));
          }
        }
 else {
          for (int i=0; i < op.n(); i++) {
            cz.putScalar(i,op.op(x.getDouble(i)));
          }
        }
      }
    }
  }
}"
3312,"@Override protected INDArray compute(){
  INDArray x=op.x();
  INDArray y=op.y();
  DataBuffer dx=x.data();
  DataBuffer dy=(y != null ? y.data() : null);
  int nTensors=x.tensorssAlongDimension(dimensions);
  List<RecursiveTask<Double>> taskList=new ArrayList<>(nTensors);
  boolean canDoDirectly=false;
  for (int i=0; i < nTensors; i++) {
    Accumulation opOnDimension=(Accumulation)op.opForDimension(i,dimensions);
    INDArray x2=opOnDimension.x();
    INDArray y2=opOnDimension.y();
    if (i == 0) {
      if (y2 == null)       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2);
 else       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2,y2);
    }
    RecursiveTask<Double> task;
    if (canDoDirectly) {
      if (y != null) {
        task=opOnDimension.getAccumulationOpDataBufferTask(parallelThreshold,opOnDimension.n(),dx,dy,x2.offset(),y2.offset(),x2.elementWiseStride(),y2.elementWiseStride(),true);
      }
 else {
        task=opOnDimension.getAccumulationOpDataBufferTask(parallelThreshold,opOnDimension.n(),dx,null,x2.offset(),0,x2.elementWiseStride(),0,true);
      }
    }
 else {
      task=new AccumulationViaTensorDataBufferTask(opOnDimension,parallelThreshold,x2,y2);
    }
    task.fork();
    taskList.add(task);
  }
  int[] retShape=ArrayUtil.removeIndex(x.shape(),dimensions);
  INDArray out=Nd4j.create(retShape);
  int i=0;
  for (  RecursiveTask<Double> task : taskList) {
    out.putScalar(i++,task.join());
  }
  return out;
}","@Override protected Double compute(){
  Accumulation opOnDimension=(Accumulation)op.opForDimension(tensorNum,dimensions);
  INDArray x2=opOnDimension.x();
  INDArray y2=opOnDimension.y();
  boolean canDoDirectly;
  if (y2 == null)   canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2);
 else   canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2,y2);
  RecursiveTask<Double> task;
  if (canDoDirectly) {
    if (y2 != null) {
      task=opOnDimension.getAccumulationOpDataBufferTask(parallelThreshold,opOnDimension.n(),x2.data(),y2.data(),x2.offset(),y2.offset(),x2.elementWiseStride(),y2.elementWiseStride(),true);
    }
 else {
      task=opOnDimension.getAccumulationOpDataBufferTask(parallelThreshold,opOnDimension.n(),x2.data(),null,x2.offset(),0,x2.elementWiseStride(),0,true);
    }
  }
 else {
    task=new AccumulationViaTensorDataBufferTask(opOnDimension,parallelThreshold,x2,y2);
  }
  return task.invoke();
}"
3313,"@Override protected INDArray compute(){
  INDArray x=op.x();
  INDArray y=op.y();
  DataBuffer dx=x.data();
  DataBuffer dy=(y != null ? y.data() : null);
  int nTensors=x.tensorssAlongDimension(dimensions);
  List<RecursiveTask<Pair<Double,Integer>>> taskList=new ArrayList<>(nTensors);
  boolean canDoDirectly=false;
  for (int i=0; i < nTensors; i++) {
    IndexAccumulation opOnDimension=(IndexAccumulation)op.opForDimension(i,dimensions);
    INDArray x2=opOnDimension.x();
    INDArray y2=opOnDimension.y();
    if (i == 0) {
      if (y2 == null)       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2);
 else       canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2,y2);
    }
    RecursiveTask<Pair<Double,Integer>> task;
    if (canDoDirectly) {
      if (y != null) {
        task=opOnDimension.getIndexAccumulationOpDataBufferTask(0,opOnDimension.n(),dx,dy,x2.offset(),y2.offset(),x2.elementWiseStride(),y2.elementWiseStride(),0,true);
      }
 else {
        task=opOnDimension.getIndexAccumulationOpDataBufferTask(0,opOnDimension.n(),dx,null,x2.offset(),0,x2.elementWiseStride(),0,0,true);
      }
    }
 else {
      task=new IndexAccumulationViaTensorDataBufferTask(opOnDimension,parallelThreshold,x2,y2);
    }
    task.fork();
    taskList.add(task);
  }
  int[] retShape=ArrayUtil.removeIndex(x.shape(),dimensions);
  INDArray out=Nd4j.create(retShape);
  int i=0;
  for (  RecursiveTask<Pair<Double,Integer>> task : taskList) {
    Pair<Double,Integer> pair=task.join();
    out.putScalar(i++,pair.getSecond());
  }
  return out;
}","@Override protected Pair<Double,Integer> compute(){
  IndexAccumulation opOnDimension=(IndexAccumulation)op.opForDimension(tensorNum,dimensions);
  INDArray x2=opOnDimension.x();
  INDArray y2=opOnDimension.y();
  boolean canDoDirectly;
  if (y2 == null)   canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2);
 else   canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x2,y2);
  RecursiveTask<Pair<Double,Integer>> task;
  if (canDoDirectly) {
    if (y2 != null) {
      task=opOnDimension.getIndexAccumulationOpDataBufferTask(parallelThreshold,opOnDimension.n(),x2.data(),y2.data(),x2.offset(),y2.offset(),x2.elementWiseStride(),y2.elementWiseStride(),0,true);
    }
 else {
      task=opOnDimension.getIndexAccumulationOpDataBufferTask(parallelThreshold,opOnDimension.n(),x2.data(),null,x2.offset(),0,x2.elementWiseStride(),0,0,true);
    }
  }
 else {
    task=new IndexAccumulationViaTensorDataBufferTask(opOnDimension,parallelThreshold,x2,y2);
  }
  return task.invoke();
}"
3314,"@Override public void doTask(){
  if (x == z) {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      Nd4j.getBlasWrapper().level1().axpy(n,1.0,y,offsetY,incrY,x,offsetX,incrX);
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i;
            nbbx.setFloat(ox,nbbx.getFloat(ox) + nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setFloat(ox,x.getFloat(ox) + y.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i;
            nbbx.setDouble(ox,nbbx.getDouble(ox) + nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setDouble(ox,nbbx.getDouble(ox) + nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
 else {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float[] yf=(float[])y.array();
        float[] zf=(float[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i]=xf[offsetX + i] + yf[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i * incrZ]=xf[offsetX + i * incrX] + yf[offsetY + i * incrY];
          }
        }
      }
 else {
        double[] xd=(double[])x.array();
        double[] yd=(double[])y.array();
        double[] zd=(double[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i]=xd[offsetX + i] + yd[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i * incrZ]=xd[offsetX + i * incrX] + yd[offsetY + i * incrY];
          }
        }
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      ByteBuf nbbz=z.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        int byteOffsetZ=4 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i,nbbx.getFloat(byteOffsetX + i) + nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i * incrZ,x.getFloat(byteOffsetX + i * incrX) + y.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        int byteOffsetZ=8 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i,nbbx.getDouble(byteOffsetX + i) + nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i * incrZ,nbbx.getDouble(byteOffsetX + i * incrX) + nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
}","@Override public void doTask(){
  if (x == z) {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      Nd4j.getBlasWrapper().level1().axpy(n,1.0,y,offsetY,incrY,x,offsetX,incrX);
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i;
            nbbx.setFloat(ox,nbbx.getFloat(ox) + nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setFloat(ox,nbbx.getFloat(ox) + nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i;
            nbbx.setDouble(ox,nbbx.getDouble(ox) + nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setDouble(ox,nbbx.getDouble(ox) + nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
 else {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float[] yf=(float[])y.array();
        float[] zf=(float[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i]=xf[offsetX + i] + yf[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i * incrZ]=xf[offsetX + i * incrX] + yf[offsetY + i * incrY];
          }
        }
      }
 else {
        double[] xd=(double[])x.array();
        double[] yd=(double[])y.array();
        double[] zd=(double[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i]=xd[offsetX + i] + yd[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i * incrZ]=xd[offsetX + i * incrX] + yd[offsetY + i * incrY];
          }
        }
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      ByteBuf nbbz=z.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        int byteOffsetZ=4 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i,nbbx.getFloat(byteOffsetX + i) + nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i * incrZ,nbbx.getFloat(byteOffsetX + i * incrX) + nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        int byteOffsetZ=8 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i,nbbx.getDouble(byteOffsetX + i) + nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i * incrZ,nbbx.getDouble(byteOffsetX + i * incrX) + nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
}"
3315,"@Override public void doTask(){
  if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      float[] yf=(float[])y.array();
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xf[offsetX + i]*=yf[offsetY + i];
          }
        }
 else {
          float[] zf=(float[])z.array();
          for (int i=0; i < n; i++) {
            zf[offsetZ + i]=xf[offsetX + i] * yf[offsetY + i];
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xf[offsetX + i * incrX]*=yf[offsetY + i * incrY];
          }
        }
 else {
          float[] zf=(float[])z.array();
          for (int i=0; i < n; i++) {
            zf[offsetZ + i * incrZ]=xf[offsetX + i * incrX] * yf[offsetY + i * incrY];
          }
        }
      }
    }
 else {
      double[] xd=(double[])x.array();
      double[] yd=(double[])y.array();
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xd[offsetX + i]*=yd[offsetY + i];
          }
        }
 else {
          double[] zd=(double[])z.array();
          for (int i=0; i < n; i++) {
            zd[offsetZ + i]=xd[offsetX + i] * yd[offsetY + i];
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xd[offsetX + i * incrX]*=yd[offsetY + i * incrY];
          }
        }
 else {
          double[] zd=(double[])z.array();
          for (int i=0; i < n; i++) {
            zd[offsetZ + i * incrZ]=xd[offsetX + i * incrX] * yd[offsetY + i * incrY];
          }
        }
      }
    }
  }
 else {
    ByteBuf nbbx=x.asNetty();
    ByteBuf nbby=y.asNetty();
    ByteBuf nbbz=z.asNetty();
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      int byteOffsetX=4 * offsetX;
      int byteOffsetY=4 * offsetY;
      int byteOffsetZ=4 * offsetZ;
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < 4 * n; i+=4) {
            int xbIdx=byteOffsetX + i;
            nbbx.setFloat(xbIdx,nbbx.getFloat(xbIdx) * nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i,nbbx.getFloat(byteOffsetX + i) * nbby.getFloat(byteOffsetY + i));
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < 4 * n; i+=4) {
            int xbIdx=byteOffsetX + i * incrX;
            nbbx.setFloat(xbIdx,nbbx.getFloat(xbIdx) * nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i * incrZ,x.getFloat(byteOffsetX + i * incrX) * y.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
    }
 else {
      int byteOffsetX=8 * offsetX;
      int byteOffsetY=8 * offsetY;
      int byteOffsetZ=8 * offsetZ;
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < 8 * n; i+=8) {
            int xbIdx=byteOffsetX + i;
            nbbx.setDouble(xbIdx,nbbx.getDouble(xbIdx) * nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i,nbbx.getDouble(byteOffsetX + i) * nbby.getDouble(byteOffsetY + i));
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < 8 * n; i+=8) {
            int xbIdx=byteOffsetX + i * incrX;
            nbbx.setDouble(xbIdx,nbbx.getDouble(xbIdx) * nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i * incrZ,nbbx.getDouble(byteOffsetX + i * incrX) * nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
}","@Override public void doTask(){
  if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      float[] yf=(float[])y.array();
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xf[offsetX + i]*=yf[offsetY + i];
          }
        }
 else {
          float[] zf=(float[])z.array();
          for (int i=0; i < n; i++) {
            zf[offsetZ + i]=xf[offsetX + i] * yf[offsetY + i];
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xf[offsetX + i * incrX]*=yf[offsetY + i * incrY];
          }
        }
 else {
          float[] zf=(float[])z.array();
          for (int i=0; i < n; i++) {
            zf[offsetZ + i * incrZ]=xf[offsetX + i * incrX] * yf[offsetY + i * incrY];
          }
        }
      }
    }
 else {
      double[] xd=(double[])x.array();
      double[] yd=(double[])y.array();
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xd[offsetX + i]*=yd[offsetY + i];
          }
        }
 else {
          double[] zd=(double[])z.array();
          for (int i=0; i < n; i++) {
            zd[offsetZ + i]=xd[offsetX + i] * yd[offsetY + i];
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < n; i++) {
            xd[offsetX + i * incrX]*=yd[offsetY + i * incrY];
          }
        }
 else {
          double[] zd=(double[])z.array();
          for (int i=0; i < n; i++) {
            zd[offsetZ + i * incrZ]=xd[offsetX + i * incrX] * yd[offsetY + i * incrY];
          }
        }
      }
    }
  }
 else {
    ByteBuf nbbx=x.asNetty();
    ByteBuf nbby=y.asNetty();
    ByteBuf nbbz=z.asNetty();
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      int byteOffsetX=4 * offsetX;
      int byteOffsetY=4 * offsetY;
      int byteOffsetZ=4 * offsetZ;
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < 4 * n; i+=4) {
            int xbIdx=byteOffsetX + i;
            nbbx.setFloat(xbIdx,nbbx.getFloat(xbIdx) * nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i,nbbx.getFloat(byteOffsetX + i) * nbby.getFloat(byteOffsetY + i));
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < 4 * n; i+=4) {
            int xbIdx=byteOffsetX + i * incrX;
            nbbx.setFloat(xbIdx,nbbx.getFloat(xbIdx) * nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i * incrZ,nbbx.getFloat(byteOffsetX + i * incrX) * nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
    }
 else {
      int byteOffsetX=8 * offsetX;
      int byteOffsetY=8 * offsetY;
      int byteOffsetZ=8 * offsetZ;
      if (incrX == 1 && incrY == 1 && (x == z || incrZ == 1)) {
        if (x == z) {
          for (int i=0; i < 8 * n; i+=8) {
            int xbIdx=byteOffsetX + i;
            nbbx.setDouble(xbIdx,nbbx.getDouble(xbIdx) * nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i,nbbx.getDouble(byteOffsetX + i) * nbby.getDouble(byteOffsetY + i));
          }
        }
      }
 else {
        if (x == z) {
          for (int i=0; i < 8 * n; i+=8) {
            int xbIdx=byteOffsetX + i * incrX;
            nbbx.setDouble(xbIdx,nbbx.getDouble(xbIdx) * nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i * incrZ,nbbx.getDouble(byteOffsetX + i * incrX) * nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
}"
3316,"@Override public void doTask(){
  if (x == z) {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      Nd4j.getBlasWrapper().level1().axpy(n,-1.0,y,offsetY,incrY,z,offsetZ,incrZ);
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i;
            nbbx.setFloat(ox,nbbx.getFloat(ox) - nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setFloat(ox,x.getFloat(ox) - y.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i;
            nbbx.setDouble(ox,nbbx.getDouble(ox) - nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setDouble(ox,nbbx.getDouble(ox) - nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
 else {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float[] yf=(float[])y.array();
        float[] zf=(float[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i]=xf[offsetX + i] - yf[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i * incrZ]=xf[offsetX + i * incrX] - yf[offsetY + i * incrY];
          }
        }
      }
 else {
        double[] xd=(double[])x.array();
        double[] yd=(double[])y.array();
        double[] zd=(double[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i]=xd[offsetX + i] - yd[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i * incrZ]=xd[offsetX + i * incrX] - yd[offsetY + i * incrY];
          }
        }
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      ByteBuf nbbz=z.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        int byteOffsetZ=4 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i,nbbx.getFloat(byteOffsetX + i) - nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i * incrZ,x.getFloat(byteOffsetX + i * incrX) - y.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        int byteOffsetZ=8 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i,nbbx.getDouble(byteOffsetX + i) - nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i * incrZ,nbbx.getDouble(byteOffsetX + i * incrX) - nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
}","@Override public void doTask(){
  if (x == z) {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      Nd4j.getBlasWrapper().level1().axpy(n,-1.0,y,offsetY,incrY,z,offsetZ,incrZ);
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i;
            nbbx.setFloat(ox,nbbx.getFloat(ox) - nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setFloat(ox,nbbx.getFloat(ox) - nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        if (incrX == 1 && incrY == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i;
            nbbx.setDouble(ox,nbbx.getDouble(ox) - nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            int ox=byteOffsetX + i * incrX;
            nbbx.setDouble(ox,nbbx.getDouble(ox) - nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
 else {
    if (x.allocationMode() == DataBuffer.AllocationMode.HEAP) {
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        float[] xf=(float[])x.array();
        float[] yf=(float[])y.array();
        float[] zf=(float[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i]=xf[offsetX + i] - yf[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zf[offsetZ + i * incrZ]=xf[offsetX + i * incrX] - yf[offsetY + i * incrY];
          }
        }
      }
 else {
        double[] xd=(double[])x.array();
        double[] yd=(double[])y.array();
        double[] zd=(double[])z.array();
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i]=xd[offsetX + i] - yd[offsetY + i];
          }
        }
 else {
          for (int i=0; i < n; i++) {
            zd[offsetZ + i * incrZ]=xd[offsetX + i * incrX] - yd[offsetY + i * incrY];
          }
        }
      }
    }
 else {
      ByteBuf nbbx=x.asNetty();
      ByteBuf nbby=y.asNetty();
      ByteBuf nbbz=z.asNetty();
      if (x.dataType() == DataBuffer.Type.FLOAT) {
        int byteOffsetX=4 * offsetX;
        int byteOffsetY=4 * offsetY;
        int byteOffsetZ=4 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i,nbbx.getFloat(byteOffsetX + i) - nbby.getFloat(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 4 * n; i+=4) {
            nbbz.setFloat(byteOffsetZ + i * incrZ,nbbx.getFloat(byteOffsetX + i * incrX) - nbby.getFloat(byteOffsetY + i * incrY));
          }
        }
      }
 else {
        int byteOffsetX=8 * offsetX;
        int byteOffsetY=8 * offsetY;
        int byteOffsetZ=8 * offsetZ;
        if (incrX == 1 && incrY == 1 && incrZ == 1) {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i,nbbx.getDouble(byteOffsetX + i) - nbby.getDouble(byteOffsetY + i));
          }
        }
 else {
          for (int i=0; i < 8 * n; i+=8) {
            nbbz.setDouble(byteOffsetZ + i * incrZ,nbbx.getDouble(byteOffsetX + i * incrX) - nbby.getDouble(byteOffsetY + i * incrY));
          }
        }
      }
    }
  }
}"
3317,"@Test public void testOpExecutionerTransformOps() throws Exception {
  final DataBuffer.AllocationMode origAlloc=Nd4j.alloc;
  DefaultOpExecutioner opExec=(DefaultOpExecutioner)Nd4j.getExecutioner();
  List<Class<? extends TransformOp>> testClasses=new ArrayList<>();
  testClasses.add(AddOp.class);
  testClasses.add(CopyOp.class);
  testClasses.add(MulOp.class);
  testClasses.add(DivOp.class);
  testClasses.add(RDivOp.class);
  testClasses.add(RSubOp.class);
  testClasses.add(SubOp.class);
  testClasses.add(Tanh.class);
  testClasses.add(Sigmoid.class);
  testClasses.add(RectifedLinear.class);
  testClasses.add(SoftMax.class);
  int[] shape={30,50};
  for (  DataBuffer.Type dtype : DataBuffer.Type.values()) {
    Nd4j.dtype=dtype;
    Nd4j.factory().setDType(dtype);
    Nd4j.getRandom().setSeed(12345);
    INDArray origFirst=Nd4j.rand(shape);
    INDArray origSecond=Nd4j.rand(shape);
    for (    Class<? extends TransformOp> opClass : testClasses) {
      String msg=""String_Node_Str"" + opClass.getName() + ""String_Node_Str""+ dtype;
      Constructor<? extends TransformOp> xyzConstructor=opClass.getConstructor(INDArray.class,INDArray.class,INDArray.class);
      DefaultOpExecutioner.setParallelThreshold(Integer.MAX_VALUE);
      Nd4j.alloc=DataBuffer.AllocationMode.HEAP;
      INDArray x1=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y1=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray z1=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      TransformOp op=xyzConstructor.newInstance(x1,y1,z1);
      opExec.exec(op);
      assertEquals(x1,origFirst);
      assertEquals(y1,origSecond);
      INDArray x2=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y2=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      op=xyzConstructor.newInstance(x2,y2,x2);
      opExec.exec(op);
      assertEquals(y2,origSecond);
      assertEquals(x2,z1);
      if (!op.isPassThrough()) {
        INDArray x1a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y1a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray z1a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x1a,y1a,z1a);
        new TransformViaTensorDataBufferTask(op,Integer.MAX_VALUE,x1a,y1a,z1a).invoke();
        assertEquals(msg,x1a,origFirst);
        assertEquals(msg,y1a,origSecond);
        assertEquals(msg,z1a,z1);
        INDArray x2a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y2a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x2a,y2a,x2a);
        new TransformViaTensorDataBufferTask(op,Integer.MAX_VALUE,x2a,y2a,x2a).invoke();
        assertEquals(msg,y2a,origSecond);
        assertEquals(msg,x2a,z1);
      }
      DefaultOpExecutioner.setParallelThreshold(5);
      Nd4j.alloc=DataBuffer.AllocationMode.HEAP;
      INDArray x3=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y3=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray z3=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      op=xyzConstructor.newInstance(x3,y3,z3);
      opExec.exec(op);
      assertEquals(msg,x3,origFirst);
      assertEquals(msg,y3,origSecond);
      assertEquals(msg,z3,z1);
      INDArray x4=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y4=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      op=xyzConstructor.newInstance(x4,y4,x4);
      opExec.exec(op);
      assertEquals(msg,y4,origSecond);
      assertEquals(msg,x4,z1);
      if (!op.isPassThrough()) {
        INDArray x3a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y3a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray z3a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x3a,y3a,z3a);
        new TransformViaTensorDataBufferTask(op,5,x3a,y3a,z3a).invoke();
        assertEquals(msg,x3a,origFirst);
        assertEquals(msg,y3a,origSecond);
        assertEquals(msg,z3a,z1);
        INDArray x4a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y4a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x4a,y4a,x4a);
        new TransformViaTensorDataBufferTask(op,5,x4a,y4a,x4a).invoke();
        assertEquals(msg,y4a,origSecond);
        assertEquals(msg,x4a,z1);
      }
      DefaultOpExecutioner.setParallelThreshold(Integer.MAX_VALUE);
      Nd4j.alloc=DataBuffer.AllocationMode.DIRECT;
      INDArray x5=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y5=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray z5=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x5,y5,z5);
      opExec.exec(op);
      assertEquals(msg,x5,origFirst);
      assertEquals(msg,y5,origSecond);
      assertEquals(msg,z5,z1);
      INDArray x6=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y6=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x6,y6,x6);
      opExec.exec(op);
      assertEquals(msg,y6,origSecond);
      assertEquals(msg,x6,z1);
      if (!op.isPassThrough()) {
        INDArray x5a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y5a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray z5a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x5a,y5a,z5a);
        new TransformViaTensorDataBufferTask(op,Integer.MAX_VALUE,x5a,y5a,z5a).invoke();
        assertEquals(msg,x5a,origFirst);
        assertEquals(msg,y5a,origSecond);
        assertEquals(msg,z5a,z5);
        INDArray x6a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y6a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x6a,y6a,x6a);
        new TransformViaTensorDataBufferTask(op,Integer.MAX_VALUE,x6a,y6a,x6a).invoke();
        assertEquals(msg,y6a,origSecond);
        assertEquals(msg,x6a,z1);
      }
      DefaultOpExecutioner.setParallelThreshold(5);
      Nd4j.alloc=DataBuffer.AllocationMode.DIRECT;
      INDArray x7=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y7=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray z7=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x7,y7,z7);
      opExec.exec(op);
      assertEquals(msg,x7,origFirst);
      assertEquals(msg,y7,origSecond);
      assertEquals(msg,z7,z1);
      INDArray x8=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y8=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x8,y8,x8);
      opExec.exec(op);
      assertEquals(msg,y8,origSecond);
      assertEquals(msg,x8,z1);
      if (!op.isPassThrough()) {
        INDArray x7a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y7a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray z7a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x7a,y7a,z7a);
        new TransformViaTensorDataBufferTask(op,5,x7a,y7a,z7a).invoke();
        assertEquals(msg,x7a,origFirst);
        assertEquals(msg,y7a,origSecond);
        assertEquals(msg,z7a,z1);
        INDArray x8a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y8a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x8a,y8a,x8a);
        new TransformViaTensorDataBufferTask(op,5,x8a,y8a,x8a).invoke();
        assertEquals(msg,y8a,origSecond);
        assertEquals(msg,x8a,z1);
      }
    }
  }
  Nd4j.alloc=origAlloc;
}","@Test public void testOpExecutionerTransformOps() throws Exception {
  final DataBuffer.AllocationMode origAlloc=Nd4j.alloc;
  DefaultOpExecutioner opExec=(DefaultOpExecutioner)Nd4j.getExecutioner();
  List<Class<? extends TransformOp>> testClasses=new ArrayList<>();
  testClasses.add(AddOp.class);
  testClasses.add(CopyOp.class);
  testClasses.add(MulOp.class);
  testClasses.add(DivOp.class);
  testClasses.add(RDivOp.class);
  testClasses.add(RSubOp.class);
  testClasses.add(SubOp.class);
  testClasses.add(Tanh.class);
  testClasses.add(Sigmoid.class);
  testClasses.add(RectifedLinear.class);
  testClasses.add(SoftMax.class);
  int[] shape={30,50};
  for (  DataBuffer.Type dtype : DataBuffer.Type.values()) {
    Nd4j.dtype=dtype;
    Nd4j.factory().setDType(dtype);
    Nd4j.getRandom().setSeed(12345);
    INDArray origFirst=Nd4j.rand(shape);
    INDArray origSecond=Nd4j.rand(shape);
    for (    Class<? extends TransformOp> opClass : testClasses) {
      String msg=""String_Node_Str"" + opClass.getName() + ""String_Node_Str""+ dtype;
      Constructor<? extends TransformOp> xyzConstructor=opClass.getConstructor(INDArray.class,INDArray.class,INDArray.class);
      DefaultOpExecutioner.setParallelThreshold(Integer.MAX_VALUE);
      Nd4j.alloc=DataBuffer.AllocationMode.HEAP;
      INDArray x1=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y1=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray z1=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      TransformOp op=xyzConstructor.newInstance(x1,y1,z1);
      opExec.exec(op);
      assertEquals(x1,origFirst);
      assertEquals(y1,origSecond);
      INDArray x2=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y2=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      op=xyzConstructor.newInstance(x2,y2,x2);
      opExec.exec(op);
      assertEquals(y2,origSecond);
      assertEquals(x2,z1);
      if (!op.isPassThrough()) {
        INDArray x1a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y1a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray z1a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x1a,y1a,z1a);
        new TransformViaTensorDataBufferAction(op,Integer.MAX_VALUE,x1a,y1a,z1a).invoke();
        assertEquals(msg,x1a,origFirst);
        assertEquals(msg,y1a,origSecond);
        assertEquals(msg,z1a,z1);
        INDArray x2a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y2a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x2a,y2a,x2a);
        new TransformViaTensorDataBufferAction(op,Integer.MAX_VALUE,x2a,y2a,x2a).invoke();
        assertEquals(msg,y2a,origSecond);
        assertEquals(msg,x2a,z1);
      }
      DefaultOpExecutioner.setParallelThreshold(5);
      Nd4j.alloc=DataBuffer.AllocationMode.HEAP;
      INDArray x3=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y3=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray z3=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      op=xyzConstructor.newInstance(x3,y3,z3);
      opExec.exec(op);
      assertEquals(msg,x3,origFirst);
      assertEquals(msg,y3,origSecond);
      assertEquals(msg,z3,z1);
      INDArray x4=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
      INDArray y4=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
      op=xyzConstructor.newInstance(x4,y4,x4);
      opExec.exec(op);
      assertEquals(msg,y4,origSecond);
      assertEquals(msg,x4,z1);
      if (!op.isPassThrough()) {
        INDArray x3a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y3a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray z3a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x3a,y3a,z3a);
        new TransformViaTensorDataBufferAction(op,5,x3a,y3a,z3a).invoke();
        assertEquals(msg,x3a,origFirst);
        assertEquals(msg,y3a,origSecond);
        assertEquals(msg,z3a,z1);
        INDArray x4a=getCopyOf(origFirst,DataBuffer.AllocationMode.HEAP,dtype);
        INDArray y4a=getCopyOf(origSecond,DataBuffer.AllocationMode.HEAP,dtype);
        op=xyzConstructor.newInstance(x4a,y4a,x4a);
        new TransformViaTensorDataBufferAction(op,5,x4a,y4a,x4a).invoke();
        assertEquals(msg,y4a,origSecond);
        assertEquals(msg,x4a,z1);
      }
      DefaultOpExecutioner.setParallelThreshold(Integer.MAX_VALUE);
      Nd4j.alloc=DataBuffer.AllocationMode.DIRECT;
      INDArray x5=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y5=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray z5=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x5,y5,z5);
      opExec.exec(op);
      assertEquals(msg,x5,origFirst);
      assertEquals(msg,y5,origSecond);
      assertEquals(msg,z5,z1);
      INDArray x6=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y6=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x6,y6,x6);
      opExec.exec(op);
      assertEquals(msg,y6,origSecond);
      assertEquals(msg,x6,z1);
      if (!op.isPassThrough()) {
        INDArray x5a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y5a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray z5a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x5a,y5a,z5a);
        new TransformViaTensorDataBufferAction(op,Integer.MAX_VALUE,x5a,y5a,z5a).invoke();
        assertEquals(msg,x5a,origFirst);
        assertEquals(msg,y5a,origSecond);
        assertEquals(msg,z5a,z5);
        INDArray x6a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y6a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x6a,y6a,x6a);
        new TransformViaTensorDataBufferAction(op,Integer.MAX_VALUE,x6a,y6a,x6a).invoke();
        assertEquals(msg,y6a,origSecond);
        assertEquals(msg,x6a,z1);
      }
      DefaultOpExecutioner.setParallelThreshold(5);
      Nd4j.alloc=DataBuffer.AllocationMode.DIRECT;
      INDArray x7=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y7=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray z7=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x7,y7,z7);
      opExec.exec(op);
      assertEquals(msg,x7,origFirst);
      assertEquals(msg,y7,origSecond);
      assertEquals(msg,z7,z1);
      INDArray x8=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
      INDArray y8=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
      op=xyzConstructor.newInstance(x8,y8,x8);
      opExec.exec(op);
      assertEquals(msg,y8,origSecond);
      assertEquals(msg,x8,z1);
      if (!op.isPassThrough()) {
        INDArray x7a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y7a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray z7a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x7a,y7a,z7a);
        new TransformViaTensorDataBufferAction(op,5,x7a,y7a,z7a).invoke();
        assertEquals(msg,x7a,origFirst);
        assertEquals(msg,y7a,origSecond);
        assertEquals(msg,z7a,z1);
        INDArray x8a=getCopyOf(origFirst,DataBuffer.AllocationMode.DIRECT,dtype);
        INDArray y8a=getCopyOf(origSecond,DataBuffer.AllocationMode.DIRECT,dtype);
        op=xyzConstructor.newInstance(x8a,y8a,x8a);
        new TransformViaTensorDataBufferAction(op,5,x8a,y8a,x8a).invoke();
        assertEquals(msg,y8a,origSecond);
        assertEquals(msg,x8a,z1);
      }
    }
  }
  Nd4j.alloc=origAlloc;
}"
3318,"private void doAccumulationOp(Accumulation op){
  if (op.x().data().allocationMode() == DataBuffer.AllocationMode.HEAP) {
    INDArray x=op.x();
    INDArray y=op.y();
    boolean canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(op.x());
    if (canDoDirectly) {
      new BufferOps.AccumulationOpDataBufferTask(op,PARALLEL_THRESHOLD,x.length(),x.data(),(y != null ? y.data() : null),x.offset(),y.offset(),x.elementWiseStride(),(y != null ? y.elementWiseStride() : 0),true).invoke();
    }
 else {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}","private void doAccumulationOp(Accumulation op){
  if (op.x().data().allocationMode() == DataBuffer.AllocationMode.HEAP) {
    INDArray x=op.x();
    INDArray y=op.y();
    boolean canDoDirectly;
    if (y == null)     canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x);
 else     canDoDirectly=OpExecutionerUtil.canDoTransformOpDirectly(x,y);
    if (canDoDirectly) {
      if (y == null) {
        new BufferOps.AccumulationOpDataBufferTask(op,PARALLEL_THRESHOLD,x.length(),x.data(),null,x.offset(),0,x.elementWiseStride(),0,true).invoke();
      }
 else {
        new BufferOps.AccumulationOpDataBufferTask(op,PARALLEL_THRESHOLD,x.length(),x.data(),y.data(),x.offset(),y.offset(),x.elementWiseStride(),y.elementWiseStride(),true).invoke();
      }
      return;
    }
 else {
      new BufferOps.AccumulationViaTensorDataBufferTask(op,PARALLEL_THRESHOLD,x,y).invoke();
    }
  }
 else {
    if (op.y() != null && Shape.opIsWholeBufferWithMatchingStrides(op)) {
      double accum=op.zeroDouble();
      DataBuffer dx=op.x().data();
      DataBuffer dy=op.y().data();
      for (int i=0; i < op.n(); i++) {
        accum=op.update(accum,dx.getDouble(i),dy.getDouble(i));
      }
    }
 else     if (Shape.opIsWholeBufferWithMatchingStrides(op)) {
      double accum=op.zeroDouble();
      DataBuffer dx=op.x().data();
      for (int i=0; i < op.n(); i++) {
        accum=op.update(accum,dx.getDouble(i));
      }
    }
 else     if (!(op.x() instanceof IComplexNDArray)) {
      IComplexNumber accum=op.zeroComplex();
      if (op.y() != null) {
        INDArray xLinear=op.x().reshape(1,op.x().length());
        INDArray yLinear=op.y().reshape(1,op.y().length());
        for (int i=0; i < op.n(); i++) {
          accum=op.update(accum,xLinear.getDouble(0,i),yLinear.getDouble(0,i));
        }
      }
 else {
        INDArray xLinear=op.x().reshape(1,op.x().length());
        for (int i=0; i < op.n(); i++) {
          accum=op.update(accum,xLinear.getDouble(0,i));
        }
      }
    }
 else {
      for (int c=0; c < op.n(); c++) {
        apply(op,c);
      }
    }
  }
}"
3319,"@Override protected Double compute(){
  if (n > threshold) {
    int nFirst=n / 2;
    BaseAccumulationDataBufferTask t1=getSubTask(threshold,nFirst,x,y,offsetX,offsetY,incrX,incrY,false);
    int nSecond=n - nFirst;
    int offsetX2=offsetX + nFirst * incrX;
    int offsetY2=offsetY + nFirst * incrY;
    BaseAccumulationDataBufferTask t2=getSubTask(threshold,nSecond,x,y,offsetX2,offsetY2,incrX,incrY,false);
    t1.fork();
    t2.fork();
    double first=t1.join();
    double second=t2.join();
    double preFinalResult=op.combineSubResults(first,second);
    if (outerTask)     return op.getFinalResult(preFinalResult);
 else     return preFinalResult;
  }
 else {
    return doTask();
  }
}","@Override protected Double compute(){
  int tensorDim;
  if (y == null)   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x);
 else   tensorDim=OpExecutionerUtil.chooseElementWiseTensorDimension(x,y);
  int nTensors=x.tensorssAlongDimension(tensorDim);
  if (nTensors == 1) {
    return new AccumulationOpDataBufferTask(op,0,tensorDim,threshold,x,y,true).invoke();
  }
 else {
    List<AccumulationOpDataBufferTask> blockList=new ArrayList<>(nTensors);
    for (int i=0; i < nTensors; i++) {
      AccumulationOpDataBufferTask task=new AccumulationOpDataBufferTask(op,i,tensorDim,threshold,x,y,false);
      task.fork();
    }
    double accum=op.zeroDouble();
    for (    AccumulationOpDataBufferTask task : blockList) {
      double subAccum=task.join();
      op.combineSubResults(accum,subAccum);
    }
    return op.getFinalResult(accum);
  }
}"
3320,"@Override public double doTask(){
  if (y != null) {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      float[] yf=(float[])y.array();
      float accum=op.zeroFloat();
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i],yf[offsetY + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i * incrX],yf[offsetY + i * incrY]);
        }
      }
      return accum;
    }
 else {
      double[] xd=(double[])x.array();
      double[] yd=(double[])y.array();
      double accum=op.zeroDouble();
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i],yd[offsetY + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i * incrX],yd[offsetY + i * incrY]);
        }
      }
      return accum;
    }
  }
 else {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      float accum=op.zeroFloat();
      if (incrX == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i * incrX]);
        }
      }
      return accum;
    }
 else {
      double[] xd=(double[])x.array();
      double accum=op.zeroDouble();
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i * incrX]);
        }
      }
      return accum;
    }
  }
}","@Override public double doTask(){
  if (y != null) {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      float[] yf=(float[])y.array();
      float accum=op.zeroFloat();
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i],yf[offsetY + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i * incrX],yf[offsetY + i * incrY]);
        }
      }
      return (outerTask ? op.getFinalResult(accum) : accum);
    }
 else {
      double[] xd=(double[])x.array();
      double[] yd=(double[])y.array();
      double accum=op.zeroDouble();
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i],yd[offsetY + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i * incrX],yd[offsetY + i * incrY]);
        }
      }
      return (outerTask ? op.getFinalResult(accum) : accum);
    }
  }
 else {
    if (x.dataType() == DataBuffer.Type.FLOAT) {
      float[] xf=(float[])x.array();
      float accum=op.zeroFloat();
      if (incrX == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xf[offsetX + i * incrX]);
        }
      }
      return (outerTask ? op.getFinalResult(accum) : accum);
    }
 else {
      double[] xd=(double[])x.array();
      double accum=op.zeroDouble();
      if (incrX == 1 && incrY == 1) {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i]);
        }
      }
 else {
        for (int i=0; i < n; i++) {
          accum=op.update(accum,xd[offsetX + i * incrX]);
        }
      }
      return (outerTask ? op.getFinalResult(accum) : accum);
    }
  }
}"
3321,"public AccumulationOpDataBufferTask(Accumulation op,int threshold,int n,DataBuffer x,DataBuffer y,int offsetX,int offsetY,int incrX,int incrY,boolean outerTask){
  super(op,threshold,n,x,y,offsetX,offsetY,incrX,incrY,outerTask);
}","public AccumulationOpDataBufferTask(Accumulation op,int tadIdx,int tadDim,int threshold,INDArray x,INDArray y,boolean outerTask){
  super(op,tadIdx,tadDim,threshold,x,y,outerTask);
}"
3322,"protected static INDArrayIndex validate(int size,INDArrayIndex index){
  if ((index instanceof IntervalIndex || index instanceof PointIndex) && size <= index.current())   throw new IllegalArgumentException(""String_Node_Str"" + index.current() + ""String_Node_Str""+ size);
  if (index instanceof IntervalIndex && size < index.end()) {
    int begin=((IntervalIndex)index).begin;
    index=NDArrayIndex.interval(begin,index.stride(),size);
  }
  return index;
}","protected static INDArrayIndex validate(int size,INDArrayIndex index){
  if ((index instanceof IntervalIndex || index instanceof PointIndex) && size <= index.current() && size > 1)   throw new IllegalArgumentException(""String_Node_Str"" + index.current() + ""String_Node_Str""+ size);
  if (index instanceof IntervalIndex && size < index.end()) {
    int begin=((IntervalIndex)index).begin;
    index=NDArrayIndex.interval(begin,index.stride(),size);
  }
  return index;
}"
3323,"public boolean tryShortCircuit(INDArrayIndex... indexes){
  int pointIndex=0;
  int interval=0;
  int newAxis=0;
  int numAll=0;
  int numSpecified=0;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i] instanceof PointIndex) {
      pointIndex++;
    }
    if (indexes[i] instanceof SpecifiedIndex)     numSpecified++;
 else     if (indexes[i] instanceof IntervalIndex && !(indexes[i] instanceof NDArrayIndexAll))     interval++;
 else     if (indexes[i] instanceof NewAxis)     newAxis++;
 else     if (indexes[i] instanceof NDArrayIndexAll)     numAll++;
  }
  if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex > 0 && numAll > 0) {
    int minDimensions=Math.max(arr.rank() - pointIndex,2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    int offset=0;
    int currIndex=0;
    int arrIndex=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[currIndex]=arr.size(arrIndex);
        stride[currIndex]=arr.stride(arrIndex);
        currIndex++;
        arrIndex++;
      }
 else {
        offset+=indexes[i].offset() * arr.stride(i);
        arrIndex++;
      }
    }
    if (arr.isMatrix() && indexes[0] instanceof PointIndex) {
      shape=ArrayUtil.reverseCopy(shape);
      stride=ArrayUtil.reverseCopy(stride);
    }
    this.strides=stride;
    this.shapes=shape;
    this.offsets=offsets;
    this.offset=offset;
    return true;
  }
 else   if (numSpecified < 1 && interval > 0 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    for (int i=0; i < shape.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[i]=arr.size(i);
        stride[i]=arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
 else       if (indexes[i] instanceof IntervalIndex) {
        shape[i]=indexes[i].length();
        stride[i]=indexes[i].stride() * arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    this.offset=0;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
 else   if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2) + newAxis;
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    int prependNewAxes=0;
    boolean allFirst=false;
    int shapeAxis=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NewAxis) {
        if (allFirst) {
          shape[i]=1;
          stride[i]=0;
        }
 else {
          prependNewAxes++;
        }
      }
 else {
        if (i == 0)         allFirst=true;
        shape[i]=arr.size(shapeAxis + prependNewAxes);
        stride[i]=arr.stride(shapeAxis + prependNewAxes);
        shapeAxis++;
      }
    }
    return true;
  }
  return false;
}","public boolean tryShortCircuit(INDArrayIndex... indexes){
  int pointIndex=0;
  int interval=0;
  int newAxis=0;
  int numAll=0;
  int numSpecified=0;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i] instanceof PointIndex) {
      pointIndex++;
    }
    if (indexes[i] instanceof SpecifiedIndex)     numSpecified++;
 else     if (indexes[i] instanceof IntervalIndex && !(indexes[i] instanceof NDArrayIndexAll))     interval++;
 else     if (indexes[i] instanceof NewAxis)     newAxis++;
 else     if (indexes[i] instanceof NDArrayIndexAll)     numAll++;
  }
  if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex > 0 && numAll > 0) {
    int minDimensions=Math.max(arr.rank() - pointIndex,2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    int offset=0;
    int currIndex=0;
    int arrIndex=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[currIndex]=arr.size(arrIndex);
        stride[currIndex]=arr.stride(arrIndex);
        currIndex++;
        arrIndex++;
      }
 else {
        offset+=indexes[i].offset() * arr.stride(i);
        arrIndex++;
      }
    }
    if (arr.isMatrix() && indexes[0] instanceof PointIndex) {
      shape=ArrayUtil.reverseCopy(shape);
      stride=ArrayUtil.reverseCopy(stride);
    }
    this.strides=stride;
    this.shapes=shape;
    this.offsets=offsets;
    this.offset=offset;
    return true;
  }
 else   if (numSpecified < 1 && interval > 0 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2);
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    for (int i=0; i < shape.length; i++) {
      if (indexes[i] instanceof NDArrayIndexAll) {
        shape[i]=arr.size(i);
        stride[i]=arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
 else       if (indexes[i] instanceof IntervalIndex) {
        shape[i]=indexes[i].length();
        stride[i]=indexes[i].stride() * arr.stride(i);
        offsets[i]=indexes[i].offset();
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    this.offset=0;
    for (int i=0; i < indexes.length; i++) {
      offset+=offsets[i] * (stride[i] / indexes[i].stride());
    }
    return true;
  }
 else   if (numSpecified < 1 && interval < 1 && newAxis < 1 && pointIndex < 1 && numAll > 0) {
    int minDimensions=Math.max(arr.rank(),2) + newAxis;
    int[] shape=new int[minDimensions];
    Arrays.fill(shape,1);
    int[] stride=new int[minDimensions];
    Arrays.fill(stride,arr.elementStride());
    int[] offsets=new int[minDimensions];
    int prependNewAxes=0;
    boolean allFirst=false;
    int shapeAxis=0;
    for (int i=0; i < indexes.length; i++) {
      if (indexes[i] instanceof NewAxis) {
        if (allFirst) {
          shape[i]=1;
          stride[i]=0;
        }
 else {
          prependNewAxes++;
        }
      }
 else {
        if (i == 0)         allFirst=true;
        shape[i]=arr.size(shapeAxis + prependNewAxes);
        stride[i]=arr.stride(shapeAxis + prependNewAxes);
        shapeAxis++;
      }
    }
    this.shapes=shape;
    this.strides=stride;
    this.offsets=offsets;
    return true;
  }
  return false;
}"
3324,"/** 
 * Prepares two arrays for raw iteration linearly through the data. It uses the same data for allocation
 * @param dst the first array
 * @param src the second array
 */
public static Pair<INDArray,INDArray> prepareTwoRawArrayIter(INDArray dst,INDArray src){
  StridePermutation[] perms=Shape.createSortedStrides(dst.stride());
  int[] outShape=new int[dst.rank()];
  int[] outStridesA=new int[dst.rank()];
  int[] outStridesB=new int[src.rank()];
  int dstOffset=dst.offset();
  int sourceOffset=src.offset();
  for (int i=0; i < dst.rank(); i++) {
    int iPerm=perms[dst.rank() - i - i].getPermutation();
    outShape[i]=dst.size(iPerm);
    outStridesA[i]=dst.stride(iPerm);
    outStridesB[i]=dst.stride(iPerm);
  }
  for (int i=0; i < dst.rank(); i++) {
    int outStrideA=outStridesA[i];
    int outStrideB=outStridesB[i];
    int shapeI=outShape[i];
    if (outStrideA < 0) {
      dstOffset+=outStrideA * shapeI - 1;
      sourceOffset+=outStrideB * shapeI - 1;
      outStridesA[i]-=outStrideA;
      outStridesB[i]-=outStrideB;
    }
  }
  for (int i=0, j=1; j < dst.rank(); j++) {
    if (outShape[i] == 1) {
      outShape[i]=outShape[j];
      outStridesA[i]=outStridesA[j];
      outStridesB[i]=outStridesB[j];
    }
 else     if (outShape[j] == 1) {
    }
 else     if (outStridesA[i] * outShape[i] == outStridesA[j] && outStridesB[i] * outShape[i] == outStridesB[j]) {
      outShape[i]*=outShape[j];
    }
 else {
      i++;
      outShape[i]=outShape[j];
      outStridesA[i]=outStridesA[j];
      outStridesB[i]=outStridesB[j];
    }
  }
  INDArray retDst=Nd4j.create(dst.data(),outShape,outStridesA,dstOffset,dst.ordering());
  INDArray sourceDst=Nd4j.create(src.data(),outShape,outStridesB,sourceOffset,src.ordering());
  return new Pair<>(retDst,sourceDst);
}","/** 
 * Prepares two arrays for raw iteration linearly through the data. It uses the same data for allocation
 * @param dst the first array
 * @param src the second array
 */
public static Pair<INDArray,INDArray> prepareTwoRawArrayIter(INDArray dst,INDArray src){
  StridePermutation[] perms=Shape.createSortedStrides(dst.stride());
  int[] outShape=new int[dst.rank()];
  int[] outStridesA=new int[dst.rank()];
  int[] outStridesB=new int[src.rank()];
  int dstOffset=dst.offset();
  int sourceOffset=src.offset();
  for (int i=0; i < dst.rank(); i++) {
    int iPerm=perms[dst.rank() - i - 1].getPermutation();
    outShape[i]=dst.size(iPerm);
    outStridesA[i]=dst.stride(iPerm);
    outStridesB[i]=src.stride(iPerm);
  }
  for (int i=0; i < dst.rank(); i++) {
    int outStrideA=outStridesA[i];
    int outStrideB=outStridesB[i];
    int shapeI=outShape[i];
    if (outStrideA < 0) {
      dstOffset+=outStrideA * shapeI - 1;
      sourceOffset+=outStrideB * shapeI - 1;
      outStridesA[i]-=outStrideA;
      outStridesB[i]-=outStrideB;
    }
  }
  for (int i=0, j=1; j < dst.rank(); j++) {
    if (outShape[i] == 1) {
      outShape[i]=outShape[j];
      outStridesA[i]=outStridesA[j];
      outStridesB[i]=outStridesB[j];
    }
 else     if (outShape[j] == 1) {
    }
 else     if (outStridesA[i] * outShape[i] == outStridesA[j] && outStridesB[i] * outShape[i] == outStridesB[j]) {
      outShape[i]*=outShape[j];
    }
 else {
      i++;
      outShape[i]=outShape[j];
      outStridesA[i]=outStridesA[j];
      outStridesB[i]=outStridesB[j];
    }
  }
  INDArray retDst=Nd4j.create(dst.data(),outShape,outStridesA,dstOffset,dst.ordering());
  INDArray sourceDst=Nd4j.create(src.data(),src.shape(),outStridesB,sourceOffset,src.ordering());
  return new Pair<>(retDst,sourceDst);
}"
3325,"public double score(){
  double ret=0.0;
switch (lossFunction) {
case CUSTOM:
    throw new IllegalStateException(""String_Node_Str"");
case RECONSTRUCTION_CROSSENTROPY:
  INDArray xEntLogZ2=log(z);
INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=log(z).rsubi(1);
ret=-labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).muli(xEntOneMinusLogOneMinusZ2).sumNumber().doubleValue();
break;
case MCXENT:
INDArray sums=labels.mul(log(z));
ret=-sums.sumNumber().doubleValue();
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsubi(1);
ret=labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).muli(xEntOneMinusLogOneMinusZ).sum(1).sumNumber().doubleValue();
break;
case RMSE_XENT:
INDArray rmseXentDiff=delta == null ? labels.sub(z) : delta;
INDArray squaredrmseXentDiff=pow(rmseXentDiff,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
ret=sqrt.sumNumber().doubleValue();
break;
case MSE:
INDArray mseDelta=delta == null ? labels.sub(z) : delta;
ret=0.5 * pow(mseDelta,2).sum(1).sumNumber().doubleValue();
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=z.sub(labels.mul(expLLLogZ)).sumNumber().doubleValue();
break;
case SQUARED_LOSS:
ret=pow(delta == null ? labels.sub(z) : delta,2).sumNumber().doubleValue();
break;
case NEGATIVELOGLIKELIHOOD:
INDArray log=log(z);
INDArray sums2=labels.mul(log);
ret=-sums2.sumNumber().doubleValue();
break;
}
if (useRegularization) {
ret+=l1 + l2;
}
if (miniBatch) ret/=(double)miniBatchSize;
return ret;
}","public double score(){
  double ret=0.0;
switch (lossFunction) {
case CUSTOM:
    throw new IllegalStateException(""String_Node_Str"");
case RECONSTRUCTION_CROSSENTROPY:
  INDArray xEntLogZ2=logZ(z);
INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=xEntLogZ2.dup().rsubi(1);
ret=-labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).muli(xEntOneMinusLogOneMinusZ2).sumNumber().doubleValue();
break;
case MCXENT:
INDArray sums=labels.mul(logZ(z));
ret=-sums.sumNumber().doubleValue();
break;
case XENT:
INDArray xEntLogZ=logZ(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=xEntLogZ.dup().rsubi(1);
ret=labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).muli(xEntOneMinusLogOneMinusZ).sum(1).sumNumber().doubleValue();
break;
case RMSE_XENT:
INDArray rmseXentDiff=delta == null ? labels.sub(z) : delta;
INDArray squaredrmseXentDiff=pow(rmseXentDiff,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
ret=sqrt.sumNumber().doubleValue();
break;
case MSE:
INDArray mseDelta=delta == null ? labels.sub(z) : delta;
ret=0.5 * pow(mseDelta,2).sum(1).sumNumber().doubleValue();
break;
case EXPLL:
INDArray expLLLogZ=logZ(z);
ret=z.sub(labels.mul(expLLLogZ)).sumNumber().doubleValue();
break;
case SQUARED_LOSS:
ret=pow(delta == null ? labels.sub(z) : delta,2).sumNumber().doubleValue();
break;
case NEGATIVELOGLIKELIHOOD:
INDArray log=logZ(z);
INDArray sums2=labels.mul(log);
ret=-sums2.sumNumber().doubleValue();
break;
}
if (useRegularization) {
ret+=l1 + l2;
}
if (miniBatch) ret/=(double)miniBatchSize;
return ret;
}"
3326,"/** 
 * Create a copy of the matrix where the new offset is zero
 * @param arr the array to copy to offset 0
 * @return the same array if offset is zerootherwise a copy of the array with elements set to zero
 */
public static INDArray toOffsetZeroCopy(INDArray arr){
  if (arr.isRowVector()) {
    if (arr instanceof IComplexNDArray) {
      IComplexNDArray ret=Nd4j.createComplex(arr.shape());
      for (int i=0; i < ret.length(); i++)       ret.putScalar(i,((IComplexNDArray)arr).getComplex(i));
      return ret;
    }
 else {
      INDArray ret=Nd4j.create(arr.shape());
      for (int i=0; i < ret.length(); i++)       ret.putScalar(i,arr.getDouble(i));
      return ret;
    }
  }
  if (arr instanceof IComplexNDArray) {
    IComplexNDArray ret=Nd4j.createComplex(arr.shape());
    for (int i=0; i < ret.slices(); i++)     ret.putSlice(i,arr.slice(i));
    return ret;
  }
 else {
    if (arr.offset() == 0 && arr.data().allocationMode() == AllocationMode.HEAP && arr.length() == arr.data().length() && arr.ordering() == Nd4j.ORDER) {
      Object array=arr.data().array();
      if (array instanceof float[]) {
        float[] orig=(float[])array;
        float[] out=Arrays.copyOf(orig,orig.length);
        DataBuffer floatBuffer=Nd4j.createBuffer(out);
        int[] newShape=arr.shape();
        newShape=Arrays.copyOf(newShape,newShape.length);
        int[] newStride=arr.stride();
        newStride=Arrays.copyOf(newStride,newStride.length);
        return Nd4j.create(floatBuffer,newShape,newStride,0,arr.ordering());
      }
 else       if (array instanceof double[]) {
        double[] orig=(double[])array;
        double[] out=Arrays.copyOf(orig,orig.length);
        DataBuffer doubleBuffer=Nd4j.createBuffer(out);
        int[] newShape=arr.shape();
        newShape=Arrays.copyOf(newShape,newShape.length);
        int[] newStride=arr.stride();
        newStride=Arrays.copyOf(newStride,newStride.length);
        return Nd4j.create(doubleBuffer,newShape,newStride,0,arr.ordering());
      }
    }
    INDArray ret=Nd4j.create(arr.shape());
    for (int i=0; i < arr.vectorsAlongDimension(0); i++) {
      ret.vectorAlongDimension(i,0).assign(arr.vectorAlongDimension(i,0));
    }
    return ret;
  }
}","/** 
 * Create a copy of the matrix where the new offset is zero
 * @param arr the array to copy to offset 0
 * @return the same array if offset is zerootherwise a copy of the array with elements set to zero
 */
public static INDArray toOffsetZeroCopy(INDArray arr){
  if (arr.isRowVector()) {
    if (arr instanceof IComplexNDArray) {
      IComplexNDArray ret=Nd4j.createComplex(arr.shape());
      for (int i=0; i < ret.length(); i++)       ret.putScalar(i,((IComplexNDArray)arr).getComplex(i));
      return ret;
    }
 else {
      INDArray ret=Nd4j.create(arr.shape());
      for (int i=0; i < ret.length(); i++)       ret.putScalar(i,arr.getDouble(i));
      return ret;
    }
  }
  if (arr instanceof IComplexNDArray) {
    IComplexNDArray ret=Nd4j.createComplex(arr.shape());
    for (int i=0; i < ret.slices(); i++)     ret.putSlice(i,arr.slice(i));
    return ret;
  }
 else {
    if (arr.offset() == 0 && arr.data().allocationMode() == AllocationMode.HEAP && arr.length() == arr.data().length() && arr.ordering() == Nd4j.order() && strideDescendingCAscendingF(arr.ordering(),arr.stride())) {
      Object array=arr.data().array();
      if (array instanceof float[]) {
        float[] orig=(float[])array;
        float[] out=Arrays.copyOf(orig,orig.length);
        DataBuffer floatBuffer=Nd4j.createBuffer(out);
        int[] newShape=arr.shape();
        newShape=Arrays.copyOf(newShape,newShape.length);
        int[] newStride=arr.stride();
        newStride=Arrays.copyOf(newStride,newStride.length);
        return Nd4j.create(floatBuffer,newShape,newStride,0,arr.ordering());
      }
 else       if (array instanceof double[]) {
        double[] orig=(double[])array;
        double[] out=Arrays.copyOf(orig,orig.length);
        DataBuffer doubleBuffer=Nd4j.createBuffer(out);
        int[] newShape=arr.shape();
        newShape=Arrays.copyOf(newShape,newShape.length);
        int[] newStride=arr.stride();
        newStride=Arrays.copyOf(newStride,newStride.length);
        return Nd4j.create(doubleBuffer,newShape,newStride,0,arr.ordering());
      }
    }
    INDArray ret=Nd4j.create(arr.shape());
    for (int i=0; i < arr.vectorsAlongDimension(0); i++) {
      ret.vectorAlongDimension(i,0).assign(arr.vectorAlongDimension(i,0));
    }
    return ret;
  }
}"
3327,"@Override public void init(INDArray arr,int begin,int dimension){
  this.begin=0;
  this.end=arr.size(dimension);
}","@Override public void init(INDArray arr,int begin,int dimension){
  this.begin=0;
  this.end=arr.size(dimension);
  this.length=end;
}"
3328,"/** 
 * Number of slices: aka shape[0]
 * @return the number of slicesfor this nd array
 */
@Override public int slices(){
  if (shape.length < 1)   return 0;
  return shape[0];
}","/** 
 * Number of slices: aka shape[0]
 * @return the number of slicesfor this nd array
 */
@Override public int slices(){
  if (shape.length < 1)   return 0;
  if (isRowVector())   return length();
  return shape[0];
}"
3329,"/** 
 * Based on the passed in array compute the shape,offsets, and strides for the given indexes
 * @param indexes the indexesto compute this based on
 */
public void exec(INDArrayIndex... indexes){
  indexes=NDArrayIndex.resolve(arr.shape(),indexes);
  int[] shape=arr.shape();
  int numIntervals=0;
  int newAxesPrepend=0;
  boolean encounteredAll=false;
  List<Integer> accumShape=new ArrayList<>();
  List<Integer> accumStrides=new ArrayList<>();
  List<Integer> accumOffsets=new ArrayList<>();
  List<Integer> intervalStrides=new ArrayList<>();
  List<Integer> pointStrides=new ArrayList<>();
  List<Integer> pointOffsets=new ArrayList<>();
  int numPointIndexes=0;
  int shapeIndex=0;
  int strideIndex=0;
  List<Integer> prependNewAxes=new ArrayList<>();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof NDArrayIndexAll)     encounteredAll=true;
    if (idx instanceof PointIndex) {
      pointOffsets.add(idx.offset());
      pointStrides.add(arr.stride(strideIndex));
      numPointIndexes++;
      shapeIndex++;
      strideIndex++;
      continue;
    }
 else     if (idx instanceof NewAxis) {
      if (encounteredAll) {
        prependNewAxes.add(i);
      }
 else       newAxesPrepend++;
      continue;
    }
 else     if (idx instanceof IntervalIndex && !(idx instanceof NDArrayIndexAll) || idx instanceof SpecifiedIndex) {
      if (idx instanceof IntervalIndex) {
        accumStrides.add(arr.stride(strideIndex) * idx.stride());
        intervalStrides.add(idx.stride());
        if (idx.stride() > 1)         numIntervals++;
      }
 else       accumStrides.add(arr.stride(strideIndex));
      accumShape.add(idx.length());
      if (idx instanceof IntervalIndex) {
        accumOffsets.add(idx.offset());
      }
 else       accumOffsets.add(idx.offset());
      shapeIndex++;
      strideIndex++;
      continue;
    }
    accumShape.add(shape[shapeIndex++]);
    accumStrides.add(arr.stride(strideIndex++));
    accumOffsets.add(idx.offset());
  }
  while (shapeIndex < shape.length) {
    if (Shape.isVector(shape)) {
      accumShape.add(1);
      shapeIndex++;
    }
 else     accumShape.add(shape[shapeIndex++]);
  }
  int delta=(shape.length <= 2 ? shape.length : shape.length - numPointIndexes);
  boolean needsFilledIn=accumShape.size() != accumStrides.size() && accumOffsets.size() != accumShape.size();
  while (accumOffsets.size() < delta && needsFilledIn)   accumOffsets.add(0);
  while (accumShape.size() < 2) {
    if (Shape.isRowVectorShape(arr.shape()))     accumShape.add(0,1);
 else     accumShape.add(1);
  }
  while (strideIndex < accumShape.size()) {
    accumStrides.add(arr.stride(strideIndex++));
  }
  if (newAxesPrepend > 0) {
    for (int i=0; i < newAxesPrepend; i++) {
      accumShape.add(0,1);
      accumStrides.add(0,0);
      accumOffsets.add(0,0);
    }
  }
  int numAdded=0;
  for (int i=0; i < prependNewAxes.size(); i++) {
    accumShape.add(prependNewAxes.get(i) - numAdded,1);
    accumStrides.add(prependNewAxes.get(i) - numAdded,0);
    numAdded++;
  }
  int trailingZeroRemove=accumOffsets.size() - 1;
  while (accumOffsets.size() > accumShape.size()) {
    if (accumOffsets.get(trailingZeroRemove) == 0)     accumOffsets.remove(accumOffsets.size() - 1);
    trailingZeroRemove--;
  }
  if (accumStrides.size() < accumOffsets.size())   accumStrides.addAll(pointStrides);
  while (accumOffsets.size() < accumShape.size()) {
    if (Shape.isRowVectorShape(arr.shape()))     accumOffsets.add(0,0);
 else     accumOffsets.add(0);
  }
  while (accumStrides.size() < accumOffsets.size()) {
    if (arr.isRowVector())     accumStrides.add(0,arr.elementStride());
 else     accumStrides.add(arr.elementStride());
  }
  this.strides=Ints.toArray(accumStrides);
  this.shapes=Ints.toArray(accumShape);
  this.offsets=Ints.toArray(accumOffsets);
  if (numPointIndexes > 0 && !pointStrides.isEmpty()) {
    if (newAxesPrepend >= 1) {
      while (pointStrides.size() < accumOffsets.size()) {
        pointStrides.add(1);
      }
      for (int i=0; i < accumStrides.size(); i++) {
        if (accumStrides.get(i) == 0)         pointStrides.set(i,0);
      }
    }
    while (pointOffsets.size() < pointStrides.size()) {
      pointOffsets.add(0);
    }
    if (arr.isRowVector() && !intervalStrides.isEmpty() && pointOffsets.get(0) == 0)     this.offset=indexes[1].offset();
 else     this.offset=ArrayUtil.dotProduct(pointOffsets,pointStrides);
  }
 else   if (numIntervals > 0) {
    this.offset=ArrayUtil.dotProduct(accumOffsets,accumStrides) / numIntervals;
  }
 else   this.offset=ArrayUtil.calcOffset(accumShape,accumOffsets,accumStrides);
}","/** 
 * Based on the passed in array compute the shape,offsets, and strides for the given indexes
 * @param indexes the indexesto compute this based on
 */
public void exec(INDArrayIndex... indexes){
  indexes=NDArrayIndex.resolve(arr.shape(),indexes);
  int[] shape=arr.shape();
  int numIntervals=0;
  int newAxesPrepend=0;
  boolean encounteredAll=false;
  List<Integer> accumShape=new ArrayList<>();
  List<Integer> accumStrides=new ArrayList<>();
  List<Integer> accumOffsets=new ArrayList<>();
  List<Integer> intervalStrides=new ArrayList<>();
  List<Integer> pointStrides=new ArrayList<>();
  List<Integer> pointOffsets=new ArrayList<>();
  int numPointIndexes=0;
  int shapeIndex=0;
  int strideIndex=0;
  List<Integer> prependNewAxes=new ArrayList<>();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof NDArrayIndexAll)     encounteredAll=true;
    if (idx instanceof PointIndex) {
      pointOffsets.add(idx.offset());
      pointStrides.add(arr.stride(strideIndex));
      numPointIndexes++;
      shapeIndex++;
      strideIndex++;
      continue;
    }
 else     if (idx instanceof NewAxis) {
      if (encounteredAll) {
        prependNewAxes.add(i);
      }
 else       newAxesPrepend++;
      continue;
    }
 else     if (idx instanceof IntervalIndex && !(idx instanceof NDArrayIndexAll) || idx instanceof SpecifiedIndex) {
      if (idx instanceof IntervalIndex) {
        accumStrides.add(arr.stride(strideIndex) * idx.stride());
        intervalStrides.add(idx.stride());
        if (idx.stride() > 1)         numIntervals++;
      }
 else       accumStrides.add(arr.stride(strideIndex));
      accumShape.add(idx.length());
      if (idx instanceof IntervalIndex) {
        accumOffsets.add(idx.offset());
      }
 else       accumOffsets.add(idx.offset());
      shapeIndex++;
      strideIndex++;
      continue;
    }
    accumShape.add(shape[shapeIndex++]);
    accumStrides.add(arr.stride(strideIndex++));
    accumOffsets.add(idx.offset());
  }
  while (shapeIndex < shape.length) {
    if (Shape.isVector(shape)) {
      accumShape.add(1);
      shapeIndex++;
    }
 else     accumShape.add(shape[shapeIndex++]);
  }
  int delta=(shape.length <= 2 ? shape.length : shape.length - numPointIndexes);
  boolean needsFilledIn=accumShape.size() != accumStrides.size() && accumOffsets.size() != accumShape.size();
  while (accumOffsets.size() < delta && needsFilledIn)   accumOffsets.add(0);
  while (accumShape.size() < 2) {
    if (Shape.isRowVectorShape(arr.shape()))     accumShape.add(0,1);
 else     accumShape.add(1);
  }
  while (strideIndex < accumShape.size()) {
    accumStrides.add(arr.stride(strideIndex++));
  }
  if (newAxesPrepend > 0) {
    for (int i=0; i < newAxesPrepend; i++) {
      accumShape.add(0,1);
      accumStrides.add(0,0);
      accumOffsets.add(0,0);
    }
  }
  int numAdded=0;
  for (int i=0; i < prependNewAxes.size(); i++) {
    accumShape.add(prependNewAxes.get(i) - numAdded,1);
    accumStrides.add(prependNewAxes.get(i) - numAdded,0);
    numAdded++;
  }
  int trailingZeroRemove=accumOffsets.size() - 1;
  while (accumOffsets.size() > accumShape.size()) {
    if (accumOffsets.get(trailingZeroRemove) == 0)     accumOffsets.remove(accumOffsets.size() - 1);
    trailingZeroRemove--;
  }
  if (accumStrides.size() < accumOffsets.size())   accumStrides.addAll(pointStrides);
  while (accumOffsets.size() < accumShape.size()) {
    if (Shape.isRowVectorShape(arr.shape()))     accumOffsets.add(0,0);
 else     accumOffsets.add(0);
  }
  if (Shape.isMatrix(shape)) {
    if (indexes[0] instanceof PointIndex && indexes[1] instanceof NDArrayIndexAll)     Collections.reverse(accumShape);
  }
  this.shapes=Ints.toArray(accumShape);
  boolean isColumnVector=Shape.isColumnVectorShape(this.shapes);
  while (accumStrides.size() < accumOffsets.size()) {
    if (!isColumnVector)     accumStrides.add(0,arr.elementStride());
 else     accumStrides.add(arr.elementStride());
  }
  this.strides=Ints.toArray(accumStrides);
  this.offsets=Ints.toArray(accumOffsets);
  if (numPointIndexes > 0 && !pointStrides.isEmpty()) {
    if (newAxesPrepend >= 1) {
      while (pointStrides.size() < accumOffsets.size()) {
        pointStrides.add(1);
      }
      for (int i=0; i < accumStrides.size(); i++) {
        if (accumStrides.get(i) == 0)         pointStrides.set(i,0);
      }
    }
    while (pointOffsets.size() < pointStrides.size()) {
      pointOffsets.add(0);
    }
    if (arr.isRowVector() && !intervalStrides.isEmpty() && pointOffsets.get(0) == 0)     this.offset=indexes[1].offset();
 else     this.offset=ArrayUtil.dotProduct(pointOffsets,pointStrides);
  }
 else   if (numIntervals > 0) {
    this.offset=ArrayUtil.dotProduct(accumOffsets,accumStrides) / numIntervals;
  }
 else   this.offset=ArrayUtil.calcOffset(accumShape,accumOffsets,accumStrides);
}"
3330,"@Test public void testSwapAxesFortranOrder(){
  INDArray n=Nd4j.create(Nd4j.linspace(1,30,30).data(),new int[]{3,5,2});
  for (int i=0; i < n.slices(); i++) {
    INDArray nSlice=n.slice(i);
    System.out.println(nSlice);
  }
  INDArray slice=n.swapAxes(2,1);
  INDArray assertion=Nd4j.create(new double[]{1,4,7,10,13});
  INDArray test=slice.slice(0).slice(0);
  assertEquals(assertion,test);
}","@Test public void testSwapAxesFortranOrder(){
  INDArray n=Nd4j.create(Nd4j.linspace(1,30,30).data(),new int[]{3,5,2});
  for (int i=0; i < n.slices(); i++) {
    INDArray nSlice=n.slice(i);
    for (int j=0; j < nSlice.slices(); j++) {
      INDArray sliceJ=nSlice.slice(j);
      System.out.println(sliceJ);
    }
    System.out.println(nSlice);
  }
  INDArray slice=n.swapAxes(2,1);
  INDArray assertion=Nd4j.create(new double[]{1,4,7,10,13});
  INDArray test=slice.slice(0).slice(0);
  assertEquals(assertion,test);
}"
3331,"@Test public void testShape(){
  INDArray ndarray=Nd4j.create(new float[][]{{1f,2f},{3f,4f}});
  INDArray subarray=ndarray.get(NDArrayIndex.point(0),NDArrayIndex.all());
  assertTrue(subarray.isRowVector());
  int[] shape=subarray.shape();
  assertEquals(shape[0],1);
  assertEquals(shape[0],2);
}","@Test public void testShape(){
  INDArray ndarray=Nd4j.create(new float[][]{{1f,2f},{3f,4f}});
  INDArray subarray=ndarray.get(NDArrayIndex.point(0),NDArrayIndex.all());
  assertTrue(subarray.isRowVector());
  int[] shape=subarray.shape();
  assertEquals(shape[0],1);
  assertEquals(shape[1],2);
}"
3332,"@Test public void testRowVectorInterval(){
  int len=30;
  INDArray row=Nd4j.zeros(len);
  for (int i=0; i < len; i++) {
    row.putScalar(i,i);
  }
  INDArray idx=Nd4j.zeros(1,2,3).slice(2,2);
  System.out.println(row.get(NDArrayIndex.point(0),NDArrayIndex.interval(0,10)));
  System.out.println(row.get(NDArrayIndex.point(0),NDArrayIndex.interval(20,30)));
  System.out.println(row.get(NDArrayIndex.interval(0,10)));
  System.out.println(row.get(NDArrayIndex.interval(20,30)));
  INDArray first10a=row.get(NDArrayIndex.point(0),NDArrayIndex.interval(0,10));
  assertArrayEquals(first10a.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(first10a.getDouble(i) == i);
  INDArray first10b=row.get(NDArrayIndex.interval(0,10));
  assertArrayEquals(first10b.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(first10b.getDouble(i) == i);
  INDArray last10a=row.get(NDArrayIndex.point(0),NDArrayIndex.interval(20,30));
  assertArrayEquals(last10a.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(last10a.getDouble(i) == 20 + i);
  INDArray last10b=row.get(NDArrayIndex.interval(20,30));
  assertArrayEquals(last10b.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(last10b.getDouble(i) == 20 + i);
}","@Test public void testRowVectorInterval(){
  int len=30;
  INDArray row=Nd4j.zeros(len);
  for (int i=0; i < len; i++) {
    row.putScalar(i,i);
  }
  INDArray first10a=row.get(NDArrayIndex.point(0),NDArrayIndex.interval(0,10));
  assertArrayEquals(first10a.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(first10a.getDouble(i) == i);
  INDArray first10b=row.get(NDArrayIndex.interval(0,10));
  assertArrayEquals(first10b.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(first10b.getDouble(i) == i);
  INDArray last10a=row.get(NDArrayIndex.point(0),NDArrayIndex.interval(20,30));
  assertArrayEquals(last10a.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(last10a.getDouble(i) == 20 + i);
  INDArray last10b=row.get(NDArrayIndex.interval(20,30));
  assertArrayEquals(last10b.shape(),new int[]{1,10});
  for (int i=0; i < 10; i++)   assertTrue(last10b.getDouble(i) == 20 + i);
}"
3333,"@Override public void init(int begin,int end){
  this.begin=begin;
  this.index=begin;
  this.end=inclusive ? end + 1 : end;
  for (int i=begin; i < end; i+=stride) {
    length++;
  }
}","@Override public void init(int begin,int end){
  this.begin=begin;
  this.index=begin;
  this.end=inclusive ? end + 1 : end;
  for (int i=begin; i < this.end; i+=stride) {
    length++;
  }
}"
3334,"/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.htsliceml
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray permute(int... rearrange){
  if (rearrange.length != shape.length)   return dup();
  checkArrangeArray(rearrange);
  int[] newShape=doPermuteSwap(shape,rearrange);
  int[] newStride=doPermuteSwap(stride,rearrange);
  INDArray value=create(data(),newShape,newStride,offset(),ordering());
  return value;
}","/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.htsliceml
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray permute(int... rearrange){
  if (rearrange.length != shape.length)   return dup();
  checkArrangeArray(rearrange);
  int[] newShape=doPermuteSwap(shape,rearrange);
  int[] newStride=doPermuteSwap(stride,rearrange);
  char newOrder=Shape.getOrder(newShape,newStride,elementStride());
  INDArray value=create(data(),newShape,newStride,offset(),newOrder);
  return value;
}"
3335,"/** 
 * Tensor matrix multiplication. Both tensors must be the same rank
 * @param a the left tensor
 * @param b the  right tensor
 * @param axes the axes for each array to do matrix multiply along
 * @return
 */
public static INDArray tensorMmul(INDArray a,INDArray b,int[][] axes){
  int validationLength=Math.min(axes[0].length,axes[1].length);
  for (int i=0; i < validationLength; i++) {
    if (a.size(axes[0][i]) != b.size(axes[1][i]))     throw new IllegalArgumentException(""String_Node_Str"");
    if (axes[0][i] < 0)     axes[0][i]+=a.rank();
    if (axes[1][i] < 0)     axes[1][i]+=b.rank();
  }
  List<Integer> listA=new ArrayList<>();
  for (int i=0; i < a.rank(); i++) {
    if (!Ints.contains(axes[0],i))     listA.add(i);
  }
  int[] newAxesA=Ints.concat(Ints.toArray(listA),axes[0]);
  List<Integer> listB=new ArrayList<>();
  for (int i=0; i < b.rank(); i++) {
    if (!Ints.contains(axes[1],i))     listB.add(i);
  }
  int[] newAxesB=Ints.concat(axes[1],Ints.toArray(listB));
  int n2=1;
  int aLength=Math.min(a.rank(),axes[0].length);
  for (int i=0; i < aLength; i++) {
    n2*=a.size(axes[0][i]);
  }
  int[] newShapeA={-1,n2};
  int[] oldShapeA=Ints.toArray(listA);
  for (int i=0; i < oldShapeA.length; i++)   oldShapeA[i]=a.size(oldShapeA[i]);
  int n3=1;
  int bNax=Math.min(b.rank(),axes[1].length);
  for (int i=0; i < bNax; i++) {
    n3*=b.size(axes[1][i]);
  }
  int[] newShapeB={n3,-1};
  int[] oldShapeB=Ints.toArray(listB);
  for (int i=0; i < oldShapeB.length; i++)   oldShapeB[i]=b.size(oldShapeB[i]);
  INDArray at=a.permute(newAxesA).reshape('c',newShapeA);
  INDArray bt=b.permute(newAxesB).reshape('c',newShapeB);
  INDArray ret=at.mmul(bt);
  int[] aPlusB=Ints.concat(oldShapeA,oldShapeB);
  return ret.reshape(aPlusB);
}","/** 
 * Tensor matrix multiplication. Both tensors must be the same rank
 * @param a the left tensor
 * @param b the  right tensor
 * @param axes the axes for each array to do matrix multiply along
 * @return
 */
public static INDArray tensorMmul(INDArray a,INDArray b,int[][] axes){
  int validationLength=Math.min(axes[0].length,axes[1].length);
  for (int i=0; i < validationLength; i++) {
    if (a.size(axes[0][i]) != b.size(axes[1][i]))     throw new IllegalArgumentException(""String_Node_Str"");
    if (axes[0][i] < 0)     axes[0][i]+=a.rank();
    if (axes[1][i] < 0)     axes[1][i]+=b.rank();
  }
  List<Integer> listA=new ArrayList<>();
  for (int i=0; i < a.rank(); i++) {
    if (!Ints.contains(axes[0],i))     listA.add(i);
  }
  int[] newAxesA=Ints.concat(Ints.toArray(listA),axes[0]);
  List<Integer> listB=new ArrayList<>();
  for (int i=0; i < b.rank(); i++) {
    if (!Ints.contains(axes[1],i))     listB.add(i);
  }
  int[] newAxesB=Ints.concat(axes[1],Ints.toArray(listB));
  int n2=1;
  int aLength=Math.min(a.rank(),axes[0].length);
  for (int i=0; i < aLength; i++) {
    n2*=a.size(axes[0][i]);
  }
  int[] newShapeA={-1,n2};
  int[] oldShapeA=Ints.toArray(listA);
  for (int i=0; i < oldShapeA.length; i++)   oldShapeA[i]=a.size(oldShapeA[i]);
  int n3=1;
  int bNax=Math.min(b.rank(),axes[1].length);
  for (int i=0; i < bNax; i++) {
    n3*=b.size(axes[1][i]);
  }
  int[] newShapeB={n3,-1};
  int[] oldShapeB=Ints.toArray(listB);
  for (int i=0; i < oldShapeB.length; i++)   oldShapeB[i]=b.size(oldShapeB[i]);
  INDArray at=a.permute(newAxesA).reshape(newShapeA);
  INDArray bt=b.permute(newAxesB).reshape(newShapeB);
  INDArray ret=at.mmul(bt);
  int[] aPlusB=Ints.concat(oldShapeA,oldShapeB);
  return ret.reshape(aPlusB);
}"
3336,"/** 
 * Based on the passed in array compute the shape,offsets, and strides for the given indexes
 * @param indexes the indexesto compute this based on
 */
public void exec(INDArrayIndex... indexes){
  indexes=NDArrayIndex.resolve(arr.shape(),indexes);
  int[] shape=arr.shape();
  int numIntervals=0;
  int newAxesPrepend=0;
  boolean encounteredAll=false;
  List<Integer> accumShape=new ArrayList<>();
  List<Integer> accumStrides=new ArrayList<>();
  List<Integer> accumOffsets=new ArrayList<>();
  List<Integer> intervalStrides=new ArrayList<>();
  List<Integer> pointStrides=new ArrayList<>();
  List<Integer> pointOffsets=new ArrayList<>();
  int numPointIndexes=0;
  int shapeIndex=0;
  int strideIndex=0;
  List<Integer> prependNewAxes=new ArrayList<>();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof NDArrayIndexAll)     encounteredAll=true;
    if (idx instanceof PointIndex) {
      pointOffsets.add(idx.offset());
      pointStrides.add(arr.stride(strideIndex));
      numPointIndexes++;
      shapeIndex++;
      strideIndex++;
      continue;
    }
 else     if (idx instanceof NewAxis) {
      if (encounteredAll) {
        prependNewAxes.add(i);
      }
 else       newAxesPrepend++;
      continue;
    }
 else     if (idx instanceof IntervalIndex && !(idx instanceof NDArrayIndexAll) || idx instanceof SpecifiedIndex) {
      if (idx instanceof IntervalIndex) {
        accumStrides.add(arr.stride(strideIndex) * idx.stride());
        intervalStrides.add(idx.stride());
        if (idx.stride() > 1)         numIntervals++;
      }
 else       accumStrides.add(arr.stride(strideIndex));
      accumShape.add(idx.length());
      if (idx instanceof IntervalIndex) {
        accumOffsets.add(idx.offset());
      }
 else       accumOffsets.add(idx.offset());
      shapeIndex++;
      strideIndex++;
      continue;
    }
    accumShape.add(shape[shapeIndex++]);
    accumStrides.add(arr.stride(strideIndex++));
    accumOffsets.add(idx.offset());
  }
  while (shapeIndex < shape.length) {
    if (Shape.isVector(shape)) {
      accumShape.add(1);
      shapeIndex++;
    }
 else     accumShape.add(shape[shapeIndex++]);
  }
  int delta=(shape.length <= 2 ? shape.length : shape.length - numPointIndexes);
  boolean needsFilledIn=accumShape.size() != accumStrides.size() && accumOffsets.size() != accumShape.size();
  while (accumOffsets.size() < delta && needsFilledIn)   accumOffsets.add(0);
  while (accumShape.size() < 2)   accumShape.add(1);
  if (newAxesPrepend > 0) {
    for (int i=0; i < newAxesPrepend; i++) {
      accumShape.add(0,1);
      accumStrides.add(0,0);
      accumOffsets.add(0,0);
    }
  }
  for (int i=0; i < prependNewAxes.size(); i++) {
    accumShape.add(prependNewAxes.get(i) - i,1);
    accumStrides.add(prependNewAxes.get(i) - i,0);
  }
  int trailingZeroRemove=accumOffsets.size() - 1;
  while (accumOffsets.size() > accumShape.size()) {
    if (accumOffsets.get(trailingZeroRemove) == 0)     accumOffsets.remove(accumOffsets.size() - 1);
    trailingZeroRemove--;
  }
  if (accumStrides.size() < accumOffsets.size())   accumStrides.addAll(pointStrides);
  while (accumOffsets.size() < accumShape.size())   accumOffsets.add(0);
  while (accumStrides.size() < accumOffsets.size()) {
    accumStrides.add(arr.elementStride());
  }
  if (indexes.length <= 2 && indexes[0] instanceof PointIndex && shape.length == 2 && newAxesPrepend < 1) {
    Collections.reverse(accumShape);
    Collections.reverse(accumStrides);
  }
  this.strides=Ints.toArray(accumStrides);
  this.shapes=Ints.toArray(accumShape);
  this.offsets=Ints.toArray(accumOffsets);
  if (numPointIndexes > 0 && !pointStrides.isEmpty()) {
    if (newAxesPrepend >= 1) {
      while (pointStrides.size() < accumOffsets.size()) {
        pointStrides.add(1);
      }
      for (int i=0; i < accumStrides.size(); i++) {
        if (accumStrides.get(i) == 0)         pointStrides.set(i,0);
      }
    }
 else {
      while (pointStrides.size() < pointStrides.size()) {
        pointStrides.add(1);
      }
    }
    this.offset=ArrayUtil.dotProduct(pointOffsets,pointStrides);
  }
 else   if (numIntervals > 0) {
    this.offset=ArrayUtil.dotProduct(accumOffsets,accumStrides) / numIntervals;
  }
 else   this.offset=ArrayUtil.calcOffset(accumShape,accumOffsets,accumStrides);
}","/** 
 * Based on the passed in array compute the shape,offsets, and strides for the given indexes
 * @param indexes the indexesto compute this based on
 */
public void exec(INDArrayIndex... indexes){
  indexes=NDArrayIndex.resolve(arr.shape(),indexes);
  int[] shape=arr.shape();
  int numIntervals=0;
  int newAxesPrepend=0;
  boolean encounteredAll=false;
  List<Integer> accumShape=new ArrayList<>();
  List<Integer> accumStrides=new ArrayList<>();
  List<Integer> accumOffsets=new ArrayList<>();
  List<Integer> intervalStrides=new ArrayList<>();
  List<Integer> pointStrides=new ArrayList<>();
  List<Integer> pointOffsets=new ArrayList<>();
  int numPointIndexes=0;
  int shapeIndex=0;
  int strideIndex=0;
  List<Integer> prependNewAxes=new ArrayList<>();
  for (int i=0; i < indexes.length; i++) {
    INDArrayIndex idx=indexes[i];
    if (idx instanceof NDArrayIndexAll)     encounteredAll=true;
    if (idx instanceof PointIndex) {
      pointOffsets.add(idx.offset());
      pointStrides.add(arr.stride(strideIndex));
      numPointIndexes++;
      shapeIndex++;
      strideIndex++;
      continue;
    }
 else     if (idx instanceof NewAxis) {
      if (encounteredAll) {
        prependNewAxes.add(i);
      }
 else       newAxesPrepend++;
      continue;
    }
 else     if (idx instanceof IntervalIndex && !(idx instanceof NDArrayIndexAll) || idx instanceof SpecifiedIndex) {
      if (idx instanceof IntervalIndex) {
        accumStrides.add(arr.stride(strideIndex) * idx.stride());
        intervalStrides.add(idx.stride());
        if (idx.stride() > 1)         numIntervals++;
      }
 else       accumStrides.add(arr.stride(strideIndex));
      accumShape.add(idx.length());
      if (idx instanceof IntervalIndex) {
        accumOffsets.add(idx.offset());
      }
 else       accumOffsets.add(idx.offset());
      shapeIndex++;
      strideIndex++;
      continue;
    }
    accumShape.add(shape[shapeIndex++]);
    accumStrides.add(arr.stride(strideIndex++));
    accumOffsets.add(idx.offset());
  }
  while (shapeIndex < shape.length) {
    if (Shape.isVector(shape)) {
      accumShape.add(1);
      shapeIndex++;
    }
 else     accumShape.add(shape[shapeIndex++]);
  }
  int delta=(shape.length <= 2 ? shape.length : shape.length - numPointIndexes);
  boolean needsFilledIn=accumShape.size() != accumStrides.size() && accumOffsets.size() != accumShape.size();
  while (accumOffsets.size() < delta && needsFilledIn)   accumOffsets.add(0);
  while (accumShape.size() < 2) {
    if (Shape.isRowVectorShape(arr.shape()))     accumShape.add(0,1);
 else     accumShape.add(1);
  }
  if (newAxesPrepend > 0) {
    for (int i=0; i < newAxesPrepend; i++) {
      accumShape.add(0,1);
      accumStrides.add(0,0);
      accumOffsets.add(0,0);
    }
  }
  for (int i=0; i < prependNewAxes.size(); i++) {
    accumShape.add(prependNewAxes.get(i) - i,1);
    accumStrides.add(prependNewAxes.get(i) - i,0);
  }
  int trailingZeroRemove=accumOffsets.size() - 1;
  while (accumOffsets.size() > accumShape.size()) {
    if (accumOffsets.get(trailingZeroRemove) == 0)     accumOffsets.remove(accumOffsets.size() - 1);
    trailingZeroRemove--;
  }
  if (accumStrides.size() < accumOffsets.size())   accumStrides.addAll(pointStrides);
  while (accumOffsets.size() < accumShape.size()) {
    if (Shape.isRowVectorShape(arr.shape()))     accumOffsets.add(0,0);
 else     accumOffsets.add(0);
  }
  while (accumStrides.size() < accumOffsets.size()) {
    if (arr.isRowVector())     accumStrides.add(0,arr.elementStride());
 else     accumStrides.add(arr.elementStride());
  }
  this.strides=Ints.toArray(accumStrides);
  this.shapes=Ints.toArray(accumShape);
  this.offsets=Ints.toArray(accumOffsets);
  if (numPointIndexes > 0 && !pointStrides.isEmpty()) {
    if (newAxesPrepend >= 1) {
      while (pointStrides.size() < accumOffsets.size()) {
        pointStrides.add(1);
      }
      for (int i=0; i < accumStrides.size(); i++) {
        if (accumStrides.get(i) == 0)         pointStrides.set(i,0);
      }
    }
 else {
      while (pointStrides.size() < pointStrides.size()) {
        pointStrides.add(1);
      }
    }
    if (arr.isRowVector() && !intervalStrides.isEmpty() && pointOffsets.get(0) == 0)     this.offset=indexes[1].offset();
 else     this.offset=ArrayUtil.dotProduct(pointOffsets,pointStrides);
  }
 else   if (numIntervals > 0) {
    this.offset=ArrayUtil.dotProduct(accumOffsets,accumStrides) / numIntervals;
  }
 else   this.offset=ArrayUtil.calcOffset(accumShape,accumOffsets,accumStrides);
}"
3337,"@Test public void testTensorDot(){
  INDArray oneThroughSixty=Nd4j.arange(60).reshape(3,4,5);
  INDArray oneThroughTwentyFour=Nd4j.arange(24).reshape(4,3,2);
  INDArray result=Nd4j.tensorMmul(oneThroughSixty,oneThroughTwentyFour,new int[][]{{1,0},{0,1}});
  assertArrayEquals(new int[]{5,2},result.shape());
  INDArray assertion=Nd4j.create(new double[][]{{4400,4730},{4532,4874},{4664,5018},{4796,5162},{4928,5306}});
  assertEquals(assertion,result);
}","@Test public void testTensorDot(){
  INDArray w=Nd4j.valueArrayOf(new int[]{2,1,2,2},0.5);
  INDArray col=Nd4j.create(new double[]{1,1,1,1,3,3,3,3,1,1,1,1,3,3,3,3,1,1,1,1,3,3,3,3,1,1,1,1,3,3,3,3,2,2,2,2,4,4,4,4,2,2,2,2,4,4,4,4,2,2,2,2,4,4,4,4,2,2,2,2,4,4,4,4},new int[]{1,1,2,2,4,4});
  INDArray test=Nd4j.tensorMmul(col,w,new int[][]{{1,2,3},{1,2,3}});
  INDArray assertion2=Nd4j.create(new double[]{3.,3.,3.,3.,3.,3.,3.,3.,7.,7.,7.,7.,7.,7.,7.,7.,3.,3.,3.,3.,3.,3.,3.,3.,7.,7.,7.,7.,7.,7.,7.,7.},new int[]{1,4,4,2},new int[]{16,8,2,1},0,'f');
  assertion2.setOrder('f');
  assertEquals(assertion2,test);
  INDArray oneThroughSixty=Nd4j.arange(60).reshape(3,4,5);
  INDArray oneThroughTwentyFour=Nd4j.arange(24).reshape(4,3,2);
  INDArray result=Nd4j.tensorMmul(oneThroughSixty,oneThroughTwentyFour,new int[][]{{1,0},{0,1}});
  assertArrayEquals(new int[]{5,2},result.shape());
  INDArray assertion=Nd4j.create(new double[][]{{4400,4730},{4532,4874},{4664,5018},{4796,5162},{4928,5306}},'f');
  assertEquals(assertion,result);
}"
3338,"@Override protected void sgemm(char Order,char TransA,char TransB,int M,int N,int K,float alpha,INDArray A,int lda,INDArray B,int ldb,float beta,INDArray C,int ldc){
  A=Shape.toOffsetZero(A);
  B=Shape.toOffsetZero(B);
  DataBuffer aData=A.data();
  DataBuffer bData=B.data();
  float[] cData=getFloatData(C);
  BLAS.getInstance().sgemm(String.valueOf(TransA),String.valueOf(TransB),M,N,K,alpha,aData.asFloat(),getBlasOffset(A),lda,bData.asFloat(),getBlasOffset(B),ldb,beta,cData,getBlasOffset(C),ldc);
  setData(cData,C);
}","@Override protected void sgemm(char Order,char TransA,char TransB,int M,int N,int K,float alpha,INDArray A,int lda,INDArray B,int ldb,float beta,INDArray C,int ldc){
  DataBuffer aData=A.data();
  DataBuffer bData=B.data();
  float[] cData=getFloatData(C);
  BLAS.getInstance().sgemm(String.valueOf(TransA),String.valueOf(TransB),M,N,K,alpha,aData.asFloat(),getBlasOffset(A),lda,bData.asFloat(),getBlasOffset(B),ldb,beta,cData,getBlasOffset(C),ldc);
  setData(cData,C);
}"
3339,"protected void collectRows(INDArray slice){
  if (slice.isRowVector()) {
    vectors.add(slice);
  }
 else   if (isMatrix()) {
    for (int i=0; i < slice.rows(); i++)     vectors.add(slice.getRow(i));
  }
 else   for (int i=0; i < slice.slices(); i++)   collectRows(slice.slice(i));
}","protected void collectRows(INDArray slice){
  if (slice.isRowVector()) {
    vectors.add(slice);
  }
 else   if (slice.isMatrix()) {
    for (int i=0; i < slice.rows(); i++)     vectors.add(slice.getRow(i));
  }
 else   for (int i=0; i < slice.slices(); i++)   collectRows(slice.slice(i));
}"
3340,"/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public INDArray broadcast(int[] shape){
  ensureNotCleanedUp();
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=this.shape.length - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  if (isScalar()) {
    INDArray ret=Nd4j.valueArrayOf(shape,getDouble(0));
    return ret;
  }
 else   if (isColumnVector() && Shape.isMatrix(shape)) {
    INDArray ret=create(shape);
    for (int i=0; i < ret.columns(); i++)     ret.putColumn(i,this.dup());
    return ret;
  }
 else   if (isRowVector()) {
    INDArray ret=create(shape);
    for (int i=0; i < ret.rows(); i++)     ret.putRow(i,this.dup());
    return ret;
  }
  int[] retShape=new int[shape.length];
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(1,shape[i]);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],shape()[i]);
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < shape().length)       retShape[i]=Math.max(shape[i],shape()[i]);
 else       retShape[i]=shape[i];
    }
  }
  INDArray ret=create(retShape);
  INDArray linear=ret.linearView();
  INDArray thisLinear=linearView();
  int bufferIdx=0;
  for (int i=0; i < ret.length(); i++) {
    linear.putScalar(i,thisLinear.getDouble(bufferIdx));
    bufferIdx++;
    if (bufferIdx >= length())     bufferIdx=0;
  }
  return ret;
}","/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public INDArray broadcast(int[] shape){
  ensureNotCleanedUp();
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=this.shape.length - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  int[] retShape=new int[shape.length];
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(1,shape[i]);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],shape()[i]);
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < shape().length)       retShape[i]=Math.max(shape[i],shape()[i]);
 else       retShape[i]=shape[i];
    }
  }
  INDArray ret=create(retShape);
  INDArray linear=ret.linearView();
  INDArray thisLinear=linearView();
  int bufferIdx=0;
  for (int i=0; i < ret.length(); i++) {
    linear.putScalar(i,thisLinear.getDouble(bufferIdx));
    bufferIdx++;
    if (bufferIdx >= length())     bufferIdx=0;
  }
  return ret;
}"
3341,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  if (isVector()) {
    if (isRowVector()) {
      if (indexes.length == 1) {
        int offset=NDArrayIndex.offset(this,indexes[0]);
        int length=indexes[0].length();
        return create(data,new int[]{1,length},stride(),offset);
      }
 else {
        if (indexes[0].offset() > 0)         throw new IllegalArgumentException(""String_Node_Str"");
        int offset=NDArrayIndex.offset(this,indexes[1]);
        int length=indexes[1].length();
        return create(data,new int[]{1,length},stride(),offset);
      }
    }
 else {
      if (indexes.length == 1) {
        int offset=NDArrayIndex.offset(this,indexes[0]);
        int length=indexes[0].length();
        return create(data,new int[]{length,1},stride(),offset);
      }
 else {
        if (indexes[1].offset() > 0)         throw new IllegalArgumentException(""String_Node_Str"");
        int offset=NDArrayIndex.offset(this,indexes[0]);
        int length=indexes[0].length();
        return create(data,new int[]{length,1},stride(),offset);
      }
    }
  }
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  int[] stride=Indices.stride(this);
  int offsetAugment=0;
  if (shape[0] == 1 && shape.length > 2) {
    int[] newShape=new int[shape.length - 1];
    for (int i=0; i < newShape.length; i++) {
      newShape[i]=shape[i + 1];
    }
    shape=newShape;
    if (offsets.length > newShape.length) {
      int[] newOffsets=new int[offsets.length - 1];
      for (int i=0; i < newOffsets.length; i++) {
        newOffsets[i]=offsets[i + 1];
      }
      if (ordering() == 'c')       offsetAugment=offsets[0] * stride[0];
 else {
        offsetAugment=offsets[0] * stride[0];
      }
      offsets=newOffsets;
    }
    if (stride.length > offsets.length) {
      int[] newStrides=new int[stride.length - 1];
      for (int i=0; i < newStrides.length; i++) {
        newStrides[i]=stride[i + 1];
      }
      stride=newStrides;
    }
  }
  if (stride.length > offsets.length) {
    stride=Arrays.copyOfRange(stride,1,stride.length);
  }
  if (offsets.length > shape.length) {
    offsets=ArrayUtil.removeIndex(offsets,ArrayUtil.range(0,shape.length));
  }
  if (ArrayUtil.prod(shape) == 1 && rank() > 2) {
    if (this instanceof IComplexNDArray) {
      IComplexNDArray arr=(IComplexNDArray)this;
      return Nd4j.scalar(arr.getComplex(indexes[indexes.length - 1].indices()[0]));
    }
    return Nd4j.scalar(getDouble(indexes[indexes.length - 1].indices()[0]));
  }
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else       if (indexes.length == 2 && isMatrix()) {
        for (int i=0; i < ret.slices(); i++) {
          int sliceToGetFrom=indexes[0].indices()[i];
          if (sliceToGetFrom >= slices())           break;
          INDArray slice=slice(sliceToGetFrom);
          INDArray retSlice=ret.slice(i);
          int[] finalIndices=indexes[1].indices();
          for (int j=0; j < retSlice.length(); j++) {
            if (j >= retSlice.length() || finalIndices[j] >= slice.length())             break;
            retSlice.putScalar(j,slice.getDouble(finalIndices[j]));
          }
        }
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    INDArray ret=create(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getDouble(get));
        count++;
      }
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  INDArray ret=subArray(offsets,shape,stride);
  if (offsetAugment > 0)   ret=create(ret.data(),ret.shape(),ret.stride(),ret.offset() + offsetAugment);
  return ret;
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  int[] stride=Indices.stride(this);
  int offsetAugment=0;
  if (shape[0] == 1 && shape.length > 2) {
    int[] newShape=new int[shape.length - 1];
    for (int i=0; i < newShape.length; i++) {
      newShape[i]=shape[i + 1];
    }
    shape=newShape;
    if (offsets.length > newShape.length) {
      int[] newOffsets=new int[offsets.length - 1];
      for (int i=0; i < newOffsets.length; i++) {
        newOffsets[i]=offsets[i + 1];
      }
      if (ordering() == 'c')       offsetAugment=offsets[0] * stride[0];
 else {
        offsetAugment=offsets[0] * stride[0];
      }
      offsets=newOffsets;
    }
    if (stride.length > offsets.length) {
      int[] newStrides=new int[stride.length - 1];
      for (int i=0; i < newStrides.length; i++) {
        newStrides[i]=stride[i + 1];
      }
      stride=newStrides;
    }
  }
  if (stride.length > offsets.length) {
    stride=Arrays.copyOfRange(stride,1,stride.length);
  }
  if (offsets.length > shape.length) {
    offsets=ArrayUtil.removeIndex(offsets,ArrayUtil.range(0,shape.length));
  }
  if (ArrayUtil.prod(shape) == 1 && rank() > 2) {
    if (this instanceof IComplexNDArray) {
      IComplexNDArray arr=(IComplexNDArray)this;
      return Nd4j.scalar(arr.getComplex(indexes[indexes.length - 1].indices()[0]));
    }
    return Nd4j.scalar(getDouble(indexes[indexes.length - 1].indices()[0]));
  }
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else       if (indexes.length == 2 && isMatrix()) {
        for (int i=0; i < ret.slices(); i++) {
          int sliceToGetFrom=indexes[0].indices()[i];
          if (sliceToGetFrom >= slices())           break;
          INDArray slice=slice(sliceToGetFrom);
          INDArray retSlice=ret.slice(i);
          int[] finalIndices=indexes[1].indices();
          for (int j=0; j < retSlice.length(); j++) {
            if (j >= retSlice.length() || finalIndices[j] >= slice.length())             break;
            retSlice.putScalar(j,slice.getDouble(finalIndices[j]));
          }
        }
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    INDArray ret=create(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getDouble(get));
        count++;
      }
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  INDArray ret=subArray(offsets,shape,stride);
  if (offsetAugment > 0)   ret=create(ret.data(),ret.shape(),ret.stride(),ret.offset() + offsetAugment);
  return ret;
}"
3342,"/** 
 * Start the server
 */
public void start(){
  try {
    InputStream is=new ClassPathResource(resourcePath).getInputStream();
    File tmpConfig=new File(resourcePath);
    if (!tmpConfig.getParentFile().exists())     tmpConfig.getParentFile().mkdirs();
    BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(tmpConfig));
    IOUtils.copy(is,bos);
    bos.flush();
    run(new String[]{""String_Node_Str"",tmpConfig.getAbsolutePath()});
    tmpConfig.deleteOnExit();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Start the server
 */
public void start(){
  try {
    InputStream is=new ClassPathResource(resourcePath,InstrumentationApplication.class.getClassLoader()).getInputStream();
    File tmpConfig=new File(resourcePath);
    if (!tmpConfig.getParentFile().exists())     tmpConfig.getParentFile().mkdirs();
    BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(tmpConfig));
    IOUtils.copy(is,bos);
    bos.flush();
    run(new String[]{""String_Node_Str"",tmpConfig.getAbsolutePath()});
    tmpConfig.deleteOnExit();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
3343,"@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS);
}","@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS,JavaBackend.class.getClassLoader());
}"
3344,"@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS);
}","@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS,JblasBackend.class.getClassLoader());
}"
3345,"@Test public void testLoader() throws Exception {
  Nd4j.dtype=DataBuffer.Type.DOUBLE;
  KernelFunctionLoader loader=KernelFunctionLoader.getInstance();
  loader.load();
  ClassPathResource res=new ClassPathResource(""String_Node_Str"");
  if (!res.exists())   throw new IllegalStateException(""String_Node_Str"");
  Properties props=new Properties();
  props.load(res.getInputStream());
  loader.unload();
}","@Test public void testLoader() throws Exception {
  Nd4j.dtype=DataBuffer.Type.DOUBLE;
  KernelFunctionLoader loader=KernelFunctionLoader.getInstance();
  loader.load();
  ClassPathResource res=new ClassPathResource(""String_Node_Str"",KernelFunctionLoader.class.getClassLoader());
  if (!res.exists())   throw new IllegalStateException(""String_Node_Str"");
  Properties props=new Properties();
  props.load(res.getInputStream());
  loader.unload();
}"
3346,"@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS);
}","@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS,JCublasBackend.class.getClassLoader());
}"
3347,"/** 
 * Configure the given information based on the device
 */
public void configure(){
  if (confCalled)   return;
  syncThreads=Boolean.parseBoolean(System.getProperty(SYNC_THREADS,""String_Node_Str""));
  if (numDevices == 0) {
    getNumDevices();
  }
  for (int i=0; i < numDevices; i++) {
    ClassPathResource confFile=new ClassPathResource(""String_Node_Str"" + i);
    if (confFile.exists()) {
      Properties props=new Properties();
      try {
        props.load(confFile.getInputStream());
        confs.put(i,new DeviceConfiguration(i,props));
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
 else     confs.put(i,new DeviceConfiguration(i));
  }
  confCalled=true;
}","/** 
 * Configure the given information based on the device
 */
public void configure(){
  if (confCalled)   return;
  syncThreads=Boolean.parseBoolean(System.getProperty(SYNC_THREADS,""String_Node_Str""));
  if (numDevices == 0) {
    getNumDevices();
  }
  for (int i=0; i < numDevices; i++) {
    ClassPathResource confFile=new ClassPathResource(""String_Node_Str"" + i,ContextHolder.class.getClassLoader());
    if (confFile.exists()) {
      Properties props=new Properties();
      try {
        props.load(confFile.getInputStream());
        confs.put(i,new DeviceConfiguration(i,props));
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
 else     confs.put(i,new DeviceConfiguration(i));
  }
  confCalled=true;
}"
3348,"/** 
 * Singleton pattern
 * @return the instance for the context holder.
 */
public static synchronized ContextHolder getInstance(){
  if (INSTANCE == null) {
    Properties props=new Properties();
    try {
      props.load(new ClassPathResource(""String_Node_Str"").getInputStream());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    INSTANCE=new ContextHolder();
    INSTANCE.configure();
    for (    String pair : props.stringPropertyNames())     System.getProperties().put(pair,props.getProperty(pair));
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
      @Override public void run(){
        INSTANCE.destroy();
      }
    }
));
  }
  return INSTANCE;
}","/** 
 * Singleton pattern
 * @return the instance for the context holder.
 */
public static synchronized ContextHolder getInstance(){
  if (INSTANCE == null) {
    Properties props=new Properties();
    try {
      props.load(new ClassPathResource(""String_Node_Str"",ContextHolder.class.getClassLoader()).getInputStream());
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
    INSTANCE=new ContextHolder();
    INSTANCE.configure();
    for (    String pair : props.stringPropertyNames())     System.getProperties().put(pair,props.getProperty(pair));
    Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
      @Override public void run(){
        INSTANCE.destroy();
      }
    }
));
  }
  return INSTANCE;
}"
3349,"/** 
 * Load the appropriate functions from the class path in to one module
 * @return the module associated with this
 * @throws Exception
 */
public void load() throws Exception {
  if (init)   return;
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  ClassPathResource res=new ClassPathResource(""String_Node_Str"");
  if (!res.exists())   throw new IllegalStateException(""String_Node_Str"");
  Properties props=new Properties();
  props.load(res.getInputStream());
  log.info(""String_Node_Str"");
  ensureImports(props,""String_Node_Str"");
  ensureImports(props,""String_Node_Str"");
  compileAndLoad(props,FLOAT,""String_Node_Str"");
  compileAndLoad(props,DOUBLE,""String_Node_Str"");
  init=true;
}","/** 
 * Load the appropriate functions from the class path in to one module
 * @return the module associated with this
 * @throws Exception
 */
public void load() throws Exception {
  if (init)   return;
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  ClassPathResource res=new ClassPathResource(""String_Node_Str"",KernelFunctionLoader.class.getClassLoader());
  if (!res.exists())   throw new IllegalStateException(""String_Node_Str"");
  Properties props=new Properties();
  props.load(res.getInputStream());
  log.info(""String_Node_Str"");
  ensureImports(props,""String_Node_Str"");
  ensureImports(props,""String_Node_Str"");
  compileAndLoad(props,FLOAT,""String_Node_Str"");
  compileAndLoad(props,DOUBLE,""String_Node_Str"");
  init=true;
}"
3350,"private String loadFile(String file) throws IOException {
  ClassPathResource resource=new ClassPathResource(file);
  String tmpDir=System.getProperty(""String_Node_Str"");
  if (!resource.exists())   throw new IllegalStateException(""String_Node_Str"" + resource);
  File out=new File(tmpDir,file);
  if (!out.getParentFile().exists())   out.getParentFile().mkdirs();
  if (out.exists())   out.delete();
  out.createNewFile();
  BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(out));
  IOUtils.copy(resource.getInputStream(),bos);
  bos.flush();
  bos.close();
  out.deleteOnExit();
  return out.getAbsolutePath();
}","private String loadFile(String file) throws IOException {
  ClassPathResource resource=new ClassPathResource(file,KernelFunctionLoader.class.getClassLoader());
  String tmpDir=System.getProperty(""String_Node_Str"");
  if (!resource.exists())   throw new IllegalStateException(""String_Node_Str"" + resource);
  File out=new File(tmpDir,file);
  if (!out.getParentFile().exists())   out.getParentFile().mkdirs();
  if (out.exists())   out.delete();
  out.createNewFile();
  BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream(out));
  IOUtils.copy(resource.getInputStream(),bos);
  bos.flush();
  bos.close();
  out.deleteOnExit();
  return out.getAbsolutePath();
}"
3351,"/** 
 * Called at initialization in the static context. Registers cuda functions based on the cudafunctions.properties in the classpath
 * @throws IOException
 */
public static void register() throws Exception {
  ClassPathResource res=new ClassPathResource(""String_Node_Str"");
  if (!res.exists())   throw new IllegalStateException(""String_Node_Str"");
  Properties props=new Properties();
  props.load(res.getInputStream());
  KernelFunctionLoader.getInstance().load();
  String reduceFunctionsList=props.getProperty(REDUCE);
  for (  String function : reduceFunctionsList.split(""String_Node_Str""))   reduceFunctions.add(function);
  SHARED_MEM=Integer.parseInt(props.getProperty(SHARED_MEM_KEY,""String_Node_Str""));
  THREADS=Integer.parseInt(props.getProperty(THREADS_KEY,""String_Node_Str""));
  BLOCKS=Integer.parseInt(props.getProperty(BLOCKS_KEY,""String_Node_Str""));
}","/** 
 * Called at initialization in the static context. Registers cuda functions based on the cudafunctions.properties in the classpath
 * @throws IOException
 */
public static void register() throws Exception {
  ClassPathResource res=new ClassPathResource(""String_Node_Str"",KernelFunctions.class.getClassLoader());
  if (!res.exists())   throw new IllegalStateException(""String_Node_Str"");
  Properties props=new Properties();
  props.load(res.getInputStream());
  KernelFunctionLoader.getInstance().load();
  String reduceFunctionsList=props.getProperty(REDUCE);
  for (  String function : reduceFunctionsList.split(""String_Node_Str""))   reduceFunctions.add(function);
  SHARED_MEM=Integer.parseInt(props.getProperty(SHARED_MEM_KEY,""String_Node_Str""));
  THREADS=Integer.parseInt(props.getProperty(THREADS_KEY,""String_Node_Str""));
  BLOCKS=Integer.parseInt(props.getProperty(BLOCKS_KEY,""String_Node_Str""));
}"
3352,"@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS);
}","@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS,NetlibBlasBackend.class.getClassLoader());
}"
3353,"public static List<DataSet> loadIris(int from,int to) throws IOException {
  ClassPathResource resource=new ClassPathResource(""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") List<String> lines=IOUtils.readLines(resource.getInputStream());
  List<DataSet> list=new ArrayList<>();
  INDArray ret=Nd4j.ones(Math.abs(to - from),4);
  double[][] outcomes=new double[lines.size()][3];
  int putCount=0;
  for (int i=from; i < to; i++) {
    String line=lines.get(i);
    String[] split=line.split(""String_Node_Str"");
    addRow(ret,putCount++,split);
    String outcome=split[split.length - 1];
    double[] rowOutcome=new double[3];
    rowOutcome[Integer.parseInt(outcome)]=1;
    outcomes[i]=rowOutcome;
  }
  for (int i=0; i < ret.rows(); i++)   list.add(new DataSet(ret.getRow(i),Nd4j.create(outcomes[from + i])));
  return list;
}","public static List<DataSet> loadIris(int from,int to) throws IOException {
  ClassPathResource resource=new ClassPathResource(""String_Node_Str"",IrisUtils.class.getClassLoader());
  @SuppressWarnings(""String_Node_Str"") List<String> lines=IOUtils.readLines(resource.getInputStream());
  List<DataSet> list=new ArrayList<>();
  INDArray ret=Nd4j.ones(Math.abs(to - from),4);
  double[][] outcomes=new double[lines.size()][3];
  int putCount=0;
  for (int i=from; i < to; i++) {
    String line=lines.get(i);
    String[] split=line.split(""String_Node_Str"");
    addRow(ret,putCount++,split);
    String outcome=split[split.length - 1];
    double[] rowOutcome=new double[3];
    rowOutcome[Integer.parseInt(outcome)]=1;
    outcomes[i]=rowOutcome;
  }
  for (int i=0; i < ret.rows(); i++)   list.add(new DataSet(ret.getRow(i),Nd4j.create(outcomes[from + i])));
  return list;
}"
3354,"@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS);
}","@Override public Resource getConfigurationResource(){
  return new ClassPathResource(LINALG_PROPS,CpuBackend.class.getClassLoader());
}"
3355,"private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException {
  stream.defaultReadObject();
  doReadObject(stream);
  copied=new HashMap<>();
  pointersToContexts=HashBasedTable.create();
  ref=new WeakReference<DataBuffer>(this,Nd4j.bufferRefQueue());
  freed=new AtomicBoolean(false);
}","private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException {
  doReadObject(stream);
  copied=new HashMap<>();
  pointersToContexts=HashBasedTable.create();
  ref=new WeakReference<DataBuffer>(this,Nd4j.bufferRefQueue());
  freed=new AtomicBoolean(false);
}"
3356,"@Override protected int idamax(int N,INDArray X,int incX){
  return NativeBlas.idamax(N,getDoubleData(X),getBlasOffset(X),incX);
}","@Override protected int idamax(int N,INDArray X,int incX){
  return NativeBlas.idamax(N,getDoubleData(X),getBlasOffset(X),incX) - 1;
}"
3357,"@Override protected int icamax(int N,IComplexNDArray X,int incX){
  return NativeBlas.icamax(N,getFloatData(X),getBlasOffset(X),incX);
}","@Override protected int icamax(int N,IComplexNDArray X,int incX){
  return NativeBlas.icamax(N,getFloatData(X),getBlasOffset(X),incX) - 1;
}"
3358,"protected void doWriteObject(java.io.ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  out.writeUTF(allocationMode.name());
  out.writeLong(length());
  out.writeUTF(dataType().name());
  if (dataType() == Type.DOUBLE) {
    for (int i=0; i < length(); i++)     out.writeDouble(getDouble(i));
  }
 else {
    for (int i=0; i < length(); i++)     out.writeFloat(getFloat(i));
  }
  out.flush();
}","protected void doWriteObject(java.io.ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  out.writeUTF(allocationMode.name());
  out.writeInt(length());
  out.writeUTF(dataType().name());
  if (dataType() == Type.DOUBLE) {
    for (int i=0; i < length(); i++)     out.writeDouble(getDouble(i));
  }
 else {
    for (int i=0; i < length(); i++)     out.writeFloat(getFloat(i));
  }
  out.flush();
}"
3359,"/** 
 * Sync the device
 */
public static void sync(){
  JCuda.cudaDeviceSynchronize();
  ContextHolder.syncStream();
}","/** 
 * Sync the device
 */
public static void sync(){
  ContextHolder.syncStream();
}"
3360,"@Override protected void cdotc_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotc){
}","@Override protected void cdotc_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotc){
  throw new UnsupportedOperationException();
}"
3361,"@Override protected void zdotc_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotc){
}","@Override protected void zdotc_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotc){
  throw new UnsupportedOperationException();
}"
3362,"@Override protected void drotmg(double d1,double d2,double b1,double b2,INDArray P){
}","@Override protected void drotmg(double d1,double d2,double b1,double b2,INDArray P){
  throw new UnsupportedOperationException();
}"
3363,"@Override protected void drot(int N,INDArray X,int incX,INDArray Y,int incY,double c,double s){
}","@Override protected void drot(int N,INDArray X,int incX,INDArray Y,int incY,double c,double s){
  throw new UnsupportedOperationException();
}"
3364,"@Override protected void drotg(double a,double b,double c,double s){
}","@Override protected void drotg(double a,double b,double c,double s){
  throw new UnsupportedOperationException();
}"
3365,"@Override protected void srotm(int N,INDArray X,int incX,INDArray Y,int incY,INDArray P){
}","@Override protected void srotm(int N,INDArray X,int incX,INDArray Y,int incY,INDArray P){
  throw new UnsupportedOperationException();
}"
3366,"@Override protected void srotg(float a,float b,float c,float s){
}","@Override protected void srotg(float a,float b,float c,float s){
  throw new UnsupportedOperationException();
}"
3367,"@Override protected void srotmg(float d1,float d2,float b1,float b2,INDArray P){
}","@Override protected void srotmg(float d1,float d2,float b1,float b2,INDArray P){
  throw new UnsupportedOperationException();
}"
3368,"@Override protected double dsdot(int N,INDArray X,int incX,INDArray Y,int incY){
  return 0;
}","@Override protected double dsdot(int N,INDArray X,int incX,INDArray Y,int incY){
  throw new UnsupportedOperationException();
}"
3369,"@Override protected void drotm(int N,INDArray X,int incX,INDArray Y,int incY,INDArray P){
}","@Override protected void drotm(int N,INDArray X,int incX,INDArray Y,int incY,INDArray P){
  throw new UnsupportedOperationException();
}"
3370,"@Override protected void zdotu_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotu){
}","@Override protected void zdotu_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotu){
  throw new UnsupportedOperationException();
}"
3371,"@Override protected void srot(int N,INDArray X,int incX,INDArray Y,int incY,float c,float s){
}","@Override protected void srot(int N,INDArray X,int incX,INDArray Y,int incY,float c,float s){
  throw new UnsupportedOperationException();
}"
3372,"@Override protected float sdsdot(int N,float alpha,INDArray X,int incX,INDArray Y,int incY){
  return 0;
}","@Override protected float sdsdot(int N,float alpha,INDArray X,int incX,INDArray Y,int incY){
  throw new UnsupportedOperationException();
}"
3373,"@Override protected void cdotu_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotu){
}","@Override protected void cdotu_sub(int N,IComplexNDArray X,int incX,IComplexNDArray Y,int incY,IComplexNDArray dotu){
  throw new UnsupportedOperationException();
}"
3374,"/** 
 * Fetch a particular number on a multi dimensional scale.
 * @param indexes the indexes to get a number from
 * @return the number at the specified indices
 */
@Override public INDArray getScalar(int... indexes){
  int ix=offset;
  for (int i=0; i < indexes.length; i++) {
    ix+=indexes[i] * stride[i];
  }
  if (ix >= data.length())   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(indexes));
  return createScalar(data.getDouble(ix));
}","/** 
 * Fetch a particular number on a multi dimensional scale.
 * @param indexes the indexes to get a number from
 * @return the number at the specified indices
 */
@Override public INDArray getScalar(int... indexes){
  int ix=offset;
  for (int i=0; i < indexes.length; i++) {
    ix+=indexes[i] * stride[i];
  }
  if (ix >= data.length())   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(indexes));
  return createScalarForIndex(ix,false);
}"
3375,"/** 
 * Get the specified column
 * @param c
 */
@Override public INDArray getColumn(int c){
  ensureNotCleanedUp();
  if (shape.length == 2)   return vectorAlongDimension(c,0);
 else   if (isRowVector()) {
    return createScalar(getDouble(c));
  }
 else   if (isColumnVector() && c == 0)   return this;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Get the specified column
 * @param c
 */
@Override public INDArray getColumn(int c){
  ensureNotCleanedUp();
  if (shape.length == 2)   return vectorAlongDimension(c,0);
 else   if (isRowVector()) {
    return createScalarForIndex(c,true);
  }
 else   if (isColumnVector() && c == 0)   return this;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}"
3376,"/** 
 * Get a copy of a row.
 * @param r the row to get
 */
@Override public INDArray getRow(int r){
  ensureNotCleanedUp();
  if (shape.length == 2) {
    if (isColumnVector())     return createScalar(getDouble(r));
    return vectorAlongDimension(r,1);
  }
 else   if (size(0) == 1 && shape.length == 3) {
    return slice(0).vectorAlongDimension(r,1);
  }
 else   if (isRowVector() && r == 0)   return this;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Get a copy of a row.
 * @param r the row to get
 */
@Override public INDArray getRow(int r){
  ensureNotCleanedUp();
  if (shape.length == 2) {
    if (isColumnVector())     return createScalarForIndex(r,true);
    return vectorAlongDimension(r,1);
  }
 else   if (size(0) == 1 && shape.length == 3) {
    return slice(0).vectorAlongDimension(r,1);
  }
 else   if (isRowVector() && r == 0)   return this;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}"
3377,"public int[] sliceStride(int slice){
  if (hasOneStride() && ordering() == NDArrayFactory.FORTRAN) {
    int[] ret=new int[stride.length - 1];
    Arrays.fill(ret,1);
    if (ordering() == NDArrayFactory.C) {
      int firstNon1=getFirstNonOneStrideIdx();
      int count=0;
      for (int i=firstNon1; i < stride.length; i++) {
        if (stride[i] > elementStride()) {
          ret[count++]=stride[i];
        }
      }
    }
 else {
      int firstNon1=getFirstNonOneStrideIdx();
      int count=0;
      for (int i=firstNon1; i < stride.length; i++) {
        if (stride[i] > elementStride()) {
          ret[count++]=stride[i];
        }
      }
    }
    return ret;
  }
  return Arrays.copyOfRange(stride,1,stride.length);
}","public int[] sliceStride(){
  if (hasOneStride() && ordering() == NDArrayFactory.FORTRAN) {
    int[] ret=new int[stride.length - 1];
    Arrays.fill(ret,1);
    if (ordering() == NDArrayFactory.C) {
      int firstNon1=getFirstNonOneStrideIdx();
      int count=0;
      for (int i=firstNon1; i < stride.length; i++) {
        if (stride[i] > elementStride()) {
          ret[count++]=stride[i];
        }
      }
    }
 else {
      int firstNon1=getFirstNonOneStrideIdx();
      int count=0;
      for (int i=firstNon1; i < stride.length; i++) {
        if (stride[i] > elementStride()) {
          ret[count++]=stride[i];
        }
      }
    }
    return ret;
  }
  return Arrays.copyOfRange(stride,1,stride.length);
}"
3378,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray diviRowVector(INDArray rowVector);","/** 
 * In place division of a row vector
 * @param rowVector the row vector used for division
 * @return the result of the division 
 */
INDArray diviRowVector(INDArray rowVector);"
3379,"/** 
 * In place reverse divison of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray rdiviColumnVector(INDArray columnVector);","/** 
 * In place reverse divison of a column vector
 * @param columnVector the column vector used for division
 * @return the result of the division 
 */
INDArray rdiviColumnVector(INDArray columnVector);"
3380,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray rsubRowVector(INDArray rowVector);","/** 
 * Reverse subtraction of a row vector (copy)
 * @param rowVector the row vector to subtract
 * @return the result of the subtraction
 */
INDArray rsubRowVector(INDArray rowVector);"
3381,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray muliColumnVector(INDArray columnVector);","/** 
 * In place multiplication of a column vector
 * @param columnVector the column vector used for multiplication
 * @return the result of the multiplication
 */
INDArray muliColumnVector(INDArray columnVector);"
3382,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray rdiviRowVector(INDArray rowVector);","/** 
 * In place reverse division of a column vector
 * @param rowVector the row vector used for division
 * @return the result of the division 
 */
INDArray rdiviRowVector(INDArray rowVector);"
3383,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray divColumnVector(INDArray columnVector);","/** 
 * Division of a column vector (copy)
 * @param columnVector the column vector used for division
 * @return the result of the division 
 */
INDArray divColumnVector(INDArray columnVector);"
3384,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray addiRowVector(INDArray rowVector);","/** 
 * In place addition of a row vector
 * @param rowVector the row vector to add
 * @return the result of the addition
 */
INDArray addiRowVector(INDArray rowVector);"
3385,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray divRowVector(INDArray rowVector);","/** 
 * Division of a row vector (copy)
 * @param rowVector the row vector used for division
 * @return the result of the division 
 */
INDArray divRowVector(INDArray rowVector);"
3386,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray rsubiColumnVector(INDArray columnVector);","/** 
 * In place reverse subtraction of a column vector
 * @param columnVector the column vector to subtract
 * @return the result of the subtraction
 */
INDArray rsubiColumnVector(INDArray columnVector);"
3387,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray addColumnVector(INDArray columnVector);","/** 
 * Addition of a column vector (copy)
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray addColumnVector(INDArray columnVector);"
3388,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray mulColumnVector(INDArray columnVector);","/** 
 * Multiplication of a column vector (copy)
 * @param columnVector the column vector used for multiplication
 * @return the result of the multiplication
 */
INDArray mulColumnVector(INDArray columnVector);"
3389,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray subiRowVector(INDArray rowVector);","/** 
 * In place subtraction of a row vector
 * @param rowVector the row vector to subtract
 * @return the result of the subtraction
 */
INDArray subiRowVector(INDArray rowVector);"
3390,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray mulRowVector(INDArray rowVector);","/** 
 * Multiplication of a row vector (copy)
 * @param rowVector the row vector used for multiplication
 * @return the result of the multiplication
 */
INDArray mulRowVector(INDArray rowVector);"
3391,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray addRowVector(INDArray rowVector);","/** 
 * Addition of a row vector (copy)
 * @param rowVector the row vector to add
 * @return the result of the addition
 */
INDArray addRowVector(INDArray rowVector);"
3392,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray diviColumnVector(INDArray columnVector);","/** 
 * In place division of a column vector
 * @param columnVector the column vector used for division
 * @return the result of the division 
 */
INDArray diviColumnVector(INDArray columnVector);"
3393,"/** 
 * In place reverse division of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray rdivColumnVector(INDArray columnVector);","/** 
 * Reverse division of a column vector (copy)
 * @param columnVector the column vector used for division
 * @return the result of the division 
 */
INDArray rdivColumnVector(INDArray columnVector);"
3394,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray rsubColumnVector(INDArray columnVector);","/** 
 * Reverse subtraction of a column vector (copy)
 * @param columnVector the column vector to subtract
 * @return the result of the subtraction
 */
INDArray rsubColumnVector(INDArray columnVector);"
3395,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray subiColumnVector(INDArray columnVector);","/** 
 * In place subtraction of a column vector
 * @param columnVector the column vector to subtract
 * @return the result of the subtraction
 */
INDArray subiColumnVector(INDArray columnVector);"
3396,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray muliRowVector(INDArray rowVector);","/** 
 * In place multiplication of a row vector
 * @param rowVector the row vector used for multiplication
 * @return the result of the multiplication
 */
INDArray muliRowVector(INDArray rowVector);"
3397,"/** 
 * In place addition of a column vector
 * @param columnVector the column vector to add
 * @return the result of the addition
 */
INDArray subColumnVector(INDArray columnVector);","/** 
 * Subtraction of a column vector (copy)
 * @param columnVector the column vector to subtract
 * @return the result of the subtraction
 */
INDArray subColumnVector(INDArray columnVector);"
3398,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray subRowVector(INDArray rowVector);","/** 
 * Subtraction of a row vector (copy)
 * @param rowVector the row vector to subtract
 * @return the result of the subtraction
 */
INDArray subRowVector(INDArray rowVector);"
3399,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray rdivRowVector(INDArray rowVector);","/** 
 * Reverse division of a column vector (copy)
 * @param rowVector the row vector used for division
 * @return the result of the division 
 */
INDArray rdivRowVector(INDArray rowVector);"
3400,"/** 
 * In place addition of a column vector
 * @param rowVector the column vector to add
 * @return the result of the addition
 */
INDArray rsubiRowVector(INDArray rowVector);","/** 
 * In place reverse subtraction of a row vector
 * @param rowVector the row vector to subtract
 * @return the result of the subtraction
 */
INDArray rsubiRowVector(INDArray rowVector);"
3401,"/** 
 * Compute the linear offset for an index in an ndarray. For c ordering this is just the index itself. For fortran ordering, the following algorithm is used. Assuming an ndarray is a list of vectors. The index of the vector relative to the given index is calculated. vectorAlongDimension is then used along the last dimension using the computed index. The offset + the computed column wrt the index: (index % the size of the last dimension) will render the given index in fortran ordering
 * @param index the index
 * @param arr the array
 * @return the linear offset
 */
public static int linearOffset(int index,INDArray arr){
  if (arr.ordering() == NDArrayFactory.C) {
    double otherTest=Double.valueOf(index) % Double.valueOf(arr.size(-1));
    int test=(int)Math.floor(otherTest);
    INDArray vec=arr.vectorAlongDimension(test,-1);
    int otherDim=arr.vectorAlongDimension(test,-1).offset() + index;
    return otherDim;
  }
 else {
    int majorStride=arr.stride(-2);
    int vectorsAlongDimension=arr.vectorsAlongDimension(-1);
    double rowCalc=(double)(index * majorStride) / (double)arr.length();
    int floor=(int)Math.floor(rowCalc);
    INDArray arrVector=arr.vectorAlongDimension(floor,-1);
    int columnIndex=index % arr.size(-1);
    int retOffset=arrVector.linearIndex(columnIndex);
    return retOffset;
  }
}","/** 
 * Compute the linear offset for an index in an ndarray. For c ordering this is just the index itself. For fortran ordering, the following algorithm is used. Assuming an ndarray is a list of vectors. The index of the vector relative to the given index is calculated. vectorAlongDimension is then used along the last dimension using the computed index. The offset + the computed column wrt the index: (index % the size of the last dimension) will render the given index in fortran ordering
 * @param index the index
 * @param arr the array
 * @return the linear offset
 */
public static int linearOffset(int index,INDArray arr){
  if (arr.ordering() == NDArrayFactory.C) {
    double otherTest=((double)index) % arr.size(-1);
    int test=(int)Math.floor(otherTest);
    INDArray vec=arr.vectorAlongDimension(test,-1);
    int otherDim=arr.vectorAlongDimension(test,-1).offset() + index;
    return otherDim;
  }
 else {
    int majorStride=arr.stride(-2);
    int vectorsAlongDimension=arr.vectorsAlongDimension(-1);
    double rowCalc=(double)(index * majorStride) / (double)arr.length();
    int floor=(int)Math.floor(rowCalc);
    INDArray arrVector=arr.vectorAlongDimension(floor,-1);
    int columnIndex=index % arr.size(-1);
    int retOffset=arrVector.linearIndex(columnIndex);
    return retOffset;
  }
}"
3402,"/** 
 * Compute the linear offset for an index in an ndarray. For c ordering this is just the index itself. For fortran ordering, the following algorithm is used. Assuming an ndarray is a list of vectors. The index of the vector relative to the given index is calculated. vectorAlongDimension is then used along the last dimension using the computed index. The offset + the computed column wrt the index: (index % the size of the last dimension) will render the given index in fortran ordering
 * @param index the index
 * @param arr the array
 * @return the linear offset
 */
public static int rowNumber(int index,INDArray arr){
  double otherTest=Double.valueOf(index) / Double.valueOf(arr.size(-1));
  int test=(int)Math.floor(otherTest);
  int vectors=arr.vectorsAlongDimension(-1);
  if (test >= vectors)   return vectors - 1;
  return test;
}","/** 
 * Compute the linear offset for an index in an ndarray. For c ordering this is just the index itself. For fortran ordering, the following algorithm is used. Assuming an ndarray is a list of vectors. The index of the vector relative to the given index is calculated. vectorAlongDimension is then used along the last dimension using the computed index. The offset + the computed column wrt the index: (index % the size of the last dimension) will render the given index in fortran ordering
 * @param index the index
 * @param arr the array
 * @return the linear offset
 */
public static int rowNumber(int index,INDArray arr){
  double otherTest=((double)index) / arr.size(-1);
  int test=(int)Math.floor(otherTest);
  int vectors=arr.vectorsAlongDimension(-1);
  if (test >= vectors)   return vectors - 1;
  return test;
}"
3403,"/** 
 * Compute A <- alpha * x * y^T + A (general rank-1 update)
 */
@Override public INDArray ger(float alpha,INDArray x,INDArray y,INDArray a){
  DataTypeValidation.assertFloat(x,y,a);
  NativeBlas.sger(a.rows(),a.columns(),alpha,x.data().asFloat(),x.offset(),x.majorStride(),y.data().asFloat(),y.offset(),y.majorStride(),a.data().asFloat(),a.offset(),a.rows());
  return a;
}","/** 
 * Compute A <- alpha * x * y^T + A (general rank-1 update)
 */
@Override public INDArray ger(float alpha,INDArray x,INDArray y,INDArray a){
  if (x.data().dataType() == DataBuffer.Type.DOUBLE) {
    return ger((double)alpha,x,y,a);
  }
  DataTypeValidation.assertFloat(x,y,a);
  NativeBlas.sger(a.rows(),a.columns(),alpha,x.data().asFloat(),x.offset(),x.majorStride(),y.data().asFloat(),y.offset(),y.majorStride(),a.data().asFloat(),a.offset(),a.rows());
  return a;
}"
3404,"@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (isRowVector()) {
    offsets[0]=0;
  }
  int offset=this.offset + ArrayUtil.dotProduct(offsets,this.stride);
  if (ordering() == NDArrayFactory.C) {
    return create(data,Arrays.copyOf(shape,shape.length),ArrayUtil.reverseCopy(stride),offset,ordering);
  }
 else   if (ordering() == NDArrayFactory.FORTRAN) {
    return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
  }
  throw new IllegalStateException(""String_Node_Str"");
}","@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  boolean adjustOffsets=false;
  if (offsets.length > 1 && Shape.isRowVectorShape(shape) && offsets[0] > 0) {
    for (int i=1; i < offsets.length; i++) {
      if (offsets[i] == 0) {
        adjustOffsets=true;
        break;
      }
    }
    if (adjustOffsets) {
      for (int i=1; i < offsets.length; i++) {
        if (offsets[i] < 1)         offsets[i]=1;
      }
    }
  }
  int offset=this.offset + ArrayUtil.dotProduct(offsets,this.stride);
  if (adjustOffsets)   offset--;
  if (ordering() == NDArrayFactory.C) {
    return create(data,Arrays.copyOf(shape,shape.length),ArrayUtil.reverseCopy(stride),offset,ordering);
  }
 else   if (ordering() == NDArrayFactory.FORTRAN) {
    return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
3405,"/** 
 * Generic scoring function
 * @param labels            the labels to score
 * @param lossFunction      the loss function to use
 * @param z                 the output function
 * @param l2                the l2 coefficient
 * @param useRegularization whether to use regularization
 * @return the score for the given parameters
 */
public static double score(INDArray labels,LossFunction lossFunction,INDArray z,double l2,boolean useRegularization){
  double ret=0.0;
  double reg=0.5 * l2;
  if (!Arrays.equals(labels.shape(),z.shape()))   throw new IllegalArgumentException(""String_Node_Str"");
switch (lossFunction) {
case RECONSTRUCTION_CROSSENTROPY:
    INDArray xEntLogZ2=log(z);
  INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=log(z).rsubi(1);
ret=labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).muli(xEntOneMinusLogOneMinusZ2).sum(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case MCXENT:
INDArray columnSums=labels.mul(log(z));
ret=columnSums.mean(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsubi(1);
ret=labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).muli(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case RMSE_XENT:
INDArray rmseXentDiff=labels.sub(z);
INDArray squaredrmseXentDiff=pow(rmseXentDiff,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
ret=sqrt.sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5 * pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case SQUARED_LOSS:
ret=pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case NEGATIVELOGLIKELIHOOD:
ret=-Nd4j.mean(Nd4j.sum(labels.mul(log(z)).addi(labels.rsub(1).muli(log(z.rsub(1)))),1)).getDouble(0);
break;
}
if (useRegularization) ret+=reg;
ret/=(double)labels.rows();
return ret;
}","/** 
 * Generic scoring function. Note that an IllegalArgumentException is thrown if the given loss function is custom. An alternative mechanism for scoring (preferrably with a function name and the op factory) should be used instead.
 * @param labels            the labels to score
 * @param lossFunction      the loss function to use
 * @param z                 the output function
 * @param l2                the l2 coefficient
 * @param useRegularization whether to use regularization
 * @return the score for the given parameters
 */
public static double score(INDArray labels,LossFunction lossFunction,INDArray z,double l2,boolean useRegularization){
  double ret=0.0;
  double reg=0.5 * l2;
  if (!Arrays.equals(labels.shape(),z.shape()))   throw new IllegalArgumentException(""String_Node_Str"");
switch (lossFunction) {
case CUSTOM:
    throw new IllegalStateException(""String_Node_Str"");
case RECONSTRUCTION_CROSSENTROPY:
  INDArray xEntLogZ2=log(z);
INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=log(z).rsubi(1);
ret=labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).muli(xEntOneMinusLogOneMinusZ2).sum(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case MCXENT:
INDArray columnSums=labels.mul(log(z));
ret=columnSums.mean(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsubi(1);
ret=labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).muli(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case RMSE_XENT:
INDArray rmseXentDiff=labels.sub(z);
INDArray squaredrmseXentDiff=pow(rmseXentDiff,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
ret=sqrt.sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5 * pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case SQUARED_LOSS:
ret=pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case NEGATIVELOGLIKELIHOOD:
ret=-Nd4j.mean(Nd4j.sum(labels.mul(log(z)).addi(labels.rsub(1).muli(log(z.rsub(1)))),1)).getDouble(0);
break;
}
if (useRegularization) ret+=reg;
ret/=(double)labels.rows();
return ret;
}"
3406,"@Override public IComplexNDArray gemm(IComplexNumber alpha,IComplexNDArray a,IComplexNDArray b,IComplexNumber beta,IComplexNDArray c){
  DataTypeValidation.assertSameDataType(a,b,c);
  if (a.data().dataType() == DataBuffer.Type.FLOAT)   NativeBlas.cgemm('N','N',c.rows(),c.columns(),a.columns(),new ComplexFloat(alpha.realComponent().floatValue(),alpha.imaginaryComponent().floatValue()),a.data().asFloat(),a.blasOffset(),a.size(0),b.data().asFloat(),b.blasOffset(),b.size(0),new ComplexFloat(beta.realComponent().floatValue(),beta.imaginaryComponent().floatValue()),c.data().asFloat(),c.blasOffset(),c.size(0));
 else   NativeBlas.zgemm('N','N',c.rows(),c.columns(),a.columns(),new ComplexDouble(alpha.realComponent().floatValue(),alpha.imaginaryComponent().floatValue()),a.data().asDouble(),a.blasOffset(),a.size(0),b.data().asDouble(),b.blasOffset(),b.size(0),new ComplexDouble(beta.realComponent().floatValue(),beta.imaginaryComponent().floatValue()),c.data().asDouble(),c.blasOffset(),c.size(0));
  return c;
}","@Override public IComplexNDArray gemm(IComplexNumber alpha,IComplexNDArray a,IComplexNDArray b,IComplexNumber beta,IComplexNDArray c){
  DataTypeValidation.assertSameDataType(a,b,c);
  if (a.data().dataType() == DataBuffer.Type.FLOAT)   NativeBlas.cgemm('N','N',c.rows(),c.columns(),a.columns(),new ComplexFloat(alpha.realComponent().floatValue(),alpha.imaginaryComponent().floatValue()),a.data().asFloat(),a.offset() / 2,a.size(0),b.data().asFloat(),b.offset() / 2,b.size(0),new ComplexFloat(beta.realComponent().floatValue(),beta.imaginaryComponent().floatValue()),c.data().asFloat(),c.offset() / 2,c.size(0));
 else   NativeBlas.zgemm('N','N',c.rows(),c.columns(),a.columns(),new ComplexDouble(alpha.realComponent().floatValue(),alpha.imaginaryComponent().floatValue()),a.data().asDouble(),a.offset() / 2,a.size(0),b.data().asDouble(),b.offset() / 2,b.size(0),new ComplexDouble(beta.realComponent().floatValue(),beta.imaginaryComponent().floatValue()),c.data().asDouble(),c.offset() / 2,c.size(0));
  return c;
}"
3407,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else       if (indexes.length == 2 && isMatrix()) {
        for (int i=0; i < ret.slices(); i++) {
          int sliceToGetFrom=indexes[0].indices()[i];
          if (sliceToGetFrom >= slices())           break;
          INDArray slice=slice(sliceToGetFrom);
          INDArray retSlice=ret.slice(i);
          int[] finalIndices=indexes[1].indices();
          for (int j=0; j < retSlice.length(); j++) {
            if (j >= retSlice.length() || finalIndices[j] >= slice.length())             break;
            retSlice.putScalar(j,slice.getDouble(finalIndices[j]));
          }
        }
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    INDArray ret=create(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getDouble(get));
        count++;
      }
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  return subArray(offsets,shape,ArrayUtil.copy(stride()));
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else       if (indexes.length == 2 && isMatrix()) {
        for (int i=0; i < ret.slices(); i++) {
          int sliceToGetFrom=indexes[0].indices()[i];
          if (sliceToGetFrom >= slices())           break;
          INDArray slice=slice(sliceToGetFrom);
          INDArray retSlice=ret.slice(i);
          int[] finalIndices=indexes[1].indices();
          for (int j=0; j < retSlice.length(); j++) {
            if (j >= retSlice.length() || finalIndices[j] >= slice.length())             break;
            retSlice.putScalar(j,slice.getDouble(finalIndices[j]));
          }
        }
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    INDArray ret=create(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getDouble(get));
        count++;
      }
    }
 else     if (isVector()) {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  return subArray(offsets,shape,ArrayUtil.copy(stride()));
}"
3408,"@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int offset=this.offset + ArrayUtil.dotProduct(offsets,this.stride);
  if (ordering() == NDArrayFactory.C)   return create(data,Arrays.copyOf(shape,shape.length),ArrayUtil.reverseCopy(stride),offset,ordering);
  return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
}","@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  if (isRowVector()) {
    offsets[0]=0;
  }
  int offset=this.offset + ArrayUtil.dotProduct(offsets,this.stride);
  if (ordering() == NDArrayFactory.C)   return create(data,Arrays.copyOf(shape,shape.length),ArrayUtil.reverseCopy(stride),offset,ordering);
  return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
}"
3409,"/** 
 * The offsets (begin index) for each index
 * @param indices the indices
 * @return the offsets for the given set of indices
 */
public static int[] offsets(NDArrayIndex... indices){
  int[] ret=new int[indices.length];
  for (int i=0; i < indices.length; i++) {
    int offset=indices[i].offset();
    if (offset == 0 && i > 0 && i < indices.length - 1)     ret[i]=1;
 else     ret[i]=indices[i].offset();
  }
  return ret;
}","/** 
 * The offsets (begin index) for each index
 * @param indices the indices
 * @return the offsets for the given set of indices
 */
public static int[] offsets(NDArrayIndex... indices){
  int[] ret=new int[indices.length];
  for (int i=0; i < indices.length; i++) {
    int offset=indices[i].offset();
    if (offset == 0 && i > 0 && i < indices.length - 1)     ret[i]=1;
 else     ret[i]=indices[i].offset();
  }
  if (ret.length == 1) {
    ret=new int[]{1,ret[0]};
  }
  return ret;
}"
3410,"/** 
 * Prunes indices of greater length than the shape and fills in missing indices if there are any
 * @param originalShape the original shape to adjust to
 * @param indexes       the indexes to adjust
 * @return the  adjusted indices
 */
public static NDArrayIndex[] adjustIndices(int[] originalShape,NDArrayIndex... indexes){
  if (indexes.length < originalShape.length)   indexes=fillIn(originalShape,indexes);
  if (indexes.length > originalShape.length) {
    NDArrayIndex[] ret=new NDArrayIndex[originalShape.length];
    System.arraycopy(indexes,0,ret,0,originalShape.length);
    return ret;
  }
  if (indexes.length == originalShape.length)   return indexes;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i].end() >= originalShape[i] || indexes[i] instanceof NDArrayIndex.NDArrayIndexAll)     indexes[i]=NDArrayIndex.interval(0,originalShape[i] - 1);
  }
  return indexes;
}","/** 
 * Prunes indices of greater length than the shape and fills in missing indices if there are any
 * @param originalShape the original shape to adjust to
 * @param indexes       the indexes to adjust
 * @return the  adjusted indices
 */
public static NDArrayIndex[] adjustIndices(int[] originalShape,NDArrayIndex... indexes){
  if (Shape.isVector(originalShape) && indexes.length == 1)   return indexes;
  if (indexes.length < originalShape.length)   indexes=fillIn(originalShape,indexes);
  if (indexes.length > originalShape.length) {
    NDArrayIndex[] ret=new NDArrayIndex[originalShape.length];
    System.arraycopy(indexes,0,ret,0,originalShape.length);
    return ret;
  }
  if (indexes.length == originalShape.length)   return indexes;
  for (int i=0; i < indexes.length; i++) {
    if (indexes[i].end() >= originalShape[i] || indexes[i] instanceof NDArrayIndex.NDArrayIndexAll)     indexes[i]=NDArrayIndex.interval(0,originalShape[i] - 1);
  }
  return indexes;
}"
3411,"protected INDArray newShape(int[] newShape,char ordering){
  ensureNotCleanedUp();
  if (Arrays.equals(newShape,this.shape()))   return this;
 else   if (Shape.isVector(newShape) && isVector()) {
    if (isRowVector() && Shape.isColumnVectorShape(newShape)) {
      return Nd4j.create(data,newShape,stride,offset);
    }
 else     if (isRowVector() && newShape.length == 1 || isRowVector() && newShape.length == 2) {
      this.shape=newShape;
    }
 else     if (isColumnVector() && Shape.isRowVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{1,stride[0]},offset);
    }
  }
  INDArray newCopy=this;
  int[] newStrides=null;
  if (newStrides == null) {
    newStrides=this instanceof IComplexNDArray ? Nd4j.getComplexStrides(newShape,ordering()) : Nd4j.getStrides(newShape,ordering());
  }
  if (shape().length > 1 || this.ordering != ordering || newShape.length != shape().length) {
    if (this instanceof IComplexNDArray)     return Nd4j.create(data,newShape,newStrides,offset,ordering);
    newCopy=Nd4j.create(data,newShape,newStrides,offset,ordering);
    return newCopy;
  }
  if (this instanceof IComplexNDArray)   return Nd4j.createComplex(newCopy.data(),newShape,newStrides,offset);
  return Nd4j.create(newCopy.data(),newShape,newStrides,offset);
}","protected INDArray newShape(int[] newShape,char ordering){
  ensureNotCleanedUp();
  if (Arrays.equals(newShape,this.shape()))   return this;
 else   if (Shape.isVector(newShape) && isVector()) {
    if (isRowVector() && Shape.isColumnVectorShape(newShape)) {
      return Nd4j.create(data,newShape,stride,offset);
    }
 else     if (isRowVector() && newShape.length == 1 || isRowVector() && newShape.length == 2) {
      this.shape=newShape;
    }
 else     if (isColumnVector() && Shape.isRowVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{stride[0],1},offset);
    }
  }
  INDArray newCopy=this;
  int[] newStrides=null;
  if (newStrides == null) {
    newStrides=this instanceof IComplexNDArray ? Nd4j.getComplexStrides(newShape,ordering()) : Nd4j.getStrides(newShape,ordering());
  }
  if (shape().length > 1 || this.ordering != ordering || newShape.length != shape().length) {
    if (this instanceof IComplexNDArray)     return Nd4j.create(data,newShape,newStrides,offset,ordering);
    newCopy=Nd4j.create(data,newShape,newStrides,offset,ordering);
    return newCopy;
  }
  if (this instanceof IComplexNDArray)   return Nd4j.createComplex(newCopy.data(),newShape,newStrides,offset);
  return Nd4j.create(newCopy.data(),newShape,newStrides,offset);
}"
3412,"/** 
 * Dimshuffle: an extension of permute that adds the ability to broadcast various dimensions. <p/> See theano for more examples. This will only accept integers and xs. <p/> An x indicates a dimension should be broadcasted rather than permuted.
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public IComplexNDArray dimShuffle(Object[] rearrange,int[] newOrder,boolean[] broadCastable){
}","/** 
 * Dimshuffle: an extension of permute that adds the ability to broadcast various dimensions. <p/> See theano for more examples. This will only accept integers and xs. <p/> An x indicates a dimension should be broadcasted rather than permuted.
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public IComplexNDArray dimShuffle(Object[] rearrange,int[] newOrder,boolean[] broadCastable){
  return (IComplexNDArray)super.dimShuffle(rearrange,newOrder,broadCastable);
}"
3413,"/** 
 * Returns the slice of this from the specified dimension
 * @param slice     the dimension to return from
 * @param dimension the dimension of the slice to return
 * @return the slice of this matrix from the specified dimensionand dimension
 */
@Override public IComplexNDArray slice(int slice,int dimension){
  int offset=this.offset + dimension * stride[slice];
  if (slice == 0)   return slice(dimension);
  return Nd4j.createComplex(data,ArrayUtil.removeIndex(shape,dimension),ArrayUtil.removeIndex(stride,dimension),offset,ordering);
}","/** 
 * Returns the slice of this from the specified dimension
 * @param slice     the dimension to return from
 * @param dimension the dimension of the slice to return
 * @return the slice of this matrix from the specified dimensionand dimension
 */
@Override public IComplexNDArray slice(int slice,int dimension){
  return (IComplexNDArray)super.slice(slice,dimension);
}"
3414,"/** 
 * Get the specified column
 * @param c
 */
@Override public IComplexNDArray getColumn(int c){
  if (shape.length == 2) {
    if (ordering == NDArrayFactory.C) {
      IComplexNDArray ret=Nd4j.createComplex(data,new int[]{shape[0]},new int[]{stride[0]},offset + (c * 2),ordering);
      return ret;
    }
 else {
      IComplexNDArray ret=Nd4j.createComplex(data,new int[]{shape[0]},new int[]{stride[0]},offset + (c * 2),ordering);
      return ret;
    }
  }
 else   if (isColumnVector() && c == 0)   return this;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Get the specified column
 * @param c
 */
@Override public IComplexNDArray getColumn(int c){
  return (IComplexNDArray)super.getColumn(c);
}"
3415,"/** 
 * Get a copy of a row.
 * @param r
 */
@Override public IComplexNDArray getRow(int r){
  if (shape.length == 2) {
    if (ordering == NDArrayFactory.C) {
      IComplexNDArray ret=Nd4j.createComplex(data,new int[]{shape[1]},new int[]{stride[1]},offset + (r * 2) * columns(),ordering);
      return ret;
    }
 else {
      IComplexNDArray ret=Nd4j.createComplex(data,new int[]{shape[1]},new int[]{stride[1]},offset + (r * 2),ordering);
      return ret;
    }
  }
 else   if (isRowVector() && r == 0)   return this;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","/** 
 * Get a copy of a row.
 * @param r
 */
@Override public IComplexNDArray getRow(int r){
  return (IComplexNDArray)super.getRow(r);
}"
3416,"/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.html
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public IComplexNDArray permute(int[] rearrange){
  if (rearrange.length < shape.length)   return dup();
  checkArrangeArray(rearrange);
  int[] newDims=doPermuteSwap(shape,rearrange);
  int[] newStrides=doPermuteSwap(stride,rearrange);
  IComplexNDArray ret=Nd4j.createComplex(data,newDims,newStrides,offset,ordering);
  return ret;
}","/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.html
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public IComplexNDArray permute(int[] rearrange){
  return (IComplexNDArray)super.permute(rearrange);
}"
3417,"/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public IComplexNDArray broadcast(int[] shape){
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=this.shape.length - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  if (isScalar()) {
    IComplexNDArray ret=Nd4j.createComplex(Nd4j.valueArrayOf(shape,getDouble(0)));
    return ret;
  }
 else   if (isColumnVector() && Shape.isMatrix(shape)) {
    IComplexNDArray ret=Nd4j.createComplex(shape);
    for (int i=0; i < ret.columns(); i++)     ret.putColumn(i,this.dup());
    return ret;
  }
  int[] retShape=new int[shape.length];
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],1);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],shape()[i]);
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < shape().length)       retShape[i]=Math.max(shape[i],shape()[i]);
 else       retShape[i]=shape[i];
    }
  }
  IComplexNDArray ret=Nd4j.createComplex(retShape);
  IComplexNDArray linear=ret.linearView();
  IComplexNDArray thisLinear=linearView();
  int bufferIdx=0;
  for (int i=0; i < ret.length(); i++) {
    linear.putScalar(i,thisLinear.getComplex(bufferIdx));
    bufferIdx++;
    if (bufferIdx >= length())     bufferIdx=0;
  }
  return ret;
}","/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public IComplexNDArray broadcast(int[] shape){
  return (IComplexNDArray)super.broadcast(shape);
}"
3418,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public IComplexNDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  int[] offsets=Indices.offsets(indexes);
  if (offsets.length != indexes.length)   throw new IllegalStateException(""String_Node_Str"");
  int[] shape=Indices.shape(shape(),indexes);
  if (shape.length < offsets.length) {
    int[] copy=new int[offsets.length];
    Arrays.fill(copy,1);
    int delta=Math.abs(shape.length - copy.length);
    for (int i=copy.length - 1; i > 0; i--) {
      copy[i]=shape[i - delta];
    }
    shape=copy;
  }
  if (!Indices.isContiguous(indexes)) {
    IComplexNDArray ret=Nd4j.createComplex(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      for (int i=0; i < ret.slices(); i++) {
        INDArray putSlice=slice(i).get(Arrays.copyOfRange(indexes,1,indexes.length));
        ret.putSlice(i,putSlice);
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    IComplexNDArray ret=Nd4j.createComplex(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getComplex(get));
        count++;
      }
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  int[] strides=ArrayUtil.copy(stride());
  return subArray(offsets,shape,strides);
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public IComplexNDArray get(NDArrayIndex... indexes){
  return (IComplexNDArray)super.get(indexes);
}"
3419,"/** 
 * Get the vector along a particular dimension
 * @param index     the index of the vector to getScalar
 * @param dimension the dimension to getScalar the vector from
 * @return the vector along a particular dimension
 */
@Override public IComplexNDArray vectorAlongDimension(int index,int dimension){
  int vectorsAlongDimension=vectorsAlongDimension(dimension);
  if (index >= vectorsAlongDimension)   throw new IllegalArgumentException(""String_Node_Str"" + dimension);
  if (isMatrix()) {
    if (dimension == 0) {
      return Nd4j.createComplex(data,new int[]{1,shape[dimension]},new int[]{stride[dimension],1},offset + index * stride[stride.length - 1]);
    }
 else     if (dimension == 1) {
      return Nd4j.createComplex(data,new int[]{1,shape[dimension]},new int[]{stride[dimension],1},offset + index * stride[0]);
    }
  }
  return Nd4j.createComplex(data,new int[]{1,shape[dimension]},stride[dimension] != 1 ? new int[]{stride[dimension],1} : new int[]{1,stride[dimension]},offset + index * stride[0]);
}","/** 
 * Get the vector along a particular dimension
 * @param index     the index of the vector to getScalar
 * @param dimension the dimension to getScalar the vector from
 * @return the vector along a particular dimension
 */
@Override public IComplexNDArray vectorAlongDimension(int index,int dimension){
  return (IComplexNDArray)super.vectorAlongDimension(index,dimension);
}"
3420,"/** 
 * Insert a row in to this array Will throw an exception if this ndarray is not a matrix
 * @param row   the row insert into
 * @param toPut the row to insert
 * @return this
 */
@Override public IComplexNDArray putRow(int row,INDArray toPut){
}","/** 
 * Insert a row in to this array Will throw an exception if this ndarray is not a matrix
 * @param row   the row insert into
 * @param toPut the row to insert
 * @return this
 */
@Override public IComplexNDArray putRow(int row,INDArray toPut){
  return (IComplexNDArray)super.putRow(row,toPut);
}"
3421,"@Override public IComplexNDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return Nd4j.createComplex(shape);
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int offset=(this.offset + ArrayUtil.dotProduct(offsets,this.stride));
  IComplexNDArray ret=Nd4j.createComplex(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
  return ret;
}","@Override public IComplexNDArray subArray(int[] offsets,int[] shape,int[] stride){
  return (IComplexNDArray)super.subArray(offsets,shape,stride);
}"
3422,"/** 
 * Mainly here for people coming from numpy. This is equivalent to a call to permute
 * @param dimension the dimension to swap
 * @param with      the one to swap it with
 * @return the swapped axes view
 */
public IComplexNDArray swapAxes(int dimension,int with){
  if (isVector()) {
    return transpose();
  }
  int[] shape=ArrayUtil.range(0,shape().length);
  shape[dimension]=with;
  shape[with]=dimension;
  return permute(shape);
}","/** 
 * Mainly here for people coming from numpy. This is equivalent to a call to permute
 * @param dimension the dimension to swap
 * @param with      the one to swap it with
 * @return the swapped axes view
 */
public IComplexNDArray swapAxes(int dimension,int with){
  return (IComplexNDArray)super.swapAxes(dimension,with);
}"
3423,"/** 
 * Get whole columns from the passed indices.
 * @param cindices
 */
@Override public IComplexNDArray getColumns(int[] cindices){
  IComplexNDArray rows=Nd4j.createComplex(rows(),cindices.length);
  for (int i=0; i < cindices.length; i++) {
    rows.putColumn(i,getColumn(cindices[i]));
  }
  return rows;
}","/** 
 * Get whole columns from the passed indices.
 * @param cindices
 */
@Override public IComplexNDArray getColumns(int[] cindices){
  return (IComplexNDArray)super.getColumns(cindices);
}"
3424,"/** 
 * Replicate and tile array to fill out to the given shape
 * @param shape the new shape of this ndarray
 * @return the shape to fill out to
 */
@Override public IComplexNDArray repmat(int[] shape){
}","/** 
 * Replicate and tile array to fill out to the given shape
 * @param shape the new shape of this ndarray
 * @return the shape to fill out to
 */
@Override public IComplexNDArray repmat(int[] shape){
  return (IComplexNDArray)super.repmat(shape);
}"
3425,"/** 
 * Returns the slice of this from the specified dimension
 * @param slice     the dimension to return from
 * @param dimension the dimension of the slice to return
 * @return the slice of this matrix from the specified dimensionand dimension
 */
@Override public INDArray slice(int slice,int dimension){
  if (shape.length == 2) {
    if (dimension == 1)     return getRow(slice);
 else     if (dimension == 0)     return getColumn(slice);
 else     throw new IllegalAccessError(""String_Node_Str"");
  }
  if (slice == shape.length - 1)   return slice(dimension);
  INDArray slice2=Nd4j.create(data,ArrayUtil.removeIndex(shape,dimension),ArrayUtil.removeIndex(stride,dimension),offset + slice * stride[dimension],ordering);
  return slice2;
}","/** 
 * Returns the slice of this from the specified dimension
 * @param slice     the dimension to return from
 * @param dimension the dimension of the slice to return
 * @return the slice of this matrix from the specified dimensionand dimension
 */
@Override public INDArray slice(int slice,int dimension){
  if (shape.length == 2) {
    if (dimension == 1)     return getRow(slice);
 else     if (dimension == 0)     return getColumn(slice);
 else     throw new IllegalAccessError(""String_Node_Str"");
  }
  if (slice == shape.length - 1)   return slice(dimension);
  INDArray slice2=create(data,ArrayUtil.removeIndex(shape,dimension),ArrayUtil.removeIndex(stride,dimension),offset + slice * stride[dimension],ordering);
  return slice2;
}"
3426,"@Override public IComplexNDArray muli(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return Nd4j.createComplex(this).muli(n,result);
}","@Override public IComplexNDArray muli(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return create(this).muli(n,result);
}"
3427,"@Override public IComplexNDArray rdivi(IComplexNumber n,IComplexNDArray result){
  return Nd4j.createComplex(this).rdivi(n,result);
}","@Override public IComplexNDArray rdivi(IComplexNumber n,IComplexNDArray result){
  return create(this).rdivi(n,result);
}"
3428,"@Override public IComplexNDArray subi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return Nd4j.createComplex(this).subi(n,result);
}","@Override public IComplexNDArray subi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return create(this).subi(n,result);
}"
3429,"protected void init(int[] shape){
  ensureNotCleanedUp();
  this.shape=shape;
  if (this.shape.length == 1) {
    rows=1;
    columns=this.shape[0];
  }
 else   if (this.shape().length == 2) {
    rows=shape[0];
    columns=shape[1];
  }
  if (this.shape.length == 1) {
    init(new int[]{1,this.shape[0]});
  }
  if (this.ordering == '\u0000')   this.ordering=Nd4j.order();
  this.length=ArrayUtil.prod(this.shape);
  if (this.stride == null) {
    this.stride=Nd4j.getStrides(shape,ordering);
  }
  if (this.stride.length != this.shape.length) {
    if (ordering == NDArrayFactory.FORTRAN)     this.stride=ArrayUtil.calcStridesFortran(this.shape);
 else     this.stride=ArrayUtil.calcStrides(this.shape);
  }
}","protected void init(int[] shape){
  ensureNotCleanedUp();
  this.shape=shape;
  if (this.shape.length == 1) {
    rows=1;
    columns=this.shape[0];
  }
 else   if (this.shape().length == 2) {
    rows=shape[0];
    columns=shape[1];
  }
  if (this.shape.length == 1) {
    init(new int[]{1,this.shape[0]});
  }
  if (this.ordering == '\u0000')   this.ordering=Nd4j.order();
  this.length=ArrayUtil.prod(this.shape);
  if (this.stride == null) {
    this.stride=Nd4j.getStrides(shape,ordering);
  }
  if (this.stride.length != this.shape.length) {
    this.stride=getStrides(shape,ordering());
  }
}"
3430,"/** 
 * Perform an copy matrix multiplication
 * @param other  the other matrix to perform matrix multiply with
 * @param result the result ndarray
 * @return the result of the matrix multiplication
 */
@Override public INDArray mmuli(INDArray other,INDArray result){
  ensureNotCleanedUp();
  INDArray otherArray=other;
  INDArray resultArray=result;
  if (other.shape().length > 2) {
    for (int i=0; i < other.slices(); i++) {
      result.putSlice(i,slice(i).mmul(other.slice(i)));
    }
    return result;
  }
  LinAlgExceptions.assertMultiplies(this,other);
  if (other.isScalar()) {
    return muli(otherArray.getDouble(0),resultArray);
  }
  if (isScalar()) {
    return otherArray.muli(getDouble(0),resultArray);
  }
  if (result == this || result == other) {
    INDArray temp=Nd4j.create(resultArray.shape(),ArrayUtil.calcStridesFortran(resultArray.shape()));
    if (otherArray.columns() == 1) {
      if (data.dataType() == (DataBuffer.Type.DOUBLE))       Nd4j.getBlasWrapper().gemv(1.0,this,otherArray,0.0,temp);
 else       Nd4j.getBlasWrapper().gemv(1.0f,this,otherArray,0.0f,temp);
    }
 else {
      if (data.dataType() == (DataBuffer.Type.DOUBLE))       Nd4j.getBlasWrapper().gemm(1.0,this,otherArray,0.0,temp);
 else       Nd4j.getBlasWrapper().gemm(1.0f,this,otherArray,0.0f,temp);
    }
    Nd4j.getBlasWrapper().copy(temp,resultArray);
  }
 else {
    if (otherArray.columns() == 1)     if (data.dataType() == (DataBuffer.Type.DOUBLE))     Nd4j.getBlasWrapper().gemv(1.0,this,otherArray,0.0,resultArray);
 else     Nd4j.getBlasWrapper().gemv(1.0f,this,otherArray,0.0f,resultArray);
 else {
      if (data.dataType() == (DataBuffer.Type.DOUBLE))       Nd4j.getBlasWrapper().gemm(1.0,this,otherArray,0.0,resultArray);
 else       Nd4j.getBlasWrapper().gemm(1.0f,this,otherArray,0.0f,resultArray);
    }
  }
  if (Nd4j.ENFORCE_NUMERICAL_STABILITY)   Nd4j.clearNans(resultArray);
  return resultArray;
}","/** 
 * Perform an copy matrix multiplication
 * @param other  the other matrix to perform matrix multiply with
 * @param result the result ndarray
 * @return the result of the matrix multiplication
 */
@Override public INDArray mmuli(INDArray other,INDArray result){
  ensureNotCleanedUp();
  INDArray otherArray=other;
  INDArray resultArray=result;
  if (other.shape().length > 2) {
    for (int i=0; i < other.slices(); i++) {
      result.putSlice(i,slice(i).mmul(other.slice(i)));
    }
    return result;
  }
  LinAlgExceptions.assertMultiplies(this,other);
  if (other.isScalar()) {
    return muli(otherArray.getDouble(0),resultArray);
  }
  if (isScalar()) {
    return otherArray.muli(getDouble(0),resultArray);
  }
  if (result == this || result == other) {
    INDArray temp=create(resultArray.shape(),getStrides(shape,NDArrayFactory.FORTRAN));
    if (otherArray.columns() == 1) {
      if (data.dataType() == (DataBuffer.Type.DOUBLE))       Nd4j.getBlasWrapper().gemv(1.0,this,otherArray,0.0,temp);
 else       Nd4j.getBlasWrapper().gemv(1.0f,this,otherArray,0.0f,temp);
    }
 else {
      if (data.dataType() == (DataBuffer.Type.DOUBLE))       Nd4j.getBlasWrapper().gemm(1.0,this,otherArray,0.0,temp);
 else       Nd4j.getBlasWrapper().gemm(1.0f,this,otherArray,0.0f,temp);
    }
    Nd4j.getBlasWrapper().copy(temp,resultArray);
  }
 else {
    if (otherArray.columns() == 1)     if (data.dataType() == (DataBuffer.Type.DOUBLE))     Nd4j.getBlasWrapper().gemv(1.0,this,otherArray,0.0,resultArray);
 else     Nd4j.getBlasWrapper().gemv(1.0f,this,otherArray,0.0f,resultArray);
 else {
      if (data.dataType() == (DataBuffer.Type.DOUBLE))       Nd4j.getBlasWrapper().gemm(1.0,this,otherArray,0.0,resultArray);
 else       Nd4j.getBlasWrapper().gemm(1.0f,this,otherArray,0.0f,resultArray);
    }
  }
  if (Nd4j.ENFORCE_NUMERICAL_STABILITY)   Nd4j.clearNans(resultArray);
  return resultArray;
}"
3431,"/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.htsliceml
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray permute(int[] rearrange){
  ensureNotCleanedUp();
  if (rearrange.length != shape.length)   return dup();
  checkArrangeArray(rearrange);
  int[] newShape=doPermuteSwap(shape,rearrange);
  if (isVector() || isMatrix()) {
    if (Arrays.equals(rearrange,ArrayUtil.reverseCopy(ArrayUtil.range(0,2))))     return transpose();
    return this;
  }
  int[] newStride=doPermuteSwap(stride,rearrange);
  INDArray value=Nd4j.create(data(),newShape,newStride,offset,ordering);
  return value;
}","/** 
 * See: http://www.mathworks.com/help/matlab/ref/permute.htsliceml
 * @param rearrange the dimensions to swap to
 * @return the newly permuted array
 */
@Override public INDArray permute(int[] rearrange){
  ensureNotCleanedUp();
  if (rearrange.length != shape.length)   return dup();
  checkArrangeArray(rearrange);
  int[] newShape=doPermuteSwap(shape,rearrange);
  if (isVector() || isMatrix()) {
    if (Arrays.equals(rearrange,ArrayUtil.reverseCopy(ArrayUtil.range(0,2))))     return transpose();
    return this;
  }
  int[] newStride=doPermuteSwap(stride,rearrange);
  INDArray value=create(data(),newShape,newStride,offset,ordering);
  return value;
}"
3432,"/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public INDArray broadcast(int[] shape){
  ensureNotCleanedUp();
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=this.shape.length - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  if (isScalar()) {
    INDArray ret=Nd4j.valueArrayOf(shape,getDouble(0));
    return ret;
  }
 else   if (isColumnVector() && Shape.isMatrix(shape)) {
    INDArray ret=Nd4j.create(shape);
    for (int i=0; i < ret.columns(); i++)     ret.putColumn(i,this.dup());
    return ret;
  }
 else   if (isRowVector()) {
    INDArray ret=Nd4j.create(shape);
    for (int i=0; i < ret.rows(); i++)     ret.putRow(i,this.dup());
    return ret;
  }
  int[] retShape=new int[shape.length];
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(1,shape[i]);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],shape()[i]);
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < shape().length)       retShape[i]=Math.max(shape[i],shape()[i]);
 else       retShape[i]=shape[i];
    }
  }
  INDArray ret=Nd4j.create(retShape);
  INDArray linear=ret.linearView();
  INDArray thisLinear=linearView();
  int bufferIdx=0;
  for (int i=0; i < ret.length(); i++) {
    linear.putScalar(i,thisLinear.getDouble(bufferIdx));
    bufferIdx++;
    if (bufferIdx >= length())     bufferIdx=0;
  }
  return ret;
}","/** 
 * Broadcasts this ndarray to be the specified shape
 * @param shape the new shape of this ndarray
 * @return the broadcasted ndarray
 */
@Override public INDArray broadcast(int[] shape){
  ensureNotCleanedUp();
  if (Shape.shapeEquals(shape,shape()))   return this;
  boolean compatible=true;
  int count=shape.length - 1;
  int thisCount=this.shape.length - 1;
  for (int i=shape.length - 1; i > 0; i--) {
    if (count < 0 || thisCount < 0)     break;
    if (shape[count] != shape()[thisCount] && shape[count] != 1 && shape()[thisCount] != 1) {
      compatible=false;
      break;
    }
    count--;
    thisCount--;
  }
  if (!compatible)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape()) + ""String_Node_Str""+ Arrays.toString(shape));
  if (isScalar()) {
    INDArray ret=Nd4j.valueArrayOf(shape,getDouble(0));
    return ret;
  }
 else   if (isColumnVector() && Shape.isMatrix(shape)) {
    INDArray ret=create(shape);
    for (int i=0; i < ret.columns(); i++)     ret.putColumn(i,this.dup());
    return ret;
  }
 else   if (isRowVector()) {
    INDArray ret=create(shape);
    for (int i=0; i < ret.rows(); i++)     ret.putRow(i,this.dup());
    return ret;
  }
  int[] retShape=new int[shape.length];
  for (int i=0; i < retShape.length; i++) {
    if (shape().length == 1) {
      if (i == 0) {
        if (i < shape().length)         retShape[i]=Math.max(1,shape[i]);
 else         retShape[i]=shape[i];
      }
 else {
        if (i < shape().length)         retShape[i]=Math.max(shape[i],shape()[i]);
 else         retShape[i]=shape[i];
      }
    }
 else {
      if (i < shape().length)       retShape[i]=Math.max(shape[i],shape()[i]);
 else       retShape[i]=shape[i];
    }
  }
  INDArray ret=create(retShape);
  INDArray linear=ret.linearView();
  INDArray thisLinear=linearView();
  int bufferIdx=0;
  for (int i=0; i < ret.length(); i++) {
    linear.putScalar(i,thisLinear.getDouble(bufferIdx));
    bufferIdx++;
    if (bufferIdx >= length())     bufferIdx=0;
  }
  return ret;
}"
3433,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=Nd4j.create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    INDArray ret=Nd4j.create(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getDouble(get));
        count++;
      }
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  return subArray(offsets,shape,ArrayUtil.copy(stride()));
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length()) {
    INDArray ret=create(shape);
    NDArrayIndex slices=indexes[0];
    int[] indices=slices.indices();
    if (indexes.length == 1) {
      NDArrayIndex subRange=indexes[0];
      int count=0;
      for (int i=0; i < indices.length; i++) {
        if (count >= ret.length())         count=0;
        int get=subRange.indices()[count];
        ret.putScalar(count,getDouble(get));
        count++;
      }
    }
 else {
      NDArrayIndex[] subRange=Arrays.copyOfRange(indexes,1,indexes.length);
      NDArrayIndex[] putRange=NDArrayIndex.rangeOfLength(subRange);
      for (int i=0; i < indices.length; i++) {
        INDArray sliceI=ret.slice(i);
        INDArray thisSlice=slice(indices[i]);
        sliceI.put(putRange,thisSlice.get(subRange));
      }
    }
    return ret;
  }
  return subArray(offsets,shape,ArrayUtil.copy(stride()));
}"
3434,"/** 
 * Get the vector along a particular dimension
 * @param index     the index of the vector to getScalar
 * @param dimension the dimension to getScalar the vector from
 * @return the vector along a particular dimension
 */
@Override public INDArray vectorAlongDimension(int index,int dimension){
  int vectorsAlongDimension=vectorsAlongDimension(dimension);
  if (index >= vectorsAlongDimension)   throw new IllegalArgumentException(""String_Node_Str"" + dimension);
  if (ordering() == NDArrayFactory.FORTRAN) {
    if (index >= vectorsAlongDimension)     throw new IllegalArgumentException(""String_Node_Str"" + dimension);
    if (isMatrix()) {
      if (dimension == 0) {
        return Nd4j.create(data,new int[]{shape[dimension],1},new int[]{stride[dimension],1},offset + index * stride[stride.length - 1]);
      }
 else       if (dimension == 1) {
        return Nd4j.create(data,new int[]{1,shape[dimension]},new int[]{stride[dimension],1},calcoffset(index));
      }
    }
    return Nd4j.create(data,new int[]{1,shape[dimension]},stride[dimension] != 1 ? new int[]{stride[dimension],1} : new int[]{1,stride[dimension]},calcoffset(index));
  }
  if (isMatrix()) {
    if (dimension == 0) {
      if (ordering() == NDArrayFactory.C)       return Nd4j.create(data,new int[]{shape[dimension],1},new int[]{stride[dimension],1},offset + index * stride[stride.length - 1]);
 else       return Nd4j.create(data,new int[]{shape[dimension],1},new int[]{stride[dimension],1},calcoffset(index));
    }
 else     if (dimension == 1) {
      if (ordering() == NDArrayFactory.C)       return Nd4j.create(data,new int[]{1,shape[dimension]},ArrayUtil.of(1,stride[dimension]),calcoffset(index));
      return Nd4j.create(data,new int[]{1,shape[dimension]},new int[]{stride[dimension],1},calcoffset(index));
    }
  }
  int arrOffset=offset + index * stride[0];
  if (arrOffset >= length()) {
    int numDecremented=0;
    int startIndex=index;
    while (startIndex >= slices()) {
      numDecremented++;
      startIndex-=slices();
    }
    arrOffset=offset + ((startIndex * stride[0]) + (numDecremented * stride[1]));
  }
  return Nd4j.create(data,new int[]{1,shape[dimension]},new int[]{1,stride[dimension]},arrOffset);
}","/** 
 * Get the vector along a particular dimension
 * @param index     the index of the vector to getScalar
 * @param dimension the dimension to getScalar the vector from
 * @return the vector along a particular dimension
 */
@Override public INDArray vectorAlongDimension(int index,int dimension){
  int vectorsAlongDimension=vectorsAlongDimension(dimension);
  if (index >= vectorsAlongDimension)   throw new IllegalArgumentException(""String_Node_Str"" + dimension);
  if (ordering() == NDArrayFactory.FORTRAN) {
    if (index >= vectorsAlongDimension)     throw new IllegalArgumentException(""String_Node_Str"" + dimension);
    if (isMatrix()) {
      if (dimension == 0) {
        return create(data,new int[]{shape[dimension],1},new int[]{stride[dimension],1},offset + index * stride[stride.length - 1]);
      }
 else       if (dimension == 1) {
        return create(data,new int[]{1,shape[dimension]},new int[]{stride[dimension],1},calcoffset(index));
      }
    }
    return create(data,new int[]{1,shape[dimension]},stride[dimension] != 1 ? new int[]{stride[dimension],1} : new int[]{1,stride[dimension]},calcoffset(index));
  }
  if (isMatrix()) {
    if (dimension == 0) {
      if (ordering() == NDArrayFactory.C)       return create(data,new int[]{shape[dimension],1},new int[]{stride[dimension],1},offset + index * stride[stride.length - 1]);
 else       return create(data,new int[]{shape[dimension],1},new int[]{stride[dimension],1},calcoffset(index));
    }
 else     if (dimension == 1) {
      if (ordering() == NDArrayFactory.C)       return create(data,new int[]{1,shape[dimension]},ArrayUtil.of(1,stride[dimension]),calcoffset(index));
      return create(data,new int[]{1,shape[dimension]},new int[]{stride[dimension],1},calcoffset(index));
    }
  }
  int arrOffset=offset + index * stride[0];
  if (arrOffset >= length()) {
    int numDecremented=0;
    int startIndex=index;
    while (startIndex >= slices()) {
      numDecremented++;
      startIndex-=slices();
    }
    arrOffset=offset + ((startIndex * stride[0]) + (numDecremented * stride[1]));
  }
  return create(data,new int[]{1,shape[dimension]},new int[]{1,stride[dimension]},arrOffset);
}"
3435,"@Override public INDArray linearViewColumnOrder(){
  ensureNotCleanedUp();
  return Nd4j.create(data,new int[]{length,1},offset());
}","@Override public INDArray linearViewColumnOrder(){
  ensureNotCleanedUp();
  return create(data,new int[]{length,1},offset());
}"
3436,"/** 
 * Flattens the array for linear indexing
 * @return the flattened version of this array
 */
@Override public INDArray ravel(){
  ensureNotCleanedUp();
  INDArray ret=Nd4j.create(length,ordering);
  int dimension=shape.length == 2 ? 1 : shape.length - 1;
  int count=0;
  for (int i=0; i < vectorsAlongDimension(dimension); i++) {
    INDArray vec=vectorAlongDimension(i,dimension);
    for (int j=0; j < vec.length(); j++) {
      ret.putScalar(count++,vec.getDouble(j));
    }
  }
  return ret;
}","/** 
 * Flattens the array for linear indexing
 * @return the flattened version of this array
 */
@Override public INDArray ravel(){
  ensureNotCleanedUp();
  INDArray ret=create(new int[]{1,length},ordering);
  int dimension=shape.length == 2 ? 1 : shape.length - 1;
  int count=0;
  for (int i=0; i < vectorsAlongDimension(dimension); i++) {
    INDArray vec=vectorAlongDimension(i,dimension);
    for (int j=0; j < vec.length(); j++) {
      ret.putScalar(count++,vec.getDouble(j));
    }
  }
  return ret;
}"
3437,"protected INDArray newShape(int[] newShape,char ordering){
  ensureNotCleanedUp();
  if (Arrays.equals(newShape,this.shape()))   return this;
 else   if (Shape.isVector(newShape) && isVector()) {
    if (isRowVector() && Shape.isColumnVectorShape(newShape)) {
      return Nd4j.create(data,newShape,stride,offset);
    }
 else     if (isRowVector() && newShape.length == 1 || isRowVector() && newShape.length == 2) {
      this.shape=newShape;
    }
 else     if (isColumnVector() && Shape.isRowVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{stride[0],1},offset);
    }
  }
  INDArray newCopy=this;
  int[] newStrides=null;
  if (newStrides == null) {
    newStrides=this instanceof IComplexNDArray ? Nd4j.getComplexStrides(newShape,ordering()) : Nd4j.getStrides(newShape,ordering());
  }
  if (shape().length > 1 || this.ordering != ordering || newShape.length != shape().length) {
    if (this instanceof IComplexNDArray)     return Nd4j.create(data,newShape,newStrides,offset,ordering);
    newCopy=Nd4j.create(data,newShape,newStrides,offset,ordering);
    return newCopy;
  }
  if (this instanceof IComplexNDArray)   return Nd4j.createComplex(newCopy.data(),newShape,newStrides,offset);
  return Nd4j.create(newCopy.data(),newShape,newStrides,offset);
}","protected INDArray newShape(int[] newShape,char ordering){
  ensureNotCleanedUp();
  if (Arrays.equals(newShape,this.shape()))   return this;
 else   if (Shape.isVector(newShape) && isVector()) {
    if (isRowVector() && Shape.isColumnVectorShape(newShape)) {
      return create(data,newShape,stride,offset);
    }
 else     if (isRowVector() && newShape.length == 1 || isRowVector() && newShape.length == 2) {
      this.shape=newShape;
    }
 else     if (isColumnVector() && Shape.isRowVectorShape(newShape)) {
      return create(data,newShape,new int[]{stride[0],1},offset);
    }
  }
  INDArray newCopy=this;
  int[] newStrides=null;
  if (newStrides == null) {
    newStrides=this instanceof IComplexNDArray ? Nd4j.getComplexStrides(newShape,ordering()) : Nd4j.getStrides(newShape,ordering());
  }
  if (shape().length > 1 || this.ordering != ordering || newShape.length != shape().length) {
    if (this instanceof IComplexNDArray)     return create(data,newShape,newStrides,offset,ordering);
    newCopy=create(data,newShape,newStrides,offset,ordering);
    return newCopy;
  }
  return create(newCopy.data(),newShape,newStrides,offset);
}"
3438,"@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return Nd4j.create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int offset=this.offset + ArrayUtil.dotProduct(offsets,this.stride);
  if (ordering() == NDArrayFactory.C && shape[0] == 1)   return Nd4j.create(data,Arrays.copyOf(shape,shape.length),ArrayUtil.reverseCopy(stride),offset,ordering);
  return Nd4j.create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
}","@Override public INDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return create(Nd4j.createBuffer(shape));
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int offset=this.offset + ArrayUtil.dotProduct(offsets,this.stride);
  if (ordering() == NDArrayFactory.C && shape[0] == 1)   return create(data,Arrays.copyOf(shape,shape.length),ArrayUtil.reverseCopy(stride),offset,ordering);
  return create(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
}"
3439,"@Override public IComplexNDArray addi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return Nd4j.createComplex(this).addi(n,result);
}","@Override public IComplexNDArray addi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return create(this).addi(n,result);
}"
3440,"/** 
 * Return transposed version of this matrix.
 */
@Override public INDArray transposei(){
  if (isRowVector())   return Nd4j.create(data,shape.length == 1 ? new int[]{shape[0],1} : ArrayUtil.reverseCopy(shape()),offset);
 else   if (isColumnVector())   return Nd4j.create(data,new int[]{1,shape[0]},offset);
  if (isMatrix()) {
    if (this instanceof IComplexNDArray) {
      IComplexNDArray arr=Nd4j.createComplex(columns(),rows());
      IComplexNDArray arrThis=(IComplexNDArray)this;
      for (int i=0; i < arr.rows(); i++) {
        for (int j=0; j < arr.columns(); j++)         arr.put(i,j,arrThis.getComplex(j,i));
      }
      return arr;
    }
 else {
      INDArray arr=Nd4j.create(columns(),rows());
      for (int i=0; i < arr.rows(); i++) {
        for (int j=0; j < arr.columns(); j++)         arr.put(i,j,getDouble(j,i));
      }
      return arr;
    }
  }
  INDArray arr=Nd4j.create(ArrayUtil.reverseCopy(shape()));
  for (int i=0; i < arr.slices(); i++) {
    arr.putSlice(i,arr.slice(i).transpose());
  }
  return arr;
}","/** 
 * Return transposed version of this matrix.
 */
@Override public INDArray transposei(){
  if (isRowVector())   return create(data,shape.length == 1 ? new int[]{shape[0],1} : ArrayUtil.reverseCopy(shape()),offset);
 else   if (isColumnVector())   return create(data,new int[]{1,shape[0]},offset);
  if (isMatrix()) {
    if (this instanceof IComplexNDArray) {
      INDArray arr=create(new int[]{columns(),rows()});
      INDArray arrThis=this;
      for (int i=0; i < arr.rows(); i++) {
        for (int j=0; j < arr.columns(); j++)         arr.put(i,j,arrThis.getDouble(j,i));
      }
      return arr;
    }
 else {
      INDArray arr=create(columns(),rows());
      for (int i=0; i < arr.rows(); i++) {
        for (int j=0; j < arr.columns(); j++)         arr.put(i,j,getDouble(j,i));
      }
      return arr;
    }
  }
  INDArray arr=create(ArrayUtil.reverseCopy(shape()));
  for (int i=0; i < arr.slices(); i++) {
    arr.putSlice(i,arr.slice(i).transpose());
  }
  return arr;
}"
3441,"/** 
 * Get whole rows from the passed indices.
 * @param rindices
 */
@Override public INDArray getRows(int[] rindices){
  ensureNotCleanedUp();
  INDArray rows=Nd4j.create(rindices.length,columns());
  for (int i=0; i < rindices.length; i++) {
    rows.putRow(i,getRow(rindices[i]));
  }
  return rows;
}","/** 
 * Get whole rows from the passed indices.
 * @param rindices
 */
@Override public INDArray getRows(int[] rindices){
  ensureNotCleanedUp();
  INDArray rows=create(new int[]{rindices.length,columns()});
  for (int i=0; i < rindices.length; i++) {
    rows.putRow(i,getRow(rindices[i]));
  }
  return rows;
}"
3442,"/** 
 * Get whole columns from the passed indices.
 * @param cindices
 */
@Override public INDArray getColumns(int[] cindices){
  ensureNotCleanedUp();
  INDArray rows=Nd4j.create(rows(),cindices.length);
  for (int i=0; i < cindices.length; i++) {
    rows.putColumn(i,getColumn(cindices[i]));
  }
  return rows;
}","/** 
 * Get whole columns from the passed indices.
 * @param cindices
 */
@Override public INDArray getColumns(int[] cindices){
  ensureNotCleanedUp();
  INDArray rows=create(rows(),cindices.length);
  for (int i=0; i < cindices.length; i++) {
    rows.putColumn(i,getColumn(cindices[i]));
  }
  return rows;
}"
3443,"@Override public IComplexNDArray divi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return Nd4j.createComplex(this).divi(n,result);
}","@Override public IComplexNDArray divi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return create(this).divi(n,result);
}"
3444,"@Override public IComplexNDArray rsubi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return Nd4j.createComplex(this).rsubi(n,result);
}","@Override public IComplexNDArray rsubi(IComplexNumber n,IComplexNDArray result){
  ensureNotCleanedUp();
  return create(this).rsubi(n,result);
}"
3445,"@Override public INDArray dup(){
  ensureNotCleanedUp();
  INDArray ret=Nd4j.create(data.dup(),shape(),stride(),offset());
  return ret;
}","@Override public INDArray dup(){
  ensureNotCleanedUp();
  INDArray ret=create(data.dup(),shape(),stride(),offset());
  return ret;
}"
3446,"INDArray create(double[] data,int[] ints,int[] ints1,char order,int offset);","INDArray create(int[] shape,int[] stride,int offset,char ordering);"
3447,"IComplexNDArray createComplex(int[] ints,int[] ints1,int[] stride,int offset);","IComplexNDArray createComplex(int[] shape,int[] complexStrides,int offset,char ordering);"
3448,"public static INDArray create(DataBuffer buffer){
  INDArray ret=INSTANCE.create(buffer);
  logCreationIfNecessary(ret);
  return ret;
}","/** 
 * @param buffer
 * @return
 */
public static INDArray create(DataBuffer buffer){
  INDArray ret=INSTANCE.create(buffer);
  logCreationIfNecessary(ret);
  return ret;
}"
3449,"/** 
 * Returns the length of the indices
 * @return the length of the range
 */
public int length(){
  if (indices.length < 1)   return 0;
  return indices[indices.length - 1] - indices[0];
}","/** 
 * Returns the length of the indices
 * @return the length of the range
 */
public int length(){
  return indices.length;
}"
3450,"@Test public void testInterval(){
  int[] interval=NDArrayIndex.interval(0,2).indices();
  assertTrue(Arrays.equals(interval,new int[]{0,1}));
  int[] interval2=NDArrayIndex.interval(1,3).indices();
  assertEquals(2,interval2.length);
  int[] nextInterval=NDArrayIndex.interval(0,5).indices();
  assertEquals(5,nextInterval.length);
  nextInterval=NDArrayIndex.interval(0,5,true).indices();
  assertEquals(6,nextInterval.length);
}","@Test public void testInterval(){
  int[] interval=NDArrayIndex.interval(0,2).indices();
  assertTrue(Arrays.equals(interval,new int[]{0,1}));
  int[] interval2=NDArrayIndex.interval(1,3).indices();
  assertEquals(2,interval2.length);
  int[] nextInterval=NDArrayIndex.interval(0,5).indices();
  assertEquals(5,nextInterval.length);
  nextInterval=NDArrayIndex.interval(0,5,true).indices();
  assertEquals(6,nextInterval.length);
  assertEquals(nextInterval.length,NDArrayIndex.interval(0,5,true).length());
}"
3451,"@Test public void testRMseXent(){
  INDArray in=Nd4j.create(new double[][]{{1,2},{3,4}});
  INDArray out=Nd4j.create(new double[][]{{5,6},{7,8}});
  double diff=LossFunctions.score(in,LossFunctions.LossFunction.RMSE_XENT,out,0,false);
  assertEquals(4,diff,1e-1);
}","@Test public void testRMseXent(){
  INDArray in=Nd4j.create(new double[][]{{1,2},{3,4}});
  INDArray out=Nd4j.create(new double[][]{{5,6},{7,8}});
  double diff=LossFunctions.score(in,LossFunctions.LossFunction.RMSE_XENT,out,0,false);
  assertEquals(8,diff,1e-1);
}"
3452,"/** 
 * Generic scoring function
 * @param labels            the labels to score
 * @param lossFunction      the loss function to use
 * @param z                 the output function
 * @param l2                the l2 coefficient
 * @param useRegularization whether to use regularization
 * @return the score for the given parameters
 */
public static double score(INDArray labels,LossFunction lossFunction,INDArray z,double l2,boolean useRegularization){
  double ret=0.0;
  double reg=0.5 * l2;
  if (!Arrays.equals(labels.shape(),z.shape()))   throw new IllegalArgumentException(""String_Node_Str"");
switch (lossFunction) {
case RECONSTRUCTION_CROSSENTROPY:
    INDArray xEntLogZ2=log(z);
  INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=log(z).rsubi(1);
ret=labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).muli(xEntOneMinusLogOneMinusZ2).sum(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case MCXENT:
INDArray columnSums=labels.mul(log(z));
ret=columnSums.mean(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsubi(1);
ret=labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).muli(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case RMSE_XENT:
INDArray rmseXentDiff=labels.sub(z);
INDArray squaredrmseXentDiff=pow(rmseXentDiff,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
ret=sqrt.sum(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5 * pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case SQUARED_LOSS:
ret=pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case NEGATIVELOGLIKELIHOOD:
ret=-Nd4j.mean(Nd4j.sum(labels.mul(log(z)).addi(labels.rsub(1).muli(log(z.rsub(1)))),1)).getDouble(0);
break;
}
if (useRegularization) ret+=reg;
ret/=(double)labels.rows();
return ret;
}","/** 
 * Generic scoring function
 * @param labels            the labels to score
 * @param lossFunction      the loss function to use
 * @param z                 the output function
 * @param l2                the l2 coefficient
 * @param useRegularization whether to use regularization
 * @return the score for the given parameters
 */
public static double score(INDArray labels,LossFunction lossFunction,INDArray z,double l2,boolean useRegularization){
  double ret=0.0;
  double reg=0.5 * l2;
  if (!Arrays.equals(labels.shape(),z.shape()))   throw new IllegalArgumentException(""String_Node_Str"");
switch (lossFunction) {
case RECONSTRUCTION_CROSSENTROPY:
    INDArray xEntLogZ2=log(z);
  INDArray xEntOneMinusLabelsOut2=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ2=log(z).rsubi(1);
ret=labels.mul(xEntLogZ2).add(xEntOneMinusLabelsOut2).muli(xEntOneMinusLogOneMinusZ2).sum(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case MCXENT:
INDArray columnSums=labels.mul(log(z));
ret=columnSums.mean(1).mean(Integer.MAX_VALUE).getDouble(0);
break;
case XENT:
INDArray xEntLogZ=log(z);
INDArray xEntOneMinusLabelsOut=labels.rsub(1);
INDArray xEntOneMinusLogOneMinusZ=log(z).rsubi(1);
ret=labels.mul(xEntLogZ).add(xEntOneMinusLabelsOut).muli(xEntOneMinusLogOneMinusZ).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case RMSE_XENT:
INDArray rmseXentDiff=labels.sub(z);
INDArray squaredrmseXentDiff=pow(rmseXentDiff,2.0);
INDArray sqrt=sqrt(squaredrmseXentDiff);
ret=sqrt.sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case MSE:
INDArray mseDelta=labels.sub(z);
ret=0.5 * pow(mseDelta,2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case EXPLL:
INDArray expLLLogZ=log(z);
ret=z.sub(labels.mul(expLLLogZ)).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case SQUARED_LOSS:
ret=pow(labels.sub(z),2).sum(1).sum(Integer.MAX_VALUE).getDouble(0);
break;
case NEGATIVELOGLIKELIHOOD:
ret=-Nd4j.mean(Nd4j.sum(labels.mul(log(z)).addi(labels.rsub(1).muli(log(z.rsub(1)))),1)).getDouble(0);
break;
}
if (useRegularization) ret+=reg;
ret/=(double)labels.rows();
return ret;
}"
3453,"/** 
 * Upsampling a signal (specifically the first 2 dimensions)
 * @param d the data to upsample
 * @param scale the amount to scale by
 * @return the upsampled ndarray
 */
public static INDArray upSample(INDArray d,INDArray scale){
  List<INDArray> idx=new ArrayList<>();
  for (int i=0; i < d.shape().length; i++) {
    INDArray tmp=Nd4j.zeros(d.size(i) * (int)scale.getDouble(i),1);
    int[] indices=ArrayUtil.range(0,(int)scale.getDouble(i) * d.size(i),(int)scale.getDouble(i));
    NDArrayIndex index=new NDArrayIndex(indices);
    tmp.put(new NDArrayIndex[]{index},1);
    INDArray put=tmp.cumsum(0);
    idx.add(put.sub(1));
  }
  INDArray ret=Nd4j.create(ArrayUtil.toInts(ArrayUtil.toNDArray(d.shape()).muli(scale)));
  INDArray retLinear=ret.linearView();
  for (int i=0; i < retLinear.length(); i++) {
    for (int j=0; j < idx.get(0).length(); j++) {
      int slice=idx.get(0).getInt(j);
      for (int k=1; k < idx.size(); k++) {
      }
    }
  }
  return ret;
}","/** 
 * Upsampling a signal (specifically the first 2 dimensions)
 * @param d the data to upsample
 * @param scale the amount to scale by
 * @return the upsampled ndarray
 */
public static INDArray upSample(INDArray d,INDArray scale){
  List<INDArray> idx=new ArrayList<>();
  for (int i=0; i < d.shape().length; i++) {
    INDArray tmp=Nd4j.zeros(d.size(i) * (int)scale.getDouble(i),1);
    int[] indices=ArrayUtil.range(0,(int)scale.getDouble(i) * d.size(i),(int)scale.getDouble(i));
    NDArrayIndex index=new NDArrayIndex(indices);
    tmp.put(new NDArrayIndex[]{index},1);
    INDArray put=tmp.cumsum(0);
    idx.add(put.sub(1));
  }
  NDArrayIndex[] ret=new NDArrayIndex[idx.size()];
  for (int i=0; i < ret.length; i++)   ret[i]=NDArrayIndex.create(idx.get(i))[0];
  return d.get(ret);
}"
3454,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public IComplexNDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    IComplexNDArray ret=Nd4j.createComplex(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      for (int i=0; i < ret.slices(); i++) {
        INDArray putSlice=slice(i).get(Arrays.copyOfRange(indexes,1,indexes.length));
        ret.putSlice(i,putSlice);
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) >= length())   return this;
  int[] strides;
  strides=ArrayUtil.copy(stride());
  if (offsets.length != shape.length)   offsets=Arrays.copyOfRange(offsets,0,shape.length);
  if (strides.length != shape.length)   strides=Arrays.copyOfRange(strides,0,shape.length);
  return subArray(offsets,shape,strides);
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public IComplexNDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  int[] offsets=Indices.offsets(indexes);
  if (offsets.length != indexes.length)   throw new IllegalStateException(""String_Node_Str"");
  int[] shape=Indices.shape(shape(),indexes);
  if (shape.length < offsets.length) {
    int[] copy=new int[offsets.length];
    Arrays.fill(copy,1);
    int delta=Math.abs(shape.length - copy.length);
    for (int i=copy.length - 1; i > 0; i--) {
      copy[i]=shape[i - delta];
    }
    shape=copy;
  }
  if (!Indices.isContiguous(indexes)) {
    IComplexNDArray ret=Nd4j.createComplex(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      for (int i=0; i < ret.slices(); i++) {
        INDArray putSlice=slice(i).get(Arrays.copyOfRange(indexes,1,indexes.length));
        ret.putSlice(i,putSlice);
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) >= length())   return this;
  int[] strides=ArrayUtil.copy(stride());
  return subArray(offsets,shape,strides);
}"
3455,"@Override public IComplexNDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return Nd4j.createComplex(shape);
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  for (int i=0; i < offsets.length; i++)   offsets[i]/=2;
  int offset=(this.offset + ArrayUtil.dotProduct(offsets,this.stride));
  IComplexNDArray ret=Nd4j.createComplex(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
  return ret;
}","@Override public IComplexNDArray subArray(int[] offsets,int[] shape,int[] stride){
  ensureNotCleanedUp();
  int n=shape.length;
  if (shape.length < 1)   return Nd4j.createComplex(shape);
  if (offsets.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(offsets));
  if (shape.length != n)   throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(shape));
  if (Arrays.equals(shape,this.shape)) {
    if (ArrayUtil.isZero(offsets)) {
      return this;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  int offset=(this.offset + ArrayUtil.dotProduct(offsets,this.stride));
  IComplexNDArray ret=Nd4j.createComplex(data,Arrays.copyOf(shape,shape.length),stride,offset,ordering);
  return ret;
}"
3456,"/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=Nd4j.create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      for (int i=0; i < ret.slices(); i++) {
        INDArray putSlice=slice(i).get(Arrays.copyOfRange(indexes,1,indexes.length));
        ret.putSlice(i,putSlice);
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length())   return this;
  int[] strides=null;
  strides=ArrayUtil.copy(stride());
  if (offsets.length != shape.length)   offsets=Arrays.copyOfRange(offsets,0,shape.length);
  if (strides.length != shape.length)   strides=Arrays.copyOfRange(strides,0,shape.length);
  return subArray(offsets,shape,strides);
}","/** 
 * Returns a subset of this array based on the specified indexes
 * @param indexes the indexes in to the array
 * @return a view of the array with the specified indices
 */
@Override public INDArray get(NDArrayIndex... indexes){
  ensureNotCleanedUp();
  indexes=Indices.adjustIndices(shape(),indexes);
  int[] offsets=Indices.offsets(indexes);
  int[] shape=Indices.shape(shape(),indexes);
  if (!Indices.isContiguous(indexes)) {
    INDArray ret=Nd4j.create(shape);
    if (ret.isVector() && isVector()) {
      int[] indices=indexes[0].indices();
      for (int i=0; i < ret.length(); i++) {
        ret.putScalar(i,getDouble(indices[i]));
      }
      return ret;
    }
    if (!ret.isVector()) {
      if (slices() == 1) {
        INDArray newSlice=slice(0);
        NDArrayIndex[] putIndices=Arrays.copyOfRange(indexes,1,indexes.length);
        return newSlice.get(putIndices);
      }
 else {
        for (int i=0; i < ret.slices(); i++) {
          INDArray slice=slice(i);
          INDArray putSlice=slice.get(Arrays.copyOfRange(indexes,1,indexes.length));
          ret.putSlice(i,putSlice);
        }
      }
    }
 else {
      INDArray putSlice=slice(0).get(Arrays.copyOfRange(indexes,1,indexes.length));
      ret.putSlice(0,putSlice);
    }
    return ret;
  }
  if (ArrayUtil.prod(shape) > length())   return this;
  int[] strides=ArrayUtil.copy(stride());
  return subArray(offsets,shape,strides);
}"
3457,"/** 
 * Compare two matrices. Returns true if and only if other is also a DoubleMatrix which has the same size and the maximal absolute difference in matrix elements is smaller than 1e-6.
 * @param o
 */
@Override public boolean equals(Object o){
  ensureNotCleanedUp();
  INDArray n=null;
  if (!(o instanceof INDArray))   return false;
  if (n == null)   n=(INDArray)o;
  if (isScalar() && n.isScalar()) {
    if (data.dataType() == DataBuffer.FLOAT) {
      double val=getDouble(0);
      double val2=n.getDouble(0);
      return Math.abs(val - val2) < 1e-6;
    }
 else {
      double val=getDouble(0);
      double val2=n.getDouble(0);
      return Math.abs(val - val2) < 1e-6;
    }
  }
 else   if (isVector() && n.isVector()) {
    for (int i=0; i < length; i++) {
      if (data.dataType() == DataBuffer.FLOAT) {
        double curr=getDouble(i);
        double comp=n.getDouble(i);
        if (Math.abs(curr - comp) > 1e-3)         return false;
      }
 else {
        double curr=getDouble(i);
        double comp=n.getDouble(i);
        if (Math.abs(curr - comp) > 1e-3)         return false;
      }
    }
    return true;
  }
  if (!Shape.shapeEquals(shape(),n.shape()))   return false;
  if (slices() != n.slices())   return false;
  for (int i=0; i < slices(); i++) {
    INDArray slice=slice(i);
    INDArray nSlice=n.slice(i);
    if (!slice.equals(nSlice))     return false;
  }
  return true;
}","/** 
 * Compare two matrices. Returns true if and only if other is also a DoubleMatrix which has the same size and the maximal absolute difference in matrix elements is smaller than 1e-6.
 * @param o
 */
@Override public boolean equals(Object o){
  ensureNotCleanedUp();
  INDArray n=null;
  if (!(o instanceof INDArray))   return false;
  if (n == null)   n=(INDArray)o;
  if (isScalar() && n.isScalar()) {
    if (data.dataType() == DataBuffer.FLOAT) {
      double val=getDouble(0);
      double val2=n.getDouble(0);
      return Math.abs(val - val2) < Nd4j.EPS_THRESHOLD;
    }
 else {
      double val=getDouble(0);
      double val2=n.getDouble(0);
      return Math.abs(val - val2) < Nd4j.EPS_THRESHOLD;
    }
  }
 else   if (isVector() && n.isVector()) {
    for (int i=0; i < length; i++) {
      if (data.dataType() == DataBuffer.FLOAT) {
        double curr=getDouble(i);
        double comp=n.getDouble(i);
        if (Math.abs(curr - comp) > Nd4j.EPS_THRESHOLD)         return false;
      }
 else {
        double curr=getDouble(i);
        double comp=n.getDouble(i);
        if (Math.abs(curr - comp) > Nd4j.EPS_THRESHOLD)         return false;
      }
    }
    return true;
  }
  if (!Shape.shapeEquals(shape(),n.shape()))   return false;
  if (slices() != n.slices())   return false;
  for (int i=0; i < slices(); i++) {
    INDArray slice=slice(i);
    INDArray nSlice=n.slice(i);
    if (!slice.equals(nSlice))     return false;
  }
  return true;
}"
3458,"protected INDArray newShape(int[] newShape,char ordering){
  ensureNotCleanedUp();
  if (Arrays.equals(newShape,this.shape()))   return this;
 else   if (Shape.isVector(newShape) && isVector()) {
    if (isRowVector() && Shape.isColumnVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{stride[0],1},offset);
    }
 else     if (isRowVector() && newShape.length == 1 || isRowVector() && newShape.length == 2) {
      this.shape=newShape;
    }
 else     if (isColumnVector() && Shape.isRowVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{stride[1]},offset);
    }
  }
  INDArray newCopy=this;
  int[] newStrides=null;
  if (shape().length > 1 && ((ordering == NDArrayFactory.C && this.ordering != NDArrayFactory.C) || (ordering == NDArrayFactory.FORTRAN && this.ordering != NDArrayFactory.FORTRAN))) {
    newStrides=noCopyReshape(newShape,ordering);
    if (newStrides == null) {
      newCopy=Nd4j.create(shape(),ordering);
      for (int i=0; i < vectorsAlongDimension(0); i++) {
        INDArray copyFrom=vectorAlongDimension(i,0);
        INDArray copyTo=newCopy.vectorAlongDimension(i,0);
        for (int j=0; j < copyFrom.length(); j++) {
          copyTo.putScalar(j,copyFrom.getDouble(i));
        }
      }
    }
  }
  if (newStrides == null)   newStrides=this instanceof IComplexNDArray ? Nd4j.getComplexStrides(newShape) : Nd4j.getStrides(newShape);
  if (this instanceof IComplexNDArray)   return Nd4j.createComplex(newCopy.data(),newShape,newStrides,offset);
  return Nd4j.create(newCopy.data(),newShape,newStrides,offset);
}","protected INDArray newShape(int[] newShape,char ordering){
  ensureNotCleanedUp();
  if (Arrays.equals(newShape,this.shape()))   return this;
 else   if (Shape.isVector(newShape) && isVector()) {
    if (isRowVector() && Shape.isColumnVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{stride[0],1},offset);
    }
 else     if (isRowVector() && newShape.length == 1 || isRowVector() && newShape.length == 2) {
      this.shape=newShape;
    }
 else     if (isColumnVector() && Shape.isRowVectorShape(newShape)) {
      return Nd4j.create(data,newShape,new int[]{stride[0]},offset);
    }
  }
  INDArray newCopy=this;
  int[] newStrides=null;
  if (shape().length > 1 && ((ordering == NDArrayFactory.C && this.ordering != NDArrayFactory.C) || (ordering == NDArrayFactory.FORTRAN && this.ordering != NDArrayFactory.FORTRAN))) {
    newStrides=noCopyReshape(newShape,ordering);
    if (newStrides == null) {
      newCopy=Nd4j.create(shape(),ordering);
      for (int i=0; i < vectorsAlongDimension(0); i++) {
        INDArray copyFrom=vectorAlongDimension(i,0);
        INDArray copyTo=newCopy.vectorAlongDimension(i,0);
        for (int j=0; j < copyFrom.length(); j++) {
          copyTo.putScalar(j,copyFrom.getDouble(i));
        }
      }
    }
  }
  if (newStrides == null)   newStrides=this instanceof IComplexNDArray ? Nd4j.getComplexStrides(newShape) : Nd4j.getStrides(newShape);
  if (this instanceof IComplexNDArray)   return Nd4j.createComplex(newCopy.data(),newShape,newStrides,offset);
  return Nd4j.create(newCopy.data(),newShape,newStrides,offset);
}"
3459,"/** 
 * ND Convolution
 * @param input  the input to op
 * @param kernel the kernel to op with
 * @param type   the type of convolution
 * @param axes   the axes to do the convolution along
 * @return the convolution of the given input and kernel
 */
@Override public INDArray convn(INDArray input,INDArray kernel,Convolution.Type type,int[] axes){
  if (kernel.isScalar() && input.isScalar())   return kernel.mul(input);
  INDArray shape=ArrayUtil.toNDArray(input.shape()).add(ArrayUtil.toNDArray(kernel.shape())).subi(1);
  int[] intShape=ArrayUtil.toInts(shape);
  IComplexNDArray fftedInput=FFT.rawfftn(Nd4j.createComplex(input),intShape,axes);
  IComplexNDArray fftedKernel=FFT.rawfftn(Nd4j.createComplex(kernel),intShape,axes);
  if (!Arrays.equals(fftedInput.shape(),fftedKernel.shape())) {
    if (fftedInput.length() < fftedKernel.length())     fftedInput=ComplexNDArrayUtil.padWithZeros(fftedInput,fftedKernel.shape());
 else     fftedKernel=ComplexNDArrayUtil.padWithZeros(fftedKernel,fftedInput.shape());
  }
  IComplexNDArray inputTimesKernel=fftedInput.muli(fftedKernel);
  IComplexNDArray convolution=FFT.ifftn(inputTimesKernel);
switch (type) {
case FULL:
    return convolution.getReal();
case SAME:
  return ComplexNDArrayUtil.center(convolution,input.shape()).getReal();
case VALID:
int[] shape2=ArrayUtil.toInts(Transforms.abs(ArrayUtil.toNDArray(input.shape()).sub(ArrayUtil.toNDArray(kernel.shape())).addi(1)));
for (int i=0; i < shape2.length; i++) shape2[i]=Math.max(1,shape2[i]);
return ComplexNDArrayUtil.center(convolution,shape2).getReal();
}
return convolution.getReal();
}","/** 
 * ND Convolution
 * @param input  the input to op
 * @param kernel the kernel to op with
 * @param type   the type of convolution
 * @param axes   the axes to do the convolution along
 * @return the convolution of the given input and kernel
 */
@Override public INDArray convn(INDArray input,INDArray kernel,Convolution.Type type,int[] axes){
  if (input.shape().length != kernel.shape().length) {
    int[] newShape=new int[Math.max(input.shape().length,kernel.shape().length)];
    Arrays.fill(newShape,1);
    int lengthDelta=Math.abs(input.shape().length - kernel.shape().length);
    if (input.shape().length < kernel.shape().length) {
      System.arraycopy(input.shape(),0,newShape,kernel.shape().length - lengthDelta,Math.min(kernel.shape().length,input.shape().length) - lengthDelta);
      input=input.reshape(newShape);
    }
 else {
      System.arraycopy(kernel.shape(),0,newShape,input.shape().length - lengthDelta,Math.min(kernel.shape().length,input.shape().length) - lengthDelta);
      kernel=kernel.reshape(newShape);
    }
  }
  if (kernel.isScalar() && input.isScalar())   return kernel.mul(input);
  INDArray shape=ArrayUtil.toNDArray(input.shape()).add(ArrayUtil.toNDArray(kernel.shape())).subi(1);
  int[] intShape=ArrayUtil.toInts(shape);
  IComplexNDArray fftedInput=FFT.rawfftn(Nd4j.createComplex(input),intShape,axes);
  IComplexNDArray fftedKernel=FFT.rawfftn(Nd4j.createComplex(kernel),intShape,axes);
  if (!Arrays.equals(fftedInput.shape(),fftedKernel.shape())) {
    if (fftedInput.length() < fftedKernel.length())     fftedInput=ComplexNDArrayUtil.padWithZeros(fftedInput,fftedKernel.shape());
 else     fftedKernel=ComplexNDArrayUtil.padWithZeros(fftedKernel,fftedInput.shape());
  }
  IComplexNDArray inputTimesKernel=fftedInput.muli(fftedKernel);
  IComplexNDArray convolution=FFT.ifftn(inputTimesKernel);
switch (type) {
case FULL:
    return convolution.getReal();
case SAME:
  return ComplexNDArrayUtil.center(convolution,input.shape()).getReal();
case VALID:
int[] shape2=ArrayUtil.toInts(Transforms.abs(ArrayUtil.toNDArray(input.shape()).sub(ArrayUtil.toNDArray(kernel.shape())).addi(1)));
return ComplexNDArrayUtil.center(convolution,shape2).getReal();
}
return convolution.getReal();
}"
3460,"/** 
 * Calculate the shape for the given set of indices. <p/> The shape is defined as (for each dimension) the difference between the end index + 1 and the begin index <p/> If specified, this will check for whether any of the indices are >= to end - 1 and if so, prune it down
 * @param shape   the original shape
 * @param indices the indices to calculate the shape for
 * @return the shape for the given indices
 */
public static int[] shape(int[] shape,NDArrayIndex... indices){
  if (indices.length > shape.length)   return shape;
  int[] ret=new int[indices.length];
  for (int i=0; i < ret.length; i++) {
    if (indices[i] instanceof NDArrayIndex.NDArrayIndexAll) {
      ret[i]=shape[i];
    }
 else {
      int[] currIndices=indices[i].indices();
      if (currIndices.length < 1)       continue;
      int end=currIndices[currIndices.length - 1];
      if (end > shape[i])       end=shape[i] - 1;
      int begin=currIndices[0];
      ret[i]=indices[i].isInterval() ? Math.abs(end - begin) + 1 : indices[i].indices().length;
    }
  }
  List<Integer> nonZeros=new ArrayList<>();
  for (int i=0; i < ret.length; i++) {
    if (ret[i] > 0)     nonZeros.add(ret[i]);
  }
  return ArrayUtil.toArray(nonZeros);
}","/** 
 * Calculate the shape for the given set of indices. <p/> The shape is defined as (for each dimension) the difference between the end index + 1 and the begin index <p/> If specified, this will check for whether any of the indices are >= to end - 1 and if so, prune it down
 * @param shape   the original shape
 * @param indices the indices to calculate the shape for
 * @return the shape for the given indices
 */
public static int[] shape(int[] shape,NDArrayIndex... indices){
  return shape(shape,new int[shape.length],indices);
}"
3461,"/** 
 * Flattens the array for linear indexing
 * @return the flattened version of this array
 */
@Override public IComplexNDArray ravel(){
  final IComplexNDArray ret=Nd4j.createComplex(length,ordering);
  final AtomicInteger counter=new AtomicInteger(0);
  SliceOp op=new SliceOp(){
    @Override public void operate(    INDArray nd){
      IComplexNDArray nd1=(IComplexNDArray)nd;
      for (int i=0; i < nd.length(); i++) {
        int element=counter.getAndIncrement();
        ret.putScalar(element,nd1.getComplex(i));
      }
    }
  }
;
  if (ordering == NDArrayFactory.C) {
    iterateOverAllRows(op);
  }
 else   if (ordering == NDArrayFactory.FORTRAN) {
    iterateOverAllColumns(op);
  }
  return ret;
}","/** 
 * Flattens the array for linear indexing
 * @return the flattened version of this array
 */
@Override public IComplexNDArray ravel(){
  ensureNotCleanedUp();
  IComplexNDArray ret=Nd4j.createComplex(length,ordering);
  int dimension=shape.length == 2 ? 1 : shape.length;
  int count=0;
  for (int i=0; i < vectorsAlongDimension(dimension); i++) {
    IComplexNDArray vec=vectorAlongDimension(i,dimension);
    for (int j=0; j < vec.length(); j++) {
      ret.putScalar(count++,vec.getComplex(j));
    }
  }
  return ret;
}"
3462,"@Override public IComplexNDArray gemv(IComplexFloat alpha,IComplexNDArray a,IComplexNDArray x,IComplexFloat beta,IComplexNDArray y){
  DataTypeValidation.assertDouble(a,x,y);
  NativeBlas.cgemv('N',a.rows(),a.columns(),(ComplexFloat)alpha,a.data().asFloat(),a.blasOffset(),a.rows(),x.data().asFloat(),x.offset(),x.secondaryStride(),(ComplexFloat)beta,y.data().asFloat(),y.blasOffset(),y.secondaryStride());
  return y;
}","@Override public IComplexNDArray gemv(IComplexFloat alpha,IComplexNDArray a,IComplexNDArray x,IComplexFloat beta,IComplexNDArray y){
  DataTypeValidation.assertFloat(a,x,y);
  NativeBlas.cgemv('N',a.rows(),a.columns(),(ComplexFloat)alpha,a.data().asFloat(),a.blasOffset(),a.rows(),x.data().asFloat(),x.offset(),x.secondaryStride(),(ComplexFloat)beta,y.data().asFloat(),y.blasOffset(),y.secondaryStride());
  return y;
}"
3463,"/** 
 * Or over the whole ndarray given some condition
 * @param n
 * @param cond
 * @return
 */
public static boolean or(INDArray n,Condition cond){
  boolean ret=true;
  INDArray linear=n.linearView();
  for (int i=0; i < linear.length(); i++) {
    ret=ret || cond.apply(linear.getFloat(i));
  }
  return ret;
}","/** 
 * Or over the whole ndarray given some condition
 * @param n
 * @param cond
 * @return
 */
public static boolean or(INDArray n,Condition cond){
  boolean ret=false;
  INDArray linear=n.linearView();
  for (int i=0; i < linear.length(); i++) {
    ret=ret || cond.apply(linear.getFloat(i));
  }
  return ret;
}"
3464,"@Override public float[] asFloat(){
  return new float[0];
}","@Override public float[] asFloat(){
  ensureNotFreed();
  return ArrayUtil.toFloats(asDouble());
}"
3465,"@Override public double[] asDouble(){
  ensureNotFreed();
  double[] ret=new double[length];
  Pointer p=Pointer.to(ret);
  JCublas.cublasGetVector(length,elementSize(),pointer(),1,p,1);
  return ret;
}","@Override public double[] asDouble(){
  ensureNotFreed();
  double[] ret=new double[length];
  JCuda.cudaMemcpy(Pointer.to(ret),pointer(),length * elementSize(),cudaMemcpyKind.cudaMemcpyDeviceToHost);
  return ret;
}"
3466,"@Override public float[] asFloat(){
  ensureNotFreed();
  float[] ret=new float[length];
  Pointer p=Pointer.to(ret);
  JCublas.cublasGetVector(length,elementSize(),pointer(),1,p,1);
  return ret;
}","@Override public float[] asFloat(){
  ensureNotFreed();
  float[] ret=new float[length];
  JCuda.cudaMemcpy(Pointer.to(ret),pointer(),length * elementSize(),cudaMemcpyKind.cudaMemcpyDeviceToHost);
  return ret;
}"
3467,"private void init(ReferenceQueue<INDArray> queue){
  this.queue=queue;
  setPriority(Thread.MAX_PRIORITY);
  setName(""String_Node_Str"");
  setDaemon(true);
}","private void init(ReferenceQueue<INDArray> queue){
  this.queue=queue;
  setPriority(Thread.MAX_PRIORITY);
  setName(""String_Node_Str"");
  setDaemon(true);
  ranFinals=new AtomicLong(-1);
}"
3468,"@Override public void run(){
  while (true) {
    Reference<INDArray> ref=(Reference<INDArray>)queue.poll();
    if (ref != null) {
      INDArray reffed=ref.get();
      reffed.data().removeReferencing(reffed.id());
      if (reffed.data().references().isEmpty()) {
        reffed.data().destroy();
        System.out.println(""String_Node_Str"");
      }
    }
  }
}","@Override public void run(){
  while (true) {
    Reference<INDArray> ref=(Reference<INDArray>)queue.poll();
    runFinalize();
    if (ref != null) {
      INDArray reffed=ref.get();
      reffed.data().removeReferencing(reffed.id());
    }
  }
}"
3469,"/** 
 * General matrix multiply
 * @param A
 * @param B
 * @param C
 * @param alpha
 * @param beta
 * @return
 */
public static INDArray gemm(INDArray A,INDArray B,INDArray C,float alpha,float beta){
  DataTypeValidation.assertFloat(A,B,C);
  Pointer cAPointer=getPointer(A);
  Pointer cBPointer=getPointer(B);
  Pointer cCPointer=getPointer(C);
  try {
    JCublas.cublasSgemm('n','n',C.rows(),C.columns(),A.columns(),alpha,cAPointer,A.rows(),cBPointer,B.rows(),beta,cCPointer,C.rows());
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + JCuda.cudaGetErrorString(JCuda.cudaGetLastError()),e);
  }
  return C;
}","/** 
 * General matrix multiply
 * @param A
 * @param B
 * @param C
 * @param alpha
 * @param beta
 * @return
 */
public static INDArray gemm(INDArray A,INDArray B,INDArray C,float alpha,float beta){
  DataTypeValidation.assertFloat(A,B,C);
  Pointer cAPointer=getPointer(A);
  Pointer cBPointer=getPointer(B);
  Pointer cCPointer=getPointer(C);
  JCublas.cublasSgemm('n','n',C.rows(),C.columns(),A.columns(),alpha,cAPointer,A.rows(),cBPointer,B.rows(),beta,cCPointer,C.rows());
  return C;
}"
3470,"@Override public IComplexNumber getComplex(int i){
  return dataType() == DataBuffer.FLOAT ? getComplexFloat(i) : getComplexDouble(i);
}","@Override public IComplexNumber getComplex(int i){
  ensureNotFreed();
  return dataType() == DataBuffer.FLOAT ? getComplexFloat(i) : getComplexDouble(i);
}"
3471,"/** 
 * Copy the data of this buffer to another buffer on the gpu
 * @param to the buffer to copy data to
 */
protected void copyTo(JCudaBuffer to){
  if (to.dataType() != dataType())   throw new IllegalArgumentException(""String_Node_Str"");
  JCuda.cudaMemcpy(to.pointer(),pointer(),length() * elementSize(),cudaMemcpyKind.cudaMemcpyDeviceToDevice);
}","/** 
 * Copy the data of this buffer to another buffer on the gpu
 * @param to the buffer to copy data to
 */
protected void copyTo(JCudaBuffer to){
  ensureNotFreed();
  if (to.dataType() != dataType())   throw new IllegalArgumentException(""String_Node_Str"");
  JCuda.cudaMemcpy(to.pointer(),pointer(),length() * elementSize(),cudaMemcpyKind.cudaMemcpyDeviceToDevice);
}"
3472,"/** 
 * Set an individual element
 * @param index the index of the element
 * @param from  the element to get data from
 */
protected void set(int index,Pointer from){
  set(index,1,from);
}","/** 
 * Set an individual element
 * @param index the index of the element
 * @param from  the element to get data from
 */
protected void set(int index,Pointer from){
  ensureNotFreed();
  set(index,1,from);
}"
3473,"@Override public void destroy(){
  try {
    if (!freed) {
      JCuda.cudaFree(pointer);
      freed=true;
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override public synchronized void destroy(){
  ensureNotFreed();
  try {
    if (!freed.get()) {
      JCuda.cudaFree(pointer);
      freed.set(true);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
3474,"@Override public int getInt(int ix){
  return 0;
}","@Override public int getInt(int ix){
  ensureNotFreed();
  return 0;
}"
3475,"@Override public DataBuffer dup(){
  throw new UnsupportedOperationException();
}","@Override public DataBuffer dup(){
  ensureNotFreed();
  throw new UnsupportedOperationException();
}"
3476,"@Override public void assign(int[] offsets,int[] strides,DataBuffer... buffers){
  assign(offsets,strides,length(),buffers);
}","@Override public void assign(int[] offsets,int[] strides,DataBuffer... buffers){
  ensureNotFreed();
  assign(offsets,strides,length(),buffers);
}"
3477,"@Override public void setData(double[] data){
  if (data.length != length)   throw new IllegalArgumentException(""String_Node_Str"" + length() + ""String_Node_Str""+ data.length);
  if (pointer() == null)   alloc();
  JCuda.cudaMemcpy(pointer(),Pointer.to(data),data.length * elementSize(),cudaMemcpyKind.cudaMemcpyHostToDevice);
}","@Override public void setData(double[] data){
  ensureNotFreed();
  if (data.length != length)   throw new IllegalArgumentException(""String_Node_Str"" + length() + ""String_Node_Str""+ data.length);
  if (pointer() == null)   alloc();
  JCuda.cudaMemcpy(pointer(),Pointer.to(data),data.length * elementSize(),cudaMemcpyKind.cudaMemcpyHostToDevice);
}"
3478,"@Override public double getDouble(int i){
  double[] d=new double[1];
  Pointer p=Pointer.to(d);
  get(i,p);
  return d[0];
}","@Override public double getDouble(int i){
  ensureNotFreed();
  double[] d=new double[1];
  Pointer p=Pointer.to(d);
  get(i,p);
  return d[0];
}"
3479,"@Override public float[] getFloatsAt(int offset,int inc,int length){
  return ArrayUtil.toFloats(getDoublesAt(offset,1,length));
}","@Override public float[] getFloatsAt(int offset,int inc,int length){
  ensureNotFreed();
  return ArrayUtil.toFloats(getDoublesAt(offset,1,length));
}"
3480,"@Override public double[] asDouble(){
  double[] ret=new double[length];
  Pointer p=Pointer.to(ret);
  JCublas.cublasGetVector(length,elementSize(),pointer(),1,p,1);
  return ret;
}","@Override public double[] asDouble(){
  ensureNotFreed();
  double[] ret=new double[length];
  Pointer p=Pointer.to(ret);
  JCublas.cublasGetVector(length,elementSize(),pointer(),1,p,1);
  return ret;
}"
3481,"@Override public DataBuffer dup(){
  CudaDoubleDataBuffer buffer=new CudaDoubleDataBuffer(length());
  copyTo(buffer);
  return buffer;
}","@Override public DataBuffer dup(){
  ensureNotFreed();
  CudaDoubleDataBuffer buffer=new CudaDoubleDataBuffer(length());
  copyTo(buffer);
  return buffer;
}"
3482,"@Override public void assign(Number value,int offset){
  int arrLength=length - offset;
  double[] data=new double[arrLength];
  for (int i=0; i < data.length; i++)   data[i]=value.doubleValue();
  set(offset,arrLength,Pointer.to(data));
}","@Override public void assign(Number value,int offset){
  ensureNotFreed();
  int arrLength=length - offset;
  double[] data=new double[arrLength];
  for (int i=0; i < data.length; i++)   data[i]=value.doubleValue();
  set(offset,arrLength,Pointer.to(data));
}"
3483,"@Override public double[] getDoublesAt(int offset,int inc,int length){
  if (offset + length > length())   length-=offset;
  double[] ret=new double[length];
  Pointer p=Pointer.to(ret);
  get(offset,inc,length,p);
  return ret;
}","@Override public double[] getDoublesAt(int offset,int inc,int length){
  ensureNotFreed();
  if (offset + length > length())   length-=offset;
  double[] ret=new double[length];
  Pointer p=Pointer.to(ret);
  get(offset,inc,length,p);
  return ret;
}"
3484,"@Override public void init(INDArray x,INDArray y,INDArray z,int n){
  super.init(x,y,z,n);
  if (x instanceof IComplexNDArray) {
    this.maxComplex=Nd4j.getExecutioner().execAndReturn(new Max(x)).currentResultComplex();
    IComplexNDArray complexX=(IComplexNDArray)x;
    this.y=Transforms.exp(complexX.sub(maxComplex));
    this.sumComplex=Nd4j.getExecutioner().execAndReturn(new Sum(y)).currentResultComplex();
    this.y.divi(sumComplex);
    this.extraArgs=new Object[]{maxComplex,sumComplex};
  }
 else {
    this.max=Nd4j.getExecutioner().execAndReturn(new Max(x)).currentResult();
    INDArray xMinusMax=x.sub(max);
    this.y=Transforms.exp(xMinusMax);
    this.sum=Nd4j.getExecutioner().execAndReturn(new Sum(this.y)).currentResult();
    this.y.divi(sum);
    this.extraArgs=new Object[]{max,sum};
  }
}","@Override public void init(INDArray x,INDArray y,INDArray z,int n){
  super.init(x,y,z,n);
  if (x instanceof IComplexNDArray) {
    this.maxComplex=Nd4j.getExecutioner().execAndReturn(new Max(x)).currentResultComplex();
    IComplexNDArray complexX=(IComplexNDArray)x;
    this.y=Transforms.exp(complexX.sub(maxComplex));
    if (this.y.shape().length < 2) {
      this.sumComplex=Nd4j.getExecutioner().execAndReturn(new Sum(y)).currentResultComplex();
      this.y.divi(sumComplex);
    }
 else {
      throw new NotImplementedException(""String_Node_Str"");
    }
    this.extraArgs=new Object[]{maxComplex,sumComplex};
  }
 else {
    this.max=Nd4j.getExecutioner().execAndReturn(new Max(x)).currentResult();
    INDArray xMinusMax=x.sub(max);
    this.y=Transforms.exp(xMinusMax);
    if (this.y.shape().length < 2) {
      this.sum=Nd4j.getExecutioner().execAndReturn(new Sum(this.y)).currentResult();
      this.y.divi(sum);
      this.extraArgs=new Object[]{max,sum};
    }
 else {
      INDArray aSum=this.y.sum(1).repmat(new int[]{this.y.shape()[1],1}).transpose();
      this.y.divi(aSum);
      this.extraArgs=new Object[]{max,aSum};
    }
  }
}"
3485,"/** 
 * Binarizes the dataset such that any number greater than cutoff is 1 otherwise zero
 * @param cutoff the cutoff point
 */
@Override public void binarize(double cutoff){
  for (int i=0; i < getFeatures().length(); i++) {
    double curr=(double)getFeatures().getScalar(i).element();
    if (curr > cutoff)     getFeatures().put(i,Nd4j.scalar(1));
 else     getFeatures().put(i,Nd4j.scalar(0));
  }
}","/** 
 * Binarizes the dataset such that any number greater than cutoff is 1 otherwise zero
 * @param cutoff the cutoff point
 */
@Override public void binarize(double cutoff){
  INDArray linear=getFeatureMatrix().linearView();
  for (int i=0; i < getFeatures().length(); i++) {
    double curr=linear.getDouble(i);
    if (curr > cutoff)     getFeatures().putScalar(i,1);
 else     getFeatures().putScalar(i,0);
  }
}"
3486,"@Override public IComplexNDArray scal(IComplexDouble alpha,IComplexNDArray x){
  return SimpleJCublas.scal(alpha,x.linearView());
}","@Override public IComplexNDArray scal(IComplexDouble alpha,IComplexNDArray x){
  return SimpleJCublas.scal(alpha,x);
}"
3487,"@Override public IComplexNDArray copy(IComplexNDArray x,IComplexNDArray y){
  SimpleJCublas.copy(x.linearView(),y.linearView());
  return y;
}","@Override public IComplexNDArray copy(IComplexNDArray x,IComplexNDArray y){
  SimpleJCublas.copy(x,y);
  return y;
}"
3488,"@Override public INDArray swap(INDArray x,INDArray y){
  SimpleJCublas.swap(x.linearView(),y.linearView());
  return y;
}","@Override public INDArray swap(INDArray x,INDArray y){
  SimpleJCublas.swap(x,y);
  return y;
}"
3489,"@Override public IComplexNDArray axpy(IComplexNumber da,IComplexNDArray dx,IComplexNDArray dy){
  if (da instanceof IComplexDouble) {
    SimpleJCublas.axpy((IComplexDouble)da,dx.linearView(),dy.linearView());
  }
 else   SimpleJCublas.axpy((IComplexFloat)da,dx.linearView(),dy.linearView());
  return dy;
}","@Override public IComplexNDArray axpy(IComplexNumber da,IComplexNDArray dx,IComplexNDArray dy){
  if (da instanceof IComplexDouble) {
    SimpleJCublas.axpy((IComplexDouble)da,dx,dy);
  }
 else   SimpleJCublas.axpy((IComplexFloat)da,dx,dy);
  return dy;
}"
3490,"protected void doSampleUniform(Pointer out,float min,float max,int n){
  JCurand.curandGenerateUniform(random.generator(),out,n);
  String functionName=""String_Node_Str"";
  CUfunction func=KernelFunctionLoader.getInstance().getFunction(functionName,""String_Node_Str"");
  if (func == null)   throw new IllegalArgumentException(""String_Node_Str"" + functionName + ""String_Node_Str"");
  int blocks=PointerUtil.getNumBlocks(n,128,64);
  int threads=PointerUtil.getNumThreads(n,64);
  Pointer kernelParams=Pointer.to(Pointer.to(new int[]{n}),Pointer.to(new double[]{min}),Pointer.to(new double[]{max}),Pointer.to(out),Pointer.to(random.generator()));
  KernelFunctions.invoke(blocks,threads,func,kernelParams);
}","protected void doSampleUniform(Pointer out,float min,float max,int n){
  JCurand.curandGenerateUniform(random.generator(),out,n);
  String functionName=""String_Node_Str"";
  CUfunction func=KernelFunctionLoader.getInstance().getFunction(functionName,""String_Node_Str"");
  if (func == null)   throw new IllegalArgumentException(""String_Node_Str"" + functionName + ""String_Node_Str"");
  int blocks=PointerUtil.getNumBlocks(n,128,64);
  int threads=PointerUtil.getNumThreads(n,64);
  Pointer kernelParams=Pointer.to(Pointer.to(new int[]{n}),Pointer.to(new float[]{min}),Pointer.to(new float[]{max}),Pointer.to(out),Pointer.to(random.generator()));
  KernelFunctions.invoke(blocks,threads,func,kernelParams);
}"
3491,"/** 
 * Scale by 1 / norm2 of the matrix
 * @param toScale the ndarray to scale
 * @return the scaled ndarray
 */
public static INDArray unitVec(INDArray toScale){
  double length=toScale.norm2(Integer.MAX_VALUE).getDouble(0);
  if (length > 0) {
    if (toScale.data().dataType().equals(DataBuffer.FLOAT))     return Nd4j.getBlasWrapper().scal(1.0f / length,toScale);
 else     return Nd4j.getBlasWrapper().scal(1.0 / length,toScale);
  }
  return toScale;
}","/** 
 * Scale by 1 / norm2 of the matrix
 * @param toScale the ndarray to scale
 * @return the scaled ndarray
 */
public static INDArray unitVec(INDArray toScale){
  double length=toScale.norm2(Integer.MAX_VALUE).getDouble(0);
  if (length > 0) {
    if (toScale.data().dataType().equals(DataBuffer.FLOAT))     return Nd4j.getBlasWrapper().scal(1.0f / (float)length,toScale);
 else     return Nd4j.getBlasWrapper().scal(1.0 / length,toScale);
  }
  return toScale;
}"
3492,"/** 
 * Returns the squared (Euclidean) distance.
 */
@Override public double squaredDistance(INDArray other){
  double sd=0.0;
  if (other instanceof IComplexNDArray) {
    IComplexNDArray n=(IComplexNDArray)other;
    IComplexNDArray nLinear=n.linearView();
    for (int i=0; i < length; i++) {
      IComplexNumber diff=linearView().getComplex(i).sub(nLinear.getComplex(i));
      double d=(double)diff.absoluteValue();
      sd+=d * d;
    }
    return sd;
  }
  for (int i=0; i < length; i++) {
    INDArray linear=other.linearView();
    IComplexNumber diff=linearView().getComplex(i).sub(linear.getDouble(i));
    double d=(double)diff.absoluteValue();
    sd+=d * d;
  }
  return sd;
}","/** 
 * Returns the squared (Euclidean) distance.
 */
@Override public double squaredDistance(INDArray other){
  double sd=0.0;
  if (other instanceof IComplexNDArray) {
    IComplexNDArray n=(IComplexNDArray)other;
    IComplexNDArray nLinear=n.linearView();
    for (int i=0; i < length; i++) {
      IComplexNumber diff=linearView().getComplex(i).sub(nLinear.getComplex(i));
      double d=diff.absoluteValue().doubleValue();
      sd+=d * d;
    }
    return sd;
  }
  for (int i=0; i < length; i++) {
    INDArray linear=other.linearView();
    IComplexNumber diff=linearView().getComplex(i).sub(linear.getDouble(i));
    double d=diff.absoluteValue().doubleValue();
    sd+=d * d;
  }
  return sd;
}"
3493,"/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(double)(curr instanceof IComplexNumber ? ((IComplexNumber)curr).absoluteValue() : (double)curr);
  double otherValue=(double)(value instanceof IComplexNumber ? ((IComplexNumber)value).absoluteValue() : (double)value);
  if (originValue == otherValue) {
    if (value instanceof IComplexNumber) {
      return Nd4j.createDouble(1,0);
    }
 else     return (double)1;
  }
 else {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(0,0);
 else     return (double)0;
  }
}","/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(curr instanceof IComplexNumber ? ((IComplexNumber)curr).absoluteValue().doubleValue() : (double)curr);
  double otherValue=(double)(value instanceof IComplexNumber ? ((IComplexNumber)value).absoluteValue().doubleValue() : (double)value);
  if (originValue == otherValue) {
    if (value instanceof IComplexNumber) {
      return Nd4j.createDouble(1,0);
    }
 else     return (double)1;
  }
 else {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(0,0);
 else     return (double)0;
  }
}"
3494,"/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(double)(curr instanceof IComplexNDArray ? ((IComplexNumber)curr).absoluteValue() : (double)curr);
  double otherValue=(double)(value instanceof IComplexNDArray ? ((IComplexNumber)value).absoluteValue() : (double)value);
  if (originValue > otherValue) {
    if (value instanceof IComplexNumber) {
      return Nd4j.createDouble(1,0);
    }
 else     return (double)1;
  }
 else {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(0,0);
 else     return (double)0;
  }
}","/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(curr instanceof IComplexNDArray ? ((IComplexNumber)curr).absoluteValue().doubleValue() : (double)curr);
  double otherValue=(value instanceof IComplexNDArray ? ((IComplexNumber)value).absoluteValue().doubleValue() : (double)value);
  if (originValue > otherValue) {
    if (value instanceof IComplexNumber) {
      return Nd4j.createDouble(1,0);
    }
 else     return (double)1;
  }
 else {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(0,0);
 else     return (double)0;
  }
}"
3495,"/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(double)(curr instanceof IComplexNDArray ? ((IComplexNumber)curr).absoluteValue() : (double)curr);
  double otherValue=(double)(value instanceof IComplexNDArray ? ((IComplexNumber)value).absoluteValue() : (double)value);
  if (originValue < otherValue) {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(1,0);
 else     return 1;
  }
 else {
    if (value instanceof IComplexNDArray)     return Nd4j.createDouble(0,0);
 else     return 0;
  }
}","/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(curr instanceof IComplexNDArray ? ((IComplexNumber)curr).absoluteValue().doubleValue() : (double)curr);
  double otherValue=(value instanceof IComplexNDArray ? ((IComplexNumber)value).absoluteValue().doubleValue() : (double)value);
  if (originValue < otherValue) {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(1,0);
 else     return 1;
  }
 else {
    if (value instanceof IComplexNDArray)     return Nd4j.createDouble(0,0);
 else     return 0;
  }
}"
3496,"/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(double)(curr instanceof IComplexNumber ? ((IComplexNumber)curr).absoluteValue() : (double)curr);
  double otherValue=(double)(value instanceof IComplexNumber ? ((IComplexNumber)value).absoluteValue() : (double)value);
  if (originValue != otherValue) {
    if (value instanceof IComplexNumber) {
      return Nd4j.createDouble(1,0);
    }
 else     return (double)1;
  }
 else {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(0,0);
 else     return (double)0;
  }
}","/** 
 * The transformation for a given value (a scalar ndarray)
 * @param value the value to applyTransformToOrigin (a scalar ndarray)
 * @param i     the index of the element being acted upon
 * @return the transformed value based on the input
 */
@Override public Object apply(INDArray from,Object value,int i){
  Object curr=getFromOrigin(from,i);
  double originValue=(curr instanceof IComplexNumber ? ((IComplexNumber)curr).absoluteValue().doubleValue() : (double)curr);
  double otherValue=(value instanceof IComplexNumber ? ((IComplexNumber)value).absoluteValue().doubleValue() : (double)value);
  if (originValue != otherValue) {
    if (value instanceof IComplexNumber) {
      return Nd4j.createDouble(1,0);
    }
 else     return (double)1;
  }
 else {
    if (value instanceof IComplexNumber)     return Nd4j.createDouble(0,0);
 else     return (double)0;
  }
}"
3497,"@Test public void testGetMulti(){
  assertEquals(8,n.length());
  assertEquals(true,Arrays.equals(ArrayUtil.of(2,2,2),n.shape()));
  float val=(float)n.getScalar(1,1,1).element();
  assertEquals(8.0,val,1e-6);
}","@Test public void testGetMulti(){
  assertEquals(8,n.length());
  assertEquals(true,Arrays.equals(ArrayUtil.of(2,2,2),n.shape()));
  float val=(float)n.getScalar(new int[]{1,1,1}).element();
  assertEquals(8.0,val,1e-6);
}"
3498,"/** 
 * Release the lock if it's currently held by the calling thread. If the current thread does not hold the lock, and error will be thrown.
 */
public synchronized void release(){
  checkThread();
  thread=null;
}","/** 
 * Release the lock if it's currently held by the calling thread. If the current thread does not hold the lock, and error will be thrown.
 */
public synchronized void release(){
  checkThread();
  thread=null;
  released=true;
}"
3499,"/** 
 * Acquire the lock if it's currently not acquired by another thread. If it's currently held by another thread, tryAcquire will return false, otherwise true is returned.
 * @return Returns true if the lock was acquired, false otherwise.
 */
public synchronized boolean tryAcquire(){
  if ((thread != null) && (thread != Thread.currentThread())) {
    return false;
  }
  thread=Thread.currentThread();
  return true;
}","/** 
 * Acquire the lock if it's currently not acquired by another thread. If it's currently held by another thread, tryAcquire will return false, otherwise true is returned.
 * @return Returns true if the lock was acquired, false otherwise.
 */
public synchronized boolean tryAcquire(){
  if ((thread != null) && (thread != Thread.currentThread())) {
    return false;
  }
  thread=Thread.currentThread();
  released=false;
  return true;
}"
3500,"/** 
 * Checks if the locker has access to the current thread. If the locker holds a different thread, than an Error is thrown.
 */
public void checkThread(){
  if ((thread != Thread.currentThread())) {
    throw new Error(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ thread);
  }
}","/** 
 * Checks if the locker has access to the current thread. If the locker holds a different thread, than an Error is thrown.
 */
public void checkThread(){
  if (released && thread == null) {
    throw new Error(""String_Node_Str"");
  }
  if ((thread != Thread.currentThread())) {
    throw new Error(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ thread);
  }
}"
3501,"/** 
 * Acquire the lock if it's currently not acquired by another thread. If it's currently held by another thread, an Error will be thrown.
 */
public synchronized void acquire(){
  if ((thread != null) && (thread != Thread.currentThread())) {
    throw new Error(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ thread);
  }
  thread=Thread.currentThread();
}","/** 
 * Acquire the lock if it's currently not acquired by another thread. If it's currently held by another thread, an Error will be thrown.
 */
public synchronized void acquire(){
  if ((thread != null) && (thread != Thread.currentThread())) {
    throw new Error(""String_Node_Str"" + Thread.currentThread() + ""String_Node_Str""+ thread);
  }
  thread=Thread.currentThread();
  released=false;
}"
3502,"protected void acquireLock(){
  _acquireLock(getV8RuntimePtr());
}","protected void acquireLock(final long v8RuntimePtr){
  _acquireLock(v8RuntimePtr);
}"
3503,"protected void releaseLock(){
  _releaseLock(getV8RuntimePtr());
}","protected void releaseLock(final long v8RuntimePtr){
  _releaseLock(v8RuntimePtr);
}"
3504,"@Test(expected=IllegalStateException.class) public void testJ2V8CannotCreateRuntime(){
  V8.createV8Runtime();
}","@Test(expected=IllegalStateException.class) public void testJ2V8CannotCreateRuntime(){
  String oldValue=System.getProperty(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    V8.createV8Runtime();
  }
  finally {
    System.setProperty(""String_Node_Str"",oldValue);
  }
}"
3505,"@Test public void testCreateIntegerMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(3,map.size());
  assertEquals(1,map.get(""String_Node_Str""));
  assertEquals(2,map.get(""String_Node_Str""));
  assertEquals(3,map.get(""String_Node_Str""));
  object.release();
}","@Test public void testCreateIntegerMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(3,map.size());
  assertEquals(1,map.get(""String_Node_Str""));
  assertEquals(2,map.get(""String_Node_Str""));
  assertEquals(3,map.get(""String_Node_Str""));
  object.release();
}"
3506,"@Test public void testCreateListFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<Object> list=V8ObjectUtils.toList(array);
  assertEquals(3,list.size());
  assertEquals(1,list.get(0));
  assertEquals(2,list.get(1));
  assertEquals(3,list.get(2));
  array.release();
}","@Test public void testCreateListFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<? super Object> list=V8ObjectUtils.toList(array);
  assertEquals(3,list.size());
  assertEquals(1,list.get(0));
  assertEquals(2,list.get(1));
  assertEquals(3,list.get(2));
  array.release();
}"
3507,"@Test public void testCreateListWithUndefinedFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<Object> list=V8ObjectUtils.toList(array);
  assertEquals(10,list.size());
  assertEquals(1,list.get(0));
  assertEquals(2,list.get(1));
  assertEquals(3,list.get(2));
  assertNull(list.get(3));
  assertNull(list.get(4));
  assertNull(list.get(5));
  assertNull(list.get(6));
  assertNull(list.get(7));
  assertNull(list.get(8));
  assertEquals(10,list.get(9));
  array.release();
}","@Test public void testCreateListWithUndefinedFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<? super Object> list=V8ObjectUtils.toList(array);
  assertEquals(10,list.size());
  assertEquals(1,list.get(0));
  assertEquals(2,list.get(1));
  assertEquals(3,list.get(2));
  assertNull(list.get(3));
  assertNull(list.get(4));
  assertNull(list.get(5));
  assertNull(list.get(6));
  assertNull(list.get(7));
  assertNull(list.get(8));
  assertEquals(10,list.get(9));
  array.release();
}"
3508,"@Test public void testCreateBooleanMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertTrue((boolean)map.get(""String_Node_Str""));
  assertTrue((boolean)map.get(""String_Node_Str""));
  assertFalse((boolean)map.get(""String_Node_Str""));
  assertFalse((boolean)map.get(""String_Node_Str""));
  object.release();
}","@Test public void testCreateBooleanMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertTrue((Boolean)map.get(""String_Node_Str""));
  assertTrue((Boolean)map.get(""String_Node_Str""));
  assertFalse((Boolean)map.get(""String_Node_Str""));
  assertFalse((Boolean)map.get(""String_Node_Str""));
  object.release();
}"
3509,"@Test public void testNullObjectGivesEmptyMap(){
  Map<String,Object> map=V8ObjectUtils.toMap(null);
  assertNotNull(map);
  assertEquals(0,map.size());
}","@Test public void testNullObjectGivesEmptyMap(){
  Map<String,? super Object> map=V8ObjectUtils.toMap(null);
  assertNotNull(map);
  assertEquals(0,map.size());
}"
3510,"@SuppressWarnings(""String_Node_Str"") @Test public void testCreateMatrixFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<Object> list=V8ObjectUtils.toList(array);
  assertEquals(3,list.size());
  assertEquals(3,((List)list.get(0)).size());
  assertEquals(3,((List)list.get(1)).size());
  assertEquals(3,((List)list.get(2)).size());
  assertEquals(1,((List)list.get(0)).get(0));
  assertEquals(2,((List)list.get(0)).get(1));
  assertEquals(3,((List)list.get(0)).get(2));
  assertTrue((boolean)((List)list.get(1)).get(0));
  assertFalse((boolean)((List)list.get(1)).get(1));
  assertTrue((boolean)((List)list.get(1)).get(2));
  assertEquals(""String_Node_Str"",((List)list.get(2)).get(0));
  assertEquals(""String_Node_Str"",((List)list.get(2)).get(1));
  assertEquals(""String_Node_Str"",((List)list.get(2)).get(2));
  array.release();
}","@SuppressWarnings(""String_Node_Str"") @Test public void testCreateMatrixFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<? super Object> list=V8ObjectUtils.toList(array);
  assertEquals(3,list.size());
  assertEquals(3,((List)list.get(0)).size());
  assertEquals(3,((List)list.get(1)).size());
  assertEquals(3,((List)list.get(2)).size());
  assertEquals(1,((List)list.get(0)).get(0));
  assertEquals(2,((List)list.get(0)).get(1));
  assertEquals(3,((List)list.get(0)).get(2));
  assertTrue((Boolean)((List)list.get(1)).get(0));
  assertFalse((Boolean)((List)list.get(1)).get(1));
  assertTrue((Boolean)((List)list.get(1)).get(2));
  assertEquals(""String_Node_Str"",((List)list.get(2)).get(0));
  assertEquals(""String_Node_Str"",((List)list.get(2)).get(1));
  assertEquals(""String_Node_Str"",((List)list.get(2)).get(2));
  array.release();
}"
3511,"@Test public void testCreateMixedMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertTrue((boolean)map.get(""String_Node_Str""));
  assertEquals(1,(int)map.get(""String_Node_Str""));
  assertEquals(3.14159,(double)map.get(""String_Node_Str""),0.0000001);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  object.release();
}","@Test public void testCreateMixedMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertTrue((Boolean)map.get(""String_Node_Str""));
  assertEquals(1,(int)(Integer)map.get(""String_Node_Str""));
  assertEquals(3.14159,(Double)map.get(""String_Node_Str""),0.0000001);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  object.release();
}"
3512,"@Test public void testCreateStringMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  object.release();
}","@Test public void testCreateStringMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  object.release();
}"
3513,"@SuppressWarnings(""String_Node_Str"") @Test public void testCreateMapWithLists(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(2,map.size());
  assertEquals(1,((List)map.get(""String_Node_Str"")).get(0));
  assertEquals(2,((List)map.get(""String_Node_Str"")).get(1));
  assertEquals(3,((List)map.get(""String_Node_Str"")).get(2));
  assertEquals(4,((List)map.get(""String_Node_Str"")).get(0));
  assertEquals(5,((List)map.get(""String_Node_Str"")).get(1));
  assertEquals(6,((List)map.get(""String_Node_Str"")).get(2));
  object.release();
}","@SuppressWarnings(""String_Node_Str"") @Test public void testCreateMapWithLists(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(2,map.size());
  assertEquals(1,((List)map.get(""String_Node_Str"")).get(0));
  assertEquals(2,((List)map.get(""String_Node_Str"")).get(1));
  assertEquals(3,((List)map.get(""String_Node_Str"")).get(2));
  assertEquals(4,((List)map.get(""String_Node_Str"")).get(0));
  assertEquals(5,((List)map.get(""String_Node_Str"")).get(1));
  assertEquals(6,((List)map.get(""String_Node_Str"")).get(2));
  object.release();
}"
3514,"@Test public void testCreateMapWithNulls(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(1,map.size());
  assertNull(map.get(0));
  object.release();
}","@Test public void testCreateMapWithNulls(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(1,map.size());
  assertNull(map.get(0));
  object.release();
}"
3515,"@Test public void testNullArrayGivesEmptyMap(){
  List<Object> list=V8ObjectUtils.toList(null);
  assertNotNull(list);
  assertEquals(0,list.size());
}","@Test public void testNullArrayGivesEmptyMap(){
  List<? super Object> list=V8ObjectUtils.toList(null);
  assertNotNull(list);
  assertEquals(0,list.size());
}"
3516,"@Test public void testCreateListWithNullFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<Object> list=V8ObjectUtils.toList(array);
  assertEquals(1,list.size());
  assertNull(list.get(0));
  array.release();
}","@Test public void testCreateListWithNullFromV8Array(){
  V8Array array=v8.executeArrayScript(""String_Node_Str"");
  List<? super Object> list=V8ObjectUtils.toList(array);
  assertEquals(1,list.size());
  assertNull(list.get(0));
  array.release();
}"
3517,"@Test public void testCreateDoubleMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertEquals(1.1,(double)map.get(""String_Node_Str""),0.000001);
  assertEquals(2.2,(double)map.get(""String_Node_Str""),0.000001);
  assertEquals(3.3,(double)map.get(""String_Node_Str""),0.000001);
  assertEquals(4.4,(double)map.get(""String_Node_Str""),0.000001);
  object.release();
}","@Test public void testCreateDoubleMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(4,map.size());
  assertEquals(1.1,(Double)map.get(""String_Node_Str""),0.000001);
  assertEquals(2.2,(Double)map.get(""String_Node_Str""),0.000001);
  assertEquals(3.3,(Double)map.get(""String_Node_Str""),0.000001);
  assertEquals(4.4,(Double)map.get(""String_Node_Str""),0.000001);
  object.release();
}"
3518,"@SuppressWarnings(""String_Node_Str"") @Test public void testCreateNestedMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,Object> map=V8ObjectUtils.toMap(object);
  assertEquals(2,map.size());
  assertEquals(7,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",((Map)map.get(""String_Node_Str"")).get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",((Map)map.get(""String_Node_Str"")).get(""String_Node_Str""));
  object.release();
}","@SuppressWarnings(""String_Node_Str"") @Test public void testCreateNestedMapFromV8Object(){
  V8Object object=v8.executeObjectScript(""String_Node_Str"");
  Map<String,? super Object> map=V8ObjectUtils.toMap(object);
  assertEquals(2,map.size());
  assertEquals(7,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",((Map)map.get(""String_Node_Str"")).get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",((Map)map.get(""String_Node_Str"")).get(""String_Node_Str""));
  object.release();
}"
3519,"/** 
 * Array Function 
 */
@Test public void testSimpleArrayFunction(){
  v8.executeVoidScript(""String_Node_Str"");
  V8Array result=v8.executeArrayFunction(""String_Node_Str"",null);
  assertEquals(3,result.getSize());
  result.release();
}","/** 
 * Array Function 
 */
@Test public void testSimpleArrayFunction(){
  v8.executeVoidScript(""String_Node_Str"");
  V8Array result=v8.executeArrayFunction(""String_Node_Str"",null);
  assertEquals(3,result.length());
  result.release();
}"
3520,"@Override public void onLayoutChildren(RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getItemCount() == 0) {
    detachAndScrapAttachedViews(recycler);
    return;
  }
  if (getChildCount() == 0 && state.isPreLayout()) {
    return;
  }
  if (!state.isPreLayout()) {
    mFirstChangedPosition=mChangedPositionCount=0;
  }
  if (getChildCount() == 0) {
    View scrap=recycler.getViewForPosition(0);
    addView(scrap);
    measureChildWithMargins(scrap,0,0);
    mDecoratedChildWidth=getDecoratedMeasuredWidth(scrap);
    mDecoratedChildHeight=getDecoratedMeasuredHeight(scrap);
    detachAndScrapView(scrap,recycler);
  }
  updateWindowSizing();
  SparseIntArray removedCache=null;
  if (state.isPreLayout()) {
    removedCache=new SparseIntArray(getChildCount());
    for (int i=0; i < getChildCount(); i++) {
      final View view=getChildAt(i);
      LayoutParams lp=(LayoutParams)view.getLayoutParams();
      if (lp.isItemRemoved()) {
        removedCache.put(lp.getViewAdapterPosition(),REMOVE_VISIBLE);
      }
    }
    if (removedCache.size() == 0 && mChangedPositionCount > 0) {
      for (int i=mFirstChangedPosition; i < (mFirstChangedPosition + mChangedPositionCount); i++) {
        removedCache.put(i,REMOVE_INVISIBLE);
      }
    }
  }
  int childLeft;
  int childTop;
  if (getChildCount() == 0) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else   if (!state.isPreLayout() && getVisibleChildCount() >= state.getItemCount()) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else {
    final View topChild=getChildAt(0);
    if (mForceClearOffsets) {
      childLeft=childTop=0;
      mForceClearOffsets=false;
    }
 else {
      childLeft=getDecoratedLeft(topChild);
      childTop=getDecoratedTop(topChild);
    }
    if (!state.isPreLayout() && getVerticalSpace() > (getTotalRowCount() * mDecoratedChildHeight)) {
      mFirstVisiblePosition=mFirstVisiblePosition % getTotalColumnCount();
      childTop=0;
      if ((mFirstVisiblePosition + mVisibleColumnCount) > state.getItemCount()) {
        mFirstVisiblePosition=Math.max(state.getItemCount() - mVisibleColumnCount,0);
        childLeft=0;
      }
    }
    int maxFirstRow=getTotalRowCount() - (mVisibleRowCount - 1);
    int maxFirstCol=getTotalColumnCount() - (mVisibleColumnCount - 1);
    boolean isOutOfRowBounds=getFirstVisibleRow() > maxFirstRow;
    boolean isOutOfColBounds=getFirstVisibleColumn() > maxFirstCol;
    if (isOutOfRowBounds || isOutOfColBounds) {
      int firstRow;
      if (isOutOfRowBounds) {
        firstRow=maxFirstRow;
      }
 else {
        firstRow=getFirstVisibleRow();
      }
      int firstCol;
      if (isOutOfColBounds) {
        firstCol=maxFirstCol;
      }
 else {
        firstCol=getFirstVisibleColumn();
      }
      mFirstVisiblePosition=firstRow * getTotalColumnCount() + firstCol;
      childLeft=getHorizontalSpace() - (mDecoratedChildWidth * mVisibleColumnCount);
      childTop=getVerticalSpace() - (mDecoratedChildHeight * mVisibleRowCount);
      if (getFirstVisibleRow() == 0) {
        childTop=Math.min(childTop,0);
      }
      if (getFirstVisibleColumn() == 0) {
        childLeft=Math.min(childLeft,0);
      }
    }
  }
  detachAndScrapAttachedViews(recycler);
  fillGrid(DIRECTION_NONE,childLeft,childTop,recycler,state,removedCache);
  if (!state.isPreLayout() && !recycler.getScrapList().isEmpty()) {
    final List<RecyclerView.ViewHolder> scrapList=recycler.getScrapList();
    final HashSet<View> disappearingViews=new HashSet<View>(scrapList.size());
    for (    RecyclerView.ViewHolder holder : scrapList) {
      final View child=holder.itemView;
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      if (!lp.isItemRemoved()) {
        disappearingViews.add(child);
      }
    }
    for (    View child : disappearingViews) {
      layoutDisappearingView(child);
    }
  }
}","@Override public void onLayoutChildren(RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getItemCount() == 0) {
    detachAndScrapAttachedViews(recycler);
    return;
  }
  if (getChildCount() == 0 && state.isPreLayout()) {
    return;
  }
  if (!state.isPreLayout()) {
    mFirstChangedPosition=mChangedPositionCount=0;
  }
  if (getChildCount() == 0) {
    View scrap=recycler.getViewForPosition(0);
    addView(scrap);
    measureChildWithMargins(scrap,0,0);
    mDecoratedChildWidth=getDecoratedMeasuredWidth(scrap);
    mDecoratedChildHeight=getDecoratedMeasuredHeight(scrap);
    detachAndScrapView(scrap,recycler);
  }
  updateWindowSizing();
  SparseIntArray removedCache=null;
  if (state.isPreLayout()) {
    removedCache=new SparseIntArray(getChildCount());
    for (int i=0; i < getChildCount(); i++) {
      final View view=getChildAt(i);
      LayoutParams lp=(LayoutParams)view.getLayoutParams();
      if (lp.isItemRemoved()) {
        removedCache.put(lp.getViewLayoutPosition(),REMOVE_VISIBLE);
      }
    }
    if (removedCache.size() == 0 && mChangedPositionCount > 0) {
      for (int i=mFirstChangedPosition; i < (mFirstChangedPosition + mChangedPositionCount); i++) {
        removedCache.put(i,REMOVE_INVISIBLE);
      }
    }
  }
  int childLeft;
  int childTop;
  if (getChildCount() == 0) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else   if (!state.isPreLayout() && getVisibleChildCount() >= state.getItemCount()) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else {
    final View topChild=getChildAt(0);
    if (mForceClearOffsets) {
      childLeft=childTop=0;
      mForceClearOffsets=false;
    }
 else {
      childLeft=getDecoratedLeft(topChild);
      childTop=getDecoratedTop(topChild);
    }
    if (!state.isPreLayout() && getVerticalSpace() > (getTotalRowCount() * mDecoratedChildHeight)) {
      mFirstVisiblePosition=mFirstVisiblePosition % getTotalColumnCount();
      childTop=0;
      if ((mFirstVisiblePosition + mVisibleColumnCount) > state.getItemCount()) {
        mFirstVisiblePosition=Math.max(state.getItemCount() - mVisibleColumnCount,0);
        childLeft=0;
      }
    }
    int maxFirstRow=getTotalRowCount() - (mVisibleRowCount - 1);
    int maxFirstCol=getTotalColumnCount() - (mVisibleColumnCount - 1);
    boolean isOutOfRowBounds=getFirstVisibleRow() > maxFirstRow;
    boolean isOutOfColBounds=getFirstVisibleColumn() > maxFirstCol;
    if (isOutOfRowBounds || isOutOfColBounds) {
      int firstRow;
      if (isOutOfRowBounds) {
        firstRow=maxFirstRow;
      }
 else {
        firstRow=getFirstVisibleRow();
      }
      int firstCol;
      if (isOutOfColBounds) {
        firstCol=maxFirstCol;
      }
 else {
        firstCol=getFirstVisibleColumn();
      }
      mFirstVisiblePosition=firstRow * getTotalColumnCount() + firstCol;
      childLeft=getHorizontalSpace() - (mDecoratedChildWidth * mVisibleColumnCount);
      childTop=getVerticalSpace() - (mDecoratedChildHeight * mVisibleRowCount);
      if (getFirstVisibleRow() == 0) {
        childTop=Math.min(childTop,0);
      }
      if (getFirstVisibleColumn() == 0) {
        childLeft=Math.min(childLeft,0);
      }
    }
  }
  detachAndScrapAttachedViews(recycler);
  fillGrid(DIRECTION_NONE,childLeft,childTop,recycler,state,removedCache);
  if (!state.isPreLayout() && !recycler.getScrapList().isEmpty()) {
    final List<RecyclerView.ViewHolder> scrapList=recycler.getScrapList();
    final HashSet<View> disappearingViews=new HashSet<View>(scrapList.size());
    for (    RecyclerView.ViewHolder holder : scrapList) {
      final View child=holder.itemView;
      final LayoutParams lp=(LayoutParams)child.getLayoutParams();
      if (!lp.isItemRemoved()) {
        disappearingViews.add(child);
      }
    }
    for (    View child : disappearingViews) {
      layoutDisappearingView(child);
    }
  }
}"
3521,"@Override public int scrollHorizontallyBy(int dx,RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getChildCount() == 0) {
    return 0;
  }
  final View topView=getChildAt(0);
  final View bottomView=getChildAt(mVisibleColumnCount - 1);
  int viewSpan=getDecoratedRight(bottomView) - getDecoratedLeft(topView);
  if (viewSpan <= getHorizontalSpace()) {
    return 0;
  }
  int delta;
  boolean leftBoundReached=getFirstVisibleColumn() == 0;
  boolean rightBoundReached=getLastVisibleColumn() >= getTotalColumnCount();
  if (dx > 0) {
    if (rightBoundReached) {
      int rightOffset=getHorizontalSpace() - getDecoratedRight(bottomView) + getPaddingRight();
      delta=Math.max(-dx,rightOffset);
    }
 else {
      delta=-dx;
    }
  }
 else {
    if (leftBoundReached) {
      int leftOffset=-getDecoratedLeft(topView) + getPaddingLeft();
      delta=Math.min(-dx,leftOffset);
    }
 else {
      delta=-dx;
    }
  }
  offsetChildrenHorizontal(delta);
  if (dx > 0) {
    if (getDecoratedRight(topView) < 0 && !rightBoundReached) {
      fillGrid(DIRECTION_END,recycler);
    }
 else     if (!rightBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
 else {
    if (getDecoratedLeft(topView) > 0 && !leftBoundReached) {
      fillGrid(DIRECTION_START,recycler);
    }
 else     if (!leftBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
  return -delta;
}","@Override public int scrollHorizontallyBy(int dx,RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getChildCount() == 0) {
    return 0;
  }
  final View topView=getChildAt(0);
  final View bottomView=getChildAt(mVisibleColumnCount - 1);
  int viewSpan=getDecoratedRight(bottomView) - getDecoratedLeft(topView);
  if (viewSpan < getHorizontalSpace()) {
    return 0;
  }
  int delta;
  boolean leftBoundReached=getFirstVisibleColumn() == 0;
  boolean rightBoundReached=getLastVisibleColumn() >= getTotalColumnCount();
  if (dx > 0) {
    if (rightBoundReached) {
      int rightOffset=getHorizontalSpace() - getDecoratedRight(bottomView) + getPaddingRight();
      delta=Math.max(-dx,rightOffset);
    }
 else {
      delta=-dx;
    }
  }
 else {
    if (leftBoundReached) {
      int leftOffset=-getDecoratedLeft(topView) + getPaddingLeft();
      delta=Math.min(-dx,leftOffset);
    }
 else {
      delta=-dx;
    }
  }
  offsetChildrenHorizontal(delta);
  if (dx > 0) {
    if (getDecoratedRight(topView) < 0 && !rightBoundReached) {
      fillGrid(DIRECTION_END,recycler);
    }
 else     if (!rightBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
 else {
    if (getDecoratedLeft(topView) > 0 && !leftBoundReached) {
      fillGrid(DIRECTION_START,recycler);
    }
 else     if (!leftBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
  return -delta;
}"
3522,"private int getTotalRowCount(){
  int maxRow=getItemCount() / mTotalColumnCount;
  if (getItemCount() % mTotalColumnCount != 0) {
    maxRow++;
  }
  return maxRow;
}","private int getTotalRowCount(){
  if (getItemCount() == 0 || mTotalColumnCount == 0) {
    return 0;
  }
  int maxRow=getItemCount() / mTotalColumnCount;
  if (getItemCount() % mTotalColumnCount != 0) {
    maxRow++;
  }
  return maxRow;
}"
3523,"@Override public int scrollVerticallyBy(int dy,RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getChildCount() == 0) {
    return 0;
  }
  final View topView=getChildAt(0);
  final View bottomView=getChildAt(getChildCount() - 1);
  int viewSpan=getDecoratedBottom(bottomView) - getDecoratedTop(topView);
  if (viewSpan <= getVerticalSpace()) {
    return 0;
  }
  int delta;
  int maxRowCount=getTotalRowCount();
  boolean topBoundReached=getFirstVisibleRow() == 0;
  boolean bottomBoundReached=getLastVisibleRow() >= maxRowCount;
  if (dy > 0) {
    if (bottomBoundReached) {
      int bottomOffset;
      if (rowOfIndex(getChildCount() - 1) >= (maxRowCount - 1)) {
        bottomOffset=getVerticalSpace() - getDecoratedBottom(bottomView) + getPaddingBottom();
      }
 else {
        bottomOffset=getVerticalSpace() - (getDecoratedBottom(bottomView) + mDecoratedChildHeight) + getPaddingBottom();
      }
      delta=Math.max(-dy,bottomOffset);
    }
 else {
      delta=-dy;
    }
  }
 else {
    if (topBoundReached) {
      int topOffset=-getDecoratedTop(topView) + getPaddingTop();
      delta=Math.min(-dy,topOffset);
    }
 else {
      delta=-dy;
    }
  }
  offsetChildrenVertical(delta);
  if (dy > 0) {
    if (getDecoratedBottom(topView) < 0 && !bottomBoundReached) {
      fillGrid(DIRECTION_DOWN,recycler);
    }
 else     if (!bottomBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
 else {
    if (getDecoratedTop(topView) > 0 && !topBoundReached) {
      fillGrid(DIRECTION_UP,recycler);
    }
 else     if (!topBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
  return -delta;
}","@Override public int scrollVerticallyBy(int dy,RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getChildCount() == 0) {
    return 0;
  }
  final View topView=getChildAt(0);
  final View bottomView=getChildAt(getChildCount() - 1);
  int viewSpan=getDecoratedBottom(bottomView) - getDecoratedTop(topView);
  if (viewSpan < getVerticalSpace()) {
    return 0;
  }
  int delta;
  int maxRowCount=getTotalRowCount();
  boolean topBoundReached=getFirstVisibleRow() == 0;
  boolean bottomBoundReached=getLastVisibleRow() >= maxRowCount;
  if (dy > 0) {
    if (bottomBoundReached) {
      int bottomOffset;
      if (rowOfIndex(getChildCount() - 1) >= (maxRowCount - 1)) {
        bottomOffset=getVerticalSpace() - getDecoratedBottom(bottomView) + getPaddingBottom();
      }
 else {
        bottomOffset=getVerticalSpace() - (getDecoratedBottom(bottomView) + mDecoratedChildHeight) + getPaddingBottom();
      }
      delta=Math.max(-dy,bottomOffset);
    }
 else {
      delta=-dy;
    }
  }
 else {
    if (topBoundReached) {
      int topOffset=-getDecoratedTop(topView) + getPaddingTop();
      delta=Math.min(-dy,topOffset);
    }
 else {
      delta=-dy;
    }
  }
  offsetChildrenVertical(delta);
  if (dy > 0) {
    if (getDecoratedBottom(topView) < 0 && !bottomBoundReached) {
      fillGrid(DIRECTION_DOWN,recycler);
    }
 else     if (!bottomBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
 else {
    if (getDecoratedTop(topView) > 0 && !topBoundReached) {
      fillGrid(DIRECTION_UP,recycler);
    }
 else     if (!topBoundReached) {
      fillGrid(DIRECTION_NONE,recycler);
    }
  }
  return -delta;
}"
3524,"@Override public void onLayoutChildren(RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getItemCount() == 0) {
    detachAndScrapAttachedViews(recycler);
    return;
  }
  if (getChildCount() == 0) {
    View scrap=recycler.getViewForPosition(0);
    addView(scrap);
    measureChildWithMargins(scrap,0,0);
    mDecoratedChildWidth=getDecoratedMeasuredWidth(scrap);
    mDecoratedChildHeight=getDecoratedMeasuredHeight(scrap);
    detachAndScrapView(scrap,recycler);
  }
  updateWindowSizing();
  int childLeft;
  int childTop;
  if (getChildCount() == 0) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else   if (getVisibleChildCount() > getItemCount()) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else {
    final View topChild=getChildAt(0);
    if (mForceClearOffsets) {
      childLeft=childTop=0;
      mForceClearOffsets=false;
    }
 else {
      childLeft=getDecoratedLeft(topChild);
      childTop=getDecoratedTop(topChild);
    }
    int lastVisiblePosition=positionOfIndex(getVisibleChildCount() - 1);
    if (lastVisiblePosition >= getItemCount()) {
      lastVisiblePosition=(getItemCount() - 1);
      int lastColumn=mVisibleColumnCount - 1;
      int lastRow=mVisibleRowCount - 1;
      mFirstVisiblePosition=Math.max(lastVisiblePosition - lastColumn - (lastRow * getTotalColumnCount()),0);
      childLeft=getHorizontalSpace() - (mDecoratedChildWidth * mVisibleColumnCount);
      childTop=getVerticalSpace() - (mDecoratedChildHeight * mVisibleRowCount);
      if (getFirstVisibleRow() == 0) {
        childTop=Math.min(childTop,0);
      }
      if (getFirstVisibleColumn() == 0) {
        childLeft=Math.min(childLeft,0);
      }
    }
  }
  detachAndScrapAttachedViews(recycler);
  fillGrid(DIRECTION_NONE,childLeft,childTop,recycler);
}","@Override public void onLayoutChildren(RecyclerView.Recycler recycler,RecyclerView.State state){
  if (getItemCount() == 0) {
    detachAndScrapAttachedViews(recycler);
    return;
  }
  if (getChildCount() == 0) {
    View scrap=recycler.getViewForPosition(0);
    addView(scrap);
    measureChildWithMargins(scrap,0,0);
    mDecoratedChildWidth=getDecoratedMeasuredWidth(scrap);
    mDecoratedChildHeight=getDecoratedMeasuredHeight(scrap);
    detachAndScrapView(scrap,recycler);
  }
  updateWindowSizing();
  int childLeft;
  int childTop;
  if (getChildCount() == 0) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else   if (getVisibleChildCount() > getItemCount()) {
    mFirstVisiblePosition=0;
    childLeft=childTop=0;
  }
 else {
    final View topChild=getChildAt(0);
    if (mForceClearOffsets) {
      childLeft=childTop=0;
      mForceClearOffsets=false;
    }
 else {
      childLeft=getDecoratedLeft(topChild);
      childTop=getDecoratedTop(topChild);
    }
    int maxFirstRow=getTotalRowCount() - (mVisibleRowCount - 1);
    int maxFirstCol=getTotalColumnCount() - (mVisibleColumnCount - 1);
    boolean isOutOfRowBounds=getFirstVisibleRow() > maxFirstRow;
    boolean isOutOfColBounds=getFirstVisibleColumn() > maxFirstCol;
    if (isOutOfRowBounds || isOutOfColBounds) {
      int firstRow;
      if (isOutOfRowBounds) {
        firstRow=maxFirstRow;
      }
 else {
        firstRow=getFirstVisibleRow();
      }
      int firstCol;
      if (isOutOfColBounds) {
        firstCol=maxFirstCol;
      }
 else {
        firstCol=getFirstVisibleColumn();
      }
      mFirstVisiblePosition=firstRow * getTotalColumnCount() + firstCol;
      childLeft=getHorizontalSpace() - (mDecoratedChildWidth * mVisibleColumnCount);
      childTop=getVerticalSpace() - (mDecoratedChildHeight * mVisibleRowCount);
      if (getFirstVisibleRow() == 0) {
        childTop=Math.min(childTop,0);
      }
      if (getFirstVisibleColumn() == 0) {
        childLeft=Math.min(childLeft,0);
      }
    }
  }
  detachAndScrapAttachedViews(recycler);
  fillGrid(DIRECTION_NONE,childLeft,childTop,recycler);
}"
3525,"private void writeInjectMethod(JavaWriter jw,TypeElement element,AnnotatedFragment fragment) throws IOException, ProcessingException {
  Set<ArgumentAnnotatedField> allArguments=fragment.getAll();
  String fragmentType=supportAnnotations ? ""String_Node_Str"" + element.getSimpleName().toString() : element.getSimpleName().toString();
  jw.beginMethod(""String_Node_Str"",""String_Node_Str"",EnumSet.of(Modifier.PUBLIC,Modifier.FINAL,Modifier.STATIC),fragmentType,""String_Node_Str"");
  if (!allArguments.isEmpty()) {
    jw.emitStatement(""String_Node_Str"");
    if (!fragment.getRequiredFields().isEmpty()) {
      jw.beginControlFlow(""String_Node_Str"");
      jw.emitStatement(""String_Node_Str"");
      jw.endControlFlow();
    }
  }
  int setterAssignmentHelperCounter=0;
  for (  ArgumentAnnotatedField field : allArguments) {
    jw.emitEmptyLine();
    String setterMethod=null;
    boolean useSetter=field.isUseSetterMethod();
    if (useSetter) {
      ExecutableElement setterMethodElement=fragment.findSetterForField(field);
      setterMethod=setterMethodElement.getSimpleName().toString();
    }
    if (field.hasCustomBundler()) {
      String setterAssignmentHelperStr=null;
      String assignmentStr;
      if (useSetter) {
        setterAssignmentHelperStr=field.getType() + ""String_Node_Str"" + setterAssignmentHelperCounter+ ""String_Node_Str"";
        assignmentStr=""String_Node_Str"" + setterAssignmentHelperCounter + ""String_Node_Str"";
        setterAssignmentHelperCounter++;
      }
 else {
        assignmentStr=""String_Node_Str"";
      }
      if (field.isRequired()) {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(CUSTOM_BUNDLER_BUNDLE_KEY + field.getKey()) + ""String_Node_Str"");
        jw.emitStatement(""String_Node_Str"",field.getKey());
        jw.endControlFlow();
        if (useSetter) {
          jw.emitStatement(setterAssignmentHelperStr,field.getBundlerFieldName(),field.getKey());
          jw.emitStatement(assignmentStr,setterMethod);
        }
 else {
          jw.emitStatement(assignmentStr,field.getName(),field.getBundlerFieldName(),field.getKey());
        }
      }
 else {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(CUSTOM_BUNDLER_BUNDLE_KEY + field.getKey()) + ""String_Node_Str"");
        if (useSetter) {
          jw.emitStatement(setterAssignmentHelperStr,field.getBundlerFieldName(),field.getKey());
          jw.emitStatement(assignmentStr,setterMethod);
        }
 else {
          jw.emitStatement(assignmentStr,field.getName(),field.getBundlerFieldName(),field.getKey());
        }
        jw.endControlFlow();
      }
    }
 else {
      String op=getOperation(field);
      if (op == null) {
        throw new ProcessingException(element,""String_Node_Str"" + ""String_Node_Str"",ArgsBundler.class.getSimpleName());
      }
      String cast=""String_Node_Str"".equals(op) ? ""String_Node_Str"" + field.getType() + ""String_Node_Str"" : ""String_Node_Str"";
      if (!field.isRequired()) {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(field.getKey()) + ""String_Node_Str"");
      }
 else {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(field.getKey()) + ""String_Node_Str"");
        jw.emitStatement(""String_Node_Str"",field.getKey());
        jw.endControlFlow();
      }
      if (useSetter) {
        jw.emitStatement(""String_Node_Str"",setterMethod,op,field.getKey(),cast);
      }
 else {
        jw.emitStatement(""String_Node_Str"",field.getName(),op,field.getKey(),cast);
      }
      if (!field.isRequired()) {
        jw.endControlFlow();
      }
    }
  }
  jw.endMethod();
}","private void writeInjectMethod(JavaWriter jw,TypeElement element,AnnotatedFragment fragment) throws IOException, ProcessingException {
  Set<ArgumentAnnotatedField> allArguments=fragment.getAll();
  String fragmentType=supportAnnotations ? ""String_Node_Str"" + element.getSimpleName().toString() : element.getSimpleName().toString();
  jw.beginMethod(""String_Node_Str"",""String_Node_Str"",EnumSet.of(Modifier.PUBLIC,Modifier.FINAL,Modifier.STATIC),fragmentType,""String_Node_Str"");
  if (!allArguments.isEmpty()) {
    jw.emitStatement(""String_Node_Str"");
    if (!fragment.getRequiredFields().isEmpty()) {
      jw.beginControlFlow(""String_Node_Str"");
      jw.emitStatement(""String_Node_Str"");
      jw.endControlFlow();
    }
  }
  int setterAssignmentHelperCounter=0;
  for (  ArgumentAnnotatedField field : allArguments) {
    jw.emitEmptyLine();
    String setterMethod=null;
    boolean useSetter=field.isUseSetterMethod();
    if (useSetter) {
      ExecutableElement setterMethodElement=fragment.findSetterForField(field);
      setterMethod=setterMethodElement.getSimpleName().toString();
    }
    if (field.hasCustomBundler()) {
      String setterAssignmentHelperStr=null;
      String assignmentStr;
      if (useSetter) {
        setterAssignmentHelperStr=field.getType() + ""String_Node_Str"" + setterAssignmentHelperCounter+ ""String_Node_Str"";
        assignmentStr=""String_Node_Str"" + setterAssignmentHelperCounter + ""String_Node_Str"";
        setterAssignmentHelperCounter++;
      }
 else {
        assignmentStr=""String_Node_Str"";
      }
      if (field.isRequired()) {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(CUSTOM_BUNDLER_BUNDLE_KEY + field.getKey()) + ""String_Node_Str"");
        jw.emitStatement(""String_Node_Str"",field.getKey());
        jw.endControlFlow();
        if (useSetter) {
          jw.emitStatement(setterAssignmentHelperStr,field.getBundlerFieldName(),field.getKey());
          jw.emitStatement(assignmentStr,setterMethod);
        }
 else {
          jw.emitStatement(assignmentStr,field.getName(),field.getBundlerFieldName(),field.getKey());
        }
      }
 else {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(CUSTOM_BUNDLER_BUNDLE_KEY + field.getKey()) + ""String_Node_Str"");
        if (useSetter) {
          jw.emitStatement(setterAssignmentHelperStr,field.getBundlerFieldName(),field.getKey());
          jw.emitStatement(assignmentStr,setterMethod);
        }
 else {
          jw.emitStatement(assignmentStr,field.getName(),field.getBundlerFieldName(),field.getKey());
        }
        jw.endControlFlow();
      }
    }
 else {
      String op=getOperation(field);
      if (op == null) {
        throw new ProcessingException(element,""String_Node_Str"" + ""String_Node_Str"",ArgsBundler.class.getSimpleName());
      }
      String cast=""String_Node_Str"".equals(op) ? ""String_Node_Str"" + field.getType() + ""String_Node_Str"" : ""String_Node_Str"";
      if (!field.isRequired()) {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(field.getKey()) + ""String_Node_Str"");
      }
 else {
        jw.beginControlFlow(""String_Node_Str"" + JavaWriter.stringLiteral(field.getKey()) + ""String_Node_Str"");
        jw.emitStatement(""String_Node_Str"",field.getKey());
        jw.endControlFlow();
      }
      if (useSetter) {
        jw.emitStatement(""String_Node_Str"" + setterAssignmentHelperCounter + ""String_Node_Str"",field.getType(),op,field.getKey(),cast);
        jw.emitStatement(""String_Node_Str"" + setterAssignmentHelperCounter + ""String_Node_Str"",setterMethod);
        setterAssignmentHelperCounter++;
      }
 else {
        jw.emitStatement(""String_Node_Str"",field.getName(),op,field.getKey(),cast);
      }
      if (!field.isRequired()) {
        jw.endControlFlow();
      }
    }
  }
  jw.endMethod();
}"
3526,"/** 
 * Constructor.
 * @param table The table for which to get find a primary key.
 * @throws SQLException
 */
public PrimaryKeyFinder(String table) throws SQLException {
  this.table=table;
  if (table == null || table.trim().length() == 0) {
    throw new SQLException(""String_Node_Str"" + this.table + ""String_Node_Str"");
  }
  Statement stat=null;
  ResultSet rs=null;
  try {
    stat=conn.createStatement();
    rs=stat.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + escape(table) + ""String_Node_Str"");
    if (!rs.next())     throw new SQLException(""String_Node_Str"" + table + ""String_Node_Str"");
    Matcher matcher=PK_NAMED_PATTERN.matcher(rs.getString(1));
    if (matcher.find()) {
      pkName='\'' + escape(matcher.group(1).toLowerCase()) + '\'';
      pkColumns=matcher.group(2).split(""String_Node_Str"");
    }
 else {
      matcher=PK_UNNAMED_PATTERN.matcher(rs.getString(1));
      if (matcher.find()) {
        pkColumns=matcher.group(1).split(""String_Node_Str"");
      }
    }
    if (pkColumns == null) {
      rs=stat.executeQuery(""String_Node_Str"" + escape(table) + ""String_Node_Str"");
      while (rs.next()) {
        if (rs.getBoolean(6))         pkColumns=new String[]{rs.getString(2)};
      }
    }
    if (pkColumns != null)     for (int i=0; i < pkColumns.length; i++) {
      pkColumns[i]=pkColumns[i].toLowerCase().trim();
    }
  }
  finally {
    try {
      if (rs != null)       rs.close();
    }
 catch (    Exception e) {
    }
    try {
      if (stat != null)       stat.close();
    }
 catch (    Exception e) {
    }
  }
}","/** 
 * Constructor.
 * @param table The table for which to get find a primary key.
 * @throws SQLException
 */
public PrimaryKeyFinder(String table) throws SQLException {
  this.table=table;
  if (table == null || table.trim().length() == 0) {
    throw new SQLException(""String_Node_Str"" + this.table + ""String_Node_Str"");
  }
  Statement stat=null;
  ResultSet rs=null;
  try {
    stat=conn.createStatement();
    rs=stat.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + escape(table) + ""String_Node_Str"");
    if (!rs.next())     throw new SQLException(""String_Node_Str"" + table + ""String_Node_Str"");
    Matcher matcher=PK_NAMED_PATTERN.matcher(rs.getString(1));
    if (matcher.find()) {
      pkName='\'' + escape(matcher.group(1)) + '\'';
      pkColumns=matcher.group(2).split(""String_Node_Str"");
    }
 else {
      matcher=PK_UNNAMED_PATTERN.matcher(rs.getString(1));
      if (matcher.find()) {
        pkColumns=matcher.group(1).split(""String_Node_Str"");
      }
    }
    if (pkColumns == null) {
      rs=stat.executeQuery(""String_Node_Str"" + escape(table) + ""String_Node_Str"");
      while (rs.next()) {
        if (rs.getBoolean(6))         pkColumns=new String[]{rs.getString(2)};
      }
    }
    if (pkColumns != null)     for (int i=0; i < pkColumns.length; i++) {
      pkColumns[i]=pkColumns[i].trim();
    }
  }
  finally {
    try {
      if (rs != null)       rs.close();
    }
 catch (    Exception e) {
    }
    try {
      if (stat != null)       stat.close();
    }
 catch (    Exception e) {
    }
  }
}"
3527,"@Test public void columnOrderOfgetPrimaryKeys() throws SQLException {
  ResultSet rs;
  ResultSetMetaData rsmeta;
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"" + ""String_Node_Str"");
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertFalse(rs.next());
  rsmeta=rs.getMetaData();
  assertEquals(rsmeta.getColumnCount(),6);
  assertEquals(rsmeta.getColumnName(1),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(2),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(3),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(4),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(5),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(6),""String_Node_Str"");
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getInt(""String_Node_Str""),1);
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),1);
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
}","@Test public void columnOrderOfgetPrimaryKeys() throws SQLException {
  ResultSet rs;
  ResultSetMetaData rsmeta;
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"" + ""String_Node_Str"");
  stat.executeUpdate(""String_Node_Str"");
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertFalse(rs.next());
  rsmeta=rs.getMetaData();
  assertEquals(rsmeta.getColumnCount(),6);
  assertEquals(rsmeta.getColumnName(1),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(2),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(3),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(4),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(5),""String_Node_Str"");
  assertEquals(rsmeta.getColumnName(6),""String_Node_Str"");
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getInt(""String_Node_Str""),1);
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),null);
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),1);
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
  rs=meta.getPrimaryKeys(null,null,""String_Node_Str"");
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),1);
  assertTrue(rs.next());
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getString(""String_Node_Str""),""String_Node_Str"");
  assertEquals(rs.getInt(""String_Node_Str""),0);
  assertFalse(rs.next());
  rs.close();
}"
3528,"/** 
 * Extracts and loads the specified library file to the target folder
 * @param libFolderForCurrentOS Library path.
 * @param libraryFileName       Library name.
 * @param targetFolder          Target folder.
 * @return
 */
private static boolean extractAndLoadLibraryFile(String libFolderForCurrentOS,String libraryFileName,String targetFolder){
  String nativeLibraryFilePath=libFolderForCurrentOS + ""String_Node_Str"" + libraryFileName;
  String uuid=UUID.randomUUID().toString();
  String extractedLibFileName=String.format(""String_Node_Str"",getVersion(),uuid,libraryFileName);
  String extractedLckFileName=extractedLibFileName + ""String_Node_Str"";
  File extractedLibFile=new File(targetFolder,extractedLibFileName);
  File extractedLckFile=new File(targetFolder,extractedLckFileName);
  try {
    InputStream reader=SQLiteJDBCLoader.class.getResourceAsStream(nativeLibraryFilePath);
    FileOutputStream writer=new FileOutputStream(extractedLibFile);
    try {
      byte[] buffer=new byte[8192];
      int bytesRead=0;
      while ((bytesRead=reader.read(buffer)) != -1) {
        writer.write(buffer,0,bytesRead);
      }
    }
  finally {
      if (!extractedLckFile.exists()) {
        new FileOutputStream(extractedLckFile).close();
      }
      extractedLibFile.deleteOnExit();
      extractedLckFile.deleteOnExit();
      if (writer != null) {
        writer.close();
      }
      if (reader != null) {
        reader.close();
      }
    }
    extractedLibFile.setReadable(true);
    extractedLibFile.setWritable(true,true);
    extractedLibFile.setExecutable(true);
{
      InputStream nativeIn=SQLiteJDBCLoader.class.getResourceAsStream(nativeLibraryFilePath);
      InputStream extractedLibIn=new FileInputStream(extractedLibFile);
      try {
        if (!contentsEquals(nativeIn,extractedLibIn)) {
          throw new RuntimeException(String.format(""String_Node_Str"",extractedLibFile));
        }
      }
  finally {
        if (nativeIn != null) {
          nativeIn.close();
        }
        if (extractedLibIn != null) {
          extractedLibIn.close();
        }
      }
    }
    return loadNativeLibrary(targetFolder,extractedLibFileName);
  }
 catch (  IOException e) {
    System.err.println(e.getMessage());
    return false;
  }
}","/** 
 * Extracts and loads the specified library file to the target folder
 * @param libFolderForCurrentOS Library path.
 * @param libraryFileName       Library name.
 * @param targetFolder          Target folder.
 * @return
 */
private static boolean extractAndLoadLibraryFile(String libFolderForCurrentOS,String libraryFileName,String targetFolder){
  String nativeLibraryFilePath=libFolderForCurrentOS + ""String_Node_Str"" + libraryFileName;
  String uuid=UUID.randomUUID().toString();
  String extractedLibFileName=String.format(""String_Node_Str"",getVersion(),uuid,libraryFileName);
  String extractedLckFileName=extractedLibFileName + ""String_Node_Str"";
  File extractedLibFile=new File(targetFolder,extractedLibFileName);
  File extractedLckFile=new File(targetFolder,extractedLckFileName);
  try {
    InputStream reader=SQLiteJDBCLoader.class.getResourceAsStream(nativeLibraryFilePath);
    FileOutputStream writer=new FileOutputStream(extractedLibFile);
    if (!extractedLckFile.exists()) {
      new FileOutputStream(extractedLckFile).close();
    }
    try {
      byte[] buffer=new byte[8192];
      int bytesRead=0;
      while ((bytesRead=reader.read(buffer)) != -1) {
        writer.write(buffer,0,bytesRead);
      }
    }
  finally {
      extractedLibFile.deleteOnExit();
      extractedLckFile.deleteOnExit();
      if (writer != null) {
        writer.close();
      }
      if (reader != null) {
        reader.close();
      }
    }
    extractedLibFile.setReadable(true);
    extractedLibFile.setWritable(true,true);
    extractedLibFile.setExecutable(true);
{
      InputStream nativeIn=SQLiteJDBCLoader.class.getResourceAsStream(nativeLibraryFilePath);
      InputStream extractedLibIn=new FileInputStream(extractedLibFile);
      try {
        if (!contentsEquals(nativeIn,extractedLibIn)) {
          throw new RuntimeException(String.format(""String_Node_Str"",extractedLibFile));
        }
      }
  finally {
        if (nativeIn != null) {
          nativeIn.close();
        }
        if (extractedLibIn != null) {
          extractedLibIn.close();
        }
      }
    }
    return loadNativeLibrary(targetFolder,extractedLibFileName);
  }
 catch (  IOException e) {
    System.err.println(e.getMessage());
    return false;
  }
}"
3529,"/** 
 * Deleted old native libraries e.g. on Windows the DLL file is not removed on VM-Exit (bug #80)
 */
static void cleanup(){
  String tempFolder=getTempDir().getAbsolutePath();
  File dir=new File(tempFolder);
  File[] nativeLibFiles=dir.listFiles(new FilenameFilter(){
    private final String searchPattern=""String_Node_Str"" + getVersion();
    public boolean accept(    File dir,    String name){
      return name.startsWith(searchPattern) && !name.endsWith(""String_Node_Str"");
    }
  }
);
  if (nativeLibFiles != null) {
    for (    File nativeLibFile : nativeLibFiles) {
      File lckFile=new File(nativeLibFile.getName() + ""String_Node_Str"");
      if (!lckFile.exists()) {
        try {
          nativeLibFile.delete();
        }
 catch (        SecurityException e) {
          System.err.println(""String_Node_Str"" + e.getMessage());
        }
      }
    }
  }
}","/** 
 * Deleted old native libraries e.g. on Windows the DLL file is not removed on VM-Exit (bug #80)
 */
static void cleanup(){
  String tempFolder=getTempDir().getAbsolutePath();
  File dir=new File(tempFolder);
  File[] nativeLibFiles=dir.listFiles(new FilenameFilter(){
    private final String searchPattern=""String_Node_Str"" + getVersion();
    public boolean accept(    File dir,    String name){
      return name.startsWith(searchPattern) && !name.endsWith(""String_Node_Str"");
    }
  }
);
  if (nativeLibFiles != null) {
    for (    File nativeLibFile : nativeLibFiles) {
      File lckFile=new File(nativeLibFile.getAbsolutePath() + ""String_Node_Str"");
      if (!lckFile.exists()) {
        try {
          nativeLibFile.delete();
        }
 catch (        SecurityException e) {
          System.err.println(""String_Node_Str"" + e.getMessage());
        }
      }
    }
  }
}"
3530,"public void close() throws SQLException {
  cols=null;
  colsMeta=null;
  meta=null;
  open=false;
  limitRows=0;
  row=0;
  lastCol=-1;
  columnNameToIndex=null;
  if (stmt == null) {
    return;
  }
  if (stmt != null && stmt.pointer != 0) {
    db.reset(stmt.pointer);
    if (closeStmt) {
      closeStmt=false;
      ((Statement)stmt).close();
    }
  }
}","public void close() throws SQLException {
  cols=null;
  colsMeta=null;
  meta=null;
  open=false;
  limitRows=0;
  row=0;
  lastCol=-1;
  columnNameToIndex=null;
synchronized (db) {
    if (stmt == null) {
      return;
    }
    if (stmt != null && stmt.pointer != 0) {
      db.reset(stmt.pointer);
      if (closeStmt) {
        closeStmt=false;
        ((Statement)stmt).close();
      }
    }
  }
}"
3531,"/** 
 * @param datePrecision One of SECONDS or MILLISECONDS
 * @throws SQLException 
 */
public void setDatePrecision(String datePrecision) throws SQLException {
  setPragma(Pragma.DATE_PRECISION,DatePrecision.getPrecision(datePrecision).getValue());
}","/** 
 * @param datePrecision One of SECONDS or MILLISECONDS
 * @throws SQLException 
 */
public void setDatePrecision(String datePrecision) throws SQLException {
  this.datePrecision=DatePrecision.getPrecision(datePrecision);
}"
3532,"/** 
 * Enables or disables the count-changes flag. When enabled, INSERT, UPDATE and DELETE statements return the number of rows they modified.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_count_changes"">www.sqlite.org/pragma.html#pragma_count_changes</a>
 */
public void enableCountChanges(boolean enable){
  set(Pragma.COUNT_CHANGES,enable);
}","/** 
 * @deprecated Enables or disables the count-changes flag. When enabled, INSERT, UPDATE and DELETE statements return the number of rows they modified.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_count_changes"">www.sqlite.org/pragma.html#pragma_count_changes</a>
 */
public void enableCountChanges(boolean enable){
  set(Pragma.COUNT_CHANGES,enable);
}"
3533,"/** 
 * Enables or disables the full_column_name flag. This flag together with the short_column_names flag determine the way SQLite assigns names to result columns of SELECT statements.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_full_column_names"">www.sqlite.org/pragma.html#pragma_full_column_names</a>
 */
public void enableFullColumnNames(boolean enable){
  set(Pragma.FULL_COLUMN_NAMES,enable);
}","/** 
 * @deprecated Enables or disables the full_column_name flag. This flag together with the short_column_names flag determine the way SQLite assigns names to result columns of SELECT statements.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_full_column_names"">www.sqlite.org/pragma.html#pragma_full_column_names</a>
 */
public void enableFullColumnNames(boolean enable){
  set(Pragma.FULL_COLUMN_NAMES,enable);
}"
3534,"/** 
 * Enables or disables the empty_result_callbacks flag.
 * @param enable True to enable; false to disable.false.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks"">http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks</a>
 */
public void enableEmptyResultCallBacks(boolean enable){
  set(Pragma.EMPTY_RESULT_CALLBACKS,enable);
}","/** 
 * @deprecated Enables or disables the empty_result_callbacks flag.
 * @param enable True to enable; false to disable.false.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks"">http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks</a>
 */
public void enableEmptyResultCallBacks(boolean enable){
  set(Pragma.EMPTY_RESULT_CALLBACKS,enable);
}"
3535,"/** 
 * @param dateStringFormat Format of date string
 */
public void setDateStringFormat(String dateStringFormat){
  setPragma(Pragma.DATE_STRING_FORMAT,dateStringFormat);
}","/** 
 * @param dateStringFormat Format of date string
 */
public void setDateStringFormat(String dateStringFormat){
  this.dateStringFormat=dateStringFormat;
}"
3536,"/** 
 * @param dateClass One of INTEGER, TEXT or REAL
 */
public void setDateClass(String dateClass){
  setPragma(Pragma.DATE_CLASS,DateClass.getDateClass(dateClass).getValue());
}","/** 
 * @param dateClass One of INTEGER, TEXT or REAL
 */
public void setDateClass(String dateClass){
  this.dateClass=DateClass.getDateClass(dateClass);
}"
3537,"/** 
 * @param datePrecision One of SECONDS or MILLISECONDS
 * @throws SQLException 
 */
public void setDatePrecision(String datePrecision) throws SQLException {
  setPragma(Pragma.DATE_PRECISION,DatePrecision.getPrecision(datePrecision).getValue());
}","/** 
 * @param datePrecision One of SECONDS or MILLISECONDS
 * @throws SQLException 
 */
public void setDatePrecision(String datePrecision) throws SQLException {
  this.datePrecision=DatePrecision.getPrecision(datePrecision);
}"
3538,"/** 
 * Enables or disables the count-changes flag. When enabled, INSERT, UPDATE and DELETE statements return the number of rows they modified.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_count_changes"">www.sqlite.org/pragma.html#pragma_count_changes</a>
 */
public void enableCountChanges(boolean enable){
  set(Pragma.COUNT_CHANGES,enable);
}","/** 
 * @deprecated Enables or disables the count-changes flag. When enabled, INSERT, UPDATE and DELETE statements return the number of rows they modified.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_count_changes"">www.sqlite.org/pragma.html#pragma_count_changes</a>
 */
public void enableCountChanges(boolean enable){
  set(Pragma.COUNT_CHANGES,enable);
}"
3539,"/** 
 * Enables or disables the full_column_name flag. This flag together with the short_column_names flag determine the way SQLite assigns names to result columns of SELECT statements.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_full_column_names"">www.sqlite.org/pragma.html#pragma_full_column_names</a>
 */
public void enableFullColumnNames(boolean enable){
  set(Pragma.FULL_COLUMN_NAMES,enable);
}","/** 
 * @deprecated Enables or disables the full_column_name flag. This flag together with the short_column_names flag determine the way SQLite assigns names to result columns of SELECT statements.
 * @param enable True to enable; false to disable.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_full_column_names"">www.sqlite.org/pragma.html#pragma_full_column_names</a>
 */
public void enableFullColumnNames(boolean enable){
  set(Pragma.FULL_COLUMN_NAMES,enable);
}"
3540,"/** 
 * Enables or disables the empty_result_callbacks flag.
 * @param enable True to enable; false to disable.false.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks"">http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks</a>
 */
public void enableEmptyResultCallBacks(boolean enable){
  set(Pragma.EMPTY_RESULT_CALLBACKS,enable);
}","/** 
 * @deprecated Enables or disables the empty_result_callbacks flag.
 * @param enable True to enable; false to disable.false.
 * @see <a href=""http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks"">http://www.sqlite.org/pragma.html#pragma_empty_result_callbacks</a>
 */
public void enableEmptyResultCallBacks(boolean enable){
  set(Pragma.EMPTY_RESULT_CALLBACKS,enable);
}"
3541,"/** 
 * @param dateStringFormat Format of date string
 */
public void setDateStringFormat(String dateStringFormat){
  setPragma(Pragma.DATE_STRING_FORMAT,dateStringFormat);
}","/** 
 * @param dateStringFormat Format of date string
 */
public void setDateStringFormat(String dateStringFormat){
  this.dateStringFormat=dateStringFormat;
}"
3542,"/** 
 * @param dateClass One of INTEGER, TEXT or REAL
 */
public void setDateClass(String dateClass){
  setPragma(Pragma.DATE_CLASS,DateClass.getDateClass(dateClass).getValue());
}","/** 
 * @param dateClass One of INTEGER, TEXT or REAL
 */
public void setDateClass(String dateClass){
  this.dateClass=DateClass.getDateClass(dateClass);
}"
3543,"/** 
 * @see java.sql.DatabaseMetaData#getImportedKeys(java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getImportedKeys(String catalog,String schema,String table) throws SQLException {
  String sql;
  ResultSet rs=null;
  Statement stat=conn.createStatement();
  sql=String.format(""String_Node_Str"",quote(catalog),quote(schema)) + String.format(""String_Node_Str"",quote(catalog),quote(schema),quote(table)) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Integer.toString(importedKeyInitiallyDeferred)+ ""String_Node_Str"";
  try {
    rs=stat.executeQuery(""String_Node_Str"" + escape(table) + ""String_Node_Str"");
    int i;
    for (i=0; rs.next(); i++) {
      int keySeq=rs.getInt(2) + 1;
      String PKTabName=rs.getString(3);
      String FKColName=rs.getString(4);
      String PKColName=rs.getString(5);
      String updateRule=rs.getString(6);
      String deleteRule=rs.getString(7);
      if (i > 0) {
        sql+=""String_Node_Str"";
      }
      sql+=String.format(""String_Node_Str"",keySeq) + String.format(""String_Node_Str"",escape(PKTabName),escape(FKColName),escape(PKColName)) + String.format(""String_Node_Str"",escape(updateRule))+ String.format(""String_Node_Str"",importedKeyNoAction)+ String.format(""String_Node_Str"",importedKeyCascade)+ String.format(""String_Node_Str"",importedKeyRestrict)+ String.format(""String_Node_Str"",importedKeySetNull)+ String.format(""String_Node_Str"",importedKeySetDefault)+ ""String_Node_Str""+ String.format(""String_Node_Str"",escape(deleteRule))+ String.format(""String_Node_Str"",importedKeyNoAction)+ String.format(""String_Node_Str"",importedKeyCascade)+ String.format(""String_Node_Str"",importedKeyRestrict)+ String.format(""String_Node_Str"",importedKeySetNull)+ String.format(""String_Node_Str"",importedKeySetDefault)+ ""String_Node_Str"";
    }
    sql+=""String_Node_Str"";
    rs.close();
  }
 catch (  SQLException e) {
    sql+=""String_Node_Str"" + importedKeyNoAction + ""String_Node_Str""+ importedKeyNoAction+ ""String_Node_Str"";
  }
  return stat.executeQuery(sql);
}","/** 
 * @see java.sql.DatabaseMetaData#getImportedKeys(java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getImportedKeys(String catalog,String schema,String table) throws SQLException {
  String sql;
  ResultSet rs=null;
  Statement stat=conn.createStatement();
  sql=String.format(""String_Node_Str"",quote(catalog),quote(schema)) + String.format(""String_Node_Str"",quote(catalog),quote(schema),quote(table)) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Integer.toString(importedKeyInitiallyDeferred)+ ""String_Node_Str"";
  try {
    rs=stat.executeQuery(""String_Node_Str"" + escape(table) + ""String_Node_Str"");
    int i;
    for (i=0; rs.next(); i++) {
      int keySeq=rs.getInt(2) + 1;
      String PKTabName=rs.getString(3);
      String FKColName=rs.getString(4);
      String PKColName=rs.getString(5);
      String updateRule=rs.getString(6);
      String deleteRule=rs.getString(7);
      if (i > 0) {
        sql+=""String_Node_Str"";
      }
      sql+=String.format(""String_Node_Str"",keySeq) + String.format(""String_Node_Str"",escape(PKTabName),escape(FKColName),escape(PKColName)) + String.format(""String_Node_Str"",escape(updateRule))+ String.format(""String_Node_Str"",importedKeyNoAction)+ String.format(""String_Node_Str"",importedKeyCascade)+ String.format(""String_Node_Str"",importedKeyRestrict)+ String.format(""String_Node_Str"",importedKeySetNull)+ String.format(""String_Node_Str"",importedKeySetDefault)+ ""String_Node_Str""+ String.format(""String_Node_Str"",escape(deleteRule))+ String.format(""String_Node_Str"",importedKeyNoAction)+ String.format(""String_Node_Str"",importedKeyCascade)+ String.format(""String_Node_Str"",importedKeyRestrict)+ String.format(""String_Node_Str"",importedKeySetNull)+ String.format(""String_Node_Str"",importedKeySetDefault)+ ""String_Node_Str"";
    }
    sql+=""String_Node_Str"";
    rs.close();
  }
 catch (  SQLException e) {
    sql+=""String_Node_Str"" + importedKeyNoAction + ""String_Node_Str""+ importedKeyNoAction+ ""String_Node_Str"";
  }
  return ((Stmt)stat).executeQuery(sql,true);
}"
3544,"/** 
 * @see java.sql.DatabaseMetaData#getCrossReference(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getCrossReference(String pc,String ps,String pt,String fc,String fs,String ft) throws SQLException {
  if (pt == null) {
    return getExportedKeys(fc,fs,ft);
  }
  if (ft == null) {
    return getImportedKeys(pc,ps,pt);
  }
  StringBuilder query=new StringBuilder();
  query.append(String.format(""String_Node_Str"",quote(pc),quote(ps),quote(pt)) + ""String_Node_Str"" + String.format(""String_Node_Str"",quote(fc),quote(fs),quote(ft))+ ""String_Node_Str""+ ""String_Node_Str""+ Integer.toString(importedKeyInitiallyDeferred)+ ""String_Node_Str"");
  return conn.createStatement().executeQuery(query.toString());
}","/** 
 * @see java.sql.DatabaseMetaData#getCrossReference(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getCrossReference(String pc,String ps,String pt,String fc,String fs,String ft) throws SQLException {
  if (pt == null) {
    return getExportedKeys(fc,fs,ft);
  }
  if (ft == null) {
    return getImportedKeys(pc,ps,pt);
  }
  StringBuilder query=new StringBuilder();
  query.append(String.format(""String_Node_Str"",quote(pc),quote(ps),quote(pt)) + ""String_Node_Str"" + String.format(""String_Node_Str"",quote(fc),quote(fs),quote(ft))+ ""String_Node_Str""+ ""String_Node_Str""+ Integer.toString(importedKeyInitiallyDeferred)+ ""String_Node_Str"");
  return ((Stmt)conn.createStatement()).executeQuery(query.toString(),true);
}"
3545,"/** 
 * @see java.sql.DatabaseMetaData#getIndexInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean)
 */
public ResultSet getIndexInfo(String c,String s,String t,boolean u,boolean approximate) throws SQLException {
  String sql;
  ResultSet rs=null;
  Statement stat=conn.createStatement();
  sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + escape(t) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Integer.toString(tableIndexOther)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  try {
    ArrayList<ArrayList<Object>> indexList=new ArrayList<ArrayList<Object>>();
    rs=stat.executeQuery(""String_Node_Str"" + escape(t) + ""String_Node_Str"");
    while (rs.next()) {
      indexList.add(new ArrayList<Object>());
      indexList.get(indexList.size() - 1).add(rs.getString(2));
      indexList.get(indexList.size() - 1).add(rs.getInt(3));
    }
    rs.close();
    int i=0;
    Iterator<ArrayList<Object>> indexIterator=indexList.iterator();
    ArrayList<Object> currentIndex;
    while (indexIterator.hasNext()) {
      currentIndex=indexIterator.next();
      String indexName=currentIndex.get(0).toString();
      int unique=(Integer)currentIndex.get(1);
      rs=stat.executeQuery(""String_Node_Str"" + escape(indexName) + ""String_Node_Str"");
      for (; rs.next(); i++) {
        int ordinalPosition=rs.getInt(1) + 1;
        String colName=rs.getString(3);
        if (i > 0) {
          sql+=""String_Node_Str"";
        }
        sql+=""String_Node_Str"" + Integer.toString(1 - unique) + ""String_Node_Str""+ ""String_Node_Str""+ escape(indexName)+ ""String_Node_Str""+ Integer.toString(ordinalPosition)+ ""String_Node_Str""+ ""String_Node_Str""+ escape(colName)+ ""String_Node_Str"";
        i++;
      }
      rs.close();
    }
    sql+=""String_Node_Str"";
  }
 catch (  SQLException e) {
    sql+=""String_Node_Str"";
  }
  return stat.executeQuery(sql);
}","/** 
 * @see java.sql.DatabaseMetaData#getIndexInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean)
 */
public ResultSet getIndexInfo(String c,String s,String t,boolean u,boolean approximate) throws SQLException {
  String sql;
  ResultSet rs=null;
  Statement stat=conn.createStatement();
  sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + escape(t) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Integer.toString(tableIndexOther)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  try {
    ArrayList<ArrayList<Object>> indexList=new ArrayList<ArrayList<Object>>();
    rs=stat.executeQuery(""String_Node_Str"" + escape(t) + ""String_Node_Str"");
    while (rs.next()) {
      indexList.add(new ArrayList<Object>());
      indexList.get(indexList.size() - 1).add(rs.getString(2));
      indexList.get(indexList.size() - 1).add(rs.getInt(3));
    }
    rs.close();
    int i=0;
    Iterator<ArrayList<Object>> indexIterator=indexList.iterator();
    ArrayList<Object> currentIndex;
    while (indexIterator.hasNext()) {
      currentIndex=indexIterator.next();
      String indexName=currentIndex.get(0).toString();
      int unique=(Integer)currentIndex.get(1);
      rs=stat.executeQuery(""String_Node_Str"" + escape(indexName) + ""String_Node_Str"");
      for (; rs.next(); i++) {
        int ordinalPosition=rs.getInt(1) + 1;
        String colName=rs.getString(3);
        if (i > 0) {
          sql+=""String_Node_Str"";
        }
        sql+=""String_Node_Str"" + Integer.toString(1 - unique) + ""String_Node_Str""+ ""String_Node_Str""+ escape(indexName)+ ""String_Node_Str""+ Integer.toString(ordinalPosition)+ ""String_Node_Str""+ ""String_Node_Str""+ escape(colName)+ ""String_Node_Str"";
        i++;
      }
      rs.close();
    }
    sql+=""String_Node_Str"";
  }
 catch (  SQLException e) {
    sql+=""String_Node_Str"";
  }
  return ((Stmt)stat).executeQuery(sql,true);
}"
3546,"/** 
 * Constructor.
 * @param table The table for which to get find a primary key.
 * @throws SQLException
 */
public PrimaryKeyFinder(String table) throws SQLException {
  this.table=table;
  if (table == null || table.trim().length() == 0) {
    throw new SQLException(""String_Node_Str"" + this.table + ""String_Node_Str"");
  }
  Statement stat=null;
  ResultSet rs=null;
  try {
    stat=conn.createStatement();
    rs=stat.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + escape(table) + ""String_Node_Str"");
    if (!rs.next())     throw new SQLException(""String_Node_Str"" + table + ""String_Node_Str"");
    Matcher matcher=PK_NAMED_PATTERN.matcher(rs.getString(1));
    if (matcher.find()) {
      pkName='\'' + escape(matcher.group(1).toLowerCase()) + '\'';
      pkColumns=matcher.group(2).split(""String_Node_Str"");
    }
 else {
      matcher=PK_UNNAMED_PATTERN.matcher(rs.getString(1));
      if (matcher.find()) {
        pkColumns=matcher.group(1).split(""String_Node_Str"");
      }
    }
    if (pkColumns == null) {
      rs=stat.executeQuery(""String_Node_Str"" + escape(table) + ""String_Node_Str"");
      while (rs.next()) {
        if (rs.getBoolean(6))         pkColumns=new String[]{rs.getString(2)};
      }
    }
    if (pkColumns != null)     for (int i=0; i < pkColumns.length; i++) {
      pkColumns[i]=pkColumns[i].toLowerCase().trim();
    }
  }
  finally {
    try {
      if (rs != null)       rs.close();
    }
 catch (    Exception e1) {
    }
    try {
      if (stat != null)       stat.close();
    }
 catch (    Exception e1) {
    }
  }
}","/** 
 * Constructor.
 * @param table The table for which to get find a primary key.
 * @throws SQLException
 */
public PrimaryKeyFinder(String table) throws SQLException {
  this.table=table;
  if (table == null || table.trim().length() == 0) {
    throw new SQLException(""String_Node_Str"" + this.table + ""String_Node_Str"");
  }
  Statement stat=null;
  ResultSet rs=null;
  try {
    stat=conn.createStatement();
    rs=stat.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + escape(table) + ""String_Node_Str"");
    if (!rs.next())     throw new SQLException(""String_Node_Str"" + table + ""String_Node_Str"");
    Matcher matcher=PK_NAMED_PATTERN.matcher(rs.getString(1));
    if (matcher.find()) {
      pkName='\'' + escape(matcher.group(1).toLowerCase()) + '\'';
      pkColumns=matcher.group(2).split(""String_Node_Str"");
    }
 else {
      matcher=PK_UNNAMED_PATTERN.matcher(rs.getString(1));
      if (matcher.find()) {
        pkColumns=matcher.group(1).split(""String_Node_Str"");
      }
    }
    if (pkColumns == null) {
      rs=stat.executeQuery(""String_Node_Str"" + escape(table) + ""String_Node_Str"");
      while (rs.next()) {
        if (rs.getBoolean(6))         pkColumns=new String[]{rs.getString(2)};
      }
    }
    if (pkColumns != null)     for (int i=0; i < pkColumns.length; i++) {
      pkColumns[i]=pkColumns[i].toLowerCase().trim();
    }
  }
  finally {
    try {
      if (rs != null)       rs.close();
    }
 catch (    Exception e) {
    }
    try {
      if (stat != null)       stat.close();
    }
 catch (    Exception e) {
    }
  }
}"
3547,"/** 
 * @see java.sql.DatabaseMetaData#getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
 */
public synchronized ResultSet getTables(String c,String s,String t,String[] types) throws SQLException {
  checkOpen();
  t=(t == null || ""String_Node_Str"".equals(t)) ? ""String_Node_Str"" : t.toUpperCase();
  String sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + escape(t) + ""String_Node_Str"";
  if (types != null) {
    sql+=""String_Node_Str"";
    for (int i=0; i < types.length; i++) {
      if (i > 0) {
        sql+=""String_Node_Str"";
      }
      sql+=""String_Node_Str"" + types[i].toUpperCase() + ""String_Node_Str"";
    }
    sql+=""String_Node_Str"";
  }
  sql+=""String_Node_Str"";
  return conn.createStatement().executeQuery(sql);
}","/** 
 * @see java.sql.DatabaseMetaData#getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String[])
 */
public synchronized ResultSet getTables(String c,String s,String tblNamePattern,String types[]) throws SQLException {
  checkOpen();
  tblNamePattern=(tblNamePattern == null || ""String_Node_Str"".equals(tblNamePattern)) ? ""String_Node_Str"" : escape(tblNamePattern);
  StringBuilder sql=new StringBuilder();
  sql.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(tblNamePattern).append(""String_Node_Str"");
  if (types == null) {
    sql.append(""String_Node_Str"");
  }
 else {
    sql.append(""String_Node_Str"").append(types[0].toUpperCase()).append(""String_Node_Str"");
    for (int i=1; i < types.length; i++) {
      sql.append(""String_Node_Str"").append(types[i].toUpperCase()).append(""String_Node_Str"");
    }
  }
  sql.append(""String_Node_Str"");
  return ((Stmt)conn.createStatement()).executeQuery(sql.toString(),true);
}"
3548,"/** 
 * @see java.sql.DatabaseMetaData#getPrimaryKeys(java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getPrimaryKeys(String c,String s,String table) throws SQLException {
  PrimaryKeyFinder pkFinder=new PrimaryKeyFinder(table);
  String[] columns=pkFinder.getColumns();
  Statement stat=conn.createStatement();
  StringBuilder sql=new StringBuilder(512);
  sql.append(""String_Node_Str"").append(escape(table)).append(""String_Node_Str"");
  if (columns == null) {
    sql.append(""String_Node_Str"");
    return stat.executeQuery(sql.toString());
  }
  String pkName=pkFinder.getName();
  for (int i=0; i < columns.length; i++) {
    if (i > 0)     sql.append(""String_Node_Str"");
    sql.append(""String_Node_Str"").append(pkName).append(""String_Node_Str"").append(escape(columns[i].trim())).append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  return stat.executeQuery(sql.append(""String_Node_Str"").toString());
}","/** 
 * @see java.sql.DatabaseMetaData#getPrimaryKeys(java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getPrimaryKeys(String c,String s,String table) throws SQLException {
  PrimaryKeyFinder pkFinder=new PrimaryKeyFinder(table);
  String[] columns=pkFinder.getColumns();
  Statement stat=conn.createStatement();
  StringBuilder sql=new StringBuilder(512);
  sql.append(""String_Node_Str"").append(escape(table)).append(""String_Node_Str"");
  if (columns == null) {
    sql.append(""String_Node_Str"");
    return ((Stmt)stat).executeQuery(sql.toString(),true);
  }
  String pkName=pkFinder.getName();
  for (int i=0; i < columns.length; i++) {
    if (i > 0)     sql.append(""String_Node_Str"");
    sql.append(""String_Node_Str"").append(pkName).append(""String_Node_Str"").append(escape(columns[i].trim())).append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  return ((Stmt)stat).executeQuery(sql.append(""String_Node_Str"").toString(),true);
}"
3549,"/** 
 * @see java.sql.DatabaseMetaData#getExportedKeys(java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getExportedKeys(String catalog,String schema,String table) throws SQLException {
  PrimaryKeyFinder pkFinder=new PrimaryKeyFinder(table);
  String[] pkColumns=pkFinder.getColumns();
  Stmt stat=(Stmt)conn.createStatement();
  catalog=(catalog != null) ? quote(catalog) : null;
  schema=(schema != null) ? quote(schema) : null;
  StringBuilder exportedKeysQuery=new StringBuilder(512);
  int count=0;
  if (pkColumns != null) {
    ResultSet rs=stat.executeQuery(""String_Node_Str"");
    ArrayList<String> tableList=new ArrayList<String>();
    while (rs.next()) {
      tableList.add(rs.getString(1));
    }
    rs.close();
    ResultSet fk=null;
    String target=table.toLowerCase();
    for (    String tbl : tableList) {
      try {
        fk=stat.executeQuery(""String_Node_Str"" + escape(tbl) + ""String_Node_Str"");
      }
 catch (      SQLException e) {
        if (e.getErrorCode() == Codes.SQLITE_DONE)         continue;
        throw e;
      }
      Stmt stat2=null;
      try {
        stat2=(Stmt)conn.createStatement();
        while (fk.next()) {
          int keySeq=fk.getInt(2) + 1;
          String PKTabName=fk.getString(3).toLowerCase();
          if (PKTabName == null || !PKTabName.equals(target)) {
            continue;
          }
          String PKColName=fk.getString(5);
          PKColName=(PKColName == null) ? pkColumns[0] : PKColName.toLowerCase();
          exportedKeysQuery.append(count > 0 ? ""String_Node_Str"" : ""String_Node_Str"").append(Integer.toString(keySeq)).append(""String_Node_Str"").append(escape(tbl)).append(""String_Node_Str"").append(escape(fk.getString(4))).append(""String_Node_Str"").append(escape(PKColName)).append(""String_Node_Str"").append(RULE_MAP.get(fk.getString(6))).append(""String_Node_Str"").append(RULE_MAP.get(fk.getString(7))).append(""String_Node_Str"");
          String fkName=""String_Node_Str"";
          rs=stat2.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + escape(tbl) + ""String_Node_Str"");
          if (rs.next()) {
            Matcher matcher=FK_NAMED_PATTERN.matcher(rs.getString(1));
            if (matcher.find()) {
              fkName='\'' + escape(matcher.group(1).toLowerCase()) + '\'';
            }
          }
          rs.close();
          exportedKeysQuery.append(fkName).append(""String_Node_Str"");
          count++;
        }
      }
  finally {
        try {
          if (rs != null)           rs.close();
        }
 catch (        SQLException e) {
        }
        try {
          if (stat2 != null)           stat2.close();
        }
 catch (        SQLException e) {
        }
        try {
          if (fk != null)           fk.close();
        }
 catch (        SQLException e) {
        }
      }
    }
  }
  boolean exist=(count > 0);
  StringBuilder sql=new StringBuilder(512);
  sql.append(""String_Node_Str"").append(catalog).append(""String_Node_Str"").append(schema).append(""String_Node_Str"").append(quote(table)).append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(catalog).append(""String_Node_Str"").append(schema).append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(pkFinder.getName() != null ? pkFinder.getName() : ""String_Node_Str"").append(""String_Node_Str"").append(Integer.toString(importedKeyInitiallyDeferred)).append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"");
  if (exist)   sql.append(exportedKeysQuery).append(""String_Node_Str"");
  return stat.executeQuery(sql.toString());
}","/** 
 * @see java.sql.DatabaseMetaData#getExportedKeys(java.lang.String,java.lang.String,java.lang.String)
 */
public ResultSet getExportedKeys(String catalog,String schema,String table) throws SQLException {
  PrimaryKeyFinder pkFinder=new PrimaryKeyFinder(table);
  String[] pkColumns=pkFinder.getColumns();
  Stmt stat=(Stmt)conn.createStatement();
  catalog=(catalog != null) ? quote(catalog) : null;
  schema=(schema != null) ? quote(schema) : null;
  StringBuilder exportedKeysQuery=new StringBuilder(512);
  int count=0;
  if (pkColumns != null) {
    ResultSet rs=stat.executeQuery(""String_Node_Str"");
    ArrayList<String> tableList=new ArrayList<String>();
    while (rs.next()) {
      tableList.add(rs.getString(1));
    }
    rs.close();
    ResultSet fk=null;
    String target=table.toLowerCase();
    for (    String tbl : tableList) {
      try {
        fk=stat.executeQuery(""String_Node_Str"" + escape(tbl) + ""String_Node_Str"");
      }
 catch (      SQLException e) {
        if (e.getErrorCode() == Codes.SQLITE_DONE)         continue;
        throw e;
      }
      Stmt stat2=null;
      try {
        stat2=(Stmt)conn.createStatement();
        while (fk.next()) {
          int keySeq=fk.getInt(2) + 1;
          String PKTabName=fk.getString(3).toLowerCase();
          if (PKTabName == null || !PKTabName.equals(target)) {
            continue;
          }
          String PKColName=fk.getString(5);
          PKColName=(PKColName == null) ? pkColumns[0] : PKColName.toLowerCase();
          exportedKeysQuery.append(count > 0 ? ""String_Node_Str"" : ""String_Node_Str"").append(Integer.toString(keySeq)).append(""String_Node_Str"").append(escape(tbl)).append(""String_Node_Str"").append(escape(fk.getString(4))).append(""String_Node_Str"").append(escape(PKColName)).append(""String_Node_Str"").append(RULE_MAP.get(fk.getString(6))).append(""String_Node_Str"").append(RULE_MAP.get(fk.getString(7))).append(""String_Node_Str"");
          String fkName=""String_Node_Str"";
          rs=stat2.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + escape(tbl) + ""String_Node_Str"");
          if (rs.next()) {
            Matcher matcher=FK_NAMED_PATTERN.matcher(rs.getString(1));
            if (matcher.find()) {
              fkName='\'' + escape(matcher.group(1).toLowerCase()) + '\'';
            }
          }
          rs.close();
          exportedKeysQuery.append(fkName).append(""String_Node_Str"");
          count++;
        }
      }
  finally {
        try {
          if (rs != null)           rs.close();
        }
 catch (        SQLException e) {
        }
        try {
          if (stat2 != null)           stat2.close();
        }
 catch (        SQLException e) {
        }
        try {
          if (fk != null)           fk.close();
        }
 catch (        SQLException e) {
        }
      }
    }
  }
  boolean exist=(count > 0);
  StringBuilder sql=new StringBuilder(512);
  sql.append(""String_Node_Str"").append(catalog).append(""String_Node_Str"").append(schema).append(""String_Node_Str"").append(quote(table)).append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(catalog).append(""String_Node_Str"").append(schema).append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(pkFinder.getName() != null ? pkFinder.getName() : ""String_Node_Str"").append(""String_Node_Str"").append(Integer.toString(importedKeyInitiallyDeferred)).append(""String_Node_Str"").append(exist ? ""String_Node_Str"" : ""String_Node_Str"");
  if (exist)   sql.append(exportedKeysQuery).append(""String_Node_Str"");
  return ((Stmt)stat).executeQuery(sql.toString(),true);
}"
3550,"/** 
 * Default constructor for a given statement.
 * @param stmt The statement.
 */
RS(Stmt stmt){
  this.stmt=stmt;
  this.db=stmt.db;
}","/** 
 * Default constructor for a given statement.
 * @param stmt The statement.
 * @param closeStmt TODO
 */
RS(Stmt stmt){
  this.stmt=stmt;
  this.db=stmt.db;
}"
3551,"/** 
 * @see java.sql.ResultSet#close()
 */
public void close() throws SQLException {
  cols=null;
  colsMeta=null;
  meta=null;
  open=false;
  limitRows=0;
  row=0;
  lastCol=-1;
  if (stmt == null) {
    return;
  }
  if (stmt != null && stmt.pointer != 0) {
    db.reset(stmt.pointer);
  }
}","/** 
 * @see java.sql.ResultSet#close()
 */
public void close() throws SQLException {
  cols=null;
  colsMeta=null;
  meta=null;
  open=false;
  limitRows=0;
  row=0;
  lastCol=-1;
  if (stmt == null) {
    return;
  }
  if (stmt != null && stmt.pointer != 0) {
    db.reset(stmt.pointer);
    if (closeStmt) {
      closeStmt=false;
      stmt.close();
    }
  }
}"
3552,"/** 
 * @see org.sqlite.DB#interrupt()
 */
@Override native synchronized void interrupt();","/** 
 * @see org.sqlite.DB#interrupt()
 */
@Override native void interrupt();"
3553,"private void Encoding(String typeName){
  this.typeName=typeName;
}","private void Encoding(Encoding encoding){
  this.typeName=encoding.getValue();
}"
3554,"public void setEncoding(String encoding){
  config.setEncoding(Encoding.valueOf(encoding));
}","public void setEncoding(String encoding){
  config.setEncoding(Encoding.getEncoding(encoding));
}"
3555,"public ResultSet getColumns(String c,String s,String tbl,String colPat) throws SQLException {
  Statement stat=conn.createStatement();
  ResultSet rs;
  String sql;
  checkOpen();
  if (getColumnsTblName == null)   getColumnsTblName=conn.prepareStatement(""String_Node_Str"");
  getColumnsTblName.setString(1,tbl);
  rs=getColumnsTblName.executeQuery();
  if (!rs.next())   return rs;
  tbl=rs.getString(1);
  rs.close();
  sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + escape(tbl) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  rs=stat.executeQuery(""String_Node_Str"" + escape(tbl) + ""String_Node_Str"");
  boolean colFound=false;
  for (int i=0; rs.next(); i++) {
    String colName=rs.getString(2);
    String colType=rs.getString(3);
    String colNotNull=rs.getString(4);
    int colNullable=2;
    if (colNotNull != null)     colNullable=colNotNull.equals(""String_Node_Str"") ? 1 : 0;
    if (colFound)     sql+=""String_Node_Str"";
    colFound=true;
    colType=colType == null ? ""String_Node_Str"" : colType.toUpperCase();
    int colJavaType=-1;
    if (colType.equals(""String_Node_Str"") || colType.equals(""String_Node_Str""))     colJavaType=Types.INTEGER;
 else     if (colType.equals(""String_Node_Str""))     colJavaType=Types.VARCHAR;
 else     if (colType.equals(""String_Node_Str""))     colJavaType=Types.FLOAT;
 else     colJavaType=Types.VARCHAR;
    sql+=""String_Node_Str"" + i + ""String_Node_Str""+ colNullable+ ""String_Node_Str""+ colJavaType+ ""String_Node_Str""+ escape(colName)+ ""String_Node_Str""+ escape(colType)+ ""String_Node_Str"";
    if (colPat != null)     sql+=""String_Node_Str"" + escape(colPat) + ""String_Node_Str"";
  }
  sql+=colFound ? ""String_Node_Str"" : ""String_Node_Str"" + ""String_Node_Str"";
  rs.close();
  return stat.executeQuery(sql);
}","public ResultSet getColumns(String c,String s,String tbl,String colPat) throws SQLException {
  Statement stat=conn.createStatement();
  ResultSet rs;
  String sql;
  checkOpen();
  if (getColumnsTblName == null)   getColumnsTblName=conn.prepareStatement(""String_Node_Str"");
  getColumnsTblName.setString(1,tbl);
  rs=getColumnsTblName.executeQuery();
  if (!rs.next())   return rs;
  tbl=rs.getString(1);
  rs.close();
  sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + escape(tbl) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  rs=stat.executeQuery(""String_Node_Str"" + escape(tbl) + ""String_Node_Str"");
  boolean colFound=false;
  for (int i=0; rs.next(); i++) {
    String colName=rs.getString(2);
    String colType=rs.getString(3);
    String colNotNull=rs.getString(4);
    int colNullable=2;
    if (colNotNull != null)     colNullable=colNotNull.equals(""String_Node_Str"") ? 1 : 0;
    if (colFound)     sql+=""String_Node_Str"";
    colFound=true;
    colType=colType == null ? ""String_Node_Str"" : colType.toUpperCase();
    int colJavaType=-1;
    if (colType.matches(""String_Node_Str""))     colJavaType=Types.INTEGER;
 else     if (colType.matches(""String_Node_Str""))     colJavaType=Types.VARCHAR;
 else     if (colType.matches(""String_Node_Str""))     colJavaType=Types.FLOAT;
 else     colJavaType=Types.VARCHAR;
    sql+=""String_Node_Str"" + i + ""String_Node_Str""+ colNullable+ ""String_Node_Str""+ colJavaType+ ""String_Node_Str""+ escape(colName)+ ""String_Node_Str""+ escape(colType)+ ""String_Node_Str"";
    if (colPat != null)     sql+=""String_Node_Str"" + escape(colPat) + ""String_Node_Str"";
  }
  sql+=colFound ? ""String_Node_Str"" : ""String_Node_Str"" + ""String_Node_Str"";
  rs.close();
  return stat.executeQuery(sql);
}"
3556,"public boolean next() throws SQLException {
  if (!open)   return false;
  lastCol=-1;
  if (row == 0) {
    row++;
    return true;
  }
  if (maxRows != 0 && row > maxRows)   return false;
  if (limitRows != 0 && row >= limitRows)   return false;
  int statusCode=db.step(stmt.pointer);
switch (statusCode) {
case SQLITE_DONE:
    close();
  return false;
case SQLITE_ROW:
row++;
return true;
case SQLITE_BUSY:
default :
db.throwex(statusCode);
return false;
}
}","public boolean next() throws SQLException {
  if (!open)   return false;
  lastCol=-1;
  if (row == 0) {
    row++;
    return true;
  }
  if (maxRows != 0 && row > maxRows)   return false;
  int statusCode=db.step(stmt.pointer);
switch (statusCode) {
case SQLITE_DONE:
    close();
  return false;
case SQLITE_ROW:
row++;
return true;
case SQLITE_BUSY:
default :
db.throwex(statusCode);
return false;
}
}"
3557,"protected void finalize() throws SQLException {
  close();
}","@Override protected void finalize() throws SQLException {
  close();
}"
3558,"@Before public void setUp() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  connection=null;
  Class.forName(""String_Node_Str"");
  connection=DriverManager.getConnection(""String_Node_Str"");
}","@Before public void setUp() throws Exception {
  isPureJava=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  connection=null;
  Class.forName(""String_Node_Str"");
  connection=DriverManager.getConnection(""String_Node_Str"");
}"
3559,"@After public void tearDown() throws Exception {
  if (connection != null)   connection.close();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}","@After public void tearDown() throws Exception {
  if (connection != null)   connection.close();
  System.setProperty(""String_Node_Str"",isPureJava);
}"
3560,"@SuppressWarnings(""String_Node_Str"") private T parseResponse(GaePendingResult<T,R> request,HTTPResponse response) throws IOException, ApiException, InterruptedException {
  if (shouldRetry(response)) {
    return request.retry();
  }
  byte[] bytes=response.getContent();
  R resp;
  String contentType=null;
  for (  HTTPHeader header : response.getHeaders()) {
    if (header.getName().equalsIgnoreCase(""String_Node_Str"")) {
      contentType=header.getValue();
    }
  }
  if (contentType != null && contentType.startsWith(""String_Node_Str"") && responseClass == PhotoRequest.Response.class && response.getResponseCode() == 200) {
    PhotoResult result=new PhotoResult();
    result.contentType=contentType;
    result.imageData=bytes;
    return (T)result;
  }
  Gson gson=new GsonBuilder().registerTypeAdapter(DateTime.class,new DateTimeAdapter()).registerTypeAdapter(Distance.class,new DistanceAdapter()).registerTypeAdapter(Duration.class,new DurationAdapter()).registerTypeAdapter(Fare.class,new FareAdapter()).registerTypeAdapter(LatLng.class,new LatLngAdapter()).registerTypeAdapter(AddressComponentType.class,new SafeEnumAdapter<AddressComponentType>(AddressComponentType.UNKNOWN)).registerTypeAdapter(AddressType.class,new SafeEnumAdapter<AddressType>(AddressType.UNKNOWN)).registerTypeAdapter(TravelMode.class,new SafeEnumAdapter<TravelMode>(TravelMode.UNKNOWN)).registerTypeAdapter(LocationType.class,new SafeEnumAdapter<LocationType>(LocationType.UNKNOWN)).registerTypeAdapter(RatingType.class,new SafeEnumAdapter<RatingType>(RatingType.UNKNOWN)).registerTypeAdapter(DayOfWeek.class,new DayOfWeekAdaptor()).registerTypeAdapter(PriceLevel.class,new PriceLevelAdaptor()).registerTypeAdapter(Instant.class,new InstantAdapter()).registerTypeAdapter(LocalTime.class,new LocalTimeAdapter()).registerTypeAdapter(GeolocationApi.Response.class,new GeolocationResponseAdapter()).setFieldNamingPolicy(fieldNamingPolicy).create();
  try {
    resp=gson.fromJson(new String(bytes,""String_Node_Str""),responseClass);
  }
 catch (  JsonSyntaxException e) {
    if (response.getResponseCode() > 399) {
      throw new IOException(String.format(""String_Node_Str"",response.getResponseCode(),new String(response.getContent(),Charset.defaultCharset())));
    }
    throw e;
  }
  if (resp.successful()) {
    return resp.getResult();
  }
 else {
    ApiException e=resp.getError();
    if (shouldRetry(e)) {
      return request.retry();
    }
 else {
      throw e;
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private T parseResponse(GaePendingResult<T,R> request,HTTPResponse response) throws IOException, ApiException, InterruptedException {
  if (shouldRetry(response)) {
    return request.retry();
  }
  byte[] bytes=response.getContent();
  R resp;
  String contentType=null;
  for (  HTTPHeader header : response.getHeaders()) {
    if (header.getName().equalsIgnoreCase(""String_Node_Str"")) {
      contentType=header.getValue();
    }
  }
  if (contentType != null && contentType.startsWith(""String_Node_Str"") && responseClass == PhotoRequest.Response.class && response.getResponseCode() == 200) {
    PhotoResult result=new PhotoResult();
    result.contentType=contentType;
    result.imageData=bytes;
    return (T)result;
  }
  Gson gson=new GsonBuilder().registerTypeAdapter(DateTime.class,new DateTimeAdapter()).registerTypeAdapter(Distance.class,new DistanceAdapter()).registerTypeAdapter(Duration.class,new DurationAdapter()).registerTypeAdapter(Fare.class,new FareAdapter()).registerTypeAdapter(LatLng.class,new LatLngAdapter()).registerTypeAdapter(AddressComponentType.class,new SafeEnumAdapter<AddressComponentType>(AddressComponentType.UNKNOWN)).registerTypeAdapter(AddressType.class,new SafeEnumAdapter<AddressType>(AddressType.UNKNOWN)).registerTypeAdapter(TravelMode.class,new SafeEnumAdapter<TravelMode>(TravelMode.UNKNOWN)).registerTypeAdapter(LocationType.class,new SafeEnumAdapter<LocationType>(LocationType.UNKNOWN)).registerTypeAdapter(RatingType.class,new SafeEnumAdapter<RatingType>(RatingType.UNKNOWN)).registerTypeAdapter(DayOfWeek.class,new DayOfWeekAdaptor()).registerTypeAdapter(PriceLevel.class,new PriceLevelAdaptor()).registerTypeAdapter(Instant.class,new InstantAdapter()).registerTypeAdapter(LocalTime.class,new LocalTimeAdapter()).registerTypeAdapter(GeolocationApi.Response.class,new GeolocationResponseAdapter()).registerTypeAdapter(EncodedPolyline.class,new EncodedPolylineInstanceCreator(""String_Node_Str"")).setFieldNamingPolicy(fieldNamingPolicy).create();
  try {
    resp=gson.fromJson(new String(bytes,""String_Node_Str""),responseClass);
  }
 catch (  JsonSyntaxException e) {
    if (response.getResponseCode() > 399) {
      throw new IOException(String.format(""String_Node_Str"",response.getResponseCode(),new String(response.getContent(),Charset.defaultCharset())));
    }
    throw e;
  }
  if (resp.successful()) {
    return resp.getResult();
  }
 else {
    ApiException e=resp.getError();
    if (shouldRetry(e)) {
      return request.retry();
    }
 else {
      throw e;
    }
  }
}"
3561,"@Test public void testCanonicalLiteralsForAddressComponentType(){
  Map<AddressComponentType,String> addressComponentTypeToLiteralMap=new HashMap<AddressComponentType,String>();
  addressComponentTypeToLiteralMap.put(AddressComponentType.STREET_ADDRESS,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ROUTE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.INTERSECTION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POLITICAL,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.COUNTRY,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_1,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_2,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_3,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_4,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_5,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.COLLOQUIAL_AREA,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.LOCALITY,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.WARD,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_1,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_2,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_3,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_4,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_5,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.NEIGHBORHOOD,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.PREMISE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBPREMISE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_CODE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POST_BOX,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_CODE_PREFIX,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_CODE_SUFFIX,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.NATURAL_FEATURE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.AIRPORT,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.PARK,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.FLOOR,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.PARKING,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POINT_OF_INTEREST,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.BUS_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.TRAIN_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBWAY_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.TRANSIT_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.LIGHT_RAIL_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ESTABLISHMENT,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_TOWN,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ROOM,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.STREET_NUMBER,""String_Node_Str"");
  for (  Map.Entry<AddressComponentType,String> AddressComponentTypeLiteralPair : addressComponentTypeToLiteralMap.entrySet()) {
    assertEquals(AddressComponentTypeLiteralPair.getValue(),AddressComponentTypeLiteralPair.getKey().toCanonicalLiteral());
  }
  assertEquals(addressComponentTypeToLiteralMap.size() + 1,AddressComponentType.values().length);
}","@Test public void testCanonicalLiteralsForAddressComponentType(){
  Map<AddressComponentType,String> addressComponentTypeToLiteralMap=new HashMap<AddressComponentType,String>();
  addressComponentTypeToLiteralMap.put(AddressComponentType.STREET_ADDRESS,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ROUTE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.INTERSECTION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POLITICAL,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.COUNTRY,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_1,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_2,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_3,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_4,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ADMINISTRATIVE_AREA_LEVEL_5,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.COLLOQUIAL_AREA,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.LOCALITY,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.WARD,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_1,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_2,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_3,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_4,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBLOCALITY_LEVEL_5,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.NEIGHBORHOOD,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.PREMISE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBPREMISE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_CODE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POST_BOX,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_CODE_PREFIX,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_CODE_SUFFIX,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.NATURAL_FEATURE,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.AIRPORT,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.PARK,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.FLOOR,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.PARKING,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POINT_OF_INTEREST,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.BUS_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.TRAIN_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.SUBWAY_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.TRANSIT_STATION,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ESTABLISHMENT,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.POSTAL_TOWN,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.ROOM,""String_Node_Str"");
  addressComponentTypeToLiteralMap.put(AddressComponentType.STREET_NUMBER,""String_Node_Str"");
  for (  Map.Entry<AddressComponentType,String> AddressComponentTypeLiteralPair : addressComponentTypeToLiteralMap.entrySet()) {
    assertEquals(AddressComponentTypeLiteralPair.getValue(),AddressComponentTypeLiteralPair.getKey().toCanonicalLiteral());
  }
  assertEquals(addressComponentTypeToLiteralMap.size() + 1,AddressComponentType.values().length);
}"
3562,"<T,R extends ApiResponse<T>>PendingResult<T> post(ApiConfig config,Class<? extends R> clazz,GeolocationPayload payload){
  checkContext(config.supportsClientId);
  StringBuilder url=new StringBuilder(config.path);
  if (config.supportsClientId && clientId != null) {
    url.append(""String_Node_Str"").append(clientId);
  }
 else {
    url.append(""String_Node_Str"").append(apiKey);
  }
  if (config.supportsClientId && clientId != null) {
    try {
      String signature=urlSigner.getSignature(url.toString());
      url.append(""String_Node_Str"").append(signature);
    }
 catch (    Exception e) {
      return new ExceptionResult<T>(e);
    }
  }
  String hostName=config.hostName;
  if (baseUrlOverride != null) {
    hostName=baseUrlOverride;
  }
  Gson gson=new Gson();
  String jsonPayload=gson.toJson(payload);
  return requestHandler.handlePost(hostName,url.toString(),jsonPayload,USER_AGENT,clazz,config.fieldNamingPolicy,errorTimeout);
}","<T,R extends ApiResponse<T>,P>PendingResult<T> post(ApiConfig config,Class<? extends R> clazz,P payload){
  checkContext(config.supportsClientId);
  StringBuilder url=new StringBuilder(config.path);
  if (config.supportsClientId && clientId != null) {
    url.append(""String_Node_Str"").append(clientId);
  }
 else {
    url.append(""String_Node_Str"").append(apiKey);
  }
  if (config.supportsClientId && clientId != null) {
    try {
      String signature=urlSigner.getSignature(url.toString());
      url.append(""String_Node_Str"").append(signature);
    }
 catch (    Exception e) {
      return new ExceptionResult<T>(e);
    }
  }
  String hostName=config.hostName;
  if (baseUrlOverride != null) {
    hostName=baseUrlOverride;
  }
  Gson gson=new Gson();
  String jsonPayload=gson.toJson(payload);
  return requestHandler.handlePost(hostName,url.toString(),jsonPayload,USER_AGENT,clazz,config.fieldNamingPolicy,errorTimeout);
}"
3563,"@Override public ApiException getError(){
  return ApiException.from(error.status,error.message);
}","@Override public ApiException getError(){
  if (successful()) {
    return null;
  }
  ApiException e;
  if (reason.equals(""String_Node_Str"")) {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
 else   if (reason.equals(""String_Node_Str"")) {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
 else   if (reason.equals(""String_Node_Str"")) {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
 else   if (reason.equals(""String_Node_Str"")) {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
 else   if (reason.equals(""String_Node_Str"")) {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
 else   if (reason.equals(""String_Node_Str"")) {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
 else {
    e=ApiException.from(""String_Node_Str"",reason + ""String_Node_Str"" + message);
  }
  return e;
}"
3564,"@Override public GeolocationResult getResult(){
  return result;
}","@Override public GeolocationResult getResult(){
  GeolocationResult result=new GeolocationResult();
  result.accuracy=accuracy;
  result.location=location;
  return result;
}"
3565,"public static PendingResult<GeolocationResult> geolocate(GeoApiContext context,GeolocationPayload payload){
  return context.post(GEOLOCATION_API_CONFIG,GeolocationResponse.class,payload);
}","public static PendingResult<GeolocationResult> geolocate(GeoApiContext context,GeolocationPayload payload){
  return context.post(GEOLOCATION_API_CONFIG,Response.class,payload);
}"
3566,"@Override public boolean successful(){
  return error == null;
}","@Override public boolean successful(){
  return code == 200;
}"
3567,"@Override public <T,R extends ApiResponse<T>>PendingResult<T> handlePost(String hostName,String url,String payload,String userAgent,Class<R> clazz,FieldNamingPolicy fieldNamingPolicy,long errorTimeout){
  RequestBody body=RequestBody.create(JSON,payload);
  Request req=new Request.Builder().post(body).header(""String_Node_Str"",userAgent).url(hostName + url).build();
  LOG.log(Level.CONFIG,""String_Node_Str"",hostName + url);
  LOG.log(Level.CONFIG,""String_Node_Str"",payload);
  return new OkHttpPendingResult<T,R>(req,client,clazz,fieldNamingPolicy,errorTimeout);
}","@Override public <T,R extends ApiResponse<T>>PendingResult<T> handlePost(String hostName,String url,String payload,String userAgent,Class<R> clazz,FieldNamingPolicy fieldNamingPolicy,long errorTimeout){
  RequestBody body=RequestBody.create(JSON,payload);
  Request req=new Request.Builder().post(body).header(""String_Node_Str"",userAgent).url(hostName + url).build();
  LOG.log(Level.INFO,""String_Node_Str"",hostName + url);
  LOG.log(Level.INFO,""String_Node_Str"",payload);
  return new OkHttpPendingResult<T,R>(req,client,clazz,fieldNamingPolicy,errorTimeout);
}"
3568,"/** 
 * Performs the request synchronously.
 * @return The result.
 */
T await() throws Exception ;","/** 
 * Performs the GET request synchronously.
 * @return The result.
 */
T await() throws Exception ;"
3569,"@SuppressWarnings(""String_Node_Str"") private T parseResponse(OkHttpPendingResult<T,R> request,Response response) throws Exception {
  if (RETRY_ERROR_CODES.contains(response.code()) && cumulativeSleepTime < errorTimeOut) {
    return request.retry();
  }
  byte[] bytes=getBytes(response);
  R resp;
  String contentType=response.header(""String_Node_Str"");
  if (contentType != null && contentType.startsWith(""String_Node_Str"") && responseClass == PhotoRequest.Response.class && response.code() == 200) {
    PhotoResult result=new PhotoResult();
    result.contentType=contentType;
    result.imageData=bytes;
    return (T)result;
  }
  Gson gson=new GsonBuilder().registerTypeAdapter(DateTime.class,new DateTimeAdapter()).registerTypeAdapter(Distance.class,new DistanceAdapter()).registerTypeAdapter(Duration.class,new DurationAdapter()).registerTypeAdapter(Fare.class,new FareAdapter()).registerTypeAdapter(LatLng.class,new LatLngAdapter()).registerTypeAdapter(AddressComponentType.class,new SafeEnumAdapter<AddressComponentType>(AddressComponentType.UNKNOWN)).registerTypeAdapter(AddressType.class,new SafeEnumAdapter<AddressType>(AddressType.UNKNOWN)).registerTypeAdapter(TravelMode.class,new SafeEnumAdapter<TravelMode>(TravelMode.UNKNOWN)).registerTypeAdapter(LocationType.class,new SafeEnumAdapter<LocationType>(LocationType.UNKNOWN)).registerTypeAdapter(RatingType.class,new SafeEnumAdapter<RatingType>(RatingType.UNKNOWN)).registerTypeAdapter(DayOfWeek.class,new DayOfWeekAdaptor()).registerTypeAdapter(PriceLevel.class,new PriceLevelAdaptor()).registerTypeAdapter(Instant.class,new InstantAdapter()).registerTypeAdapter(LocalTime.class,new LocalTimeAdapter()).setFieldNamingPolicy(fieldNamingPolicy).create();
  try {
    resp=gson.fromJson(new String(bytes,""String_Node_Str""),responseClass);
  }
 catch (  JsonSyntaxException e) {
    if (!response.isSuccessful()) {
      throw new IOException(String.format(""String_Node_Str"",response.code(),response.message()));
    }
    throw e;
  }
  if (resp.successful()) {
    return resp.getResult();
  }
 else {
    ApiException e=resp.getError();
    if (e instanceof OverQueryLimitException && cumulativeSleepTime < errorTimeOut) {
      return request.retry();
    }
 else {
      throw e;
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private T parseResponse(OkHttpPendingResult<T,R> request,Response response) throws Exception {
  if (RETRY_ERROR_CODES.contains(response.code()) && cumulativeSleepTime < errorTimeOut) {
    return request.retry();
  }
  byte[] bytes=getBytes(response);
  R resp;
  String contentType=response.header(""String_Node_Str"");
  LOG.log(Level.INFO,""String_Node_Str"",response);
  LOG.log(Level.INFO,""String_Node_Str"",new String(bytes,""String_Node_Str""));
  if (contentType != null && contentType.startsWith(""String_Node_Str"") && responseClass == PhotoRequest.Response.class && response.code() == 200) {
    PhotoResult result=new PhotoResult();
    result.contentType=contentType;
    result.imageData=bytes;
    return (T)result;
  }
  Gson gson=new GsonBuilder().registerTypeAdapter(DateTime.class,new DateTimeAdapter()).registerTypeAdapter(Distance.class,new DistanceAdapter()).registerTypeAdapter(Duration.class,new DurationAdapter()).registerTypeAdapter(Fare.class,new FareAdapter()).registerTypeAdapter(LatLng.class,new LatLngAdapter()).registerTypeAdapter(AddressComponentType.class,new SafeEnumAdapter<AddressComponentType>(AddressComponentType.UNKNOWN)).registerTypeAdapter(AddressType.class,new SafeEnumAdapter<AddressType>(AddressType.UNKNOWN)).registerTypeAdapter(TravelMode.class,new SafeEnumAdapter<TravelMode>(TravelMode.UNKNOWN)).registerTypeAdapter(LocationType.class,new SafeEnumAdapter<LocationType>(LocationType.UNKNOWN)).registerTypeAdapter(RatingType.class,new SafeEnumAdapter<RatingType>(RatingType.UNKNOWN)).registerTypeAdapter(DayOfWeek.class,new DayOfWeekAdaptor()).registerTypeAdapter(PriceLevel.class,new PriceLevelAdaptor()).registerTypeAdapter(Instant.class,new InstantAdapter()).registerTypeAdapter(LocalTime.class,new LocalTimeAdapter()).registerTypeAdapter(GeolocationApi.Response.class,new GeolocationResponseAdapter()).setFieldNamingPolicy(fieldNamingPolicy).create();
  try {
    resp=gson.fromJson(new String(bytes,""String_Node_Str""),responseClass);
  }
 catch (  JsonSyntaxException e) {
    LOG.log(Level.INFO,""String_Node_Str"",e);
    if (!response.isSuccessful()) {
      throw new IOException(String.format(""String_Node_Str"",response.code(),response.message()));
    }
    throw e;
  }
  if (resp.successful()) {
    return resp.getResult();
  }
 else {
    ApiException e=resp.getError();
    if (e instanceof OverQueryLimitException && cumulativeSleepTime < errorTimeOut) {
      return request.retry();
    }
 else {
      throw e;
    }
  }
}"
3570,"/** 
 * Specifies the unit system to use when expressing distance as text. Distance Matrix results contain text within distance fields to indicate the distance of the calculated route.
 * @see <a href=""https://developers.google.com/maps/documentation/distancematrix/#unit_systems"">Unit systems in the Distance Matrix API</a>
 * @param unit One of {@link Unit#METRIC},   {@link Unit#IMPERIAL}.
 */
public DistanceMatrixApiRequest units(Unit unit){
  return param(""String_Node_Str"",unit);
}","/** 
 * Specifies the unit system to use when expressing distance as text. Distance Matrix results contain text within distance fields to indicate the distance of the calculated route.
 * @see <a href=""https://developers.google.com/maps/documentation/distancematrix/#unit_systems"">
   *   Unit systems in the Distance Matrix API</a>
 * @param unit One of {@link Unit#METRIC},   {@link Unit#IMPERIAL}.
 */
public DistanceMatrixApiRequest units(Unit unit){
  return param(""String_Node_Str"",unit);
}"
3571,"/** 
 * Test transit details.
 */
@Test public void testTransitDetails() throws Exception {
  DirectionsRoute[] routes=DirectionsApi.newRequest(context).origin(""String_Node_Str"").destination(""String_Node_Str"").mode(TravelMode.TRANSIT).departureTime(new DateTime(2015,2,15,11,0,DateTimeZone.UTC)).await();
  DirectionsLeg testLeg=routes[0].legs[0];
  int i=0;
  for (; i < testLeg.steps.length - 1 && testLeg.steps[i].travelMode != TravelMode.TRANSIT; i++)   assertTrue(""String_Node_Str"",i < testLeg.steps.length - 1);
  assertNotNull(testLeg.steps[i].transitDetails);
  assertNotNull(testLeg.steps[i].transitDetails.arrivalStop);
  assertNotNull(testLeg.steps[i].transitDetails.arrivalTime);
  assertNotNull(testLeg.steps[i].transitDetails.departureStop);
  assertNotNull(testLeg.steps[i].transitDetails.departureTime);
  assertNotNull(testLeg.steps[i].transitDetails.line);
  assertNotNull(testLeg.steps[i].transitDetails.line.agencies);
  assertNotNull(testLeg.steps[i].transitDetails.line.vehicle);
}","/** 
 * Test transit details.
 */
@Test public void testTransitDetails() throws Exception {
  DirectionsRoute[] routes=DirectionsApi.newRequest(context).origin(""String_Node_Str"").destination(""String_Node_Str"").mode(TravelMode.TRANSIT).departureTime(new DateTime(2015,2,15,11,0,DateTimeZone.UTC)).await();
  DirectionsLeg testLeg=routes[0].legs[0];
  int i=0;
  while (testLeg.steps[i].travelMode != TravelMode.TRANSIT) {
    i++;
  }
  assertTrue(""String_Node_Str"",i < testLeg.steps.length);
  assertNotNull(testLeg.steps[i].transitDetails);
  assertNotNull(testLeg.steps[i].transitDetails.arrivalStop);
  assertNotNull(testLeg.steps[i].transitDetails.arrivalTime);
  assertNotNull(testLeg.steps[i].transitDetails.departureStop);
  assertNotNull(testLeg.steps[i].transitDetails.departureTime);
  assertNotNull(testLeg.steps[i].transitDetails.line);
  assertNotNull(testLeg.steps[i].transitDetails.line.agencies);
  assertNotNull(testLeg.steps[i].transitDetails.line.vehicle);
}"
3572,"/** 
 * Making a request using just components filter: <a href=""https://maps.googleapis.com/maps/api/geocode/json?components=route:Annegatan|administrative_area:Helsinki|country:Finland""> Searching for a route of Annegatan, in the administrative area of Helsinki, and the country of Finland </a>.
 */
@Test public void testGeocodeWithJustComponents() throws Exception {
  GeocodingResult[] results=GeocodingApi.newRequest(context).components(GeocodingApi.ComponentFilter.route(""String_Node_Str""),GeocodingApi.ComponentFilter.administrativeArea(""String_Node_Str""),GeocodingApi.ComponentFilter.country(""String_Node_Str"")).await();
  assertNotNull(results);
  assertEquals(""String_Node_Str"",results[0].formattedAddress);
}","/** 
 * Making a request using just components filter: <a href=""https://maps.googleapis.com/maps/api/geocode/json?components=route:Annegatan|administrative_area:Helsinki|country:Finland""> Searching for a route of Annegatan, in the administrative area of Helsinki, and the country of Finland </a>.
 */
@Test public void testGeocodeWithJustComponents() throws Exception {
  GeocodingResult[] results=GeocodingApi.newRequest(context).components(GeocodingApi.ComponentFilter.route(""String_Node_Str""),GeocodingApi.ComponentFilter.administrativeArea(""String_Node_Str""),GeocodingApi.ComponentFilter.country(""String_Node_Str"")).await();
  assertNotNull(results);
  assertTrue(results[0].formattedAddress.startsWith(""String_Node_Str""));
}"
3573,"public void decryptPassword(PasswordItem item){
  Intent intent=new Intent(this,PgpHandler.class);
  intent.putExtra(""String_Node_Str"",item.toString());
  intent.putExtra(""String_Node_Str"",item.getFile().getAbsolutePath());
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {
    ShortcutInfo shortcut=new ShortcutInfo.Builder(this,item.getFullPathToParent()).setShortLabel(item.toString()).setLongLabel(item.getFullPathToParent() + item.toString()).setIcon(Icon.createWithResource(this,R.drawable.ic_launcher)).setIntent(intent.setAction(""String_Node_Str"")).build();
    shortcutManager.addDynamicShortcuts(Arrays.asList(shortcut));
  }
  startActivityForResult(intent,PgpHandler.REQUEST_CODE_DECRYPT_AND_VERIFY);
}","public void decryptPassword(PasswordItem item){
  Intent intent=new Intent(this,PgpHandler.class);
  intent.putExtra(""String_Node_Str"",item.toString());
  intent.putExtra(""String_Node_Str"",item.getFile().getAbsolutePath());
  intent.putExtra(""String_Node_Str"",""String_Node_Str"");
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {
    ShortcutInfo shortcut=new ShortcutInfo.Builder(this,item.getFullPathToParent()).setShortLabel(item.toString()).setLongLabel(item.getFullPathToParent() + item.toString()).setIcon(Icon.createWithResource(this,R.drawable.ic_launcher)).setIntent(intent.setAction(""String_Node_Str"")).build();
    List<ShortcutInfo> shortcuts=shortcutManager.getDynamicShortcuts();
    if (shortcuts.size() >= shortcutManager.getMaxShortcutCountPerActivity() && shortcuts.size() > 0) {
      shortcuts.remove(shortcuts.size() - 1);
      shortcuts.add(0,shortcut);
      shortcutManager.setDynamicShortcuts(shortcuts);
    }
 else {
      shortcutManager.addDynamicShortcuts(Collections.singletonList(shortcut));
    }
  }
  startActivityForResult(intent,PgpHandler.REQUEST_CODE_DECRYPT_AND_VERIFY);
}"
3574,"/** 
 * Generates a completely random password.
 * @param size    length of password to generate
 * @param pwFlags flag field where set bits indicate conditions thegenerated password must meet <table summary =""bits of flag field""> <tr><td>Bit</td><td>Condition</td></tr> <tr><td>0</td><td>include at least one number</td></tr> <tr><td>1</td><td>include at least one uppercase letter</td></tr> <tr><td>2</td><td>include at least one symbol</td></tr> <tr><td>3</td><td>don't include ambiguous characters</td></tr> <tr><td>4</td><td>don't include vowels</td></tr> </table>
 * @return the generated password
 */
public static String rand(int size,int pwFlags){
  String password=""String_Node_Str"";
  char cha;
  int i, featureFlags, num;
  String val;
  String bank=""String_Node_Str"";
  if ((pwFlags & pwgen.DIGITS) > 0) {
    bank+=pwgen.DIGITS_STR;
  }
  if ((pwFlags & pwgen.UPPERS) > 0) {
    bank+=pwgen.UPPERS_STR;
  }
  bank+=pwgen.LOWERS_STR;
  if ((pwFlags & pwgen.SYMBOLS) > 0) {
    bank+=pwgen.SYMBOLS_STR;
  }
  do {
    featureFlags=pwFlags;
    i=0;
    while (i < size) {
      num=randnum.number(bank.length());
      cha=bank.toCharArray()[num];
      val=String.valueOf(cha);
      if ((pwFlags & pwgen.AMBIGUOUS) > 0 && pwgen.AMBIGUOUS_STR.contains(val)) {
        continue;
      }
      if ((pwFlags & pwgen.NO_VOWELS) > 0 && pwgen.VOWELS_STR.contains(val)) {
        continue;
      }
      password+=val;
      i++;
      if (pwgen.DIGITS_STR.contains(val)) {
        featureFlags&=~pwgen.DIGITS;
      }
      if (pwgen.UPPERS_STR.contains(val)) {
        featureFlags&=~pwgen.UPPERS;
      }
      if (pwgen.SYMBOLS_STR.contains(val)) {
        featureFlags&=~pwgen.SYMBOLS;
      }
    }
  }
 while ((featureFlags & (pwgen.UPPERS | pwgen.DIGITS | pwgen.SYMBOLS)) > 0);
  return password;
}","/** 
 * Generates a completely random password.
 * @param size    length of password to generate
 * @param pwFlags flag field where set bits indicate conditions thegenerated password must meet <table summary =""bits of flag field""> <tr><td>Bit</td><td>Condition</td></tr> <tr><td>0</td><td>include at least one number</td></tr> <tr><td>1</td><td>include at least one uppercase letter</td></tr> <tr><td>2</td><td>include at least one symbol</td></tr> <tr><td>3</td><td>don't include ambiguous characters</td></tr> <tr><td>4</td><td>don't include vowels</td></tr> </table>
 * @return the generated password
 */
public static String rand(int size,int pwFlags){
  String password;
  char cha;
  int i, featureFlags, num;
  String val;
  String bank=""String_Node_Str"";
  if ((pwFlags & pwgen.DIGITS) > 0) {
    bank+=pwgen.DIGITS_STR;
  }
  if ((pwFlags & pwgen.UPPERS) > 0) {
    bank+=pwgen.UPPERS_STR;
  }
  bank+=pwgen.LOWERS_STR;
  if ((pwFlags & pwgen.SYMBOLS) > 0) {
    bank+=pwgen.SYMBOLS_STR;
  }
  do {
    password=""String_Node_Str"";
    featureFlags=pwFlags;
    i=0;
    while (i < size) {
      num=randnum.number(bank.length());
      cha=bank.toCharArray()[num];
      val=String.valueOf(cha);
      if ((pwFlags & pwgen.AMBIGUOUS) > 0 && pwgen.AMBIGUOUS_STR.contains(val)) {
        continue;
      }
      if ((pwFlags & pwgen.NO_VOWELS) > 0 && pwgen.VOWELS_STR.contains(val)) {
        continue;
      }
      password+=val;
      i++;
      if (pwgen.DIGITS_STR.contains(val)) {
        featureFlags&=~pwgen.DIGITS;
      }
      if (pwgen.UPPERS_STR.contains(val)) {
        featureFlags&=~pwgen.UPPERS;
      }
      if (pwgen.SYMBOLS_STR.contains(val)) {
        featureFlags&=~pwgen.SYMBOLS;
      }
    }
  }
 while ((featureFlags & (pwgen.UPPERS | pwgen.DIGITS | pwgen.SYMBOLS)) > 0);
  return password;
}"
3575,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  final Activity callingActivity=getActivity();
  LayoutInflater inflater=callingActivity.getLayoutInflater();
  final View view=inflater.inflate(R.layout.fragment_pwgen,null);
  Typeface monoTypeface=Typeface.createFromAsset(callingActivity.getAssets(),""String_Node_Str"");
  builder.setView(view);
  SharedPreferences prefs=getActivity().getApplicationContext().getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE);
  CheckBox checkBox=(CheckBox)view.findViewById(R.id.numerals);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.symbols);
  checkBox.setChecked(prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.uppercase);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.ambiguous);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.pronounceable);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",true));
  TextView textView=(TextView)view.findViewById(R.id.lengthNumber);
  textView.setText(Integer.toString(prefs.getInt(""String_Node_Str"",20)));
  ((EditText)view.findViewById(R.id.passwordText)).setTypeface(monoTypeface);
  builder.setPositiveButton(getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      EditText edit=(EditText)callingActivity.findViewById(R.id.crypto_password_edit);
      EditText generate=(EditText)view.findViewById(R.id.passwordText);
      edit.append(generate.getText());
    }
  }
);
  builder.setNegativeButton(getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
);
  builder.setNeutralButton(getResources().getString(R.string.pwgen_generate),null);
  final AlertDialog ad=builder.setTitle(""String_Node_Str"").create();
  ad.setOnShowListener(new DialogInterface.OnShowListener(){
    @Override public void onShow(    DialogInterface dialog){
      setPreferences();
      EditText editText=(EditText)view.findViewById(R.id.passwordText);
      editText.setText(pwgen.generate(getActivity().getApplicationContext()).get(0));
      Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL);
      b.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          setPreferences();
          EditText editText=(EditText)view.findViewById(R.id.passwordText);
          editText.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0));
        }
      }
);
    }
  }
);
  return ad;
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  final Activity callingActivity=getActivity();
  LayoutInflater inflater=callingActivity.getLayoutInflater();
  final View view=inflater.inflate(R.layout.fragment_pwgen,null);
  Typeface monoTypeface=Typeface.createFromAsset(callingActivity.getAssets(),""String_Node_Str"");
  builder.setView(view);
  SharedPreferences prefs=getActivity().getApplicationContext().getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE);
  CheckBox checkBox=(CheckBox)view.findViewById(R.id.numerals);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.symbols);
  checkBox.setChecked(prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.uppercase);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.ambiguous);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",false));
  checkBox=(CheckBox)view.findViewById(R.id.pronounceable);
  checkBox.setChecked(!prefs.getBoolean(""String_Node_Str"",true));
  TextView textView=(TextView)view.findViewById(R.id.lengthNumber);
  textView.setText(Integer.toString(prefs.getInt(""String_Node_Str"",20)));
  ((TextView)view.findViewById(R.id.passwordText)).setTypeface(monoTypeface);
  builder.setPositiveButton(getResources().getString(R.string.dialog_ok),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      EditText edit=(EditText)callingActivity.findViewById(R.id.crypto_password_edit);
      TextView generate=(TextView)view.findViewById(R.id.passwordText);
      edit.append(generate.getText());
    }
  }
);
  builder.setNegativeButton(getResources().getString(R.string.dialog_cancel),new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
);
  builder.setNeutralButton(getResources().getString(R.string.pwgen_generate),null);
  final AlertDialog ad=builder.setTitle(""String_Node_Str"").create();
  ad.setOnShowListener(new DialogInterface.OnShowListener(){
    @Override public void onShow(    DialogInterface dialog){
      setPreferences();
      TextView textView=(TextView)view.findViewById(R.id.passwordText);
      textView.setText(pwgen.generate(getActivity().getApplicationContext()).get(0));
      Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL);
      b.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          setPreferences();
          TextView textView=(TextView)view.findViewById(R.id.passwordText);
          textView.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0));
        }
      }
);
    }
  }
);
  return ad;
}"
3576,"@Override public void onClick(View v){
  setPreferences();
  EditText editText=(EditText)view.findViewById(R.id.passwordText);
  editText.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0));
}","@Override public void onClick(View v){
  setPreferences();
  TextView textView=(TextView)view.findViewById(R.id.passwordText);
  textView.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0));
}"
3577,"@Override public void onShow(DialogInterface dialog){
  setPreferences();
  EditText editText=(EditText)view.findViewById(R.id.passwordText);
  editText.setText(pwgen.generate(getActivity().getApplicationContext()).get(0));
  Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL);
  b.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      setPreferences();
      EditText editText=(EditText)view.findViewById(R.id.passwordText);
      editText.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0));
    }
  }
);
}","@Override public void onShow(DialogInterface dialog){
  setPreferences();
  TextView textView=(TextView)view.findViewById(R.id.passwordText);
  textView.setText(pwgen.generate(getActivity().getApplicationContext()).get(0));
  Button b=ad.getButton(AlertDialog.BUTTON_NEUTRAL);
  b.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      setPreferences();
      TextView textView=(TextView)view.findViewById(R.id.passwordText);
      textView.setText(pwgen.generate(callingActivity.getApplicationContext()).get(0));
    }
  }
);
}"
3578,"public void onClick(DialogInterface dialog,int whichButton){
  settings.edit().putBoolean(""String_Node_Str"",false).apply();
switch (operation) {
case NEW_REPO_BUTTON:
    initializeRepositoryInfo();
  break;
case CLONE_REPO_BUTTON:
Intent intent=new Intent(activity,GitActivity.class);
intent.putExtra(""String_Node_Str"",GitActivity.REQUEST_CLONE);
startActivityForResult(intent,GitActivity.REQUEST_CLONE);
break;
}
}","public void onClick(DialogInterface dialog,int whichButton){
  settings.edit().putBoolean(""String_Node_Str"",false).apply();
switch (operation) {
case NEW_REPO_BUTTON:
    initializeRepositoryInfo();
  break;
case CLONE_REPO_BUTTON:
PasswordRepository.initialize(PasswordStore.this);
Intent intent=new Intent(activity,GitActivity.class);
intent.putExtra(""String_Node_Str"",GitActivity.REQUEST_CLONE);
startActivityForResult(intent,GitActivity.REQUEST_CLONE);
break;
}
}"
3579,"protected void initRepository(final int operation){
  new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      settings.edit().putBoolean(""String_Node_Str"",true).apply();
      if (settings.getString(""String_Node_Str"",null) == null) {
        Intent intent=new Intent(activity,UserPreference.class);
        intent.putExtra(""String_Node_Str"",""String_Node_Str"");
        startActivityForResult(intent,operation);
      }
 else {
        PasswordRepository.closeRepository();
        checkLocalRepository();
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      settings.edit().putBoolean(""String_Node_Str"",false).apply();
switch (operation) {
case NEW_REPO_BUTTON:
        initializeRepositoryInfo();
      break;
case CLONE_REPO_BUTTON:
    Intent intent=new Intent(activity,GitActivity.class);
  intent.putExtra(""String_Node_Str"",GitActivity.REQUEST_CLONE);
startActivityForResult(intent,GitActivity.REQUEST_CLONE);
break;
}
}
}
).show();
}","protected void initRepository(final int operation){
  PasswordRepository.closeRepository();
  new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      settings.edit().putBoolean(""String_Node_Str"",true).apply();
      if (settings.getString(""String_Node_Str"",null) == null) {
        Intent intent=new Intent(activity,UserPreference.class);
        intent.putExtra(""String_Node_Str"",""String_Node_Str"");
        startActivityForResult(intent,operation);
      }
 else {
switch (operation) {
case NEW_REPO_BUTTON:
          initializeRepositoryInfo();
        break;
case CLONE_REPO_BUTTON:
      PasswordRepository.initialize(PasswordStore.this);
    Intent intent=new Intent(activity,GitActivity.class);
  intent.putExtra(""String_Node_Str"",GitActivity.REQUEST_CLONE);
startActivityForResult(intent,GitActivity.REQUEST_CLONE);
break;
}
}
}
}
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
settings.edit().putBoolean(""String_Node_Str"",false).apply();
switch (operation) {
case NEW_REPO_BUTTON:
initializeRepositoryInfo();
break;
case CLONE_REPO_BUTTON:
PasswordRepository.initialize(PasswordStore.this);
Intent intent=new Intent(activity,GitActivity.class);
intent.putExtra(""String_Node_Str"",GitActivity.REQUEST_CLONE);
startActivityForResult(intent,GitActivity.REQUEST_CLONE);
break;
}
}
}
).show();
}"
3580,"private void createRepository(){
  File localDir=PasswordRepository.getWorkTree();
  localDir.mkdir();
  try {
    PasswordRepository.createRepository(localDir);
    new File(localDir.getAbsolutePath() + ""String_Node_Str"").createNewFile();
    settings.edit().putBoolean(""String_Node_Str"",true).apply();
  }
 catch (  Exception e) {
    e.printStackTrace();
    localDir.delete();
    return;
  }
  checkLocalRepository();
}","private void createRepository(){
  if (!PasswordRepository.isInitialized()) {
    PasswordRepository.initialize(this);
  }
  File localDir=PasswordRepository.getWorkTree();
  localDir.mkdir();
  try {
    PasswordRepository.createRepository(localDir);
    new File(localDir.getAbsolutePath() + ""String_Node_Str"").createNewFile();
    settings.edit().putBoolean(""String_Node_Str"",true).apply();
  }
 catch (  Exception e) {
    e.printStackTrace();
    localDir.delete();
    return;
  }
  checkLocalRepository();
}"
3581,"@Override protected void configure(OpenSshConfig.Host hc,Session session){
  session.setConfig(""String_Node_Str"",""String_Node_Str"");
  CredentialsProvider provider=new CredentialsProvider(){
    @Override public boolean isInteractive(){
      return false;
    }
    @Override public boolean supports(    CredentialItem... items){
      return true;
    }
    @Override public boolean get(    URIish uri,    CredentialItem... items) throws UnsupportedCredentialItem {
      for (      CredentialItem item : items) {
        if (item instanceof CredentialItem.Username) {
          ((CredentialItem.Username)item).setValue(username);
          continue;
        }
        if (item instanceof CredentialItem.StringType) {
          ((CredentialItem.StringType)item).setValue(passphrase);
        }
      }
      return true;
    }
  }
;
  UserInfo userInfo=new CredentialsProviderUserInfo(session,provider);
  session.setUserInfo(userInfo);
}","@Override protected void configure(OpenSshConfig.Host hc,Session session){
  session.setConfig(""String_Node_Str"",""String_Node_Str"");
  session.setConfig(""String_Node_Str"",""String_Node_Str"");
  CredentialsProvider provider=new CredentialsProvider(){
    @Override public boolean isInteractive(){
      return false;
    }
    @Override public boolean supports(    CredentialItem... items){
      return true;
    }
    @Override public boolean get(    URIish uri,    CredentialItem... items) throws UnsupportedCredentialItem {
      for (      CredentialItem item : items) {
        if (item instanceof CredentialItem.Username) {
          ((CredentialItem.Username)item).setValue(username);
          continue;
        }
        if (item instanceof CredentialItem.StringType) {
          ((CredentialItem.StringType)item).setValue(passphrase);
        }
      }
      return true;
    }
  }
;
  UserInfo userInfo=new CredentialsProviderUserInfo(session,provider);
  session.setUserInfo(userInfo);
}"
3582,"public void cloneOperation(UsernamePasswordCredentialsProvider provider){
  saveConfiguration(null);
  CloneCommand cmd=Git.cloneRepository().setCredentialsProvider(provider).setCloneAllBranches(true).setDirectory(localDir).setURI(hostname);
  new GitAsyncTask(activity,true,false,CloneCommand.class).execute(cmd);
}","public void cloneOperation(UsernamePasswordCredentialsProvider provider){
  SharedPreferences.Editor editor=settings.edit();
  editor.putString(""String_Node_Str"",((EditText)findViewById(R.id.server_url)).getText().toString());
  editor.putString(""String_Node_Str"",((EditText)findViewById(R.id.server_path)).getText().toString());
  editor.putString(""String_Node_Str"",((EditText)findViewById(R.id.server_user)).getText().toString());
  editor.putString(""String_Node_Str"",protocol);
  editor.putString(""String_Node_Str"",connectionMode);
  editor.putString(""String_Node_Str"",port);
  editor.commit();
  CloneCommand cmd=Git.cloneRepository().setCredentialsProvider(provider).setCloneAllBranches(true).setDirectory(localDir).setURI(hostname);
  new GitAsyncTask(activity,true,false,CloneCommand.class).execute(cmd);
}"
3583,"@Override public void onBound(IOpenPgpService service){
  Log.i(""String_Node_Str"",""String_Node_Str"");
  Bundle extra=getIntent().getExtras();
  if (extra.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    setContentView(R.layout.decrypt_layout);
    ((TextView)findViewById(R.id.crypto_password_file)).setText(extra.getString(""String_Node_Str""));
    String cat=new File(extra.getString(""String_Node_Str"").replace(PasswordRepository.getWorkTree().getAbsolutePath(),""String_Node_Str"")).getParentFile().getName();
    ((TextView)findViewById(R.id.crypto_password_category)).setText(cat + ""String_Node_Str"");
    decryptAndVerify(new Intent());
  }
 else   if (extra.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    bindingDialog.dismiss();
    setContentView(R.layout.encrypt_layout);
    String cat=extra.getString(""String_Node_Str"");
    cat=cat.replace(PasswordRepository.getWorkTree().getAbsolutePath(),""String_Node_Str"");
    cat=cat + ""String_Node_Str"";
    ((TextView)findViewById(R.id.crypto_password_category)).setText(cat);
  }
 else   if (extra.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    bindingDialog.dismiss();
    getKeyIds(new Intent());
  }
}","@Override public void onBound(IOpenPgpService service){
  Log.i(""String_Node_Str"",""String_Node_Str"");
  Bundle extra=getIntent().getExtras();
  if (extra.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    setContentView(R.layout.decrypt_layout);
    ((TextView)findViewById(R.id.crypto_password_file)).setText(extra.getString(""String_Node_Str""));
    String cat=new File(extra.getString(""String_Node_Str"").replace(PasswordRepository.getWorkTree().getAbsolutePath(),""String_Node_Str"")).getParentFile().getName();
    ((TextView)findViewById(R.id.crypto_password_category)).setText(cat + ""String_Node_Str"");
    decryptAndVerify(new Intent());
  }
 else   if (extra.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    setContentView(R.layout.encrypt_layout);
    String cat=extra.getString(""String_Node_Str"");
    cat=cat.replace(PasswordRepository.getWorkTree().getAbsolutePath(),""String_Node_Str"");
    cat=cat + ""String_Node_Str"";
    ((TextView)findViewById(R.id.crypto_password_category)).setText(cat);
  }
 else   if (extra.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
    getKeyIds(new Intent());
  }
}"
3584,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  this.activity=this;
  this.clipboard=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
  settings=PreferenceManager.getDefaultSharedPreferences(this);
  String providerPackageName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  accountName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  keyIDs=settings.getString(""String_Node_Str"",""String_Node_Str"");
  registered=false;
  if (TextUtils.isEmpty(providerPackageName)) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    Intent intent=new Intent(this,UserPreference.class);
    startActivity(intent);
    setResult(RESULT_CANCELED);
    finish();
  }
 else {
    mServiceConnection=new OpenPgpServiceConnection(PgpHandler.this,providerPackageName,this);
    mServiceConnection.bindToService();
    bindingDialog=new ProgressDialog(this);
    bindingDialog.setMessage(""String_Node_Str"");
    bindingDialog.setCancelable(false);
    bindingDialog.show();
    registered=true;
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  this.activity=this;
  this.clipboard=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
  settings=PreferenceManager.getDefaultSharedPreferences(this);
  String providerPackageName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  accountName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  keyIDs=settings.getString(""String_Node_Str"",""String_Node_Str"");
  registered=false;
  if (TextUtils.isEmpty(providerPackageName)) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    Intent intent=new Intent(this,UserPreference.class);
    startActivity(intent);
    setResult(RESULT_CANCELED);
    finish();
  }
 else {
    mServiceConnection=new OpenPgpServiceConnection(PgpHandler.this,providerPackageName,this);
    mServiceConnection.bindToService();
    registered=true;
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  }
}"
3585,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  Log.d(Constants.TAG,""String_Node_Str"" + resultCode);
  if (resultCode == RESULT_OK) {
switch (requestCode) {
case REQUEST_CODE_ENCRYPT:
{
        encrypt(data);
        break;
      }
case REQUEST_CODE_DECRYPT_AND_VERIFY:
{
      decryptAndVerify(data);
      break;
    }
case REQUEST_CODE_GET_KEY_IDS:
  getKeyIds(data);
break;
}
}
 else if (resultCode == RESULT_CANCELED) {
bindingDialog.dismiss();
setResult(RESULT_CANCELED,data);
finish();
}
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  Log.d(Constants.TAG,""String_Node_Str"" + resultCode);
  if (resultCode == RESULT_OK) {
switch (requestCode) {
case REQUEST_CODE_ENCRYPT:
{
        encrypt(data);
        break;
      }
case REQUEST_CODE_DECRYPT_AND_VERIFY:
{
      decryptAndVerify(data);
      break;
    }
case REQUEST_CODE_GET_KEY_IDS:
  getKeyIds(data);
break;
}
}
 else if (resultCode == RESULT_CANCELED) {
setResult(RESULT_CANCELED,data);
finish();
}
}"
3586,"@Override public void onReturn(Intent result){
switch (result.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR)) {
case OpenPgpApi.RESULT_CODE_SUCCESS:
{
      if (requestCode == REQUEST_CODE_DECRYPT_AND_VERIFY && os != null) {
        try {
          Log.d(OpenPgpApi.TAG,""String_Node_Str"" + os.toByteArray().length + ""String_Node_Str""+ os.toString(""String_Node_Str""));
          bindingDialog.dismiss();
          if (returnToCiphertextField) {
            findViewById(R.id.crypto_container).setVisibility(View.VISIBLE);
            String[] passContent=os.toString(""String_Node_Str"").split(""String_Node_Str"");
            ((TextView)findViewById(R.id.crypto_password_show)).setText(passContent[0]);
            String extraContent=os.toString(""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
            if (extraContent.length() != 0) {
              ((TextView)findViewById(R.id.crypto_extra_show)).setText(extraContent);
            }
            new DelayShow().execute();
            if (settings.getBoolean(""String_Node_Str"",true)) {
              copyToClipBoard();
            }
          }
 else {
            showToast(os.toString());
          }
        }
 catch (        UnsupportedEncodingException e) {
          Log.e(Constants.TAG,""String_Node_Str"",e);
        }
      }
      if (requestCode == REQUEST_CODE_ENCRYPT && os != null) {
        try {
          String path=getIntent().getExtras().getString(""String_Node_Str"") + ""String_Node_Str"" + ((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString()+ ""String_Node_Str"";
          OutputStream outputStream=FileUtils.openOutputStream(new File(path));
          outputStream.write(os.toByteArray());
          Intent data=new Intent();
          data.putExtra(""String_Node_Str"",path);
          data.putExtra(""String_Node_Str"",((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString());
          setResult(RESULT_OK,data);
          finish();
        }
 catch (        Exception e) {
          Log.e(Constants.TAG,""String_Node_Str"",e);
        }
      }
      if (result.hasExtra(OpenPgpApi.RESULT_KEY_IDS)) {
        long[] ids=result.getLongArrayExtra(OpenPgpApi.RESULT_KEY_IDS);
        ArrayList<String> keys=new ArrayList<String>();
        for (int i=0; i < ids.length; i++) {
          keys.add(OpenPgpUtils.convertKeyIdToHex(ids[i]));
        }
        keyIDs=StringUtils.join(keys,""String_Node_Str"");
        if (!keyIDs.isEmpty()) {
          String mKeys=keyIDs.split(""String_Node_Str"").length > 1 ? keyIDs : keyIDs.split(""String_Node_Str"")[0];
          settings.edit().putString(""String_Node_Str"",keyIDs).apply();
          Log.i(""String_Node_Str"",mKeys);
        }
        setResult(RESULT_OK);
        finish();
      }
      break;
    }
case OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED:
{
    Log.i(""String_Node_Str"",""String_Node_Str"");
    PendingIntent pi=result.getParcelableExtra(OpenPgpApi.RESULT_INTENT);
    try {
      PgpHandler.this.startIntentSenderForResult(pi.getIntentSender(),requestCode,null,0,0,0);
    }
 catch (    IntentSender.SendIntentException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
    }
    break;
  }
case OpenPgpApi.RESULT_CODE_ERROR:
{
  showToast(""String_Node_Str"");
  OpenPgpError error=result.getParcelableExtra(OpenPgpApi.RESULT_ERROR);
  handleError(error);
  bindingDialog.dismiss();
  break;
}
}
}","@Override public void onReturn(Intent result){
switch (result.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR)) {
case OpenPgpApi.RESULT_CODE_SUCCESS:
{
      if (requestCode == REQUEST_CODE_DECRYPT_AND_VERIFY && os != null) {
        try {
          Log.d(OpenPgpApi.TAG,""String_Node_Str"" + os.toByteArray().length + ""String_Node_Str""+ os.toString(""String_Node_Str""));
          if (returnToCiphertextField) {
            findViewById(R.id.crypto_container).setVisibility(View.VISIBLE);
            String[] passContent=os.toString(""String_Node_Str"").split(""String_Node_Str"");
            ((TextView)findViewById(R.id.crypto_password_show)).setText(passContent[0]);
            String extraContent=os.toString(""String_Node_Str"").replaceFirst(""String_Node_Str"",""String_Node_Str"");
            if (extraContent.length() != 0) {
              ((TextView)findViewById(R.id.crypto_extra_show)).setText(extraContent);
            }
            new DelayShow().execute();
            if (settings.getBoolean(""String_Node_Str"",true)) {
              copyToClipBoard();
            }
          }
 else {
            Log.d(""String_Node_Str"",""String_Node_Str"" + os.toString());
          }
        }
 catch (        UnsupportedEncodingException e) {
          Log.e(Constants.TAG,""String_Node_Str"",e);
        }
      }
      if (requestCode == REQUEST_CODE_ENCRYPT && os != null) {
        try {
          String path=getIntent().getExtras().getString(""String_Node_Str"") + ""String_Node_Str"" + ((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString()+ ""String_Node_Str"";
          OutputStream outputStream=FileUtils.openOutputStream(new File(path));
          outputStream.write(os.toByteArray());
          Intent data=new Intent();
          data.putExtra(""String_Node_Str"",path);
          data.putExtra(""String_Node_Str"",((EditText)findViewById(R.id.crypto_password_file_edit)).getText().toString());
          setResult(RESULT_OK,data);
          finish();
        }
 catch (        Exception e) {
          Log.e(Constants.TAG,""String_Node_Str"",e);
        }
      }
      if (result.hasExtra(OpenPgpApi.RESULT_KEY_IDS)) {
        long[] ids=result.getLongArrayExtra(OpenPgpApi.RESULT_KEY_IDS);
        ArrayList<String> keys=new ArrayList<String>();
        for (int i=0; i < ids.length; i++) {
          keys.add(OpenPgpUtils.convertKeyIdToHex(ids[i]));
        }
        keyIDs=StringUtils.join(keys,""String_Node_Str"");
        if (!keyIDs.isEmpty()) {
          String mKeys=keyIDs.split(""String_Node_Str"").length > 1 ? keyIDs : keyIDs.split(""String_Node_Str"")[0];
          settings.edit().putString(""String_Node_Str"",keyIDs).apply();
          Log.i(""String_Node_Str"",mKeys);
        }
        setResult(RESULT_OK);
        finish();
      }
      break;
    }
case OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED:
{
    Log.i(""String_Node_Str"",""String_Node_Str"");
    PendingIntent pi=result.getParcelableExtra(OpenPgpApi.RESULT_INTENT);
    try {
      PgpHandler.this.startIntentSenderForResult(pi.getIntentSender(),requestCode,null,0,0,0);
    }
 catch (    IntentSender.SendIntentException e) {
      Log.e(Constants.TAG,""String_Node_Str"",e);
    }
    break;
  }
case OpenPgpApi.RESULT_CODE_ERROR:
{
  OpenPgpError error=result.getParcelableExtra(OpenPgpApi.RESULT_ERROR);
  handleError(error);
  break;
}
}
}"
3587,"public void createPassword(View v){
  this.currentDir=getCurrentDir();
  Log.i(""String_Node_Str"",""String_Node_Str"" + this.currentDir.getAbsolutePath());
  this.leftActivity=true;
  try {
    Intent intent=new Intent(this,PgpHandler.class);
    intent.putExtra(""String_Node_Str"",FileUtils.readFileToString(PasswordRepository.getFile(""String_Node_Str"")));
    intent.putExtra(""String_Node_Str"",this.currentDir.getAbsolutePath());
    intent.putExtra(""String_Node_Str"",""String_Node_Str"");
    startActivityForResult(intent,PgpHandler.REQUEST_CODE_ENCRYPT);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void createPassword(View v){
  this.currentDir=getCurrentDir();
  Log.i(""String_Node_Str"",""String_Node_Str"" + this.currentDir.getAbsolutePath());
  this.leftActivity=true;
  try {
    Intent intent=new Intent(this,PgpHandler.class);
    intent.putExtra(""String_Node_Str"",FileUtils.readFileToString(PasswordRepository.getFile(""String_Node_Str"")));
    intent.putExtra(""String_Node_Str"",getCurrentDir().getAbsolutePath());
    intent.putExtra(""String_Node_Str"",""String_Node_Str"");
    startActivityForResult(intent,PgpHandler.REQUEST_CODE_ENCRYPT);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
3588,"private File getCurrentDir(){
  return new File(((PasswordFragment)getFragmentManager().findFragmentByTag(""String_Node_Str"")).getArguments().getString(""String_Node_Str""));
}","private File getCurrentDir(){
  PasswordFragment plist;
  if (null != (plist=(PasswordFragment)getFragmentManager().findFragmentByTag(""String_Node_Str""))) {
    return plist.getCurrentDir();
  }
  return null;
}"
3589,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  this.activity=this;
  this.clipboard=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
  settings=PreferenceManager.getDefaultSharedPreferences(this);
  String providerPackageName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  accountName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  keyIDs=settings.getString(""String_Node_Str"",""String_Node_Str"");
  if (TextUtils.isEmpty(providerPackageName)) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    Intent intent=new Intent(this,UserPreference.class);
    startActivity(intent);
    setResult(RESULT_CANCELED);
    finish();
  }
 else {
    mServiceConnection=new OpenPgpServiceConnection(PgpHandler.this,providerPackageName,this);
    mServiceConnection.bindToService();
    bindingDialog=new ProgressDialog(this);
    bindingDialog.setMessage(""String_Node_Str"");
    bindingDialog.setCancelable(false);
    bindingDialog.show();
    ActionBar actionBar=getActionBar();
    actionBar.setDisplayHomeAsUpEnabled(true);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  this.activity=this;
  this.clipboard=(ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
  settings=PreferenceManager.getDefaultSharedPreferences(this);
  String providerPackageName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  accountName=settings.getString(""String_Node_Str"",""String_Node_Str"");
  keyIDs=settings.getString(""String_Node_Str"",""String_Node_Str"");
  registered=false;
  if (TextUtils.isEmpty(providerPackageName)) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    Intent intent=new Intent(this,UserPreference.class);
    startActivity(intent);
    setResult(RESULT_CANCELED);
    finish();
  }
 else {
    mServiceConnection=new OpenPgpServiceConnection(PgpHandler.this,providerPackageName,this);
    mServiceConnection.bindToService();
    bindingDialog=new ProgressDialog(this);
    bindingDialog.setMessage(""String_Node_Str"");
    bindingDialog.setCancelable(false);
    bindingDialog.show();
    registered=true;
    ActionBar actionBar=getActionBar();
    actionBar.setDisplayHomeAsUpEnabled(true);
  }
}"
3590,"@Override public void onStop(){
  super.onStop();
  if (this.mServiceConnection.isBound())   try {
    this.mServiceConnection.unbindFromService();
  }
 catch (  Exception e) {
  }
}","@Override public void onStop(){
  super.onStop();
  if (this.registered && this.mServiceConnection.isBound())   try {
    this.mServiceConnection.unbindFromService();
  }
 catch (  Exception e) {
  }
}"
3591,"@Override public View getView(int i,View convertView,ViewGroup viewGroup){
  View rowView=convertView;
  final PasswordItem pass=values.get(i);
  if (rowView == null) {
    LayoutInflater inflater=(LayoutInflater)activity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    rowView=inflater.inflate(R.layout.password_row_layout,viewGroup,false);
    ViewHolder viewHolder=new ViewHolder();
    viewHolder.name=(TextView)rowView.findViewById(R.id.label);
    viewHolder.back_name=(TextView)rowView.findViewById(R.id.label_back);
    viewHolder.type=(TextView)rowView.findViewById(R.id.type);
    rowView.setTag(viewHolder);
    View.OnClickListener onClickListener=new View.OnClickListener(){
      @Override public void onClick(      View view){
switch (view.getId()) {
case R.id.crypto_show_button:
          activity.decryptPassword(pass);
        break;
case R.id.crypto_delete_button:
      activity.deletePassword(pass);
    break;
}
}
}
;
((ImageButton)rowView.findViewById(R.id.crypto_show_button)).setOnClickListener(onClickListener);
((ImageButton)rowView.findViewById(R.id.crypto_delete_button)).setOnClickListener(onClickListener);
}
ViewHolder holder=(ViewHolder)rowView.getTag();
holder.name.setText(pass.toString());
holder.back_name.setText(pass.toString());
if (pass.getType() == PasswordItem.TYPE_CATEGORY) {
holder.name.setTextColor(this.activity.getResources().getColor(android.R.color.holo_blue_dark));
holder.name.setTypeface(Typeface.create(Typeface.DEFAULT,Typeface.BOLD));
holder.type.setText(""String_Node_Str"");
}
 else {
holder.type.setText(""String_Node_Str"");
holder.name.setTextColor(this.activity.getResources().getColor(android.R.color.holo_orange_dark));
holder.name.setTypeface(Typeface.create(Typeface.DEFAULT,Typeface.NORMAL));
holder.back_name.setTextColor(this.activity.getResources().getColor(android.R.color.white));
holder.back_name.setTypeface(Typeface.create(Typeface.DEFAULT,Typeface.BOLD_ITALIC));
}
return rowView;
}","@Override public View getView(int i,View convertView,ViewGroup viewGroup){
  View rowView=convertView;
  final PasswordItem pass=values.get(i);
  if (rowView == null) {
    LayoutInflater inflater=(LayoutInflater)activity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    rowView=inflater.inflate(R.layout.password_row_layout,viewGroup,false);
    ViewHolder viewHolder=new ViewHolder();
    viewHolder.name=(TextView)rowView.findViewById(R.id.label);
    viewHolder.back_name=(TextView)rowView.findViewById(R.id.label_back);
    viewHolder.type=(TextView)rowView.findViewById(R.id.type);
    rowView.setTag(viewHolder);
  }
  ViewHolder holder=(ViewHolder)rowView.getTag();
  holder.name.setText(pass.toString());
  holder.back_name.setText(pass.toString());
  if (pass.getType() == PasswordItem.TYPE_CATEGORY) {
    holder.name.setTextColor(this.activity.getResources().getColor(android.R.color.holo_blue_dark));
    holder.name.setTypeface(Typeface.create(Typeface.DEFAULT,Typeface.BOLD));
    holder.type.setText(""String_Node_Str"");
  }
 else {
    holder.type.setText(""String_Node_Str"");
    holder.name.setTextColor(this.activity.getResources().getColor(android.R.color.holo_orange_dark));
    holder.name.setTypeface(Typeface.create(Typeface.DEFAULT,Typeface.NORMAL));
    holder.back_name.setTextColor(this.activity.getResources().getColor(android.R.color.white));
    holder.back_name.setTypeface(Typeface.create(Typeface.DEFAULT,Typeface.BOLD_ITALIC));
    View.OnClickListener onClickListener=new View.OnClickListener(){
      @Override public void onClick(      View view){
switch (view.getId()) {
case R.id.crypto_show_button:
          activity.decryptPassword(pass);
        break;
case R.id.crypto_delete_button:
      activity.deletePassword(pass);
    break;
}
}
}
;
((ImageButton)rowView.findViewById(R.id.crypto_show_button)).setOnClickListener(onClickListener);
((ImageButton)rowView.findViewById(R.id.crypto_delete_button)).setOnClickListener(onClickListener);
}
return rowView;
}"
3592,"@Override public View getView(final int position,View convertView,ViewGroup parent){
  convertView=LayoutInflater.from(MainActivity.this).inflate(R.layout.view_list_item,null);
  WaterDrop drop=(WaterDrop)convertView.findViewById(R.id.drop);
  drop.setText(String.valueOf(position));
  drop.setOnDragCompeteListener(new OnDragCompeteListener(){
    @Override public void onDrag(){
      Toast.makeText(MainActivity.this,""String_Node_Str"" + position,Toast.LENGTH_SHORT).show();
    }
  }
);
  return convertView;
}","@Override public View getView(final int position,View convertView,ViewGroup parent){
  if (convertView == null) {
    convertView=LayoutInflater.from(MainActivity.this).inflate(R.layout.view_list_item,null);
  }
  WaterDrop drop=(WaterDrop)convertView.findViewById(R.id.drop);
  drop.setText(String.valueOf(position));
  drop.setOnDragCompeteListener(new OnDragCompeteListener(){
    @Override public void onDrag(){
      Toast.makeText(MainActivity.this,""String_Node_Str"" + position,Toast.LENGTH_SHORT).show();
    }
  }
);
  return convertView;
}"
3593,"public void finish(View target,float x,float y){
  mDropCover.finish(target,x,y);
  mDropCover.setOnDragCompeteListener(null);
}","public void finish(final View target,final float x,final float y){
  target.postDelayed(new Runnable(){
    @Override public void run(){
      mDropCover.finish(target,x,y);
      mDropCover.setOnDragCompeteListener(null);
    }
  }
,100);
}"
3594,"/** 
 * Add a class that has just been scanned (as opposed to just referenced by a scanned class). Not threadsafe, should be run in single threaded context.
 */
static ClassInfo addScannedClass(final String className,final int classModifiers,final boolean isInterface,final boolean isAnnotation,final Map<String,ClassInfo> classNameToClassInfo,final ClasspathElement classpathElement,final ScanSpec scanSpec,final LogNode log){
  boolean classEncounteredMultipleTimes=false;
  ClassInfo classInfo=classNameToClassInfo.get(className);
  if (classInfo == null) {
    classNameToClassInfo.put(className,classInfo=new ClassInfo(className,classModifiers,false));
  }
 else {
    if (!classInfo.isExternalClass) {
      classEncounteredMultipleTimes=true;
    }
  }
  final ModuleRef modRef=classpathElement.getClasspathElementModuleRef();
  final File file=modRef != null ? null : classpathElement.getClasspathElementFile(log);
  if ((classInfo.moduleRef != null && modRef != null && !classInfo.moduleRef.equals(modRef)) || (classInfo.classpathElementFile != null && file != null && !classInfo.classpathElementFile.equals(file))) {
    classEncounteredMultipleTimes=true;
  }
  if (classEncounteredMultipleTimes) {
    if (log != null) {
      log.log(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  if (classInfo.classpathElementFile == null) {
    classInfo.classpathElementFile=file;
    classInfo.jarfilePackageRoot=classpathElement.getJarfilePackageRoot();
  }
  if (classInfo.moduleRef == null) {
    classInfo.moduleRef=modRef;
  }
  final ClassLoader[] classLoaders=classpathElement.getClassLoaders();
  if (classInfo.classLoaders == null) {
    classInfo.classLoaders=classLoaders;
  }
 else   if (classLoaders != null && !classInfo.classLoaders.equals(classLoaders)) {
    final LinkedHashSet<ClassLoader> allClassLoaders=new LinkedHashSet<>(Arrays.asList(classInfo.classLoaders));
    for (    final ClassLoader classLoader : classLoaders) {
      allClassLoaders.add(classLoader);
    }
    final List<ClassLoader> classLoaderOrder=new ArrayList<>(allClassLoaders);
    classInfo.classLoaders=classLoaderOrder.toArray(new ClassLoader[classLoaderOrder.size()]);
  }
  classInfo.isExternalClass=false;
  classInfo.modifiers|=classModifiers;
  classInfo.isInterface|=isInterface;
  classInfo.isAnnotation|=isAnnotation;
  return classInfo;
}","/** 
 * Add a class that has just been scanned (as opposed to just referenced by a scanned class). Not threadsafe, should be run in single threaded context.
 */
static ClassInfo addScannedClass(final String className,final int classModifiers,final boolean isInterface,final boolean isAnnotation,final Map<String,ClassInfo> classNameToClassInfo,final ClasspathElement classpathElement,final ScanSpec scanSpec,final LogNode log){
  boolean classEncounteredMultipleTimes=false;
  ClassInfo classInfo=classNameToClassInfo.get(className);
  if (classInfo == null) {
    classNameToClassInfo.put(className,classInfo=new ClassInfo(className,classModifiers,false));
  }
 else {
    if (!classInfo.isExternalClass) {
      classEncounteredMultipleTimes=true;
    }
  }
  final ModuleRef modRef=classpathElement.getClasspathElementModuleRef();
  final File file=modRef != null ? null : classpathElement.getClasspathElementFile(log);
  if ((classInfo.moduleRef != null && modRef != null && !classInfo.moduleRef.equals(modRef)) || (classInfo.classpathElementFile != null && file != null && !classInfo.classpathElementFile.equals(file))) {
    classEncounteredMultipleTimes=true;
  }
  if (classEncounteredMultipleTimes) {
    if (log != null) {
      log.log(""String_Node_Str"" + className + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  if (classInfo.classpathElementFile == null) {
    classInfo.classpathElementFile=file;
    classInfo.jarfilePackageRoot=classpathElement.getJarfilePackageRoot();
  }
  if (classInfo.moduleRef == null) {
    classInfo.moduleRef=modRef;
  }
  final ClassLoader[] classLoaders=classpathElement.getClassLoaders();
  if (classInfo.classLoaders == null) {
    classInfo.classLoaders=classLoaders;
  }
 else   if (classLoaders != null && !Arrays.equals(classInfo.classLoaders,classLoaders)) {
    final LinkedHashSet<ClassLoader> allClassLoaders=new LinkedHashSet<>(Arrays.asList(classInfo.classLoaders));
    for (    final ClassLoader classLoader : classLoaders) {
      allClassLoaders.add(classLoader);
    }
    final List<ClassLoader> classLoaderOrder=new ArrayList<>(allClassLoaders);
    classInfo.classLoaders=classLoaderOrder.toArray(new ClassLoader[classLoaderOrder.size()]);
  }
  classInfo.isExternalClass=false;
  classInfo.modifiers|=classModifiers;
  classInfo.isInterface|=isInterface;
  classInfo.isAnnotation|=isAnnotation;
  return classInfo;
}"
3595,"@Override public boolean equals(final Object obj){
  if (!(obj instanceof ModuleRef)) {
    return false;
  }
  final ModuleRef mr=(ModuleRef)obj;
  return reference.equals(this.reference) && mr.layer.equals(this.layer);
}","@Override public boolean equals(final Object obj){
  if (!(obj instanceof ModuleRef)) {
    return false;
  }
  final ModuleRef mr=(ModuleRef)obj;
  return mr.reference.equals(this.reference) && mr.layer.equals(this.layer);
}"
3596,"/** 
 * Parses and returns Integer, Long or Double type. <pre> Number  Minus? IntegralPart FractionalPart? ExponentPart? Minus  ""-"" IntegralPart  ""0"" / [1-9] [0-9] FractionalPart  ""."" [0-9]+ ExponentPart  ( ""e"" / ""E"" ) ( ""+"" / ""-"" )? [0-9]+ </pre>
 */
private Object parseNumber() throws ParseException {
  final int startIdx=getPosition();
  if (peek() == '-') {
    next();
  }
  final int integralStartIdx=getPosition();
  for (; hasMore(); next()) {
    final char c=peek();
    if (c < '0' || c > '9') {
      break;
    }
  }
  final int integralEndIdx=getPosition();
  final int numIntegralDigits=integralEndIdx - integralStartIdx;
  if (numIntegralDigits == 0) {
    throw new ParseException(this,""String_Node_Str"");
  }
  final boolean hasFractionalPart=peek() == '.';
  if (hasFractionalPart) {
    next();
    for (; hasMore(); next()) {
      final char c=peek();
      if (c < '0' || c > '9') {
        break;
      }
    }
    if (getPosition() - (integralEndIdx + 1) == 0) {
      throw new ParseException(this,""String_Node_Str"");
    }
  }
  final boolean hasExponentPart=peek() == '.';
  if (hasExponentPart) {
    next();
    final char sign=peek();
    if (sign == '-' || sign == '+') {
      next();
    }
    final int exponentStart=getPosition();
    for (; hasMore(); next()) {
      final char c=peek();
      if (c < '0' || c > '9') {
        break;
      }
    }
    if (getPosition() - exponentStart == 0) {
      throw new ParseException(this,""String_Node_Str"");
    }
  }
  final int endIdx=getPosition();
  final String numberStr=getSubstring(startIdx,endIdx).toString();
  if (hasFractionalPart || hasExponentPart) {
    return Double.valueOf(numberStr);
  }
 else   if (numIntegralDigits < 9) {
    return Integer.valueOf(numberStr);
  }
 else   if (numIntegralDigits == 9) {
    final long longVal=Long.valueOf(numberStr);
    if (longVal >= Integer.MIN_VALUE && longVal < Integer.MAX_VALUE) {
      return Integer.valueOf((int)longVal);
    }
 else {
      return Long.valueOf(longVal);
    }
  }
 else {
    return Long.valueOf(numberStr);
  }
}","/** 
 * Parses and returns Integer, Long or Double type. <pre> Number  Minus? IntegralPart FractionalPart? ExponentPart? Minus  ""-"" IntegralPart  ""0"" / [1-9] [0-9] FractionalPart  ""."" [0-9]+ ExponentPart  ( ""e"" / ""E"" ) ( ""+"" / ""-"" )? [0-9]+ </pre>
 */
private Object parseNumber() throws ParseException {
  final int startIdx=getPosition();
  if (peek() == '-') {
    next();
  }
  final int integralStartIdx=getPosition();
  for (; hasMore(); next()) {
    final char c=peek();
    if (c < '0' || c > '9') {
      break;
    }
  }
  final int integralEndIdx=getPosition();
  final int numIntegralDigits=integralEndIdx - integralStartIdx;
  if (numIntegralDigits == 0) {
    throw new ParseException(this,""String_Node_Str"");
  }
  final boolean hasFractionalPart=peek() == '.';
  if (hasFractionalPart) {
    next();
    for (; hasMore(); next()) {
      final char c=peek();
      if (c < '0' || c > '9') {
        break;
      }
    }
    if (getPosition() - (integralEndIdx + 1) == 0) {
      throw new ParseException(this,""String_Node_Str"");
    }
  }
  final boolean hasExponentPart=peek() == '.';
  if (hasExponentPart) {
    next();
    final char sign=peek();
    if (sign == '-' || sign == '+') {
      next();
    }
    final int exponentStart=getPosition();
    for (; hasMore(); next()) {
      final char c=peek();
      if (c < '0' || c > '9') {
        break;
      }
    }
    if (getPosition() - exponentStart == 0) {
      throw new ParseException(this,""String_Node_Str"");
    }
  }
  final int endIdx=getPosition();
  final String numberStr=getSubstring(startIdx,endIdx).toString();
  if (hasFractionalPart || hasExponentPart) {
    return Double.valueOf(numberStr);
  }
 else   if (numIntegralDigits < 9) {
    return Integer.valueOf(numberStr);
  }
 else   if (numIntegralDigits == 9) {
    final long longVal=Long.parseLong(numberStr);
    if (longVal >= Integer.MIN_VALUE && longVal < Integer.MAX_VALUE) {
      return Integer.valueOf((int)longVal);
    }
 else {
      return Long.valueOf(longVal);
    }
  }
 else {
    return Long.valueOf(numberStr);
  }
}"
3597,"public AnnotationClassRef(final String classRefTypeDescriptor){
  this.typeDescriptor=classRefTypeDescriptor;
}","AnnotationClassRef(final String typeDescriptorStr){
  this.typeDescriptorStr=typeDescriptorStr;
}"
3598,"/** 
 * Get the type signature for a type reference used in an annotation parameter. <p> Call getType() to get a   {@code Class<?>} reference for this class.
 * @return The type signature of the annotation class ref.
 */
public TypeSignature getTypeSignature(){
  if (typeSignature == null) {
    try {
      typeSignature=TypeSignature.parse(typeDescriptor,scanResult);
    }
 catch (    final ParseException e) {
      throw new IllegalArgumentException(e);
    }
  }
  return typeSignature;
}","/** 
 * Get the type signature for a type reference used in an annotation parameter.
 * @return The type signature of the annotation class ref.
 */
private TypeSignature getTypeSignature(){
  if (typeSignature == null) {
    try {
      final TypeSignature typeSig=TypeSignature.parse(typeDescriptorStr,scanResult);
      typeSignature=typeSig;
    }
 catch (    final ParseException e) {
      throw new IllegalArgumentException(e);
    }
  }
  return typeSignature;
}"
3599,"/** 
 * Get the class name of the enum.
 * @return The name of the enum class.
 */
public String getClassName(){
  return className;
}","@Override protected String getClassName(){
  return className;
}"
3600,"/** 
 * Find the set difference between this ClassInfoList and another ClassInfoList, i.e. (this \ other).
 * @param other The other  {@link ClassInfoList} to subtract from this one.
 * @return The set difference of this {@link ClassInfoList} and other, i.e. (this \ other).
 */
public ClassInfoList exclude(final ClassInfoList other){
  final Set<ClassInfo> reachableClassesDifference=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesDifference=directlyRelatedClasses == null ? new HashSet<>() : new HashSet<>(directlyRelatedClasses);
  reachableClassesDifference.removeAll(other);
  if (other.directlyRelatedClasses != null) {
    directlyRelatedClassesDifference.removeAll(other.directlyRelatedClasses);
  }
  return new ClassInfoList(reachableClassesDifference,directlyRelatedClassesDifference);
}","/** 
 * Find the set difference between this ClassInfoList and another ClassInfoList, i.e. (this \ other).
 * @param other The other  {@link ClassInfoList} to subtract from this one.
 * @return The set difference of this {@link ClassInfoList} and other, i.e. (this \ other).
 */
public ClassInfoList exclude(final ClassInfoList other){
  final Set<ClassInfo> reachableClassesDifference=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesDifference=new HashSet<>();
  if (directlyRelatedClasses != null) {
    directlyRelatedClassesDifference.addAll(directlyRelatedClasses);
  }
  reachableClassesDifference.removeAll(other);
  if (other.directlyRelatedClasses != null) {
    directlyRelatedClassesDifference.removeAll(other.directlyRelatedClasses);
  }
  return new ClassInfoList(reachableClassesDifference,directlyRelatedClassesDifference);
}"
3601,"/** 
 * Find the intersection of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to intersect with this one.
 * @return The intersection of this {@link ClassInfoList} with the others.
 */
public ClassInfoList intersect(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesIntersection=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesIntersecion=directlyRelatedClasses == null ? new HashSet<>() : new HashSet<>(directlyRelatedClasses);
  for (  final ClassInfoList other : others) {
    reachableClassesIntersection.retainAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesIntersecion.retainAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesIntersection,directlyRelatedClassesIntersecion);
}","/** 
 * Find the intersection of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to intersect with this one.
 * @return The intersection of this {@link ClassInfoList} with the others.
 */
public ClassInfoList intersect(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesIntersection=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesIntersection=new HashSet<>();
  if (directlyRelatedClasses != null) {
    directlyRelatedClassesIntersection.addAll(directlyRelatedClasses);
  }
  for (  final ClassInfoList other : others) {
    reachableClassesIntersection.retainAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesIntersection.retainAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesIntersection,directlyRelatedClassesIntersection);
}"
3602,"/** 
 * Find the union of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to union with this one.
 * @return The union of this {@link ClassInfoList} with the others.
 */
public ClassInfoList union(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesUnion=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesUnion=directlyRelatedClasses == null ? new HashSet<>() : new HashSet<>(directlyRelatedClasses);
  for (  final ClassInfoList other : others) {
    reachableClassesUnion.addAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesUnion.addAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesUnion,directlyRelatedClassesUnion);
}","/** 
 * Find the union of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to union with this one.
 * @return The union of this {@link ClassInfoList} with the others.
 */
public ClassInfoList union(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesUnion=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesUnion=new HashSet<>();
  if (directlyRelatedClasses != null) {
    directlyRelatedClassesUnion.addAll(directlyRelatedClasses);
  }
  for (  final ClassInfoList other : others) {
    reachableClassesUnion.addAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesUnion.addAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesUnion,directlyRelatedClassesUnion);
}"
3603,"@Override public int hashCode(){
  int h=annotationName.hashCode();
  if (annotationParamValues != null) {
    for (int i=0; i < annotationParamValues.size(); i++) {
      final AnnotationParamValue e=annotationParamValues.get(i);
      h=h * 7 + e.getParamName().hashCode() * 3 + e.getParamValue().hashCode();
    }
  }
  return h;
}","@Override public int hashCode(){
  int h=getAnnotationName().hashCode();
  if (annotationParamValues != null) {
    for (int i=0; i < annotationParamValues.size(); i++) {
      final AnnotationParamValue e=annotationParamValues.get(i);
      h=h * 7 + e.getParamName().hashCode() * 3 + e.getParamValue().hashCode();
    }
  }
  return h;
}"
3604,"/** 
 * Get the parameter value of the annotation.
 * @return The annotation parameter values.
 */
public List<AnnotationParamValue> getAnnotationParamValues(){
  return annotationParamValues;
}","/** 
 * Get the parameter value of this annotation, including any default values inherited from the annotation class definition.
 * @return The annotation parameter values, including any default values, or the empty list if none.
 */
public List<AnnotationParamValue> getAnnotationParamValues(){
  final List<AnnotationParamValue> defaultParamValues=classInfo.annotationDefaultParamValues;
  if (defaultParamValues == null && annotationParamValues == null) {
    return Collections.<AnnotationParamValue>emptyList();
  }
 else   if (defaultParamValues == null) {
    return annotationParamValues;
  }
 else   if (annotationParamValues == null) {
    return defaultParamValues;
  }
  final Map<String,Object> allParamValues=new HashMap<>();
  for (  final AnnotationParamValue defaultParamValue : defaultParamValues) {
    allParamValues.put(defaultParamValue.paramName,defaultParamValue.paramValue.get());
  }
  for (  final AnnotationParamValue annotationParamValue : this.annotationParamValues) {
    allParamValues.put(annotationParamValue.paramName,annotationParamValue.paramValue.get());
  }
  final List<AnnotationParamValue> result=new ArrayList<>();
  for (  final Entry<String,Object> ent : allParamValues.entrySet()) {
    result.add(new AnnotationParamValue(ent.getKey(),ent.getValue()));
  }
  Collections.sort(result);
  return result;
}"
3605,"@Override public int compareTo(final AnnotationInfo o){
  final int diff=annotationName.compareTo(o.annotationName);
  if (diff != 0) {
    return diff;
  }
  if (annotationParamValues == null && o.annotationParamValues == null) {
    return 0;
  }
 else   if (annotationParamValues == null) {
    return -1;
  }
 else   if (o.annotationParamValues == null) {
    return 1;
  }
 else {
    for (int i=0, max=Math.max(annotationParamValues.size(),o.annotationParamValues.size()); i < max; i++) {
      if (i >= annotationParamValues.size()) {
        return -1;
      }
 else       if (i >= o.annotationParamValues.size()) {
        return 1;
      }
 else {
        final int diff2=annotationParamValues.get(i).compareTo(o.annotationParamValues.get(i));
        if (diff2 != 0) {
          return diff2;
        }
      }
    }
  }
  return 0;
}","@Override public int compareTo(final AnnotationInfo o){
  final int diff=getAnnotationName().compareTo(o.getAnnotationName());
  if (diff != 0) {
    return diff;
  }
  if (annotationParamValues == null && o.annotationParamValues == null) {
    return 0;
  }
 else   if (annotationParamValues == null) {
    return -1;
  }
 else   if (o.annotationParamValues == null) {
    return 1;
  }
 else {
    for (int i=0, max=Math.max(annotationParamValues.size(),o.annotationParamValues.size()); i < max; i++) {
      if (i >= annotationParamValues.size()) {
        return -1;
      }
 else       if (i >= o.annotationParamValues.size()) {
        return 1;
      }
 else {
        final int diff2=annotationParamValues.get(i).compareTo(o.annotationParamValues.get(i));
        if (diff2 != 0) {
          return diff2;
        }
      }
    }
  }
  return 0;
}"
3606,"/** 
 * @param annotationName The name of the annotation.
 * @param annotationParamValues The annotation parameter values, or null if none.
 */
public AnnotationInfo(final String annotationName,final List<AnnotationParamValue> annotationParamValues){
  this.annotationName=annotationName;
  if (annotationParamValues != null) {
    Collections.sort(annotationParamValues);
  }
  this.annotationParamValues=annotationParamValues;
}","/** 
 * @param annotationName The name of the annotation.
 * @param annotationParamValues The annotation parameter values, or null if none.
 */
public AnnotationInfo(final String annotationName,final List<AnnotationParamValue> annotationParamValues){
  this.annotationName=annotationName;
  this.annotationParamValues=annotationParamValues;
}"
3607,"/** 
 * Get the parameter value of this annotation, including any default values inherited from the annotation class definition, or the empty list if none.
 * @return The annotation parameter values, including any default values, or the empty list if none.
 */
public List<AnnotationParamValue> getAnnotationParamValues(){
  final List<AnnotationParamValue> defaultParamValues=classInfo.annotationDefaultParamValues;
  if (defaultParamValues == null && annotationParamValues == null) {
    return Collections.<AnnotationParamValue>emptyList();
  }
 else   if (defaultParamValues == null) {
    return annotationParamValues;
  }
 else   if (annotationParamValues == null) {
    return defaultParamValues;
  }
  final Map<String,Object> allParamValues=new HashMap<>();
  for (  final AnnotationParamValue defaultParamValue : defaultParamValues) {
    allParamValues.put(defaultParamValue.paramName,defaultParamValue.paramValue.get());
  }
  for (  final AnnotationParamValue annotationParamValue : this.annotationParamValues) {
    allParamValues.put(annotationParamValue.paramName,annotationParamValue.paramValue.get());
  }
  final List<AnnotationParamValue> result=new ArrayList<>();
  for (  final Entry<String,Object> ent : allParamValues.entrySet()) {
    result.add(new AnnotationParamValue(ent.getKey(),ent.getValue()));
  }
  Collections.sort(result);
  return result;
}","/** 
 * Get the parameter value of this annotation, including any default values inherited from the annotation class definition, or the empty list if none.
 * @return The annotation parameter values, including any default values, or the empty list if none.
 */
public List<AnnotationParamValue> getAnnotationParamValues(){
  if (classInfo == null) {
    return Collections.<AnnotationParamValue>emptyList();
  }
  final List<AnnotationParamValue> defaultParamValues=classInfo.annotationDefaultParamValues;
  if (defaultParamValues == null && annotationParamValues == null) {
    return Collections.<AnnotationParamValue>emptyList();
  }
 else   if (defaultParamValues == null) {
    return annotationParamValues;
  }
 else   if (annotationParamValues == null) {
    return defaultParamValues;
  }
  final Map<String,Object> allParamValues=new HashMap<>();
  for (  final AnnotationParamValue defaultParamValue : defaultParamValues) {
    allParamValues.put(defaultParamValue.paramName,defaultParamValue.paramValue.get());
  }
  for (  final AnnotationParamValue annotationParamValue : this.annotationParamValues) {
    allParamValues.put(annotationParamValue.paramName,annotationParamValue.paramValue.get());
  }
  final List<AnnotationParamValue> result=new ArrayList<>();
  for (  final Entry<String,Object> ent : allParamValues.entrySet()) {
    result.add(new AnnotationParamValue(ent.getKey(),ent.getValue()));
  }
  Collections.sort(result);
  return result;
}"
3608,"/** 
 * Add field info. 
 */
void addFieldInfo(final FieldInfoList fieldInfoList,final Map<String,ClassInfo> classNameToClassInfo){
  for (  final FieldInfo fieldInfo : fieldInfoList) {
    fieldInfo.definingClassInfo=this;
    final AnnotationInfoList fieldAnnotationInfoList=fieldInfo.annotationInfo;
    if (fieldAnnotationInfoList != null) {
      for (      final AnnotationInfo fieldAnnotationInfo : fieldAnnotationInfoList) {
        final ClassInfo annotationClassInfo=getOrCreateClassInfo(fieldAnnotationInfo.getName(),ANNOTATION_CLASS_MODIFIER,scanSpec,classNameToClassInfo);
        this.addRelatedClass(RelType.FIELD_ANNOTATIONS,annotationClassInfo);
        annotationClassInfo.addRelatedClass(RelType.CLASSES_WITH_FIELD_ANNOTATION,this);
        fieldAnnotationInfo.setClassInfo(annotationClassInfo);
      }
    }
  }
  if (this.fieldInfo == null) {
    this.fieldInfo=fieldInfoList;
  }
 else {
    this.fieldInfo.addAll(fieldInfoList);
  }
}","/** 
 * Add field info. 
 */
void addFieldInfo(final FieldInfoList fieldInfoList,final Map<String,ClassInfo> classNameToClassInfo){
  for (  final FieldInfo fieldInfo : fieldInfoList) {
    final AnnotationInfoList fieldAnnotationInfoList=fieldInfo.annotationInfo;
    if (fieldAnnotationInfoList != null) {
      for (      final AnnotationInfo fieldAnnotationInfo : fieldAnnotationInfoList) {
        final ClassInfo annotationClassInfo=getOrCreateClassInfo(fieldAnnotationInfo.getName(),ANNOTATION_CLASS_MODIFIER,scanSpec,classNameToClassInfo);
        this.addRelatedClass(RelType.FIELD_ANNOTATIONS,annotationClassInfo);
        annotationClassInfo.addRelatedClass(RelType.CLASSES_WITH_FIELD_ANNOTATION,this);
        fieldAnnotationInfo.setClassInfo(annotationClassInfo);
      }
    }
    fieldInfo.definingClassInfo=this;
  }
  if (this.fieldInfo == null) {
    this.fieldInfo=fieldInfoList;
  }
 else {
    this.fieldInfo.addAll(fieldInfoList);
  }
}"
3609,"/** 
 * Add method info. 
 */
void addMethodInfo(final MethodInfoList methodInfoList,final Map<String,ClassInfo> classNameToClassInfo){
  for (  final MethodInfo methodInfo : methodInfoList) {
    methodInfo.definingClassInfo=this;
    final AnnotationInfoList methodAnnotationInfoList=methodInfo.annotationInfo;
    if (methodAnnotationInfoList != null) {
      for (      final AnnotationInfo methodAnnotationInfo : methodAnnotationInfoList) {
        final ClassInfo annotationClassInfo=getOrCreateClassInfo(methodAnnotationInfo.getName(),ANNOTATION_CLASS_MODIFIER,scanSpec,classNameToClassInfo);
        this.addRelatedClass(RelType.METHOD_ANNOTATIONS,annotationClassInfo);
        annotationClassInfo.addRelatedClass(RelType.CLASSES_WITH_METHOD_ANNOTATION,this);
        methodAnnotationInfo.setClassInfo(annotationClassInfo);
      }
    }
    final AnnotationInfo[][] methodParamAnnotationInfoList=methodInfo.parameterAnnotationInfo;
    if (methodParamAnnotationInfoList != null) {
      for (int i=0; i < methodParamAnnotationInfoList.length; i++) {
        final AnnotationInfo[] paramAnnotationInfoArr=methodParamAnnotationInfoList[i];
        if (paramAnnotationInfoArr != null) {
          for (int j=0; j < paramAnnotationInfoArr.length; j++) {
            final AnnotationInfo methodParamAnnotationInfo=paramAnnotationInfoArr[j];
            final ClassInfo annotationClassInfo=getOrCreateClassInfo(methodParamAnnotationInfo.getName(),ANNOTATION_CLASS_MODIFIER,scanSpec,classNameToClassInfo);
            methodParamAnnotationInfo.setClassInfo(annotationClassInfo);
          }
        }
      }
    }
    methodInfo.definingClassInfo=this;
  }
  if (this.methodInfo == null) {
    this.methodInfo=methodInfoList;
  }
 else {
    this.methodInfo.addAll(methodInfoList);
  }
}","/** 
 * Add method info. 
 */
void addMethodInfo(final MethodInfoList methodInfoList,final Map<String,ClassInfo> classNameToClassInfo){
  for (  final MethodInfo methodInfo : methodInfoList) {
    final AnnotationInfoList methodAnnotationInfoList=methodInfo.annotationInfo;
    if (methodAnnotationInfoList != null) {
      for (      final AnnotationInfo methodAnnotationInfo : methodAnnotationInfoList) {
        final ClassInfo annotationClassInfo=getOrCreateClassInfo(methodAnnotationInfo.getName(),ANNOTATION_CLASS_MODIFIER,scanSpec,classNameToClassInfo);
        this.addRelatedClass(RelType.METHOD_ANNOTATIONS,annotationClassInfo);
        annotationClassInfo.addRelatedClass(RelType.CLASSES_WITH_METHOD_ANNOTATION,this);
        methodAnnotationInfo.setClassInfo(annotationClassInfo);
      }
    }
    final AnnotationInfo[][] methodParamAnnotationInfoList=methodInfo.parameterAnnotationInfo;
    if (methodParamAnnotationInfoList != null) {
      for (int i=0; i < methodParamAnnotationInfoList.length; i++) {
        final AnnotationInfo[] paramAnnotationInfoArr=methodParamAnnotationInfoList[i];
        if (paramAnnotationInfoArr != null) {
          for (int j=0; j < paramAnnotationInfoArr.length; j++) {
            final AnnotationInfo methodParamAnnotationInfo=paramAnnotationInfoArr[j];
            final ClassInfo annotationClassInfo=getOrCreateClassInfo(methodParamAnnotationInfo.getName(),ANNOTATION_CLASS_MODIFIER,scanSpec,classNameToClassInfo);
            methodParamAnnotationInfo.setClassInfo(annotationClassInfo);
          }
        }
      }
    }
    methodInfo.definingClassInfo=this;
  }
  if (this.methodInfo == null) {
    this.methodInfo=methodInfoList;
  }
 else {
    this.methodInfo.addAll(methodInfoList);
  }
}"
3610,"void logTo(final LogNode log){
  if (log != null) {
    final LogNode subLog=log.log(""String_Node_Str"" + (isAnnotation ? ""String_Node_Str"" : isInterface ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ className);
    if (superclassName != null) {
      subLog.log(""String_Node_Str"" + (isInterface && !isAnnotation ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ superclassName);
    }
    if (implementedInterfaces != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",implementedInterfaces));
    }
    if (classAnnotations != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",classAnnotations));
    }
    if (methodInfoList != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",methodInfoList));
    }
    if (fieldInfoList != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",fieldInfoList));
    }
    if (typeSignature != null) {
      ClassTypeSignature typeSig=null;
      try {
        typeSig=ClassTypeSignature.parse(typeSignature,null);
      }
 catch (      final ParseException e) {
      }
      subLog.log(""String_Node_Str"" + (typeSig == null ? typeSignature : typeSig.toString(classModifiers,isAnnotation,isInterface,className)));
    }
  }
}","void logTo(final LogNode log){
  if (log != null) {
    final LogNode subLog=log.log(""String_Node_Str"" + (isAnnotation ? ""String_Node_Str"" : isInterface ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ className);
    if (superclassName != null) {
      subLog.log(""String_Node_Str"" + (isInterface && !isAnnotation ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ superclassName);
    }
    if (implementedInterfaces != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",implementedInterfaces));
    }
    if (classAnnotations != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",classAnnotations));
    }
    if (annotationParamDefaultValues != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",annotationParamDefaultValues));
    }
    if (methodInfoList != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",methodInfoList));
    }
    if (fieldInfoList != null) {
      subLog.log(""String_Node_Str"" + Join.join(""String_Node_Str"",fieldInfoList));
    }
    if (typeSignature != null) {
      ClassTypeSignature typeSig=null;
      try {
        typeSig=ClassTypeSignature.parse(typeSignature,null);
      }
 catch (      final ParseException e) {
      }
      subLog.log(""String_Node_Str"" + (typeSig == null ? typeSignature : typeSig.toString(classModifiers,isAnnotation,isInterface,className)));
    }
  }
}"
3611,"public static void main(final String[] args){
  final ScanResult scanResult=new FastClasspathScanner().whitelistPackages(""String_Node_Str"").blacklistPackages(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").enableMethodInfo().ignoreMethodVisibility().enableFieldInfo().ignoreFieldVisibility().enableAnnotationInfo().verbose().scan();
  System.out.println(scanResult.generateClassGraphDotFile(12,8,false,false));
}","public static void main(final String[] args) throws IOException {
  final ScanResult scanResult=new FastClasspathScanner().whitelistPackages(""String_Node_Str"").blacklistPackages(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").enableMethodInfo().ignoreMethodVisibility().enableFieldInfo().ignoreFieldVisibility().enableAnnotationInfo().scan();
  try (PrintWriter writer=new PrintWriter(""String_Node_Str"")){
    writer.print(scanResult.getAllClasses().generateGraphVizDotFile(12,8,false,false,true));
  }
 }"
3612,"/** 
 * Find the set difference between this ClassInfoList and another ClassInfoList, i.e. (this \ other).
 * @param other The other  {@link ClassInfoList} to subtract from this one.
 * @return The set difference of this {@link ClassInfoList} and other, i.e. (this \ other).
 */
public ClassInfoList exclude(final ClassInfoList other){
  final Set<ClassInfo> reachableClassesDifference=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesDifference=directlyRelatedClasses == null ? new HashSet<>() : new HashSet<>(directlyRelatedClasses);
  reachableClassesDifference.removeAll(other);
  if (other.directlyRelatedClasses != null) {
    directlyRelatedClassesDifference.removeAll(other.directlyRelatedClasses);
  }
  return new ClassInfoList(reachableClassesDifference,directlyRelatedClassesDifference);
}","/** 
 * Find the set difference between this ClassInfoList and another ClassInfoList, i.e. (this \ other).
 * @param other The other  {@link ClassInfoList} to subtract from this one.
 * @return The set difference of this {@link ClassInfoList} and other, i.e. (this \ other).
 */
public ClassInfoList exclude(final ClassInfoList other){
  final Set<ClassInfo> reachableClassesDifference=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesDifference=directlyRelatedClasses == null ? new HashSet<ClassInfo>() : new HashSet<>(directlyRelatedClasses);
  reachableClassesDifference.removeAll(other);
  if (other.directlyRelatedClasses != null) {
    directlyRelatedClassesDifference.removeAll(other.directlyRelatedClasses);
  }
  return new ClassInfoList(reachableClassesDifference,directlyRelatedClassesDifference);
}"
3613,"/** 
 * Find the intersection of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to intersect with this one.
 * @return The intersection of this {@link ClassInfoList} with the others.
 */
public ClassInfoList intersect(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesIntersection=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesIntersecion=directlyRelatedClasses == null ? new HashSet<>() : new HashSet<>(directlyRelatedClasses);
  for (  final ClassInfoList other : others) {
    reachableClassesIntersection.retainAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesIntersecion.retainAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesIntersection,directlyRelatedClassesIntersecion);
}","/** 
 * Find the intersection of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to intersect with this one.
 * @return The intersection of this {@link ClassInfoList} with the others.
 */
public ClassInfoList intersect(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesIntersection=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesIntersecion=directlyRelatedClasses == null ? new HashSet<ClassInfo>() : new HashSet<>(directlyRelatedClasses);
  for (  final ClassInfoList other : others) {
    reachableClassesIntersection.retainAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesIntersecion.retainAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesIntersection,directlyRelatedClassesIntersecion);
}"
3614,"/** 
 * Find the union of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to union with this one.
 * @return The union of this {@link ClassInfoList} with the others.
 */
public ClassInfoList union(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesUnion=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesUnion=directlyRelatedClasses == null ? new HashSet<>() : new HashSet<>(directlyRelatedClasses);
  for (  final ClassInfoList other : others) {
    reachableClassesUnion.addAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesUnion.addAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesUnion,directlyRelatedClassesUnion);
}","/** 
 * Find the union of this ClassInfoList with one or more others.
 * @param others The other  {@link ClassInfoList}s to union with this one.
 * @return The union of this {@link ClassInfoList} with the others.
 */
public ClassInfoList union(final ClassInfoList... others){
  final Set<ClassInfo> reachableClassesUnion=new HashSet<>(reachableClasses);
  final Set<ClassInfo> directlyRelatedClassesUnion=directlyRelatedClasses == null ? new HashSet<ClassInfo>() : new HashSet<>(directlyRelatedClasses);
  for (  final ClassInfoList other : others) {
    reachableClassesUnion.addAll(other);
    if (other.directlyRelatedClasses != null) {
      directlyRelatedClassesUnion.addAll(other.directlyRelatedClasses);
    }
  }
  return new ClassInfoList(reachableClassesUnion,directlyRelatedClassesUnion);
}"
3615,"/** 
 * Returns the module location as a File, i.e.   {@code new File(moduleReference.location())}. Returns null for modules that do not have a location. Returns a file that does not exist for ""jrt:/"" (system) module locations.
 */
public File getModuleLocationFile(){
  if (moduleLocationFile == null && moduleLocation != null) {
    moduleLocationFile=new File(moduleLocation);
  }
  return moduleLocationFile;
}","/** 
 * Returns the module location as a File, i.e.   {@code new File(moduleReference.location())}. Returns null for modules that do not have a location, or for system (""jrt:/"") modules.
 */
public File getModuleLocationFile(){
  if (moduleLocationFile == null && moduleLocation != null) {
    if (!isSystemModule()) {
      moduleLocationFile=new File(moduleLocation);
    }
 else {
      return null;
    }
  }
  return moduleLocationFile;
}"
3616,"/** 
 * Returns true if this module's location is a ""jrt:/"" URI, or if it has no location URI. 
 */
public boolean isSystemModule(){
  if (moduleLocation == null) {
    return true;
  }
  final String scheme=moduleLocation.getScheme();
  if (scheme == null) {
    return false;
  }
  return scheme.equalsIgnoreCase(""String_Node_Str"");
}","/** 
 * Returns true if this module's location is a ""jrt:/"" URI, or if it has no location URI. 
 */
public boolean isSystemModule(){
  if (moduleLocation == null) {
    return true;
  }
  final String scheme=moduleLocation.getScheme();
  if (scheme == null) {
    return false;
  }
  return !scheme.equalsIgnoreCase(""String_Node_Str"");
}"
3617,"/** 
 * Returns the list of File objects for unique classpath elements (directories or jarfiles), in classloader resolution order.
 * @return The unique classpath elements.
 */
public List<File> getUniqueClasspathElements(){
  return classpathElementOrderFiles;
}","/** 
 * Returns the list of File objects for unique classpath elements (directories or jarfiles), in classloader resolution order.
 * @return The unique classpath elements.
 */
public List<File> getUniqueClasspathElements(){
  final List<File> classpathElementOrderFiles=new ArrayList<>();
  for (  final ClasspathElement classpathElement : classpathOrder) {
    final ModuleRef modRef=classpathElement.getClasspathElementModuleRef();
    if (modRef != null) {
      if (!modRef.isSystemModule()) {
        classpathElementOrderFiles.add(modRef.getModuleLocationFile());
      }
    }
 else {
      classpathElementOrderFiles.add(classpathElement.getClasspathElementFile(log));
    }
  }
  return classpathElementOrderFiles;
}"
3618,"/** 
 * Returns the list of unique classpath element paths as URLs, in classloader resolution order.
 * @return The unique classpath element URLs.
 */
public List<URL> getUniqueClasspathElementURLs(){
  final List<URL> classpathElementOrderURLs=new ArrayList<>(classpathElementOrderFiles.size());
  for (  final File classpathElementFile : classpathElementOrderFiles) {
    try {
      classpathElementOrderURLs.add(classpathElementFile.toURI().toURL());
    }
 catch (    final MalformedURLException e) {
      throw new RuntimeException(e);
    }
  }
  return classpathElementOrderURLs;
}","/** 
 * Returns the list of unique classpath element paths as URLs, in classloader resolution order.
 * @return The unique classpath element URLs.
 */
public List<URL> getUniqueClasspathElementURLs(){
  final List<URL> classpathElementOrderURLs=new ArrayList<>();
  for (  final ClasspathElement classpathElement : classpathOrder) {
    final ModuleRef modRef=classpathElement.getClasspathElementModuleRef();
    if (modRef != null) {
      try {
        classpathElementOrderURLs.add(modRef.getModuleLocation().toURL());
      }
 catch (      final MalformedURLException e) {
      }
    }
 else {
      try {
        classpathElementOrderURLs.add(classpathElement.getClasspathElementFile(log).toURI().toURL());
      }
 catch (      final MalformedURLException e) {
      }
    }
  }
  return classpathElementOrderURLs;
}"
3619,"/** 
 * The result of a scan. Make sure you call complete() after calling the constructor. 
 */
ScanResult(final ScanSpec scanSpec,final List<ClasspathElement> classpathOrder,final ClassLoader[] envClassLoaderOrder,final ClassGraphBuilder classGraphBuilder,final Map<File,Long> fileToLastModified,final NestedJarHandler nestedJarHandler,final InterruptionChecker interruptionChecker,final LogNode log){
  this.scanSpec=scanSpec;
  this.classpathOrder=classpathOrder;
  this.envClassLoaderOrder=envClassLoaderOrder;
  this.classpathElementOrderFiles=new ArrayList<>();
  for (  final ClasspathElement classpathElement : classpathOrder) {
    classpathElementOrderFiles.add(classpathElement.getClasspathElementFile(log));
  }
  this.fileToLastModified=fileToLastModified;
  this.classGraphBuilder=classGraphBuilder;
  this.nestedJarHandler=nestedJarHandler;
  this.interruptionChecker=interruptionChecker;
  this.log=log;
  if (classGraphBuilder != null) {
    if (classGraphBuilder.getClassNameToClassInfo() != null) {
      for (      final ClassInfo ci : classGraphBuilder.getClassNameToClassInfo().values()) {
        ci.setScanResult(this);
      }
    }
  }
}","/** 
 * The result of a scan. Make sure you call complete() after calling the constructor. 
 */
ScanResult(final ScanSpec scanSpec,final List<ClasspathElement> classpathOrder,final ClassLoader[] envClassLoaderOrder,final ClassGraphBuilder classGraphBuilder,final Map<File,Long> fileToLastModified,final NestedJarHandler nestedJarHandler,final InterruptionChecker interruptionChecker,final LogNode log){
  this.scanSpec=scanSpec;
  this.classpathOrder=classpathOrder;
  this.envClassLoaderOrder=envClassLoaderOrder;
  this.fileToLastModified=fileToLastModified;
  this.classGraphBuilder=classGraphBuilder;
  this.nestedJarHandler=nestedJarHandler;
  this.interruptionChecker=interruptionChecker;
  this.log=log;
  if (classGraphBuilder != null) {
    if (classGraphBuilder.getClassNameToClassInfo() != null) {
      for (      final ClassInfo ci : classGraphBuilder.getClassNameToClassInfo().values()) {
        ci.setScanResult(this);
      }
    }
  }
}"
3620,"/** 
 * Get a map from class name to ClassLoader(s) for the class. 
 */
public Map<String,ClassLoader[]> getClassNameToClassLoaders(){
  return classNameToClassLoaders;
}","/** 
 * Get a map from class name to ClassLoader(s) for the class.
 * @return The map.
 */
public Map<String,ClassLoader[]> getClassNameToClassLoaders(){
  return classNameToClassLoaders;
}"
3621,"private void labelClassNodeHTML(final ClassInfo ci,final String shape,final String boxBgColor,final StringBuilder buf){
  buf.append(""String_Node_Str"" + shape + ""String_Node_Str""+ boxBgColor+ ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"" + ci.getModifiersStr() + ""String_Node_Str""+ (ci.isEnum() ? ""String_Node_Str"" : ci.isAnnotation() ? ""String_Node_Str"" : ci.isInterface() ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  final String className=ci.getClassName();
  final int dotIdx=className.lastIndexOf('.');
  if (dotIdx > 0) {
    buf.append(""String_Node_Str"");
    GraphvizUtils.htmlEncode(className.substring(0,dotIdx + 1),buf);
    buf.append(""String_Node_Str"");
  }
  buf.append(""String_Node_Str"");
  GraphvizUtils.htmlEncode(className.substring(dotIdx + 1),buf);
  buf.append(""String_Node_Str"");
  final float darkness=0.8f;
  final int r=(int)(Integer.parseInt(boxBgColor.substring(0,2),16) * darkness);
  final int g=(int)(Integer.parseInt(boxBgColor.substring(2,4),16) * darkness);
  final int b=(int)(Integer.parseInt(boxBgColor.substring(4,6),16) * darkness);
  final String darkerColor=String.format(""String_Node_Str"",Integer.toString(r >> 4,16),Integer.toString(r & 0xf,16),Integer.toString(g >> 4,16),Integer.toString(g & 0xf,16),Integer.toString(b >> 4,16),Integer.toString(b & 0xf,16));
  if (ci.annotationInfo != null && ci.annotationInfo.size() > 0) {
    buf.append(""String_Node_Str"" + darkerColor + ""String_Node_Str"");
    final List<AnnotationInfo> annotationInfoSorted=new ArrayList<>(ci.annotationInfo);
    Collections.sort(annotationInfoSorted,new Comparator<AnnotationInfo>(){
      @Override public int compare(      final AnnotationInfo a1,      final AnnotationInfo a2){
        return a1.getAnnotationName().compareTo(a2.getAnnotationName());
      }
    }
);
    for (    final AnnotationInfo ai : annotationInfoSorted) {
      buf.append(""String_Node_Str"");
      buf.append(""String_Node_Str"");
      GraphvizUtils.htmlEncode(ai.toString(),buf);
      buf.append(""String_Node_Str"");
    }
  }
  if (ci.fieldInfo != null && ci.fieldInfo.size() > 0) {
    buf.append(""String_Node_Str"" + darkerColor + ""String_Node_Str""+ (scanSpec.ignoreFieldVisibility ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    final List<FieldInfo> fieldInfoSorted=new ArrayList<>(ci.fieldInfo);
    Collections.sort(fieldInfoSorted,new Comparator<FieldInfo>(){
      @Override public int compare(      final FieldInfo f1,      final FieldInfo f2){
        return f1.getFieldName().compareTo(f2.getFieldName());
      }
    }
);
    for (    final FieldInfo fi : fieldInfoSorted) {
      buf.append(""String_Node_Str"");
      buf.append(""String_Node_Str"");
      for (      final AnnotationInfo ai : fi.getAnnotationInfo()) {
        if (buf.charAt(buf.length() - 1) != ' ') {
          buf.append(' ');
        }
        GraphvizUtils.htmlEncode(ai.toString(),buf);
      }
      if (scanSpec.ignoreFieldVisibility) {
        if (buf.charAt(buf.length() - 1) != ' ') {
          buf.append(' ');
        }
        buf.append(fi.getModifierStr());
      }
      if (buf.charAt(buf.length() - 1) != ' ') {
        buf.append(' ');
      }
      GraphvizUtils.htmlEncode(fi.getTypeStr(),buf);
      buf.append(""String_Node_Str"");
      buf.append(""String_Node_Str"");
      GraphvizUtils.htmlEncode(fi.getFieldName(),buf);
      buf.append(""String_Node_Str"");
    }
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
  }
  if (ci.methodInfo != null && ci.methodInfo.size() > 0) {
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"" + darkerColor + ""String_Node_Str""+ (scanSpec.ignoreMethodVisibility ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    final List<MethodInfo> methodInfoSorted=new ArrayList<>(ci.methodInfo);
    Collections.sort(methodInfoSorted,new Comparator<MethodInfo>(){
      @Override public int compare(      final MethodInfo f1,      final MethodInfo f2){
        return f1.getMethodName().compareTo(f2.getMethodName());
      }
    }
);
    for (    final MethodInfo mi : methodInfoSorted) {
      if (!mi.getMethodName().equals(""String_Node_Str"")) {
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        for (        final AnnotationInfo ai : mi.getAnnotationInfo()) {
          if (buf.charAt(buf.length() - 1) != ' ') {
            buf.append(' ');
          }
          GraphvizUtils.htmlEncode(ai.toString(),buf);
        }
        if (scanSpec.ignoreMethodVisibility) {
          if (buf.charAt(buf.length() - 1) != ' ') {
            buf.append(' ');
          }
          buf.append(mi.getModifiersStr());
        }
        if (buf.charAt(buf.length() - 1) != ' ') {
          buf.append(' ');
        }
        if (!mi.getMethodName().equals(""String_Node_Str"")) {
          GraphvizUtils.htmlEncode(mi.getResultTypeStr(),buf);
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        if (mi.getMethodName().equals(""String_Node_Str"")) {
          GraphvizUtils.htmlEncode(mi.getClassName().substring(mi.getClassName().lastIndexOf('.') + 1),buf);
        }
 else {
          GraphvizUtils.htmlEncode(mi.getMethodName(),buf);
        }
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        buf.append('(');
        if (mi.getParameterTypes() != null && mi.getNumParameters() != 0) {
          final AnnotationInfo[][] annotationInfoForParam=mi.getParameterAnnotationInfo();
          final String[] typeOfParam=mi.getParameterTypeStrs();
          final String[] nameOfParam=mi.getParameterNames();
          for (int i=0, wrapPos=0; i < mi.getNumParameters(); i++) {
            if (i > 0) {
              buf.append(""String_Node_Str"");
              wrapPos+=2;
            }
            if (wrapPos > PARAM_WRAP_WIDTH) {
              buf.append(""String_Node_Str"");
              wrapPos=0;
            }
            if (annotationInfoForParam != null && annotationInfoForParam[i] != null) {
              for (              final AnnotationInfo ai : annotationInfoForParam[i]) {
                final String ais=ai.toString();
                if (!ais.isEmpty()) {
                  if (buf.charAt(buf.length() - 1) != ' ') {
                    buf.append(' ');
                  }
                  GraphvizUtils.htmlEncode(ais,buf);
                  wrapPos+=1 + ais.length();
                  if (wrapPos > PARAM_WRAP_WIDTH) {
                    buf.append(""String_Node_Str"");
                    wrapPos=0;
                  }
                }
              }
            }
            GraphvizUtils.htmlEncode(typeOfParam[i],buf);
            wrapPos+=typeOfParam[i].length();
            if (wrapPos > PARAM_WRAP_WIDTH) {
              buf.append(""String_Node_Str"");
              wrapPos=0;
            }
            if (nameOfParam != null && nameOfParam[i] != null) {
              buf.append(""String_Node_Str"");
              GraphvizUtils.htmlEncode(nameOfParam[i],buf);
              wrapPos+=1 + nameOfParam[i].length();
              buf.append(""String_Node_Str"");
            }
          }
        }
        buf.append(')');
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
  }
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
}","private void labelClassNodeHTML(final ClassInfo ci,final String shape,final String boxBgColor,final StringBuilder buf){
  buf.append(""String_Node_Str"" + shape + ""String_Node_Str""+ boxBgColor+ ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"" + ci.getModifiersStr() + ""String_Node_Str""+ (ci.isEnum() ? ""String_Node_Str"" : ci.isAnnotation() ? ""String_Node_Str"" : ci.isInterface() ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
  final String className=ci.getClassName();
  final int dotIdx=className.lastIndexOf('.');
  if (dotIdx > 0) {
    buf.append(""String_Node_Str"");
    GraphvizUtils.htmlEncode(className.substring(0,dotIdx + 1),buf);
    buf.append(""String_Node_Str"");
  }
  buf.append(""String_Node_Str"");
  GraphvizUtils.htmlEncode(className.substring(dotIdx + 1),buf);
  buf.append(""String_Node_Str"");
  final float darkness=0.8f;
  final int r=(int)(Integer.parseInt(boxBgColor.substring(0,2),16) * darkness);
  final int g=(int)(Integer.parseInt(boxBgColor.substring(2,4),16) * darkness);
  final int b=(int)(Integer.parseInt(boxBgColor.substring(4,6),16) * darkness);
  final String darkerColor=String.format(""String_Node_Str"",Integer.toString(r >> 4,16),Integer.toString(r & 0xf,16),Integer.toString(g >> 4,16),Integer.toString(g & 0xf,16),Integer.toString(b >> 4,16),Integer.toString(b & 0xf,16));
  if (ci.annotationInfo != null && ci.annotationInfo.size() > 0) {
    buf.append(""String_Node_Str"" + darkerColor + ""String_Node_Str"");
    final List<AnnotationInfo> annotationInfoSorted=new ArrayList<>(ci.annotationInfo);
    Collections.sort(annotationInfoSorted,new Comparator<AnnotationInfo>(){
      @Override public int compare(      final AnnotationInfo a1,      final AnnotationInfo a2){
        return a1.getAnnotationName().compareTo(a2.getAnnotationName());
      }
    }
);
    for (    final AnnotationInfo ai : annotationInfoSorted) {
      buf.append(""String_Node_Str"");
      buf.append(""String_Node_Str"");
      GraphvizUtils.htmlEncode(ai.toString(),buf);
      buf.append(""String_Node_Str"");
    }
  }
  if (ci.fieldInfo != null && ci.fieldInfo.size() > 0) {
    buf.append(""String_Node_Str"" + darkerColor + ""String_Node_Str""+ (scanSpec.ignoreFieldVisibility ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    final List<FieldInfo> fieldInfoSorted=new ArrayList<>(ci.fieldInfo);
    Collections.sort(fieldInfoSorted,new Comparator<FieldInfo>(){
      @Override public int compare(      final FieldInfo f1,      final FieldInfo f2){
        return f1.getFieldName().compareTo(f2.getFieldName());
      }
    }
);
    for (    final FieldInfo fi : fieldInfoSorted) {
      buf.append(""String_Node_Str"");
      buf.append(""String_Node_Str"");
      for (      final AnnotationInfo ai : fi.getAnnotationInfo()) {
        if (buf.charAt(buf.length() - 1) != ' ') {
          buf.append(' ');
        }
        GraphvizUtils.htmlEncode(ai.toString(),buf);
      }
      if (scanSpec.ignoreFieldVisibility) {
        if (buf.charAt(buf.length() - 1) != ' ') {
          buf.append(' ');
        }
        buf.append(fi.getModifierStr());
      }
      if (buf.charAt(buf.length() - 1) != ' ') {
        buf.append(' ');
      }
      GraphvizUtils.htmlEncode(fi.getTypeStr(),buf);
      buf.append(""String_Node_Str"");
      buf.append(""String_Node_Str"");
      GraphvizUtils.htmlEncode(fi.getFieldName(),buf);
      buf.append(""String_Node_Str"");
    }
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
  }
  if (ci.methodInfo != null && ci.methodInfo.size() > 0) {
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"" + darkerColor + ""String_Node_Str""+ (scanSpec.ignoreMethodVisibility ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    final List<MethodInfo> methodInfoSorted=new ArrayList<>(ci.methodInfo);
    Collections.sort(methodInfoSorted,new Comparator<MethodInfo>(){
      @Override public int compare(      final MethodInfo f1,      final MethodInfo f2){
        return f1.getMethodName().compareTo(f2.getMethodName());
      }
    }
);
    for (    final MethodInfo mi : methodInfoSorted) {
      if (!mi.getMethodName().equals(""String_Node_Str"")) {
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        for (        final AnnotationInfo ai : mi.getAnnotationInfo()) {
          if (buf.charAt(buf.length() - 1) != ' ') {
            buf.append(' ');
          }
          GraphvizUtils.htmlEncode(ai.toString(),buf);
        }
        if (scanSpec.ignoreMethodVisibility) {
          if (buf.charAt(buf.length() - 1) != ' ') {
            buf.append(' ');
          }
          buf.append(mi.getModifiersStr());
        }
        if (buf.charAt(buf.length() - 1) != ' ') {
          buf.append(' ');
        }
        if (!mi.getMethodName().equals(""String_Node_Str"")) {
          GraphvizUtils.htmlEncode(mi.getResultType().toString(),buf);
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        if (mi.getMethodName().equals(""String_Node_Str"")) {
          GraphvizUtils.htmlEncode(mi.getClassName().substring(mi.getClassName().lastIndexOf('.') + 1),buf);
        }
 else {
          GraphvizUtils.htmlEncode(mi.getMethodName(),buf);
        }
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        buf.append(""String_Node_Str"");
        buf.append('(');
        if (mi.getParameterTypes() != null && mi.getNumParameters() != 0) {
          final AnnotationInfo[][] annotationInfoForParam=mi.getParameterAnnotationInfo();
          final String[] typeOfParam=mi.getParameterTypeStrs();
          final String[] nameOfParam=mi.getParameterNames();
          for (int i=0, wrapPos=0; i < mi.getNumParameters(); i++) {
            if (i > 0) {
              buf.append(""String_Node_Str"");
              wrapPos+=2;
            }
            if (wrapPos > PARAM_WRAP_WIDTH) {
              buf.append(""String_Node_Str"");
              wrapPos=0;
            }
            if (annotationInfoForParam != null && annotationInfoForParam[i] != null) {
              for (              final AnnotationInfo ai : annotationInfoForParam[i]) {
                final String ais=ai.toString();
                if (!ais.isEmpty()) {
                  if (buf.charAt(buf.length() - 1) != ' ') {
                    buf.append(' ');
                  }
                  GraphvizUtils.htmlEncode(ais,buf);
                  wrapPos+=1 + ais.length();
                  if (wrapPos > PARAM_WRAP_WIDTH) {
                    buf.append(""String_Node_Str"");
                    wrapPos=0;
                  }
                }
              }
            }
            GraphvizUtils.htmlEncode(typeOfParam[i],buf);
            wrapPos+=typeOfParam[i].length();
            if (nameOfParam != null && nameOfParam[i] != null) {
              buf.append(""String_Node_Str"");
              GraphvizUtils.htmlEncode(nameOfParam[i],buf);
              wrapPos+=1 + nameOfParam[i].length();
              buf.append(""String_Node_Str"");
            }
          }
        }
        buf.append(')');
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(""String_Node_Str"");
  }
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
}"
3622,"/** 
 * Generates a .dot file which can be fed into GraphViz for layout and visualization of the class graph. The sizeX and sizeY parameters are the image output size to use (in inches) when GraphViz is asked to render the .dot file.
 */
String generateClassGraphDotFile(final float sizeX,final float sizeY){
  final StringBuilder buf=new StringBuilder();
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"" + sizeX + ""String_Node_Str""+ sizeY+ ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  final Set<ClassInfo> standardClassNodes=ClassInfo.filterClassInfo(allClassInfo,true,scanSpec,ClassType.STANDARD_CLASS);
  final ClassInfo objectClass=classNameToClassInfo.get(""String_Node_Str"");
  if (objectClass != null) {
    standardClassNodes.remove(objectClass);
  }
  final Set<ClassInfo> interfaceNodes=ClassInfo.filterClassInfo(allClassInfo,true,scanSpec,ClassType.IMPLEMENTED_INTERFACE);
  final Set<ClassInfo> annotationNodes=ClassInfo.filterClassInfo(allClassInfo,true,scanSpec,ClassType.ANNOTATION);
  for (  final ClassInfo node : standardClassNodes) {
    buf.append(""String_Node_Str"").append(""String_Node_Str"").append(node.getClassName()).append(""String_Node_Str"");
    labelClassNodeHTML(node,""String_Node_Str"",""String_Node_Str"",buf);
    buf.append(""String_Node_Str"");
  }
  for (  final ClassInfo node : interfaceNodes) {
    buf.append(""String_Node_Str"").append(""String_Node_Str"").append(node.getClassName()).append(""String_Node_Str"");
    labelClassNodeHTML(node,""String_Node_Str"",""String_Node_Str"",buf);
    buf.append(""String_Node_Str"");
  }
  for (  final ClassInfo node : annotationNodes) {
    buf.append(""String_Node_Str"").append(""String_Node_Str"").append(node.getClassName()).append(""String_Node_Str"");
    labelClassNodeHTML(node,""String_Node_Str"",""String_Node_Str"",buf);
    buf.append(""String_Node_Str"");
  }
  final Set<ClassInfo> allVisibleNodes=new HashSet<>();
  allVisibleNodes.addAll(standardClassNodes);
  allVisibleNodes.addAll(interfaceNodes);
  allVisibleNodes.addAll(annotationNodes);
  buf.append(""String_Node_Str"");
  for (  final ClassInfo classNode : standardClassNodes) {
    final ClassInfo directSuperclassNode=classNode.getDirectSuperclass();
    if (directSuperclassNode != null && allVisibleNodes.contains(directSuperclassNode)) {
      buf.append(""String_Node_Str"" + classNode.getClassName() + ""String_Node_Str""+ directSuperclassNode.getClassName()+ ""String_Node_Str"");
    }
    for (    final ClassInfo implementedInterfaceNode : classNode.getDirectlyImplementedInterfaces()) {
      if (allVisibleNodes.contains(implementedInterfaceNode)) {
        buf.append(""String_Node_Str"" + classNode.getClassName() + ""String_Node_Str""+ implementedInterfaceNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo fieldTypeNode : lookup(classNode.getClassNamesReferencedInFieldTypeDescriptors())) {
      if (allVisibleNodes.contains(fieldTypeNode)) {
        buf.append(""String_Node_Str"" + fieldTypeNode.getClassName() + ""String_Node_Str""+ classNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo fieldTypeNode : lookup(classNode.getClassNamesReferencedInMethodTypeDescriptors())) {
      if (allVisibleNodes.contains(fieldTypeNode)) {
        buf.append(""String_Node_Str"" + fieldTypeNode.getClassName() + ""String_Node_Str""+ classNode.getClassName()+ ""String_Node_Str"");
      }
    }
  }
  for (  final ClassInfo interfaceNode : interfaceNodes) {
    for (    final ClassInfo superinterfaceNode : interfaceNode.getDirectSuperinterfaces()) {
      if (allVisibleNodes.contains(superinterfaceNode)) {
        buf.append(""String_Node_Str"" + interfaceNode.getClassName() + ""String_Node_Str""+ superinterfaceNode.getClassName()+ ""String_Node_Str"");
      }
    }
  }
  for (  final ClassInfo annotationNode : annotationNodes) {
    for (    final ClassInfo annotatedClassNode : annotationNode.getClassesWithDirectAnnotation()) {
      if (allVisibleNodes.contains(annotatedClassNode)) {
        buf.append(""String_Node_Str"" + annotatedClassNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo annotatedClassNode : annotationNode.getAnnotationsWithDirectMetaAnnotation()) {
      if (allVisibleNodes.contains(annotatedClassNode)) {
        buf.append(""String_Node_Str"" + annotatedClassNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo classWithMethodAnnotationNode : annotationNode.getClassesWithDirectMethodAnnotation()) {
      if (allVisibleNodes.contains(classWithMethodAnnotationNode)) {
        buf.append(""String_Node_Str"" + classWithMethodAnnotationNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo classWithMethodAnnotationNode : annotationNode.getClassesWithFieldAnnotation()) {
      if (allVisibleNodes.contains(classWithMethodAnnotationNode)) {
        buf.append(""String_Node_Str"" + classWithMethodAnnotationNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}","/** 
 * Generates a .dot file which can be fed into GraphViz for layout and visualization of the class graph. The sizeX and sizeY parameters are the image output size to use (in inches) when GraphViz is asked to render the .dot file.
 */
String generateClassGraphDotFile(final float sizeX,final float sizeY){
  final StringBuilder buf=new StringBuilder();
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"" + sizeX + ""String_Node_Str""+ sizeY+ ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  buf.append(""String_Node_Str"");
  final Set<ClassInfo> standardClassNodes=ClassInfo.filterClassInfo(allClassInfo,true,scanSpec,ClassType.STANDARD_CLASS);
  final ClassInfo objectClass=classNameToClassInfo.get(""String_Node_Str"");
  if (objectClass != null) {
    standardClassNodes.remove(objectClass);
  }
  final Set<ClassInfo> interfaceNodes=ClassInfo.filterClassInfo(allClassInfo,true,scanSpec,ClassType.IMPLEMENTED_INTERFACE);
  final Set<ClassInfo> annotationNodes=ClassInfo.filterClassInfo(allClassInfo,true,scanSpec,ClassType.ANNOTATION);
  for (  final ClassInfo node : standardClassNodes) {
    buf.append(""String_Node_Str"").append(node.getClassName()).append(""String_Node_Str"");
    labelClassNodeHTML(node,""String_Node_Str"",""String_Node_Str"",buf);
    buf.append(""String_Node_Str"");
  }
  for (  final ClassInfo node : interfaceNodes) {
    buf.append(""String_Node_Str"").append(node.getClassName()).append(""String_Node_Str"");
    labelClassNodeHTML(node,""String_Node_Str"",""String_Node_Str"",buf);
    buf.append(""String_Node_Str"");
  }
  for (  final ClassInfo node : annotationNodes) {
    buf.append(""String_Node_Str"").append(node.getClassName()).append(""String_Node_Str"");
    labelClassNodeHTML(node,""String_Node_Str"",""String_Node_Str"",buf);
    buf.append(""String_Node_Str"");
  }
  final Set<ClassInfo> allVisibleNodes=new HashSet<>();
  allVisibleNodes.addAll(standardClassNodes);
  allVisibleNodes.addAll(interfaceNodes);
  allVisibleNodes.addAll(annotationNodes);
  buf.append(""String_Node_Str"");
  for (  final ClassInfo classNode : standardClassNodes) {
    final ClassInfo directSuperclassNode=classNode.getDirectSuperclass();
    if (directSuperclassNode != null && allVisibleNodes.contains(directSuperclassNode)) {
      buf.append(""String_Node_Str"" + classNode.getClassName() + ""String_Node_Str""+ directSuperclassNode.getClassName()+ ""String_Node_Str"");
    }
    for (    final ClassInfo implementedInterfaceNode : classNode.getDirectlyImplementedInterfaces()) {
      if (allVisibleNodes.contains(implementedInterfaceNode)) {
        buf.append(""String_Node_Str"" + classNode.getClassName() + ""String_Node_Str""+ implementedInterfaceNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo fieldTypeNode : lookup(classNode.getClassNamesReferencedInFieldTypeDescriptors())) {
      if (allVisibleNodes.contains(fieldTypeNode)) {
        buf.append(""String_Node_Str"" + fieldTypeNode.getClassName() + ""String_Node_Str""+ classNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo fieldTypeNode : lookup(classNode.getClassNamesReferencedInMethodTypeDescriptors())) {
      if (allVisibleNodes.contains(fieldTypeNode)) {
        buf.append(""String_Node_Str"" + fieldTypeNode.getClassName() + ""String_Node_Str""+ classNode.getClassName()+ ""String_Node_Str"");
      }
    }
  }
  for (  final ClassInfo interfaceNode : interfaceNodes) {
    for (    final ClassInfo superinterfaceNode : interfaceNode.getDirectSuperinterfaces()) {
      if (allVisibleNodes.contains(superinterfaceNode)) {
        buf.append(""String_Node_Str"" + interfaceNode.getClassName() + ""String_Node_Str""+ superinterfaceNode.getClassName()+ ""String_Node_Str"");
      }
    }
  }
  for (  final ClassInfo annotationNode : annotationNodes) {
    for (    final ClassInfo annotatedClassNode : annotationNode.getClassesWithDirectAnnotation()) {
      if (allVisibleNodes.contains(annotatedClassNode)) {
        buf.append(""String_Node_Str"" + annotatedClassNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo annotatedClassNode : annotationNode.getAnnotationsWithDirectMetaAnnotation()) {
      if (allVisibleNodes.contains(annotatedClassNode)) {
        buf.append(""String_Node_Str"" + annotatedClassNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo classWithMethodAnnotationNode : annotationNode.getClassesWithDirectMethodAnnotation()) {
      if (allVisibleNodes.contains(classWithMethodAnnotationNode)) {
        buf.append(""String_Node_Str"" + classWithMethodAnnotationNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
    for (    final ClassInfo classWithMethodAnnotationNode : annotationNode.getClassesWithFieldAnnotation()) {
      if (allVisibleNodes.contains(classWithMethodAnnotationNode)) {
        buf.append(""String_Node_Str"" + classWithMethodAnnotationNode.getClassName() + ""String_Node_Str""+ annotationNode.getClassName()+ ""String_Node_Str"");
      }
    }
  }
  buf.append(""String_Node_Str"");
  return buf.toString();
}"
3623,"/** 
 * Split a path on File.pathSeparator (':' on Linux, ';' on Windows), but also allow for the use of URLs with protocol specifiers, e.g. ""http://domain/jar1.jar:http://domain/jar2.jar"". This is really not even handled by the JRE, in all likelihood, but it's better to be robust.
 */
public static String[] smartPathSplit(final String pathStr){
  if (pathStr == null || pathStr.isEmpty()) {
    return new String[0];
  }
  if (File.pathSeparatorChar == ':') {
    final Set<Integer> splitPoints=new HashSet<>();
    for (int i=-1; ; ) {
      boolean foundNonPathSeparator=false;
      for (int j=0; j < UNIX_NON_PATH_SEPARATORS.length; j++) {
        if (pathStr.regionMatches(true,i - UNIX_NON_PATH_SEPARATOR_COLON_POSITIONS[j],UNIX_NON_PATH_SEPARATORS[j],0,UNIX_NON_PATH_SEPARATORS[j].length())) {
          foundNonPathSeparator=true;
          break;
        }
      }
      if (!foundNonPathSeparator) {
        splitPoints.add(i);
      }
      i=pathStr.indexOf(':',i + 1);
      if (i < 0) {
        splitPoints.add(pathStr.length());
        break;
      }
    }
    final List<Integer> splitPointsSorted=new ArrayList<>(splitPoints);
    Collections.sort(splitPointsSorted);
    final List<String> parts=new ArrayList<>();
    for (int i=1; i < splitPointsSorted.size(); i++) {
      final int idx0=splitPointsSorted.get(i - 1);
      final int idx1=splitPointsSorted.get(i);
      String part=pathStr.substring(idx0 + 1,idx1).trim();
      part=part.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (!part.isEmpty()) {
        parts.add(part);
      }
    }
    return parts.toArray(new String[parts.size()]);
  }
 else {
    final List<String> partsFiltered=new ArrayList<>();
    for (    final String part : pathStr.split(File.pathSeparator)) {
      final String partFiltered=part.trim();
      if (!partFiltered.isEmpty()) {
        partsFiltered.add(partFiltered);
      }
    }
    return partsFiltered.toArray(new String[partsFiltered.size()]);
  }
}","/** 
 * Split a path on File.pathSeparator (':' on Linux, ';' on Windows), but also allow for the use of URLs with protocol specifiers, e.g. ""http://domain/jar1.jar:http://domain/jar2.jar"". This is really not even handled by the JRE, in all likelihood, but it's better to be robust.
 */
public static String[] smartPathSplit(final String pathStr){
  if (pathStr == null || pathStr.isEmpty()) {
    return new String[0];
  }
  if (File.pathSeparatorChar == ':') {
    final Set<Integer> splitPoints=new HashSet<>();
    for (int i=-1; ; ) {
      boolean foundNonPathSeparator=false;
      for (int j=0; j < UNIX_NON_PATH_SEPARATORS.length; j++) {
        final int startIdx=i - UNIX_NON_PATH_SEPARATOR_COLON_POSITIONS[j];
        if (pathStr.regionMatches(true,startIdx,UNIX_NON_PATH_SEPARATORS[j],0,UNIX_NON_PATH_SEPARATORS[j].length())) {
          if (startIdx == 0 || pathStr.charAt(startIdx - 1) == ':') {
            foundNonPathSeparator=true;
            break;
          }
        }
      }
      if (!foundNonPathSeparator) {
        splitPoints.add(i);
      }
      i=pathStr.indexOf(':',i + 1);
      if (i < 0) {
        splitPoints.add(pathStr.length());
        break;
      }
    }
    final List<Integer> splitPointsSorted=new ArrayList<>(splitPoints);
    Collections.sort(splitPointsSorted);
    final List<String> parts=new ArrayList<>();
    for (int i=1; i < splitPointsSorted.size(); i++) {
      final int idx0=splitPointsSorted.get(i - 1);
      final int idx1=splitPointsSorted.get(i);
      String part=pathStr.substring(idx0 + 1,idx1).trim();
      part=part.replaceAll(""String_Node_Str"",""String_Node_Str"");
      if (!part.isEmpty()) {
        parts.add(part);
      }
    }
    return parts.toArray(new String[parts.size()]);
  }
 else {
    final List<String> partsFiltered=new ArrayList<>();
    for (    final String part : pathStr.split(File.pathSeparator)) {
      final String partFiltered=part.trim();
      if (!partFiltered.isEmpty()) {
        partsFiltered.add(partFiltered);
      }
    }
    return partsFiltered.toArray(new String[partsFiltered.size()]);
  }
}"
3624,"/** 
 * Returns true if the given directory path is a descendant of a blacklisted path, or an ancestor or descendant of a whitelisted path. The path should end in ""/"".
 */
ScanSpecPathMatch dirWhitelistMatchStatus(final String relativePath){
  for (  final String blacklistedPath : blacklistedPathPrefixes) {
    if (relativePath.startsWith(blacklistedPath)) {
      return ScanSpecPathMatch.HAS_BLACKLISTED_PATH_PREFIX;
    }
  }
  for (  final String whitelistedPath : whitelistedPathPrefixes) {
    if (disableRecursiveScanning && relativePath.equals(whitelistedPath)) {
      return ScanSpecPathMatch.HAS_WHITELISTED_PATH_PREFIX;
    }
 else     if (!disableRecursiveScanning && relativePath.startsWith(whitelistedPath)) {
      return ScanSpecPathMatch.HAS_WHITELISTED_PATH_PREFIX;
    }
 else     if (whitelistedPath.startsWith(relativePath) || ""String_Node_Str"".equals(relativePath)) {
      return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
    }
  }
  for (  final String whitelistedPath : whitelistedPathsNonRecursive) {
    if (relativePath.equals(whitelistedPath)) {
      return ScanSpecPathMatch.AT_WHITELISTED_PATH;
    }
 else     if (whitelistedPath.startsWith(relativePath) || ""String_Node_Str"".equals(relativePath)) {
      return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
    }
  }
  if (specificallyWhitelistedClassParentRelativePaths.contains(relativePath) && !specificallyBlacklistedClassRelativePaths.contains(relativePath)) {
    return ScanSpecPathMatch.AT_WHITELISTED_CLASS_PACKAGE;
  }
  for (  final String whitelistedClassPathPrefix : specificallyWhitelistedClassParentRelativePaths) {
    if (whitelistedClassPathPrefix.startsWith(relativePath) || ""String_Node_Str"".equals(relativePath)) {
      return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
    }
  }
  return ScanSpecPathMatch.NOT_WITHIN_WHITELISTED_PATH;
}","/** 
 * Returns true if the given directory path is a descendant of a blacklisted path, or an ancestor or descendant of a whitelisted path. The path should end in ""/"".
 */
ScanSpecPathMatch dirWhitelistMatchStatus(final String relativePath){
  for (  final String blacklistedPath : blacklistedPathPrefixes) {
    if (relativePath.startsWith(blacklistedPath)) {
      return ScanSpecPathMatch.HAS_BLACKLISTED_PATH_PREFIX;
    }
  }
  if (specificallyWhitelistedClassParentRelativePaths.contains(relativePath) && !specificallyBlacklistedClassRelativePaths.contains(relativePath)) {
    return ScanSpecPathMatch.AT_WHITELISTED_CLASS_PACKAGE;
  }
  if (whitelistedPathPrefixes.contains(relativePath) || whitelistedPathsNonRecursive.contains(relativePath)) {
    return ScanSpecPathMatch.AT_WHITELISTED_PATH;
  }
  if (relativePath.equals(""String_Node_Str"")) {
    return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
  }
  for (  final String whitelistedPathPrefix : whitelistedPathPrefixes) {
    if (whitelistedPathPrefix.startsWith(relativePath)) {
      return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
    }
  }
  for (  final String whitelistedPathNonRecursive : whitelistedPathsNonRecursive) {
    if (whitelistedPathNonRecursive.startsWith(relativePath)) {
      return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
    }
  }
  for (  final String whitelistedClassPathPrefix : specificallyWhitelistedClassParentRelativePaths) {
    if (whitelistedClassPathPrefix.startsWith(relativePath)) {
      return ScanSpecPathMatch.ANCESTOR_OF_WHITELISTED_PATH;
    }
  }
  if (!disableRecursiveScanning) {
    for (    final String whitelistedPathPrefix : whitelistedPathPrefixes) {
      if (relativePath.startsWith(whitelistedPathPrefix)) {
        return ScanSpecPathMatch.HAS_WHITELISTED_PATH_PREFIX;
      }
    }
  }
  return ScanSpecPathMatch.NOT_WITHIN_WHITELISTED_PATH;
}"
3625,"/** 
 * Parses the scanning specification that was passed to the FastClasspathScanner constructor, and finds all ClassLoaders.
 */
public ScanSpec(final String[] scanSpec,final LogNode log){
  final HashSet<String> uniqueWhitelistedPathPrefixes=new HashSet<>();
  final HashSet<String> uniqueBlacklistedPathPrefixes=new HashSet<>();
  boolean scanJars=true, scanNonJars=true;
  for (  final String scanSpecEntry : scanSpec) {
    String spec=scanSpecEntry;
    if (""String_Node_Str"".equals(scanSpecEntry)) {
      blacklistSystemPackages=false;
    }
 else     if (""String_Node_Str"".equals(scanSpecEntry)) {
      blacklistSystemJars=false;
      blacklistSystemPackages=false;
    }
 else {
      final boolean blacklisted=spec.startsWith(""String_Node_Str"");
      if (blacklisted) {
        spec=spec.substring(1);
      }
      if (spec.startsWith(""String_Node_Str"")) {
        spec=spec.substring(4);
        if (spec.indexOf('/') >= 0) {
          if (log != null) {
            log.log(""String_Node_Str"" + ""String_Node_Str"" + spec + ""String_Node_Str"");
          }
        }
 else {
          if (spec.isEmpty()) {
            if (blacklisted) {
              scanJars=false;
            }
 else {
              scanNonJars=false;
            }
          }
 else {
            if (blacklisted) {
              if (spec.contains(""String_Node_Str"")) {
                blacklistedJarPatterns.add(specToPattern(spec));
              }
 else {
                blacklistedJars.add(spec);
              }
            }
 else {
              if (spec.contains(""String_Node_Str"")) {
                whitelistedJarPatterns.add(specToPattern(spec));
              }
 else {
                whitelistedJars.add(spec);
              }
            }
          }
        }
      }
 else {
        final String specPath=spec.replace('.','/');
        boolean isClassName=false;
        final int lastSlashIdx=specPath.lastIndexOf('/');
        if (lastSlashIdx < specPath.length() - 1) {
          isClassName=Character.isUpperCase(specPath.charAt(lastSlashIdx + 1));
        }
        if (isClassName) {
          if (blacklisted) {
            specificallyBlacklistedClassNames.add(spec);
            specificallyBlacklistedClassRelativePaths.add(specPath + ""String_Node_Str"");
          }
 else {
            specificallyWhitelistedClassRelativePaths.add(specPath + ""String_Node_Str"");
          }
        }
 else {
          if (blacklisted) {
            uniqueBlacklistedPathPrefixes.add(specPath + ""String_Node_Str"");
          }
 else {
            uniqueWhitelistedPathPrefixes.add(specPath + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (uniqueBlacklistedPathPrefixes.contains(""String_Node_Str"")) {
    if (log != null) {
      log.log(""String_Node_Str"");
    }
    uniqueBlacklistedPathPrefixes.remove(""String_Node_Str"");
  }
  uniqueWhitelistedPathPrefixes.removeAll(uniqueBlacklistedPathPrefixes);
  whitelistedJars.removeAll(blacklistedJars);
  if (!(whitelistedJars.isEmpty() && whitelistedJarPatterns.isEmpty())) {
    scanNonJars=false;
  }
  if (!scanJars && !scanNonJars) {
    if (log != null) {
      log.log(""String_Node_Str"");
    }
    scanNonJars=true;
  }
  if (uniqueWhitelistedPathPrefixes.isEmpty() || uniqueWhitelistedPathPrefixes.contains(""String_Node_Str"")) {
    whitelistedPathPrefixes.add(""String_Node_Str"");
  }
 else {
    whitelistedPathPrefixes.addAll(uniqueWhitelistedPathPrefixes);
  }
  if (blacklistSystemPackages) {
    uniqueBlacklistedPathPrefixes.add(""String_Node_Str"");
    uniqueBlacklistedPathPrefixes.add(""String_Node_Str"");
    uniqueBlacklistedPathPrefixes.add(""String_Node_Str"");
  }
  blacklistedPathPrefixes.addAll(uniqueBlacklistedPathPrefixes);
  for (  final String prefix : blacklistedPathPrefixes) {
    blacklistedPackagePrefixes.add(prefix.replace('/','.'));
  }
  specificallyWhitelistedClassRelativePaths.removeAll(specificallyBlacklistedClassRelativePaths);
  for (  final String whitelistedClass : specificallyWhitelistedClassRelativePaths) {
    final int lastSlashIdx=whitelistedClass.lastIndexOf('/');
    specificallyWhitelistedClassParentRelativePaths.add(whitelistedClass.substring(0,lastSlashIdx + 1));
  }
  this.scanJars=scanJars;
  this.scanDirs=scanNonJars;
  if (log != null) {
    log.log(""String_Node_Str"" + whitelistedPathPrefixes);
    if (!blacklistedPathPrefixes.isEmpty()) {
      log.log(""String_Node_Str"" + blacklistedPathPrefixes);
    }
    if (!whitelistedJars.isEmpty()) {
      log.log(""String_Node_Str"" + whitelistedJars);
    }
    if (!whitelistedJarPatterns.isEmpty()) {
      log.log(""String_Node_Str"" + whitelistedJarPatterns);
    }
    if (!blacklistedJars.isEmpty()) {
      log.log(""String_Node_Str"" + blacklistedJars);
    }
    if (!blacklistedJarPatterns.isEmpty()) {
      log.log(""String_Node_Str"" + blacklistedJarPatterns);
    }
    if (!specificallyWhitelistedClassRelativePaths.isEmpty()) {
      log.log(""String_Node_Str"" + specificallyWhitelistedClassRelativePaths);
    }
    if (!specificallyBlacklistedClassRelativePaths.isEmpty()) {
      log.log(""String_Node_Str"" + specificallyBlacklistedClassRelativePaths);
    }
    if (!scanJars) {
      log.log(""String_Node_Str"");
    }
    if (!scanNonJars) {
      log.log(""String_Node_Str"");
    }
  }
  this.classLoaders=findAllClassLoaders(log == null ? null : log.log(""String_Node_Str""));
}","/** 
 * Parses the scanning specification that was passed to the FastClasspathScanner constructor, and finds all ClassLoaders.
 */
public ScanSpec(final String[] scanSpec,final LogNode log){
  final HashSet<String> uniqueWhitelistedPathPrefixes=new HashSet<>();
  final HashSet<String> uniqueBlacklistedPathPrefixes=new HashSet<>();
  boolean scanJars=true, scanNonJars=true;
  for (  final String scanSpecEntry : scanSpec) {
    String spec=scanSpecEntry;
    if (""String_Node_Str"".equals(scanSpecEntry)) {
      blacklistSystemPackages=false;
    }
 else     if (""String_Node_Str"".equals(scanSpecEntry)) {
      blacklistSystemJars=false;
      blacklistSystemPackages=false;
    }
 else {
      final boolean blacklisted=spec.startsWith(""String_Node_Str"");
      if (blacklisted) {
        spec=spec.substring(1);
      }
      if (spec.startsWith(""String_Node_Str"")) {
        spec=spec.substring(4);
        if (spec.indexOf('/') >= 0) {
          if (log != null) {
            log.log(""String_Node_Str"" + ""String_Node_Str"" + spec + ""String_Node_Str"");
          }
        }
 else {
          if (spec.isEmpty()) {
            if (blacklisted) {
              scanJars=false;
            }
 else {
              scanNonJars=false;
            }
          }
 else {
            if (blacklisted) {
              if (spec.contains(""String_Node_Str"")) {
                blacklistedJarPatterns.add(specToPattern(spec));
              }
 else {
                blacklistedJars.add(spec);
              }
            }
 else {
              if (spec.contains(""String_Node_Str"")) {
                whitelistedJarPatterns.add(specToPattern(spec));
              }
 else {
                whitelistedJars.add(spec);
              }
            }
          }
        }
      }
 else {
        final String specPath=spec.replace('.','/');
        boolean isClassName=false;
        final int lastSlashIdx=specPath.lastIndexOf('/');
        if (lastSlashIdx < specPath.length() - 1) {
          isClassName=Character.isUpperCase(specPath.charAt(lastSlashIdx + 1));
        }
        if (isClassName) {
          if (blacklisted) {
            specificallyBlacklistedClassNames.add(spec);
            specificallyBlacklistedClassRelativePaths.add(specPath + ""String_Node_Str"");
          }
 else {
            specificallyWhitelistedClassRelativePaths.add(specPath + ""String_Node_Str"");
          }
        }
 else {
          if (blacklisted) {
            uniqueBlacklistedPathPrefixes.add(specPath + ""String_Node_Str"");
          }
 else {
            uniqueWhitelistedPathPrefixes.add(specPath + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (uniqueBlacklistedPathPrefixes.contains(""String_Node_Str"")) {
    if (log != null) {
      log.log(""String_Node_Str"");
    }
    uniqueBlacklistedPathPrefixes.remove(""String_Node_Str"");
  }
  uniqueWhitelistedPathPrefixes.removeAll(uniqueBlacklistedPathPrefixes);
  whitelistedJars.removeAll(blacklistedJars);
  if (!(whitelistedJars.isEmpty() && whitelistedJarPatterns.isEmpty())) {
    scanNonJars=false;
  }
  if (!scanJars && !scanNonJars) {
    if (log != null) {
      log.log(""String_Node_Str"");
    }
    scanNonJars=true;
  }
  if (uniqueWhitelistedPathPrefixes.isEmpty() || uniqueWhitelistedPathPrefixes.contains(""String_Node_Str"")) {
    if (specificallyWhitelistedClassRelativePaths.isEmpty()) {
      whitelistedPathPrefixes.add(""String_Node_Str"");
    }
  }
 else {
    whitelistedPathPrefixes.addAll(uniqueWhitelistedPathPrefixes);
  }
  if (blacklistSystemPackages) {
    uniqueBlacklistedPathPrefixes.add(""String_Node_Str"");
    uniqueBlacklistedPathPrefixes.add(""String_Node_Str"");
    uniqueBlacklistedPathPrefixes.add(""String_Node_Str"");
  }
  blacklistedPathPrefixes.addAll(uniqueBlacklistedPathPrefixes);
  for (  final String prefix : blacklistedPathPrefixes) {
    blacklistedPackagePrefixes.add(prefix.replace('/','.'));
  }
  specificallyWhitelistedClassRelativePaths.removeAll(specificallyBlacklistedClassRelativePaths);
  for (  final String whitelistedClass : specificallyWhitelistedClassRelativePaths) {
    final int lastSlashIdx=whitelistedClass.lastIndexOf('/');
    specificallyWhitelistedClassParentRelativePaths.add(whitelistedClass.substring(0,lastSlashIdx + 1));
  }
  this.scanJars=scanJars;
  this.scanDirs=scanNonJars;
  if (log != null) {
    log.log(""String_Node_Str"" + whitelistedPathPrefixes);
    if (!blacklistedPathPrefixes.isEmpty()) {
      log.log(""String_Node_Str"" + blacklistedPathPrefixes);
    }
    if (!whitelistedJars.isEmpty()) {
      log.log(""String_Node_Str"" + whitelistedJars);
    }
    if (!whitelistedJarPatterns.isEmpty()) {
      log.log(""String_Node_Str"" + whitelistedJarPatterns);
    }
    if (!blacklistedJars.isEmpty()) {
      log.log(""String_Node_Str"" + blacklistedJars);
    }
    if (!blacklistedJarPatterns.isEmpty()) {
      log.log(""String_Node_Str"" + blacklistedJarPatterns);
    }
    if (!specificallyWhitelistedClassRelativePaths.isEmpty()) {
      log.log(""String_Node_Str"" + specificallyWhitelistedClassRelativePaths);
    }
    if (!specificallyBlacklistedClassRelativePaths.isEmpty()) {
      log.log(""String_Node_Str"" + specificallyBlacklistedClassRelativePaths);
    }
    if (!scanJars) {
      log.log(""String_Node_Str"");
    }
    if (!scanNonJars) {
      log.log(""String_Node_Str"");
    }
  }
  this.classLoaders=findAllClassLoaders(log == null ? null : log.log(""String_Node_Str""));
}"
3626,"/** 
 * Scan a zipfile for file path patterns matching the scan spec. 
 */
private void scanZipFile(final File zipFileFile,final ZipFile zipFile,final LogNode log){
  String prevParentRelativePath=null;
  ScanSpecPathMatch prevParentMatchStatus=null;
  int entryIdx=0;
  for (final Enumeration<? extends ZipEntry> entries=zipFile.entries(); entries.hasMoreElements(); ) {
    if ((entryIdx++ & 0x3ff) == 0) {
      if (interruptionChecker.checkAndReturn()) {
        return;
      }
    }
    final ZipEntry zipEntry=entries.nextElement();
    String relativePath=zipEntry.getName();
    if (relativePath.startsWith(""String_Node_Str"")) {
      relativePath=relativePath.substring(1);
    }
    final boolean isDir=zipEntry.isDirectory();
    if (isDir) {
      continue;
    }
    final int lastSlashIdx=relativePath.lastIndexOf(""String_Node_Str"");
    final String parentRelativePath=lastSlashIdx < 0 ? ""String_Node_Str"" : relativePath.substring(0,lastSlashIdx + 1);
    final boolean parentRelativePathChanged=!parentRelativePath.equals(prevParentRelativePath);
    final ScanSpecPathMatch parentMatchStatus=prevParentRelativePath == null || parentRelativePathChanged ? scanSpec.pathWhitelistMatchStatus(parentRelativePath) : prevParentMatchStatus;
    prevParentRelativePath=parentRelativePath;
    prevParentMatchStatus=parentMatchStatus;
    if (parentMatchStatus != ScanSpecPathMatch.WITHIN_WHITELISTED_PATH && (parentMatchStatus != ScanSpecPathMatch.AT_WHITELISTED_CLASS_PACKAGE || !scanSpec.isSpecificallyWhitelistedClass(relativePath))) {
      continue;
    }
    if (log != null) {
      log.log(""String_Node_Str"" + relativePath);
    }
    if (ClasspathRelativePath.isClassfile(relativePath)) {
      classfileMatches.add(new ClasspathResourceInZipFile(zipFileFile,relativePath,zipEntry));
    }
    for (    final FilePathTesterAndMatchProcessorWrapper fileMatcher : scanSpec.getFilePathTestersAndMatchProcessorWrappers()) {
      if (fileMatcher.filePathMatches(zipFileFile,relativePath,log)) {
        fileMatches.put(fileMatcher.fileMatchProcessorWrapper,new ClasspathResourceInZipFile(zipFileFile,relativePath,zipEntry));
      }
    }
    if (relativePath.equalsIgnoreCase(""String_Node_Str"")) {
      fastManifestParser=new FastManifestParser(zipFile,zipEntry,log);
    }
  }
  fileToLastModified.put(zipFileFile,zipFileFile.lastModified());
}","/** 
 * Scan a zipfile for file path patterns matching the scan spec. 
 */
private void scanZipFile(final File zipFileFile,final ZipFile zipFile,final LogNode log){
  String prevParentRelativePath=null;
  ScanSpecPathMatch prevParentMatchStatus=null;
  int entryIdx=0;
  for (final Enumeration<? extends ZipEntry> entries=zipFile.entries(); entries.hasMoreElements(); ) {
    if ((entryIdx++ & 0x3ff) == 0) {
      if (interruptionChecker.checkAndReturn()) {
        return;
      }
    }
    final ZipEntry zipEntry=entries.nextElement();
    String relativePath=zipEntry.getName();
    if (relativePath.startsWith(""String_Node_Str"")) {
      relativePath=relativePath.substring(1);
    }
    final boolean isDir=zipEntry.isDirectory();
    if (isDir) {
      continue;
    }
    final int lastSlashIdx=relativePath.lastIndexOf(""String_Node_Str"");
    final String parentRelativePath=lastSlashIdx < 0 ? ""String_Node_Str"" : relativePath.substring(0,lastSlashIdx + 1);
    final boolean parentRelativePathChanged=!parentRelativePath.equals(prevParentRelativePath);
    final ScanSpecPathMatch parentMatchStatus=prevParentRelativePath == null || parentRelativePathChanged ? scanSpec.pathWhitelistMatchStatus(parentRelativePath) : prevParentMatchStatus;
    prevParentRelativePath=parentRelativePath;
    prevParentMatchStatus=parentMatchStatus;
    if (relativePath.equalsIgnoreCase(""String_Node_Str"")) {
      if (log != null) {
        log.log(""String_Node_Str"" + relativePath);
      }
      fastManifestParser=new FastManifestParser(zipFile,zipEntry,log);
    }
    if (parentMatchStatus != ScanSpecPathMatch.WITHIN_WHITELISTED_PATH && (parentMatchStatus != ScanSpecPathMatch.AT_WHITELISTED_CLASS_PACKAGE || !scanSpec.isSpecificallyWhitelistedClass(relativePath))) {
      continue;
    }
    if (log != null) {
      log.log(""String_Node_Str"" + relativePath);
    }
    if (ClasspathRelativePath.isClassfile(relativePath)) {
      classfileMatches.add(new ClasspathResourceInZipFile(zipFileFile,relativePath,zipEntry));
    }
    for (    final FilePathTesterAndMatchProcessorWrapper fileMatcher : scanSpec.getFilePathTestersAndMatchProcessorWrappers()) {
      if (fileMatcher.filePathMatches(zipFileFile,relativePath,log)) {
        fileMatches.put(fileMatcher.fileMatchProcessorWrapper,new ClasspathResourceInZipFile(zipFileFile,relativePath,zipEntry));
      }
    }
  }
  fileToLastModified.put(zipFileFile,zipFileFile.lastModified());
}"
3627,"/** 
 * Strip away any ""jar:"" prefix from a filename URI, and convert it to a file path, handling possibly-broken mixes of filesystem and URI conventions. Follows symbolic links, and resolves any relative paths relative to resolveBaseFile.
 */
private static File urlToFile(final File resolveBaseFile,final String relativePathStr){
  if (relativePathStr.isEmpty()) {
    return null;
  }
  String pathStr=relativePathStr;
  if (pathStr.startsWith(""String_Node_Str"")) {
    pathStr=pathStr.substring(4);
  }
  if (pathStr.startsWith(""String_Node_Str"") || pathStr.startsWith(""String_Node_Str"")) {
    if (FastClasspathScanner.verbose) {
      Log.log(""String_Node_Str"" + pathStr);
    }
    return null;
  }
  if (pathStr.indexOf('\\') >= 0) {
    pathStr=pathStr.replace('\\','/');
  }
  if (pathStr.startsWith(""String_Node_Str"")) {
    pathStr=pathStr.substring(7);
  }
  if (pathStr.startsWith(""String_Node_Str"")) {
    pathStr=pathStr.substring(5);
  }
  if (pathStr.length() > 2 && Character.isLetter(pathStr.charAt(0)) && pathStr.charAt(1) == ':') {
    pathStr='/' + pathStr;
  }
  if (pathStr.endsWith(""String_Node_Str"") && !pathStr.equals(""String_Node_Str"")) {
    pathStr=relativePathStr.substring(0,pathStr.length() - 1);
  }
  pathStr=pathStr.replace(""String_Node_Str"",""String_Node_Str"");
  try {
    if (pathStr.startsWith(""String_Node_Str"")) {
      return new File(new URL(""String_Node_Str"" + pathStr).toURI());
    }
 else {
      String base=resolveBaseFile.toURI().toString();
      if (!base.endsWith(""String_Node_Str"")) {
        base+=""String_Node_Str"";
      }
      return new File(new URL(base + pathStr).toURI());
    }
  }
 catch (  MalformedURLException|URISyntaxException e) {
    if (FastClasspathScanner.verbose) {
      Log.log(""String_Node_Str"" + resolveBaseFile + ""String_Node_Str""+ relativePathStr+ ""String_Node_Str""+ e);
    }
    return null;
  }
}","/** 
 * Strip away any ""jar:"" prefix from a filename URI, and convert it to a file path, handling possibly-broken mixes of filesystem and URI conventions. Follows symbolic links, and resolves any relative paths relative to resolveBaseFile.
 */
private static File urlToFile(final File resolveBaseFile,final String relativePathStr){
  if (relativePathStr.isEmpty()) {
    return null;
  }
  String pathStr=relativePathStr;
  if (pathStr.startsWith(""String_Node_Str"")) {
    pathStr=pathStr.substring(4);
  }
  if (pathStr.startsWith(""String_Node_Str"") || pathStr.startsWith(""String_Node_Str"")) {
    if (FastClasspathScanner.verbose) {
      Log.log(""String_Node_Str"" + pathStr);
    }
    return null;
  }
  if (pathStr.indexOf('\\') >= 0) {
    pathStr=pathStr.replace('\\','/');
  }
  if (pathStr.startsWith(""String_Node_Str"")) {
    pathStr=pathStr.substring(7);
  }
  if (pathStr.startsWith(""String_Node_Str"")) {
    pathStr=pathStr.substring(5);
  }
  if (pathStr.length() > 2 && Character.isLetter(pathStr.charAt(0)) && pathStr.charAt(1) == ':') {
    pathStr='/' + pathStr;
  }
  if (pathStr.endsWith(""String_Node_Str"") && !pathStr.equals(""String_Node_Str"")) {
    pathStr=pathStr.substring(0,pathStr.length() - 1);
  }
  pathStr=pathStr.replace(""String_Node_Str"",""String_Node_Str"");
  try {
    if (pathStr.startsWith(""String_Node_Str"")) {
      return new File(new URL(""String_Node_Str"" + pathStr).toURI());
    }
 else     if (resolveBaseFile == null) {
      return new File(new URL(pathStr).toURI());
    }
 else {
      String base=resolveBaseFile.toURI().toString();
      if (!base.endsWith(""String_Node_Str"")) {
        base+=""String_Node_Str"";
      }
      return new File(new URL(base + pathStr).toURI());
    }
  }
 catch (  MalformedURLException|URISyntaxException e) {
    if (FastClasspathScanner.verbose) {
      Log.log(""String_Node_Str"" + resolveBaseFile + ""String_Node_Str""+ relativePathStr+ ""String_Node_Str""+ e);
    }
    return null;
  }
}"
3628,"/** 
 * Read another chunk of size BUFFER_CHUNK_SIZE from the InputStream; double the size of the buffer if necessary to accommodate the new chunk.
 */
private void readMore(final int amountToRead) throws IOException {
  final int totReadAhead=amountToRead + BUFFER_CHUNK_SIZE;
  final int newUsed=used + totReadAhead;
  int newBufLen=buf.length;
  while (newBufLen < newUsed) {
    newBufLen<<=1;
  }
  if (newBufLen > buf.length) {
    buf=Arrays.copyOf(buf,newBufLen);
  }
  final int bytesRead=inputStream.read(buf,used,totReadAhead);
  if (bytesRead < 0) {
    throw new IOException(""String_Node_Str"");
  }
  used+=bytesRead;
}","/** 
 * Read another chunk of size BUFFER_CHUNK_SIZE from the InputStream; double the size of the buffer if necessary to accommodate the new chunk.
 */
private void readMore(final int amountToRead) throws IOException {
  int bytesToRead=amountToRead + BUFFER_CHUNK_SIZE;
  final int newUsed=used + bytesToRead;
  int newBufLen=buf.length;
  while (newBufLen < newUsed) {
    newBufLen<<=1;
  }
  if (newBufLen > buf.length) {
    buf=Arrays.copyOf(buf,newBufLen);
  }
  while (bytesToRead > 0) {
    final int bytesRead=inputStream.read(buf,used,bytesToRead);
    if (bytesRead > 0) {
      used+=bytesRead;
      bytesToRead-=bytesRead;
    }
 else {
      break;
    }
  }
  if (used - curr < amountToRead) {
    throw new IOException(""String_Node_Str"");
  }
}"
3629,"/** 
 * Constructs a FastClasspathScanner instance. You can pass a scanning specification to the constructor to describe what should be scanned. This prevents irrelevant classpath entries from being unecessarily scanned, which can be time-consuming. (Note that calling the constructor does not start the scan, you must separately call .scan() to perform the actual scan.)
 * @param scanSpec The constructor accepts a list of whitelisted package prefixes / jar names to scan, as well as blacklisted packages/jars not to scan, where blacklisted entries are prefixed with the '-' character. For example: new FastClasspathScanner(""com.x""): limits scanning to the package com.x and its sub-packages in all jarfiles and all directory entries on the classpath. new FastClasspathScanner(""com.x"", ""-com.x.y""): limits scanning to com.x and all sub-packages *except* com.x.y in all jars and directories on the classpath. new FastClasspathScanner(""com.x"", ""-com.x.y"", ""jar:deploy.jar""): limits scanning to com.x and all its sub-packages except com.x.y, but only looks in jars named deploy.jar on the classpath. Note: 1. Whitelisting one or more jar entries prevents non-jar entries (directories) on the classpath from being scanned. 2. Only the leafname of a jarfile can be specified in a ""jar:"" or ""-jar:"" entry, so if there is a chance of conflict, make sure the jarfile's leaf name is unique. new FastClasspathScanner(""com.x"", ""-jar:irrelevant.jar""): limits scanning to com.x and all sub-packages in all directories on the classpath, and in all jars except irrelevant.jar. (i.e. blacklisting a jarfile only excludes the specified jarfile, it doesn't prevent all directories from being scanned, as with whitelisting a jarfile.) new FastClasspathScanner(""com.x"", ""jar:""): limits scanning to com.x and all sub-packages, but only looks in jarfiles on the classpath -- directories are not scanned. (i.e. ""jar:"" is a wildcard to indicate that all jars are whitelisted, and as in the example above, whitelisting jarfiles prevents non-jars (directories) from being scanned.) new FastClasspathScanner(""com.x"", ""-jar:""): limits scanning to com.x and all sub-packages, but only looks in directories on the classpath -- jarfiles are not scanned. (i.e. ""-jar:"" is a wildcard to indicate that all jars are blacklisted.) new FastClasspathScanner(): If you don't specify any whitelisted package prefixes, all jarfiles and all directories on the classpath will be scanned. N.B. System, bootstrap and extension jarfiles (i.e. the JRE jarfiles) are never scanned.
 */
public FastClasspathScanner(final String... scanSpec){
  this.recursiveScanner=new RecursiveScanner(classpathFinder,scanSpec);
  final ArrayList<String> whitelistClassRefPrefix=new ArrayList<>();
  final ArrayList<String> blacklistClassRefPrefix=new ArrayList<>();
  if (scanSpec.length == 0 || (scanSpec.length == 1 && scanSpec[0].isEmpty())) {
    for (    String pkg : BLACKLISTED_PACKAGES) {
      String pkgPrefix=pkg + ""String_Node_Str"";
      blacklistedPackagePrefixes.add(pkgPrefix);
      blacklistClassRefPrefix.add(pkgPrefix.replace('.','/'));
    }
  }
 else {
    for (    final String spec : scanSpec) {
      if (!(spec.startsWith(""String_Node_Str"") || spec.startsWith(""String_Node_Str""))) {
        if (spec.startsWith(""String_Node_Str"")) {
          String pkgPrefix=spec.substring(1) + ""String_Node_Str"";
          if (!pkgPrefix.isEmpty()) {
            blacklistedPackagePrefixes.add(pkgPrefix);
          }
          final String descriptor=pkgPrefix.replace('.','/');
          blacklistClassRefPrefix.add(descriptor);
        }
 else {
          String pkgPrefix=spec + ""String_Node_Str"";
          if (!spec.isEmpty()) {
            whitelistedPackagePrefixes.add(pkgPrefix);
          }
          final String descriptor=spec.replace('.','/');
          whitelistClassRefPrefix.add(descriptor);
        }
      }
    }
  }
  this.matchFilenameExtension(""String_Node_Str"",new FileMatchProcessor(){
    @Override public void processMatch(    final String relativePath,    final InputStream inputStream,    final int lengthBytes) throws IOException {
      if (!relativePathToClassInfo.containsKey(relativePath)) {
        final ClassInfo classInfo=ClassfileBinaryParser.readClassInfoFromClassfileHeader(relativePath,inputStream,classNameToStaticFieldnameToMatchProcessor,whitelistClassRefPrefix,blacklistClassRefPrefix);
        if (classInfo != null) {
          relativePathToClassInfo.put(relativePath,classInfo);
        }
      }
 else {
        if (verbose) {
          Log.log(relativePath.replace('/','.') + ""String_Node_Str"");
        }
      }
    }
  }
);
}","/** 
 * Constructs a FastClasspathScanner instance. You can pass a scanning specification to the constructor to describe what should be scanned. This prevents irrelevant classpath entries from being unecessarily scanned, which can be time-consuming. (Note that calling the constructor does not start the scan, you must separately call .scan() to perform the actual scan.)
 * @param scanSpec The constructor accepts a list of whitelisted package prefixes / jar names to scan, as well as blacklisted packages/jars not to scan, where blacklisted entries are prefixed with the '-' character. For example: new FastClasspathScanner(""com.x""): limits scanning to the package com.x and its sub-packages in all jarfiles and all directory entries on the classpath. new FastClasspathScanner(""com.x"", ""-com.x.y""): limits scanning to com.x and all sub-packages *except* com.x.y in all jars and directories on the classpath. new FastClasspathScanner(""com.x"", ""-com.x.y"", ""jar:deploy.jar""): limits scanning to com.x and all its sub-packages except com.x.y, but only looks in jars named deploy.jar on the classpath. Note: 1. Whitelisting one or more jar entries prevents non-jar entries (directories) on the classpath from being scanned. 2. Only the leafname of a jarfile can be specified in a ""jar:"" or ""-jar:"" entry, so if there is a chance of conflict, make sure the jarfile's leaf name is unique. new FastClasspathScanner(""com.x"", ""-jar:irrelevant.jar""): limits scanning to com.x and all sub-packages in all directories on the classpath, and in all jars except irrelevant.jar. (i.e. blacklisting a jarfile only excludes the specified jarfile, it doesn't prevent all directories from being scanned, as with whitelisting a jarfile.) new FastClasspathScanner(""com.x"", ""jar:""): limits scanning to com.x and all sub-packages, but only looks in jarfiles on the classpath -- directories are not scanned. (i.e. ""jar:"" is a wildcard to indicate that all jars are whitelisted, and as in the example above, whitelisting jarfiles prevents non-jars (directories) from being scanned.) new FastClasspathScanner(""com.x"", ""-jar:""): limits scanning to com.x and all sub-packages, but only looks in directories on the classpath -- jarfiles are not scanned. (i.e. ""-jar:"" is a wildcard to indicate that all jars are blacklisted.) new FastClasspathScanner(): If you don't specify any whitelisted package prefixes, all jarfiles and all directories on the classpath will be scanned. N.B. System, bootstrap and extension jarfiles (i.e. the JRE jarfiles) are never scanned.
 */
public FastClasspathScanner(final String... scanSpec){
  this.classpathFinder=new ClasspathFinder();
  if (FastClasspathScanner.verbose) {
    Log.log(""String_Node_Str"" + this.classpathFinder.getUniqueClasspathElements());
  }
  this.scanSpec=new ScanSpec(scanSpec);
  this.recursiveScanner=new RecursiveScanner(classpathFinder,this.scanSpec);
  final ScanSpec scanSpecParsed=this.scanSpec;
  this.matchFilenameExtension(""String_Node_Str"",new FileMatchProcessor(){
    @Override public void processMatch(    final String relativePath,    final InputStream inputStream,    final int lengthBytes) throws IOException {
      if (!relativePathToClassInfo.containsKey(relativePath)) {
        final ClassInfo classInfo=ClassfileBinaryParser.readClassInfoFromClassfileHeader(relativePath,inputStream,classNameToStaticFieldnameToMatchProcessor,scanSpecParsed);
        if (classInfo != null) {
          relativePathToClassInfo.put(relativePath,classInfo);
        }
      }
 else {
        if (verbose) {
          Log.log(relativePath.replace('/','.') + ""String_Node_Str"");
        }
      }
    }
  }
);
}"
3630,"/** 
 * Check a class is a regular class or interface and not an annotation, and that it is in a whitelisted package. Throws IllegalArgumentException otherwise. Returns the name of the class or interface.
 */
private String classOrInterfaceName(final Class<?> classOrInterface){
  String classOrIfaceName=classOrInterface.getName();
  checkClassNameIsInWhitelistedPackage(classOrIfaceName);
  if (classOrInterface.isAnnotation()) {
    throw new IllegalArgumentException(classOrIfaceName + ""String_Node_Str"");
  }
  return classOrInterface.getName();
}","/** 
 * Check a class is a regular class or interface and not an annotation, and that it is in a whitelisted package. Throws IllegalArgumentException otherwise. Returns the name of the class or interface.
 */
private String classOrInterfaceName(final Class<?> classOrInterface){
  final String classOrIfaceName=classOrInterface.getName();
  checkClassNameIsInWhitelistedPackage(classOrIfaceName);
  if (classOrInterface.isAnnotation()) {
    throw new IllegalArgumentException(classOrIfaceName + ""String_Node_Str"");
  }
  return classOrInterface.getName();
}"
3631,"/** 
 * Check a class is an annotation, and that it is in a whitelisted package. Throws IllegalArgumentException otherwise. Returns the name of the annotation.
 */
private String annotationName(final Class<?> annotation){
  String annotationName=annotation.getName();
  checkClassNameIsInWhitelistedPackage(annotationName);
  if (!annotation.isAnnotation()) {
    throw new IllegalArgumentException(annotationName + ""String_Node_Str"");
  }
  return annotation.getName();
}","/** 
 * Check a class is an annotation, and that it is in a whitelisted package. Throws IllegalArgumentException otherwise. Returns the name of the annotation.
 */
private String annotationName(final Class<?> annotation){
  final String annotationName=annotation.getName();
  checkClassNameIsInWhitelistedPackage(annotationName);
  if (!annotation.isAnnotation()) {
    throw new IllegalArgumentException(annotationName + ""String_Node_Str"");
  }
  return annotation.getName();
}"
3632,"/** 
 * Check a class is in a whitelisted package. Returns the name of the class if it is in a whitelisted package, otherwise throws an IllegalArgumentException.
 */
private String className(final Class<?> cls){
  String className=cls.getName();
  checkClassNameIsInWhitelistedPackage(className);
  return className;
}","/** 
 * Check a class is in a whitelisted package. Returns the name of the class if it is in a whitelisted package, otherwise throws an IllegalArgumentException.
 */
private String className(final Class<?> cls){
  final String className=cls.getName();
  checkClassNameIsInWhitelistedPackage(className);
  return className;
}"
3633,"/** 
 * Check a class is an interface, and that it is in a whitelisted package. Throws IllegalArgumentException otherwise. Returns the name of the interface.
 */
private String interfaceName(final Class<?> iface){
  String ifaceName=iface.getName();
  checkClassNameIsInWhitelistedPackage(ifaceName);
  if (!iface.isInterface()) {
    throw new IllegalArgumentException(ifaceName + ""String_Node_Str"");
  }
  return iface.getName();
}","/** 
 * Check a class is an interface, and that it is in a whitelisted package. Throws IllegalArgumentException otherwise. Returns the name of the interface.
 */
private String interfaceName(final Class<?> iface){
  final String ifaceName=iface.getName();
  checkClassNameIsInWhitelistedPackage(ifaceName);
  if (!iface.isInterface()) {
    throw new IllegalArgumentException(ifaceName + ""String_Node_Str"");
  }
  return iface.getName();
}"
3634,"/** 
 * Check a class is a standard class (not an interface or annotation), and that it is in a whitelisted package. Returns the name of the class if it is a standard class and it is in a whitelisted package, otherwise throws an IllegalArgumentException.
 */
private String standardClassName(final Class<?> cls){
  String className=cls.getName();
  checkClassNameIsInWhitelistedPackage(className);
  if (cls.isAnnotation()) {
    throw new IllegalArgumentException(className + ""String_Node_Str"");
  }
 else   if (cls.isInterface()) {
    throw new IllegalArgumentException(cls.getName() + ""String_Node_Str"");
  }
  return className;
}","/** 
 * Check a class is a standard class (not an interface or annotation), and that it is in a whitelisted package. Returns the name of the class if it is a standard class and it is in a whitelisted package, otherwise throws an IllegalArgumentException.
 */
private String standardClassName(final Class<?> cls){
  final String className=cls.getName();
  checkClassNameIsInWhitelistedPackage(className);
  if (cls.isAnnotation()) {
    throw new IllegalArgumentException(className + ""String_Node_Str"");
  }
 else   if (cls.isInterface()) {
    throw new IllegalArgumentException(cls.getName() + ""String_Node_Str"");
  }
  return className;
}"
3635,"/** 
 * Checks that the named class is in a whitelisted (non-blacklisted) package. Throws IllegalArgumentException otherwise.
 */
private void checkClassNameIsInWhitelistedPackage(String className){
  boolean isWhitelisted=whitelistedPackagePrefixes.isEmpty();
  for (  String pkgPrefix : whitelistedPackagePrefixes) {
    if (className.startsWith(pkgPrefix)) {
      isWhitelisted=true;
      break;
    }
  }
  boolean isBlacklisted=false;
  for (  String pkgPrefix : blacklistedPackagePrefixes) {
    if (className.startsWith(pkgPrefix)) {
      isBlacklisted=true;
      break;
    }
  }
  if (isBlacklisted) {
    throw new IllegalArgumentException(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  if (!isWhitelisted) {
    throw new IllegalArgumentException(""String_Node_Str"" + className + ""String_Node_Str"");
  }
}","/** 
 * Checks that the named class is in a whitelisted (non-blacklisted) package. Throws IllegalArgumentException otherwise.
 */
private void checkClassNameIsInWhitelistedPackage(final String className){
  if (!scanSpec.classIsInWhitelistedPackage(className)) {
    throw new IllegalArgumentException(""String_Node_Str"" + className + ""String_Node_Str"");
  }
}"
3636,"/** 
 * Calls the provided ClassMatchProcessor for classes on the classpath that have a field of the given type. Matches classes that have fields of the given type, array fields with an element type of the given type, and fields of parameterized type that have a type parameter of the given type. (Does not call the classloader on non-matching classes.) The field type must be declared in a package that is whitelisted (and not blacklisted).
 * @param implementedInterface The interface that classes need to implement.
 * @param classMatchProcessor the ClassMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchClassesWithFieldOfType(final Class<T> fieldType,final ClassMatchProcessor classMatchProcessor){
  classMatchers.add(new ClassMatcher(){
    @Override public void lookForMatches(){
      String fieldTypeName=className(fieldType);
      for (      final String klass : getNamesOfClassesWithFieldOfType(fieldTypeName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + fieldTypeName + ""String_Node_Str""+ klass);
        }
        final Class<? extends T> cls=loadClass(klass);
        classMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}","/** 
 * Calls the provided ClassMatchProcessor for classes on the classpath that have a field of the given type. Matches classes that have fields of the given type, array fields with an element type of the given type, and fields of parameterized type that have a type parameter of the given type. (Does not call the classloader on non-matching classes.) The field type must be declared in a package that is whitelisted (and not blacklisted).
 * @param implementedInterface The interface that classes need to implement.
 * @param classMatchProcessor the ClassMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchClassesWithFieldOfType(final Class<T> fieldType,final ClassMatchProcessor classMatchProcessor){
  classMatchers.add(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String fieldTypeName=className(fieldType);
      for (      final String klass : getNamesOfClassesWithFieldOfType(fieldTypeName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + fieldTypeName + ""String_Node_Str""+ klass);
        }
        final Class<? extends T> cls=loadClass(klass);
        classMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}"
3637,"/** 
 * Returns the names of classes that have a field of the given type. Returns classes that have fields with the same type as the requested type, array fields with an element type that matches the requested type, and fields of parameterized type that have a type parameter of the requested type. The field type must be declared in a package that is whitelisted (and not blacklisted).
 */
public List<String> getNamesOfClassesWithFieldOfType(final Class<?> fieldType){
  String fieldTypeName=fieldType.getName();
  checkClassNameIsInWhitelistedPackage(fieldTypeName);
  return getScanResults().getNamesOfClassesWithFieldOfType(fieldTypeName);
}","/** 
 * Returns the names of classes that have a field of the given type. Returns classes that have fields with the same type as the requested type, array fields with an element type that matches the requested type, and fields of parameterized type that have a type parameter of the requested type. The field type must be declared in a package that is whitelisted (and not blacklisted).
 */
public List<String> getNamesOfClassesWithFieldOfType(final Class<?> fieldType){
  final String fieldTypeName=fieldType.getName();
  checkClassNameIsInWhitelistedPackage(fieldTypeName);
  return getScanResults().getNamesOfClassesWithFieldOfType(fieldTypeName);
}"
3638,"/** 
 * Directly examine contents of classfile binary header to determine annotations, implemented interfaces, the super-class etc.
 * @return the information obtained as a ClassInfo object, or null if the classfile is invalid.
 */
public static ClassInfo readClassInfoFromClassfileHeader(final String relativePath,final InputStream inputStream,final HashMap<String,HashMap<String,StaticFinalFieldMatchProcessor>> classNameToStaticFieldnameToMatchProcessor,final ArrayList<String> whitelistClassRefPrefix,final ArrayList<String> blacklistClassRefPrefix){
  try (final DataInputStream inp=new DataInputStream(new BufferedInputStream(inputStream,8192))){
    if (inp.readInt() != 0xCAFEBABE) {
      if (FastClasspathScanner.verbose) {
        Log.log(""String_Node_Str"" + relativePath);
      }
      return null;
    }
    inp.readUnsignedShort();
    inp.readUnsignedShort();
    final int cpCount=inp.readUnsignedShort();
    final Object[] constantPool=new Object[cpCount];
    final int[] indirectStringRef=new int[cpCount];
    Arrays.fill(indirectStringRef,-1);
    for (int i=1; i < cpCount; ++i) {
      final int tag=inp.readUnsignedByte();
switch (tag) {
case 1:
        constantPool[i]=inp.readUTF();
      break;
case 3:
    constantPool[i]=inp.readInt();
  break;
case 4:
constantPool[i]=inp.readFloat();
break;
case 5:
constantPool[i]=inp.readLong();
i++;
break;
case 6:
constantPool[i]=inp.readDouble();
i++;
break;
case 7:
case 8:
indirectStringRef[i]=inp.readUnsignedShort();
break;
case 9:
case 10:
case 11:
case 12:
inp.skipBytes(4);
break;
case 15:
inp.skipBytes(3);
break;
case 16:
inp.skipBytes(2);
break;
case 18:
inp.skipBytes(4);
break;
default :
break;
}
}
for (int i=1; i < cpCount; i++) {
if (indirectStringRef[i] >= 0) {
constantPool[i]=constantPool[indirectStringRef[i]];
}
}
final int flags=inp.readUnsignedShort();
final boolean isInterface=(flags & 0x0200) != 0;
final boolean isAnnotation=(flags & 0x2000) != 0;
final String classNamePath=readRefdString(inp,constantPool);
final String className=classNamePath.replace('/','.');
String superclassName=readRefdString(inp,constantPool);
if (superclassName != null) {
superclassName=superclassName.replace('/','.');
}
if (className.equals(""String_Node_Str"")) {
return null;
}
if (!className.equals(relativePath.substring(0,relativePath.length() - 6).replace('/','.'))) {
if (FastClasspathScanner.verbose) {
Log.log(""String_Node_Str"" + className + ""String_Node_Str""+ relativePath+ ""String_Node_Str"");
}
return null;
}
final ClassInfo classInfo=new ClassInfo(className,isInterface && !isAnnotation,isAnnotation,superclassName);
final int interfaceCount=inp.readUnsignedShort();
classInfo.interfaceNames=interfaceCount > 0 ? new ArrayList<String>(interfaceCount) : null;
for (int i=0; i < interfaceCount; i++) {
classInfo.interfaceNames.add(readRefdString(inp,constantPool).replace('/','.'));
}
final HashMap<String,StaticFinalFieldMatchProcessor> staticFieldnameToMatchProcessor=classNameToStaticFieldnameToMatchProcessor.get(classInfo.className);
HashSet<String> whitelistedFieldTypes=null;
final int fieldCount=inp.readUnsignedShort();
for (int i=0; i < fieldCount; i++) {
final int accessFlags=inp.readUnsignedShort();
final boolean isStaticFinal=(accessFlags & 0x0018) == 0x0018;
final String fieldName=readRefdString(inp,constantPool);
final StaticFinalFieldMatchProcessor staticFinalFieldMatchProcessor=staticFieldnameToMatchProcessor != null ? staticFieldnameToMatchProcessor.get(fieldName) : null;
final String fieldTypeDescriptor=readRefdString(inp,constantPool);
final int attributesCount=inp.readUnsignedShort();
whitelistedFieldTypes=findWhitelistedTypeDescriptorParts(fieldTypeDescriptor,whitelistClassRefPrefix,blacklistClassRefPrefix,whitelistedFieldTypes);
if (!isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + classInfo.className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str"");
}
boolean foundConstantValue=false;
for (int j=0; j < attributesCount; j++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (attributeName.equals(""String_Node_Str"") && isStaticFinal && staticFinalFieldMatchProcessor != null) {
Object constValue=constantPool[inp.readUnsignedShort()];
switch (fieldTypeDescriptor) {
case ""String_Node_Str"":
constValue=((Integer)constValue).byteValue();
break;
case ""String_Node_Str"":
constValue=(char)((Integer)constValue).intValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).shortValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).intValue() != 0;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
break;
default :
break;
}
if (FastClasspathScanner.verbose) {
Log.log(""String_Node_Str"" + classInfo.className + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ constValue);
}
staticFinalFieldMatchProcessor.processMatch(classInfo.className,fieldName,constValue);
foundConstantValue=true;
}
 else if (attributeName.equals(""String_Node_Str"")) {
final String fieldTypeSignature=readRefdString(inp,constantPool);
whitelistedFieldTypes=findWhitelistedTypeDescriptorParts(fieldTypeSignature,whitelistClassRefPrefix,blacklistClassRefPrefix,whitelistedFieldTypes);
}
 else {
inp.skipBytes(attributeLength);
}
if (!foundConstantValue && isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + classInfo.className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
}
classInfo.whitelistedFieldTypes=whitelistedFieldTypes;
final int methodCount=inp.readUnsignedShort();
for (int i=0; i < methodCount; i++) {
inp.skipBytes(6);
final int attributesCount=inp.readUnsignedShort();
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
final int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
classInfo.annotationNames=null;
final int attributesCount=inp.readUnsignedShort();
for (int i=0; i < attributesCount; i++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (""String_Node_Str"".equals(attributeName)) {
final int annotationCount=inp.readUnsignedShort();
for (int m=0; m < annotationCount; m++) {
final String annotationName=readAnnotation(inp,constantPool);
if (!annotationName.startsWith(""String_Node_Str"")) {
if (classInfo.annotationNames == null) {
classInfo.annotationNames=new ArrayList<>();
}
classInfo.annotationNames.add(annotationName);
}
}
}
 else {
inp.skipBytes(attributeLength);
}
}
return classInfo;
}
 catch (final IOException e) {
Log.log(""String_Node_Str"" + relativePath + ""String_Node_Str""+ e.getMessage());
return null;
}
}","/** 
 * Directly examine contents of classfile binary header to determine annotations, implemented interfaces, the super-class etc.
 * @return the information obtained as a ClassInfo object, or null if the classfile is invalid.
 */
public static ClassInfo readClassInfoFromClassfileHeader(final String relativePath,final InputStream inputStream,final HashMap<String,HashMap<String,StaticFinalFieldMatchProcessor>> classNameToStaticFieldnameToMatchProcessor,final ScanSpec scanSpec){
  try (final DataInputStream inp=new DataInputStream(new BufferedInputStream(inputStream,8192))){
    if (inp.readInt() != 0xCAFEBABE) {
      if (FastClasspathScanner.verbose) {
        Log.log(""String_Node_Str"" + relativePath);
      }
      return null;
    }
    inp.readUnsignedShort();
    inp.readUnsignedShort();
    final int cpCount=inp.readUnsignedShort();
    final Object[] constantPool=new Object[cpCount];
    final int[] indirectStringRef=new int[cpCount];
    Arrays.fill(indirectStringRef,-1);
    for (int i=1; i < cpCount; ++i) {
      final int tag=inp.readUnsignedByte();
switch (tag) {
case 1:
        constantPool[i]=inp.readUTF();
      break;
case 3:
    constantPool[i]=inp.readInt();
  break;
case 4:
constantPool[i]=inp.readFloat();
break;
case 5:
constantPool[i]=inp.readLong();
i++;
break;
case 6:
constantPool[i]=inp.readDouble();
i++;
break;
case 7:
case 8:
indirectStringRef[i]=inp.readUnsignedShort();
break;
case 9:
case 10:
case 11:
case 12:
inp.skipBytes(4);
break;
case 15:
inp.skipBytes(3);
break;
case 16:
inp.skipBytes(2);
break;
case 18:
inp.skipBytes(4);
break;
default :
break;
}
}
for (int i=1; i < cpCount; i++) {
if (indirectStringRef[i] >= 0) {
constantPool[i]=constantPool[indirectStringRef[i]];
}
}
final int flags=inp.readUnsignedShort();
final boolean isInterface=(flags & 0x0200) != 0;
final boolean isAnnotation=(flags & 0x2000) != 0;
final String classNamePath=readRefdString(inp,constantPool);
final String className=classNamePath.replace('/','.');
String superclassName=readRefdString(inp,constantPool);
if (superclassName != null) {
superclassName=superclassName.replace('/','.');
}
if (className.equals(""String_Node_Str"")) {
return null;
}
if (!className.equals(relativePath.substring(0,relativePath.length() - 6).replace('/','.'))) {
if (FastClasspathScanner.verbose) {
Log.log(""String_Node_Str"" + className + ""String_Node_Str""+ relativePath+ ""String_Node_Str"");
}
return null;
}
final ClassInfo classInfo=new ClassInfo(className,isInterface && !isAnnotation,isAnnotation,superclassName);
final int interfaceCount=inp.readUnsignedShort();
classInfo.interfaceNames=interfaceCount > 0 ? new ArrayList<String>(interfaceCount) : null;
for (int i=0; i < interfaceCount; i++) {
classInfo.interfaceNames.add(readRefdString(inp,constantPool).replace('/','.'));
}
final HashMap<String,StaticFinalFieldMatchProcessor> staticFieldnameToMatchProcessor=classNameToStaticFieldnameToMatchProcessor.get(classInfo.className);
HashSet<String> whitelistedFieldTypes=null;
final int fieldCount=inp.readUnsignedShort();
for (int i=0; i < fieldCount; i++) {
final int accessFlags=inp.readUnsignedShort();
final boolean isStaticFinal=(accessFlags & 0x0018) == 0x0018;
final String fieldName=readRefdString(inp,constantPool);
final StaticFinalFieldMatchProcessor staticFinalFieldMatchProcessor=staticFieldnameToMatchProcessor != null ? staticFieldnameToMatchProcessor.get(fieldName) : null;
final String fieldTypeDescriptor=readRefdString(inp,constantPool);
final int attributesCount=inp.readUnsignedShort();
whitelistedFieldTypes=findWhitelistedTypeDescriptorParts(fieldTypeDescriptor,scanSpec,whitelistedFieldTypes);
if (!isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + classInfo.className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str"");
}
boolean foundConstantValue=false;
for (int j=0; j < attributesCount; j++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (attributeName.equals(""String_Node_Str"") && isStaticFinal && staticFinalFieldMatchProcessor != null) {
Object constValue=constantPool[inp.readUnsignedShort()];
switch (fieldTypeDescriptor) {
case ""String_Node_Str"":
constValue=((Integer)constValue).byteValue();
break;
case ""String_Node_Str"":
constValue=(char)((Integer)constValue).intValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).shortValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).intValue() != 0;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
break;
default :
break;
}
if (FastClasspathScanner.verbose) {
Log.log(""String_Node_Str"" + classInfo.className + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ constValue);
}
staticFinalFieldMatchProcessor.processMatch(classInfo.className,fieldName,constValue);
foundConstantValue=true;
}
 else if (attributeName.equals(""String_Node_Str"")) {
final String fieldTypeSignature=readRefdString(inp,constantPool);
whitelistedFieldTypes=findWhitelistedTypeDescriptorParts(fieldTypeSignature,scanSpec,whitelistedFieldTypes);
}
 else {
inp.skipBytes(attributeLength);
}
if (!foundConstantValue && isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + classInfo.className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
}
classInfo.whitelistedFieldTypes=whitelistedFieldTypes;
final int methodCount=inp.readUnsignedShort();
for (int i=0; i < methodCount; i++) {
inp.skipBytes(6);
final int attributesCount=inp.readUnsignedShort();
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
final int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
classInfo.annotationNames=null;
final int attributesCount=inp.readUnsignedShort();
for (int i=0; i < attributesCount; i++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (""String_Node_Str"".equals(attributeName)) {
final int annotationCount=inp.readUnsignedShort();
for (int m=0; m < annotationCount; m++) {
final String annotationName=readAnnotation(inp,constantPool);
if (!annotationName.startsWith(""String_Node_Str"")) {
if (classInfo.annotationNames == null) {
classInfo.annotationNames=new ArrayList<>();
}
classInfo.annotationNames.add(annotationName);
}
}
}
 else {
inp.skipBytes(attributeLength);
}
}
return classInfo;
}
 catch (final IOException e) {
Log.log(""String_Node_Str"" + relativePath + ""String_Node_Str""+ e.getMessage());
return null;
}
}"
3639,"/** 
 * Find whitelisted (non-blacklisted) type names in the given type descriptor, and add them to the set of whitelisted field types.
 */
private static HashSet<String> findWhitelistedTypeDescriptorParts(final String typeDescriptor,final ArrayList<String> whitelistClassRefPrefix,final ArrayList<String> blacklistClassRefPrefix,HashSet<String> whitelistedFieldTypes){
  final Matcher matcher=TYPE_PARAM_PATTERN.matcher(typeDescriptor);
  while (matcher.find()) {
    final String descriptorPart=matcher.group(2);
    boolean isWhitelisted=whitelistClassRefPrefix.isEmpty();
    for (    final String whitelistPrefix : whitelistClassRefPrefix) {
      if (descriptorPart.startsWith(whitelistPrefix)) {
        isWhitelisted=true;
        break;
      }
    }
    boolean isBlacklisted=false;
    for (    final String blacklistPrefix : blacklistClassRefPrefix) {
      if (descriptorPart.startsWith(blacklistPrefix)) {
        isBlacklisted=true;
        break;
      }
    }
    if (isWhitelisted && !isBlacklisted) {
      if (whitelistedFieldTypes == null) {
        whitelistedFieldTypes=new HashSet<>();
      }
      final String fieldTypeName=descriptorPart.replace('/','.');
      whitelistedFieldTypes.add(fieldTypeName);
    }
  }
  return whitelistedFieldTypes;
}","/** 
 * Find whitelisted (non-blacklisted) type names in the given type descriptor, and add them to the set of whitelisted field types.
 */
private static HashSet<String> findWhitelistedTypeDescriptorParts(final String typeDescriptor,final ScanSpec scanSpec,HashSet<String> whitelistedFieldTypes){
  final Matcher matcher=TYPE_PARAM_PATTERN.matcher(typeDescriptor);
  while (matcher.find()) {
    final String descriptorPart=matcher.group(2);
    if (scanSpec.pathIsWhitelisted(descriptorPart)) {
      if (whitelistedFieldTypes == null) {
        whitelistedFieldTypes=new HashSet<>();
      }
      final String fieldTypeName=descriptorPart.replace('/','.');
      whitelistedFieldTypes.add(fieldTypeName);
    }
  }
  return whitelistedFieldTypes;
}"
3640,"public ImplementedInterfaceDAGNode(ClassInfo classInfo){
  super(classInfo);
}","public ImplementedInterfaceDAGNode(final ClassInfo classInfo){
  super(classInfo);
}"
3641,"public ClassGraphBuilder(final Collection<ClassInfo> relativePathToClassInfo){
  this.allClassInfo=new ArrayList<>(relativePathToClassInfo);
}","public ClassGraphBuilder(final Collection<ClassInfo> classInfoFromScan){
  this.allClassInfo=new ArrayList<>(handleScalaAuxClasses(classInfoFromScan));
}"
3642,"/** 
 * Connect this node to a different node type (for annotations, the cross-linked class is a class annotated by this annotation; for regular classes, the cross-linked class is an interface that the class implements).
 */
public void addCrossLink(final String crossLinkedClassName){
  this.crossLinkedClassNames.add(crossLinkedClassName);
}","/** 
 * Connect this node to a different node type (for annotations, the cross-linked class is a class annotated by this annotation; for regular classes, the cross-linked class is an interface that the class implements).
 */
public DAGNode addCrossLink(final String crossLinkedClassName){
  this.crossLinkedClassNames.add(crossLinkedClassName);
  return this;
}"
3643,"/** 
 * Get the named node from the map, or create a new node with this name and store it in the map if there isn't yet a node in the map with this name. Returns the found or created node, after connecting it as a super-node to the specified sub-node.
 */
public static DAGNode getOrNew(final HashMap<String,DAGNode> map,final String name,final DAGNode subNode){
  DAGNode node=map.get(name);
  if (node == null) {
    map.put(name,node=new DAGNode(name));
  }
  subNode.directSuperNodes.add(node);
  node.directSubNodes.add(subNode);
  return node;
}","/** 
 * Get the named node from the map, or create a new node with this name and store it in the map if there isn't yet a node in the map with this name. Returns the found or created node.
 */
public static DAGNode getOrNew(final HashMap<String,DAGNode> map,final String name){
  DAGNode node=map.get(name);
  if (node == null) {
    map.put(name,node=new DAGNode(name));
  }
  return node;
}"
3644,"/** 
 * Parse the system classpath. 
 */
private void parseSystemClasspath(){
  clearClasspath();
  final ArrayList<ClassLoader> classLoaders=new ArrayList<>();
  final HashSet<ClassLoader> classLoadersSet=new HashSet<>();
  classLoadersSet.add(ClassLoader.getSystemClassLoader());
  classLoaders.add(ClassLoader.getSystemClassLoader());
  try {
    throw new Exception();
  }
 catch (  final Exception e) {
    final StackTraceElement[] stacktrace=e.getStackTrace();
    if (stacktrace.length >= 3) {
      final ArrayList<ClassLoader> callerClassLoaders=new ArrayList<>();
      final StackTraceElement caller=stacktrace[2];
      for (ClassLoader cl=caller.getClass().getClassLoader(); cl != null; cl=cl.getParent()) {
        callerClassLoaders.add(cl);
      }
      for (int i=callerClassLoaders.size() - 1; i >= 0; --i) {
        final ClassLoader cl=callerClassLoaders.get(i);
        if (classLoadersSet.add(cl)) {
          classLoaders.add(cl);
        }
      }
    }
  }
  if (classLoadersSet.add(Thread.currentThread().getContextClassLoader())) {
    classLoaders.add(Thread.currentThread().getContextClassLoader());
  }
  for (  final ClassLoader cl : classLoaders) {
    if (cl != null) {
      if (cl instanceof URLClassLoader) {
        for (        final URL url : ((URLClassLoader)cl).getURLs()) {
          final String protocol=url.getProtocol();
          if (protocol == null || protocol.equalsIgnoreCase(""String_Node_Str"")) {
            addClasspathElement(url.getFile());
          }
        }
      }
 else       if (cl.getClass().getName().equals(""String_Node_Str"")) {
        try {
          final Method getPaths=cl.getClass().getDeclaredMethod(""String_Node_Str"");
          getPaths.setAccessible(true);
          @SuppressWarnings(""String_Node_Str"") final Set<String> paths=(Set<String>)getPaths.invoke(cl);
          for (          final String path : paths) {
            addClasspathElement(path);
          }
        }
 catch (        final Exception e) {
          Log.log(""String_Node_Str"" + cl.getClass().getName() + ""String_Node_Str""+ e.getMessage());
        }
      }
 else {
        Log.log(""String_Node_Str"" + cl.getClass().getName());
      }
    }
  }
  final String classpathProperty=System.getProperty(""String_Node_Str"");
  if (classpathProperty == null || classpathProperty.isEmpty()) {
    for (    final String pathElement : classpathProperty.split(File.pathSeparator)) {
      addClasspathElement(pathElement);
    }
  }
  initialized=true;
}","/** 
 * Parse the system classpath. 
 */
private void parseSystemClasspath(){
  clearClasspath();
  final ArrayList<ClassLoader> classLoaders=new ArrayList<>();
  final HashSet<ClassLoader> classLoadersSet=new HashSet<>();
  classLoadersSet.add(ClassLoader.getSystemClassLoader());
  classLoaders.add(ClassLoader.getSystemClassLoader());
  try {
    throw new Exception();
  }
 catch (  final Exception e) {
    final StackTraceElement[] stacktrace=e.getStackTrace();
    if (stacktrace.length >= 3) {
      final ArrayList<ClassLoader> callerClassLoaders=new ArrayList<>();
      final StackTraceElement caller=stacktrace[2];
      for (ClassLoader cl=caller.getClass().getClassLoader(); cl != null; cl=cl.getParent()) {
        callerClassLoaders.add(cl);
      }
      for (int i=callerClassLoaders.size() - 1; i >= 0; --i) {
        final ClassLoader cl=callerClassLoaders.get(i);
        if (classLoadersSet.add(cl)) {
          classLoaders.add(cl);
        }
      }
    }
  }
  if (classLoadersSet.add(Thread.currentThread().getContextClassLoader())) {
    classLoaders.add(Thread.currentThread().getContextClassLoader());
  }
  for (  final ClassLoader cl : classLoaders) {
    if (cl != null) {
      if (cl instanceof URLClassLoader) {
        for (        final URL url : ((URLClassLoader)cl).getURLs()) {
          final String protocol=url.getProtocol();
          if (protocol == null || protocol.equalsIgnoreCase(""String_Node_Str"")) {
            addClasspathElement(url.getFile());
          }
        }
      }
 else       if (cl.getClass().getName().equals(""String_Node_Str"")) {
        try {
          final Method getPaths=cl.getClass().getDeclaredMethod(""String_Node_Str"");
          getPaths.setAccessible(true);
          @SuppressWarnings(""String_Node_Str"") final Set<String> paths=(Set<String>)getPaths.invoke(cl);
          for (          final String path : paths) {
            addClasspathElement(path);
          }
        }
 catch (        final Exception e) {
          Log.log(""String_Node_Str"" + cl.getClass().getName() + ""String_Node_Str""+ e.getMessage());
        }
      }
 else {
        Log.log(""String_Node_Str"" + cl.getClass().getName());
      }
    }
  }
  addClasspathElements(System.getProperty(""String_Node_Str""));
  initialized=true;
}"
3645,"/** 
 * Override the system classpath with a custom classpath to search. 
 */
public void overrideClasspath(final String classpath){
  clearClasspath();
  for (  final String pathElement : classpath.split(File.pathSeparator)) {
    addClasspathElement(pathElement);
  }
  initialized=true;
}","/** 
 * Override the system classpath with a custom classpath to search. 
 */
public void overrideClasspath(final String classpath){
  clearClasspath();
  addClasspathElements(classpath);
  initialized=true;
}"
3646,"/** 
 * Constructs a FastClasspathScanner instance.
 * @param packagesToScan the whitelist of package prefixes to scan, e.g. ""com.xyz.widget"", ""com.xyz.gizmo"". If no whitelisted packages are given (i.e. if the constructor is called with zero arguments), or a whitelisted package is """", then all packages on the classpath are whitelisted. If a package name is prefixed with ""-"", e.g. ""-com.xyz.otherthing"", then that package is blacklisted, rather than whitelisted. The final list of packages scanned is the set of whitelisted packages minus the set of blacklisted packages.
 */
public FastClasspathScanner(final String... packagesToScan){
  final HashSet<String> uniqueWhitelistedPaths=new HashSet<>();
  final HashSet<String> uniqueBlacklistedPaths=new HashSet<>();
  boolean scanAll=false;
  if (packagesToScan.length == 0) {
    scanAll=true;
  }
 else {
    for (    final String packageToScan : packagesToScan) {
      if (packageToScan.isEmpty()) {
        scanAll=true;
        break;
      }
      String pkg=packageToScan.replace('.','/') + ""String_Node_Str"";
      final boolean blacklisted=pkg.startsWith(""String_Node_Str"");
      if (blacklisted) {
        pkg=pkg.substring(1);
      }
      (blacklisted ? uniqueBlacklistedPaths : uniqueWhitelistedPaths).add(pkg);
    }
  }
  uniqueWhitelistedPaths.removeAll(uniqueBlacklistedPaths);
  String[] whitelistedPaths;
  if (scanAll) {
    whitelistedPaths=new String[]{""String_Node_Str""};
  }
 else {
    whitelistedPaths=new String[uniqueWhitelistedPaths.size()];
    int i=0;
    for (    final String path : uniqueWhitelistedPaths) {
      whitelistedPaths[i++]=path;
    }
  }
  String[] blacklistedPaths;
  blacklistedPaths=new String[uniqueBlacklistedPaths.size()];
  int i=0;
  for (  final String path : uniqueBlacklistedPaths) {
    blacklistedPaths[i++]=path;
  }
  classpath=new ClasspathFinder();
  classGraphBuilder=new ClassGraphBuilder();
  recursiveScanner=new RecursiveScanner(classpath,whitelistedPaths,blacklistedPaths,classGraphBuilder);
  this.matchFilenameExtension(""String_Node_Str"",new FileMatchProcessor(){
    @Override public void processMatch(    final String relativePath,    final InputStream inputStream,    final int lengthBytes) throws IOException {
      classGraphBuilder.readClassInfoFromClassfileHeader(relativePath,inputStream,classNameToStaticFieldnameToMatchProcessor);
    }
  }
);
}","/** 
 * Constructs a FastClasspathScanner instance.
 * @param packagesToScan the whitelist of package prefixes to scan, e.g. ""com.xyz.widget"", ""com.xyz.gizmo"". If no whitelisted packages are given (i.e. if the constructor is called with zero arguments), or a whitelisted package is """", then all packages on the classpath are whitelisted. If a package name is prefixed with ""-"", e.g. ""-com.xyz.otherthing"", then that package is blacklisted, rather than whitelisted. The final list of packages scanned is the set of whitelisted packages minus the set of blacklisted packages.
 */
public FastClasspathScanner(final String... packagesToScan){
  final HashSet<String> uniqueWhitelistedPaths=new HashSet<>();
  final HashSet<String> uniqueBlacklistedPaths=new HashSet<>();
  boolean scanAll=false;
  if (packagesToScan.length == 0) {
    scanAll=true;
  }
 else {
    for (    final String packageToScan : packagesToScan) {
      if (packageToScan.isEmpty()) {
        scanAll=true;
        break;
      }
      String pkg=packageToScan.replace('.','/') + ""String_Node_Str"";
      final boolean blacklisted=pkg.startsWith(""String_Node_Str"");
      if (blacklisted) {
        pkg=pkg.substring(1);
      }
      (blacklisted ? uniqueBlacklistedPaths : uniqueWhitelistedPaths).add(pkg);
    }
  }
  uniqueWhitelistedPaths.removeAll(uniqueBlacklistedPaths);
  String[] whitelistedPaths;
  if (scanAll) {
    whitelistedPaths=new String[]{""String_Node_Str""};
  }
 else {
    whitelistedPaths=new String[uniqueWhitelistedPaths.size()];
    int i=0;
    for (    final String path : uniqueWhitelistedPaths) {
      whitelistedPaths[i++]=path;
    }
  }
  String[] blacklistedPaths;
  blacklistedPaths=new String[uniqueBlacklistedPaths.size()];
  int i=0;
  for (  final String path : uniqueBlacklistedPaths) {
    blacklistedPaths[i++]=path;
  }
  recursiveScanner=new RecursiveScanner(classpath,whitelistedPaths,blacklistedPaths);
  this.matchFilenameExtension(""String_Node_Str"",new FileMatchProcessor(){
    @Override public void processMatch(    final String relativePath,    final InputStream inputStream,    final int lengthBytes) throws IOException {
      final ClassInfo newClassInfo=new ClassInfo(relativePath);
      final ClassInfo oldClassInfo=classNameToClassInfo.put(newClassInfo.className,newClassInfo);
      if (oldClassInfo == null) {
        ClassfileBinaryParser.readClassInfoFromClassfileHeader(relativePath,inputStream,newClassInfo,classNameToStaticFieldnameToMatchProcessor);
      }
 else {
        if (FastClasspathScanner.verbose) {
          Log.log(relativePath.replace('/','.') + ""String_Node_Str"");
        }
      }
    }
  }
);
}"
3647,"/** 
 * Scans the classpath for matching files, and calls any match processors if a match is identified. This method should be called after all required match processors have been added. This method should be called before any ""getNamesOf"" methods (e.g. getNamesOfSubclassesOf()).
 */
public FastClasspathScanner scan(){
  recursiveScanner.scan(false);
  return this;
}","/** 
 * Scans the classpath for matching files, and calls any match processors if a match is identified. This method should be called after all required match processors have been added. This method should be called before any ""getNamesOf"" methods (e.g. getNamesOfSubclassesOf()).
 */
public FastClasspathScanner scan(){
  final long scanStart=System.currentTimeMillis();
  classNameToClassInfo.clear();
  recursiveScanner.scan(false);
  classGraphBuilder=new ClassGraphBuilder(classNameToClassInfo.values());
  for (  final ClassMatcher classMatcher : classMatchers) {
    classMatcher.lookForMatches();
  }
  if (FastClasspathScanner.verbose) {
    Log.log(""String_Node_Str"" + (System.currentTimeMillis() - scanStart) + ""String_Node_Str"");
  }
  return this;
}"
3648,"/** 
 * Calls the provided InterfaceMatchProcessor for classes on the classpath that implement the specified interface or a subinterface, or whose superclasses implement the specified interface or a sub-interface. Will call the class loader on each matching interface (using Class.forName()) before calling the InterfaceMatchProcessor. Does not call the classloader on non-matching classes or interfaces.
 * @param implementedInterface The interface that classes need to implement.
 * @param interfaceMatchProcessor the ClassMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchClassesImplementing(final Class<T> implementedInterface,final InterfaceMatchProcessor<T> interfaceMatchProcessor){
  recursiveScanner.addClassMatcher(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String implementedInterfaceName=interfaceName(implementedInterface);
      for (      final String implClass : getNamesOfClassesImplementing(implementedInterfaceName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + implementedInterfaceName + ""String_Node_Str""+ implClass);
        }
        final Class<? extends T> cls=loadClass(implClass);
        interfaceMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}","/** 
 * Calls the provided InterfaceMatchProcessor for classes on the classpath that implement the specified interface or a subinterface, or whose superclasses implement the specified interface or a sub-interface. Will call the class loader on each matching interface (using Class.forName()) before calling the InterfaceMatchProcessor. Does not call the classloader on non-matching classes or interfaces.
 * @param implementedInterface The interface that classes need to implement.
 * @param interfaceMatchProcessor the ClassMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchClassesImplementing(final Class<T> implementedInterface,final InterfaceMatchProcessor<T> interfaceMatchProcessor){
  classMatchers.add(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String implementedInterfaceName=interfaceName(implementedInterface);
      for (      final String implClass : getNamesOfClassesImplementing(implementedInterfaceName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + implementedInterfaceName + ""String_Node_Str""+ implClass);
        }
        final Class<? extends T> cls=loadClass(implClass);
        interfaceMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}"
3649,"/** 
 * Calls the provided SubinterfaceMatchProcessor if an interface that extends a given superinterface is found on the classpath. Will call the class loader on each matching interface (using Class.forName()) before calling the SubinterfaceMatchProcessor. Does not call the classloader on non-matching classes or interfaces.
 * @param superinterface The superinterface to match (i.e. the interface that subinterfaces need to extend to match).
 * @param subinterfaceMatchProcessor the SubinterfaceMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchSubinterfacesOf(final Class<T> superinterface,final SubinterfaceMatchProcessor<T> subinterfaceMatchProcessor){
  recursiveScanner.addClassMatcher(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String superinterfaceName=interfaceName(superinterface);
      for (      final String subinterfaceName : getNamesOfSubinterfacesOf(superinterfaceName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + superinterfaceName + ""String_Node_Str""+ subinterfaceName);
        }
        final Class<? extends T> cls=loadClass(subinterfaceName);
        subinterfaceMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}","/** 
 * Calls the provided SubinterfaceMatchProcessor if an interface that extends a given superinterface is found on the classpath. Will call the class loader on each matching interface (using Class.forName()) before calling the SubinterfaceMatchProcessor. Does not call the classloader on non-matching classes or interfaces.
 * @param superinterface The superinterface to match (i.e. the interface that subinterfaces need to extend to match).
 * @param subinterfaceMatchProcessor the SubinterfaceMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchSubinterfacesOf(final Class<T> superinterface,final SubinterfaceMatchProcessor<T> subinterfaceMatchProcessor){
  classMatchers.add(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String superinterfaceName=interfaceName(superinterface);
      for (      final String subinterfaceName : getNamesOfSubinterfacesOf(superinterfaceName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + superinterfaceName + ""String_Node_Str""+ subinterfaceName);
        }
        final Class<? extends T> cls=loadClass(subinterfaceName);
        subinterfaceMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}"
3650,"/** 
 * Returns the names of classes on the classpath that implement the specified interface or a subinterface, or whose superclasses implement the specified interface or a sub-interface. Should be called after scan(), and returns matching interfaces whether or not an InterfaceMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param implementedInterfaceName The name of the interface that classes need to implement.
 * @return A list of the names of matching classes, or the empty list if none.
 */
public List<String> getNamesOfClassesImplementing(final String implementedInterfaceName){
  return classGraphBuilder.getNamesOfClassesImplementing(implementedInterfaceName);
}","/** 
 * Returns the names of classes on the classpath that implement the specified interface or a subinterface, or whose superclasses implement the specified interface or a sub-interface. Should be called after scan(), and returns matching interfaces whether or not an InterfaceMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param implementedInterfaceName The name of the interface that classes need to implement.
 * @return A list of the names of matching classes, or the empty list if none.
 */
public List<String> getNamesOfClassesImplementing(final String implementedInterfaceName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfClassesImplementing(implementedInterfaceName);
}"
3651,"/** 
 * Calls the provided ClassMatchProcessor if classes are found on the classpath that have the specified annotation.
 * @param annotation The class annotation to match.
 * @param classAnnotationMatchProcessor the ClassAnnotationMatchProcessor to call when a match is found.
 */
public FastClasspathScanner matchClassesWithAnnotation(final Class<?> annotation,final ClassAnnotationMatchProcessor classAnnotationMatchProcessor){
  recursiveScanner.addClassMatcher(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String annotationName=annotationName(annotation);
      for (      final String classWithAnnotation : getNamesOfClassesWithAnnotation(annotationName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + annotationName + ""String_Node_Str""+ classWithAnnotation);
        }
        final Class<?> cls=loadClass(classWithAnnotation);
        classAnnotationMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}","/** 
 * Calls the provided ClassMatchProcessor if classes are found on the classpath that have the specified annotation.
 * @param annotation The class annotation to match.
 * @param classAnnotationMatchProcessor the ClassAnnotationMatchProcessor to call when a match is found.
 */
public FastClasspathScanner matchClassesWithAnnotation(final Class<?> annotation,final ClassAnnotationMatchProcessor classAnnotationMatchProcessor){
  classMatchers.add(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String annotationName=annotationName(annotation);
      for (      final String classWithAnnotation : getNamesOfClassesWithAnnotation(annotationName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + annotationName + ""String_Node_Str""+ classWithAnnotation);
        }
        final Class<?> cls=loadClass(classWithAnnotation);
        classAnnotationMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}"
3652,"/** 
 * Return the names of all annotations that are annotated with the specified meta-annotation.
 * @param metaAnnotationName The name of the specified meta-annotation.
 * @return A list of the names of annotations that are annotated with the specified meta annotation, or theempty list if none.
 */
public List<String> getNamesOfAnnotationsWithMetaAnnotation(final String metaAnnotationName){
  return classGraphBuilder.getNamesOfAnnotationsWithMetaAnnotation(metaAnnotationName);
}","/** 
 * Return the names of all annotations that are annotated with the specified meta-annotation.
 * @param metaAnnotationName The name of the specified meta-annotation.
 * @return A list of the names of annotations that are annotated with the specified meta annotation, or theempty list if none.
 */
public List<String> getNamesOfAnnotationsWithMetaAnnotation(final String metaAnnotationName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfAnnotationsWithMetaAnnotation(metaAnnotationName);
}"
3653,"/** 
 * Returns the names of classes on the classpath that are superclasses of the specified subclass. Should be called after scan(), and returns matching classes whether or not a SubclassMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param subclassName The subclass to match (i.e. the class that needs to extend a superclass for the superclass to match).
 * @return A list of the names of matching classes, or the empty list if none.
 */
public List<String> getNamesOfSuperclassesOf(final String subclassName){
  return classGraphBuilder.getNamesOfSuperclassesOf(subclassName);
}","/** 
 * Returns the names of classes on the classpath that are superclasses of the specified subclass. Should be called after scan(), and returns matching classes whether or not a SubclassMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param subclassName The subclass to match (i.e. the class that needs to extend a superclass for the superclass to match).
 * @return A list of the names of matching classes, or the empty list if none.
 */
public List<String> getNamesOfSuperclassesOf(final String subclassName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfSuperclassesOf(subclassName);
}"
3654,"/** 
 * Returns the names of interfaces on the classpath that are superinterfaces of a given subinterface. Should be called after scan(), and returns matching interfaces whether or not a SubinterfaceMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching interfaces, just returns their
 * @param subInterfaceName The name of the superinterface to match (i.e. the name of the interface that subinterfaces need to extend).
 * @return A list of the names of matching interfaces, or the empty list if none.
 */
public List<String> getNamesOfSuperinterfacesOf(final String subInterfaceName){
  return classGraphBuilder.getNamesOfSuperinterfacesOf(subInterfaceName);
}","/** 
 * Returns the names of interfaces on the classpath that are superinterfaces of a given subinterface. Should be called after scan(), and returns matching interfaces whether or not a SubinterfaceMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching interfaces, just returns their
 * @param subInterfaceName The name of the superinterface to match (i.e. the name of the interface that subinterfaces need to extend).
 * @return A list of the names of matching interfaces, or the empty list if none.
 */
public List<String> getNamesOfSuperinterfacesOf(final String subInterfaceName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfSuperinterfacesOf(subInterfaceName);
}"
3655,"/** 
 * Returns the names of all classes and interfaces processed during the scan, i.e. all classes reachable after taking into account the package whitelist and blacklist criteria.
 */
public Set<String> getNamesOfAllClasses(){
  return classGraphBuilder.getNamesOfAllClasses();
}","/** 
 * Returns the names of all classes and interfaces processed during the scan, i.e. all classes reachable after taking into account the package whitelist and blacklist criteria.
 */
public Set<String> getNamesOfAllClasses(){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfAllClasses();
}"
3656,"/** 
 * Returns the names of interfaces on the classpath that extend a given superinterface. Should be called after scan(), and returns matching interfaces whether or not a SubinterfaceMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching interfaces, just returns their names.
 * @param superInterfaceName The name of the superinterface to match (i.e. the name of the interface that subinterfaces need to extend).
 * @return A list of the names of matching interfaces, or the empty list if none.
 */
public List<String> getNamesOfSubinterfacesOf(final String superInterfaceName){
  return classGraphBuilder.getNamesOfSubinterfacesOf(superInterfaceName);
}","/** 
 * Returns the names of interfaces on the classpath that extend a given superinterface. Should be called after scan(), and returns matching interfaces whether or not a SubinterfaceMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching interfaces, just returns their names.
 * @param superInterfaceName The name of the superinterface to match (i.e. the name of the interface that subinterfaces need to extend).
 * @return A list of the names of matching interfaces, or the empty list if none.
 */
public List<String> getNamesOfSubinterfacesOf(final String superInterfaceName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfSubinterfacesOf(superInterfaceName);
}"
3657,"/** 
 * Return the names of all annotations and meta-annotations on the specified class or interface.
 * @param classOrInterfaceName The name of the class or interface.
 * @return A list of the names of annotations and meta-annotations on the class, or the empty list if none.
 */
public List<String> getNamesOfAnnotationsOnClass(final String classOrInterfaceName){
  return classGraphBuilder.getNamesOfAnnotationsOnClass(classOrInterfaceName);
}","/** 
 * Return the names of all annotations and meta-annotations on the specified class or interface.
 * @param classOrInterfaceName The name of the class or interface.
 * @return A list of the names of annotations and meta-annotations on the class, or the empty list if none.
 */
public List<String> getNamesOfAnnotationsOnClass(final String classOrInterfaceName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfAnnotationsOnClass(classOrInterfaceName);
}"
3658,"/** 
 * Returns true if the classpath contents have been changed since scan() was last called. Only considers classpath prefixes whitelisted in the call to the constructor. Returns true if scan() has not yet been run. Much faster than standard classpath scanning, because only timestamps are checked, and jarfiles don't have to be opened.
 */
public boolean classpathContentsModifiedSinceScan(){
  return recursiveScanner.classpathContentsModifiedSinceScan();
}","/** 
 * Returns true if the classpath contents have been changed since scan() was last called. Only considers classpath prefixes whitelisted in the call to the constructor. Returns true if scan() has not yet been run. Much faster than standard classpath scanning, because only timestamps are checked, and jarfiles don't have to be opened.
 */
public boolean classpathContentsModifiedSinceScan(){
  final long scanStart=System.currentTimeMillis();
  boolean modified=recursiveScanner.classpathContentsModifiedSinceScan();
  if (FastClasspathScanner.verbose) {
    Log.log(""String_Node_Str"" + (System.currentTimeMillis() - scanStart) + ""String_Node_Str"");
  }
  return modified;
}"
3659,"/** 
 * Returns the names of classes on the classpath that have the specified annotation. Should be called after scan(), and returns matching classes whether or not a ClassAnnotationMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param annotationName The name of the class annotation.
 * @return A list of the names of classes that have the named annotation, or the empty list if none.
 */
public List<String> getNamesOfClassesWithAnnotation(final String annotationName){
  return classGraphBuilder.getNamesOfClassesWithAnnotation(annotationName);
}","/** 
 * Returns the names of classes on the classpath that have the specified annotation. Should be called after scan(), and returns matching classes whether or not a ClassAnnotationMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param annotationName The name of the class annotation.
 * @return A list of the names of classes that have the named annotation, or the empty list if none.
 */
public List<String> getNamesOfClassesWithAnnotation(final String annotationName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfClassesWithAnnotation(annotationName);
}"
3660,"/** 
 * Calls the provided SubclassMatchProcessor if classes are found on the classpath that extend the specified superclass. Will call the class loader on each matching class (using Class.forName()) before calling the SubclassMatchProcessor. Does not call the classloader on non-matching classes or interfaces.
 * @param superclass The superclass to match (i.e. the class that subclasses need to extend to match).
 * @param subclassMatchProcessor the SubclassMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchSubclassesOf(final Class<T> superclass,final SubclassMatchProcessor<T> subclassMatchProcessor){
  recursiveScanner.addClassMatcher(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String superclassName=className(superclass);
      for (      final String subclassName : getNamesOfSubclassesOf(superclassName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + superclassName + ""String_Node_Str""+ subclassName);
        }
        final Class<? extends T> cls=loadClass(subclassName);
        subclassMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}","/** 
 * Calls the provided SubclassMatchProcessor if classes are found on the classpath that extend the specified superclass. Will call the class loader on each matching class (using Class.forName()) before calling the SubclassMatchProcessor. Does not call the classloader on non-matching classes or interfaces.
 * @param superclass The superclass to match (i.e. the class that subclasses need to extend to match).
 * @param subclassMatchProcessor the SubclassMatchProcessor to call when a match is found.
 */
public <T>FastClasspathScanner matchSubclassesOf(final Class<T> superclass,final SubclassMatchProcessor<T> subclassMatchProcessor){
  classMatchers.add(new ClassMatcher(){
    @Override public void lookForMatches(){
      final String superclassName=className(superclass);
      for (      final String subclassName : getNamesOfSubclassesOf(superclassName)) {
        if (verbose) {
          Log.log(""String_Node_Str"" + superclassName + ""String_Node_Str""+ subclassName);
        }
        final Class<? extends T> cls=loadClass(subclassName);
        subclassMatchProcessor.processMatch(cls);
      }
    }
  }
);
  return this;
}"
3661,"/** 
 * Return the names of all meta-annotations on the specified annotation.
 * @param annotationName The name of the specified annotation.
 * @return A list of the names of meta-annotations on the specified annotation, or the empty list if none.
 */
public List<String> getNamesOfMetaAnnotationsOnAnnotation(final String annotationName){
  return classGraphBuilder.getNamesOfMetaAnnotationsOnAnnotation(annotationName);
}","/** 
 * Return the names of all meta-annotations on the specified annotation.
 * @param annotationName The name of the specified annotation.
 * @return A list of the names of meta-annotations on the specified annotation, or the empty list if none.
 */
public List<String> getNamesOfMetaAnnotationsOnAnnotation(final String annotationName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfMetaAnnotationsOnAnnotation(annotationName);
}"
3662,"/** 
 * Returns the names of classes on the classpath that extend the specified superclass. Should be called after scan(), and returns matching classes whether or not a SubclassMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param superclassName The name of the superclass to match (i.e. the name of the class that subclasses need to extend).
 * @return A list of the names of matching classes, or the empty list if none.
 */
public List<String> getNamesOfSubclassesOf(final String superclassName){
  return classGraphBuilder.getNamesOfSubclassesOf(superclassName);
}","/** 
 * Returns the names of classes on the classpath that extend the specified superclass. Should be called after scan(), and returns matching classes whether or not a SubclassMatchProcessor was added to the scanner before the call to scan(). Does not call the classloader on the matching classes, just returns their names.
 * @param superclassName The name of the superclass to match (i.e. the name of the class that subclasses need to extend).
 * @return A list of the names of matching classes, or the empty list if none.
 */
public List<String> getNamesOfSubclassesOf(final String superclassName){
  checkScanCompleted();
  return classGraphBuilder.getNamesOfSubclassesOf(superclassName);
}"
3663,"/** 
 * Directly examine contents of classfile binary header.
 * @param verbose
 */
public void readClassInfoFromClassfileHeader(final InputStream inputStream,boolean verbose) throws IOException {
  final DataInputStream inp=new DataInputStream(new BufferedInputStream(inputStream,1024));
  if (inp.readInt() != 0xCAFEBABE) {
    return;
  }
  inp.readUnsignedShort();
  inp.readUnsignedShort();
  final int cpCount=inp.readUnsignedShort();
  final Object[] constantPool=new Object[cpCount];
  final int[] indirectStringRef=new int[cpCount];
  Arrays.fill(indirectStringRef,-1);
  for (int i=1; i < cpCount; ++i) {
    final int tag=inp.readUnsignedByte();
switch (tag) {
case 1:
      constantPool[i]=inp.readUTF();
    break;
case 3:
  constantPool[i]=inp.readInt();
break;
case 4:
constantPool[i]=inp.readFloat();
break;
case 5:
constantPool[i]=inp.readLong();
i++;
break;
case 6:
constantPool[i]=inp.readDouble();
i++;
break;
case 7:
case 8:
indirectStringRef[i]=inp.readUnsignedShort();
break;
case 9:
case 10:
case 11:
case 12:
inp.skipBytes(4);
break;
case 15:
inp.skipBytes(3);
break;
case 16:
inp.skipBytes(2);
break;
case 18:
inp.skipBytes(4);
break;
default :
break;
}
}
for (int i=1; i < cpCount; i++) {
if (indirectStringRef[i] >= 0) {
constantPool[i]=constantPool[indirectStringRef[i]];
}
}
final int flags=inp.readUnsignedShort();
final boolean isInterface=(flags & 0x0200) != 0;
final boolean isAnnotation=(flags & 0x2000) != 0;
final String className=readRefdString(inp,constantPool).replace('/','.');
if (className.equals(""String_Node_Str"")) {
return;
}
if (!classesEncounteredSoFarDuringScan.add(className)) {
return;
}
final String superclassName=readRefdString(inp,constantPool).replace('/','.');
final HashMap<String,StaticFinalFieldMatchProcessor> staticFieldnameToMatchProcessor=classNameToStaticFieldnameToMatchProcessor.get(className);
final int interfaceCount=inp.readUnsignedShort();
final ArrayList<String> interfaces=interfaceCount > 0 ? new ArrayList<String>() : null;
for (int i=0; i < interfaceCount; i++) {
interfaces.add(readRefdString(inp,constantPool).replace('/','.'));
}
final int fieldCount=inp.readUnsignedShort();
for (int i=0; i < fieldCount; i++) {
final int accessFlags=inp.readUnsignedShort();
final boolean isStaticFinal=(accessFlags & 0x0018) == 0x0018;
final String fieldName=readRefdString(inp,constantPool);
final StaticFinalFieldMatchProcessor staticFinalFieldMatchProcessor=staticFieldnameToMatchProcessor != null ? staticFieldnameToMatchProcessor.get(fieldName) : null;
final String descriptor=readRefdString(inp,constantPool);
final int attributesCount=inp.readUnsignedShort();
if (!isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str"");
}
 else if (!isStaticFinal || staticFinalFieldMatchProcessor == null) {
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
final int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
 else {
boolean foundConstantValue=false;
for (int j=0; j < attributesCount; j++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (attributeName.equals(""String_Node_Str"")) {
Object constValue=constantPool[inp.readUnsignedShort()];
switch (descriptor) {
case ""String_Node_Str"":
constValue=((Integer)constValue).byteValue();
break;
case ""String_Node_Str"":
constValue=(char)((Integer)constValue).intValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).shortValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).intValue() != 0;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
break;
default :
break;
}
if (verbose) {
Log.log(""String_Node_Str"" + className + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ constValue);
}
staticFinalFieldMatchProcessor.processMatch(className,fieldName,constValue);
foundConstantValue=true;
}
 else {
inp.skipBytes(attributeLength);
}
if (!foundConstantValue) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
}
}
final int methodCount=inp.readUnsignedShort();
for (int i=0; i < methodCount; i++) {
inp.skipBytes(6);
final int attributesCount=inp.readUnsignedShort();
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
final int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
for (int i=0; i < inp.readUnsignedShort(); i++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (""String_Node_Str"".equals(attributeName)) {
final int annotationCount=inp.readUnsignedShort();
for (int m=0; m < annotationCount; m++) {
final String annotationName=readAnnotation(inp,constantPool);
linkAnnotation(annotationName,className,isAnnotation);
}
}
 else {
inp.skipBytes(attributeLength);
}
}
if (isAnnotation) {
}
 else if (isInterface) {
linkInterface(interfaces,className);
}
 else {
linkClass(superclassName,interfaces,className);
}
}","/** 
 * Directly examine contents of classfile binary header.
 * @param verbose
 */
public void readClassInfoFromClassfileHeader(final InputStream inputStream,boolean verbose) throws IOException {
  final DataInputStream inp=new DataInputStream(new BufferedInputStream(inputStream,1024));
  if (inp.readInt() != 0xCAFEBABE) {
    return;
  }
  inp.readUnsignedShort();
  inp.readUnsignedShort();
  final int cpCount=inp.readUnsignedShort();
  final Object[] constantPool=new Object[cpCount];
  final int[] indirectStringRef=new int[cpCount];
  Arrays.fill(indirectStringRef,-1);
  for (int i=1; i < cpCount; ++i) {
    final int tag=inp.readUnsignedByte();
switch (tag) {
case 1:
      constantPool[i]=inp.readUTF();
    break;
case 3:
  constantPool[i]=inp.readInt();
break;
case 4:
constantPool[i]=inp.readFloat();
break;
case 5:
constantPool[i]=inp.readLong();
i++;
break;
case 6:
constantPool[i]=inp.readDouble();
i++;
break;
case 7:
case 8:
indirectStringRef[i]=inp.readUnsignedShort();
break;
case 9:
case 10:
case 11:
case 12:
inp.skipBytes(4);
break;
case 15:
inp.skipBytes(3);
break;
case 16:
inp.skipBytes(2);
break;
case 18:
inp.skipBytes(4);
break;
default :
break;
}
}
for (int i=1; i < cpCount; i++) {
if (indirectStringRef[i] >= 0) {
constantPool[i]=constantPool[indirectStringRef[i]];
}
}
final int flags=inp.readUnsignedShort();
final boolean isInterface=(flags & 0x0200) != 0;
final boolean isAnnotation=(flags & 0x2000) != 0;
final String className=readRefdString(inp,constantPool).replace('/','.');
if (className.equals(""String_Node_Str"")) {
return;
}
if (!classesEncounteredSoFarDuringScan.add(className)) {
return;
}
final String superclassName=readRefdString(inp,constantPool).replace('/','.');
final HashMap<String,StaticFinalFieldMatchProcessor> staticFieldnameToMatchProcessor=classNameToStaticFieldnameToMatchProcessor.get(className);
final int interfaceCount=inp.readUnsignedShort();
final ArrayList<String> interfaces=interfaceCount > 0 ? new ArrayList<String>() : null;
for (int i=0; i < interfaceCount; i++) {
interfaces.add(readRefdString(inp,constantPool).replace('/','.'));
}
final int fieldCount=inp.readUnsignedShort();
for (int i=0; i < fieldCount; i++) {
final int accessFlags=inp.readUnsignedShort();
final boolean isStaticFinal=(accessFlags & 0x0018) == 0x0018;
final String fieldName=readRefdString(inp,constantPool);
final StaticFinalFieldMatchProcessor staticFinalFieldMatchProcessor=staticFieldnameToMatchProcessor != null ? staticFieldnameToMatchProcessor.get(fieldName) : null;
final String descriptor=readRefdString(inp,constantPool);
final int attributesCount=inp.readUnsignedShort();
if (!isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str"");
}
 else if (!isStaticFinal || staticFinalFieldMatchProcessor == null) {
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
final int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
 else {
boolean foundConstantValue=false;
for (int j=0; j < attributesCount; j++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (attributeName.equals(""String_Node_Str"")) {
Object constValue=constantPool[inp.readUnsignedShort()];
switch (descriptor) {
case ""String_Node_Str"":
constValue=((Integer)constValue).byteValue();
break;
case ""String_Node_Str"":
constValue=(char)((Integer)constValue).intValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).shortValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).intValue() != 0;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
break;
default :
break;
}
if (verbose) {
Log.log(""String_Node_Str"" + className + ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ constValue);
}
staticFinalFieldMatchProcessor.processMatch(className,fieldName,constValue);
foundConstantValue=true;
}
 else {
inp.skipBytes(attributeLength);
}
if (!foundConstantValue) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
}
}
final int methodCount=inp.readUnsignedShort();
for (int i=0; i < methodCount; i++) {
inp.skipBytes(6);
final int attributesCount=inp.readUnsignedShort();
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
final int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
int attributesCount=inp.readUnsignedShort();
for (int i=0; i < attributesCount; i++) {
final String attributeName=readRefdString(inp,constantPool);
final int attributeLength=inp.readInt();
if (""String_Node_Str"".equals(attributeName)) {
final int annotationCount=inp.readUnsignedShort();
for (int m=0; m < annotationCount; m++) {
final String annotationName=readAnnotation(inp,constantPool);
linkAnnotation(annotationName,className,isAnnotation);
}
}
 else {
inp.skipBytes(attributeLength);
}
}
if (isAnnotation) {
}
 else if (isInterface) {
linkInterface(interfaces,className);
}
 else {
linkClass(superclassName,interfaces,className);
}
}"
3664,"/** 
 * Find the upwards and downwards transitive closure for each node in a graph. Assumes the graph is a DAG in general, but handles cycles (which may occur in the case of meta-annotations).
 */
private static void findTransitiveClosure(Collection<? extends DAGNode> nodes){
  HashSet<DAGNode> activeTopDownNodes=new HashSet<>();
  for (  DAGNode node : nodes) {
    if (node.directSuperNodes.isEmpty()) {
      activeTopDownNodes.add(node);
    }
  }
  while (!activeTopDownNodes.isEmpty()) {
    HashSet<DAGNode> activeTopDownNodesNext=new HashSet<>(activeTopDownNodes.size());
    for (    DAGNode node : activeTopDownNodes) {
      boolean changed=node.allSuperNodes.addAll(node.directSuperNodes);
      for (      DAGNode superNode : node.directSuperNodes) {
        changed|=node.allSuperNodes.addAll(superNode.allSuperNodes);
      }
      if (changed) {
        for (        DAGNode subNode : node.directSubNodes) {
          activeTopDownNodesNext.add(subNode);
        }
      }
    }
    activeTopDownNodes=activeTopDownNodesNext;
  }
  HashSet<DAGNode> activeBottomUpNodes=new HashSet<>();
  for (  DAGNode node : nodes) {
    if (node.directSubNodes.isEmpty()) {
      activeBottomUpNodes.add(node);
    }
  }
  while (!activeBottomUpNodes.isEmpty()) {
    HashSet<DAGNode> activeBottomUpNodesNext=new HashSet<>(activeBottomUpNodes.size());
    for (    DAGNode node : activeBottomUpNodes) {
      boolean changed=node.allSubNodes.addAll(node.directSubNodes);
      for (      DAGNode subNode : node.directSubNodes) {
        changed|=node.allSubNodes.addAll(subNode.allSubNodes);
      }
      if (changed) {
        for (        DAGNode superNode : node.directSuperNodes) {
          activeBottomUpNodesNext.add(superNode);
        }
      }
    }
    activeBottomUpNodes=activeBottomUpNodesNext;
  }
}","/** 
 * Find the upwards and downwards transitive closure for each node in a graph. Assumes the graph is a DAG in general, but handles cycles (which may occur in the case of meta-annotations).
 */
private static void findTransitiveClosure(Collection<? extends DAGNode> nodes){
  HashSet<DAGNode> activeTopDownNodes=new HashSet<>();
  for (  DAGNode node : nodes) {
    if (node.directSuperNodes.isEmpty()) {
      for (      DAGNode sub : node.directSubNodes) {
        activeTopDownNodes.add(sub);
      }
    }
  }
  while (!activeTopDownNodes.isEmpty()) {
    HashSet<DAGNode> activeTopDownNodesNext=new HashSet<>(activeTopDownNodes.size());
    for (    DAGNode node : activeTopDownNodes) {
      boolean changed=node.allSuperNodes.addAll(node.directSuperNodes);
      for (      DAGNode superNode : node.directSuperNodes) {
        changed|=node.allSuperNodes.addAll(superNode.allSuperNodes);
      }
      if (changed) {
        for (        DAGNode subNode : node.directSubNodes) {
          activeTopDownNodesNext.add(subNode);
        }
      }
    }
    activeTopDownNodes=activeTopDownNodesNext;
  }
  HashSet<DAGNode> activeBottomUpNodes=new HashSet<>();
  for (  DAGNode node : nodes) {
    if (node.directSubNodes.isEmpty()) {
      for (      DAGNode sup : node.directSuperNodes) {
        activeBottomUpNodes.add(sup);
      }
    }
  }
  while (!activeBottomUpNodes.isEmpty()) {
    HashSet<DAGNode> activeBottomUpNodesNext=new HashSet<>(activeBottomUpNodes.size());
    for (    DAGNode node : activeBottomUpNodes) {
      boolean changed=node.allSubNodes.addAll(node.directSubNodes);
      for (      DAGNode subNode : node.directSubNodes) {
        changed|=node.allSubNodes.addAll(subNode.allSubNodes);
      }
      if (changed) {
        for (        DAGNode superNode : node.directSuperNodes) {
          activeBottomUpNodesNext.add(superNode);
        }
      }
    }
    activeBottomUpNodes=activeBottomUpNodesNext;
  }
}"
3665,"@Test public void varArgsAnyOfByClass(){
  assertThat(scanner.getNamesOfClassesWithMetaAnnotationsAnyOf(MetaAnnotation.class,NonMetaAnnotation.class)).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName(),NonMetaClass.class.getName());
}","@Test public void varArgsAnyOfByClass(){
  assertThat(scanner.getNamesOfClassesWithAnnotationsAnyOf(MetaAnnotation.class,NonMetaAnnotation.class)).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName(),NonMetaClass.class.getName());
}"
3666,"@Test public void metaAnnotationsByClass(){
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotatedAnnotation.class)).containsExactly(MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithMetaAnnotation(MetaAnnotation.class)).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithMetaAnnotation(MetaAnnotatedAnnotation.class)).containsOnly(MetaAnnotatedClass.class.getName(),MetaMetaAnnotatedClass.class.getName());
}","@Test public void metaAnnotationsByClass(){
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotatedAnnotation.class)).containsExactly(MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotation.class)).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotatedAnnotation.class)).containsOnly(MetaAnnotatedClass.class.getName(),MetaMetaAnnotatedClass.class.getName());
}"
3667,"@Test public void varArgsAllOfByClass(){
  assertThat(scanner.getNamesOfClassesWithMetaAnnotationsAllOf(MetaAnnotation.class,NonMetaAnnotation.class)).containsExactly(MetaAndNonMetaAnnotatedClass.class.getName());
}","@Test public void varArgsAllOfByClass(){
  assertThat(scanner.getNamesOfClassesWithAnnotationsAllOf(MetaAnnotation.class,NonMetaAnnotation.class)).containsExactly(MetaAndNonMetaAnnotatedClass.class.getName());
}"
3668,"@Test public void varArgsAllOfByName(){
  assertThat(scanner.getNamesOfClassesWithMetaAnnotationsAllOf(MetaAnnotation.class.getName(),NonMetaAnnotation.class.getName())).containsExactly(MetaAndNonMetaAnnotatedClass.class.getName());
}","@Test public void varArgsAllOfByName(){
  assertThat(scanner.getNamesOfClassesWithAnnotationsAllOf(MetaAnnotation.class.getName(),NonMetaAnnotation.class.getName())).containsExactly(MetaAndNonMetaAnnotatedClass.class.getName());
}"
3669,"@Test public void nonMeta(){
  assertThat(scanner.getNamesOfClassesWithMetaAnnotation(NonMetaAnnotation.class)).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),NonMetaClass.class.getName());
}","@Test public void nonMeta(){
  assertThat(scanner.getNamesOfClassesWithAnnotation(NonMetaAnnotation.class)).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),NonMetaClass.class.getName());
}"
3670,"@Test public void varArgsAnyOfByName(){
  assertThat(scanner.getNamesOfClassesWithMetaAnnotationsAnyOf(MetaAnnotation.class.getName(),NonMetaAnnotation.class.getName())).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName(),NonMetaClass.class.getName());
}","@Test public void varArgsAnyOfByName(){
  assertThat(scanner.getNamesOfClassesWithAnnotationsAnyOf(MetaAnnotation.class.getName(),NonMetaAnnotation.class.getName())).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName(),NonMetaClass.class.getName());
}"
3671,"@Test public void metaAnnotationsByName(){
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotatedAnnotation.class.getName())).containsExactly(MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithMetaAnnotation(MetaAnnotation.class.getName())).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithMetaAnnotation(MetaAnnotatedAnnotation.class.getName())).containsOnly(MetaAnnotatedClass.class.getName(),MetaMetaAnnotatedClass.class.getName());
}","@Test public void metaAnnotationsByName(){
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotatedAnnotation.class.getName())).containsExactly(MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotation.class.getName())).containsOnly(MetaAndNonMetaAnnotatedClass.class.getName(),MetaAnnotatedClass.class.getName());
  assertThat(scanner.getNamesOfClassesWithAnnotation(MetaAnnotatedAnnotation.class.getName())).containsOnly(MetaAnnotatedClass.class.getName(),MetaMetaAnnotatedClass.class.getName());
}"
3672,"/** 
 * Scan a zipfile for matching file path patterns. (Does not recurse into zipfiles within zipfiles.)
 */
private void scanZipfile(final String zipfilePath,final ZipFile zipFile,final long zipFileLastModified,final boolean scanTimestampsOnly) throws IOException {
  boolean timestampWarning=false;
  for (final Enumeration<? extends ZipEntry> entries=zipFile.entries(); entries.hasMoreElements(); ) {
    final ZipEntry entry=entries.nextElement();
    if (!entry.isDirectory()) {
      final String path=entry.getName();
      boolean scanFile=false;
      for (      final String whitelistedPath : whitelistedPathsToScan) {
        if (path.startsWith(whitelistedPath) || whitelistedPath.equals(""String_Node_Str"")) {
          scanFile=true;
          break;
        }
      }
      for (      final String blacklistedPath : blacklistedPathsToScan) {
        if (path.startsWith(blacklistedPath)) {
          scanFile=false;
          break;
        }
      }
      if (scanFile) {
        final long entryTime=USE_ZIPFILE_ENTRY_MODIFICATION_TIMES ? entry.getTime() : zipFileLastModified;
        lastModified=Math.max(lastModified,entryTime);
        if (entryTime > System.currentTimeMillis() && !timestampWarning) {
          final String msg=zipfilePath + ""String_Node_Str"";
          System.err.println(msg);
          timestampWarning=true;
        }
        if (!scanTimestampsOnly) {
          if (path.endsWith(""String_Node_Str"")) {
            try (final InputStream inputStream=zipFile.getInputStream(entry)){
              readClassInfoFromClassfileHeader(inputStream);
            }
             if (classNameToClassfileHash != null) {
              try (final InputStream inputStream=zipFile.getInputStream(entry)){
                hashInputStream(path.substring(0,path.length() - 6).replace('/','.'),inputStream);
              }
             }
          }
 else {
            for (            final FilePathMatcher fileMatcher : filePathMatchers) {
              if (fileMatcher.pattern.matcher(path).matches()) {
                try (final InputStream inputStream=zipFile.getInputStream(entry)){
                  fileMatcher.fileMatchProcessor.processMatch(path,path,inputStream);
                }
               }
            }
          }
        }
      }
    }
  }
}","/** 
 * Scan a zipfile for matching file path patterns. (Does not recurse into zipfiles within zipfiles.)
 */
private void scanZipfile(final String zipfilePath,final ZipFile zipFile,final long zipFileLastModified,final boolean scanTimestampsOnly) throws IOException {
  boolean timestampWarning=false;
  for (final Enumeration<? extends ZipEntry> entries=zipFile.entries(); entries.hasMoreElements(); ) {
    final ZipEntry entry=entries.nextElement();
    if (!entry.isDirectory()) {
      final String path=entry.getName();
      boolean scanFile=false;
      for (      final String whitelistedPath : whitelistedPathsToScan) {
        if (path.startsWith(whitelistedPath) || whitelistedPath.equals(""String_Node_Str"")) {
          scanFile=true;
          break;
        }
      }
      for (      final String blacklistedPath : blacklistedPathsToScan) {
        if (path.startsWith(blacklistedPath)) {
          scanFile=false;
          break;
        }
      }
      if (scanFile) {
        final long entryTime=USE_ZIPFILE_ENTRY_MODIFICATION_TIMES ? entry.getTime() : zipFileLastModified;
        lastModified=Math.max(lastModified,entryTime);
        if (entryTime > System.currentTimeMillis() && !timestampWarning) {
          final String msg=zipfilePath + ""String_Node_Str"";
          System.err.println(msg);
          timestampWarning=true;
        }
        if (!scanTimestampsOnly) {
          if (path.endsWith(""String_Node_Str"")) {
            try (final InputStream inputStream=zipFile.getInputStream(entry)){
              readClassInfoFromClassfileHeader(inputStream);
            }
             if (classNameToClassfileHash != null) {
              try (final InputStream inputStream=zipFile.getInputStream(entry)){
                hashInputStream(path.substring(0,path.length() - 6).replace('/','.'),inputStream);
              }
             }
          }
          for (          final FilePathMatcher fileMatcher : filePathMatchers) {
            if (fileMatcher.pattern.matcher(path).matches()) {
              try (final InputStream inputStream=zipFile.getInputStream(entry)){
                fileMatcher.fileMatchProcessor.processMatch(path,path,inputStream);
              }
             }
          }
        }
      }
    }
  }
}"
3673,"/** 
 * Scan a file.
 */
private void scanFile(final File file,final String absolutePath,final String relativePath,final boolean scanTimestampsOnly) throws IOException {
  lastModified=Math.max(lastModified,file.lastModified());
  if (!scanTimestampsOnly) {
    if (relativePath.endsWith(""String_Node_Str"")) {
      try (final InputStream inputStream=new FileInputStream(file)){
        readClassInfoFromClassfileHeader(inputStream);
      }
       if (classNameToClassfileHash != null) {
        try (final InputStream inputStream=new FileInputStream(file)){
          hashInputStream(relativePath.substring(0,relativePath.length() - 6).replace('/','.'),inputStream);
        }
       }
    }
 else {
      for (      final FilePathMatcher fileMatcher : filePathMatchers) {
        if (fileMatcher.pattern.matcher(relativePath).matches()) {
          try (final InputStream inputStream=new FileInputStream(file)){
            fileMatcher.fileMatchProcessor.processMatch(absolutePath,relativePath,inputStream);
          }
         }
      }
    }
  }
}","/** 
 * Scan a file.
 */
private void scanFile(final File file,final String absolutePath,final String relativePath,final boolean scanTimestampsOnly) throws IOException {
  lastModified=Math.max(lastModified,file.lastModified());
  if (!scanTimestampsOnly) {
    if (relativePath.endsWith(""String_Node_Str"")) {
      try (final InputStream inputStream=new FileInputStream(file)){
        readClassInfoFromClassfileHeader(inputStream);
      }
       if (classNameToClassfileHash != null) {
        try (final InputStream inputStream=new FileInputStream(file)){
          hashInputStream(relativePath.substring(0,relativePath.length() - 6).replace('/','.'),inputStream);
        }
       }
    }
    for (    final FilePathMatcher fileMatcher : filePathMatchers) {
      if (fileMatcher.pattern.matcher(relativePath).matches()) {
        try (final InputStream inputStream=new FileInputStream(file)){
          fileMatcher.fileMatchProcessor.processMatch(absolutePath,relativePath,inputStream);
        }
       }
    }
  }
}"
3674,"/** 
 * Directly examine contents of classfile binary header.
 */
private void readClassInfoFromClassfileHeader(final InputStream inputStream) throws IOException {
  DataInputStream inp=new DataInputStream(new BufferedInputStream(inputStream,1024));
  if (inp.readInt() != 0xCAFEBABE) {
    return;
  }
  inp.readUnsignedShort();
  inp.readUnsignedShort();
  int cpCount=inp.readUnsignedShort();
  Object[] constantPool=new Object[cpCount];
  int[] indirectStringRef=new int[cpCount];
  Arrays.fill(indirectStringRef,-1);
  for (int i=1; i < cpCount; ++i) {
    final int tag=inp.readUnsignedByte();
switch (tag) {
case 1:
      constantPool[i]=inp.readUTF();
    break;
case 3:
  constantPool[i]=inp.readInt();
break;
case 4:
constantPool[i]=inp.readFloat();
break;
case 5:
constantPool[i]=inp.readLong();
i++;
break;
case 6:
constantPool[i]=inp.readDouble();
i++;
break;
case 7:
case 8:
indirectStringRef[i]=inp.readUnsignedShort();
break;
case 9:
case 10:
case 11:
case 12:
inp.skipBytes(4);
break;
case 15:
inp.skipBytes(3);
break;
case 16:
inp.skipBytes(2);
break;
case 18:
inp.skipBytes(4);
break;
default :
break;
}
}
for (int i=1; i < cpCount; i++) {
if (indirectStringRef[i] >= 0) {
constantPool[i]=constantPool[indirectStringRef[i]];
}
}
int flags=inp.readUnsignedShort();
boolean isInterface=(flags & 0x0200) != 0;
String className=readRefdString(inp,constantPool).replace('/','.');
if (!classesEncounteredSoFarDuringScan.add(className)) {
return;
}
String superclassName=readRefdString(inp,constantPool).replace('/','.');
HashMap<String,StaticFinalFieldMatchProcessor> staticFieldnameToMatchProcessor=classNameToStaticFieldnameToMatchProcessor.get(className);
int interfaceCount=inp.readUnsignedShort();
ArrayList<String> interfaces=interfaceCount > 0 ? new ArrayList<String>() : null;
for (int i=0; i < interfaceCount; i++) {
interfaces.add(readRefdString(inp,constantPool).replace('/','.'));
}
int fieldCount=inp.readUnsignedShort();
for (int i=0; i < fieldCount; i++) {
int accessFlags=inp.readUnsignedShort();
boolean isStaticFinal=(accessFlags & 0x0018) == 0x0018;
String fieldName=readRefdString(inp,constantPool);
StaticFinalFieldMatchProcessor staticFinalFieldMatchProcessor=staticFieldnameToMatchProcessor != null ? staticFieldnameToMatchProcessor.get(fieldName) : null;
String descriptor=readRefdString(inp,constantPool);
int attributesCount=inp.readUnsignedShort();
if (!isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str"");
}
 else if (!isStaticFinal || staticFinalFieldMatchProcessor == null) {
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
 else {
boolean foundConstantValue=false;
for (int j=0; j < attributesCount; j++) {
String attributeName=readRefdString(inp,constantPool);
int attributeLength=inp.readInt();
if (attributeName.equals(""String_Node_Str"")) {
Object constValue=constantPool[inp.readUnsignedShort()];
switch (descriptor) {
case ""String_Node_Str"":
constValue=((Integer)constValue).byteValue();
break;
case ""String_Node_Str"":
constValue=(char)((Integer)constValue).intValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).shortValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).intValue() != 0;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
break;
default :
break;
}
staticFinalFieldMatchProcessor.processMatch(className,fieldName,constValue);
foundConstantValue=true;
}
 else {
inp.skipBytes(attributeLength);
}
if (!foundConstantValue) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
}
}
int methodCount=inp.readUnsignedShort();
for (int i=0; i < methodCount; i++) {
inp.skipBytes(6);
int attributesCount=inp.readUnsignedShort();
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
HashSet<String> annotations=null;
int attributesCount=inp.readUnsignedShort();
for (int i=0; i < attributesCount; i++) {
String attributeName=readRefdString(inp,constantPool);
int attributeLength=inp.readInt();
if (""String_Node_Str"".equals(attributeName)) {
int annotationCount=inp.readUnsignedShort();
for (int m=0; m < annotationCount; m++) {
String annotationName=readAnnotation(inp,constantPool);
if (annotations == null) {
annotations=new HashSet<>();
}
annotations.add(annotationName);
}
}
 else {
inp.skipBytes(attributeLength);
}
}
if (isInterface) {
classGraphBuilder.linkToSuperinterfaces(className,interfaces);
}
 else {
classGraphBuilder.linkToSuperclassAndInterfaces(className,superclassName,interfaces,annotations);
}
}","/** 
 * Directly examine contents of classfile binary header.
 */
private void readClassInfoFromClassfileHeader(final InputStream inputStream) throws IOException {
  DataInputStream inp=new DataInputStream(new BufferedInputStream(inputStream,1024));
  if (inp.readInt() != 0xCAFEBABE) {
    return;
  }
  inp.readUnsignedShort();
  inp.readUnsignedShort();
  int cpCount=inp.readUnsignedShort();
  Object[] constantPool=new Object[cpCount];
  int[] indirectStringRef=new int[cpCount];
  Arrays.fill(indirectStringRef,-1);
  for (int i=1; i < cpCount; ++i) {
    final int tag=inp.readUnsignedByte();
switch (tag) {
case 1:
      constantPool[i]=inp.readUTF();
    break;
case 3:
  constantPool[i]=inp.readInt();
break;
case 4:
constantPool[i]=inp.readFloat();
break;
case 5:
constantPool[i]=inp.readLong();
i++;
break;
case 6:
constantPool[i]=inp.readDouble();
i++;
break;
case 7:
case 8:
indirectStringRef[i]=inp.readUnsignedShort();
break;
case 9:
case 10:
case 11:
case 12:
inp.skipBytes(4);
break;
case 15:
inp.skipBytes(3);
break;
case 16:
inp.skipBytes(2);
break;
case 18:
inp.skipBytes(4);
break;
default :
break;
}
}
for (int i=1; i < cpCount; i++) {
if (indirectStringRef[i] >= 0) {
constantPool[i]=constantPool[indirectStringRef[i]];
}
}
int flags=inp.readUnsignedShort();
boolean isInterface=(flags & 0x0200) != 0;
String className=readRefdString(inp,constantPool).replace('/','.');
if (className.equals(""String_Node_Str"")) {
return;
}
if (!classesEncounteredSoFarDuringScan.add(className)) {
return;
}
String superclassName=readRefdString(inp,constantPool).replace('/','.');
HashMap<String,StaticFinalFieldMatchProcessor> staticFieldnameToMatchProcessor=classNameToStaticFieldnameToMatchProcessor.get(className);
int interfaceCount=inp.readUnsignedShort();
ArrayList<String> interfaces=interfaceCount > 0 ? new ArrayList<String>() : null;
for (int i=0; i < interfaceCount; i++) {
interfaces.add(readRefdString(inp,constantPool).replace('/','.'));
}
int fieldCount=inp.readUnsignedShort();
for (int i=0; i < fieldCount; i++) {
int accessFlags=inp.readUnsignedShort();
boolean isStaticFinal=(accessFlags & 0x0018) == 0x0018;
String fieldName=readRefdString(inp,constantPool);
StaticFinalFieldMatchProcessor staticFinalFieldMatchProcessor=staticFieldnameToMatchProcessor != null ? staticFieldnameToMatchProcessor.get(fieldName) : null;
String descriptor=readRefdString(inp,constantPool);
int attributesCount=inp.readUnsignedShort();
if (!isStaticFinal && staticFinalFieldMatchProcessor != null) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str"");
}
 else if (!isStaticFinal || staticFinalFieldMatchProcessor == null) {
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
 else {
boolean foundConstantValue=false;
for (int j=0; j < attributesCount; j++) {
String attributeName=readRefdString(inp,constantPool);
int attributeLength=inp.readInt();
if (attributeName.equals(""String_Node_Str"")) {
Object constValue=constantPool[inp.readUnsignedShort()];
switch (descriptor) {
case ""String_Node_Str"":
constValue=((Integer)constValue).byteValue();
break;
case ""String_Node_Str"":
constValue=(char)((Integer)constValue).intValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).shortValue();
break;
case ""String_Node_Str"":
constValue=((Integer)constValue).intValue() != 0;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
break;
default :
break;
}
staticFinalFieldMatchProcessor.processMatch(className,fieldName,constValue);
foundConstantValue=true;
}
 else {
inp.skipBytes(attributeLength);
}
if (!foundConstantValue) {
System.err.println(StaticFinalFieldMatchProcessor.class.getSimpleName() + ""String_Node_Str"" + className+ ""String_Node_Str""+ fieldName+ ""String_Node_Str""+ ""String_Node_Str"");
}
}
}
}
int methodCount=inp.readUnsignedShort();
for (int i=0; i < methodCount; i++) {
inp.skipBytes(6);
int attributesCount=inp.readUnsignedShort();
for (int j=0; j < attributesCount; j++) {
inp.skipBytes(2);
int attributeLength=inp.readInt();
inp.skipBytes(attributeLength);
}
}
HashSet<String> annotations=null;
int attributesCount=inp.readUnsignedShort();
for (int i=0; i < attributesCount; i++) {
String attributeName=readRefdString(inp,constantPool);
int attributeLength=inp.readInt();
if (""String_Node_Str"".equals(attributeName)) {
int annotationCount=inp.readUnsignedShort();
for (int m=0; m < annotationCount; m++) {
String annotationName=readAnnotation(inp,constantPool);
if (annotations == null) {
annotations=new HashSet<>();
}
annotations.add(annotationName);
}
}
 else {
inp.skipBytes(attributeLength);
}
}
if (isInterface) {
classGraphBuilder.linkToSuperinterfaces(className,interfaces);
}
 else {
classGraphBuilder.linkToSuperclassAndInterfaces(className,superclassName,interfaces,annotations);
}
}"
3675,"public ArrayList<String> getClassesWithAnnotation(String annotationName){
  return annotationNameToClassName.get(annotationName);
}","public List<String> getClassesWithAnnotation(String annotationName){
  ArrayList<String> classes=annotationNameToClassName.get(annotationName);
  if (classes == null) {
    return Collections.emptyList();
  }
  return classes;
}"
3676,"public ArrayList<String> getClassesImplementing(String interfaceName){
  return interfaceNameToClassNames.get(interfaceName);
}","public List<String> getClassesImplementing(String interfaceName){
  ArrayList<String> classes=interfaceNameToClassNames.get(interfaceName);
  if (classes == null) {
    return Collections.emptyList();
  }
  return classes;
}"
3677,"/** 
 * Constructor taking MAX THREAD POOL SIZE  Allows maximum of 4 threads. Any number higher than four or less than one wont be respected. Deprecated use Default Constructor. As the thread pool size will not respected anymore through this constructor. Thread pool size is determined with the number of available processors on the device.
 */
public ThinDownloadManager(int threadPoolSize){
  mRequestQueue=new DownloadRequestQueue(threadPoolSize);
  mRequestQueue.start();
}","/** 
 * Constructor taking MAX THREAD POOL SIZE  Allows maximum of 4 threads. Any number higher than four or less than one wont be respected. Deprecated use Default Constructor. As the thread pool size will not respected anymore through this constructor. Thread pool size is determined with the number of available processors on the device.
 */
public ThinDownloadManager(int threadPoolSize){
  mRequestQueue=new DownloadRequestQueue(threadPoolSize);
  mRequestQueue.start();
  setLoggingEnabled(true);
}"
3678,"private void transferData(InputStream in,OutputStream out){
  final byte data[]=new byte[BUFFER_SIZE];
  mCurrentBytes=0;
  mRequest.setDownloadState(DownloadManager.STATUS_RUNNING);
  Log.v(TAG,""String_Node_Str"" + mContentLength + ""String_Node_Str""+ mRequest.getDownloadId());
  for (; ; ) {
    if (mRequest.isCancelled()) {
      Log.v(TAG,""String_Node_Str"" + mRequest.getDownloadId());
      mRequest.finish();
      updateDownloadFailed(DownloadManager.ERROR_DOWNLOAD_CANCELLED,""String_Node_Str"");
      return;
    }
    int bytesRead=readFromResponse(data,in);
    if (mContentLength != -1 && mContentLength > 0) {
      int progress=(int)((mCurrentBytes * 100) / mContentLength);
      updateDownloadProgress(progress,mCurrentBytes);
    }
    if (bytesRead == -1) {
      updateDownloadComplete();
      return;
    }
 else     if (bytesRead == Integer.MIN_VALUE) {
      return;
    }
    if (writeDataToDestination(data,bytesRead,out)) {
      mCurrentBytes+=bytesRead;
    }
  }
}","private void transferData(InputStream in,OutputStream out){
  final byte data[]=new byte[BUFFER_SIZE];
  mCurrentBytes=0;
  mRequest.setDownloadState(DownloadManager.STATUS_RUNNING);
  Log.v(TAG,""String_Node_Str"" + mContentLength + ""String_Node_Str""+ mRequest.getDownloadId());
  for (; ; ) {
    if (mRequest.isCancelled()) {
      Log.v(TAG,""String_Node_Str"" + mRequest.getDownloadId());
      mRequest.finish();
      updateDownloadFailed(DownloadManager.ERROR_DOWNLOAD_CANCELLED,""String_Node_Str"");
      return;
    }
    int bytesRead=readFromResponse(data,in);
    if (mContentLength != -1 && mContentLength > 0) {
      int progress=(int)((mCurrentBytes * 100) / mContentLength);
      updateDownloadProgress(progress,mCurrentBytes);
    }
    if (bytesRead == -1) {
      updateDownloadComplete();
      return;
    }
 else     if (bytesRead == Integer.MIN_VALUE) {
      return;
    }
    if (writeDataToDestination(data,bytesRead,out)) {
      mCurrentBytes+=bytesRead;
    }
 else {
      mRequest.finish();
      updateDownloadFailed(DownloadManager.ERROR_FILE_ERROR,""String_Node_Str"");
      return;
    }
  }
}"
3679,"private void transferData(InputStream in,OutputStream out){
  final byte data[]=new byte[BUFFER_SIZE];
  mCurrentBytes=0;
  mRequest.setDownloadState(DownloadManager.STATUS_RUNNING);
  Log.v(TAG,""String_Node_Str"" + mContentLength + ""String_Node_Str""+ mRequest.getDownloadId());
  for (; ; ) {
    if (mRequest.isCanceled()) {
      Log.v(TAG,""String_Node_Str"" + mRequest.getDownloadId());
      mRequest.finish();
      updateDownloadFailed(DownloadManager.ERROR_DOWNLOAD_CANCELLED,""String_Node_Str"");
      return;
    }
    int bytesRead=readFromResponse(data,in);
    if (mContentLength != -1) {
      int progress=(int)((mCurrentBytes * 100) / mContentLength);
      updateDownloadProgress(progress);
    }
    if (bytesRead == -1) {
      updateDownloadComplete();
      return;
    }
 else     if (bytesRead == Integer.MIN_VALUE) {
      return;
    }
    writeDataToDestination(data,bytesRead,out);
    mCurrentBytes+=bytesRead;
  }
}","private void transferData(InputStream in,OutputStream out){
  final byte data[]=new byte[BUFFER_SIZE];
  mCurrentBytes=0;
  mRequest.setDownloadState(DownloadManager.STATUS_RUNNING);
  Log.v(TAG,""String_Node_Str"" + mContentLength + ""String_Node_Str""+ mRequest.getDownloadId());
  for (; ; ) {
    if (mRequest.isCanceled()) {
      Log.v(TAG,""String_Node_Str"" + mRequest.getDownloadId());
      mRequest.finish();
      updateDownloadFailed(DownloadManager.ERROR_DOWNLOAD_CANCELLED,""String_Node_Str"");
      return;
    }
    int bytesRead=readFromResponse(data,in);
    if (mContentLength != -1) {
      int progress=(int)((mCurrentBytes * 100) / mContentLength);
      updateDownloadProgress(progress,mCurrentBytes);
    }
    if (bytesRead == -1) {
      updateDownloadComplete();
      return;
    }
 else     if (bytesRead == Integer.MIN_VALUE) {
      return;
    }
    writeDataToDestination(data,bytesRead,out);
    mCurrentBytes+=bytesRead;
  }
}"
3680,"public void updateDownloadProgress(int progress){
  if (mRequest.getDownloadListener() != null) {
    mDelivery.postProgressUpdate(mRequest,mContentLength,progress);
  }
}","public void updateDownloadProgress(int progress,long downloadedBytes){
  if (mRequest.getDownloadListener() != null) {
    mDelivery.postProgressUpdate(mRequest,mContentLength,downloadedBytes,progress);
  }
}"
3681,"/** 
 * Cancels all the pending & running requests and releases all the dispatchers.
 */
void release(){
  if (mCurrentRequests != null) {
synchronized (mCurrentRequests) {
      mCurrentRequests.clear();
      mCurrentRequests=null;
    }
  }
  if (mDownloadQueue != null) {
    mDownloadQueue=null;
  }
  stop();
  if (mDownloadDispatchers != null) {
    for (int i=0; i < mDownloadDispatchers.length; i++) {
      mDownloadDispatchers[i]=null;
    }
    mDownloadDispatchers=null;
  }
}","/** 
 * Cancels all the pending & running requests and releases all the dispatchers.
 */
void release(){
  if (mCurrentRequests != null) {
synchronized (mCurrentRequests) {
      mCurrentRequests.clear();
      mCurrentRequests=null;
    }
  }
  if (mDownloadQueue != null) {
    mDownloadQueue=null;
  }
  if (mDownloadDispatchers != null) {
    stop();
    for (int i=0; i < mDownloadDispatchers.length; i++) {
      mDownloadDispatchers[i]=null;
    }
    mDownloadDispatchers=null;
  }
}"
3682,"private void findLowEnergyDevices(CallbackContext callbackContext,UUID[] serviceUUIDs,int scanSeconds){
  if (!PermissionHelper.hasPermission(this,ACCESS_COARSE_LOCATION)) {
    permissionCallback=callbackContext;
    this.serviceUUIDs=serviceUUIDs;
    this.scanSeconds=scanSeconds;
    PermissionHelper.requestPermission(this,REQUEST_ACCESS_COARSE_LOCATION,ACCESS_COARSE_LOCATION);
    return;
  }
  if (bluetoothAdapter.isDiscovering()) {
    return;
  }
  for (Iterator<Map.Entry<String,Peripheral>> iterator=peripherals.entrySet().iterator(); iterator.hasNext(); ) {
    Map.Entry<String,Peripheral> entry=iterator.next();
    Peripheral device=entry.getValue();
    boolean connecting=device.isConnecting();
    if (connecting) {
      LOG.d(TAG,""String_Node_Str"" + device.getDevice().getAddress());
    }
    if (!entry.getValue().isConnected() && !connecting) {
      iterator.remove();
    }
  }
  discoverCallback=callbackContext;
  if (serviceUUIDs.length > 0) {
    bluetoothAdapter.startLeScan(serviceUUIDs,this);
  }
 else {
    bluetoothAdapter.startLeScan(this);
  }
  if (scanSeconds > 0) {
    Handler handler=new Handler();
    handler.postDelayed(new Runnable(){
      @Override public void run(){
        LOG.d(TAG,""String_Node_Str"");
        BLECentralPlugin.this.bluetoothAdapter.stopLeScan(BLECentralPlugin.this);
      }
    }
,scanSeconds * 1000);
  }
  PluginResult result=new PluginResult(PluginResult.Status.NO_RESULT);
  result.setKeepCallback(true);
  callbackContext.sendPluginResult(result);
}","private void findLowEnergyDevices(CallbackContext callbackContext,UUID[] serviceUUIDs,int scanSeconds){
  if (!PermissionHelper.hasPermission(this,ACCESS_COARSE_LOCATION)) {
    permissionCallback=callbackContext;
    this.serviceUUIDs=serviceUUIDs;
    this.scanSeconds=scanSeconds;
    PermissionHelper.requestPermission(this,REQUEST_ACCESS_COARSE_LOCATION,ACCESS_COARSE_LOCATION);
    return;
  }
  if (bluetoothAdapter.isDiscovering()) {
    return;
  }
  for (Iterator<Map.Entry<String,Peripheral>> iterator=peripherals.entrySet().iterator(); iterator.hasNext(); ) {
    Map.Entry<String,Peripheral> entry=iterator.next();
    Peripheral device=entry.getValue();
    boolean connecting=device.isConnecting();
    if (connecting) {
      LOG.d(TAG,""String_Node_Str"" + device.getDevice().getAddress());
    }
    if (!entry.getValue().isConnected() && !connecting) {
      iterator.remove();
    }
  }
  discoverCallback=callbackContext;
  if (serviceUUIDs != null && serviceUUIDs.length > 0) {
    bluetoothAdapter.startLeScan(serviceUUIDs,this);
  }
 else {
    bluetoothAdapter.startLeScan(this);
  }
  if (scanSeconds > 0) {
    Handler handler=new Handler();
    handler.postDelayed(new Runnable(){
      @Override public void run(){
        LOG.d(TAG,""String_Node_Str"");
        BLECentralPlugin.this.bluetoothAdapter.stopLeScan(BLECentralPlugin.this);
      }
    }
,scanSeconds * 1000);
  }
  PluginResult result=new PluginResult(PluginResult.Status.NO_RESULT);
  result.setKeepCallback(true);
  callbackContext.sendPluginResult(result);
}"
3683,"@Override public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status){
  super.onCharacteristicRead(gatt,characteristic,status);
  if (readCallback != null) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
      readCallback.success(characteristic.getValue());
    }
 else {
      readCallback.error(""String_Node_Str"" + characteristic.getUuid() + ""String_Node_Str""+ status);
    }
    readCallback=null;
  }
  commandCompleted();
}","@Override public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status){
  super.onCharacteristicRead(gatt,characteristic,status);
  LOG.d(TAG,""String_Node_Str"" + characteristic);
  if (readCallback != null) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
      readCallback.success(characteristic.getValue());
    }
 else {
      readCallback.error(""String_Node_Str"" + characteristic.getUuid() + ""String_Node_Str""+ status);
    }
    readCallback=null;
  }
  commandCompleted();
}"
3684,"private void commandCompleted(){
  bleProcessing=false;
  processCommands();
}","private void commandCompleted(){
  LOG.d(TAG,""String_Node_Str"");
  bleProcessing=false;
  processCommands();
}"
3685,"private void queueCommand(BLECommand command){
  commandQueue.add(command);
  PluginResult result=new PluginResult(PluginResult.Status.NO_RESULT);
  result.setKeepCallback(true);
  command.getCallbackContext().sendPluginResult(result);
  if (!bleProcessing) {
    processCommands();
  }
}","private void queueCommand(BLECommand command){
  LOG.d(TAG,""String_Node_Str"" + command);
  commandQueue.add(command);
  PluginResult result=new PluginResult(PluginResult.Status.NO_RESULT);
  result.setKeepCallback(true);
  command.getCallbackContext().sendPluginResult(result);
  if (!bleProcessing) {
    LOG.d(TAG,""String_Node_Str"");
    processCommands();
  }
 else {
    LOG.d(TAG,""String_Node_Str"");
  }
}"
3686,"@Override public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic){
  super.onCharacteristicChanged(gatt,characteristic);
  CallbackContext callback=notificationCallbacks.get(generateHashKey(characteristic));
  if (callback != null) {
    PluginResult result=new PluginResult(PluginResult.Status.OK,characteristic.getValue());
    result.setKeepCallback(true);
    callback.sendPluginResult(result);
  }
}","@Override public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic){
  super.onCharacteristicChanged(gatt,characteristic);
  LOG.d(TAG,""String_Node_Str"" + characteristic);
  CallbackContext callback=notificationCallbacks.get(generateHashKey(characteristic));
  if (callback != null) {
    PluginResult result=new PluginResult(PluginResult.Status.OK,characteristic.getValue());
    result.setKeepCallback(true);
    callback.sendPluginResult(result);
  }
}"
3687,"@Override public void onDescriptorWrite(BluetoothGatt gatt,BluetoothGattDescriptor descriptor,int status){
  super.onDescriptorWrite(gatt,descriptor,status);
  commandCompleted();
}","@Override public void onDescriptorWrite(BluetoothGatt gatt,BluetoothGattDescriptor descriptor,int status){
  super.onDescriptorWrite(gatt,descriptor,status);
  LOG.d(TAG,""String_Node_Str"" + descriptor);
  commandCompleted();
}"
3688,"@Override public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status){
  super.onCharacteristicWrite(gatt,characteristic,status);
}","@Override public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,int status){
  super.onCharacteristicWrite(gatt,characteristic,status);
  LOG.d(TAG,""String_Node_Str"" + characteristic);
  if (writeCallback != null) {
    if (status == BluetoothGatt.GATT_SUCCESS) {
      writeCallback.success();
    }
 else {
      writeCallback.error(status);
    }
    writeCallback=null;
  }
  commandCompleted();
}"
3689,"private void writeNoResponse(CallbackContext callbackContext,UUID serviceUUID,UUID characteristicUUID,byte[] data){
  try {
    if (gatt == null) {
      callbackContext.error(""String_Node_Str"");
      return;
    }
    BluetoothGattService service=gatt.getService(serviceUUID);
    BluetoothGattCharacteristic characteristic=service.getCharacteristic(characteristicUUID);
    if (characteristic == null) {
      callbackContext.error(""String_Node_Str"" + characteristicUUID + ""String_Node_Str"");
    }
 else {
      characteristic.setValue(data);
      characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
      if (gatt.writeCharacteristic(characteristic)) {
        callbackContext.success();
      }
 else {
        callbackContext.error(""String_Node_Str"");
      }
    }
  }
  finally {
    commandCompleted();
  }
}","private void writeNoResponse(CallbackContext callbackContext,UUID serviceUUID,UUID characteristicUUID,byte[] data){
  boolean success=false;
  try {
    if (gatt == null) {
      callbackContext.error(""String_Node_Str"");
      return;
    }
    BluetoothGattService service=gatt.getService(serviceUUID);
    BluetoothGattCharacteristic characteristic=service.getCharacteristic(characteristicUUID);
    if (characteristic == null) {
      callbackContext.error(""String_Node_Str"" + characteristicUUID + ""String_Node_Str"");
    }
 else {
      characteristic.setValue(data);
      characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
      if (gatt.writeCharacteristic(characteristic)) {
        writeCallback=callbackContext;
        success=true;
      }
 else {
        callbackContext.error(""String_Node_Str"");
      }
    }
  }
  finally {
    if (!success) {
      commandCompleted();
    }
  }
}"
3690,"private void processCommands(){
  if (bleProcessing) {
    return;
  }
  BLECommand command=commandQueue.poll();
  if (command != null) {
    if (command.getType() == BLECommand.READ) {
      bleProcessing=true;
      readCharacteristic(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID());
    }
 else     if (command.getType() == BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT) {
      bleProcessing=true;
      writeCharacteristic(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID(),command.getData());
    }
 else     if (command.getType() == BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE) {
      bleProcessing=true;
      writeNoResponse(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID(),command.getData());
    }
 else     if (command.getType() == BLECommand.REGISTER_NOTIFY) {
      bleProcessing=true;
      registerNotifyCallback(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + command.getType());
    }
  }
}","private void processCommands(){
  LOG.d(TAG,""String_Node_Str"");
  if (bleProcessing) {
    return;
  }
  BLECommand command=commandQueue.poll();
  if (command != null) {
    if (command.getType() == BLECommand.READ) {
      LOG.d(TAG,""String_Node_Str"" + command.getCharacteristicUUID());
      bleProcessing=true;
      readCharacteristic(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID());
    }
 else     if (command.getType() == BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT) {
      LOG.d(TAG,""String_Node_Str"" + command.getCharacteristicUUID());
      bleProcessing=true;
      writeCharacteristic(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID(),command.getData());
    }
 else     if (command.getType() == BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE) {
      LOG.d(TAG,""String_Node_Str"" + command.getCharacteristicUUID());
      bleProcessing=true;
      writeNoResponse(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID(),command.getData());
    }
 else     if (command.getType() == BLECommand.REGISTER_NOTIFY) {
      LOG.d(TAG,""String_Node_Str"" + command.getCharacteristicUUID());
      bleProcessing=true;
      registerNotifyCallback(command.getCallbackContext(),command.getServiceUUID(),command.getCharacteristicUUID());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + command.getType());
    }
  }
 else {
    LOG.d(TAG,""String_Node_Str"");
  }
}"
3691,"public static void act(Long id,Point2D pos){
  if (pos == null) {
    return;
  }
  Unit target=getUnit(id);
  for (  Unit u : selection) {
    u.group.clear();
    u.group.addAll(selection);
  }
  if (target != null && target.faction != selection.get(0).faction) {
    orderAttack(target);
  }
 else {
    orderMove(pos);
  }
  moveAttack=false;
}","public static void act(Long id,Point2D pos){
  if (pos == null) {
    return;
  }
  Unit target=getUnit(id);
  Group group=new Group(selection);
  for (  Unit u : group) {
    u.group.remove(u);
    u.group=group;
  }
  if (target != null && target.faction != selection.get(0).faction) {
    orderAttack(target);
  }
 else {
    orderMove(pos);
  }
  moveAttack=false;
}"
3692,"public void updatePosition(double elapsedTime){
  double lastOrientation=hiker.getOrientation();
  Point3D lastPos=new Point3D(hiker.pos);
  if (!holdPosition) {
    Motion steering=sm.collectSteering();
    if (steering.isEmpty() && !Double.isNaN(desiredOrientation)) {
      steering.setAngle(desiredOrientation);
      desiredOrientation=Double.NaN;
    }
    Motion possibleMotion=hiker.getNearestPossibleMotion(steering,getDestination(),elapsedTime);
    Motion correctMotion=cm.correctMotion(possibleMotion,elapsedTime,toAvoid);
    hiker.move(correctMotion);
  }
  hasMoved=hiker.hasMoved(lastPos,lastOrientation);
  if (hasMoved) {
    updateElevation();
  }
  if (hasDestination) {
    hasFoundPost=false;
  }
 else {
    hasFoundPost=true;
    for (    Mover m : toFlockWith) {
      if (m.hasDestination) {
        hasFoundPost=false;
      }
    }
  }
  if (!tryHold) {
    holdPosition=false;
  }
}","public void updatePosition(double elapsedTime){
  double lastOrientation=hiker.getOrientation();
  Point3D lastPos=new Point3D(hiker.pos);
  if (!holdPosition) {
    Motion steering=sm.collectSteering();
    if (steering.isEmpty() && !Double.isNaN(desiredOrientation)) {
      steering.setAngle(desiredOrientation);
      desiredOrientation=Double.NaN;
    }
    Motion possibleMotion=hiker.getNearestPossibleMotion(steering,getDestination(),elapsedTime);
    Motion correctMotion=cm.correctMotion(possibleMotion,elapsedTime,toAvoid);
    hiker.move(correctMotion);
  }
  hasMoved=hiker.hasMoved(lastPos,lastOrientation);
  if (hasMoved) {
    updateElevation();
  }
  if (hasDestination) {
    hasFoundPost=false;
  }
 else {
    hasFoundPost=true;
    for (    Mover m : toFlockWith) {
      if (m.hasDestination) {
        hasFoundPost=false;
        break;
      }
    }
  }
  if (!tryHold) {
    holdPosition=false;
  }
}"
3693,"public boolean heading(Point2D target,double toleranceInDegrees){
  boolean res=AngleUtil.getSmallestDifference(getAngleTo(target),getOrientation()) <= AngleUtil.toRadians(toleranceInDegrees);
  return res;
}","public boolean heading(Point2D target,double toleranceInDegrees){
  return AngleUtil.getSmallestDifference(getAngleTo(target),getOrientation()) <= AngleUtil.toRadians(toleranceInDegrees);
}"
3694,"private Point3D getSeparationForce(List<Mover> neighbors){
  Point3D res=Point3D.ORIGIN;
  if (neighbors.isEmpty()) {
    return res;
  }
  for (  Mover n : neighbors) {
    if (n.hiker.priority < mover.hiker.priority)     continue;
    double neededDistance=n.hiker.getSpacing(mover.hiker) - n.hiker.getDistance(mover.hiker);
    if (neededDistance <= 0) {
      continue;
    }
    logger.info(""String_Node_Str"" + df.format(neededDistance));
    Point3D sepVector=n.hiker.getVectorTo(mover.hiker).getScaled(neededDistance);
    res=res.getAddition(sepVector);
  }
  if (res.isOrigin()) {
    return res;
  }
  if (mover.fly()) {
    return res.getMult(SEPARATION_FORCE_FOR_FLYING);
  }
  return res.getMult(SEPARATION_FORCE);
}","private Point3D getSeparationForce(List<Mover> neighbors){
  Point3D res=Point3D.ORIGIN;
  if (neighbors.isEmpty()) {
    return res;
  }
  for (  Mover n : neighbors) {
    double neededDistance=n.hiker.getSpacing(mover.hiker) - n.hiker.getDistance(mover.hiker);
    if (neededDistance <= 0) {
      continue;
    }
    if (n.hiker.priority < mover.hiker.priority)     neededDistance/=10;
    Point3D sepVector=n.hiker.getVectorTo(mover.hiker).getScaled(neededDistance);
    res=res.getAddition(sepVector);
  }
  if (res.isOrigin()) {
    return res;
  }
  if (mover.fly()) {
    return res.getMult(SEPARATION_FORCE_FOR_FLYING);
  }
  return res.getMult(SEPARATION_FORCE);
}"
3695,"void doWaitOrders(){
  if (!unit.getMover().hasFoundPost) {
    post=unit.getPos();
  }
  unit.idle();
  unit.getMover().separate();
  if (post != null && getPostDistance() > FREE_MOVE_RADIUS) {
    stateMachine.pushState(RETURN_POST);
    stateMachine.pushState(WAIT,DISTURB_DURATION);
  }
  if (unit.arming.scanning()) {
    stateMachine.pushState(RETURN_POST);
    stateMachine.pushState(AUTO_ATTACK,new ArrayList<>());
  }
  if (isAttacked()) {
    stateMachine.pushState(RETURN_POST);
    stateMachine.pushState(ATTACK_BACK);
  }
}","void doWaitOrders(){
  if (!unit.getMover().hasFoundPost) {
    post=unit.getPos();
  }
  unit.idle();
  unit.getMover().letPass();
  if (post != null && getPostDistance() > FREE_MOVE_RADIUS) {
    stateMachine.pushState(RETURN_POST);
    stateMachine.pushState(WAIT,DISTURB_DURATION);
  }
  if (unit.arming.scanning()) {
    stateMachine.pushState(RETURN_POST);
    stateMachine.pushState(AUTO_ATTACK,new ArrayList<>());
  }
  if (isAttacked()) {
    stateMachine.pushState(RETURN_POST);
    stateMachine.pushState(ATTACK_BACK);
  }
}"
3696,"void doWait(double duration){
  unit.getMover().separate();
  if (disturbTime == 0) {
    disturbTime=System.currentTimeMillis();
  }
 else   if (disturbTime + duration < System.currentTimeMillis()) {
    disturbTime=0;
    stateMachine.popState();
  }
}","void doWait(double duration){
  unit.getMover().letPass();
  if (disturbTime == 0) {
    disturbTime=System.currentTimeMillis();
  }
 else   if (disturbTime + duration < System.currentTimeMillis()) {
    disturbTime=0;
    stateMachine.popState();
  }
}"
3697,"void doReturnPost(){
  if (getPostDistance() < POST_TOLERANCE) {
    stateMachine.popState();
  }
 else   if (isAttacked()) {
    stateMachine.pushState(ATTACK_BACK);
  }
 else {
    unit.getMover().separate();
    unit.getMover().seek(post);
  }
}","void doReturnPost(){
  if (getPostDistance() < POST_TOLERANCE) {
    stateMachine.popState();
  }
 else   if (isAttacked()) {
    stateMachine.pushState(ATTACK_BACK);
  }
 else {
    unit.getMover().letPass();
    unit.getMover().seek(post);
  }
}"
3698,"void doHold(){
  post=unit.getPos();
  unit.idle();
  unit.getMover().tryToHoldPositionSoftly();
  unit.getMover().separate();
  if (unit.arming.acquiring()) {
    unit.arming.attack();
  }
}","void doHold(){
  post=unit.getPos();
  unit.idle();
  unit.getMover().tryToHoldPositionSoftly();
  unit.getMover().letPass();
  if (unit.arming.acquiring()) {
    unit.arming.attack();
  }
}"
3699,"public LightDrawer(MapView view,AssetManager am,Node rootNode,ViewPort vp){
  this.view=view;
  this.rootNode=rootNode;
  FilterPostProcessor fpp=new FilterPostProcessor(am);
  int SHADOWMAP_SIZE=4096;
  sf=new DirectionalLightShadowFilter(am,SHADOWMAP_SIZE,1);
  sf.setEnabled(true);
  sf.setShadowZExtend(SHADOWMAP_SIZE);
  fpp.addFilter(sf);
  SSAOFilter ssaoFilter=new SSAOFilter(0.5f,4f,0.2f,0.3f);
  BloomFilter bloom=new BloomFilter(BloomFilter.GlowMode.Objects);
  fpp.addFilter(bloom);
  vp.addProcessor(fpp);
}","public LightDrawer(MapView view,AssetManager am,Node rootNode,ViewPort vp){
  this.view=view;
  this.rootNode=rootNode;
  FilterPostProcessor fpp=new FilterPostProcessor(am);
  int SHADOWMAP_SIZE=4096;
  sf=new DirectionalLightShadowFilter(am,SHADOWMAP_SIZE,1);
  sf.setEnabled(true);
  sf.setEdgeFilteringMode(EdgeFilteringMode.PCF4);
  sf.setShadowZExtend(SHADOWMAP_SIZE);
  fpp.addFilter(sf);
  SSAOFilter ssaoFilter=new SSAOFilter(0.5f,4f,0.2f,0.3f);
  BloomFilter bloom=new BloomFilter(BloomFilter.GlowMode.Objects);
  fpp.addFilter(bloom);
  vp.addProcessor(fpp);
}"
3700,"@JsonIgnore @Override public double getElevation(){
  return getModifiedElevation();
}","@Override public double getElevation(){
  if (modifiedLevel != 0) {
    return modifiedLevel * STAGE_HEIGHT + elevation;
  }
 else {
    return level * STAGE_HEIGHT + elevation;
  }
}"
3701,"private double getElevation(Tile t,Cliff c){
  if (t.getModifiedLevel() > c.level + 1) {
    return (c.level + 1) * Tile.STAGE_HEIGHT;
  }
  return t.getModifiedElevation();
}","private double getElevation(Tile t,Cliff c){
  if (t.getModifiedLevel() > c.level + 1) {
    return (c.level + 1) * Tile.STAGE_HEIGHT;
  }
  return t.getElevation();
}"
3702,"public double getElevation(){
  return ModelManager.getBattlefield().getMap().get(getContainerTilePos()).getModifiedElevation();
}","public double getElevation(){
  return ModelManager.getBattlefield().getMap().get(getContainerTilePos()).getElevation();
}"
3703,"public List<T> get8Around(T n){
  List<T> res=getAround(n,1);
  return res;
}","public List<T> get8Around(T n){
  List<T> res=getInSquareWithourCenter(n,1);
  return res;
}"
3704,"public List<T> get25Around(T n){
  List<T> res=getAround(n,2);
  return res;
}","public List<T> get25Around(T n){
  List<T> res=getInSquare(n,2);
  return res;
}"
3705,"public List<T> get9Around(T n){
  List<T> res=getAround(n,1);
  res.add(n);
  return res;
}","public List<T> get9Around(T n){
  List<T> res=getInSquare(n,1);
  return res;
}"
3706,"private Trinket grow(Sowing s){
  Trinket source=s.toGrow.get(RandomUtil.nextInt(s.toGrow.size()));
  List<Trinket> neibors=ModelManager.getBattlefield().getCloseComps(source,20);
  for (int i=0; i < MAX_TRINKETS_COUNT; i++) {
    int trinketIndex=RandomUtil.between(0,s.trinketBuilders.size());
    Trinket candidate=s.trinketBuilders.get(trinketIndex).build(Point3D.ORIGIN);
    candidate.separationRadius*=s.spacings.get(trinketIndex);
    for (int j=0; j < MAX_PLACES_COUNT; j++) {
      double separationDistance=source.getSpacing(candidate);
      Point2D place=source.getCoord().getTranslation(RandomUtil.between(0,AngleUtil.FULL),RandomUtil.between(separationDistance,separationDistance * 2));
      if (!ModelManager.getBattlefield().getMap().isInBounds(place) || !s.isAllowed(place)) {
        continue;
      }
      boolean isValidePlace=true;
      for (      Trinket n : neibors) {
        if (n.getCoord().getDistance(place) < n.getSpacing(candidate)) {
          isValidePlace=false;
          break;
        }
      }
      if (isValidePlace) {
        candidate.setPos(place.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(place)));
        sowTrinket(s,candidate);
        return candidate;
      }
    }
  }
  s.toGrow.remove(source);
  return null;
}","private Trinket grow(Sowing s){
  Map m=ModelManager.getBattlefield().getMap();
  Trinket source=s.toGrow.get(RandomUtil.nextInt(s.toGrow.size()));
  List<Trinket> neibors=m.getInCircle(Trinket.class,source.getCoord(),20);
  for (int i=0; i < MAX_TRINKETS_COUNT; i++) {
    int trinketIndex=RandomUtil.between(0,s.trinketBuilders.size());
    Trinket candidate=s.trinketBuilders.get(trinketIndex).build(Point3D.ORIGIN);
    candidate.separationRadius*=s.spacings.get(trinketIndex);
    for (int j=0; j < MAX_PLACES_COUNT; j++) {
      double separationDistance=source.getSpacing(candidate);
      Point2D place=source.getCoord().getTranslation(RandomUtil.between(0,AngleUtil.FULL),RandomUtil.between(separationDistance,separationDistance * 2));
      if (!m.isInBounds(place) || !s.isAllowed(place)) {
        continue;
      }
      boolean isValidePlace=true;
      for (      Trinket n : neibors) {
        if (n.getCoord().getDistance(place) < n.getSpacing(candidate)) {
          isValidePlace=false;
          break;
        }
      }
      if (isValidePlace) {
        candidate.setPos(place.get3D(m.getAltitudeAt(place)));
        sowTrinket(s,candidate);
        return candidate;
      }
    }
  }
  s.toGrow.remove(source);
  return null;
}"
3707,"private Trinket findNewPlace(Sowing s){
  double r1=RandomUtil.next();
  double r2=RandomUtil.next();
  Point2D randomPos=new Point2D(r1 * (ModelManager.getBattlefield().getMap().xSize() - 1),r2 * (ModelManager.getBattlefield().getMap().ySize() - 1));
  if (!ModelManager.getBattlefield().getMap().isInBounds(randomPos))   return null;
  if (s.isAllowed(randomPos)) {
    int trinketIndex=RandomUtil.between(0,s.trinketBuilders.size());
    TrinketBuilder tb=s.trinketBuilders.get(trinketIndex);
    Trinket candidate=tb.build(randomPos.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(randomPos)));
    candidate.separationRadius*=s.spacings.get(trinketIndex);
    boolean isValid=true;
    for (    Trinket n : ModelManager.getBattlefield().getCloseComps(candidate,randomPos,10)) {
      double separationDistance=n.getSpacing(candidate);
      if (n.getDistance(candidate) < separationDistance) {
        isValid=false;
        break;
      }
    }
    if (isValid) {
      sowTrinket(s,candidate);
      return candidate;
    }
  }
  return null;
}","private Trinket findNewPlace(Sowing s){
  Map m=ModelManager.getBattlefield().getMap();
  Point2D randomPos=new Point2D(RandomUtil.next() * (m.xSize() - 1),RandomUtil.next() * (m.ySize() - 1));
  if (s.isAllowed(randomPos)) {
    int trinketIndex=RandomUtil.between(0,s.trinketBuilders.size());
    TrinketBuilder tb=s.trinketBuilders.get(trinketIndex);
    Trinket candidate=tb.build(randomPos.get3D(m.getAltitudeAt(randomPos)));
    candidate.separationRadius*=s.spacings.get(trinketIndex);
    boolean isValid=true;
    for (    Trinket n : m.getInCircle(Trinket.class,randomPos,10)) {
      double separationDistance=n.getSpacing(candidate);
      if (n.getDistance(candidate) < separationDistance) {
        isValid=false;
        break;
      }
    }
    if (isValid) {
      sowTrinket(s,candidate);
      return candidate;
    }
  }
  return null;
}"
3708,"public boolean isAllowed(Point2D p){
  Map map=ModelManager.getBattlefield().getMap();
  if (distFromCliff > 0) {
    boolean hasCliff=false;
    for (    Tile t : map.getAround(p,distFromCliff)) {
      if (t.hasCliff()) {
        hasCliff=true;
        break;
      }
    }
    if (!hasCliff) {
      return false;
    }
  }
  if (slopeMin > 0 || slopeMax > 0) {
    double dist=map.getNormalVectorAt(p).get2D().getLength();
    double angle=AngleUtil.RIGHT - new Point2D(dist,1).getAngle();
    if (slopeMin > 0 && angle < AngleUtil.toRadians(slopeMin)) {
      return false;
    }
    if (slopeMax > 0 && angle > AngleUtil.toRadians(slopeMax)) {
      return false;
    }
  }
  if (!textures.isEmpty()) {
    int i=0;
    for (    String s : textures) {
      AtlasLayer l;
      int texIndex=Integer.parseInt(s);
      if (texIndex >= 8)       l=map.getCover().getLayers().get(texIndex - 8);
 else       l=map.getAtlas().getLayers().get(texIndex);
      if (l.getInAtlasSpace(p) < textureMin.get(i) * 255 || l.getInAtlasSpace(p) > textureMax.get(i) * 255) {
        return false;
      }
      i++;
    }
  }
  return true;
}","public boolean isAllowed(Point2D p){
  Map map=ModelManager.getBattlefield().getMap();
  if (distFromCliff > 0) {
    boolean hasCliff=false;
    for (    Tile t : map.getInCircle(p,distFromCliff)) {
      if (t.hasCliff()) {
        hasCliff=true;
        break;
      }
    }
    if (!hasCliff) {
      return false;
    }
  }
  if (slopeMin > 0 || slopeMax > 0) {
    double dist=map.getNormalVectorAt(p).get2D().getLength();
    double angle=AngleUtil.RIGHT - new Point2D(dist,1).getAngle();
    if (slopeMin > 0 && angle < AngleUtil.toRadians(slopeMin)) {
      return false;
    }
    if (slopeMax > 0 && angle > AngleUtil.toRadians(slopeMax)) {
      return false;
    }
  }
  if (!textures.isEmpty()) {
    int i=0;
    for (    String s : textures) {
      AtlasLayer l;
      int texIndex=Integer.parseInt(s);
      if (texIndex >= 8)       l=map.getCover().getLayers().get(texIndex - 8);
 else       l=map.getAtlas().getLayers().get(texIndex);
      if (l.getInAtlasSpace(p) < textureMin.get(i) * 255 || l.getInAtlasSpace(p) > textureMax.get(i) * 255) {
        return false;
      }
      i++;
    }
  }
  return true;
}"
3709,"private Trinket grow(Sowing s){
  Trinket source=s.toGrow.get(MyRandom.nextInt(s.toGrow.size()));
  List<Trinket> neibors=ModelManager.getBattlefield().getCloseComps(source,10);
  for (int i=0; i < MAX_TRINKETS_COUNT; i++) {
    Trinket candidate=s.trinketBuilders.get(MyRandom.between(0,s.trinketBuilders.size() - 1)).build(Point3D.ORIGIN);
    for (int j=0; j < MAX_PLACES_COUNT; j++) {
      double separationDistance=source.getRadius() + candidate.getRadius();
      Point2D place=source.getCoord().getTranslation(MyRandom.between(0,Angle.FULL),MyRandom.between(separationDistance,separationDistance * 2));
      if (!ModelManager.getBattlefield().getMap().isInBounds(place) || !s.isAllowed(place))       continue;
      boolean isValidePlace=true;
      for (      Trinket n : neibors)       if (n.getCoord().getDistance(place) < n.getRadius() + candidate.getRadius()) {
        isValidePlace=false;
        break;
      }
      if (isValidePlace) {
        candidate.setPos(place.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(place)));
        sowTrinket(s,candidate);
        return candidate;
      }
    }
  }
  s.toGrow.remove(source);
  return null;
}","private Trinket grow(Sowing s){
  Trinket source=s.toGrow.get(MyRandom.nextInt(s.toGrow.size()));
  List<Trinket> neibors=ModelManager.getBattlefield().getCloseComps(source,10);
  for (int i=0; i < MAX_TRINKETS_COUNT; i++) {
    Trinket candidate=s.trinketBuilders.get(MyRandom.between(0,s.trinketBuilders.size())).build(Point3D.ORIGIN);
    for (int j=0; j < MAX_PLACES_COUNT; j++) {
      double separationDistance=source.getRadius() + candidate.getRadius();
      Point2D place=source.getCoord().getTranslation(MyRandom.between(0,Angle.FULL),MyRandom.between(separationDistance,separationDistance * 2));
      if (!ModelManager.getBattlefield().getMap().isInBounds(place) || !s.isAllowed(place))       continue;
      boolean isValidePlace=true;
      for (      Trinket n : neibors)       if (n.getCoord().getDistance(place) < n.getRadius() + candidate.getRadius()) {
        isValidePlace=false;
        break;
      }
      if (isValidePlace) {
        candidate.setPos(place.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(place)));
        sowTrinket(s,candidate);
        return candidate;
      }
    }
  }
  s.toGrow.remove(source);
  return null;
}"
3710,"private void sowTrinket(Sowing s,Trinket t){
  t.drawOnBattlefield();
  s.toGrow.add(t);
  ModelManager.getBattlefield().store(t);
}","private void sowTrinket(Sowing s,Trinket t){
  t.drawOnBattlefield();
  s.toGrow.add(t);
}"
3711,"@Override public void run(){
  thread=Thread.currentThread();
  try {
    while (!Thread.currentThread().isInterrupted()) {
      if (pauseAsked) {
synchronized (this) {
          paused=true;
          this.wait();
          paused=false;
          pauseAsked=false;
        }
      }
      for (      Sowing s : sowings) {
        Trinket newTrinket;
        if (s.toGrow.isEmpty()) {
          newTrinket=findNewPlace(s);
        }
 else {
          newTrinket=grow(s);
        }
        if (newTrinket != null) synchronized (ModelManager.getBattlefield().getMap()) {
          ModelManager.getBattlefield().getMap().getTrinkets().add(newTrinket);
        }
      }
    }
  }
 catch (  InterruptedException e) {
  }
}","@Override public void run(){
  thread=Thread.currentThread();
  try {
    while (!Thread.currentThread().isInterrupted()) {
      if (pauseAsked) {
synchronized (this) {
          paused=true;
          this.wait();
          paused=false;
          pauseAsked=false;
        }
      }
      for (      Sowing s : sowings) {
        Trinket newTrinket;
        if (s.toGrow.isEmpty()) {
          newTrinket=findNewPlace(s);
        }
 else {
          newTrinket=grow(s);
        }
        if (newTrinket != null) synchronized (ModelManager.getBattlefield().getMap()) {
          MapArtisan.attachTrinket(newTrinket,ModelManager.getBattlefield().getMap());
        }
      }
    }
  }
 catch (  InterruptedException e) {
  }
}"
3712,"private Trinket findNewPlace(Sowing s){
  Point2D randomPos=new Point2D(MyRandom.next() * (double)ModelManager.getBattlefield().getMap().xSize(),MyRandom.next() * (double)ModelManager.getBattlefield().getMap().ySize());
  if (s.isAllowed(randomPos)) {
    for (    TrinketBuilder tb : s.trinketBuilders) {
      Trinket candidate=tb.build(randomPos.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(randomPos)));
      boolean isValid=true;
      for (      Trinket n : ModelManager.getBattlefield().getCloseComps(candidate,randomPos,10)) {
        double separationDistance=n.getRadius() + candidate.getRadius();
        if (n.getDistance(candidate) < separationDistance) {
          isValid=false;
          break;
        }
      }
      if (isValid) {
        sowTrinket(s,candidate);
        return candidate;
      }
    }
  }
  return null;
}","private Trinket findNewPlace(Sowing s){
  Point2D randomPos=new Point2D(MyRandom.next() * (double)ModelManager.getBattlefield().getMap().xSize(),MyRandom.next() * (double)ModelManager.getBattlefield().getMap().ySize());
  if (s.isAllowed(randomPos)) {
    TrinketBuilder tb=s.trinketBuilders.get(MyRandom.between(0,s.trinketBuilders.size()));
    Trinket candidate=tb.build(randomPos.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(randomPos)));
    boolean isValid=true;
    for (    Trinket n : ModelManager.getBattlefield().getCloseComps(candidate,randomPos,10)) {
      double separationDistance=n.getRadius() + candidate.getRadius();
      if (n.getDistance(candidate) < separationDistance) {
        isValid=false;
        break;
      }
    }
    if (isValid) {
      sowTrinket(s,candidate);
      return candidate;
    }
  }
  return null;
}"
3713,"public Sower(){
  Sowing tree=new Sowing();
  tree.addTrinket(""String_Node_Str"");
  tree.setCliffDist(2);
  tree.setMaxSlope(30);
  sowings.add(tree);
  Sowing rocks=new Sowing();
  rocks.addTrinket(""String_Node_Str"");
  rocks.setMinSlope(20);
  rocks.allowedGrounds.add(""String_Node_Str"");
  rocks.allowedGrounds.add(""String_Node_Str"");
  sowings.add(rocks);
}","public Sower(){
  Sowing tree=new Sowing();
  tree.addTrinket(""String_Node_Str"");
  tree.addTrinket(""String_Node_Str"");
  tree.setCliffDist(2);
  tree.setMaxSlope(30);
  sowings.add(tree);
  Sowing rocks=new Sowing();
  rocks.addTrinket(""String_Node_Str"");
  rocks.setMinSlope(20);
  rocks.allowedGrounds.add(""String_Node_Str"");
  rocks.allowedGrounds.add(""String_Node_Str"");
  sowings.add(rocks);
}"
3714,"@Override public void update(float elapsedTime){
  ToolManager.setPointedSpatialLabel(spatialSelector.getSpatialLabel());
  ToolManager.setPointedSpatialEntityId(spatialSelector.getEntityId());
  Point2D coord=spatialSelector.getCoord(view.editorRend.gridNode);
  if (coord != null && ModelManager.getBattlefield().getMap().isInBounds(coord)) {
    ToolManager.updatePencilsPos(coord);
    view.editorRend.drawPencil();
  }
  guiController.update();
}","@Override public void update(float elapsedTime){
  ToolManager.setPointedSpatialLabel(spatialSelector.getSpatialLabel());
  ToolManager.setPointedSpatialEntityId(spatialSelector.getEntityId());
  Point2D coord=spatialSelector.getCoord(view.editorRend.gridNode);
  if (coord != null && ModelManager.battlefieldReady && ModelManager.getBattlefield().getMap().isInBounds(coord)) {
    ToolManager.updatePencilsPos(coord);
    view.editorRend.drawPencil();
  }
  guiController.update();
}"
3715,"private static void setBattlefield(Battlefield battlefield){
  if (battlefield != null) {
    ModelManager.battlefield=battlefield;
    ParcelManager.createParcelMeshes(ModelManager.getBattlefield().getMap());
    battlefieldReady=true;
    getBattlefield().getMap().resetTrinkets();
    getBattlefield().getEngagement().reset();
    EventManager.post(new BattleFieldUpdateEvent());
    LogUtil.logger.info(""String_Node_Str"");
  }
}","private static void setBattlefield(Battlefield battlefield){
  if (battlefield != null) {
    ModelManager.battlefield=battlefield;
    battlefieldReady=true;
    ParcelManager.createParcelMeshes(ModelManager.getBattlefield().getMap());
    getBattlefield().getMap().resetTrinkets();
    getBattlefield().getEngagement().reset();
    EventManager.post(new BattleFieldUpdateEvent());
    LogUtil.logger.info(""String_Node_Str"");
  }
}"
3716,"public Battlefield load(File file){
  ModelManager.setBattlefieldUnavailable();
  Battlefield bField=null;
  try {
    LogUtil.logger.info(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
    ObjectMapper mapper=new ObjectMapper();
    bField=mapper.readValue(file,Battlefield.class);
    bField.setFileName(file.getCanonicalPath());
    bField.getMap().atlas.finalize();
    SmileFactory f=new SmileFactory();
    mapper=new ObjectMapper(f);
    byte[] smileData=mapper.writeValueAsBytes(bField.getMap().getTiles());
    OutputStream out=new FileOutputStream(ModelManager.DEFAULT_MAP_PATH + ""String_Node_Str"");
    out.write(smileData);
    out.flush();
    out.close();
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
  if (bField == null) {
    LogUtil.logger.info(""String_Node_Str"");
    ModelManager.setBattlefieldReady();
    return null;
  }
  LogUtil.logger.info(""String_Node_Str"");
  BuilderManager.getMapStyleBuilder(bField.getMap().mapStyleID).build(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  linkTiles(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  for (  Ramp r : bField.getMap().ramps) {
    r.connect(bField.getMap());
  }
  for (  Tile t : bField.getMap().getTiles()) {
    int minLevel=t.level;
    int maxLevel=t.level;
    for (    Tile n : bField.getMap().get8Around(t)) {
      maxLevel=Math.max(maxLevel,n.level);
    }
    if (minLevel != maxLevel) {
      t.setCliff(minLevel,maxLevel);
    }
  }
  LogUtil.logger.info(""String_Node_Str"");
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      c.connect(bField.getMap());
    }
  }
  int i=0;
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      BuilderManager.getCliffShapeBuilder(t.getCliffShapeID()).build(c);
      i++;
    }
  }
  LogUtil.logger.info(""String_Node_Str"" + i + ""String_Node_Str"");
  ParcelManager.createParcelMeshes(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  bField.getMap().atlas.loadFromFile(bField.getFileName());
  LogUtil.logger.info(""String_Node_Str"");
  return bField;
}","public Battlefield load(File file){
  ModelManager.setBattlefieldUnavailable();
  Battlefield bField=null;
  try {
    LogUtil.logger.info(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
    ObjectMapper mapper=new ObjectMapper();
    bField=mapper.readValue(file,Battlefield.class);
    bField.setFileName(file.getCanonicalPath());
    bField.getMap().atlas.finalize();
    bField.getMap().cover.finalize();
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
  if (bField == null) {
    LogUtil.logger.info(""String_Node_Str"");
    ModelManager.setBattlefieldReady();
    return null;
  }
  LogUtil.logger.info(""String_Node_Str"");
  BuilderManager.getMapStyleBuilder(bField.getMap().mapStyleID).build(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  linkTiles(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  for (  Ramp r : bField.getMap().ramps) {
    r.connect(bField.getMap());
  }
  for (  Tile t : bField.getMap().getTiles()) {
    int minLevel=t.level;
    int maxLevel=t.level;
    for (    Tile n : bField.getMap().get8Around(t)) {
      maxLevel=Math.max(maxLevel,n.level);
    }
    if (minLevel != maxLevel) {
      t.setCliff(minLevel,maxLevel);
    }
  }
  LogUtil.logger.info(""String_Node_Str"");
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      c.connect(bField.getMap());
    }
  }
  int i=0;
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      BuilderManager.getCliffShapeBuilder(t.getCliffShapeID()).build(c);
      i++;
    }
  }
  LogUtil.logger.info(""String_Node_Str"" + i + ""String_Node_Str"");
  ParcelManager.createParcelMeshes(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  bField.getMap().atlas.loadFromFile(bField.getFileName(),""String_Node_Str"");
  bField.getMap().cover.loadFromFile(bField.getFileName(),""String_Node_Str"");
  LogUtil.logger.info(""String_Node_Str"");
  return bField;
}"
3717,"public void save(Battlefield battlefield){
  battlefield.getEngagement().save();
  battlefield.getMap().saveTrinkets();
  ObjectMapper mapper=new ObjectMapper();
  mapper.enable(SerializationFeature.INDENT_OUTPUT);
  try {
    if (battlefield.getFileName() != null) {
      LogUtil.logger.info(""String_Node_Str"" + battlefield.getFileName() + ""String_Node_Str"");
      mapper.writeValue(new File(battlefield.getFileName()),battlefield);
    }
 else {
      final JFileChooser fc=new JFileChooser(ModelManager.DEFAULT_MAP_PATH);
      fc.setAcceptAllFileFilterUsed(false);
      FileNameExtensionFilter filter=new FileNameExtensionFilter(""String_Node_Str"" + BATTLEFIELD_FILE_EXTENSION + ""String_Node_Str"",BATTLEFIELD_FILE_EXTENSION);
      fc.addChoosableFileFilter(filter);
      int returnVal=fc.showSaveDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        File f=fc.getSelectedFile();
        int i=f.getName().lastIndexOf('.');
        if (i == 0 || !f.getName().substring(i + 1).equals(BATTLEFIELD_FILE_EXTENSION)) {
          f=new File(f.toString() + ""String_Node_Str"" + BATTLEFIELD_FILE_EXTENSION);
        }
        battlefield.setFileName(f.getCanonicalPath());
        LogUtil.logger.info(""String_Node_Str"" + battlefield.getFileName() + ""String_Node_Str"");
        mapper.writeValue(new File(battlefield.getFileName()),battlefield);
      }
    }
  }
 catch (  Exception ex) {
    Logger.getLogger(BattlefieldFactory.class.getName()).log(Level.SEVERE,null,ex);
  }
  LogUtil.logger.info(""String_Node_Str"");
  battlefield.getMap().atlas.saveToFile(battlefield.getFileName());
  LogUtil.logger.info(""String_Node_Str"");
}","public void save(Battlefield battlefield){
  battlefield.getEngagement().save();
  battlefield.getMap().saveTrinkets();
  ObjectMapper mapper=new ObjectMapper();
  mapper.enable(SerializationFeature.INDENT_OUTPUT);
  try {
    if (battlefield.getFileName() != null) {
      LogUtil.logger.info(""String_Node_Str"" + battlefield.getFileName() + ""String_Node_Str"");
      mapper.writeValue(new File(battlefield.getFileName()),battlefield);
    }
 else {
      final JFileChooser fc=new JFileChooser(ModelManager.DEFAULT_MAP_PATH);
      fc.setAcceptAllFileFilterUsed(false);
      FileNameExtensionFilter filter=new FileNameExtensionFilter(""String_Node_Str"" + BATTLEFIELD_FILE_EXTENSION + ""String_Node_Str"",BATTLEFIELD_FILE_EXTENSION);
      fc.addChoosableFileFilter(filter);
      int returnVal=fc.showSaveDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        File f=fc.getSelectedFile();
        int i=f.getName().lastIndexOf('.');
        if (i == 0 || !f.getName().substring(i + 1).equals(BATTLEFIELD_FILE_EXTENSION)) {
          f=new File(f.toString() + ""String_Node_Str"" + BATTLEFIELD_FILE_EXTENSION);
        }
        battlefield.setFileName(f.getCanonicalPath());
        LogUtil.logger.info(""String_Node_Str"" + battlefield.getFileName() + ""String_Node_Str"");
        mapper.writeValue(new File(battlefield.getFileName()),battlefield);
      }
    }
  }
 catch (  Exception ex) {
    Logger.getLogger(BattlefieldFactory.class.getName()).log(Level.SEVERE,null,ex);
  }
  LogUtil.logger.info(""String_Node_Str"");
  battlefield.getMap().atlas.saveToFile(battlefield.getFileName(),""String_Node_Str"");
  battlefield.getMap().cover.saveToFile(battlefield.getFileName(),""String_Node_Str"");
  LogUtil.logger.info(""String_Node_Str"");
}"
3718,"public void loadFromFile(String fileName){
  byte[] bytes=new byte[width * height * LAYER_COUNT];
  try {
    FileInputStream fis=new FileInputStream(fileName + ""String_Node_Str"");
    fis.read(bytes,0,width * height * LAYER_COUNT);
    fis.close();
  }
 catch (  IOException e) {
    throw new TechnicalException(""String_Node_Str"" + e);
  }
  int index=0;
  layers.clear();
  for (int i=0; i < LAYER_COUNT; i++) {
    AtlasLayer l=new AtlasLayer(width,height);
    for (int xy=0; xy < width * height; xy++) {
      l.setByte(xy,bytes[index++]);
    }
    layers.add(l);
  }
  buffers.clear();
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
  toUpdate=true;
}","public void loadFromFile(String fileName,String suffix){
  byte[] bytes=new byte[width * height * LAYER_COUNT];
  try {
    FileInputStream fis=new FileInputStream(fileName + suffix);
    fis.read(bytes,0,width * height * LAYER_COUNT);
    fis.close();
  }
 catch (  IOException e) {
    throw new TechnicalException(""String_Node_Str"" + e);
  }
  int index=0;
  layers.clear();
  for (int i=0; i < LAYER_COUNT; i++) {
    AtlasLayer l=new AtlasLayer(width,height);
    for (int xy=0; xy < width * height; xy++) {
      l.setByte(xy,bytes[index++]);
    }
    layers.add(l);
  }
  buffers.clear();
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
  toUpdate=true;
}"
3719,"public ByteBuffer getBuffer(int index){
  return buffers.get(index);
}","public ByteBuffer getBuffer(int index){
  if (!finalized)   LogUtil.logger.warning(""String_Node_Str"");
  return buffers.get(index);
}"
3720,"public List<AtlasLayer> getLayers(){
  return layers;
}","public List<AtlasLayer> getLayers(){
  if (!finalized)   LogUtil.logger.warning(""String_Node_Str"");
  return layers;
}"
3721,"public void saveToFile(String fileName){
  byte[] bytes=new byte[width * height * LAYER_COUNT];
  int index=0;
  for (  AtlasLayer l : layers) {
    for (    Byte b : l.getBytes()) {
      bytes[index++]=b;
    }
  }
  try {
    FileOutputStream fos=new FileOutputStream(fileName + ""String_Node_Str"");
    fos.write(bytes);
    fos.close();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
  }
}","public void saveToFile(String fileName,String suffix){
  byte[] bytes=new byte[width * height * LAYER_COUNT];
  int index=0;
  for (  AtlasLayer l : layers) {
    for (    Byte b : l.getBytes()) {
      bytes[index++]=b;
    }
  }
  try {
    FileOutputStream fos=new FileOutputStream(fileName + suffix);
    fos.write(bytes);
    fos.close();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
  }
}"
3722,"@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,AtlasLayer.MAX_VALUE));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}","@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,AtlasLayer.MAX_VALUE));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
  finalized=true;
}"
3723,"public void renderTiles(){
  int index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.diffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.normals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.normals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.scales.get(index);
    groundTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  groundTexture.buildMaterial();
  index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.coverDiffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.coverNormals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.coverNormals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.coverScales.get(index);
    coverTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  coverTexture.buildMaterial();
  for (  ParcelMesh mesh : ParcelManager.getMeshes()) {
    Geometry g=new Geometry();
    Mesh jmeMesh=Translator.toJMEMesh(mesh);
    SilentTangentBinormalGenerator.generate(jmeMesh);
    g.setMesh(jmeMesh);
    g.setMaterial(groundTexture.getMaterial());
    g.setQueueBucket(Bucket.Transparent);
    g.addControl(new RigidBodyControl(0));
    parcelsSpatial.put(mesh,g);
    castAndReceiveNode.attachChild(g);
    mainPhysicsSpace.add(g);
    Geometry g2=new Geometry();
    g2.setMesh(jmeMesh);
    g2.setMaterial(coverTexture.getMaterial());
    g2.setQueueBucket(Bucket.Transparent);
    g2.setLocalTranslation(0,0,0.01f);
    layerSpatial.put(mesh,g2);
    castAndReceiveNode.attachChild(g2);
  }
  updateTiles(ModelManager.getBattlefield().getMap().getTiles());
}","public void renderTiles(){
  int index=0;
  LogUtil.logger.info(""String_Node_Str"" + ModelManager.getBattlefield().getMap().style.diffuses);
  for (  String s : ModelManager.getBattlefield().getMap().style.diffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.normals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.normals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.scales.get(index);
    groundTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  groundTexture.buildMaterial();
  index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.coverDiffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.coverNormals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.coverNormals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.coverScales.get(index);
    coverTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  coverTexture.buildMaterial();
  for (  ParcelMesh mesh : ParcelManager.getMeshes()) {
    Geometry g=new Geometry();
    Mesh jmeMesh=Translator.toJMEMesh(mesh);
    SilentTangentBinormalGenerator.generate(jmeMesh);
    g.setMesh(jmeMesh);
    g.setMaterial(groundTexture.getMaterial());
    g.setQueueBucket(Bucket.Transparent);
    g.addControl(new RigidBodyControl(0));
    parcelsSpatial.put(mesh,g);
    castAndReceiveNode.attachChild(g);
    mainPhysicsSpace.add(g);
    Geometry g2=new Geometry();
    g2.setMesh(jmeMesh);
    g2.setMaterial(coverTexture.getMaterial());
    g2.setQueueBucket(Bucket.Transparent);
    g2.setLocalTranslation(0,0,0.01f);
    layerSpatial.put(mesh,g2);
    castAndReceiveNode.attachChild(g2);
  }
  updateTiles(ModelManager.getBattlefield().getMap().getTiles());
}"
3724,"@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,1));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}","@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,AtlasLayer.MAX_VALUE));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}"
3725,"private int getBufferVal(int x,int y,int firstLayerIndex){
  int r=(int)Math.round(layers.get(firstLayerIndex).get(x,y) * 255) << 24;
  int g=(int)Math.round(layers.get(firstLayerIndex + 1).get(x,y) * 255) << 16;
  int b=(int)Math.round(layers.get(firstLayerIndex + 2).get(x,y) * 255) << 8;
  int a=(int)Math.round(layers.get(firstLayerIndex + 3).get(x,y) * 255);
  return (r + g + b+ a);
}","private int getBufferVal(int x,int y,int firstLayerIndex){
  int r=(int)Math.round(layers.get(firstLayerIndex).get(x,y)) << 24;
  int g=(int)Math.round(layers.get(firstLayerIndex + 1).get(x,y)) << 16;
  int b=(int)Math.round(layers.get(firstLayerIndex + 2).get(x,y)) << 8;
  int a=(int)Math.round(layers.get(firstLayerIndex + 3).get(x,y));
  return (r + g + b+ a);
}"
3726,"public double addAndReturnExcess(int x,int y,double toAdd){
  double excess=0;
  double newVal=get(x,y) + toAdd;
  if (newVal > 1) {
    excess=newVal - 1;
    newVal=1;
  }
  set(x,y,newVal);
  return excess;
}","public double addAndReturnExcess(int x,int y,double toAdd){
  double excess=0;
  double newVal=get(x,y) + toAdd;
  if (newVal > MAX_VALUE) {
    excess=newVal - MAX_VALUE;
    newVal=MAX_VALUE;
  }
  set(x,y,newVal);
  return excess;
}"
3727,"public void set(int x,int y,double val){
  values.set(x,y,(byte)(val * 255 - 128));
}","public void set(int x,int y,double val){
  values.set(x,y,(byte)(val - 128));
}"
3728,"public double get(int x,int y){
  return ((double)values.get(x,y) + 128) / 255;
}","public double get(int x,int y){
  return ((double)values.get(x,y) + 128);
}"
3729,"public AtlasLayer(int xSize,int ySize,double val){
  values=new Map2D<Byte>(xSize,ySize,(byte)(val * 255 - 128));
}","public AtlasLayer(int xSize,int ySize,double val){
  values=new Map2D<Byte>(xSize,ySize,(byte)(val - 128));
}"
3730,"private void decrement(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
    if (ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.withdrawAndReturnExcess(x,y,attenuatedInc);
    }
 else     if (l.get(x,y) > 0) {
      availableLayers.add(l);
    }
  }
  if (availableLayers.isEmpty()) {
    availableLayers.add(ModelManager.getBattlefield().getMap().atlas.getLayers().get(0));
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.addAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 255) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
}","private void decrement(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=Math.round(increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p)));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
    if (ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.withdrawAndReturnExcess(x,y,attenuatedInc);
    }
 else     if (l.get(x,y) > 0) {
      availableLayers.add(l);
    }
  }
  if (availableLayers.isEmpty()) {
    availableLayers.add(ModelManager.getBattlefield().getMap().atlas.getLayers().get(0));
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.addAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 255) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
}"
3731,"private void increment(Point2D p,int layer){
  Atlas toPaint=ModelManager.getBattlefield().getMap().atlas;
  if (layer > 3) {
    toPaint=ModelManager.getBattlefield().getMap().cover;
    layer-=4;
  }
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : toPaint.getLayers()) {
    if (toPaint.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.addAndReturnExcess(x,y,attenuatedInc);
    }
 else {
      if (l.get(x,y) > 0)       availableLayers.add(l);
    }
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.withdrawAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 0) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  toPaint.updatePixel(x,y);
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  String val=""String_Node_Str"";
  double total=0;
  for (  AtlasLayer l : toPaint.getLayers()) {
    val+=df.format(l.get(x,y)) + ""String_Node_Str"";
    total+=l.get(x,y);
  }
  LogUtil.logger.info(val);
  LogUtil.logger.info(""String_Node_Str"" + df.format(total));
}","private void increment(Point2D p,int layer){
  Atlas toPaint=ModelManager.getBattlefield().getMap().atlas;
  if (layer > 3) {
    toPaint=ModelManager.getBattlefield().getMap().cover;
    layer-=4;
  }
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=Math.round(increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p)));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : toPaint.getLayers()) {
    if (toPaint.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.addAndReturnExcess(x,y,attenuatedInc);
    }
 else {
      if (l.get(x,y) > 0)       availableLayers.add(l);
    }
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=Math.round(valueToDitribute / availableLayers.size());
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.withdrawAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 0) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  toPaint.updatePixel(x,y);
}"
3732,"private void smooth(ArrayList<Point2D> pixels){
  for (  Point2D p : pixels) {
    int x=(int)Math.round(p.x);
    int y=(int)Math.round(p.y);
    double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(new Point2D(x,y).getMult(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height).getDivision(ModelManager.getBattlefield().getMap().atlas.getWidth(),ModelManager.getBattlefield().getMap().atlas.getHeight()));
    int activeLayerCount=0;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        activeLayerCount++;
      }
    }
    double targetVal=255 / activeLayerCount;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        double diff=targetVal - l.get(x,y);
        if (diff < 0) {
          l.set(x,y,l.get(x,y) + Math.max(diff,-attenuatedInc));
        }
 else         if (diff > 0) {
          l.set(x,y,l.get(x,y) + Math.min(diff,attenuatedInc));
        }
      }
    }
    ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
  }
}","private void smooth(ArrayList<Point2D> pixels){
  for (  Point2D p : pixels) {
    int x=(int)Math.round(p.x);
    int y=(int)Math.round(p.y);
    double attenuatedInc=Math.round(increment * pencil.strength * pencil.getApplicationRatio(new Point2D(x,y).getMult(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height).getDivision(ModelManager.getBattlefield().getMap().atlas.getWidth(),ModelManager.getBattlefield().getMap().atlas.getHeight())));
    int activeLayerCount=0;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        activeLayerCount++;
      }
    }
    double targetVal=255 / activeLayerCount;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        double diff=targetVal - l.get(x,y);
        if (diff < 0) {
          l.set(x,y,l.get(x,y) + Math.max(diff,-attenuatedInc));
        }
 else         if (diff > 0) {
          l.set(x,y,l.get(x,y) + Math.min(diff,attenuatedInc));
        }
      }
    }
    ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
  }
}"
3733,"public void buildMaterial(){
  mat=new Material(am,""String_Node_Str"");
  Texture2D alpha0=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(0)));
  mat.setTexture(""String_Node_Str"",alpha0);
  Texture2D alpha1=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(1)));
  mat.setTexture(""String_Node_Str"",alpha1);
  mat.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
  for (int i=0; i < 12; i++) {
    if (diffuseMaps.size() > i) {
      if (i == 0) {
        mat.setTexture(""String_Node_Str"",diffuseMaps.get(i));
      }
 else {
        mat.setTexture(""String_Node_Str"" + i,diffuseMaps.get(i));
      }
      mat.setFloat(""String_Node_Str"" + i + ""String_Node_Str"",scales.get(i).floatValue());
      if (normaMaps.get(i) != null) {
        if (i == 0) {
          mat.setTexture(""String_Node_Str"",normaMaps.get(i));
        }
 else {
          mat.setTexture(""String_Node_Str"" + i,normaMaps.get(i));
        }
      }
    }
  }
}","public void buildMaterial(){
  mat=new Material(am,""String_Node_Str"");
  Texture2D alpha0=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(0)));
  mat.setTexture(""String_Node_Str"",alpha0);
  Texture2D alpha1=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(1)));
  mat.setTexture(""String_Node_Str"",alpha1);
  if (transp)   mat.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
  for (int i=0; i < 12; i++) {
    if (diffuseMaps.size() > i) {
      if (i == 0) {
        mat.setTexture(""String_Node_Str"",diffuseMaps.get(i));
      }
 else {
        mat.setTexture(""String_Node_Str"" + i,diffuseMaps.get(i));
      }
      mat.setFloat(""String_Node_Str"" + i + ""String_Node_Str"",scales.get(i).floatValue());
      if (normaMaps.get(i) != null) {
        if (i == 0) {
          mat.setTexture(""String_Node_Str"",normaMaps.get(i));
        }
 else {
          mat.setTexture(""String_Node_Str"" + i,normaMaps.get(i));
        }
      }
    }
  }
}"
3734,"public AtlasTool(){
  super(ADD_DELETE_OP,PROPAGATE_SMOOTH_OP);
  explorer=new AtlasExplorer(ModelManager.getBattlefield().getMap());
  List<String> allTextures=ModelManager.getBattlefield().getMap().style.diffuses;
  while (allTextures.size() < 8)   allTextures.add(null);
  allTextures.addAll(ModelManager.getBattlefield().getMap().style.coverDiffuses);
  set=new AssetSet(allTextures,true);
}","public AtlasTool(){
  super(ADD_DELETE_OP,PROPAGATE_SMOOTH_OP);
  explorer=new AtlasExplorer(ModelManager.getBattlefield().getMap());
  List<String> allTextures=new ArrayList<>();
  allTextures.addAll(ModelManager.getBattlefield().getMap().style.diffuses);
  while (allTextures.size() < 8)   allTextures.add(null);
  allTextures.addAll(ModelManager.getBattlefield().getMap().style.coverDiffuses);
  set=new AssetSet(allTextures,true);
}"
3735,"public void resetTrinkets(){
  trinkets.clear();
  for (  SerializableTrinket st : serializableTrinkets) {
    trinkets.add(st.getTrinket());
  }
}","public void resetTrinkets(){
  trinkets.clear();
  for (  SerializableTrinket st : serializableTrinkets) {
    Trinket t=st.getTrinket();
    trinkets.add(t);
    t.drawOnBattlefield();
  }
}"
3736,"private void add(){
  Point2D pos=pencil.getCoord();
  for (  Trinket t : ModelManager.getBattlefield().getMap().trinkets) {
    if (t.pos.equals(pos)) {
      pos=pos.getTranslation(MyRandom.between(Angle.FLAT,-Angle.FLAT),0.1);
    }
  }
  Trinket t=BuilderManager.getAllEditableTrinketBuilders().get(set.actual).build(pos.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(pos)));
  ModelManager.getBattlefield().getMap().trinkets.add(t);
}","private void add(){
  Point2D pos=pencil.getCoord();
  for (  Trinket t : ModelManager.getBattlefield().getMap().trinkets) {
    if (t.pos.equals(pos)) {
      pos=pos.getTranslation(MyRandom.between(Angle.FLAT,-Angle.FLAT),0.1);
    }
  }
  Trinket t=BuilderManager.getAllEditableTrinketBuilders().get(set.actual).build(pos.get3D(ModelManager.getBattlefield().getMap().getAltitudeAt(pos)));
  t.drawOnBattlefield();
  ModelManager.getBattlefield().getMap().trinkets.add(t);
}"
3737,"public void renderTiles(){
  int index=0;
  LogUtil.logger.info(""String_Node_Str"" + ModelManager.getBattlefield().getMap().style.diffuses);
  for (  String s : ModelManager.getBattlefield().getMap().style.diffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.normals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.normals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.scales.get(index);
    groundTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  groundTexture.buildMaterial();
  index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.coverDiffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.coverNormals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.coverNormals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.coverScales.get(index);
    coverTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  coverTexture.buildMaterial();
  for (  ParcelMesh mesh : ParcelManager.getMeshes()) {
    Geometry g=new Geometry();
    Mesh jmeMesh=Translator.toJMEMesh(mesh);
    SilentTangentBinormalGenerator.generate(jmeMesh);
    g.setMesh(jmeMesh);
    g.setMaterial(groundTexture.getMaterial());
    g.setQueueBucket(Bucket.Transparent);
    g.addControl(new RigidBodyControl(0));
    parcelsSpatial.put(mesh,g);
    castAndReceiveNode.attachChild(g);
    mainPhysicsSpace.add(g);
    Geometry g2=new Geometry();
    g2.setMesh(jmeMesh);
    g2.setMaterial(coverTexture.getMaterial());
    g2.setQueueBucket(Bucket.Transparent);
    g2.setLocalTranslation(0,0,0.01f);
    layerSpatial.put(mesh,g2);
    castAndReceiveNode.attachChild(g2);
  }
  updateTiles(ModelManager.getBattlefield().getMap().getTiles());
}","public void renderTiles(){
  int index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.diffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.normals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.normals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.scales.get(index);
    groundTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  groundTexture.buildMaterial();
  index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.coverDiffuses) {
    Texture diffuse=am.loadTexture(s);
    Texture normal=null;
    if (ModelManager.getBattlefield().getMap().style.coverNormals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.coverNormals.get(index));
    }
    double scale=ModelManager.getBattlefield().getMap().style.coverScales.get(index);
    coverTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  coverTexture.buildMaterial();
  for (  ParcelMesh mesh : ParcelManager.getMeshes()) {
    Geometry g=new Geometry();
    Mesh jmeMesh=Translator.toJMEMesh(mesh);
    SilentTangentBinormalGenerator.generate(jmeMesh);
    g.setMesh(jmeMesh);
    g.setMaterial(groundTexture.getMaterial());
    g.setQueueBucket(Bucket.Transparent);
    g.addControl(new RigidBodyControl(0));
    parcelsSpatial.put(mesh,g);
    castAndReceiveNode.attachChild(g);
    mainPhysicsSpace.add(g);
    Geometry g2=new Geometry();
    g2.setMesh(jmeMesh);
    g2.setMaterial(coverTexture.getMaterial());
    g2.setQueueBucket(Bucket.Transparent);
    g2.setLocalTranslation(0,0,0.01f);
    layerSpatial.put(mesh,g2);
    castAndReceiveNode.attachChild(g2);
  }
  updateTiles(ModelManager.getBattlefield().getMap().getTiles());
}"
3738,"@Override public void perform(Actor a){
  ParticleActor actor=(ParticleActor)a;
  if (actor.getViewElements().particleEmitter == null) {
    createEmitter(actor);
  }
  ModelActor ma=actor.getParentModelActor();
  if (ma.getViewElements().spatial == null) {
    LogUtil.logger.info(actor + ""String_Node_Str"" + ma);
  }
  Vector3f emissionPoint;
  Vector3f direction;
  if (actor.emissionBone != null) {
    if (!ma.hasBone(actor.emissionBone)) {
      LogUtil.logger.info(actor + ""String_Node_Str"" + actor.emissionBone+ ""String_Node_Str""+ ma);
      return;
    }
    emissionPoint=Translator.toVector3f(ma.getBoneCoord(actor.emissionBone));
    if (actor.directionBone != null) {
      direction=Translator.toVector3f(ma.getBoneCoord(actor.directionBone));
    }
 else {
      direction=new Vector3f(emissionPoint);
    }
  }
 else {
    emissionPoint=Translator.toVector3f(ma.getPos());
    direction=Translator.toVector3f(ma.getPos().get2D().getTranslation(ma.getYaw(),1).get3D(emissionPoint.z));
  }
  direction=direction.subtract(emissionPoint).normalize();
  Vector3f velocity=direction.mult((float)actor.velocity);
  ParticleEmitter pe=actor.getViewElements().particleEmitter;
  pe.getParticleInfluencer().setInitialVelocity(velocity);
  pe.getParticleInfluencer().setVelocityVariation((float)actor.fanning);
  if (actor.facing == ParticleActor.Facing.Velocity) {
    pe.setFaceNormal(direction);
  }
  if (pe.getParticlesPerSec() == 0) {
    pe.setParticlesPerSec(actor.perSecond);
  }
  Vector3f pos=pe.getWorldTranslation();
  pe.setLocalTranslation(emissionPoint);
  if (actor.duration == 0) {
    pe.emitAllParticles();
  }
  actor.updateDuration();
  if (pe.getUserData(""String_Node_Str"") != null && !pe.getUserData(""String_Node_Str"").equals(emissionPoint)) {
    double elapsedTime=System.currentTimeMillis() - (Long)pe.getUserData(""String_Node_Str"");
    for (    Particle p : getParticles(pe)) {
      double age=(p.startlife - p.life) * 1000;
      if (age < elapsedTime) {
        p.position.interpolate((Vector3f)pe.getUserData(""String_Node_Str""),(float)(age / elapsedTime));
      }
    }
  }
  pe.setUserData(""String_Node_Str"",pos.clone());
  pe.setUserData(""String_Node_Str"",System.currentTimeMillis());
}","@Override public void perform(Actor a){
  ParticleActor actor=(ParticleActor)a;
  if (actor.getViewElements().particleEmitter == null) {
    createEmitter(actor);
  }
  ModelActor ma=actor.getParentModelActor();
  if (ma.getViewElements().spatial == null) {
    LogUtil.logger.info(actor + ""String_Node_Str"" + ma);
  }
  Vector3f emissionPoint;
  Vector3f direction;
  if (actor.emissionBone != null) {
    if (!ma.hasBone(actor.emissionBone)) {
      LogUtil.logger.info(actor + ""String_Node_Str"" + actor.emissionBone+ ""String_Node_Str""+ ma);
      return;
    }
    emissionPoint=Translator.toVector3f(ma.getBoneCoord(actor.emissionBone));
    if (actor.directionBone != null) {
      direction=Translator.toVector3f(ma.getBoneCoord(actor.directionBone));
    }
 else {
      direction=new Vector3f(emissionPoint);
    }
  }
 else {
    emissionPoint=Translator.toVector3f(ma.getPos());
    direction=Translator.toVector3f(ma.getPos().get2D().getTranslation(ma.getYaw(),1).get3D(emissionPoint.z));
  }
  direction=direction.subtract(emissionPoint).normalize();
  Vector3f velocity=direction.mult((float)actor.velocity);
  ParticleEmitter pe=actor.getViewElements().particleEmitter;
  pe.getParticleInfluencer().setInitialVelocity(velocity);
  pe.getParticleInfluencer().setVelocityVariation((float)actor.fanning);
  if (actor.facing == ParticleActor.Facing.Velocity) {
    pe.setFaceNormal(direction);
  }
  if (pe.getParticlesPerSec() == 0) {
    pe.setParticlesPerSec(actor.perSecond);
  }
  Vector3f pos=pe.getWorldTranslation();
  pe.setLocalTranslation(emissionPoint);
  if (actor.duration == 0) {
    pe.emitAllParticles();
  }
  actor.updateDuration();
  if (pe.getUserData(""String_Node_Str"") != null && !pe.getUserData(""String_Node_Str"").equals(Vector3f.ZERO) && !pe.getUserData(""String_Node_Str"").equals(emissionPoint)) {
    double elapsedTime=System.currentTimeMillis() - (Long)pe.getUserData(""String_Node_Str"");
    for (    Particle p : getParticles(pe)) {
      double age=(p.startlife - p.life) * 1000;
      if (age < elapsedTime) {
        p.position.interpolate((Vector3f)pe.getUserData(""String_Node_Str""),(float)(age / elapsedTime));
      }
    }
  }
  pe.setUserData(""String_Node_Str"",pos.clone());
  pe.setUserData(""String_Node_Str"",System.currentTimeMillis());
}"
3739,"private void decrement(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : atlas.getLayers()) {
    if (atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.withdrawAndReturnExcess(x,y,attenuatedInc);
    }
 else     if (l.get(x,y) > 0) {
      availableLayers.add(l);
    }
  }
  if (availableLayers.isEmpty()) {
    availableLayers.add(atlas.getLayers().get(0));
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.addAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 255) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  atlas.updatePixel(x,y);
}","private void decrement(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
    if (ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.withdrawAndReturnExcess(x,y,attenuatedInc);
    }
 else     if (l.get(x,y) > 0) {
      availableLayers.add(l);
    }
  }
  if (availableLayers.isEmpty()) {
    availableLayers.add(ModelManager.getBattlefield().getMap().atlas.getLayers().get(0));
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.addAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 255) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
}"
3740,"private void increment(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : atlas.getLayers()) {
    if (atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.addAndReturnExcess(x,y,attenuatedInc);
    }
 else {
      availableLayers.add(l);
    }
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.withdrawAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 0) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  atlas.updatePixel(x,y);
}","private void increment(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
    if (ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.addAndReturnExcess(x,y,attenuatedInc);
    }
 else {
      availableLayers.add(l);
    }
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.withdrawAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 0) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
}"
3741,"private void propagate(ArrayList<Point2D> pixels){
  if (!pencil.maintained) {
    pencil.maintain();
    autoLayer=0;
    Point2D center=pencil.getCoord().getMult(atlas.getWidth(),atlas.getHeight()).getDivision(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height);
    int centerX=(int)Math.round(center.x);
    int centerY=(int)Math.round(center.y);
    for (    AtlasLayer l : atlas.getLayers()) {
      if (l.get(centerX,centerY) > atlas.getLayers().get(autoLayer).get(centerX,centerY)) {
        autoLayer=atlas.getLayers().indexOf(l);
      }
    }
  }
  for (  Point2D p : pixels) {
    increment(p,autoLayer);
  }
}","private void propagate(ArrayList<Point2D> pixels){
  if (!pencil.maintained) {
    pencil.maintain();
    autoLayer=0;
    Point2D center=pencil.getCoord().getMult(ModelManager.getBattlefield().getMap().atlas.getWidth(),ModelManager.getBattlefield().getMap().atlas.getHeight()).getDivision(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height);
    int centerX=(int)Math.round(center.x);
    int centerY=(int)Math.round(center.y);
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(centerX,centerY) > ModelManager.getBattlefield().getMap().atlas.getLayers().get(autoLayer).get(centerX,centerY)) {
        autoLayer=ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l);
      }
    }
  }
  for (  Point2D p : pixels) {
    increment(p,autoLayer);
  }
}"
3742,"public AtlasTool(){
  super(ADD_DELETE_OP,PROPAGATE_SMOOTH_OP);
  this.atlas=ModelManager.getBattlefield().getMap().atlas;
  explorer=new AtlasExplorer(ModelManager.getBattlefield().getMap());
  set=new AssetSet(ModelManager.getBattlefield().getMap().style.textures,true);
}","public AtlasTool(){
  super(ADD_DELETE_OP,PROPAGATE_SMOOTH_OP);
  explorer=new AtlasExplorer(ModelManager.getBattlefield().getMap());
  set=new AssetSet(ModelManager.getBattlefield().getMap().style.textures,true);
}"
3743,"private void smooth(ArrayList<Point2D> pixels){
  for (  Point2D p : pixels) {
    int x=(int)Math.round(p.x);
    int y=(int)Math.round(p.y);
    double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(new Point2D(x,y).getMult(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height).getDivision(atlas.getWidth(),atlas.getHeight()));
    int activeLayerCount=0;
    for (    AtlasLayer l : atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        activeLayerCount++;
      }
    }
    double targetVal=255 / activeLayerCount;
    for (    AtlasLayer l : atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        double diff=targetVal - l.get(x,y);
        if (diff < 0) {
          l.set(x,y,l.get(x,y) + Math.max(diff,-attenuatedInc));
        }
 else         if (diff > 0) {
          l.set(x,y,l.get(x,y) + Math.min(diff,attenuatedInc));
        }
      }
    }
    atlas.updatePixel(x,y);
  }
}","private void smooth(ArrayList<Point2D> pixels){
  for (  Point2D p : pixels) {
    int x=(int)Math.round(p.x);
    int y=(int)Math.round(p.y);
    double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(new Point2D(x,y).getMult(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height).getDivision(ModelManager.getBattlefield().getMap().atlas.getWidth(),ModelManager.getBattlefield().getMap().atlas.getHeight()));
    int activeLayerCount=0;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        activeLayerCount++;
      }
    }
    double targetVal=255 / activeLayerCount;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        double diff=targetVal - l.get(x,y);
        if (diff < 0) {
          l.set(x,y,l.get(x,y) + Math.max(diff,-attenuatedInc));
        }
 else         if (diff > 0) {
          l.set(x,y,l.get(x,y) + Math.min(diff,attenuatedInc));
        }
      }
    }
    ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
  }
}"
3744,"@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,1));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}","@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,AtlasLayer.MAX_VALUE));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}"
3745,"private int getBufferVal(int x,int y,int firstLayerIndex){
  int r=(int)Math.round(layers.get(firstLayerIndex).get(x,y) * 255) << 24;
  int g=(int)Math.round(layers.get(firstLayerIndex + 1).get(x,y) * 255) << 16;
  int b=(int)Math.round(layers.get(firstLayerIndex + 2).get(x,y) * 255) << 8;
  int a=(int)Math.round(layers.get(firstLayerIndex + 3).get(x,y) * 255);
  return (r + g + b+ a);
}","private int getBufferVal(int x,int y,int firstLayerIndex){
  int r=(int)Math.round(layers.get(firstLayerIndex).get(x,y)) << 24;
  int g=(int)Math.round(layers.get(firstLayerIndex + 1).get(x,y)) << 16;
  int b=(int)Math.round(layers.get(firstLayerIndex + 2).get(x,y)) << 8;
  int a=(int)Math.round(layers.get(firstLayerIndex + 3).get(x,y));
  return (r + g + b+ a);
}"
3746,"public double addAndReturnExcess(int x,int y,double toAdd){
  double excess=0;
  double newVal=get(x,y) + toAdd;
  if (newVal > 1) {
    excess=newVal - 1;
    newVal=1;
  }
  set(x,y,newVal);
  return excess;
}","public double addAndReturnExcess(int x,int y,double toAdd){
  double excess=0;
  double newVal=get(x,y) + toAdd;
  if (newVal > MAX_VALUE) {
    excess=newVal - MAX_VALUE;
    newVal=MAX_VALUE;
  }
  set(x,y,newVal);
  return excess;
}"
3747,"public void set(int x,int y,double val){
  values.set(x,y,(byte)(val * 255 - 128));
}","public void set(int x,int y,double val){
  values.set(x,y,(byte)(val - 128));
}"
3748,"public double get(int x,int y){
  return ((double)values.get(x,y) + 128) / 255;
}","public double get(int x,int y){
  return ((double)values.get(x,y) + 128);
}"
3749,"public AtlasLayer(int xSize,int ySize,double val){
  values=new Map2D<Byte>(xSize,ySize,(byte)(val * 255 - 128));
}","public AtlasLayer(int xSize,int ySize,double val){
  values=new Map2D<Byte>(xSize,ySize,(byte)(val - 128));
}"
3750,"private void decrement(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
    if (ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.withdrawAndReturnExcess(x,y,attenuatedInc);
    }
 else     if (l.get(x,y) > 0) {
      availableLayers.add(l);
    }
  }
  if (availableLayers.isEmpty()) {
    availableLayers.add(ModelManager.getBattlefield().getMap().atlas.getLayers().get(0));
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.addAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 255) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
}","private void decrement(Point2D p,int layer){
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=Math.round(increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p)));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
    if (ModelManager.getBattlefield().getMap().atlas.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.withdrawAndReturnExcess(x,y,attenuatedInc);
    }
 else     if (l.get(x,y) > 0) {
      availableLayers.add(l);
    }
  }
  if (availableLayers.isEmpty()) {
    availableLayers.add(ModelManager.getBattlefield().getMap().atlas.getLayers().get(0));
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.addAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 255) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
}"
3751,"private void increment(Point2D p,int layer){
  Atlas toPaint=ModelManager.getBattlefield().getMap().atlas;
  if (layer > 3) {
    toPaint=ModelManager.getBattlefield().getMap().cover;
    layer-=4;
  }
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : toPaint.getLayers()) {
    if (toPaint.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.addAndReturnExcess(x,y,attenuatedInc);
    }
 else {
      if (l.get(x,y) > 0)       availableLayers.add(l);
    }
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=valueToDitribute / availableLayers.size();
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.withdrawAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 0) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  toPaint.updatePixel(x,y);
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  String val=""String_Node_Str"";
  double total=0;
  for (  AtlasLayer l : toPaint.getLayers()) {
    val+=df.format(l.get(x,y)) + ""String_Node_Str"";
    total+=l.get(x,y);
  }
  LogUtil.logger.info(val);
  LogUtil.logger.info(""String_Node_Str"" + df.format(total));
}","private void increment(Point2D p,int layer){
  Atlas toPaint=ModelManager.getBattlefield().getMap().atlas;
  if (layer > 3) {
    toPaint=ModelManager.getBattlefield().getMap().cover;
    layer-=4;
  }
  int x=(int)Math.round(p.x);
  int y=(int)Math.round(p.y);
  double attenuatedInc=Math.round(increment * pencil.strength * pencil.getApplicationRatio(explorer.getInMapSpace(p)));
  double valueToDitribute=attenuatedInc;
  ArrayList<AtlasLayer> availableLayers=new ArrayList<>();
  for (  AtlasLayer l : toPaint.getLayers()) {
    if (toPaint.getLayers().indexOf(l) == layer) {
      valueToDitribute-=l.addAndReturnExcess(x,y,attenuatedInc);
    }
 else {
      if (l.get(x,y) > 0)       availableLayers.add(l);
    }
  }
  int secur=-1;
  while (valueToDitribute > 0 && !availableLayers.isEmpty() && secur++ < 50) {
    ArrayList<AtlasLayer> unavailableLayers=new ArrayList<>();
    double shared=Math.round(valueToDitribute / availableLayers.size());
    valueToDitribute=0;
    for (    AtlasLayer l : availableLayers) {
      valueToDitribute+=l.withdrawAndReturnExcess(x,y,shared);
      if (l.get(x,y) == 0) {
        unavailableLayers.add(l);
      }
    }
    availableLayers.removeAll(unavailableLayers);
  }
  if (secur > 40) {
    LogUtil.logger.warning(""String_Node_Str"");
  }
  toPaint.updatePixel(x,y);
}"
3752,"private void smooth(ArrayList<Point2D> pixels){
  for (  Point2D p : pixels) {
    int x=(int)Math.round(p.x);
    int y=(int)Math.round(p.y);
    double attenuatedInc=increment * pencil.strength * pencil.getApplicationRatio(new Point2D(x,y).getMult(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height).getDivision(ModelManager.getBattlefield().getMap().atlas.getWidth(),ModelManager.getBattlefield().getMap().atlas.getHeight()));
    int activeLayerCount=0;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        activeLayerCount++;
      }
    }
    double targetVal=255 / activeLayerCount;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        double diff=targetVal - l.get(x,y);
        if (diff < 0) {
          l.set(x,y,l.get(x,y) + Math.max(diff,-attenuatedInc));
        }
 else         if (diff > 0) {
          l.set(x,y,l.get(x,y) + Math.min(diff,attenuatedInc));
        }
      }
    }
    ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
  }
}","private void smooth(ArrayList<Point2D> pixels){
  for (  Point2D p : pixels) {
    int x=(int)Math.round(p.x);
    int y=(int)Math.round(p.y);
    double attenuatedInc=Math.round(increment * pencil.strength * pencil.getApplicationRatio(new Point2D(x,y).getMult(ModelManager.getBattlefield().getMap().width,ModelManager.getBattlefield().getMap().height).getDivision(ModelManager.getBattlefield().getMap().atlas.getWidth(),ModelManager.getBattlefield().getMap().atlas.getHeight())));
    int activeLayerCount=0;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        activeLayerCount++;
      }
    }
    double targetVal=255 / activeLayerCount;
    for (    AtlasLayer l : ModelManager.getBattlefield().getMap().atlas.getLayers()) {
      if (l.get(x,y) != 0) {
        double diff=targetVal - l.get(x,y);
        if (diff < 0) {
          l.set(x,y,l.get(x,y) + Math.max(diff,-attenuatedInc));
        }
 else         if (diff > 0) {
          l.set(x,y,l.get(x,y) + Math.min(diff,attenuatedInc));
        }
      }
    }
    ModelManager.getBattlefield().getMap().atlas.updatePixel(x,y);
  }
}"
3753,"public void buildMaterial(){
  mat=new Material(am,""String_Node_Str"");
  Texture2D alpha0=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(0)));
  mat.setTexture(""String_Node_Str"",alpha0);
  Texture2D alpha1=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(1)));
  mat.setTexture(""String_Node_Str"",alpha1);
  mat.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
  for (int i=0; i < 12; i++) {
    if (diffuseMaps.size() > i) {
      if (i == 0) {
        mat.setTexture(""String_Node_Str"",diffuseMaps.get(i));
      }
 else {
        mat.setTexture(""String_Node_Str"" + i,diffuseMaps.get(i));
      }
      mat.setFloat(""String_Node_Str"" + i + ""String_Node_Str"",scales.get(i).floatValue());
      if (normaMaps.get(i) != null) {
        if (i == 0) {
          mat.setTexture(""String_Node_Str"",normaMaps.get(i));
        }
 else {
          mat.setTexture(""String_Node_Str"" + i,normaMaps.get(i));
        }
      }
    }
  }
}","public void buildMaterial(){
  mat=new Material(am,""String_Node_Str"");
  Texture2D alpha0=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(0)));
  mat.setTexture(""String_Node_Str"",alpha0);
  Texture2D alpha1=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(1)));
  mat.setTexture(""String_Node_Str"",alpha1);
  if (transp)   mat.getAdditionalRenderState().setBlendMode(BlendMode.Alpha);
  for (int i=0; i < 12; i++) {
    if (diffuseMaps.size() > i) {
      if (i == 0) {
        mat.setTexture(""String_Node_Str"",diffuseMaps.get(i));
      }
 else {
        mat.setTexture(""String_Node_Str"" + i,diffuseMaps.get(i));
      }
      mat.setFloat(""String_Node_Str"" + i + ""String_Node_Str"",scales.get(i).floatValue());
      if (normaMaps.get(i) != null) {
        if (i == 0) {
          mat.setTexture(""String_Node_Str"",normaMaps.get(i));
        }
 else {
          mat.setTexture(""String_Node_Str"" + i,normaMaps.get(i));
        }
      }
    }
  }
}"
3754,"public Atlas(int mapWidth,int mapHeight){
  this.mapWidth=mapWidth;
  this.mapHeight=mapHeight;
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
}","public Atlas(int mapWidth,int mapHeight){
  this.mapWidth=mapWidth;
  this.mapHeight=mapHeight;
}"
3755,"@Override public void finalize(){
  layers.add(new AtlasLayer(width,height,1));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}","@Override public void finalize(){
  width=mapWidth * RESOLUTION_RATIO;
  height=mapHeight * RESOLUTION_RATIO;
  layers.add(new AtlasLayer(width,height,1));
  for (int i=1; i < LAYER_COUNT; i++) {
    layers.add(new AtlasLayer(width,height,0));
  }
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
}"
3756,"public void buildMaterial(){
  mat=new Material(am,""String_Node_Str"");
  mat.setTexture(""String_Node_Str"",new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(0))));
  mat.setTexture(""String_Node_Str"",new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(1))));
  for (int i=0; i < 12; i++) {
    if (diffuseMaps.size() > i) {
      if (i == 0) {
        mat.setTexture(""String_Node_Str"",diffuseMaps.get(i));
      }
 else {
        mat.setTexture(""String_Node_Str"" + i,diffuseMaps.get(i));
      }
      mat.setFloat(""String_Node_Str"" + i + ""String_Node_Str"",scales.get(i).floatValue());
      if (normaMaps.get(i) != null) {
        if (i == 0) {
          mat.setTexture(""String_Node_Str"",normaMaps.get(i));
        }
 else {
          mat.setTexture(""String_Node_Str"" + i,normaMaps.get(i));
        }
      }
    }
  }
}","public void buildMaterial(){
  mat=new Material(am,""String_Node_Str"");
  Texture2D alpha0=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(0)));
  Texture2D alpha1=new Texture2D(new Image(Image.Format.RGBA8,atlas.getWidth(),atlas.getHeight(),atlas.getBuffer(1)));
  mat.setTexture(""String_Node_Str"",alpha0);
  mat.setTexture(""String_Node_Str"",alpha1);
  for (int i=0; i < 12; i++) {
    if (diffuseMaps.size() > i) {
      if (i == 0) {
        mat.setTexture(""String_Node_Str"",diffuseMaps.get(i));
      }
 else {
        mat.setTexture(""String_Node_Str"" + i,diffuseMaps.get(i));
      }
      mat.setFloat(""String_Node_Str"" + i + ""String_Node_Str"",scales.get(i).floatValue());
      if (normaMaps.get(i) != null) {
        if (i == 0) {
          mat.setTexture(""String_Node_Str"",normaMaps.get(i));
        }
 else {
          mat.setTexture(""String_Node_Str"" + i,normaMaps.get(i));
        }
      }
    }
  }
}"
3757,"public void renderTiles(){
  int index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.textures) {
    Texture diffuse=am.loadTexture(s);
    Texture normal;
    if (ModelManager.getBattlefield().getMap().style.normals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.normals.get(index));
    }
 else {
      normal=null;
    }
    double scale=ModelManager.getBattlefield().getMap().style.scales.get(index);
    groundTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  groundTexture.buildMaterial();
  for (  ParcelMesh mesh : ParcelManager.getMeshes()) {
    Geometry g=new Geometry();
    Mesh jmeMesh=Translator.toJMEMesh(mesh);
    SilentTangentBinormalGenerator.generate(jmeMesh);
    g.setMesh(jmeMesh);
    g.setMaterial(mm.getLightingTexture(""String_Node_Str""));
    g.addControl(new RigidBodyControl(0));
    parcelsSpatial.put(mesh,g);
    castAndReceiveNode.attachChild(g);
    mainPhysicsSpace.add(g);
  }
  updateTiles(ModelManager.getBattlefield().getMap().getTiles());
}","public void renderTiles(){
  int index=0;
  for (  String s : ModelManager.getBattlefield().getMap().style.textures) {
    Texture diffuse=am.loadTexture(s);
    Texture normal;
    if (ModelManager.getBattlefield().getMap().style.normals.get(index) != null) {
      normal=am.loadTexture(ModelManager.getBattlefield().getMap().style.normals.get(index));
    }
 else {
      normal=null;
    }
    double scale=ModelManager.getBattlefield().getMap().style.scales.get(index);
    groundTexture.addTexture(diffuse,normal,scale);
    index++;
  }
  groundTexture.buildMaterial();
  for (  ParcelMesh mesh : ParcelManager.getMeshes()) {
    Geometry g=new Geometry();
    Mesh jmeMesh=Translator.toJMEMesh(mesh);
    SilentTangentBinormalGenerator.generate(jmeMesh);
    g.setMesh(jmeMesh);
    g.setMaterial(groundTexture.getMaterial());
    g.addControl(new RigidBodyControl(0));
    parcelsSpatial.put(mesh,g);
    castAndReceiveNode.attachChild(g);
    mainPhysicsSpace.add(g);
  }
  updateTiles(ModelManager.getBattlefield().getMap().getTiles());
}"
3758,"private static void setBattlefield(Battlefield battlefield){
  if (battlefield != null) {
    ModelManager.battlefield=battlefield;
    ParcelManager.createParcelMeshes(ModelManager.getBattlefield().getMap());
    battlefield.getEngagement().reset();
    EventManager.post(new BattleFieldUpdateEvent());
    LogUtil.logger.info(""String_Node_Str"");
  }
}","private static void setBattlefield(Battlefield battlefield){
  if (battlefield != null) {
    ModelManager.battlefield=battlefield;
    ParcelManager.createParcelMeshes(ModelManager.getBattlefield().getMap());
    ModelManager.getBattlefield().getMap().resetTrinkets();
    ModelManager.getBattlefield().getEngagement().reset();
    EventManager.post(new BattleFieldUpdateEvent());
    LogUtil.logger.info(""String_Node_Str"");
  }
}"
3759,"public Battlefield load(File file){
  Battlefield bField=null;
  try {
    LogUtil.logger.info(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
    ObjectMapper mapper=new ObjectMapper();
    bField=mapper.readValue(file,Battlefield.class);
    bField.setFileName(file.getCanonicalPath());
    bField.getMap().atlas.finalize();
    SmileFactory f=new SmileFactory();
    mapper=new ObjectMapper(f);
    byte[] smileData=mapper.writeValueAsBytes(bField.getMap().getTiles());
    OutputStream out=new FileOutputStream(ModelManager.DEFAULT_MAP_PATH + ""String_Node_Str"");
    out.write(smileData);
    out.flush();
    out.close();
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
  if (bField == null) {
    LogUtil.logger.info(""String_Node_Str"");
    return null;
  }
  LogUtil.logger.info(""String_Node_Str"");
  BuilderManager.getMapStyleBuilder(bField.getMap().mapStyleID).build(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  linkTiles(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  for (  Ramp r : bField.getMap().ramps) {
    r.connect(bField.getMap());
  }
  for (  Tile t : bField.getMap().getTiles()) {
    int minLevel=t.level;
    int maxLevel=t.level;
    for (    Tile n : bField.getMap().get8Around(t)) {
      maxLevel=Math.max(maxLevel,n.level);
    }
    if (minLevel != maxLevel) {
      t.setCliff(minLevel,maxLevel);
    }
  }
  LogUtil.logger.info(""String_Node_Str"");
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      c.connect(bField.getMap());
    }
  }
  int i=0;
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      BuilderManager.getCliffShapeBuilder(t.getCliffShapeID()).build(c);
      i++;
    }
  }
  LogUtil.logger.info(""String_Node_Str"" + i + ""String_Node_Str"");
  ParcelManager.createParcelMeshes(bField.getMap());
  bField.getMap().resetTrinkets();
  LogUtil.logger.info(""String_Node_Str"");
  bField.getMap().atlas.loadFromFile(bField.getFileName());
  LogUtil.logger.info(""String_Node_Str"");
  return bField;
}","public Battlefield load(File file){
  Battlefield bField=null;
  try {
    LogUtil.logger.info(""String_Node_Str"" + file.getCanonicalPath() + ""String_Node_Str"");
    ObjectMapper mapper=new ObjectMapper();
    bField=mapper.readValue(file,Battlefield.class);
    bField.setFileName(file.getCanonicalPath());
    bField.getMap().atlas.finalize();
    SmileFactory f=new SmileFactory();
    mapper=new ObjectMapper(f);
    byte[] smileData=mapper.writeValueAsBytes(bField.getMap().getTiles());
    OutputStream out=new FileOutputStream(ModelManager.DEFAULT_MAP_PATH + ""String_Node_Str"");
    out.write(smileData);
    out.flush();
    out.close();
  }
 catch (  Exception e1) {
    e1.printStackTrace();
  }
  if (bField == null) {
    LogUtil.logger.info(""String_Node_Str"");
    return null;
  }
  LogUtil.logger.info(""String_Node_Str"");
  BuilderManager.getMapStyleBuilder(bField.getMap().mapStyleID).build(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  linkTiles(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  for (  Ramp r : bField.getMap().ramps) {
    r.connect(bField.getMap());
  }
  for (  Tile t : bField.getMap().getTiles()) {
    int minLevel=t.level;
    int maxLevel=t.level;
    for (    Tile n : bField.getMap().get8Around(t)) {
      maxLevel=Math.max(maxLevel,n.level);
    }
    if (minLevel != maxLevel) {
      t.setCliff(minLevel,maxLevel);
    }
  }
  LogUtil.logger.info(""String_Node_Str"");
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      c.connect(bField.getMap());
    }
  }
  int i=0;
  for (  Tile t : bField.getMap().getTiles()) {
    for (    Cliff c : t.getCliffs()) {
      BuilderManager.getCliffShapeBuilder(t.getCliffShapeID()).build(c);
      i++;
    }
  }
  LogUtil.logger.info(""String_Node_Str"" + i + ""String_Node_Str"");
  ParcelManager.createParcelMeshes(bField.getMap());
  LogUtil.logger.info(""String_Node_Str"");
  bField.getMap().atlas.loadFromFile(bField.getFileName());
  LogUtil.logger.info(""String_Node_Str"");
  return bField;
}"
3760,"public Trinket getTrinket(){
  Trinket res=BuilderManager.getTrinketBuilder(builderID).build(pos,yaw,modelPath,scaleX,scaleY,scaleZ);
  return res;
}","@JsonIgnore public Trinket getTrinket(){
  Trinket res=BuilderManager.getTrinketBuilder(builderID).build(pos,yaw,modelPath,scaleX,scaleY,scaleZ);
  return res;
}"
3761,"@Subscribe protected void handleTileEvent(TilesEvent e){
  updateTiles(e.getExtended());
}","@Subscribe public void handleTileEvent(TilesEvent e){
  updateTiles(e.getExtended());
}"
3762,"public double addAndReturnExcess(int x,int y,double toAdd){
  double excess=0;
  double newVal=get(x,y) + toAdd;
  double maskVal=mask.getPixel((x) % (mask.getWidth() * (int)maskScale),(y) % (mask.getHeight() * (int)maskScale)).a;
  if (maskVal < 1)   newVal=Math.min(newVal,255 * maskVal);
  if (newVal > 255) {
    excess=newVal - 255;
    newVal=255;
  }
  set(x,y,newVal);
  return excess;
}","public double addAndReturnExcess(int x,int y,double toAdd){
  double excess=0;
  double newVal=get(x,y) + toAdd;
  double maskVal=mask.getPixel((x * mask.getWidth() * (int)maskScale / xSize) % (mask.getWidth()),(y * mask.getHeight() * (int)maskScale / ySize) % (mask.getHeight())).a;
  if (newVal > 255 * maskVal) {
    excess=newVal - 255 * maskVal;
    newVal=255 * maskVal;
  }
  set(x,y,newVal);
  return excess;
}"
3763,"public void loadFromFile(String fileName){
  byte[] bytes=new byte[width * height * LAYER_COUNT];
  try {
    FileInputStream fis=new FileInputStream(fileName + ""String_Node_Str"");
    fis.read(bytes,0,width * height * LAYER_COUNT);
    fis.close();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
  }
  int index=0;
  layers.clear();
  for (int i=0; i < LAYER_COUNT; i++) {
    AtlasLayer l=new AtlasLayer(width,height);
    layers.add(l);
  }
  buffers.clear();
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
  toUpdate=true;
}","public void loadFromFile(String fileName){
  byte[] bytes=new byte[width * height * LAYER_COUNT];
  try {
    FileInputStream fis=new FileInputStream(fileName + ""String_Node_Str"");
    fis.read(bytes,0,width * height * LAYER_COUNT);
    fis.close();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
  }
  int index=0;
  layers.clear();
  for (int i=0; i < LAYER_COUNT; i++) {
    AtlasLayer l=new AtlasLayer(width,height);
    for (int xy=0; xy < width * height; xy++)     l.setByte(xy,bytes[index++]);
    layers.add(l);
  }
  buffers.clear();
  buffers.add(buildBuffer(0));
  buffers.add(buildBuffer(1));
  toUpdate=true;
}"
3764,"@Override public void update(float elapsedTime){
  Point2D selStart=((BattlefieldInputInterpreter)inputInterpreter).selectionStart;
  if (selStart != null) {
    Point2D p=Translator.toPoint2D(inputManager.getCursorPosition());
    view.drawSelectionArea(selStart,p);
    ((BattlefieldInputInterpreter)inputInterpreter).updateSelection();
  }
 else {
    view.guiNode.detachAllChildren();
  }
  CommandManager.updateSelectables(spatialSelector.getCenterViewCoord(view.rootNode));
  guiController.update();
  if (!paused) {
    ModelManager.battlefield.armyManager.update(elapsedTime);
  }
}","@Override public void update(float elapsedTime){
  Point2D selStart=((BattlefieldInputInterpreter)inputInterpreter).clicInitialCoord;
  if (selStart != null) {
    Point2D p=Translator.toPoint2D(inputManager.getCursorPosition());
    view.drawSelectionArea(selStart,p);
    ((BattlefieldInputInterpreter)inputInterpreter).updateSelection();
  }
 else {
    view.guiNode.detachAllChildren();
  }
  CommandManager.updateSelectables(spatialSelector.getCenterViewCoord(view.rootNode));
  guiController.update();
  if (!paused) {
    ModelManager.battlefield.armyManager.update(elapsedTime);
  }
}"
3765,"public void updateSelection(){
  Point2D selectionEnd=Translator.toPoint2D(ctrl.inputManager.getCursorPosition());
  if (selectionEnd.equals(selectionStart) || selectionEnd.getDistance(selectionStart) < 10) {
    return;
  }
  AlignedBoundingBox rect=new AlignedBoundingBox(selectionStart,selectionEnd);
  List<Unit> inSelection=new ArrayList<>();
  for (  Unit u : ModelManager.battlefield.armyManager.getUnits()) {
    if (rect.contains(ctrl.spatialSelector.getScreenCoord(u.getPos()))) {
      inSelection.add(u);
    }
  }
  CommandManager.select(inSelection);
}","public void updateSelection(){
  Point2D coord=getMouseCoord();
  if (coord.equals(clicInitialCoord)) {
    return;
  }
  AlignedBoundingBox rect=new AlignedBoundingBox(clicInitialCoord,coord);
  List<Unit> inSelection=new ArrayList<>();
  for (  Unit u : ModelManager.battlefield.armyManager.getUnits()) {
    if (rect.contains(ctrl.spatialSelector.getScreenCoord(u.getPos()))) {
      inSelection.add(u);
    }
  }
  CommandManager.select(inSelection);
}"
3766,"@Override public void onAction(String name,boolean isPressed,float tpf){
  EventManager.post(new InputEvent(name));
  if (!isPressed) {
switch (name) {
case SWITCH_CTRL_1:
      ctrl.notifyListeners(""String_Node_Str"");
    break;
case SWITCH_CTRL_2:
  ctrl.notifyListeners(""String_Node_Str"");
break;
case SWITCH_CTRL_3:
ctrl.notifyListeners(""String_Node_Str"");
break;
case MULTIPLE_SELECTION:
CommandManager.setMultipleSelection(false);
break;
case SELECT:
if (System.currentTimeMillis() - dblclicTimer < DOUBLE_CLIC_DELAY && dblclicCoord.getDistance(getSpatialCoord()) < DOUBLE_CLIC_MAX_OFFSET) {
CommandManager.selectUnityInContext(ctrl.spatialSelector.getEntityId());
}
 else {
}
selectionStart=null;
dblclicTimer=System.currentTimeMillis();
dblclicCoord=getSpatialCoord();
break;
case ACTION:
CommandManager.act(ctrl.spatialSelector.getEntityId(),getSpatialCoord());
break;
case MOVE_ATTACK:
CommandManager.setMoveAttack();
break;
case HOLD:
CommandManager.orderHold();
break;
case PAUSE:
((BattlefieldController)ctrl).togglePause();
break;
}
}
 else {
switch (name) {
case MULTIPLE_SELECTION:
CommandManager.setMultipleSelection(true);
break;
case SELECT:
beginSelection();
break;
}
}
}","@Override public void onAction(String name,boolean isPressed,float tpf){
  EventManager.post(new InputEvent(name));
  if (!isPressed) {
switch (name) {
case SWITCH_CTRL_1:
      ctrl.notifyListeners(""String_Node_Str"");
    break;
case SWITCH_CTRL_2:
  ctrl.notifyListeners(""String_Node_Str"");
break;
case SWITCH_CTRL_3:
ctrl.notifyListeners(""String_Node_Str"");
break;
case MULTIPLE_SELECTION:
CommandManager.setMultipleSelection(false);
break;
case SELECT:
if (System.currentTimeMillis() - dblclicTimer < DOUBLE_CLIC_DELAY && dblclicCoord.getDistance(getSpatialCoord()) < DOUBLE_CLIC_MAX_OFFSET) {
CommandManager.selectUnityInContext(ctrl.spatialSelector.getEntityId());
}
 else {
if (!isDragging()) CommandManager.select(ctrl.spatialSelector.getEntityId(),getSpatialCoord());
}
clicInitialCoord=null;
dblclicTimer=System.currentTimeMillis();
dblclicCoord=getSpatialCoord();
break;
case ACTION:
CommandManager.act(ctrl.spatialSelector.getEntityId(),getSpatialCoord());
break;
case MOVE_ATTACK:
CommandManager.setMoveAttack();
break;
case HOLD:
CommandManager.orderHold();
break;
case PAUSE:
((BattlefieldController)ctrl).togglePause();
break;
}
}
 else {
switch (name) {
case MULTIPLE_SELECTION:
CommandManager.setMultipleSelection(true);
break;
case SELECT:
beginSelection();
break;
}
}
}"
3767,"private void beginSelection(){
  selectionStart=Translator.toPoint2D(ctrl.inputManager.getCursorPosition());
}","private void beginSelection(){
  clicInitialCoord=Translator.toPoint2D(ctrl.inputManager.getCursorPosition());
}"
3768,"@Override public void onAction(String name,boolean isPressed,float tpf){
  if (!isPressed) switch (name) {
case TOGGLE_PENCIL_SHAPE:
    toolManager.pencil.toggleShape();
  break;
case TOGGLE_PENCIL_MODE:
toolManager.pencil.toggleMode();
break;
case INC_SELECTOR_RADIUS:
toolManager.pencil.incRadius();
break;
case DEC_SELECTOR_RADIUS:
toolManager.pencil.decRadius();
break;
case SET_CLIFF_TOOL:
toolManager.setCliffTool();
break;
case SET_HEIGHT_TOOL:
toolManager.setHeightTool();
break;
case SET_ATLAS_TOOL:
toolManager.setAtlasTool();
break;
case TOGGLE_SET:
toolManager.toggleSet();
break;
case TOGGLE_GRID:
controller.view.editorRend.toggleGrid();
break;
case TOGGLE_LIGHT_COMP:
sunLight.toggleLight();
break;
case TOGGLE_SPEED:
sunLight.toggleSpeed();
break;
case RESET_COLOR:
sunLight.resetColor();
break;
case SAVE:
MapFactory.save(toolManager.map);
break;
case LOAD:
controller.model.map=MapFactory.load();
break;
}
}","@Override public void onAction(String name,boolean isPressed,float tpf){
  if (!isPressed) switch (name) {
case TOGGLE_PENCIL_SHAPE:
    toolManager.pencil.toggleShape();
  break;
case TOGGLE_PENCIL_MODE:
toolManager.pencil.toggleMode();
break;
case INC_SELECTOR_RADIUS:
toolManager.pencil.incRadius();
break;
case DEC_SELECTOR_RADIUS:
toolManager.pencil.decRadius();
break;
case SET_CLIFF_TOOL:
toolManager.setCliffTool();
break;
case SET_HEIGHT_TOOL:
toolManager.setHeightTool();
break;
case SET_ATLAS_TOOL:
toolManager.setAtlasTool();
break;
case TOGGLE_SET:
toolManager.toggleSet();
break;
case TOGGLE_GRID:
controller.view.editorRend.toggleGrid();
break;
case TOGGLE_LIGHT_COMP:
sunLight.toggleLight();
break;
case TOGGLE_SPEED:
sunLight.toggleSpeed();
break;
case RESET_COLOR:
sunLight.resetColor();
break;
case SAVE:
MapFactory.save(toolManager.map);
break;
}
}"
3769,"public Model(){
  lib=new BuilderLibrary();
  parser=new DefParser(lib);
  ArrayList<File> files=getFiles(CONFIG_PATH);
  while (!files.isEmpty()) {
    ArrayList<File> toAdd=new ArrayList<>();
    for (    File f : files)     if (f.isFile())     parser.addFile(f);
 else     if (f.isDirectory())     toAdd.addAll(getFiles(f.getAbsolutePath()));
    files.clear();
    files.addAll(toAdd);
  }
  parser.readFile();
  this.map=MapFactory.getNew(128,128,lib);
  sunLight=new SunLight();
  parcelManager=new ParcelManager(map);
  lib.map=map;
  armyManager=new ArmyManager();
  lib.am=armyManager;
  commander=new Commander(armyManager,map);
  editor=new MapToolManager(map,parcelManager,lib);
}","public Model(){
  lib=new BuilderLibrary();
  parser=new DefParser(lib);
  ArrayList<File> files=getFiles(CONFIG_PATH);
  while (!files.isEmpty()) {
    ArrayList<File> toAdd=new ArrayList<>();
    for (    File f : files)     if (f.isFile())     parser.addFile(f);
 else     if (f.isDirectory())     toAdd.addAll(getFiles(f.getAbsolutePath()));
    files.clear();
    files.addAll(toAdd);
  }
  parser.readFile();
  MapFactory factory=new MapFactory(lib);
  this.map=factory.getNew(128,128);
  sunLight=new SunLight();
  parcelManager=new ParcelManager(map);
  lib.map=map;
  armyManager=new ArmyManager();
  lib.am=armyManager;
  commander=new Commander(armyManager,map);
  editor=new MapToolManager(map,parcelManager,lib);
}"
3770,"public static Map getNew(int width,int height,BuilderLibrary lib){
  Map res=new Map(width,height);
  for (int y=0; y < height; y++)   for (int x=0; x < width; x++)   res.tiles.add(new Tile(x,y,res));
  for (int x=0; x < width; x++)   for (int y=0; y < height; y++) {
    Tile t=res.getTile(x,y);
    if (x > 0)     t.w=res.getTile(x - 1,y);
    if (x < width - 1)     t.e=res.getTile(x + 1,y);
    if (y > 0)     t.s=res.getTile(x,y - 1);
    if (y < height - 1)     t.n=res.getTile(x,y + 1);
  }
  res.style=lib.getMapStyleBuilder(""String_Node_Str"").build();
  return res;
}","public Map getNew(int width,int height){
  Map res=new Map(width,height);
  for (int y=0; y < height; y++)   for (int x=0; x < width; x++)   res.tiles.add(new Tile(x,y,res));
  linkTiles(res);
  res.mapStyleID=""String_Node_Str"";
  res.style=lib.getMapStyleBuilder(res.mapStyleID).build();
  return res;
}"
3771,"public CliffTool(MapToolManager manager,Pencil selector,BuilderLibrary lib){
  super(manager,selector);
  builder1=lib.getCliffShapeBuilder(""String_Node_Str"");
  builder2=lib.getCliffShapeBuilder(""String_Node_Str"");
  actualBuilder=builder2;
}","public CliffTool(MapToolManager manager,Pencil selector,BuilderLibrary lib){
  super(manager,selector);
  actualBuilder=manager.map.style.cliffShapes.get(0);
}"
3772,"@Override public void toggleSet(){
  if (actualBuilder == builder1) {
    actualBuilder=builder2;
  }
 else {
    actualBuilder=builder1;
  }
  LogUtil.logger.info(""String_Node_Str"" + actualBuilder.getID() + ""String_Node_Str"");
}","@Override public void toggleSet(){
  ArrayList<CliffShapeBuilder> builders=manager.map.style.cliffShapes;
  int index=builders.indexOf(actualBuilder) + 1;
  if (index == builders.size())   index=0;
  actualBuilder=builders.get(index);
  LogUtil.logger.info(""String_Node_Str"" + actualBuilder.getID() + ""String_Node_Str"");
}"
3773,"@VisibleForTesting static double normalizeLongitude(double d){
  double sign=Math.signum(d);
  double x=Math.abs(d) / 360;
  double x2=(x - Math.floor(x)) * 360;
  if (x2 >= 180)   x2-=360;
  return x2 * sign;
}","@VisibleForTesting static double normalizeLongitude(double d){
  if (d == -180.0)   return -180.0;
 else {
    double sign=Math.signum(d);
    double x=Math.abs(d) / 360;
    double x2=(x - Math.floor(x)) * 360;
    if (x2 >= 180)     x2-=360;
    return x2 * sign;
  }
}"
3774,"private static <T extends HasGeometry>List<ListPair<T>> getPairs(int minSize,List<T> list){
  List<ListPair<T>> pairs=new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);
  for (int i=minSize; i < list.size() - minSize; i++) {
    List<T> list1=list.subList(0,i);
    List<T> list2=list.subList(i,list.size());
    ListPair<T> pair=new ListPair<T>(list1,list2);
    pairs.add(pair);
  }
  return pairs;
}","@VisibleForTesting static <T extends HasGeometry>List<ListPair<T>> getPairs(int minSize,List<T> list){
  List<ListPair<T>> pairs=new ArrayList<ListPair<T>>(list.size() - 2 * minSize + 1);
  for (int i=minSize; i < list.size() - minSize + 1; i++) {
    List<T> list1=list.subList(0,i);
    List<T> list2=list.subList(i,list.size());
    ListPair<T> pair=new ListPair<T>(list1,list2);
    pairs.add(pair);
  }
  return pairs;
}"
3775,"@Override public NodeAndEntries<T> delete(Entry<T> entry){
  if (!entries.contains(entry)) {
    return new NodeAndEntries<T>(Optional.of(this),Collections.<Entry<T>>emptyList());
  }
 else {
    final List<Entry<T>> entries2=Util.remove(entries,entry);
    if (entries2.size() >= context.minChildren()) {
      Leaf<T> node=new Leaf<T>(entries2,context);
      return new NodeAndEntries<T>(of(node),Collections.<Entry<T>>emptyList());
    }
 else {
      return new NodeAndEntries<T>(Optional.<Node<T>>absent(),entries2);
    }
  }
}","@Override public NodeAndEntries<T> delete(Entry<T> entry,boolean all){
  if (!entries.contains(entry)) {
    return new NodeAndEntries<T>(Optional.of(this),Collections.<Entry<T>>emptyList(),0);
  }
 else {
    final List<Entry<T>> entries2=new ArrayList<Entry<T>>(entries);
    entries2.remove(entry);
    int numDeleted=1;
    while (all && entries2.remove(entry))     numDeleted+=1;
    if (entries2.size() >= context.minChildren()) {
      Leaf<T> node=new Leaf<T>(entries2,context);
      return new NodeAndEntries<T>(of(node),Collections.<Entry<T>>emptyList(),numDeleted);
    }
 else {
      return new NodeAndEntries<T>(Optional.<Node<T>>absent(),entries2,numDeleted);
    }
  }
}"
3776,NodeAndEntries<T> delete(Entry<T> entry);,"NodeAndEntries<T> delete(Entry<T> entry,boolean all);"
3777,"public NodeAndEntries(Optional<? extends Node<T>> node,List<Entry<T>> entries){
  this.node=node;
  this.entries=entries;
}","public NodeAndEntries(Optional<? extends Node<T>> node,List<Entry<T>> entries,int countDeleted){
  this.node=node;
  this.entries=entries;
  this.count=countDeleted;
}"
3778,"@Override public NodeAndEntries<T> delete(Entry<T> entry){
  List<Entry<T>> addTheseEntries=new ArrayList<Entry<T>>();
  List<Node<T>> removeTheseNodes=new ArrayList<Node<T>>();
  List<Node<T>> addTheseNodes=new ArrayList<Node<T>>();
  for (  final Node<T> child : children) {
    if (entry.geometry().intersects(child.geometry().mbr())) {
      final NodeAndEntries<T> result=child.delete(entry);
      if (result.node().isPresent())       addTheseNodes.add(result.node().get());
      removeTheseNodes.add(child);
      addTheseEntries.addAll(result.entries());
    }
  }
  if (removeTheseNodes.isEmpty())   return new NodeAndEntries<T>(of(this),Collections.<Entry<T>>emptyList());
 else {
    List<Node<T>> nodes=Util.remove(children,removeTheseNodes);
    nodes.addAll(addTheseNodes);
    if (nodes.size() == 0)     return new NodeAndEntries<T>(Optional.<Node<T>>absent(),addTheseEntries);
 else {
      NonLeaf<T> node=new NonLeaf<T>(nodes,context);
      return new NodeAndEntries<T>(of(node),addTheseEntries);
    }
  }
}","@Override public NodeAndEntries<T> delete(Entry<T> entry,boolean all){
  List<Entry<T>> addTheseEntries=new ArrayList<Entry<T>>();
  List<Node<T>> removeTheseNodes=new ArrayList<Node<T>>();
  List<Node<T>> addTheseNodes=new ArrayList<Node<T>>();
  int countDeleted=0;
  for (  final Node<T> child : children) {
    if (entry.geometry().intersects(child.geometry().mbr())) {
      final NodeAndEntries<T> result=child.delete(entry,all);
      if (result.node().isPresent()) {
        if (result.node().get() != child) {
          addTheseNodes.add(result.node().get());
          removeTheseNodes.add(child);
          addTheseEntries.addAll(result.entriesToAdd());
          countDeleted+=result.countDeleted();
          if (!all)           break;
        }
      }
 else {
        removeTheseNodes.add(child);
        addTheseEntries.addAll(result.entriesToAdd());
        countDeleted+=result.countDeleted();
      }
    }
  }
  if (removeTheseNodes.isEmpty())   return new NodeAndEntries<T>(of(this),Collections.<Entry<T>>emptyList(),0);
 else {
    List<Node<T>> nodes=Util.remove(children,removeTheseNodes);
    nodes.addAll(addTheseNodes);
    if (nodes.size() == 0)     return new NodeAndEntries<T>(Optional.<Node<T>>absent(),addTheseEntries,countDeleted);
 else {
      NonLeaf<T> node=new NonLeaf<T>(nodes,context);
      return new NodeAndEntries<T>(of(node),addTheseEntries,countDeleted);
    }
  }
}"
3779,"/** 
 * Delete one entry if it exists. If multiple copies of the entry are in the R-tree only one will be deleted. The entry must match on both value and geometry to be deleted.
 * @param entry the  {@link Entry} to be deleted
 * @return a new immutable R-tree without one instance of the specifiedentry
 */
public RTree<R> delete(Entry<R> entry){
  if (root.isPresent()) {
    NodeAndEntries<R> nodeAndEntries=root.get().delete(entry);
    if (nodeAndEntries.node().isPresent() && nodeAndEntries.node().get() == root.get())     return this;
 else     return new RTree<R>(nodeAndEntries.node(),size - 1 - nodeAndEntries.entries().size(),context).add(nodeAndEntries.entries());
  }
 else   return this;
}","public RTree<R> delete(Entry<R> entry){
  return delete(entry,false);
}"
3780,"@VisibleForTesting static <T extends HasGeometry>Pair<T> worstCombination(List<T> items){
  Optional<T> e1=absent();
  Optional<T> e2=absent();
{
    Optional<Double> maxArea=absent();
    for (    final T entry1 : items) {
      for (      final T entry2 : items) {
        if (entry1 != entry2) {
          final double area=entry1.geometry().mbr().add(entry2.geometry().mbr()).area();
          if (!maxArea.isPresent() || area > maxArea.get()) {
            e1=of(entry1);
            e2=of(entry2);
            maxArea=of(area);
          }
        }
      }
    }
  }
  return new Pair<T>(e1.get(),e2.get());
}","@VisibleForTesting static <T extends HasGeometry>Pair<T> worstCombination(List<T> items){
  Optional<T> e1=absent();
  Optional<T> e2=absent();
{
    Optional<Double> maxArea=absent();
    for (    final T entry1 : items) {
      for (      final T entry2 : items) {
        if (entry1 != entry2) {
          final double area=entry1.geometry().mbr().add(entry2.geometry().mbr()).area();
          if (!maxArea.isPresent() || area > maxArea.get()) {
            e1=of(entry1);
            e2=of(entry2);
            maxArea=of(area);
          }
        }
      }
    }
  }
  if (e1.isPresent())   return new Pair<T>(e1.get(),e2.get());
 else   return new Pair<T>(items.get(0),items.get(1));
}"
3781,"@Override public ImmutableStack<NodePosition<T>> search(Func1<? super Geometry,Boolean> condition,Subscriber<? super Entry<T>> subscriber,ImmutableStack<NodePosition<T>> stack,long request){
  Preconditions.checkArgument(!stack.isEmpty());
  NodePosition<T> np=stack.peek();
  Preconditions.checkArgument(this == np.node());
  Preconditions.checkArgument(np.position() <= children.size());
  if (request == 0)   return stack;
  if (np.position() == children.size()) {
    ImmutableStack<NodePosition<T>> stack2=stack.pop();
    if (stack2.isEmpty())     return stack2;
 else {
      NodePosition<T> previous=stack2.peek();
      return previous.node().search(condition,subscriber,stack2.pop().push(previous.nextPosition()),request);
    }
  }
 else {
    Node<T> child=children.get(np.position());
    return child.search(condition,subscriber,stack.push(new NodePosition<T>(child,0)),request);
  }
}","@Override public ImmutableStack<NodePosition<T>> search(Func1<? super Geometry,Boolean> condition,Subscriber<? super Entry<T>> subscriber,ImmutableStack<NodePosition<T>> stack,long request){
  Preconditions.checkArgument(!stack.isEmpty());
  NodePosition<T> np=stack.peek();
  Preconditions.checkArgument(this == np.node());
  Preconditions.checkArgument(np.position() <= children.size());
  if (request == 0)   return stack;
  if (np.position() == children.size()) {
    ImmutableStack<NodePosition<T>> stack2=stack.pop();
    if (stack2.isEmpty())     return stack2;
 else {
      NodePosition<T> previous=stack2.peek();
      return previous.node().search(condition,subscriber,stack2.pop().push(previous.nextPosition()),request);
    }
  }
 else {
    Node<T> child=children.get(np.position());
    if (condition.call(child.geometry()))     return child.search(condition,subscriber,stack.push(new NodePosition<T>(child,0)),request);
 else     return search(condition,subscriber,stack.pop().push(np.nextPosition()),request);
  }
}"
3782,"public void requestSome(long n){
  long previousCount=requested.getAndAdd(n);
  if (previousCount == 0) {
    while (true) {
      long r=requested.get();
      long numToEmit=r;
      stack=stack.peek().node().search(condition,subscriber,stack,numToEmit);
      if (stack.isEmpty() && !subscriber.isUnsubscribed()) {
        subscriber.onCompleted();
      }
 else       if (requested.addAndGet(-r) == 0)       return;
    }
  }
}","public void requestSome(long n){
  long previousCount=requested.getAndAdd(n);
  if (previousCount == 0) {
    while (true) {
      long r=requested.get();
      long numToEmit=r;
      stack=stack.peek().node().search(condition,subscriber,stack,numToEmit);
      if (stack.isEmpty()) {
        if (!subscriber.isUnsubscribed())         subscriber.onCompleted();
      }
 else       if (requested.addAndGet(-r) == 0)       return;
    }
  }
}"
3783,"public void test(){
  String serviceName=""String_Node_Str"";
  final String id1=discovery1.registerWithTTL(serviceName,7000,30).getId();
  final String id2=discovery2.registerWithTTL(serviceName,8000,30).getId();
  final String id3=discovery3.registerWithTTL(serviceName,9000,30).getId();
  for (int index=0; index < 10; index++) {
    Sys.sleep(100);
    discovery1.checkIn(id1,HealthStatus.PASS);
    discovery2.checkIn(id2,HealthStatus.PASS);
    discovery3.checkIn(id3,HealthStatus.PASS);
  }
  Sys.sleep(100);
  List<EndpointDefinition> endpointDefinitions=discovery1.loadServices(serviceName);
  assertEquals(3,endpointDefinitions.size());
  for (int index=0; index < 10; index++) {
    Sys.sleep(100);
    discovery1.checkIn(id1,HealthStatus.PASS);
    discovery2.checkIn(id2,HealthStatus.FAIL);
    discovery3.checkIn(id3,HealthStatus.PASS);
  }
  Sys.sleep(1000);
  endpointDefinitions=discovery1.loadServices(serviceName);
  assertEquals(2,endpointDefinitions.size());
}","public void test(){
  String serviceName=""String_Node_Str"";
  final String id1=discovery1.registerWithTTL(serviceName,""String_Node_Str"",7000,30).getId();
  final String id2=discovery2.registerWithTTL(serviceName,""String_Node_Str"",8000,30).getId();
  final String id3=discovery3.registerWithTTL(serviceName,""String_Node_Str"",9000,30).getId();
  for (int index=0; index < 10; index++) {
    Sys.sleep(100);
    discovery1.checkIn(id1,HealthStatus.PASS);
    discovery2.checkIn(id2,HealthStatus.PASS);
    discovery3.checkIn(id3,HealthStatus.PASS);
  }
  Sys.sleep(100);
  List<EndpointDefinition> endpointDefinitions=discovery1.loadServices(serviceName);
  assertEquals(3,endpointDefinitions.size());
  for (int index=0; index < 10; index++) {
    Sys.sleep(100);
    discovery1.checkIn(id1,HealthStatus.PASS);
    discovery2.checkIn(id2,HealthStatus.FAIL);
    discovery3.checkIn(id3,HealthStatus.PASS);
  }
  Sys.sleep(1000);
  endpointDefinitions=discovery1.loadServices(serviceName);
  assertEquals(2,endpointDefinitions.size());
}"
3784,"/** 
 * Register with the service discovery system and specify a TTL so that if the service does not send a checkIn that it is marked down. TTL is time to live.
 * @param serviceName       service name
 * @param host              host
 * @param port              port
 * @param timeToLiveSeconds ttl
 * @return EndpointDefinition
 */
default EndpointDefinition registerWithTTL(final String serviceName,final String host,final int port,final int timeToLiveSeconds){
  return new EndpointDefinition(HealthStatus.PASS,serviceName + ""String_Node_Str"" + uniqueString(port),serviceName,null,port,timeToLiveSeconds);
}","/** 
 * Register with the service discovery system and specify a TTL so that if the service does not send a checkIn that it is marked down. TTL is time to live.
 * @param serviceName       service name
 * @param host              host
 * @param port              port
 * @param timeToLiveSeconds ttl
 * @return EndpointDefinition
 */
default EndpointDefinition registerWithTTL(final String serviceName,final String host,final int port,final int timeToLiveSeconds){
  return new EndpointDefinition(HealthStatus.PASS,serviceName + ""String_Node_Str"" + uniqueString(port),serviceName,host,port,timeToLiveSeconds);
}"
3785,"public EndpointDefinition registerWithIdAndTimeToLive(final String serviceName,final String serviceId,final int port,final int timeToLiveSeconds){
  if (trace) {
    logger.trace(""String_Node_Str"" + serviceName + ""String_Node_Str""+ port);
  }
  watch(serviceName);
  EndpointDefinition endpointDefinition=new EndpointDefinition(HealthStatus.PASS,serviceId,serviceName,null,port,timeToLiveSeconds);
  return doRegister(endpointDefinition);
}","@Override public EndpointDefinition registerWithIdAndTimeToLive(final String serviceName,final String serviceId,String host,final int port,final int timeToLiveSeconds){
  if (trace) {
    logger.trace(""String_Node_Str"" + serviceName + ""String_Node_Str""+ port);
  }
  watch(serviceName);
  EndpointDefinition endpointDefinition=new EndpointDefinition(HealthStatus.PASS,serviceId,serviceName,host,port,timeToLiveSeconds);
  return doRegister(endpointDefinition);
}"
3786,"public EndpointDefinition registerWithTTL(final String serviceName,final int port,final int timeToLiveSeconds){
  if (trace) {
    logger.trace(""String_Node_Str"" + serviceName + ""String_Node_Str""+ port);
  }
  watch(serviceName);
  EndpointDefinition endpointDefinition=new EndpointDefinition(HealthStatus.PASS,serviceName + ""String_Node_Str"" + ServiceDiscovery.uniqueString(port),serviceName,null,port,timeToLiveSeconds);
  return doRegister(endpointDefinition);
}","@Override public EndpointDefinition registerWithTTL(final String serviceName,final String host,final int port,final int timeToLiveSeconds){
  if (trace) {
    logger.trace(""String_Node_Str"" + serviceName + ""String_Node_Str""+ port);
  }
  watch(serviceName);
  EndpointDefinition endpointDefinition=new EndpointDefinition(HealthStatus.PASS,serviceName + ""String_Node_Str"" + ServiceDiscovery.uniqueString(port),serviceName,host,port,timeToLiveSeconds);
  return doRegister(endpointDefinition);
}"
3787,"private void handleIncomingMessage(final String address,final Message<String> message){
  final Map<String,Object> map=jsonMapper.fromJson(message.body(),Map.class);
  final Object method=map.get(""String_Node_Str"");
  final ValueContainer args=(ValueContainer)map.get(""String_Node_Str"");
  final Object body=args.toValue();
  final CallbackBuilder callbackBuilder=CallbackBuilder.callbackBuilder();
  callbackBuilder.setOnError(throwable -> {
    logger.error(""String_Node_Str"" + address,throwable);
    message.fail(500,throwable.getMessage());
  }
);
  callbackBuilder.setCallback(returnedValue -> {
    message.reply(jsonMapper.toJson(returnedValue));
  }
);
  callbackBuilder.setOnTimeout(() -> {
    logger.error(""String_Node_Str"" + address + ""String_Node_Str""+ method);
    message.fail(408,""String_Node_Str"" + address + ""String_Node_Str""+ method);
  }
);
  final MethodCall<Object> methodCall=MethodCallBuilder.methodCallBuilder().setAddress(address).setBody(body).setTimestamp(this.timer.time()).setName(method.toString()).setId(messageId++).setCallback(callbackBuilder.build()).build();
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",methodCall.name(),message.body());
  }
  if (methodCallPredicate.test(methodCall)) {
    this.methodCallSendQueue.send(methodCall);
  }
}","private void handleIncomingMessage(final String address,final Message<String> message){
  final Map map=jsonMapper.fromJson(message.body(),Map.class);
  final Object method=map.get(""String_Node_Str"");
  final ValueContainer args=(ValueContainer)map.get(""String_Node_Str"");
  final Object body=args != null ? args.toValue() : Collections.emptyList();
  final CallbackBuilder callbackBuilder=CallbackBuilder.callbackBuilder();
  callbackBuilder.setOnError(throwable -> {
    logger.error(""String_Node_Str"" + address,throwable);
    message.fail(500,throwable.getMessage());
  }
);
  callbackBuilder.setCallback(returnedValue -> message.reply(jsonMapper.toJson(returnedValue)));
  callbackBuilder.setOnTimeout(() -> {
    logger.error(""String_Node_Str"" + address + ""String_Node_Str""+ method);
    message.fail(408,""String_Node_Str"" + address + ""String_Node_Str""+ method);
  }
);
  final MethodCall<Object> methodCall=MethodCallBuilder.methodCallBuilder().setAddress(address).setBody(body).setTimestamp(this.timer.time()).setName(method.toString()).setId(messageId++).setCallback(callbackBuilder.build()).build();
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"",methodCall.name(),message.body());
  }
  if (methodCallPredicate.test(methodCall)) {
    this.methodCallSendQueue.send(methodCall);
  }
}"
3788,"protected final boolean sendLocalQueue(){
  if (index > 0) {
    boolean ableToSend;
    if (index == queueLocal.length) {
      ableToSend=sendArray(queueLocal);
    }
 else {
      final Object[] copy=fastObjectArraySlice(queueLocal,0,index);
      ableToSend=sendArray(copy);
    }
    index=0;
    queueLocal=new Object[batchSize];
    return ableToSend;
  }
 else {
    return true;
  }
}","protected final boolean sendLocalQueue(){
  if (index > 0) {
    boolean ableToSend;
    final Object[] copy=fastObjectArraySlice(queueLocal,0,index);
    ableToSend=sendArray(copy);
    System.arraycopy(blankLocal,0,queueLocal,0,index);
    index=0;
    return ableToSend;
  }
 else {
    return true;
  }
}"
3789,"public AbstractBasicSendQueue(final BlockingQueue<Object> queue,Queue<T> owner,final int batchSize,final String name,final Logger logger){
  this.queue=queue;
  this.owner=owner;
  this.batchSize=batchSize;
  this.name=name;
  this.queueLocal=new Object[batchSize];
  this.logger=logger;
}","public AbstractBasicSendQueue(final BlockingQueue<Object> queue,Queue<T> owner,final int batchSize,final String name,final Logger logger){
  this.queue=queue;
  this.owner=owner;
  this.batchSize=batchSize;
  this.name=name;
  this.queueLocal=new Object[batchSize];
  this.blankLocal=new Object[batchSize];
  this.logger=logger;
}"
3790,"@Test public void callingActualServiceWithReturnDifferentInterfaces(){
@RequestMapping(""String_Node_Str"") class MyServiceClass implements SomeInterface {
    @Override public void method1(){
    }
    @Override public void method2(    String hi,    int amount){
    }
    @Override public String method3(    String hi,    int amount){
      return ""String_Node_Str"" + hi + ""String_Node_Str""+ amount;
    }
  }
  SomeInterface myService=new MyServiceClass();
  final ServiceBundle bundle=new ServiceBundleBuilder().setAddress(""String_Node_Str"").buildAndStart();
  bundle.addService(myService);
  bundle.startReturnHandlerProcessor();
  final MyServiceInterfaceForClient myServiceProxy=bundle.createLocalProxy(MyServiceInterfaceForClient.class,""String_Node_Str"");
  ok=false;
  Callback<String> returnHandler=new Callback<String>(){
    @Override public void accept(    String returnValue){
      puts(""String_Node_Str"",returnValue);
      ok=""String_Node_Str"".equals(returnValue);
    }
  }
;
  myServiceProxy.method3(returnHandler,""String_Node_Str"",5);
  bundle.flush();
  Sys.sleep(1000);
  ok=ok || die();
}","@Test public void callingActualServiceWithReturnDifferentInterfaces(){
@RequestMapping(""String_Node_Str"") class MyServiceClass implements SomeInterface {
    @Override public void method1(){
    }
    @Override public void method2(    String hi,    int amount){
    }
    @Override public String method3(    String hi,    int amount){
      return ""String_Node_Str"" + hi + ""String_Node_Str""+ amount;
    }
  }
  SomeInterface myService=new MyServiceClass();
  final ServiceBundle bundle=new ServiceBundleBuilder().setAddress(""String_Node_Str"").buildAndStart();
  bundle.addService(myService);
  bundle.startReturnHandlerProcessor();
  final MyServiceInterfaceForClient myServiceProxy=bundle.createLocalProxy(MyServiceInterfaceForClient.class,""String_Node_Str"");
  AtomicBoolean called=new AtomicBoolean();
  Callback<String> returnHandler=returnValue -> {
    puts(""String_Node_Str"",returnValue);
    called.set(""String_Node_Str"".equals(returnValue));
  }
;
  myServiceProxy.method3(returnHandler,""String_Node_Str"",5);
  ServiceProxyUtils.flushServiceProxy(myServiceProxy);
  Sys.sleep(1000);
  assertTrue(called.get());
}"
3791,"public static void main(final String... args){
  final ManagedServiceBuilder managedServiceBuilder=managedServiceBuilder();
  managedServiceBuilder.getHttpServerBuilder().addResponseDecorator(new HttpResponseDecorator(){
    @Override public boolean decorateTextResponse(    HttpTextResponse[] responseHolder,    String requestPath,    int code,    String contentType,    String payload,    MultiMap<String,String> responseHeaders,    MultiMap<String,String> requestHeaders,    MultiMap<String,String> requestParams){
      final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
      if (responseHeaders != null && !responseHeaders.isEmpty()) {
        responseBuilder.setHeaders(responseHeaders);
      }
      responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
      responseHolder[0]=(HttpTextResponse)responseBuilder.build();
      return true;
    }
    @Override public boolean decorateBinaryResponse(    HttpBinaryResponse[] responseHolder,    String requestPath,    int code,    String contentType,    byte[] payload,    MultiMap<String,String> responseHeaders,    MultiMap<String,String> requestHeaders,    MultiMap<String,String> requestParams){
      final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
      if (responseHeaders != null && !responseHeaders.isEmpty()) {
        responseBuilder.setHeaders(responseHeaders);
      }
      responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
      responseHolder[0]=(HttpBinaryResponse)responseBuilder.build();
      return true;
    }
  }
);
  managedServiceBuilder.setRootURI(""String_Node_Str"").addEndpointService(new NoCacheService()).startApplication();
}","public static void main(final String... args){
  final ManagedServiceBuilder managedServiceBuilder=managedServiceBuilder();
  managedServiceBuilder.getHttpServerBuilder().addResponseDecorator(new HttpResponseDecorator(){
    @Override public boolean decorateTextResponse(    HttpTextResponseHolder responseHolder,    String requestPath,    int code,    String contentType,    String payload,    MultiMap<String,String> responseHeaders,    MultiMap<String,String> requestHeaders,    MultiMap<String,String> requestParams){
      final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
      if (responseHeaders != null && !responseHeaders.isEmpty()) {
        responseBuilder.setHeaders(responseHeaders);
      }
      responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
      responseHolder.setHttpTextResponse((HttpTextResponse)responseBuilder.build());
      return true;
    }
    @Override public boolean decorateBinaryResponse(    HttpBinaryResponseHolder responseHolder,    String requestPath,    int code,    String contentType,    byte[] payload,    MultiMap<String,String> responseHeaders,    MultiMap<String,String> requestHeaders,    MultiMap<String,String> requestParams){
      final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
      if (responseHeaders != null && !responseHeaders.isEmpty()) {
        responseBuilder.setHeaders(responseHeaders);
      }
      responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
      responseHolder.setHttpBinaryResponse((HttpBinaryResponse)responseBuilder.build());
      return true;
    }
  }
);
  managedServiceBuilder.setRootURI(""String_Node_Str"").addEndpointService(new NoCacheService()).startApplication();
}"
3792,"@Override public boolean decorateTextResponse(HttpTextResponse[] responseHolder,String requestPath,int code,String contentType,String payload,MultiMap<String,String> responseHeaders,MultiMap<String,String> requestHeaders,MultiMap<String,String> requestParams){
  final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
  if (responseHeaders != null && !responseHeaders.isEmpty()) {
    responseBuilder.setHeaders(responseHeaders);
  }
  responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
  responseHolder[0]=(HttpTextResponse)responseBuilder.build();
  return true;
}","@Override public boolean decorateTextResponse(HttpTextResponseHolder responseHolder,String requestPath,int code,String contentType,String payload,MultiMap<String,String> responseHeaders,MultiMap<String,String> requestHeaders,MultiMap<String,String> requestParams){
  final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
  if (responseHeaders != null && !responseHeaders.isEmpty()) {
    responseBuilder.setHeaders(responseHeaders);
  }
  responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
  responseHolder.setHttpTextResponse((HttpTextResponse)responseBuilder.build());
  return true;
}"
3793,"@Override public boolean decorateBinaryResponse(HttpBinaryResponse[] responseHolder,String requestPath,int code,String contentType,byte[] payload,MultiMap<String,String> responseHeaders,MultiMap<String,String> requestHeaders,MultiMap<String,String> requestParams){
  final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
  if (responseHeaders != null && !responseHeaders.isEmpty()) {
    responseBuilder.setHeaders(responseHeaders);
  }
  responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
  responseHolder[0]=(HttpBinaryResponse)responseBuilder.build();
  return true;
}","@Override public boolean decorateBinaryResponse(HttpBinaryResponseHolder responseHolder,String requestPath,int code,String contentType,byte[] payload,MultiMap<String,String> responseHeaders,MultiMap<String,String> requestHeaders,MultiMap<String,String> requestParams){
  final HttpResponseBuilder responseBuilder=HttpResponseBuilder.httpResponseBuilder().setCode(code).setContentType(contentType).setBody(payload);
  if (responseHeaders != null && !responseHeaders.isEmpty()) {
    responseBuilder.setHeaders(responseHeaders);
  }
  responseBuilder.addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"").addHeader(""String_Node_Str"",""String_Node_Str"");
  responseHolder.setHttpBinaryResponse((HttpBinaryResponse)responseBuilder.build());
  return true;
}"
3794,"private Response<Object> invokeByName(MethodCall<Object> methodCall){
  final MethodAccess method=classMeta.method(methodCall.name());
  if (method != null) {
    return mapArgsAsyncHandlersAndInvoke(methodCall,method);
  }
 else {
    if (methodCall.name().equals(""String_Node_Str"")) {
      puts(""String_Node_Str"",methodCall.objectName(),methodCall.name(),methodCall.address());
      return ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),sputs(""String_Node_Str"",methodCall.objectName(),methodCall.name(),methodCall.address()),methodCall,false);
    }
 else {
      return ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),new Exception(""String_Node_Str""),methodCall,true);
    }
  }
}","private Response<Object> invokeByName(MethodCall<Object> methodCall){
  final MethodAccess method=classMeta.method(methodCall.name());
  if (method != null) {
    return mapArgsAsyncHandlersAndInvoke(methodCall,method);
  }
 else {
    if (methodCall.name().equals(""String_Node_Str"")) {
      puts(""String_Node_Str"",methodCall.objectName(),methodCall.name(),methodCall.address());
      return ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),sputs(""String_Node_Str"",methodCall.objectName(),methodCall.name(),methodCall.address()),methodCall,false);
    }
 else {
      return ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),new Exception(""String_Node_Str"" + methodCall.name()),methodCall,true);
    }
  }
}"
3795,"/** 
 * Builds a service.
 * @return new service queue
 */
public ServiceQueue build(){
  if (debug)   logger.debug(""String_Node_Str"");
  ServiceQueueSizer serviceQueueSizer=null;
  if (statsConfig != null) {
    serviceQueueSizer=new ServiceQueueSizer();
    this.addQueueCallbackHandler(new ServiceStatsListener(statsConfig.serviceName,statsConfig.statsCollector,getTimer(),statsConfig.flushTimeSeconds,TimeUnit.SECONDS,statsConfig.sampleEvery,serviceQueueSizer));
  }
  ServiceQueue serviceQueue=new ServiceQueueImpl(this.getRootAddress(),this.getServiceAddress(),this.getServiceObject(),this.getRequestQueueBuilder(),this.getResponseQueueBuilder(),this.getServiceMethodHandler(),this.getResponseQueue(),this.isAsyncResponse(),this.isHandleCallbacks(),this.getSystemManager(),this.getBeforeMethodCall(),this.getBeforeMethodCallAfterTransform(),this.getAfterMethodCall(),this.getAfterMethodCallAfterTransform(),buildQueueCallBackHandler(),getCallbackManager(),getBeforeMethodSent(),getEventManager());
  if (serviceQueueSizer != null) {
    serviceQueueSizer.setServiceQueue(serviceQueue);
  }
  if (qBitSystemManager != null) {
    qBitSystemManager.registerService(serviceQueue);
  }
  return serviceQueue;
}","/** 
 * Builds a service.
 * @return new service queue
 */
public ServiceQueue build(){
  if (debug)   logger.debug(""String_Node_Str"");
  ServiceQueueSizer serviceQueueSizer=null;
  if (statsConfig != null) {
    serviceQueueSizer=new ServiceQueueSizer();
    this.addQueueCallbackHandler(new ServiceStatsListener(statsConfig.serviceName,statsConfig.statsCollector,getTimer(),statsConfig.flushTimeSeconds,TimeUnit.SECONDS,statsConfig.sampleEvery,serviceQueueSizer));
  }
  ServiceQueue serviceQueue=new ServiceQueueImpl(this.getRootAddress(),this.getServiceAddress(),this.getServiceObject(),this.getRequestQueueBuilder(),this.getResponseQueueBuilder(),this.getServiceMethodHandler(),this.getResponseQueue(),this.isAsyncResponse(),this.isHandleCallbacks(),this.getSystemManager(),this.getBeforeMethodCall(),this.getBeforeMethodCallAfterTransform(),this.getAfterMethodCall(),this.getAfterMethodCallAfterTransform(),buildQueueCallBackHandler(),getCallbackManager(),getBeforeMethodSent(),getEventManager(),isJoinEventManager());
  if (serviceQueueSizer != null) {
    serviceQueueSizer.setServiceQueue(serviceQueue);
  }
  if (qBitSystemManager != null) {
    qBitSystemManager.registerService(serviceQueue);
  }
  return serviceQueue;
}"
3796,"@Override public void stop(){
  started.set(false);
  try {
    if (requestQueue != null)     requestQueue.stop();
  }
 catch (  Exception ex) {
    if (debug)     logger.debug(""String_Node_Str"",ex);
  }
  try {
    if (responseQueue != null)     responseQueue.stop();
  }
 catch (  Exception ex) {
    if (debug)     logger.debug(""String_Node_Str"",ex);
  }
  if (systemManager != null)   this.systemManager.serviceShutDown();
  eventManager.ifPresent(em -> em.leaveEventBus(BaseServiceQueueImpl.this));
}","@Override public void stop(){
  started.set(false);
  try {
    if (requestQueue != null)     requestQueue.stop();
  }
 catch (  Exception ex) {
    if (debug)     logger.debug(""String_Node_Str"",ex);
  }
  try {
    if (responseQueue != null)     responseQueue.stop();
  }
 catch (  Exception ex) {
    if (debug)     logger.debug(""String_Node_Str"",ex);
  }
  if (systemManager != null) {
    this.systemManager.serviceShutDown();
    this.systemManager.unregisterService(this);
  }
  eventManager.ifPresent(em -> em.leaveEventBus(BaseServiceQueueImpl.this));
}"
3797,"public BaseServiceQueueImpl(final String rootAddress,final String serviceAddress,final Object service,final QueueBuilder requestQueueBuilder,final QueueBuilder responseQueueBuilder,final ServiceMethodHandler serviceMethodHandler,final Queue<Response<Object>> responseQueue,final boolean async,final boolean handleCallbacks,final QBitSystemManager systemManager,final BeforeMethodCall beforeMethodCall,final BeforeMethodCall beforeMethodCallAfterTransform,final AfterMethodCall afterMethodCall,final AfterMethodCall afterMethodCallAfterTransform,final QueueCallBackHandler queueCallBackHandler,final CallbackManager callbackManager,final BeforeMethodSent beforeMethodSent,final EventManager eventManager){
  this.eventManager=Optional.ofNullable(eventManager);
  this.beforeMethodSent=beforeMethodSent;
  this.beforeMethodCall=beforeMethodCall;
  this.beforeMethodCallAfterTransform=beforeMethodCallAfterTransform;
  this.afterMethodCall=afterMethodCall;
  this.afterMethodCallAfterTransform=afterMethodCallAfterTransform;
  this.callbackManager=callbackManager;
  if (queueCallBackHandler == null) {
    this.queueCallBackHandler=new QueueCallBackHandler(){
      @Override public void queueLimit(){
      }
      @Override public void queueEmpty(){
      }
    }
;
  }
 else {
    this.queueCallBackHandler=queueCallBackHandler;
  }
  if (requestQueueBuilder == null) {
    this.requestQueueBuilder=new QueueBuilder();
  }
 else {
    this.requestQueueBuilder=BeanUtils.copy(requestQueueBuilder);
  }
  if (responseQueueBuilder == null) {
    this.responseQueueBuilder=new QueueBuilder();
  }
 else {
    this.responseQueueBuilder=BeanUtils.copy(responseQueueBuilder);
  }
  if (responseQueue == null) {
    logger.info(""String_Node_Str"");
    this.responseQueue=this.responseQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  }
 else {
    this.responseQueue=responseQueue;
  }
  this.responseSendQueue=this.responseQueue.sendQueueWithAutoFlush(100,TimeUnit.MILLISECONDS);
  this.service=service;
  this.serviceMethodHandler=serviceMethodHandler;
  this.serviceMethodHandler.init(service,rootAddress,serviceAddress,responseSendQueue);
  this.eventQueue=this.requestQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  this.handleCallbacks=handleCallbacks;
  this.requestQueue=initRequestQueue(serviceMethodHandler,async);
  this.systemManager=systemManager;
  this.factory=factory();
  this.eventManager.ifPresent(em -> {
    em.joinService(BaseServiceQueueImpl.this);
  }
);
}","public BaseServiceQueueImpl(final String rootAddress,final String serviceAddress,final Object service,final QueueBuilder requestQueueBuilder,final QueueBuilder responseQueueBuilder,final ServiceMethodHandler serviceMethodHandler,final Queue<Response<Object>> responseQueue,final boolean async,final boolean handleCallbacks,final QBitSystemManager systemManager,final BeforeMethodCall beforeMethodCall,final BeforeMethodCall beforeMethodCallAfterTransform,final AfterMethodCall afterMethodCall,final AfterMethodCall afterMethodCallAfterTransform,final QueueCallBackHandler queueCallBackHandler,final CallbackManager callbackManager,final BeforeMethodSent beforeMethodSent,final EventManager eventManager,final boolean joinEventManager){
  this.eventManager=Optional.ofNullable(eventManager);
  this.joinEventManager=joinEventManager;
  this.beforeMethodSent=beforeMethodSent;
  this.beforeMethodCall=beforeMethodCall;
  this.beforeMethodCallAfterTransform=beforeMethodCallAfterTransform;
  this.afterMethodCall=afterMethodCall;
  this.afterMethodCallAfterTransform=afterMethodCallAfterTransform;
  this.callbackManager=callbackManager;
  if (queueCallBackHandler == null) {
    this.queueCallBackHandler=new QueueCallBackHandler(){
      @Override public void queueLimit(){
      }
      @Override public void queueEmpty(){
      }
    }
;
  }
 else {
    this.queueCallBackHandler=queueCallBackHandler;
  }
  if (requestQueueBuilder == null) {
    this.requestQueueBuilder=new QueueBuilder();
  }
 else {
    this.requestQueueBuilder=BeanUtils.copy(requestQueueBuilder);
  }
  if (responseQueueBuilder == null) {
    this.responseQueueBuilder=new QueueBuilder();
  }
 else {
    this.responseQueueBuilder=BeanUtils.copy(responseQueueBuilder);
  }
  if (responseQueue == null) {
    logger.info(""String_Node_Str"");
    this.responseQueue=this.responseQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  }
 else {
    this.responseQueue=responseQueue;
  }
  this.responseSendQueue=this.responseQueue.sendQueueWithAutoFlush(100,TimeUnit.MILLISECONDS);
  this.service=service;
  this.serviceMethodHandler=serviceMethodHandler;
  this.serviceMethodHandler.init(service,rootAddress,serviceAddress,responseSendQueue);
  this.eventQueue=this.requestQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  this.handleCallbacks=handleCallbacks;
  this.requestQueue=initRequestQueue(serviceMethodHandler,async);
  this.systemManager=systemManager;
  this.factory=factory();
  this.eventManager.ifPresent(em -> {
    em.joinService(BaseServiceQueueImpl.this);
  }
);
}"
3798,"/** 
 * This method is where all of the action is.
 * @param methodCall           methodCall
 * @param serviceMethodHandler handler
 */
private boolean doHandleMethodCall(MethodCall<Object> methodCall,final ServiceMethodHandler serviceMethodHandler){
  if (debug) {
    logger.debug(""String_Node_Str"" + methodCall);
  }
  if (callbackManager != null) {
    callbackManager.registerCallbacks(methodCall);
  }
  final boolean continueFlag[]=new boolean[1];
  methodCall=beforeMethodProcessing(methodCall,continueFlag);
  if (continueFlag[0]) {
    if (debug)     logger.debug(""String_Node_Str"");
    return false;
  }
  Response<Object> response=serviceMethodHandler.receiveMethodCall(methodCall);
  if (response != ServiceConstants.VOID) {
    if (!afterMethodCall.after(methodCall,response)) {
      return false;
    }
    response=responseObjectTransformer.transform(response);
    if (!afterMethodCallAfterTransform.after(methodCall,response)) {
      return false;
    }
    if (!responseSendQueue.send(response)) {
      logger.error(""String_Node_Str"",response,methodCall.name(),methodCall.objectName());
    }
  }
  return false;
}","/** 
 * This method is where all of the action is.
 * @param methodCall           methodCall
 * @param serviceMethodHandler handler
 */
private boolean doHandleMethodCall(MethodCall<Object> methodCall,final ServiceMethodHandler serviceMethodHandler){
  if (debug) {
    logger.debug(""String_Node_Str"" + methodCall);
  }
  if (callbackManager != null) {
    callbackManager.registerCallbacks(methodCall);
  }
  final boolean continueFlag[]=new boolean[1];
  methodCall=beforeMethodProcessing(methodCall,continueFlag);
  if (continueFlag[0]) {
    if (debug)     logger.debug(""String_Node_Str"");
    return false;
  }
  Response<Object> response=serviceMethodHandler.receiveMethodCall(methodCall);
  if (response != ServiceConstants.VOID) {
    if (!afterMethodCall.after(methodCall,response)) {
      return false;
    }
    response=responseObjectTransformer.transform(response);
    if (!afterMethodCallAfterTransform.after(methodCall,response)) {
      return false;
    }
    if (true) {
      if (response.body() instanceof Throwable) {
        logger.error(""String_Node_Str"",((Throwable)response.body()));
      }
    }
    if (!responseSendQueue.send(response)) {
      logger.error(""String_Node_Str"",response,methodCall.name(),methodCall.objectName());
    }
  }
  return false;
}"
3799,"public ServiceQueue startServiceQueue(){
  start(serviceMethodHandler,true);
  return this;
}","public ServiceQueue startServiceQueue(){
  start(serviceMethodHandler,joinEventManager);
  return this;
}"
3800,"public ServiceQueueImpl(final String rootAddress,final String serviceAddress,final Object service,final QueueBuilder requestQueueBuilder,final QueueBuilder responseQueueBuilder,final ServiceMethodHandler serviceMethodHandler,final Queue<Response<Object>> responseQueue,final boolean async,final boolean handleCallbacks,final QBitSystemManager systemManager,final BeforeMethodCall beforeMethodCall,final BeforeMethodCall beforeMethodCallAfterTransform,final AfterMethodCall afterMethodCall,final AfterMethodCall afterMethodCallAfterTransform,final QueueCallBackHandler handler,final CallbackManager callbackManager,final BeforeMethodSent beforeMethodSent,final EventManager eventManager){
  super(rootAddress,serviceAddress,service,requestQueueBuilder,responseQueueBuilder,serviceMethodHandler,responseQueue,async,handleCallbacks,systemManager,beforeMethodCall,beforeMethodCallAfterTransform,afterMethodCall,afterMethodCallAfterTransform,handler,callbackManager,beforeMethodSent,eventManager);
}","public ServiceQueueImpl(final String rootAddress,final String serviceAddress,final Object service,final QueueBuilder requestQueueBuilder,final QueueBuilder responseQueueBuilder,final ServiceMethodHandler serviceMethodHandler,final Queue<Response<Object>> responseQueue,final boolean async,final boolean handleCallbacks,final QBitSystemManager systemManager,final BeforeMethodCall beforeMethodCall,final BeforeMethodCall beforeMethodCallAfterTransform,final AfterMethodCall afterMethodCall,final AfterMethodCall afterMethodCallAfterTransform,final QueueCallBackHandler handler,final CallbackManager callbackManager,final BeforeMethodSent beforeMethodSent,final EventManager eventManager,final boolean joinEventManager){
  super(rootAddress,serviceAddress,service,requestQueueBuilder,responseQueueBuilder,serviceMethodHandler,responseQueue,async,handleCallbacks,systemManager,beforeMethodCall,beforeMethodCallAfterTransform,afterMethodCall,afterMethodCallAfterTransform,handler,callbackManager,beforeMethodSent,eventManager,joinEventManager);
}"
3801,"@Before public void setup(){
  systemManager=new QBitSystemManager();
  eventManager=EventManagerBuilder.eventManagerBuilder().setName(""String_Node_Str"").build();
  serviceBuilder=ServiceBuilder.serviceBuilder().setEventManager(eventManager).setSystemManager(systemManager);
  eventServiceQueue=serviceBuilder.setServiceObject(eventManager).buildAndStartAll();
  serviceB=new ServiceB();
  serviceBuilder.setServiceObject(serviceB).buildAndStartAll();
  serviceA=new ServiceA(eventServiceQueue.createProxy(EventManager.class));
  final ServiceQueue serviceAQueue=serviceBuilder.setServiceObject(serviceA).buildAndStartAll();
  serviceAQueueProxy=serviceAQueue.createProxy(ServiceAInterface.class);
}","@Before public void setup(){
  systemManager=new QBitSystemManager();
  eventManager=EventManagerBuilder.eventManagerBuilder().setName(""String_Node_Str"").build();
  eventServiceQueue=ServiceBuilder.serviceBuilder().setServiceObject(eventManager).buildAndStartAll();
  serviceB=new ServiceB();
  serviceA=new ServiceA(eventServiceQueue.createProxy(EventManager.class));
  serviceBuilder=ServiceBuilder.serviceBuilder().setServiceObject(serviceA).setJoinEventManager(false).setEventManager(eventManager).setSystemManager(systemManager);
  final ServiceQueue serviceAQueue=serviceBuilder.buildAndStartAll();
  ServiceBuilder.serviceBuilder().setServiceObject(serviceB).setJoinEventManager(false).setEventManager(eventManager).setSystemManager(systemManager).buildAndStartAll();
  serviceAQueueProxy=serviceAQueue.createProxy(ServiceAInterface.class);
}"
3802,"@Before public void setup(){
  systemManager=new QBitSystemManager();
  eventManager=EventManagerBuilder.eventManagerBuilder().setName(""String_Node_Str"").build();
  serviceBuilder=ServiceBuilder.serviceBuilder().setSystemManager(systemManager);
  eventServiceQueue=serviceBuilder.setServiceObject(eventManager).buildAndStartAll();
  serviceBuilder.setEventManager(eventManager);
  serviceB=new ServiceB();
  serviceBuilder.setServiceObject(serviceB).buildAndStartAll();
  serviceA=new ServiceA(eventServiceQueue.createProxyWithAutoFlush(EventManager.class,Duration.SECOND),QBit.factory().eventBusProxyCreator());
  final ServiceQueue serviceAQueue=serviceBuilder.setServiceObject(serviceA).buildAndStartAll();
  serviceAQueueProxy=serviceAQueue.createProxy(ServiceAInterface.class);
}","@Before public void setup(){
  systemManager=new QBitSystemManager();
  eventManager=EventManagerBuilder.eventManagerBuilder().setName(""String_Node_Str"").build();
  serviceBuilder=ServiceBuilder.serviceBuilder().setSystemManager(systemManager);
  eventServiceQueue=serviceBuilder.setServiceObject(eventManager).build().startServiceQueue();
  serviceBuilder=ServiceBuilder.serviceBuilder().setSystemManager(systemManager).setEventManager(eventManager);
  serviceB=new ServiceB();
  serviceBuilder.setServiceObject(serviceB).buildAndStartAll();
  serviceBuilder=ServiceBuilder.serviceBuilder().setSystemManager(systemManager).setEventManager(eventManager);
  serviceA=new ServiceA(eventServiceQueue.createProxyWithAutoFlush(EventManager.class,Duration.SECOND),QBit.factory().eventBusProxyCreator());
  final ServiceQueue serviceAQueue=serviceBuilder.setServiceObject(serviceA).buildAndStartAll();
  serviceAQueueProxy=serviceAQueue.createProxy(ServiceAInterface.class);
}"
3803,"private RequestMetaData doGet(final String path){
  RequestMetaData requestMetaData=metaDataMap.get(path);
  if (requestMetaData == null) {
    Map.Entry<String,NavigableMap<Integer,RequestMetaData>> uriParamNumMapEntry=treeMap.lowerEntry(path);
    if (uriParamNumMapEntry == null) {
      return null;
    }
    final String requestURI=StringScanner.substringAfter(path,rootURI);
    int count=Str.split(requestURI,'/').length - 1;
    NavigableMap<Integer,RequestMetaData> uriParamMap=uriParamNumMapEntry.getValue();
    requestMetaData=uriParamMap.get(count);
    if (requestMetaData != null && path.startsWith(requestMetaData.getPath())) {
      return requestMetaData;
    }
 else {
      return null;
    }
  }
 else {
    return requestMetaData;
  }
}","private RequestMetaData doGet(final String path){
  RequestMetaData requestMetaData=metaDataMap.get(path);
  if (requestMetaData == null) {
    Map.Entry<String,NavigableMap<Integer,RequestMetaData>> uriParamNumMapEntry=treeMap.lowerEntry(path);
    if (uriParamNumMapEntry == null) {
      return null;
    }
    final String requestURI=Str.isEmpty(rootURI) ? path : StringScanner.substringAfter(path,rootURI);
    int count=Str.split(requestURI,'/').length - 1;
    NavigableMap<Integer,RequestMetaData> uriParamMap=uriParamNumMapEntry.getValue();
    requestMetaData=uriParamMap.get(count);
    if (requestMetaData != null && path.startsWith(requestMetaData.getPath())) {
      return requestMetaData;
    }
 else {
      return null;
    }
  }
 else {
    return requestMetaData;
  }
}"
3804,"@Test public void test(){
  final HttpClient client=HttpClientBuilder.httpClientBuilder().setHost(""String_Node_Str"").setPort(port).buildAndStart();
  Sys.sleep(1000);
  final HttpTextResponse response=client.postJson(""String_Node_Str"",""String_Node_Str"");
  assertEquals(202,response.code());
  assertEquals(""String_Node_Str"",response.body());
  final HttpTextResponse response2=client.postJson(""String_Node_Str"",""String_Node_Str"");
  assertEquals(200,response2.code());
  assertEquals(""String_Node_Str"",response2.body());
}","@Test public void test(){
  final HttpClient client=HttpClientBuilder.httpClientBuilder().setHost(""String_Node_Str"").setPort(port).buildAndStart();
  Sys.sleep(1000);
  final HttpTextResponse response=client.postJson(""String_Node_Str"",""String_Node_Str"");
  assertEquals(202,response.code());
  assertEquals(""String_Node_Str"",response.body());
  final HttpTextResponse response2=client.postJson(""String_Node_Str"",""String_Node_Str"");
  assertEquals(200,response2.code());
  assertEquals(""String_Node_Str"",response2.body());
  final HttpTextResponse response3=client.get(""String_Node_Str"");
  assertEquals(200,response3.code());
  assertEquals(""String_Node_Str"",response3.body());
}"
3805,"private T getItemFromLocalQueue(){
  if (lastQueue.length == 0) {
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") T item=(T)lastQueue[lastQueueIndex];
  lastQueueIndex++;
  if (lastQueueIndex == lastQueue.length) {
    lastQueueIndex=0;
    lastQueue=null;
  }
  return item;
}","private T getItemFromLocalQueue(){
  if (lastQueue.length == 0) {
    lastQueue=null;
    return null;
  }
  @SuppressWarnings(""String_Node_Str"") T item=(T)lastQueue[lastQueueIndex];
  lastQueueIndex++;
  if (lastQueueIndex == lastQueue.length) {
    lastQueueIndex=0;
    lastQueue=null;
  }
  return item;
}"
3806,"protected final boolean sendLocalQueue(){
  final Object[] copy=fastObjectArraySlice(queueLocal,0,index);
  boolean ableToSend=sendArray(copy);
  index=0;
  return ableToSend;
}","protected final boolean sendLocalQueue(){
  if (index > 0) {
    final Object[] copy=fastObjectArraySlice(queueLocal,0,index);
    boolean ableToSend=sendArray(copy);
    index=0;
    return ableToSend;
  }
 else {
    return false;
  }
}"
3807,"@Override public final void flushSends(){
  if (index > 0) {
    sendLocalQueue();
  }
}","@Override public final void flushSends(){
  sendLocalQueue();
}"
3808,"public CallbackBuilder setTimeoutDuration(@SuppressWarnings(""String_Node_Str"") long timeoutDuration){
  this.timeoutDuration=timeoutDuration;
  return this;
}","/** 
 * Deprecated. use withTimeoutInstead
 * @param timeoutDuration
 * @return
 */
@Deprecated public CallbackBuilder setTimeoutDuration(@SuppressWarnings(""String_Node_Str"") long timeoutDuration){
  this.timeoutDuration=timeoutDuration;
  return this;
}"
3809,"public <T>CallbackBuilder setCallback(Class<T> returnType,Callback<T> callback){
  this.callback=callback;
  return this;
}","/** 
 * Builder method to add a callback handler.  This is depricated.  Use withCallback instead.
 * @param returnType returnType
 * @param callback callback
 * @param < T > T
 * @return this
 */
@Deprecated public <T>CallbackBuilder setCallback(Class<T> returnType,Callback<T> callback){
  return withCallback(returnType,callback);
}"
3810,"public Runnable getOnTimeout(){
  return onTimeout;
}","/** 
 * This is Deprecated.  this will become private.  Builders should be only used to build in a local scope so this is something that you should have just set.
 * @return
 */
@Deprecated public Runnable getOnTimeout(){
  return onTimeout;
}"
3811,"public CallbackBuilder(){
}","/** 
 * Deprecated.  this will become private.  Use the static method to get one.
 */
@Deprecated public CallbackBuilder(){
}"
3812,"public CallbackBuilder setOnTimeout(Runnable onTimeout){
  this.onTimeout=onTimeout;
  return this;
}","/** 
 * Deprecated.  use withTimeoutHandler instead.
 * @param onTimeout onTimeout
 * @return
 */
@Deprecated public CallbackBuilder setOnTimeout(final Runnable onTimeout){
  this.onTimeout=onTimeout;
  return this;
}"
3813,"public TimeUnit getTimeoutTimeUnit(){
  return timeoutTimeUnit;
}","/** 
 * This is Deprecated.  this will become private.  Builders should be only used to build in a local scope so this is something that you should have just set.
 * @return
 */
@Deprecated public TimeUnit getTimeoutTimeUnit(){
  return timeoutTimeUnit;
}"
3814,"public static CallbackBuilder callbackBuilder(){
  return new CallbackBuilder();
}","/** 
 * Deprecated.  use newBuilder() instead
 * @return
 */
@Deprecated public static CallbackBuilder callbackBuilder(){
  return new CallbackBuilder();
}"
3815,"public Reactor getReactor(){
  return reactor;
}","/** 
 * This is Deprecated. this will become private. Builders should be only used to build in a local scope so this is something that you should have just set.
 * @return
 */
@Deprecated public Reactor getReactor(){
  return reactor;
}"
3816,"public long getTimeoutDuration(){
  return timeoutDuration;
}","/** 
 * This is Deprecated.  this will become private.  Builders should be only used to build in a local scope so this is something that you should have just set.
 * @return
 */
@Deprecated public long getTimeoutDuration(){
  return timeoutDuration;
}"
3817,"public Consumer<Throwable> getOnError(){
  return onError;
}","/** 
 * This is Deprecated.  this will become private.  Builders should be only used to build in a local scope so this is something that you should have just set.
 * @return
 */
@Deprecated public Consumer<Throwable> getOnError(){
  return onError;
}"
3818,"public <T>Callback<T> getCallback(){
  return callback;
}","/** 
 * This is Deprecated.  this will become private.  Builders should be only used to build in a local scope so this is something that you should have just set.
 * @return callback
 */
@Deprecated public <T>Callback<T> getCallback(){
  return callback;
}"
3819,"public CallbackBuilder setOnError(Consumer<Throwable> onError){
  this.onError=onError;
  return this;
}","/** 
 * Deprecated. use withErrorHandler instead.
 * @return
 */
@Deprecated public CallbackBuilder setOnError(Consumer<Throwable> onError){
  this.onError=onError;
  return this;
}"
3820,"public CallbackBuilder setTimeoutTimeUnit(TimeUnit timeoutTimeUnit){
  this.timeoutTimeUnit=timeoutTimeUnit;
  return this;
}","/** 
 * Deprecated.  use withTimeoutTimeUnit instead.
 * @param timeoutTimeUnit
 * @return
 */
@Deprecated public CallbackBuilder setTimeoutTimeUnit(TimeUnit timeoutTimeUnit){
  this.timeoutTimeUnit=timeoutTimeUnit;
  return this;
}"
3821,"private void addClass(final ClassMeta<?> classMeta){
  try {
    if (definitionMap.containsKey(classMeta.name())) {
      return;
    }
    final DefinitionBuilder definitionBuilder=new DefinitionBuilder();
    final String description=getDescription(classMeta);
    definitionBuilder.setDescription(description);
    Map<String,FieldAccess> fieldAccessMap=classMeta.fieldMap();
    fieldAccessMap.entrySet().forEach(fieldAccessEntry -> {
      final FieldAccess fieldAccess=fieldAccessEntry.getValue();
      if (fieldAccess.ignore() || fieldAccess.isStatic()) {
        return;
      }
      definitionBuilder.addProperty(fieldAccess.name(),convertFieldToSchema(fieldAccess));
    }
);
    final Definition definition=definitionBuilder.build();
    definitionMap.put(classMeta.name(),definition);
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"" + classMeta.longName(),ex);
  }
}","private void addClass(final ClassMeta<?> classMeta){
  try {
    if (definitionMap.containsKey(classMeta.name())) {
      return;
    }
    definitionMap.put(classMeta.name(),null);
    final DefinitionBuilder definitionBuilder=new DefinitionBuilder();
    final String description=getDescription(classMeta);
    definitionBuilder.setDescription(description);
    Map<String,FieldAccess> fieldAccessMap=classMeta.fieldMap();
    fieldAccessMap.entrySet().forEach(fieldAccessEntry -> {
      final FieldAccess fieldAccess=fieldAccessEntry.getValue();
      if (fieldAccess.ignore() || fieldAccess.isStatic()) {
        return;
      }
      definitionBuilder.addProperty(fieldAccess.name(),convertFieldToSchema(fieldAccess));
    }
);
    final Definition definition=definitionBuilder.build();
    definitionMap.put(classMeta.name(),definition);
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"" + classMeta.longName(),ex);
  }
}"
3822,"public ServiceBuilder setServiceObject(final Object serviceObject){
  if (serviceObject == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassMeta<?> classMeta=ClassMeta.classMeta(serviceObject.getClass());
  Iterable<MethodAccess> methods=classMeta.methods();
  Set<String> methodNames=new HashSet<>();
  int size;
  for (  MethodAccess methodAccess : methods) {
    if (!methodAccess.method().getDeclaringClass().isInterface()) {
      continue;
    }
    size=methodNames.size();
    methodNames.add(methodAccess.name());
    if (size == methodNames.size()) {
      throw new IllegalStateException(""String_Node_Str"" + methodAccess.name() + ""String_Node_Str""+ methodNames+ ""String_Node_Str""+ classMeta.longName());
    }
  }
  this.serviceObject=serviceObject;
  return this;
}","public ServiceBuilder setServiceObject(final Object serviceObject){
  if (serviceObject == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassMeta<?> classMeta=ClassMeta.classMeta(serviceObject.getClass());
  Iterable<MethodAccess> methods=classMeta.methods();
  Set<String> methodNames=new HashSet<>();
  int size;
  for (  MethodAccess methodAccess : methods) {
    if (methodAccess.method().getDeclaringClass().isInterface()) {
      continue;
    }
    size=methodNames.size();
    methodNames.add(methodAccess.name());
    if (size == methodNames.size()) {
      throw new IllegalStateException(""String_Node_Str"" + methodAccess.name() + ""String_Node_Str""+ methodNames+ ""String_Node_Str""+ classMeta.longName());
    }
  }
  this.serviceObject=serviceObject;
  return this;
}"
3823,"private void extractPathFromRequestMeta(final ServiceMethodMeta methodMeta,final MethodAccess methodAccess,final RequestMeta requestMeta,final PathBuilder pathBuilder,final RequestMethod requestMethod){
  final OperationBuilder operationBuilder=new OperationBuilder();
  operationBuilder.setDescription(methodMeta.getDescription());
  operationBuilder.setSummary(methodMeta.getSummary());
  addParameters(operationBuilder,requestMeta.getParameters());
  operationBuilder.setOperationId(methodAccess.name());
  if (methodMeta.hasReturn()) {
    final ResponseBuilder responseBuilder=new ResponseBuilder();
    if (methodMeta.isReturnMap()) {
    }
 else     if (methodMeta.isReturnCollection() || methodMeta.isReturnArray()) {
      responseBuilder.setSchema(definitionClassCollector.getSchema(methodMeta.getReturnType(),methodMeta.getReturnTypeComponent()));
      responseBuilder.setDescription(methodMeta.getReturnDescription());
      operationBuilder.getResponses().put(200,responseBuilder.build());
      operationBuilder.getProduces().add(""String_Node_Str"");
    }
 else {
      responseBuilder.setSchema(definitionClassCollector.getSchema(methodMeta.getReturnType()));
      responseBuilder.setDescription(methodMeta.getReturnDescription());
      operationBuilder.getResponses().put(200,responseBuilder.build());
      operationBuilder.getProduces().add(""String_Node_Str"");
    }
  }
 else {
    final ResponseBuilder responseBuilder=new ResponseBuilder();
    final SchemaBuilder schemaBuilder=new SchemaBuilder();
    schemaBuilder.setType(""String_Node_Str"");
    responseBuilder.setSchema(schemaBuilder.build());
    responseBuilder.setDescription(""String_Node_Str"");
    operationBuilder.getResponses().put(202,responseBuilder.build());
  }
switch (requestMethod) {
case GET:
    pathBuilder.setGet(operationBuilder.build());
  break;
case POST:
pathBuilder.setPost(operationBuilder.build());
break;
case PUT:
pathBuilder.setPut(operationBuilder.build());
break;
case OPTIONS:
pathBuilder.setOptions(operationBuilder.build());
break;
case DELETE:
pathBuilder.setDelete(operationBuilder.build());
break;
case HEAD:
pathBuilder.setHead(operationBuilder.build());
break;
}
}","private void extractPathFromRequestMeta(final ServiceMethodMeta methodMeta,final MethodAccess methodAccess,final RequestMeta requestMeta,final PathBuilder pathBuilder,final RequestMethod requestMethod){
  final OperationBuilder operationBuilder=new OperationBuilder();
  operationBuilder.setDescription(methodMeta.getDescription());
  operationBuilder.setSummary(methodMeta.getSummary());
  addParameters(operationBuilder,requestMeta.getParameters());
  operationBuilder.setOperationId(methodAccess.name());
  if (methodMeta.hasReturn()) {
    final ResponseBuilder responseBuilder=new ResponseBuilder();
    if (methodMeta.isReturnMap()) {
    }
 else     if (methodMeta.isReturnCollection() || methodMeta.isReturnArray()) {
      responseBuilder.setSchema(definitionClassCollector.getSchemaWithComponentClass(methodMeta.getReturnType(),methodMeta.getReturnTypeComponent()));
      responseBuilder.setDescription(methodMeta.getReturnDescription());
      operationBuilder.getResponses().put(200,responseBuilder.build());
      operationBuilder.getProduces().add(""String_Node_Str"");
    }
 else {
      responseBuilder.setSchema(definitionClassCollector.getSchema(methodMeta.getReturnType()));
      responseBuilder.setDescription(methodMeta.getReturnDescription());
      operationBuilder.getResponses().put(200,responseBuilder.build());
      operationBuilder.getProduces().add(""String_Node_Str"");
    }
  }
 else {
    final ResponseBuilder responseBuilder=new ResponseBuilder();
    final SchemaBuilder schemaBuilder=new SchemaBuilder();
    schemaBuilder.setType(""String_Node_Str"");
    responseBuilder.setSchema(schemaBuilder.build());
    responseBuilder.setDescription(""String_Node_Str"");
    operationBuilder.getResponses().put(202,responseBuilder.build());
  }
switch (requestMethod) {
case GET:
    pathBuilder.setGet(operationBuilder.build());
  break;
case POST:
pathBuilder.setPost(operationBuilder.build());
break;
case PUT:
pathBuilder.setPut(operationBuilder.build());
break;
case OPTIONS:
pathBuilder.setOptions(operationBuilder.build());
break;
case DELETE:
pathBuilder.setDelete(operationBuilder.build());
break;
case HEAD:
pathBuilder.setHead(operationBuilder.build());
break;
}
}"
3824,"@Test(expected=IllegalStateException.class) public void noOverloading(){
  ServiceQueue serviceQueue=ServiceBuilder.serviceBuilder().setServiceObject(new MyService()).build();
}","@Test public void noOverloading(){
  ServiceQueue serviceQueue=ServiceBuilder.serviceBuilder().setServiceObject(new MyService()).build();
}"
3825,"@Test(expected=IllegalStateException.class) public void noOverloadingBundle(){
  ServiceBundleBuilder.serviceBundleBuilder().build().addService(new MyService()).start();
}","@Test public void noOverloadingBundle(){
  ServiceBundleBuilder.serviceBundleBuilder().build().addService(new MyService()).start();
}"
3826,"public ServiceBuilder setServiceObject(final Object serviceObject){
  if (serviceObject == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassMeta<?> classMeta=ClassMeta.classMeta(serviceObject.getClass());
  Iterable<MethodAccess> methods=classMeta.methods();
  Set<String> methodNames=new HashSet<>();
  int size;
  for (  MethodAccess methodAccess : methods) {
    if (methodAccess.method().getDeclaringClass().isInterface()) {
      continue;
    }
    size=methodNames.size();
    methodNames.add(methodAccess.name());
    if (size == methodNames.size()) {
      throw new IllegalStateException(""String_Node_Str"" + methodAccess.name() + ""String_Node_Str""+ methodNames+ ""String_Node_Str""+ classMeta.longName());
    }
  }
  this.serviceObject=serviceObject;
  return this;
}","public ServiceBuilder setServiceObject(final Object serviceObject){
  if (serviceObject == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassMeta<?> classMeta=ClassMeta.classMeta(serviceObject.getClass());
  Iterable<MethodAccess> methods=classMeta.methods();
  Set<String> methodNames=new HashSet<>();
  int size;
  for (  MethodAccess methodAccess : methods) {
    if (methodAccess.method().getDeclaringClass().isInterface()) {
      continue;
    }
    size=methodNames.size();
    methodNames.add(methodAccess.name());
    if (size == methodNames.size()) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + methodAccess.name() + ""String_Node_Str""+ methodNames+ ""String_Node_Str""+ classMeta.longName());
    }
  }
  this.serviceObject=serviceObject;
  return this;
}"
3827,"public ServiceBuilder setServiceObject(final Object serviceObject){
  if (serviceObject == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassMeta<?> classMeta=ClassMeta.classMeta(serviceObject.getClass());
  Iterable<MethodAccess> methods=classMeta.methods();
  Set<String> methodNames=new HashSet<>();
  int size;
  for (  MethodAccess methodAccess : methods) {
    size=methodNames.size();
    methodNames.add(methodAccess.name());
    if (size == methodNames.size()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  this.serviceObject=serviceObject;
  return this;
}","public ServiceBuilder setServiceObject(final Object serviceObject){
  if (serviceObject == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ClassMeta<?> classMeta=ClassMeta.classMeta(serviceObject.getClass());
  Iterable<MethodAccess> methods=classMeta.methods();
  Set<String> methodNames=new HashSet<>();
  int size;
  for (  MethodAccess methodAccess : methods) {
    if (!methodAccess.method().getDeclaringClass().isInterface()) {
      continue;
    }
    size=methodNames.size();
    methodNames.add(methodAccess.name());
    if (size == methodNames.size()) {
      throw new IllegalStateException(""String_Node_Str"" + methodAccess.name() + ""String_Node_Str""+ methodNames+ ""String_Node_Str""+ classMeta.longName());
    }
  }
  this.serviceObject=serviceObject;
  return this;
}"
3828,"private void handleDiscoveryCheckInWithHealth(final AtomicLong lastCheckIn,final long checkInDuration){
  final AtomicBoolean ok=new AtomicBoolean(true);
  httpServer.setHttpRequestsIdleConsumer(aVoid -> {
    httpRequestServerHandler.httpRequestQueueIdle(null);
    long now=Timer.clockTime();
    if (now > lastCheckIn.get() + checkInDuration) {
      lastCheckIn.set(now);
      if (ok.get()) {
        serviceDiscovery.checkInOk(endpoint.getId());
      }
 else {
        serviceDiscovery.checkIn(endpoint.getId(),HealthStatus.FAIL);
      }
    }
    healthServiceAsync.ok(ok::set);
    ServiceProxyUtils.flushServiceProxy(healthServiceAsync);
  }
);
}","private void handleDiscoveryCheckInWithHealth(final AtomicLong lastCheckIn,final long checkInDuration){
  final AtomicBoolean ok=new AtomicBoolean(true);
  httpServer.setHttpRequestsIdleConsumer(aVoid -> {
    httpRequestServerHandler.httpRequestQueueIdle(null);
    long now=Timer.clockTime();
    if (now > lastCheckIn.get() + checkInDuration) {
      lastCheckIn.set(now);
      if (ok.get()) {
        serviceDiscovery.checkInOk(endpoint.getId());
      }
 else {
        serviceDiscovery.checkIn(endpoint.getId(),HealthStatus.FAIL);
      }
      healthServiceAsync.ok(ok::set);
      ServiceProxyUtils.flushServiceProxy(healthServiceAsync);
    }
  }
);
}"
3829,"/** 
 * Register a callbackWithTimeout handler
 * @param methodCall method call
 * @param handler    call back handler to register
 */
private void registerHandlerCallbackForClient(final MethodCall<Object> methodCall,final Callback<Object> handler){
  handlers.put(new HandlerKey(methodCall.returnAddress(),methodCall.id(),now),handler);
}","/** 
 * Register a callbackWithTimeout handler
 * @param methodCall method call
 * @param handler    call back handler to register
 */
private void registerHandlerCallbackForClient(final MethodCall<Object> methodCall,final Callback<Object> handler){
  handlers.put(new HandlerKey(methodCall.returnAddress(),methodCall.address(),methodCall.id(),now),handler);
}"
3830,"@Override public void process(long currentTime){
  if (!handleTimeouts) {
    return;
  }
  if (currentTime != 0) {
    this.now=currentTime;
  }
 else {
    this.now=timer.now();
  }
  long duration=this.now - lastCheckTime;
  if (duration > checkInterval) {
    checkForTimeOuts();
    lastCheckTime=this.now;
  }
}","@Override public void process(long currentTime){
}"
3831,"private void checkForTimeOuts(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  final ArrayList<Map.Entry<HandlerKey,Callback<Object>>> entries=new ArrayList<>(handlers.entrySet());
  for (  Map.Entry<HandlerKey,Callback<Object>> entry : entries) {
    long duration=now - entry.getKey().timestamp;
    if (duration > timeOutMS) {
      if (debug)       logger.debug(""String_Node_Str"",name,now - entry.getKey().timestamp,entry.getKey().returnAddress,entry.getKey().messageId,new Date(entry.getKey().timestamp));
      handlers.remove(entry.getKey());
      entry.getValue().onTimeout();
    }
  }
}","private void checkForTimeOuts(long timeOutMS){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  final ArrayList<Map.Entry<HandlerKey,Callback<Object>>> entries=new ArrayList<>(handlers.entrySet());
  for (  Map.Entry<HandlerKey,Callback<Object>> entry : entries) {
    long duration=now - entry.getKey().timestamp;
    if (duration > timeOutMS) {
      if (debug)       logger.debug(""String_Node_Str"",name,now - entry.getKey().timestamp,entry.getKey().returnAddress,entry.getKey().messageId,new Date(entry.getKey().timestamp));
      handlers.remove(entry.getKey());
      entry.getValue().onTimeout();
    }
  }
}"
3832,"@Override public void handleResponse(final Response<Object> response){
  final HandlerKey handlerKey=new HandlerKey(response.returnAddress(),response.id(),now);
  final Callback<Object> handler=handlers.get(handlerKey);
  handlers.remove(handlerKey);
  if (handler == null) {
    return;
  }
  if (response.wasErrors()) {
    if (debug) {
      logger.debug(""String_Node_Str"",response.address(),response.returnAddress(),response.id(),response.body());
    }
    if (response.body() instanceof Throwable) {
      handler.onError(((Throwable)response.body()));
    }
 else {
      handler.onError(new Exception(response.body().toString()));
    }
  }
 else {
    handler.accept(response.body());
  }
}","@Override public void handleResponse(final Response<Object> response){
  final HandlerKey handlerKey=new HandlerKey(response.returnAddress(),response.address(),response.id(),now);
  final Callback<Object> handler=handlers.remove(handlerKey);
  if (handler == null) {
    logger.error(""String_Node_Str"",handlerKey);
    return;
  }
  if (response.wasErrors()) {
    if (debug) {
      logger.debug(""String_Node_Str"",response.address(),response.returnAddress(),response.id(),response.body());
    }
    if (response.body() instanceof Throwable) {
      handler.onError(((Throwable)response.body()));
    }
 else {
      handler.onError(new Exception(response.body().toString()));
    }
  }
 else {
    handler.accept(response.body());
  }
}"
3833,"HandlerKey(String returnAddress,long messageId,long now){
  this.returnAddress=returnAddress;
  this.messageId=messageId;
  this.timestamp=now;
}","HandlerKey(String returnAddress,String address,long messageId,long timestamp){
  this.returnAddress=returnAddress;
  this.address=address;
  this.messageId=messageId;
  this.timestamp=timestamp;
}"
3834,"@Override public int hashCode(){
  int result=returnAddress != null ? returnAddress.hashCode() : 0;
  result=31 * result + (int)(messageId ^ (messageId >>> 32));
  return result;
}","@Override public int hashCode(){
  int result=returnAddress != null ? returnAddress.hashCode() : 0;
  result=31 * result + (int)(messageId ^ (messageId >>> 32));
  result=31 * result + (int)(timestamp ^ (timestamp >>> 32));
  return result;
}"
3835,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  final HandlerKey that=(HandlerKey)o;
  return messageId == that.messageId && !(returnAddress != null ? !returnAddress.equals(that.returnAddress) : that.returnAddress != null);
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof HandlerKey))   return false;
  HandlerKey that=(HandlerKey)o;
  if (messageId != that.messageId)   return false;
  if (timestamp != that.timestamp)   return false;
  if (returnAddress != null ? !returnAddress.equals(that.returnAddress) : that.returnAddress != null)   return false;
  return true;
}"
3836,"public EndpointServerBuilder getEndpointServerBuilder(){
  if (endpointServerBuilder == null) {
    endpointServerBuilder=EndpointServerBuilder.endpointServerBuilder();
    endpointServerBuilder.setEnableHealthEndpoint(isEnableLocalHealth());
    endpointServerBuilder.setHealthService(getHealthService());
    endpointServerBuilder.setSystemManager(this.getSystemManager());
    endpointServerBuilder.setHttpServerBuilder(getHttpServerBuilder());
    endpointServerBuilder.setStatsFlushRateSeconds(getSampleStatFlushRate());
    endpointServerBuilder.setCheckTimingEveryXCalls(getCheckTimingEveryXCalls());
    endpointServerBuilder.setServiceDiscovery(getServiceDiscovery());
    endpointServerBuilder.setUri(getRootURI());
    endpointServerBuilder.setupHealthAndStats(getHttpServerBuilder());
    if (isEnableStats()) {
      endpointServerBuilder.setStatsCollector(getStatServiceBuilder().buildStatsCollectorWithAutoFlush());
    }
    if (isEnableLocalStats()) {
      endpointServerBuilder.setEnableStatEndpoint(true);
      endpointServerBuilder.setStatsCollection(getLocalStatsCollectorBuilder().build());
    }
    if (endpointServices != null) {
      endpointServerBuilder.setServices(endpointServices);
    }
  }
  return endpointServerBuilder;
}","public EndpointServerBuilder getEndpointServerBuilder(){
  if (endpointServerBuilder == null) {
    endpointServerBuilder=EndpointServerBuilder.endpointServerBuilder();
    endpointServerBuilder.setEnableHealthEndpoint(isEnableLocalHealth());
    endpointServerBuilder.setEnableStatEndpoint(isEnableLocalStats());
    endpointServerBuilder.setHealthService(getHealthService());
    endpointServerBuilder.setSystemManager(this.getSystemManager());
    endpointServerBuilder.setHttpServerBuilder(getHttpServerBuilder());
    endpointServerBuilder.setStatsFlushRateSeconds(getSampleStatFlushRate());
    endpointServerBuilder.setCheckTimingEveryXCalls(getCheckTimingEveryXCalls());
    endpointServerBuilder.setServiceDiscovery(getServiceDiscovery());
    endpointServerBuilder.setUri(getRootURI());
    if (isEnableStats()) {
      endpointServerBuilder.setStatsCollector(getStatServiceBuilder().buildStatsCollectorWithAutoFlush());
    }
    if (isEnableLocalStats()) {
      endpointServerBuilder.setEnableStatEndpoint(true);
      endpointServerBuilder.setStatsCollection(getLocalStatsCollectorBuilder().build());
    }
    endpointServerBuilder.setupHealthAndStats(getHttpServerBuilder());
    if (endpointServices != null) {
      endpointServerBuilder.setServices(endpointServices);
    }
  }
  return endpointServerBuilder;
}"
3837,"public RequestContinuePredicate add(Predicate<HttpRequest> predicate){
  predicates.add(predicate);
  return this;
}","public RequestContinuePredicate add(final Predicate<HttpRequest> predicate){
  predicates.add(predicate);
  return this;
}"
3838,"private void buildQueue(){
  final StatsDReplicator statsDReplicator=createStatsDReplicator();
  final ServiceBuilder serviceBuilder=this.getServiceBuilder();
  serviceBuilder.setServiceObject(statsDReplicator);
  this.serviceQueue=serviceBuilder.build();
}","private void buildQueue(){
  final StatsDReplicator statsDReplicator=createStatsDReplicator();
  final ServiceBuilder serviceBuilder=this.getServiceBuilder();
  serviceBuilder.getRequestQueueBuilder().setUnableToEnqueueHandler(new UnableToEnqueueHandler(){
    @Override public boolean unableToEnqueue(    BlockingQueue<Object> queue,    String queueName){
      final Logger logger=LoggerFactory.getLogger(StatsDReplicator.class);
      logger.error(""String_Node_Str"" + queueName);
      queue.clear();
      return false;
    }
  }
);
  serviceBuilder.getResponseQueueBuilder().setUnableToEnqueueHandler(new UnableToEnqueueHandler(){
    @Override public boolean unableToEnqueue(    BlockingQueue<Object> queue,    String queueName){
      final Logger logger=LoggerFactory.getLogger(StatsDReplicator.class);
      logger.error(""String_Node_Str"" + queueName);
      queue.clear();
      return false;
    }
  }
);
  serviceBuilder.setServiceObject(statsDReplicator);
  this.serviceQueue=serviceBuilder.buildAndStartAll();
}"
3839,"public StatReplicator buildAndStart(){
  buildQueue();
  final StatReplicator proxyWithAutoFlush=serviceQueue.createProxyWithAutoFlush(StatReplicator.class,100,TimeUnit.MILLISECONDS);
  serviceQueue.start();
  return proxyWithAutoFlush;
}","public StatReplicator buildAndStart(){
  buildQueue();
  final StatReplicator proxyWithAutoFlush=serviceQueue.createProxyWithAutoFlush(StatReplicator.class,100,TimeUnit.MILLISECONDS);
  return proxyWithAutoFlush;
}"
3840,"public <T>Queue<T> build(){
  return new BasicQueue<>(this.getName(),this.getPollWait(),this.getPollTimeUnit(),this.getEnqueueTimeout(),this.getEnqueueTimeoutTimeUnit(),this.getBatchSize(),this.queueClass,this.isCheckIfBusy(),this.getSize(),this.getCheckEvery(),this.isTryTransfer());
}","public <T>Queue<T> build(){
  return new BasicQueue<>(this.getName(),this.getPollWait(),this.getPollTimeUnit(),this.getEnqueueTimeout(),this.getEnqueueTimeoutTimeUnit(),this.getBatchSize(),this.getQueueClass(),this.isCheckIfBusy(),this.getSize(),this.getCheckEvery(),this.isTryTransfer(),this.getUnableToEnqueueHandler());
}"
3841,void send(T item);,boolean send(T item);
3842,"@Override public void send(T item){
  try {
    lock.lock();
    sendQueue.send(item);
  }
  finally {
    lock.unlock();
  }
}","@Override public boolean send(T item){
  try {
    lock.lock();
    return sendQueue.send(item);
  }
  finally {
    lock.unlock();
  }
}"
3843,"/** 
 * This returns a new instance of SendQueue every time you call it so call it only once per thread.
 * @return sendQueue.
 */
@Override public SendQueue<T> sendQueue(){
  logger.info(""String_Node_Str"",name);
  return new BasicSendQueue<>(name,batchSize,queue,checkIfBusy,checkEvery,tryTransfer,enqueueTimeoutTimeUnit,enqueueTimeout);
}","/** 
 * This returns a new instance of SendQueue every time you call it so call it only once per thread.
 * @return sendQueue.
 */
@Override public SendQueue<T> sendQueue(){
  logger.info(""String_Node_Str"",name);
  return new BasicSendQueue<>(name,batchSize,queue,checkIfBusy,checkEvery,tryTransfer,enqueueTimeoutTimeUnit,enqueueTimeout,unableToEnqueueHandler);
}"
3844,"public BasicQueue(final String name,final int waitTime,@SuppressWarnings(""String_Node_Str"") final TimeUnit timeUnit,final int enqueueTimeout,final TimeUnit enqueueTimeoutTimeUnit,final int batchSize,final Class<? extends BlockingQueue> queueClass,final boolean checkIfBusy,final int size,final int checkEvery,boolean tryTransfer){
  logger.info(""String_Node_Str"",name,queueClass,batchSize,size,checkEvery,tryTransfer,waitTime,enqueueTimeout);
  this.enqueueTimeout=enqueueTimeout;
  this.tryTransfer=tryTransfer;
  this.name=name;
  this.pollTimeWait=waitTime;
  this.pollTimeTimeUnit=timeUnit;
  this.batchSize=batchSize;
  this.enqueueTimeoutTimeUnit=enqueueTimeoutTimeUnit;
  boolean shouldCheckIfBusy;
  this.receiveQueueManager=new BasicReceiveQueueManager<>();
  if (size == -1) {
    this.queue=ClassMeta.classMeta(queueClass).noArgConstructor().create();
  }
 else {
    final ClassMeta<? extends BlockingQueue> classMeta=ClassMeta.classMeta(queueClass);
    if (queueClass != LinkedTransferQueue.class) {
      if (debug)       logger.debug(""String_Node_Str"");
      final ConstructorAccess<Object> constructor=classMeta.declaredConstructor(int.class);
      this.queue=(BlockingQueue<Object>)constructor.create(size);
    }
 else {
      final ConstructorAccess<? extends BlockingQueue> constructorAccess=classMeta.noArgConstructor();
      this.queue=(BlockingQueue<Object>)constructorAccess.create();
    }
  }
  shouldCheckIfBusy=queue instanceof TransferQueue;
  this.checkIfBusy=shouldCheckIfBusy && checkIfBusy;
  this.checkEvery=checkEvery;
  logger.info(""String_Node_Str"" + ""String_Node_Str"",this.name,this.batchSize,this.checkEvery,this.tryTransfer,this.pollTimeWait,this.enqueueTimeout);
}","public BasicQueue(final String name,final int waitTime,@SuppressWarnings(""String_Node_Str"") final TimeUnit timeUnit,final int enqueueTimeout,final TimeUnit enqueueTimeoutTimeUnit,final int batchSize,final Class<? extends BlockingQueue> queueClass,final boolean checkIfBusy,final int size,final int checkEvery,boolean tryTransfer,UnableToEnqueueHandler unableToEnqueueHandler){
  logger.info(""String_Node_Str"",name,queueClass,batchSize,size,checkEvery,tryTransfer,waitTime,enqueueTimeout);
  this.enqueueTimeout=enqueueTimeout;
  this.tryTransfer=tryTransfer;
  this.name=name;
  this.pollTimeWait=waitTime;
  this.pollTimeTimeUnit=timeUnit;
  this.batchSize=batchSize;
  this.enqueueTimeoutTimeUnit=enqueueTimeoutTimeUnit;
  this.unableToEnqueueHandler=unableToEnqueueHandler;
  boolean shouldCheckIfBusy;
  this.receiveQueueManager=new BasicReceiveQueueManager<>();
  if (size == -1) {
    this.queue=ClassMeta.classMeta(queueClass).noArgConstructor().create();
  }
 else {
    final ClassMeta<? extends BlockingQueue> classMeta=ClassMeta.classMeta(queueClass);
    if (queueClass != LinkedTransferQueue.class) {
      if (debug)       logger.debug(""String_Node_Str"");
      final ConstructorAccess<Object> constructor=classMeta.declaredConstructor(int.class);
      this.queue=(BlockingQueue<Object>)constructor.create(size);
    }
 else {
      final ConstructorAccess<? extends BlockingQueue> constructorAccess=classMeta.noArgConstructor();
      this.queue=(BlockingQueue<Object>)constructorAccess.create();
    }
  }
  shouldCheckIfBusy=queue instanceof TransferQueue;
  this.checkIfBusy=shouldCheckIfBusy && checkIfBusy;
  this.checkEvery=checkEvery;
  logger.info(""String_Node_Str"" + ""String_Node_Str"",this.name,this.batchSize,this.checkEvery,this.tryTransfer,this.pollTimeWait,this.enqueueTimeout);
}"
3845,"/** 
 * Add a task that gets repeated. 
 */
public void addRepeatingTask(final long repeatEvery,final TimeUnit timeUnit,final Runnable task){
  repeatingTasks.add(new RepeatingTask(task,timeUnit,repeatEvery));
}","/** 
 * Add a task that gets repeated.
 * @param repeatEvery repeat Every time period
 * @param timeUnit unit for repeatEvery
 * @param task task to perform
 */
public void addRepeatingTask(final long repeatEvery,final TimeUnit timeUnit,final Runnable task){
  repeatingTasks.add(new RepeatingTask(task,timeUnit,repeatEvery));
}"
3846,"void pickSuggestions2(Callback<String> returnValue,String username){
  count++;
  totalCount.incrementAndGet();
  returnValue.accept(username);
}","void pickSuggestions2(Callback<String> returnValue,String username){
  count++;
  returnValue.accept(username);
}"
3847,"@Test public void test(){
  final MultiWorkerClient worker=bundle.createLocalProxy(MultiWorkerClient.class,""String_Node_Str"");
  for (int index=0; index < 200; index++) {
    worker.pickSuggestions(""String_Node_Str"" + index);
  }
  worker.clientProxyFlush();
  Sys.sleep(1000);
  super.waitForTrigger(10,o -> ContentRulesEngine.totalCount.get() >= 200);
  ok=ContentRulesEngine.totalCount.get() == 200 || die(ContentRulesEngine.totalCount);
}","@Test public void test(){
  final MultiWorkerClient worker=bundle.createLocalProxy(MultiWorkerClient.class,""String_Node_Str"");
  for (int index=0; index < 200; index++) {
    worker.pickSuggestions(""String_Node_Str"" + index);
  }
  worker.clientProxyFlush();
  Sys.sleep(1000);
  super.waitForTrigger(10,o -> ContentRulesEngine.totalCount.get() >= 200);
  assertEquals(200,ContentRulesEngine.totalCount.get());
}"
3848,"@Test public void testCheckInOk() throws Exception {
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkInOk(""String_Node_Str"");
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}","@Test public void testCheckInOk() throws Exception {
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  final AtomicBoolean result=new AtomicBoolean();
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkInOk(""String_Node_Str"");
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}"
3849,"@Test public void forceTTLExpire() throws Exception {
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.PASS);
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findAllNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
  timer.setTime();
  timer.minutes(1);
  Sys.sleep(1000);
  healthService.clientProxyFlush();
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(!names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}","@Test public void forceTTLExpire() throws Exception {
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  final AtomicBoolean result=new AtomicBoolean();
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.PASS);
  healthService.findAllNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
  timer.setTime();
  timer.minutes(1);
  Sys.sleep(1000);
  healthService.clientProxyFlush();
  final CountDownLatch countDownLatch2=new CountDownLatch(1);
  result.set(false);
  healthService.findHealthyNodes(names -> {
    result.set(!names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch2.countDown();
  }
);
  countDownLatch2.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}"
3850,"@Test public void testRegister() throws Exception {
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.clientProxyFlush();
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findAllNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  healthService.clientProxyFlush();
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(!names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}","@Test public void testRegister() throws Exception {
  final AtomicBoolean result=new AtomicBoolean();
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  healthService.findAllNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
  healthService.unregister(""String_Node_Str"");
  final CountDownLatch countDownLatch2=new CountDownLatch(1);
  result.set(false);
  healthService.findAllNodes(names -> {
    result.set(!names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch2.countDown();
  }
);
  countDownLatch2.await(10,TimeUnit.SECONDS);
}"
3851,"@Test public void transitionFromPassToFail() throws Exception {
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.PASS);
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.FAIL);
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(!names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}","@Test public void transitionFromPassToFail() throws Exception {
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  final AtomicBoolean result=new AtomicBoolean();
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.PASS);
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.FAIL);
  final CountDownLatch countDownLatch2=new CountDownLatch(1);
  result.set(false);
  healthService.findHealthyNodes(names -> {
    result.set(!names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch2.countDown();
  }
);
  countDownLatch2.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}"
3852,"@Test public void testCheckInOkUsingCheckIn() throws Exception {
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.PASS);
  countDownLatch=new CountDownLatch(1);
  result=new AtomicBoolean();
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}","@Test public void testCheckInOkUsingCheckIn() throws Exception {
  final CountDownLatch countDownLatch=new CountDownLatch(1);
  final AtomicBoolean result=new AtomicBoolean();
  healthService.register(""String_Node_Str"",1,TimeUnit.SECONDS);
  healthService.checkIn(""String_Node_Str"",HealthStatus.PASS);
  healthService.findHealthyNodes(names -> {
    result.set(names.stream().anyMatch(s -> s.equals(""String_Node_Str"")));
    countDownLatch.countDown();
  }
);
  ServiceProxyUtils.flushServiceProxy(healthService);
  countDownLatch.await(10,TimeUnit.SECONDS);
  assertTrue(""String_Node_Str"",result.get());
}"
3853,"@Test public void testUsingProxyWithAutoFlush(){
  ServiceQueue serviceQueue=serviceBuilder().setServiceAddress(""String_Node_Str"").setServiceObject(new TodoService()).build();
  serviceQueue.startServiceQueue().startCallBackHandler();
  TodoServiceClient todoServiceClient=serviceQueue.createProxyWithAutoFlush(TodoServiceClient.class,50,TimeUnit.MILLISECONDS);
  todoServiceClient.add(new TodoItem(""String_Node_Str"",""String_Node_Str"",null));
  AtomicReference<List<TodoItem>> items=new AtomicReference<>();
  todoServiceClient.list(todoItems -> items.set(todoItems));
  Sys.sleep(2000);
  ok=items.get() != null || die();
  ok=items.get().size() > 0 || die();
  ok=items.get().get(0).getDescription().equals(""String_Node_Str"") || die();
}","@Test public void testUsingProxyWithAutoFlush(){
  ServiceQueue serviceQueue=serviceBuilder().setServiceAddress(""String_Node_Str"").setServiceObject(new TodoService()).build();
  TodoServiceClient todoServiceClient=serviceQueue.createProxyWithAutoFlush(TodoServiceClient.class,25,TimeUnit.MILLISECONDS);
  serviceQueue.start();
  serviceQueue.startServiceQueue().startCallBackHandler();
  todoServiceClient.add(new TodoItem(""String_Node_Str"",""String_Node_Str"",null));
  AtomicReference<List<TodoItem>> items=new AtomicReference<>();
  todoServiceClient.list(todoItems -> items.set(todoItems));
  Sys.sleep(2000);
  ok=items.get() != null || die();
  ok=items.get().size() > 0 || die();
  ok=items.get().get(0).getDescription().equals(""String_Node_Str"") || die();
}"
3854,"@Override public void unregisterServices(final ConcurrentHashSet<EndpointDefinition> endpointDefinitions){
  for (  EndpointDefinition definition : endpointDefinitions) {
    Consul consul=consulThreadLocal.get();
    try {
      consul.agent().deregister(definition.getId());
    }
 catch (    Exception ex) {
      handleConsulRecovery(consul,ex);
    }
  }
}","@Override public void unregisterServices(final ConcurrentHashSet<EndpointDefinition> endpointDefinitions){
  for (  EndpointDefinition definition : endpointDefinitions) {
    Consul consul=consul();
    try {
      consul.agent().deregister(definition.getId());
    }
 catch (    Exception ex) {
      handleConsulRecovery(consul,ex);
    }
 finally {
      shutDownConsul(consul);
    }
  }
}"
3855,"private void shutDownConsul(Consul consul){
  try {
    consul.stop();
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
}","private void shutDownConsul(Consul consul){
  try {
    if (consul != null) {
      consul.stop();
    }
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
}"
3856,"@Override public void registerServices(final Queue<EndpointDefinition> registerQueue){
  if (trace) {
    logger.trace(sputs(""String_Node_Str"",registerQueue));
  }
  EndpointDefinition endpointDefinition=registerQueue.poll();
  if (endpointDefinition != null) {
    Consul consul=consulThreadLocal.get();
    while (endpointDefinition != null) {
      try {
        consul.agent().registerService(endpointDefinition.getPort(),endpointDefinition.getTimeToLive(),endpointDefinition.getName(),endpointDefinition.getId(),tags);
      }
 catch (      Exception ex) {
        handleConsulRecovery(consul,ex);
      }
      endpointDefinition=registerQueue.poll();
    }
  }
}","@Override public void registerServices(final Queue<EndpointDefinition> registerQueue){
  if (trace) {
    logger.trace(sputs(""String_Node_Str"",registerQueue));
  }
  EndpointDefinition endpointDefinition=registerQueue.poll();
  if (endpointDefinition != null) {
    final Consul consul=consul();
    try {
      while (endpointDefinition != null) {
        try {
          consul.agent().registerService(endpointDefinition.getPort(),endpointDefinition.getTimeToLive(),endpointDefinition.getName(),endpointDefinition.getId(),tags);
        }
 catch (        Exception ex) {
          handleConsulRecovery(consul,ex);
        }
        endpointDefinition=registerQueue.poll();
      }
    }
  finally {
      shutDownConsul(consul);
    }
  }
}"
3857,"@Override public void checkIn(final Queue<ServiceHealthCheckIn> checkInsQueue){
  if (trace) {
    logger.trace(sputs(""String_Node_Str"",checkInsQueue));
  }
  ServiceHealthCheckIn checkIn=checkInsQueue.poll();
  if (checkIn != null) {
    Consul consul=consulThreadLocal.get();
    while (checkIn != null) {
      Status status=convertStatus(checkIn.getHealthStatus());
      try {
        consul.agent().checkTtl(checkIn.getServiceId(),status,""String_Node_Str"" + checkIn.getHealthStatus());
      }
 catch (      Exception ex) {
        handleConsulRecovery(consul,ex);
      }
      checkIn=checkInsQueue.poll();
    }
  }
}","@Override public void checkIn(final Queue<ServiceHealthCheckIn> checkInsQueue){
  if (trace) {
    logger.trace(sputs(""String_Node_Str"",checkInsQueue));
  }
  ServiceHealthCheckIn checkIn=checkInsQueue.poll();
  if (checkIn != null) {
    Consul consul=consul();
    try {
      while (checkIn != null) {
        Status status=convertStatus(checkIn.getHealthStatus());
        consul.agent().checkTtl(checkIn.getServiceId(),status,""String_Node_Str"" + checkIn.getHealthStatus());
        checkIn=checkInsQueue.poll();
      }
    }
 catch (    Exception ex) {
      handleConsulRecovery(consul,ex);
    }
 finally {
      shutDownConsul(consul);
    }
  }
}"
3858,"private List<ServiceHealth> getHealthyServices(final String serviceName){
  Consul consul=consulThreadLocal.get();
  try {
    String tag=tags.length > 1 ? tags[0] : null;
    final ConsulResponse<List<ServiceHealth>> consulResponse=consul.health().getHealthyServices(serviceName,datacenter,tag,buildRequestOptions());
    this.lastIndex.set(consulResponse.getIndex());
    final List<ServiceHealth> healthyServices=consulResponse.getResponse();
    return healthyServices;
  }
 catch (  HttpClientClosedConnectionException ex) {
    handleConsulRecovery(consul,ex);
    return Collections.emptyList();
  }
}","private List<ServiceHealth> getHealthyServices(final String serviceName){
  Consul consul=consul();
  try {
    String tag=tags.length > 1 ? tags[0] : null;
    final ConsulResponse<List<ServiceHealth>> consulResponse=consul.health().getHealthyServices(serviceName,datacenter,tag,buildRequestOptions());
    this.lastIndex.set(consulResponse.getIndex());
    final List<ServiceHealth> healthyServices=consulResponse.getResponse();
    return healthyServices;
  }
 catch (  HttpClientClosedConnectionException ex) {
    handleConsulRecovery(consul,ex);
    return Collections.emptyList();
  }
 finally {
    shutDownConsul(consul);
  }
}"
3859,"public HttpRequestServiceServerHandlerUsingMetaImpl(int timeoutInSeconds,ServiceBundle serviceBundle,JsonMapper jsonMapper,final int numberOfOutstandingRequests,int flushInterval){
  this.timeoutInSeconds=timeoutInSeconds;
  lastTimeoutCheckTime=Timer.timer().now() + (timeoutInSeconds * 1000);
  this.numberOfOutstandingRequests=numberOfOutstandingRequests;
  this.jsonMapper=jsonMapper;
  this.methodCallSendQueue=serviceBundle.methodSendQueue();
  this.flushInterval=flushInterval;
  contextMetaBuilder=ContextMetaBuilder.contextMetaBuilder();
}","public HttpRequestServiceServerHandlerUsingMetaImpl(int timeoutInSeconds,ServiceBundle serviceBundle,JsonMapper jsonMapper,final int numberOfOutstandingRequests,int flushInterval){
  this.timeoutInSeconds=timeoutInSeconds;
  lastTimeoutCheckTime.set(Timer.timer().now() + (timeoutInSeconds * 1000));
  this.numberOfOutstandingRequests=numberOfOutstandingRequests;
  this.jsonMapper=jsonMapper;
  this.methodCallSendQueue=serviceBundle.methodSendQueue();
  this.flushInterval=flushInterval;
  contextMetaBuilder=ContextMetaBuilder.contextMetaBuilder();
}"
3860,"@Override public void checkTimeoutsForRequests(){
  final long now=Timer.timer().now();
  final long durationSinceLastCheck=now - lastTimeoutCheckTime;
  final long timeoutInMS=timeoutInSeconds * 1000;
  final boolean timedOut=durationSinceLastCheck > timeoutInMS;
  if (!(timedOut)) {
    return;
  }
  if (debug) {
    puts(""String_Node_Str"",""String_Node_Str"",durationSinceLastCheck,""String_Node_Str"",timeoutInMS);
  }
  executorService.submit(new Runnable(){
    @Override public void run(){
      lastTimeoutCheckTime=now;
      long duration;
      final Set<Map.Entry<String,Request<Object>>> entries=outstandingRequestMap.entrySet();
      for (      Map.Entry<String,Request<Object>> requestEntry : entries) {
        final Request<Object> request=requestEntry.getValue();
        duration=now - request.timestamp();
        if (duration > timeoutInMS) {
          if (!request.isHandled()) {
            if (debug) {
              puts(""String_Node_Str"",""String_Node_Str"",duration,""String_Node_Str"",timeoutInMS);
            }
            handleMethodTimedOut(requestEntry.getKey(),request);
          }
        }
      }
    }
  }
);
}","@Override public void checkTimeoutsForRequests(){
  final long now=Timer.timer().now();
  final long durationSinceLastCheck=now - lastTimeoutCheckTime.get();
  final long timeoutInMS=timeoutInSeconds * 1000;
  final boolean timedOut=durationSinceLastCheck > timeoutInMS;
  if (!(timedOut)) {
    return;
  }
  lastTimeoutCheckTime.set(now);
  long duration;
  final Set<Map.Entry<String,Request<Object>>> entries=outstandingRequestMap.entrySet();
  for (  Map.Entry<String,Request<Object>> requestEntry : entries) {
    final Request<Object> request=requestEntry.getValue();
    final String key=requestEntry.getKey();
    if (request.isHandled()) {
      request.handled();
      outstandingRequestMap.remove(key);
      continue;
    }
    duration=now - request.timestamp();
    if (duration > timeoutInMS) {
      final HttpResponseReceiver httpResponse=((HttpRequest)request).getReceiver();
      try {
        httpResponse.response(408,""String_Node_Str"",""String_Node_Str"");
      }
 catch (      Exception ex) {
        logger.debug(""String_Node_Str"" + request,ex);
      }
    }
  }
}"
3861,"@Override public void handleResponseFromServiceToHttpResponse(Response<Object> response,HttpRequest originatingRequest){
  String key=Str.add(""String_Node_Str"" + originatingRequest.id(),""String_Node_Str"",originatingRequest.returnAddress());
  this.outstandingRequestMap.remove(key);
  final HttpRequest httpRequest=originatingRequest;
  if (response.wasErrors()) {
    Object obj=response.body();
    if (obj instanceof ServiceMethodNotFoundException) {
      writeResponse(httpRequest.getReceiver(),404,""String_Node_Str"",jsonMapper.toJson(response.body()),httpRequest.getHeaders());
    }
 else {
      writeResponse(httpRequest.getReceiver(),500,""String_Node_Str"",jsonMapper.toJson(response.body()),httpRequest.getHeaders());
    }
  }
 else {
    writeResponse(httpRequest.getReceiver(),200,""String_Node_Str"",jsonMapper.toJson(response.body()),httpRequest.getHeaders());
  }
}","@Override public void handleResponseFromServiceToHttpResponse(final Response<Object> response,final HttpRequest originatingRequest){
  String key=Str.add(""String_Node_Str"" + originatingRequest.id(),""String_Node_Str"",originatingRequest.returnAddress());
  this.outstandingRequestMap.remove(key);
  final HttpRequest httpRequest=originatingRequest;
  if (response.wasErrors()) {
    Object obj=response.body();
    if (obj instanceof ServiceMethodNotFoundException) {
      writeResponse(httpRequest.getReceiver(),404,""String_Node_Str"",jsonMapper.toJson(response.body()),httpRequest.getHeaders());
    }
 else {
      writeResponse(httpRequest.getReceiver(),500,""String_Node_Str"",jsonMapper.toJson(response.body()),httpRequest.getHeaders());
    }
  }
 else {
    writeResponse(httpRequest.getReceiver(),200,""String_Node_Str"",jsonMapper.toJson(response.body()),httpRequest.getHeaders());
  }
}"
3862,"@Override public boolean isHandled(){
  return handled;
}","@Override public synchronized boolean isHandled(){
  return handled;
}"
3863,"@Override public void handled(){
  handled=true;
}","@Override public synchronized void handled(){
  handled=true;
}"
3864,"private void flushEventManagerCalls(){
  final EventManager eventManager=factory().eventManagerProxy();
  if (eventManager != null) {
    ServiceProxyUtils.flushServiceProxy(eventManager);
    factory().clearEventManagerProxy();
  }
}","private void flushEventManagerCalls(){
  final EventManager eventManager=factory.eventManagerProxy();
  if (eventManager != null) {
    ServiceProxyUtils.flushServiceProxy(eventManager);
    factory.clearEventManagerProxy();
  }
}"
3865,"public BaseServiceQueueImpl(final String rootAddress,final String serviceAddress,final Object service,final QueueBuilder requestQueueBuilder,final QueueBuilder responseQueueBuilder,final ServiceMethodHandler serviceMethodHandler,final Queue<Response<Object>> responseQueue,final boolean async,final boolean handleCallbacks,final QBitSystemManager systemManager){
  if (requestQueueBuilder == null) {
    this.requestQueueBuilder=new QueueBuilder();
  }
 else {
    this.requestQueueBuilder=BeanUtils.copy(requestQueueBuilder);
  }
  if (responseQueueBuilder == null) {
    this.responseQueueBuilder=new QueueBuilder();
  }
 else {
    this.responseQueueBuilder=BeanUtils.copy(responseQueueBuilder);
  }
  if (responseQueue == null) {
    logger.info(""String_Node_Str"");
    this.responseQueue=this.responseQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  }
 else {
    this.responseQueue=responseQueue;
  }
  this.responseSendQueue=this.responseQueue.sendQueue();
  this.service=service;
  this.serviceMethodHandler=serviceMethodHandler;
  this.serviceMethodHandler.init(service,rootAddress,serviceAddress,responseSendQueue);
  this.eventQueue=this.requestQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  this.handleCallbacks=handleCallbacks;
  this.requestQueue=initRequestQueue(serviceMethodHandler,async);
  this.systemManager=systemManager;
}","public BaseServiceQueueImpl(final String rootAddress,final String serviceAddress,final Object service,final QueueBuilder requestQueueBuilder,final QueueBuilder responseQueueBuilder,final ServiceMethodHandler serviceMethodHandler,final Queue<Response<Object>> responseQueue,final boolean async,final boolean handleCallbacks,final QBitSystemManager systemManager){
  if (requestQueueBuilder == null) {
    this.requestQueueBuilder=new QueueBuilder();
  }
 else {
    this.requestQueueBuilder=BeanUtils.copy(requestQueueBuilder);
  }
  if (responseQueueBuilder == null) {
    this.responseQueueBuilder=new QueueBuilder();
  }
 else {
    this.responseQueueBuilder=BeanUtils.copy(responseQueueBuilder);
  }
  if (responseQueue == null) {
    logger.info(""String_Node_Str"");
    this.responseQueue=this.responseQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  }
 else {
    this.responseQueue=responseQueue;
  }
  this.responseSendQueue=this.responseQueue.sendQueue();
  this.service=service;
  this.serviceMethodHandler=serviceMethodHandler;
  this.serviceMethodHandler.init(service,rootAddress,serviceAddress,responseSendQueue);
  this.eventQueue=this.requestQueueBuilder.setName(""String_Node_Str"" + serviceMethodHandler.address()).build();
  this.handleCallbacks=handleCallbacks;
  this.requestQueue=initRequestQueue(serviceMethodHandler,async);
  this.systemManager=systemManager;
  this.factory=factory();
}"
3866,"public void recordCount(String name,int count){
  recordWithTime(name,count,now);
}","public void recordCount(String name,int count){
  recordCountWithTime(name,count,now);
}"
3867,"public void increment(String name){
  recordWithTime(name,1,now);
}","public void increment(String name){
  recordCountWithTime(name,1,now);
}"
3868,"public void recordAllCountsWithTimes(final String[] names,final int[] counts,final long[] times){
  for (int index=0; index < names.length; index++) {
    String name=names[index];
    int count=counts[index];
    long now=times[index];
    recordWithTime(name,count,now);
  }
}","public void recordAllCountsWithTimes(final String[] names,final int[] counts,final long[] times){
  for (int index=0; index < names.length; index++) {
    String name=names[index];
    int count=counts[index];
    long now=times[index];
    recordCountWithTime(name,count,now);
  }
}"
3869,"public void recordAllCounts(final long timestamp,final String[] names,final int[] counts){
  for (int index=0; index < names.length; index++) {
    String name=names[index];
    int count=counts[index];
    recordWithTime(name,count,timestamp);
  }
}","public void recordAllCounts(final long timestamp,final String[] names,final int[] counts){
  for (int index=0; index < names.length; index++) {
    String name=names[index];
    int count=counts[index];
    recordCountWithTime(name,count,timestamp);
  }
}"
3870,"private void copyHeaders(HttpRequest request,Request jettyRequest){
  final MultiMap<String,String> headers=request.getHeaders();
  final Iterator<Map.Entry<String,Collection<String>>> iterator=headers.iterator();
  final HttpFields headerFields=jettyRequest.getHeaders();
  while (iterator.hasNext()) {
    final Map.Entry<String,Collection<String>> entry=iterator.next();
    final String paramName=entry.getKey();
    final Collection<String> values=entry.getValue();
    for (    String value : values) {
      headerFields.add(paramName,value);
      if (debug)       logger.debug(""String_Node_Str"" + paramName + ""String_Node_Str""+ value);
    }
  }
}","private void copyHeaders(HttpRequest request,Request jettyRequest){
  final MultiMap<String,String> headers=request.getHeaders();
  final Iterator<Map.Entry<String,Collection<String>>> iterator=headers.iterator();
  while (iterator.hasNext()) {
    final Map.Entry<String,Collection<String>> entry=iterator.next();
    final String headerName=entry.getKey();
    final Collection<String> values=entry.getValue();
    for (    String value : values) {
      jettyRequest.header(headerName,value);
      if (debug)       logger.debug(""String_Node_Str"" + headerName + ""String_Node_Str""+ value);
    }
  }
}"
3871,"@Override public <T>T createProxyWithChannelPrefix(final EventManager eventManager,final Class<T> eventBusProxyInterface,final String channelPrefix){
  if (!eventBusProxyInterface.isInterface()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final Map<String,String> methodToChannelMap=createMethodToChannelMap(channelPrefix,eventBusProxyInterface);
  final InvocationHandler invocationHandler=(proxy,method,args) -> {
    if (flushMethodNameSet.contains(method.getName())) {
      flushServiceProxy(eventManager);
      return null;
    }
    final String channelName=methodToChannelMap.get(method.toString());
    eventManager.sendArray(channelName,args);
    return null;
  }
;
  final Object o=Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),new Class[]{eventBusProxyInterface,ClientProxy.class},invocationHandler);
  return (T)o;
}","@Override public <T>T createProxyWithChannelPrefix(final EventManager eventManager,final Class<T> eventBusProxyInterface,final String channelPrefix){
  if (!eventBusProxyInterface.isInterface()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final Map<String,String> methodToChannelMap=createMethodToChannelMap(channelPrefix,eventBusProxyInterface);
  final InvocationHandler invocationHandler=(proxy,method,args) -> {
    if (flushMethodNameSet.contains(method.getName())) {
      flushServiceProxy(eventManager);
      return null;
    }
    final String channelName=methodToChannelMap.get(method.toString());
    eventManager.sendArray(channelName,args);
    return null;
  }
;
  final Object o=Proxy.newProxyInstance(eventBusProxyInterface.getClassLoader(),new Class[]{eventBusProxyInterface,ClientProxy.class},invocationHandler);
  return (T)o;
}"
3872,"@Override public final boolean serializeField(JsonSerializerInternal serializer,Object parent,FieldAccess fieldAccess,CharBuf builder){
  final String fieldName=fieldAccess.alias();
  final TypeType typeEnum=fieldAccess.typeEnum();
  if (useAnnotations && fieldAccess.ignore()) {
    return false;
  }
  if (useAnnotations && view != null && !fieldAccess.isViewActive(view)) {
    return false;
  }
  final boolean include=(useAnnotations && fieldAccess.include());
  if (filterProperties != null) {
    for (    FieldFilter filter : filterProperties) {
      if (!filter.include(parent,fieldAccess)) {
        return false;
      }
    }
  }
  if (customFieldSerializerMap != null) {
    final CustomFieldSerializer customFieldSerializer=customFieldSerializerMap.get(fieldAccess.name());
    if (customFieldSerializer.serializeField(serializer,parent,fieldAccess,builder)) {
      return true;
    }
  }
  if (customFieldSerializers != null) {
    for (    CustomFieldSerializer cfs : customFieldSerializers) {
      if (cfs.serializeField(serializer,parent,fieldAccess,builder) == true) {
        return true;
      }
    }
  }
switch (typeEnum) {
case INT:
    int value=fieldAccess.getInt(parent);
  if (includeDefault || include || value != 0) {
    serializeFieldName(fieldName,builder);
    builder.addInt(value);
    return true;
  }
return false;
case BOOLEAN:
boolean bvalue=fieldAccess.getBoolean(parent);
if (includeDefault || include || bvalue) {
serializeFieldName(fieldName,builder);
builder.addBoolean(bvalue);
return true;
}
return false;
case BYTE:
byte byvalue=fieldAccess.getByte(parent);
if (includeDefault || include || byvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addByte(byvalue);
return true;
}
return false;
case LONG:
long lvalue=fieldAccess.getLong(parent);
if (includeDefault || include || lvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addLong(lvalue);
return true;
}
return false;
case DOUBLE:
double dvalue=fieldAccess.getDouble(parent);
if (includeDefault || include || dvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addDouble(dvalue);
return true;
}
return false;
case FLOAT:
float fvalue=fieldAccess.getFloat(parent);
if (includeDefault || include || fvalue != 0.0f) {
serializeFieldName(fieldName,builder);
builder.addFloat(fvalue);
return true;
}
return false;
case SHORT:
short svalue=fieldAccess.getShort(parent);
if (includeDefault || include || svalue != 0) {
serializeFieldName(fieldName,builder);
builder.addShort(svalue);
return true;
}
return false;
case CHAR:
char cvalue=fieldAccess.getChar(parent);
if (includeDefault || include || cvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addQuoted(""String_Node_Str"" + cvalue);
return true;
}
return false;
}
Object value=fieldAccess.getObject(parent);
if (!includeNulls && !include && value == null) {
return false;
}
if ((includeNulls || fieldAccess.include()) && value == null) {
serializeFieldName(fieldName,builder);
builder.addNull();
return true;
}
switch (typeEnum) {
case BIG_DECIMAL:
serializeFieldName(fieldName,builder);
builder.addBigDecimal((BigDecimal)value);
return true;
case BIG_INT:
serializeFieldName(fieldName,builder);
builder.addBigInteger((BigInteger)value);
return true;
case DATE:
serializeFieldName(fieldName,builder);
serializer.serializeDate((Date)value,builder);
return true;
case STRING:
String string=(String)value;
if (includeEmpty || include || string.length() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeString(string,builder);
return true;
}
return false;
case CLASS:
serializeFieldName(fieldName,builder);
builder.addQuoted(((Class)value).getName());
return true;
case TIME_ZONE:
serializeFieldName(fieldName,builder);
TimeZone zone=(TimeZone)value;
builder.addQuoted(zone.getID());
return true;
case CHAR_SEQUENCE:
String s2=value.toString();
if (includeEmpty || include || s2.length() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeString(s2,builder);
return true;
}
return false;
case INTEGER_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addInt((Integer)value);
return true;
case LONG_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addLong((Long)value);
return true;
case FLOAT_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addFloat((Float)value);
return true;
case DOUBLE_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addDouble((Double)value);
return true;
case SHORT_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addShort((Short)value);
return true;
case BYTE_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addByte((Byte)value);
return true;
case CHAR_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addQuoted(value.toString());
return true;
case ENUM:
serializeFieldName(fieldName,builder);
builder.addQuoted(value.toString());
return true;
case COLLECTION:
case LIST:
case SET:
Collection collection=(Collection)value;
if (includeEmpty || include || collection.size() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeCollection(collection,builder);
return true;
}
return false;
case MAP:
Map map=(Map)value;
if (includeEmpty || include || map.size() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeMap(map,builder);
return true;
}
return false;
case ARRAY:
case ARRAY_INT:
case ARRAY_BYTE:
case ARRAY_SHORT:
case ARRAY_FLOAT:
case ARRAY_DOUBLE:
case ARRAY_LONG:
case ARRAY_STRING:
case ARRAY_OBJECT:
if (includeEmpty || include || Arry.len(value) > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeArray(value,builder);
return true;
}
return false;
case INTERFACE:
case ABSTRACT:
if (handleSimpleBackReference && value == parent) {
return false;
}
 else if (handleComplexBackReference) {
if (idMap.containsKey(value)) {
return false;
}
 else {
idMap.put(value,value);
}
}
serializeFieldName(fieldName,builder);
if (overrideMap != null) {
SerializeUtils.handleInstance(serializer,value,builder,overrideMap,noHandle,false,typeEnum);
}
 else {
serializer.serializeSubtypeInstance(value,builder);
}
return true;
case INSTANCE:
if (handleSimpleBackReference && value == parent) {
return false;
}
 else if (handleComplexBackReference) {
if (idMap.containsKey(value)) {
return false;
}
 else {
idMap.put(value,value);
}
}
serializeFieldName(fieldName,builder);
if (overrideMap != null) {
SerializeUtils.handleInstance(serializer,value,builder,overrideMap,noHandle,false,typeEnum);
}
 else {
if (fieldAccess.type() == value.getClass()) {
serializer.serializeInstance(value,builder);
}
 else {
serializer.serializeSubtypeInstance(value,builder);
}
}
return true;
case CURRENCY:
serializeFieldName(fieldName,builder);
builder.addCurrency((Currency)value);
return true;
default :
serializeFieldName(fieldName,builder);
serializer.serializeUnknown(value,builder);
return true;
}
}","@Override public final boolean serializeField(JsonSerializerInternal serializer,Object parent,FieldAccess fieldAccess,CharBuf builder){
  final String fieldName=fieldAccess.alias();
  TypeType typeEnum=fieldAccess.typeEnum();
  if (useAnnotations && fieldAccess.ignore()) {
    return false;
  }
  if (useAnnotations && view != null && !fieldAccess.isViewActive(view)) {
    return false;
  }
  final boolean include=(useAnnotations && fieldAccess.include());
  if (filterProperties != null) {
    for (    FieldFilter filter : filterProperties) {
      if (!filter.include(parent,fieldAccess)) {
        return false;
      }
    }
  }
  if (customFieldSerializerMap != null) {
    final CustomFieldSerializer customFieldSerializer=customFieldSerializerMap.get(fieldAccess.name());
    if (customFieldSerializer.serializeField(serializer,parent,fieldAccess,builder)) {
      return true;
    }
  }
  if (customFieldSerializers != null) {
    for (    CustomFieldSerializer cfs : customFieldSerializers) {
      if (cfs.serializeField(serializer,parent,fieldAccess,builder) == true) {
        return true;
      }
    }
  }
switch (typeEnum) {
case INT:
    int value=fieldAccess.getInt(parent);
  if (includeDefault || include || value != 0) {
    serializeFieldName(fieldName,builder);
    builder.addInt(value);
    return true;
  }
return false;
case BOOLEAN:
boolean bvalue=fieldAccess.getBoolean(parent);
if (includeDefault || include || bvalue) {
serializeFieldName(fieldName,builder);
builder.addBoolean(bvalue);
return true;
}
return false;
case BYTE:
byte byvalue=fieldAccess.getByte(parent);
if (includeDefault || include || byvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addByte(byvalue);
return true;
}
return false;
case LONG:
long lvalue=fieldAccess.getLong(parent);
if (includeDefault || include || lvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addLong(lvalue);
return true;
}
return false;
case DOUBLE:
double dvalue=fieldAccess.getDouble(parent);
if (includeDefault || include || dvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addDouble(dvalue);
return true;
}
return false;
case FLOAT:
float fvalue=fieldAccess.getFloat(parent);
if (includeDefault || include || fvalue != 0.0f) {
serializeFieldName(fieldName,builder);
builder.addFloat(fvalue);
return true;
}
return false;
case SHORT:
short svalue=fieldAccess.getShort(parent);
if (includeDefault || include || svalue != 0) {
serializeFieldName(fieldName,builder);
builder.addShort(svalue);
return true;
}
return false;
case CHAR:
char cvalue=fieldAccess.getChar(parent);
if (includeDefault || include || cvalue != 0) {
serializeFieldName(fieldName,builder);
builder.addQuoted(""String_Node_Str"" + cvalue);
return true;
}
return false;
case OBJECT:
typeEnum=TypeType.getInstanceType(fieldAccess.getObject(parent));
break;
}
Object value=fieldAccess.getObject(parent);
if (!includeNulls && !include && value == null) {
return false;
}
if ((includeNulls || fieldAccess.include()) && value == null) {
serializeFieldName(fieldName,builder);
builder.addNull();
return true;
}
switch (typeEnum) {
case BIG_DECIMAL:
serializeFieldName(fieldName,builder);
builder.addBigDecimal((BigDecimal)value);
return true;
case BIG_INT:
serializeFieldName(fieldName,builder);
builder.addBigInteger((BigInteger)value);
return true;
case DATE:
serializeFieldName(fieldName,builder);
serializer.serializeDate((Date)value,builder);
return true;
case STRING:
String string=(String)value;
if (includeEmpty || include || string.length() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeString(string,builder);
return true;
}
return false;
case CLASS:
serializeFieldName(fieldName,builder);
builder.addQuoted(((Class)value).getName());
return true;
case TIME_ZONE:
serializeFieldName(fieldName,builder);
TimeZone zone=(TimeZone)value;
builder.addQuoted(zone.getID());
return true;
case CHAR_SEQUENCE:
String s2=value.toString();
if (includeEmpty || include || s2.length() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeString(s2,builder);
return true;
}
return false;
case INTEGER_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addInt((Integer)value);
return true;
case LONG_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addLong((Long)value);
return true;
case FLOAT_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addFloat((Float)value);
return true;
case DOUBLE_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addDouble((Double)value);
return true;
case SHORT_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addShort((Short)value);
return true;
case BYTE_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addByte((Byte)value);
return true;
case CHAR_WRAPPER:
serializeFieldName(fieldName,builder);
builder.addQuoted(value.toString());
return true;
case ENUM:
serializeFieldName(fieldName,builder);
builder.addQuoted(value.toString());
return true;
case COLLECTION:
case LIST:
case SET:
Collection collection=(Collection)value;
if (includeEmpty || include || collection.size() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeCollection(collection,builder);
return true;
}
return false;
case MAP:
Map map=(Map)value;
if (includeEmpty || include || map.size() > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeMap(map,builder);
return true;
}
return false;
case ARRAY:
case ARRAY_INT:
case ARRAY_BYTE:
case ARRAY_SHORT:
case ARRAY_FLOAT:
case ARRAY_DOUBLE:
case ARRAY_LONG:
case ARRAY_STRING:
case ARRAY_OBJECT:
if (includeEmpty || include || Arry.len(value) > 0) {
serializeFieldName(fieldName,builder);
serializer.serializeArray(value,builder);
return true;
}
return false;
case INTERFACE:
case ABSTRACT:
if (handleSimpleBackReference && value == parent) {
return false;
}
 else if (handleComplexBackReference) {
if (idMap.containsKey(value)) {
return false;
}
 else {
idMap.put(value,value);
}
}
serializeFieldName(fieldName,builder);
if (overrideMap != null) {
SerializeUtils.handleInstance(serializer,value,builder,overrideMap,noHandle,false,typeEnum);
}
 else {
serializer.serializeSubtypeInstance(value,builder);
}
return true;
case INSTANCE:
if (handleSimpleBackReference && value == parent) {
return false;
}
 else if (handleComplexBackReference) {
if (idMap.containsKey(value)) {
return false;
}
 else {
idMap.put(value,value);
}
}
serializeFieldName(fieldName,builder);
if (overrideMap != null) {
SerializeUtils.handleInstance(serializer,value,builder,overrideMap,noHandle,false,typeEnum);
}
 else {
if (fieldAccess.type() == value.getClass()) {
serializer.serializeInstance(value,builder);
}
 else {
serializer.serializeSubtypeInstance(value,builder);
}
}
return true;
case CURRENCY:
serializeFieldName(fieldName,builder);
builder.addCurrency((Currency)value);
return true;
default :
serializeFieldName(fieldName,builder);
serializer.serializeUnknown(value,builder);
return true;
}
}"
3873,"@Override public <T>void forwardEvent(final EventTransferObject<Object> event){
  eventBus.forwardEvent(event);
}","@Override public <T>void forwardEvent(final EventTransferObject<Object> event){
  messageCountSinceLastFlush++;
  eventBus.forwardEvent(event);
}"
3874,"private EventManager createEventManager(){
  final EventManager eventManagerImpl=eventManagerBuilder().setEventConnector(eventConnectorHub).build();
  eventServiceQueue=serviceBuilder().setServiceObject(eventManagerImpl).build();
  return eventServiceQueue.createProxyWithAutoFlush(EventManager.class,periodicScheduler,100,TimeUnit.MILLISECONDS);
}","private EventManager createEventManager(){
  eventManagerImpl=eventManagerBuilder().setEventConnector(eventConnectorHub).build();
  eventServiceQueue=serviceBuilder().setServiceObject(eventManagerImpl).build();
  return eventServiceQueue.createProxyWithAutoFlush(EventManager.class,periodicScheduler,100,TimeUnit.MILLISECONDS);
}"
3875,"private EventManager wrapEventManager(final EventManager eventManager){
  if (eventManager instanceof ClientProxy) {
    return eventManager;
  }
 else {
    eventServiceQueue=serviceBuilder().setServiceObject(eventManager).build();
    return eventServiceQueue.createProxyWithAutoFlush(EventManager.class,periodicScheduler,100,TimeUnit.MILLISECONDS);
  }
}","private EventManager wrapEventManager(final EventManager eventManager){
  if (eventManager instanceof ClientProxy) {
    return eventManager;
  }
 else {
    eventManagerImpl=eventManager;
    eventServiceQueue=serviceBuilder().setServiceObject(eventManager).build();
    return eventServiceQueue.createProxyWithAutoFlush(EventManager.class,periodicScheduler,100,TimeUnit.MILLISECONDS);
  }
}"
3876,"private void copyParams(HttpRequest request,Request jettyRequest){
  final MultiMap<String,String> params=request.getParams();
  final Iterator<Map.Entry<String,Collection<String>>> iterator=params.iterator();
  while (iterator.hasNext()) {
    final Map.Entry<String,Collection<String>> entry=iterator.next();
    final String paramName=entry.getKey();
    final Collection<String> values=entry.getValue();
    for (    String value : values) {
      jettyRequest.param(paramName,value);
      if (debug)       puts(""String_Node_Str"",paramName,value);
    }
  }
}","private void copyParams(HttpRequest request,Request jettyRequest){
  final MultiMap<String,String> params=request.getParams();
  final Iterator<Map.Entry<String,Collection<String>>> iterator=params.iterator();
  while (iterator.hasNext()) {
    final Map.Entry<String,Collection<String>> entry=iterator.next();
    final String paramName=entry.getKey();
    final Collection<String> values=entry.getValue();
    for (    String value : values) {
      jettyRequest.param(paramName,value);
    }
  }
}"
3877,"public static HttpRequestBuilder getHttpRequestBuilder(String datacenter,String tag,RequestOptions requestOptions,String path){
  final HttpRequestBuilder httpRequestBuilder=HttpRequestBuilder.httpRequestBuilder();
  httpRequestBuilder.setUri(path);
  if (!Str.isEmpty(datacenter)) {
    httpRequestBuilder.addParam(""String_Node_Str"",datacenter);
  }
  if (!Str.isEmpty(tag)) {
    httpRequestBuilder.addParam(""String_Node_Str"",tag);
  }
  if (requestOptions.isBlocking()) {
    httpRequestBuilder.addParam(""String_Node_Str"",requestOptions.getWait());
    httpRequestBuilder.addParam(""String_Node_Str"",String.valueOf(requestOptions.getIndex()));
  }
  if (requestOptions.getConsistency() == Consistency.CONSISTENT) {
    httpRequestBuilder.addParam(""String_Node_Str"",""String_Node_Str"");
  }
  if (requestOptions.getConsistency() == Consistency.STALE) {
    httpRequestBuilder.addParam(""String_Node_Str"",""String_Node_Str"");
  }
  return httpRequestBuilder;
}","public static HttpRequestBuilder getHttpRequestBuilder(final String datacenter,final String tag,final RequestOptions requestOptions,final String path){
  final HttpRequestBuilder httpRequestBuilder=HttpRequestBuilder.httpRequestBuilder();
  httpRequestBuilder.setUri(cleanURI(path));
  if (!Str.isEmpty(datacenter)) {
    httpRequestBuilder.addParam(""String_Node_Str"",datacenter);
  }
  if (!Str.isEmpty(tag)) {
    httpRequestBuilder.addParam(""String_Node_Str"",tag);
  }
  if (requestOptions.isBlocking()) {
    httpRequestBuilder.addParam(""String_Node_Str"",requestOptions.getWait());
    httpRequestBuilder.addParam(""String_Node_Str"",String.valueOf(requestOptions.getIndex()));
  }
  if (requestOptions.getConsistency() == Consistency.CONSISTENT) {
    httpRequestBuilder.addParam(""String_Node_Str"",""String_Node_Str"");
  }
  if (requestOptions.getConsistency() == Consistency.STALE) {
    httpRequestBuilder.addParam(""String_Node_Str"",""String_Node_Str"");
  }
  return httpRequestBuilder;
}"
3878,"default ServiceServer addService(String address,ServiceQueue serviceQueue){
  serviceBundle().addServiceObject(address,serviceQueue);
  return this;
}","default ServiceServer addService(String address,ServiceQueue serviceQueue){
  serviceBundle().addService(address,serviceQueue);
  return this;
}"
3879,"@Override public void recordCount(String name,int count,long now){
  this.count+=count;
  if (out)   puts(""String_Node_Str"",name,count,now);
}","@Override public void recordCount(String name,int count,long now){
  this.count.addAndGet(count);
  if (out)   puts(""String_Node_Str"",name,count,now);
}"
3880,"@Test public void testRecord() throws Exception {
  statServiceClient.recordCount(""String_Node_Str"",1);
  serviceBundle.flush();
  triggerLatchWhen(o -> replicator.count == 1);
  waitForLatch(20);
  ok=replicator.count == 1 || die();
}","@Test public void testRecord() throws Exception {
  statServiceClient.recordCount(""String_Node_Str"",1);
  serviceBundle.flush();
  triggerLatchWhen(o -> replicator.count.get() == 1);
  waitForLatch(20);
  ok=replicator.count.get() == 1 || die();
}"
3881,"@Test public void testRecordAll() throws Exception {
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  statServiceClient.recordAllCounts(Timer.timer().now(),names,counts);
  serviceBundle.flush();
  triggerLatchWhen(o -> replicator.count == 3);
  waitForLatch(20);
  ok=replicator.count == 3 || die(replicator.count);
}","@Test public void testRecordAll() throws Exception {
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  statServiceClient.recordAllCounts(Timer.timer().now(),names,counts);
  serviceBundle.flush();
  triggerLatchWhen(o -> replicator.count.get() == 3);
  waitForLatch(20);
  ok=replicator.count.get() == 3 || die(replicator.count);
}"
3882,"@Test public void testRecordAll() throws Exception {
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  statService.recordAllCounts(Timer.timer().now(),names,counts);
  ok=replicator.count == 3 || die(replicator.count);
  ok=recorder.count == 0 || die(recorder.count);
  statService.process();
  statService.queueLimit();
  statService.queueEmpty();
  ok=recorder.count == 0 || die(recorder.count);
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 2 || die(recorder.count);
}","@Test public void testRecordAll() throws Exception {
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  statService.recordAllCounts(Timer.timer().now(),names,counts);
  ok=replicator.count.get() == 3 || die(replicator.count);
  ok=recorder.count == 0 || die(recorder.count);
  statService.process();
  statService.queueLimit();
  statService.queueEmpty();
  ok=recorder.count == 0 || die(recorder.count);
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 2 || die(recorder.count);
}"
3883,"@Test public void testRecord() throws Exception {
  statService.recordCount(""String_Node_Str"",1);
  ok=replicator.count == 1 || die();
  ok=recorder.count == 0 || die();
  statService.process();
  statService.queueLimit();
  statService.queueEmpty();
  ok=recorder.count == 0 || die();
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 1 || die();
}","@Test public void testRecord() throws Exception {
  statService.recordCount(""String_Node_Str"",1);
  ok=replicator.count.get() == 1 || die();
  ok=recorder.count == 0 || die();
  statService.process();
  statService.queueLimit();
  statService.queueEmpty();
  ok=recorder.count == 0 || die();
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 1 || die();
}"
3884,"@Test public void testReplicators() throws Exception {
  statService=new StatServiceBuilder().setRecorder(recorder).addReplicator(replicator).addReplicator(replicator).addReplicator(new NoOpReplicator()).build();
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  long[] times=Lng.array(Timer.timer().now(),Timer.timer().now() + 2000);
  statService.recordAllCountsWithTimes(names,counts,times);
  ok=replicator.count == 6 || die(replicator.count);
  ok=recorder.count == 0 || die(recorder.count);
  statService.process();
  statService.queueLimit();
  statService.queueEmpty();
  ok=recorder.count == 0 || die(recorder.count);
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 2 || die(recorder.count);
  statService=new StatServiceBuilder().setRecorder(new NoOpRecorder()).addReplicator(replicator).addReplicator(replicator).addReplicator(new NoOpReplicator()).build();
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 2 || die(recorder.count);
}","@Test public void testReplicators() throws Exception {
  statService=new StatServiceBuilder().setRecorder(recorder).addReplicator(replicator).addReplicator(replicator).addReplicator(new NoOpReplicator()).build();
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  long[] times=Lng.array(Timer.timer().now(),Timer.timer().now() + 2000);
  statService.recordAllCountsWithTimes(names,counts,times);
  ok=replicator.count.get() == 6 || die(replicator.count);
  ok=recorder.count == 0 || die(recorder.count);
  statService.process();
  statService.queueLimit();
  statService.queueEmpty();
  ok=recorder.count == 0 || die(recorder.count);
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 2 || die(recorder.count);
  statService=new StatServiceBuilder().setRecorder(new NoOpRecorder()).addReplicator(replicator).addReplicator(replicator).addReplicator(new NoOpReplicator()).build();
  statService.time(System.currentTimeMillis() + 61 * 1000);
  statService.process();
  ok=recorder.count == 2 || die(recorder.count);
}"
3885,"@Override public <T>T createRemoteProxyWithReturnAddress(Class<T> serviceInterface,String address,String serviceName,String returnAddressArg,Sender<String> sender,BeforeMethodCall beforeMethodCall,int requestBatchSize){
  return remoteServiceProxyFactory.createProxyWithReturnAddress(serviceInterface,serviceName,returnAddressArg,new SenderEndPoint(this.createEncoder(),address,sender,beforeMethodCall,requestBatchSize));
}","@Override public <T>T createRemoteProxyWithReturnAddress(Class<T> serviceInterface,String address,String serviceName,String host,int port,String returnAddressArg,Sender<String> sender,BeforeMethodCall beforeMethodCall,int requestBatchSize){
  return remoteServiceProxyFactory.createProxyWithReturnAddress(serviceInterface,serviceName,host,port,returnAddressArg,new SenderEndPoint(this.createEncoder(),address,sender,beforeMethodCall,requestBatchSize));
}"
3886,"@Override public <T>T createProxy(Class<T> serviceInterface,String serviceName,EndPoint endPoint){
  return createProxyWithReturnAddress(serviceInterface,serviceName,""String_Node_Str"",endPoint);
}","@Override public <T>T createProxy(Class<T> serviceInterface,String serviceName,EndPoint endPoint){
  return createProxyWithReturnAddress(serviceInterface,serviceName,""String_Node_Str"",0,""String_Node_Str"",endPoint);
}"
3887,"@Override public <T>T createProxyWithReturnAddress(Class<T> serviceInterface,final String serviceName,String returnAddressArg,final EndPoint endPoint){
  final String objectAddress=endPoint != null ? Str.add(endPoint.address(),""String_Node_Str"",serviceName) : ""String_Node_Str"";
  if (!Str.isEmpty(returnAddressArg)) {
    returnAddressArg=Str.add(objectAddress,""String_Node_Str"" + UUID.randomUUID());
  }
  final String returnAddress=returnAddressArg;
  final ThreadLocal<CharBuf> addressCreatorBufRef=new ThreadLocal<CharBuf>(){
    @Override protected CharBuf initialValue(){
      return CharBuf.createCharBuf(255);
    }
  }
;
  InvocationHandler invocationHandler=new InvocationHandler(){
    long timestamp=Timer.timer().now();
    int times=10;
    @Override public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      long messageId=generatedMessageId++;
      if (method.getName().equals(""String_Node_Str"")) {
        endPoint.flush();
        return null;
      }
      times--;
      if (times == 0) {
        timestamp=Timer.timer().now();
        times=10;
      }
 else {
        timestamp++;
      }
      final CharBuf addressBuf=addressCreatorBufRef.get();
      addressBuf.recycle();
      addressBuf.add(objectAddress).add(""String_Node_Str"").add(method.getName());
      final String address=addressBuf.toString();
      final MethodCall<Object> call=factory.createMethodCallToBeEncodedAndSent(messageId,address,returnAddress,serviceName,method.getName(),timestamp,args,null);
      if (method.getName().equals(""String_Node_Str"")) {
        return ""String_Node_Str"";
      }
      endPoint.call(call);
      return null;
    }
  }
;
  final Object o=Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class[]{serviceInterface,ClientProxy.class},invocationHandler);
  return (T)o;
}","@Override public <T>T createProxyWithReturnAddress(final Class<T> serviceInterface,final String serviceName,final String host,final int port,String returnAddressArg,final EndPoint endPoint){
  final String objectAddress=endPoint != null ? Str.add(endPoint.address(),""String_Node_Str"",serviceName) : ""String_Node_Str"";
  if (!Str.isEmpty(returnAddressArg)) {
    returnAddressArg=Str.add(objectAddress,""String_Node_Str"" + UUID.randomUUID());
  }
  final String returnAddress=returnAddressArg;
  final ThreadLocal<CharBuf> addressCreatorBufRef=new ThreadLocal<CharBuf>(){
    @Override protected CharBuf initialValue(){
      return CharBuf.createCharBuf(255);
    }
  }
;
  InvocationHandler invocationHandler=new InvocationHandler(){
    long timestamp=Timer.timer().now();
    int times=10;
    @Override public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      long messageId=generatedMessageId++;
      if (method.getName().equals(""String_Node_Str"")) {
        endPoint.flush();
        return null;
      }
      times--;
      if (times == 0) {
        timestamp=Timer.timer().now();
        times=10;
      }
 else {
        timestamp++;
      }
      final CharBuf addressBuf=addressCreatorBufRef.get();
      addressBuf.recycle();
      addressBuf.add(objectAddress).add(""String_Node_Str"").add(method.getName());
      final String address=addressBuf.toString();
      final MethodCall<Object> call=factory.createMethodCallToBeEncodedAndSent(messageId,address,returnAddress,serviceName,method.getName(),timestamp,args,null);
switch (method.getName()) {
case ""String_Node_Str"":
        return port;
case ""String_Node_Str"":
      return host;
case ""String_Node_Str"":
    return port == 0 ? sputs(""String_Node_Str"",serviceName,""String_Node_Str"") : sputs(""String_Node_Str"",serviceName,host,port,""String_Node_Str"");
default :
  endPoint.call(call);
}
return null;
}
}
;
if (port == 0) {
return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class[]{serviceInterface,ClientProxy.class},invocationHandler);
}
 else {
return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(),new Class[]{serviceInterface,RemoteTCPClientProxy.class},invocationHandler);
}
}"
3888,"@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  long messageId=generatedMessageId++;
  if (method.getName().equals(""String_Node_Str"")) {
    endPoint.flush();
    return null;
  }
  times--;
  if (times == 0) {
    timestamp=Timer.timer().now();
    times=10;
  }
 else {
    timestamp++;
  }
  final CharBuf addressBuf=addressCreatorBufRef.get();
  addressBuf.recycle();
  addressBuf.add(objectAddress).add(""String_Node_Str"").add(method.getName());
  final String address=addressBuf.toString();
  final MethodCall<Object> call=factory.createMethodCallToBeEncodedAndSent(messageId,address,returnAddress,serviceName,method.getName(),timestamp,args,null);
  if (method.getName().equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  endPoint.call(call);
  return null;
}","@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  long messageId=generatedMessageId++;
  if (method.getName().equals(""String_Node_Str"")) {
    endPoint.flush();
    return null;
  }
  times--;
  if (times == 0) {
    timestamp=Timer.timer().now();
    times=10;
  }
 else {
    timestamp++;
  }
  final CharBuf addressBuf=addressCreatorBufRef.get();
  addressBuf.recycle();
  addressBuf.add(objectAddress).add(""String_Node_Str"").add(method.getName());
  final String address=addressBuf.toString();
  final MethodCall<Object> call=factory.createMethodCallToBeEncodedAndSent(messageId,address,returnAddress,serviceName,method.getName(),timestamp,args,null);
switch (method.getName()) {
case ""String_Node_Str"":
    return port;
case ""String_Node_Str"":
  return host;
case ""String_Node_Str"":
return port == 0 ? sputs(""String_Node_Str"",serviceName,""String_Node_Str"") : sputs(""String_Node_Str"",serviceName,host,port,""String_Node_Str"");
default :
endPoint.call(call);
}
return null;
}"
3889,"/** 
 * @param serviceInterface client interface
 * @param serviceName      client name
 * @param returnAddressArg specify a specific return address
 * @param < T >              class type of client interface
 * @return proxy object
 */
public <T>T createProxy(final Class<T> serviceInterface,final String serviceName,final String returnAddressArg){
  if (!serviceInterface.isInterface()) {
    die(""String_Node_Str"");
  }
  BeforeMethodCall beforeMethodCall=new BeforeMethodCall(){
    @Override public boolean before(    final MethodCall call){
      final Object body=call.body();
      if (body instanceof Object[]) {
        Object[] list=(Object[])body;
        if (list.length > 0) {
          final Object o=list[0];
          if (o instanceof Callback) {
            handlers.put(new HandlerKey(call.returnAddress(),call.id()),createHandler(serviceInterface,call,(Callback)o));
            if (list.length - 1 == 0) {
              list=new Object[0];
            }
 else {
              list=Arry.slc(list,1);
            }
          }
          if (call instanceof MethodCallImpl) {
            MethodCallImpl impl=(MethodCallImpl)call;
            impl.setBody(list);
          }
        }
      }
      return true;
    }
  }
;
  T proxy=QBit.factory().createRemoteProxyWithReturnAddress(serviceInterface,uri,serviceName,returnAddressArg,(returnAddress,buffer) -> BoonClient.this.send(serviceName,buffer),beforeMethodCall,requestBatchSize);
  if (proxy instanceof ClientProxy) {
    clientProxies.add((ClientProxy)proxy);
  }
  return proxy;
}","/** 
 * @param serviceInterface client interface
 * @param serviceName      client name
 * @param returnAddressArg specify a specific return address
 * @param < T >              class type of client interface
 * @return proxy object
 */
public <T>T createProxy(final Class<T> serviceInterface,final String serviceName,final String returnAddressArg){
  if (!serviceInterface.isInterface()) {
    die(""String_Node_Str"");
  }
  BeforeMethodCall beforeMethodCall=new BeforeMethodCall(){
    @Override public boolean before(    final MethodCall call){
      final Object body=call.body();
      if (body instanceof Object[]) {
        Object[] list=(Object[])body;
        if (list.length > 0) {
          final Object o=list[0];
          if (o instanceof Callback) {
            handlers.put(new HandlerKey(call.returnAddress(),call.id()),createHandler(serviceInterface,call,(Callback)o));
            if (list.length - 1 == 0) {
              list=new Object[0];
            }
 else {
              list=Arry.slc(list,1);
            }
          }
          if (call instanceof MethodCallImpl) {
            MethodCallImpl impl=(MethodCallImpl)call;
            impl.setBody(list);
          }
        }
      }
      return true;
    }
  }
;
  T proxy=QBit.factory().createRemoteProxyWithReturnAddress(serviceInterface,uri,serviceName,httpServerProxy.getHost(),httpServerProxy.getPort(),returnAddressArg,(returnAddress,buffer) -> BoonClient.this.send(serviceName,buffer),beforeMethodCall,requestBatchSize);
  if (proxy instanceof ClientProxy) {
    clientProxies.add((ClientProxy)proxy);
  }
  return proxy;
}"
3890,"/** 
 * Create a remote proxy using a sender that knows how to forwardEvent method body over wire
 * @param serviceInterface client view of client
 * @param uri              uri of client
 * @param serviceName      name of the client that we are proxying method calls to.
 * @param returnAddressArg return address
 * @param sender           how we are sending the message over the wire
 * @param beforeMethodCall before method call
 * @param < T >              type of client
 * @param requestBatchSize request batch size
 * @return remote proxy
 */
default <T>T createRemoteProxyWithReturnAddress(Class<T> serviceInterface,String uri,String serviceName,String returnAddressArg,Sender<String> sender,BeforeMethodCall beforeMethodCall,int requestBatchSize){
  throw new UnsupportedOperationException();
}","/** 
 * Create a remote proxy using a sender that knows how to forwardEvent method body over wire
 * @param serviceInterface client view of client
 * @param uri              uri of client
 * @param serviceName      name of the client that we are proxying method calls to.
 * @param port port
 * @param host host
 * @param returnAddressArg return address
 * @param sender           how we are sending the message over the wire
 * @param beforeMethodCall before method call
 * @param < T >              type of client
 * @param requestBatchSize request batch size
 * @return remote proxy
 */
default <T>T createRemoteProxyWithReturnAddress(Class<T> serviceInterface,String uri,String serviceName,String host,int port,String returnAddressArg,Sender<String> sender,BeforeMethodCall beforeMethodCall,int requestBatchSize){
  throw new UnsupportedOperationException();
}"
3891,"@Test public void test(){
}","@Test public void test(){
  clientEventConnector.forwardEvent(event);
  flushServiceProxy(clientEventConnector);
  waitForLatch(1);
  client.flush();
  waitForLatch(1);
  verify(eventManager).forwardEvent(event);
}"
3892,"@Before public void setup(){
  setupLatch();
  eventManager=mock(EventManager.class);
  service=new EventRemoteReplicatorService(eventManager);
  serviceServer=serviceServerBuilder().build();
  serviceServer.initServices(service);
  client=clientBuilder().build();
  serviceServer.start();
  Sys.sleep(100);
  client.start();
  clientEventConnector=client.createProxy(EventConnector.class,""String_Node_Str"");
}","@Before public void setup() throws IOException {
  setupLatch();
  eventManager=mock(EventManager.class);
  service=new EventRemoteReplicatorService(eventManager);
  int port=useOneOfThese(8080,7070,6060,6666,5555,4444,2121,8081,8082,7777,6767,2323,5555);
  serviceServer=serviceServerBuilder().setPort(port).build();
  serviceServer.initServices(service);
  client=clientBuilder().build();
  serviceServer.start();
  Sys.sleep(100);
  client.start();
  clientEventConnector=client.createProxy(EventConnector.class,""String_Node_Str"");
}"
3893,"private Response<Object> invokeByName(MethodCall<Object> methodCall){
  final MethodAccess method=classMeta.method(methodCall.name());
  return mapArgsAsyncHandlersAndInvoke(methodCall,method);
}","private Response<Object> invokeByName(MethodCall<Object> methodCall){
  final MethodAccess method=classMeta.method(methodCall.name());
  if (method != null) {
    return mapArgsAsyncHandlersAndInvoke(methodCall,method);
  }
 else {
    if (methodCall.name().equals(""String_Node_Str"")) {
      puts(""String_Node_Str"",methodCall.objectName(),methodCall.name(),methodCall.address());
      return ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),sputs(""String_Node_Str"",methodCall.objectName(),methodCall.name(),methodCall.address()),methodCall,false);
    }
 else {
      return ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),new Exception(""String_Node_Str""),methodCall,true);
    }
  }
}"
3894,"private void extactHandlersFromArgumentList(MethodAccess method,Object body,List<Object> argsList){
  if (body instanceof List) {
    List<Object> list=(List<Object>)body;
    extractHandlersFromArgumentListBodyIsList(method,argsList,list);
  }
 else   if (body instanceof Object[]) {
    extactHandlersFromArgumentListArrayCase(method,(Object[])body,argsList);
  }
}","private void extactHandlersFromArgumentList(MethodAccess method,Object body,List<Object> argsList){
  if (body instanceof List) {
    List<Object> list=(List<Object>)body;
    extractHandlersFromArgumentListBodyIsList(method,argsList,list);
  }
 else   if (body instanceof Object[]) {
    extractHandlersFromArgumentListArrayCase(method,(Object[])body,argsList);
  }
}"
3895,"@Test public void testAsync2(){
  String addressToMethodCall=""String_Node_Str"";
  serviceBundle.addService(employeeService);
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  Exceptions.requireNonNull(response);
  puts(response.body());
  ok=!response.wasErrors() || die();
  puts(response.body());
  Boon.equalsOrDie(""String_Node_Str"",response.body());
}","@Test public void testAsync2(){
  String addressToMethodCall=""String_Node_Str"";
  serviceBundle.addService(employeeService);
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,new Object[]{new Callback<String>(){
    @Override public void accept(    String s){
      puts(""String_Node_Str"" + s);
    }
  }
,""String_Node_Str""},params);
  doCall();
  response=responseReceiveQueue.pollWait();
  Exceptions.requireNonNull(response);
  puts(response.body());
  ok=!response.wasErrors() || die();
  puts(response.body());
  Boon.equalsOrDie(""String_Node_Str"",response.body());
}"
3896,"public void joinEventManager(){
  final EventManager eventManager=eventManager();
  eventManager.joinService(currentService());
}","public void joinEventManager(){
  final EventManager eventManager=eventManager();
  Service service=currentService();
  eventManager.joinService(service);
}"
3897,"public static HttpRequest convertRequest(final AsyncContext asyncContext){
  final HttpServletRequest request=(HttpServletRequest)asyncContext.getRequest();
  final HttpServletResponse response=(HttpServletResponse)asyncContext.getResponse();
  final MultiMap<String,String> headers=new HttpServletHeaderMultiMap(request);
  final MultiMap<String,String> params=new HttpServletParamMultiMap(request);
  final HttpRequestBuilder httpRequestBuilder=httpRequestBuilder().setParams(params).setHeaders(headers).setUri(request.getPathInfo()).setMethod(request.getMethod());
  setRequestBodyIfNeeded(request,httpRequestBuilder);
  setupRequestHandler(asyncContext,response,httpRequestBuilder);
  return httpRequestBuilder.build();
}","public static HttpRequest convertRequest(final AsyncContext asyncContext){
  final HttpServletRequest request=(HttpServletRequest)asyncContext.getRequest();
  final HttpServletResponse response=(HttpServletResponse)asyncContext.getResponse();
  final MultiMap<String,String> headers=new HttpServletHeaderMultiMap(request);
  final MultiMap<String,String> params=new HttpServletParamMultiMap(request);
  final HttpRequestBuilder httpRequestBuilder=httpRequestBuilder().setParams(params).setHeaders(headers).setUri(request.getRequestURI()).setMethod(request.getMethod());
  setRequestBodyIfNeeded(request,httpRequestBuilder);
  setupRequestHandler(asyncContext,response,httpRequestBuilder);
  return httpRequestBuilder.build();
}"
3898,"private static void setupRequestHandler(final AsyncContext asyncContext,final HttpServletResponse response,final HttpRequestBuilder httpRequestBuilder){
  httpRequestBuilder.setTextReceiver((code,contentType,body) -> {
    response.setHeader(""String_Node_Str"",contentType);
    try {
      final ServletOutputStream outputStream=response.getOutputStream();
      outputStream.write(body.getBytes(StandardCharsets.UTF_8));
      outputStream.close();
      asyncContext.complete();
    }
 catch (    final IOException e) {
      throw new IllegalStateException(e);
    }
  }
);
}","private static void setupRequestHandler(final AsyncContext asyncContext,final HttpServletResponse response,final HttpRequestBuilder httpRequestBuilder){
  httpRequestBuilder.setTextReceiver((code,contentType,body) -> {
    response.setHeader(""String_Node_Str"",contentType);
    response.setStatus(code);
    try {
      final ServletOutputStream outputStream=response.getOutputStream();
      outputStream.write(body.getBytes(StandardCharsets.UTF_8));
      outputStream.close();
      asyncContext.complete();
    }
 catch (    final IOException e) {
      throw new IllegalStateException(e);
    }
  }
);
}"
3899,"@Test public void testRecord() throws Exception {
  statServiceClient.recordCount(""String_Node_Str"",1);
  serviceBundle.flush();
  Sys.sleep(100);
  ok=replicator.count == 1 || die();
}","@Test public void testRecord() throws Exception {
  statServiceClient.recordCount(""String_Node_Str"",1);
  serviceBundle.flush();
  triggerLatchWhen(o -> replicator.count == 1);
  waitForLatch(20);
  ok=replicator.count == 1 || die();
}"
3900,"@Test public void testRecordAll() throws Exception {
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  statServiceClient.recordAllCounts(Timer.timer().now(),names,counts);
  serviceBundle.flush();
  Sys.sleep(100);
  ok=replicator.count == 3 || die(replicator.count);
}","@Test public void testRecordAll() throws Exception {
  String[] names=Arry.array(""String_Node_Str"",""String_Node_Str"");
  int[] counts=Int.array(1,2);
  statServiceClient.recordAllCounts(Timer.timer().now(),names,counts);
  serviceBundle.flush();
  triggerLatchWhen(o -> replicator.count == 3);
  waitForLatch(20);
  ok=replicator.count == 3 || die(replicator.count);
}"
3901,"@Test public void testNoMethodCallFound(){
}","@Test public void testNoMethodCallFound(){
  ProtocolEncoder encoder=QBit.factory().createEncoder();
  MockHttpServer httpServer=new MockHttpServer();
  final ServiceBundle serviceBundle=new ServiceBundleBuilder().setAddress(""String_Node_Str"").build();
  JsonMapper mapper=new BoonJsonMapper();
  ServiceServerImpl server=new ServiceServerImpl(httpServer,encoder,QBit.factory().createProtocolParser(),serviceBundle,mapper,1,100,30,10,null);
  server.initServices(new TodoService());
  server.start();
  final AtomicBoolean resultsWorked=new AtomicBoolean();
  resultsWorked.set(false);
  httpServer.sendHttpGet(""String_Node_Str"",null,(code,mimeType,body) -> {
    if (code == 404 && body != null && body.startsWith(""String_Node_Str"")) {
      resultsWorked.set(true);
    }
  }
);
  waitForTrigger(20,o -> resultsWorked.get());
  if (!resultsWorked.get()) {
    die(""String_Node_Str"");
  }
  resultsWorked.set(false);
}"
3902,"@Test public void testServerTimeout(){
}","@Test public void testServerTimeout(){
  ProtocolEncoder encoder=QBit.factory().createEncoder();
  MockHttpServer httpServer=new MockHttpServer();
  final ServiceBundle serviceBundle=new ServiceBundleBuilder().setAddress(""String_Node_Str"").build();
  JsonMapper mapper=new BoonJsonMapper();
  ServiceServerImpl server=new ServiceServerImpl(httpServer,encoder,QBit.factory().createProtocolParser(),serviceBundle,mapper,1,100,30,10,null);
  server.initServices(Sets.set(new TodoService()));
  server.start();
  final AtomicBoolean resultsWorked=new AtomicBoolean();
  for (int index=0; index < 100; index++) {
    httpServer.sendHttpGet(""String_Node_Str"",null,(code,mimeType,body) -> {
      if (code == 408 && body != null && body.equals(""String_Node_Str"")) {
        resultsWorked.set(true);
      }
    }
);
  }
  waitForTrigger(8,o -> resultsWorked.get());
  if (!resultsWorked.get()) {
    die(""String_Node_Str"");
  }
  resultsWorked.set(false);
}"
3903,"@Test public void testServer(){
}","@Test public void testServer(){
  latch=new CountDownLatch(1);
  ProtocolEncoder encoder=QBit.factory().createEncoder();
  ProtocolParser parser=QBit.factory().createProtocolParser();
  MockHttpServer httpServer=new MockHttpServer();
  final ServiceBundle serviceBundle=new ServiceBundleBuilder().setAddress(""String_Node_Str"").build();
  JsonMapper mapper=new BoonJsonMapper();
  ServiceServerImpl server=new ServiceServerImpl(httpServer,encoder,parser,serviceBundle,mapper,30,100,30,10,null);
  server.initServices(Sets.set(new TodoService()));
  final AtomicBoolean resultsWorked=new AtomicBoolean();
  server.start();
  httpServer.postRequestObject(""String_Node_Str"",new Todo(""String_Node_Str"",""String_Node_Str"",new Date()),(code,mimeType,body) -> {
    puts(""String_Node_Str"",body,""String_Node_Str"");
    if (body != null && code == 200 && body.equals(""String_Node_Str"")) {
      resultsWorked.set(true);
    }
  }
);
  waitForTrigger(20,o -> resultsWorked.get());
  if (!resultsWorked.get()) {
    die(""String_Node_Str"");
  }
  resultsWorked.set(false);
  httpServer.sendHttpGet(""String_Node_Str"",null,(code,mimeType,body) -> {
    puts(""String_Node_Str"",code,""String_Node_Str"",mimeType,""String_Node_Str"",body);
    List<Todo> todos=Boon.fromJsonArray(body,Todo.class);
    if (todos.size() > 0) {
      Todo todo=todos.get(0);
      if (todo.getDescription().equals(""String_Node_Str"")) {
        resultsWorked.set(true);
      }
    }
  }
);
  server.flush();
  waitForTrigger(20,o -> resultsWorked.get());
  if (!resultsWorked.get()) {
    die(""String_Node_Str"");
  }
}"
3904,"private void handleResponseFromServiceBundle(final Response<Object> response,final Request<Object> originatingRequest){
  originatingRequest.handled();
  if (originatingRequest instanceof HttpRequest) {
    handleResponseFromServiceToHttpResponse(response,(HttpRequest)originatingRequest);
  }
 else   if (originatingRequest instanceof WebSocketMessage) {
    handleResponseFromServiceBundleToWebSocketSender(response,(WebSocketMessage)originatingRequest);
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + response);
  }
}","private void handleResponseFromServiceBundle(final Response<Object> response,final Request<Object> originatingRequest){
  if (originatingRequest.isHandled()) {
    return;
  }
  originatingRequest.handled();
  if (originatingRequest instanceof HttpRequest) {
    handleResponseFromServiceToHttpResponse(response,(HttpRequest)originatingRequest);
  }
 else   if (originatingRequest instanceof WebSocketMessage) {
    handleResponseFromServiceBundleToWebSocketSender(response,(WebSocketMessage)originatingRequest);
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + response);
  }
}"
3905,"@Override public boolean isHandled(){
  return false;
}","@Override public boolean isHandled(){
  return handled;
}"
3906,"private SendQueue<MethodCall<Object>> handleByAddressCall(MethodCall<Object> methodCall){
  SendQueue<MethodCall<Object>> sendQueue;
  final String callAddress=methodCall.address();
  sendQueue=serviceMapping.get(callAddress);
  if (sendQueue == null) {
    if (callAddress.indexOf('{') != -1) {
      final String[] split=StringScanner.split(callAddress,'{');
      sendQueue=serviceMapping.get(split[0]);
    }
  }
  return sendQueue;
}","private SendQueue<MethodCall<Object>> handleByAddressCall(MethodCall<Object> methodCall){
  SendQueue<MethodCall<Object>> sendQueue;
  final String callAddress=methodCall.address();
  sendQueue=serviceMapping.get(callAddress);
  if (sendQueue == null) {
    String addr;
    addr=seenAddressesDescending.higher(callAddress);
    if (addr != null && callAddress.startsWith(addr)) {
      sendQueue=serviceMapping.get(addr);
      return sendQueue;
    }
    addr=addressesByDescending.higher(callAddress);
    if (addr != null && callAddress.startsWith(addr)) {
      sendQueue=serviceMapping.get(addr);
      if (sendQueue != null) {
        seenAddressesDescending.add(addr);
      }
    }
  }
  return sendQueue;
}"
3907,"public ServiceBundleImpl(String address,int batchSize,int pollRate,Factory factory){
  if (address.endsWith(""String_Node_Str"")) {
    address=Str.slc(address,0,-1);
  }
  this.address=address;
  this.factory=factory;
  this.responseQueue=new BasicQueue<>(""String_Node_Str"" + address,pollRate,TimeUnit.MILLISECONDS,batchSize);
  this.methodQueue=new BasicQueue<>(""String_Node_Str"" + address,pollRate,TimeUnit.MILLISECONDS,batchSize);
  methodSendQueue=methodQueue.sendQueue();
  methodQueue.startListener(new ReceiveQueueListener<MethodCall<Object>>(){
    long time;
    long lastTimeAutoFlush;
    @Override public void receive(    MethodCall<Object> item){
      doCall(item);
    }
    @Override public void empty(){
      time=Timer.timer().now();
      if (time > (lastTimeAutoFlush + 50)) {
        for (        SendQueue<MethodCall<Object>> sendQueue : sendQueues) {
          sendQueue.flushSends();
        }
        lastTimeAutoFlush=time;
      }
    }
    @Override public void limit(){
    }
    @Override public void shutdown(){
    }
    @Override public void idle(){
    }
  }
);
}","public ServiceBundleImpl(String address,int batchSize,int pollRate,Factory factory){
  if (address.endsWith(""String_Node_Str"")) {
    address=Str.slc(address,0,-1);
  }
  this.address=address;
  this.factory=factory;
  this.responseQueue=new BasicQueue<>(""String_Node_Str"" + address,pollRate,TimeUnit.MILLISECONDS,batchSize);
  this.methodQueue=new BasicQueue<>(""String_Node_Str"" + address,pollRate,TimeUnit.MILLISECONDS,batchSize);
  methodSendQueue=methodQueue.sendQueue();
  start();
}"
3908,"@Override public void addService(String serviceAddress,Object object){
  if (GlobalConstants.DEBUG) {
    logger.info(Boon.className(this),serviceAddress,object);
  }
  final Service service=factory.createService(address,serviceAddress,object,responseQueue);
  services.add(service);
  final SendQueue<MethodCall<Object>> requests=service.requests();
  if (!Str.isEmpty(serviceAddress)) {
    serviceMapping.put(serviceAddress,requests);
  }
  serviceMapping.put(service.name(),requests);
  sendQueues.add(requests);
  final List<String> addresses=service.addresses(this.address);
  if (GlobalConstants.DEBUG) {
    logger.info(Boon.className(this),""String_Node_Str"",addresses);
  }
  for (  String addr : addresses) {
    SendQueue<MethodCall<Object>> methodCallSendQueue=serviceMapping.get(service.name());
    serviceMapping.put(addr,methodCallSendQueue);
  }
}","@Override public void addService(String serviceAddress,Object object){
  if (GlobalConstants.DEBUG) {
    logger.info(Boon.className(this),serviceAddress,object);
  }
  final Service service=factory.createService(address,serviceAddress,object,responseQueue);
  services.add(service);
  final SendQueue<MethodCall<Object>> requests=service.requests();
  if (!Str.isEmpty(serviceAddress)) {
    serviceMapping.put(serviceAddress,requests);
  }
  serviceMapping.put(service.name(),requests);
  sendQueues.add(requests);
  final List<String> addresses=service.addresses(this.address);
  if (GlobalConstants.DEBUG) {
    logger.info(Boon.className(this),""String_Node_Str"",addresses);
  }
  for (  String addr : addresses) {
    addressesByDescending.add(addr);
    SendQueue<MethodCall<Object>> methodCallSendQueue=serviceMapping.get(service.name());
    serviceMapping.put(addr,methodCallSendQueue);
  }
}"
3909,"private Response<Object> invokeByAddressWithComplexBinding(MethodCall<Object> methodCall){
  String mAddress=methodCall.address();
  final String[] split=StringScanner.split(mAddress,'/');
  for (  String root : addresses) {
    if (mAddress.startsWith(root)) {
      mAddress=root;
      break;
    }
  }
  Pair<MethodBinding,MethodAccess> binding=methodMap.get(mAddress);
  final MethodBinding methodBinding=binding.getFirst();
  final MethodAccess methodAccess=binding.getSecond();
  final List<ArgParamBinding> parameters=methodBinding.parameters();
  final Class<?>[] parameterTypes=methodAccess.parameterTypes();
  final List<TypeType> paramEnumTypes=methodAccess.paramTypeEnumList();
  final List<Object> args=new ArrayList<>(parameterTypes.length);
  for (int index=0; index < parameterTypes.length; index++) {
    args.add(null);
  }
  final List<List<AnnotationData>> annotationDataForParams=methodAccess.annotationDataForParams();
  for (  ArgParamBinding param : parameters) {
    final int uriPosition=param.getUriPosition();
    final int methodParamPosition=param.getMethodParamPosition();
    final String paramName=param.getMethodParamName();
    if (uriPosition != -1) {
      if (uriPosition > split.length) {
        die(""String_Node_Str"",methodAccess);
      }
 else {
        String paramAtPos=split[uriPosition];
        paramAtPos=Str.slc(paramAtPos,1,-1);
        Object arg=Conversions.coerce(paramEnumTypes.get(methodParamPosition),parameterTypes[methodParamPosition],paramAtPos);
        args.set(methodParamPosition,arg);
      }
    }
 else {
      if (Str.isEmpty(paramName)) {
        die(""String_Node_Str"");
      }
      for (int index=0; index < parameterTypes.length; index++) {
        final List<AnnotationData> paramsAnnotationData=annotationDataForParams.get(index);
        String name=""String_Node_Str"";
        for (        AnnotationData paramAnnotation : paramsAnnotationData) {
          if (paramAnnotation.getName().equals(""String_Node_Str"")) {
            name=(String)paramAnnotation.getValues().get(""String_Node_Str"");
            if (!Str.isEmpty(name)) {
              break;
            }
          }
        }
        if (paramName.equals(name)) {
          Object arg=Conversions.coerce(paramEnumTypes.get(index),parameterTypes[index],split[index]);
          args.set(index,arg);
        }
      }
    }
  }
  if (methodAccess.returnType() == Void.class) {
    methodAccess.invokeDynamicObject(service,args);
    return ServiceConstants.VOID;
  }
 else {
    Object returnValue=methodAccess.invokeDynamicObject(service,args);
    Response<Object> response=ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),returnValue);
    return response;
  }
}","private Response<Object> invokeByAddressWithComplexBinding(MethodCall<Object> methodCall){
  String mAddress=methodCall.address();
  final String[] split=StringScanner.split(mAddress,'/');
  for (  String root : addresses) {
    if (mAddress.startsWith(root)) {
      mAddress=root;
      break;
    }
  }
  Pair<MethodBinding,MethodAccess> binding=methodMap.get(mAddress);
  final MethodBinding methodBinding=binding.getFirst();
  final MethodAccess methodAccess=binding.getSecond();
  final List<ArgParamBinding> parameters=methodBinding.parameters();
  final Class<?>[] parameterTypes=methodAccess.parameterTypes();
  final List<TypeType> paramEnumTypes=methodAccess.paramTypeEnumList();
  final List<Object> args=new ArrayList<>(parameterTypes.length);
  for (int index=0; index < parameterTypes.length; index++) {
    args.add(null);
  }
  final List<List<AnnotationData>> annotationDataForParams=methodAccess.annotationDataForParams();
  for (  ArgParamBinding param : parameters) {
    final int uriPosition=param.getUriPosition();
    final int methodParamPosition=param.getMethodParamPosition();
    final String paramName=param.getMethodParamName();
    if (uriPosition != -1) {
      if (uriPosition > split.length) {
        die(""String_Node_Str"",methodAccess);
      }
 else {
        String paramAtPos=split[uriPosition];
        Object arg=Conversions.coerce(paramEnumTypes.get(methodParamPosition),parameterTypes[methodParamPosition],paramAtPos);
        args.set(methodParamPosition,arg);
      }
    }
 else {
      if (Str.isEmpty(paramName)) {
        die(""String_Node_Str"");
      }
      for (int index=0; index < parameterTypes.length; index++) {
        final List<AnnotationData> paramsAnnotationData=annotationDataForParams.get(index);
        String name=""String_Node_Str"";
        for (        AnnotationData paramAnnotation : paramsAnnotationData) {
          if (paramAnnotation.getName().equals(""String_Node_Str"")) {
            name=(String)paramAnnotation.getValues().get(""String_Node_Str"");
            if (!Str.isEmpty(name)) {
              break;
            }
          }
        }
        if (paramName.equals(name)) {
          Object arg=Conversions.coerce(paramEnumTypes.get(index),parameterTypes[index],split[index]);
          args.set(index,arg);
        }
      }
    }
  }
  if (methodAccess.returnType() == Void.class) {
    methodAccess.invokeDynamicObject(service,args);
    return ServiceConstants.VOID;
  }
 else {
    Object returnValue=methodAccess.invokeDynamicObject(service,args);
    Response<Object> response=ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.address(),methodCall.returnAddress(),returnValue);
    return response;
  }
}"
3910,"private Response<Object> invokeByAddressWithSimpleBinding(MethodCall<Object> methodCall,Pair<MethodBinding,MethodAccess> binding){
  MethodAccess methodAccess=binding.getSecond();
  if (methodAccess.returnType() == Void.class) {
    methodAccess.invokeDynamicObject(service,methodCall.body());
    return ServiceConstants.VOID;
  }
 else {
    Object returnValue=methodAccess.invokeDynamicObject(service,methodCall.body());
    Response<Object> response=ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.name(),methodCall.returnAddress(),returnValue);
    return response;
  }
}","private Response<Object> invokeByAddressWithSimpleBinding(MethodCall<Object> methodCall,Pair<MethodBinding,MethodAccess> binding){
  MethodAccess methodAccess=binding.getSecond();
  if (methodAccess.returnType() == Void.class) {
    methodAccess.invokeDynamicObject(service,methodCall.body());
    return ServiceConstants.VOID;
  }
 else {
    Object body=methodCall.body();
    if (Str.isEmpty(body) && methodAccess.parameterTypes().length > 0) {
      body=methodCall.params();
    }
    Object returnValue=methodAccess.invokeDynamicObject(service,body);
    Response<Object> response=ResponseImpl.response(methodCall.id(),methodCall.timestamp(),methodCall.name(),methodCall.returnAddress(),returnValue);
    return response;
  }
}"
3911,"@Test public void testBasicCrud(){
  String addressToMethodCall=""String_Node_Str"";
  serviceBundle.addService(employeeService);
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,rick,params);
  doCall();
  response=responseReceiveQueue.pollWait();
  Exceptions.requireNonNull(response);
  Boon.equalsOrDie(true,response.body());
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  validateRick();
  addressToMethodCall=""String_Node_Str"";
  params=new MultiMapImpl<>();
  final Map<String,String> map=Maps.map(""String_Node_Str"",""String_Node_Str"" + rick.level,""String_Node_Str"",""String_Node_Str"" + rick.active);
  params.putAll(map);
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,Lists.list(rick),params);
  doCall();
  response=responseReceiveQueue.pollWait();
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  validateRick();
  Boon.equalsOrDie(100,employee.level);
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,Lists.list(rick.id),params);
  doCall();
  response=responseReceiveQueue.pollWait();
  Boon.equalsOrDie(true,response.body());
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  puts(response.body());
  Boon.equalsOrDie(null,response.body());
}","@Test public void testBasicCrud(){
  String addressToMethodCall=""String_Node_Str"";
  serviceBundle.addService(employeeService);
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,rick,params);
  doCall();
  response=responseReceiveQueue.pollWait();
  Exceptions.requireNonNull(response);
  Boon.equalsOrDie(true,response.body());
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  validateRick();
  addressToMethodCall=""String_Node_Str"";
  params=new MultiMapImpl<>();
  params.put(""String_Node_Str"",""String_Node_Str"" + 1000);
  params.put(""String_Node_Str"",""String_Node_Str"" + rick.active);
  puts(""String_Node_Str"",params.get(""String_Node_Str""));
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  puts(""String_Node_Str"",response.body());
  Employee employee1=(Employee)response.body();
  Boon.equalsOrDie(1000,employee1.level);
  Boon.equalsOrDie(rick.active,employee1.active);
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,Lists.list(rick),params);
  doCall();
  response=responseReceiveQueue.pollWait();
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  validateRick();
  Boon.equalsOrDie(100,employee.level);
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,Lists.list(rick.id),params);
  doCall();
  response=responseReceiveQueue.pollWait();
  Boon.equalsOrDie(true,response.body());
  addressToMethodCall=""String_Node_Str"";
  call=factory.createMethodCallByAddress(addressToMethodCall,returnAddress,""String_Node_Str"",params);
  doCall();
  response=responseReceiveQueue.pollWait();
  puts(response.body());
  Boon.equalsOrDie(null,response.body());
}"
3912,"/** 
 * Creates an HttpWebRequest instance and initialises it with the appropriate parameters, based on the configuration of this service object.
 * @param url                The URL that the HttpWebRequest should target.
 * @param acceptGzipEncoding If true, ask server for GZip compressed content.
 * @param allowAutoRedirect  If true, redirection response will be automatically followed.
 * @return An initialised instance of HttpWebRequest.
 * @throws ServiceLocalException       the service local exception
 * @throws java.net.URISyntaxException the uRI syntax exception
 */
protected HttpWebRequest prepareHttpWebRequestForUrl(URI url,boolean acceptGzipEncoding,boolean allowAutoRedirect) throws ServiceLocalException, URISyntaxException {
  String scheme=url.getScheme();
  if (!scheme.equalsIgnoreCase(EWSConstants.HTTP_SCHEME) && !scheme.equalsIgnoreCase(EWSConstants.HTTPS_SCHEME)) {
    String strErr=String.format(""String_Node_Str"",scheme);
    throw new ServiceLocalException(strErr);
  }
  request=new HttpClientWebRequest(httpClient,httpContext);
  request.setProxy(getWebProxy());
  try {
    request.setUrl(url.toURL());
  }
 catch (  MalformedURLException e) {
    String strErr=String.format(""String_Node_Str"",url);
    throw new ServiceLocalException(strErr);
  }
  request.setPreAuthenticate(preAuthenticate);
  request.setTimeout(timeout);
  request.setContentType(""String_Node_Str"");
  request.setAccept(""String_Node_Str"");
  request.setUserAgent(userAgent);
  request.setAllowAutoRedirect(allowAutoRedirect);
  request.setAcceptGzipEncoding(acceptGzipEncoding);
  request.setHeaders(getHttpHeaders());
  prepareCredentials(request);
  request.prepareConnection();
  httpResponseHeaders.clear();
  return request;
}","private void prepareHttpWebRequestForUrl(URI url,boolean acceptGzipEncoding,boolean allowAutoRedirect,HttpClientWebRequest request) throws ServiceLocalException, URISyntaxException {
  try {
    request.setUrl(url.toURL());
  }
 catch (  MalformedURLException e) {
    String strErr=String.format(""String_Node_Str"",url);
    throw new ServiceLocalException(strErr);
  }
  request.setPreAuthenticate(preAuthenticate);
  request.setTimeout(timeout);
  request.setContentType(""String_Node_Str"");
  request.setAccept(""String_Node_Str"");
  request.setUserAgent(userAgent);
  request.setAllowAutoRedirect(allowAutoRedirect);
  request.setAcceptGzipEncoding(acceptGzipEncoding);
  request.setHeaders(getHttpHeaders());
  prepareCredentials(request);
  request.prepareConnection();
  httpResponseHeaders.clear();
}"
3913,"/** 
 * Create registry with configured   {@link ConnectionSocketFactory} instances.Override this method to change how to work with different schemas.
 * @return registry object
 */
protected Registry<ConnectionSocketFactory> createConnectionSocketFactoryRegistry(){
  try {
    return RegistryBuilder.<ConnectionSocketFactory>create().register(EWSConstants.HTTP_SCHEME,new PlainConnectionSocketFactory()).register(EWSConstants.HTTPS_SCHEME,EwsSSLProtocolSocketFactory.build(null)).build();
  }
 catch (  GeneralSecurityException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","/** 
 * Create registry with configured   {@see ConnectionSocketFactory} instances.Override this method to change how to work with different schemas.
 * @return registry object
 */
protected Registry<ConnectionSocketFactory> createConnectionSocketFactoryRegistry(){
  try {
    return RegistryBuilder.<ConnectionSocketFactory>create().register(EWSConstants.HTTP_SCHEME,new PlainConnectionSocketFactory()).register(EWSConstants.HTTPS_SCHEME,EwsSSLProtocolSocketFactory.build(null)).build();
  }
 catch (  GeneralSecurityException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
3914,"@Override public void close(){
  try {
    httpClient.close();
  }
 catch (  IOException e) {
  }
}","@Override public void close(){
  try {
    httpClient.close();
    if (httpPoolingClient != null)     httpPoolingClient.close();
  }
 catch (  IOException e) {
  }
}"
3915,"/** 
 * Builds the HttpWebRequest object for current service request with exception handling.
 * @return An HttpWebRequest instance
 * @throws Exception on error
 */
protected HttpWebRequest buildEwsHttpWebRequest() throws Exception {
  try {
    HttpWebRequest request=service.prepareHttpWebRequest();
    service.traceHttpRequestHeaders(TraceFlags.EwsRequestHttpHeaders,request);
    ByteArrayOutputStream requestStream=(ByteArrayOutputStream)request.getOutputStream();
    EwsServiceXmlWriter writer=new EwsServiceXmlWriter(service,requestStream);
    boolean needSignature=service.getCredentials() != null && service.getCredentials().isNeedSignature();
    writer.setRequireWSSecurityUtilityNamespace(needSignature);
    writeToXml(writer);
    if (needSignature) {
      service.getCredentials().sign(requestStream);
    }
    service.traceXml(TraceFlags.EwsRequest,requestStream);
    return request;
  }
 catch (  IOException e) {
    throw new ServiceRequestException(String.format(""String_Node_Str"",e.getMessage()),e);
  }
}","private HttpWebRequest buildEwsHttpWebRequest(HttpWebRequest request) throws Exception {
  try {
    service.traceHttpRequestHeaders(TraceFlags.EwsRequestHttpHeaders,request);
    ByteArrayOutputStream requestStream=(ByteArrayOutputStream)request.getOutputStream();
    EwsServiceXmlWriter writer=new EwsServiceXmlWriter(service,requestStream);
    boolean needSignature=service.getCredentials() != null && service.getCredentials().isNeedSignature();
    writer.setRequireWSSecurityUtilityNamespace(needSignature);
    writeToXml(writer);
    if (needSignature) {
      service.getCredentials().sign(requestStream);
    }
    service.traceXml(TraceFlags.EwsRequest,requestStream);
    return request;
  }
 catch (  IOException e) {
    throw new ServiceRequestException(String.format(""String_Node_Str"",e.getMessage()),e);
  }
}"
3916,"/** 
 * Validates this instance.
 * @throws Exception the exception
 */
public void validate() throws Exception {
  if (this.owner.isNew() && this.owner.getService().getRequestedServerVersion().ordinal() >= ExchangeVersion.Exchange2010_SP2.ordinal()) {
    boolean contactPhotoFound=false;
    for (int attachmentIndex=0; attachmentIndex < this.getAddedItems().size(); attachmentIndex++) {
      final Attachment attachment=this.getAddedItems().get(attachmentIndex);
      if (attachment != null && attachment.isNew() && attachment instanceof FileAttachment) {
        if (((FileAttachment)attachment).isContactPhoto()) {
          if (contactPhotoFound) {
            throw new ServiceValidationException(""String_Node_Str"");
          }
          contactPhotoFound=true;
        }
      }
      attachment.validate(attachmentIndex);
    }
  }
}","/** 
 * Validates this instance.
 * @throws Exception the exception
 */
public void validate() throws Exception {
  if (this.owner.isNew() && this.owner.getService().getRequestedServerVersion().ordinal() >= ExchangeVersion.Exchange2010_SP2.ordinal()) {
    boolean contactPhotoFound=false;
    for (int attachmentIndex=0; attachmentIndex < this.getAddedItems().size(); attachmentIndex++) {
      final Attachment attachment=this.getAddedItems().get(attachmentIndex);
      if (attachment != null) {
        if (attachment.isNew() && attachment instanceof FileAttachment) {
          if (((FileAttachment)attachment).isContactPhoto()) {
            if (contactPhotoFound) {
              throw new ServiceValidationException(""String_Node_Str"");
            }
            contactPhotoFound=true;
          }
        }
        attachment.validate(attachmentIndex);
      }
    }
  }
}"
3917,"/** 
 * Compares the transitions.
 * @param x The first transition.
 * @param y The second transition.
 * @return A negative number if x is less than y, 0 if x and y are equal, apositive number if x is greater than y.
 */
@Override public int compare(TimeZoneTransition x,TimeZoneTransition y){
  if (x == y) {
    return 0;
  }
 else   if (x instanceof TimeZoneTransition) {
    return -1;
  }
 else   if (y instanceof TimeZoneTransition) {
    return 1;
  }
 else {
    AbsoluteDateTransition firstTransition=(AbsoluteDateTransition)x;
    AbsoluteDateTransition secondTransition=(AbsoluteDateTransition)y;
    return firstTransition.getDateTime().compareTo(secondTransition.getDateTime());
  }
}","/** 
 * Compares the transitions.
 * @param x The first transition.
 * @param y The second transition.
 * @return A negative number if x is less than y, 0 if x and y are equal, apositive number if x is greater than y.
 */
@Override public int compare(final TimeZoneTransition x,final TimeZoneTransition y){
  if (x == y) {
    return 0;
  }
 else   if (x != null && y != null) {
    final AbsoluteDateTransition firstTransition=(AbsoluteDateTransition)x;
    final AbsoluteDateTransition secondTransition=(AbsoluteDateTransition)y;
    final Date firstDateTime=firstTransition.getDateTime();
    final Date secondDateTime=secondTransition.getDateTime();
    return firstDateTime.compareTo(secondDateTime);
  }
 else   if (y == null) {
    return 1;
  }
  return -1;
}"
3918,"/** 
 * Internals the load from XML.
 * @param reader      The reader.
 * @param propertyBag The property bag.
 * @throws Exception the exception
 */
protected void internalLoadFromXml(EwsServiceXmlReader reader,PropertyBag propertyBag) throws Exception {
  OutParam<Object> complexProperty=new OutParam<Object>();
  boolean justCreated=getPropertyInstance(propertyBag,complexProperty);
  if (!justCreated && this.hasFlag(PropertyDefinitionFlags.UpdateCollectionItems,propertyBag.getOwner().getService().getRequestedServerVersion())) {
    ComplexProperty c=(ComplexProperty)complexProperty.getParam();
    if (complexProperty.getParam() instanceof ComplexProperty) {
      c.updateFromXml(reader,reader.getLocalName());
    }
  }
 else {
    ComplexProperty c=(ComplexProperty)complexProperty.getParam();
    c.loadFromXml(reader,reader.getLocalName());
  }
  propertyBag.setObjectFromPropertyDefinition(this,complexProperty.getParam());
}","/** 
 * Internals the load from XML.
 * @param reader      The reader.
 * @param propertyBag The property bag.
 * @throws Exception the exception
 */
protected void internalLoadFromXml(EwsServiceXmlReader reader,PropertyBag propertyBag) throws Exception {
  OutParam<Object> complexProperty=new OutParam<Object>();
  boolean justCreated=getPropertyInstance(propertyBag,complexProperty);
  if (!justCreated && this.hasFlag(PropertyDefinitionFlags.UpdateCollectionItems,propertyBag.getOwner().getService().getRequestedServerVersion())) {
    Object c=complexProperty.getParam();
    if (c instanceof ComplexProperty) {
      ((ComplexProperty)c).updateFromXml(reader,reader.getLocalName());
    }
  }
 else {
    ComplexProperty c=(ComplexProperty)complexProperty.getParam();
    c.loadFromXml(reader,reader.getLocalName());
  }
  propertyBag.setObjectFromPropertyDefinition(this,complexProperty.getParam());
}"
3919,"/** 
 * Gets the enabled autodiscover endpoints on a specific host.
 * @param host      The host.
 * @param endpoints Endpoints found for host.
 * @return Flags indicating which endpoints are enabled.
 * @throws Exception the exception
 */
private boolean tryGetEnabledEndpointsForHost(String host,OutParam<EnumSet<AutodiscoverEndpoints>> endpoints) throws Exception {
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",host));
  for (int currentHop=0; currentHop < AutodiscoverMaxRedirections; currentHop++) {
    URI autoDiscoverUrl=new URI(String.format(AutodiscoverLegacyHttpsUrl,host));
    endpoints.setParam(EnumSet.of(AutodiscoverEndpoints.None));
    HttpWebRequest request=null;
    try {
      request=new HttpClientWebRequest(httpClient,httpContext);
      try {
        request.setUrl(autoDiscoverUrl.toURL());
      }
 catch (      MalformedURLException e) {
        String strErr=String.format(""String_Node_Str"",url);
        throw new ServiceLocalException(strErr);
      }
      request.setRequestMethod(""String_Node_Str"");
      request.setAllowAutoRedirect(false);
      request.setPreAuthenticate(false);
      request.setUseDefaultCredentials(this.getUseDefaultCredentials());
      prepareCredentials(request);
      request.prepareConnection();
      try {
        request.executeRequest();
      }
 catch (      IOException e) {
        return false;
      }
      OutParam<URI> outParam=new OutParam<URI>();
      if (this.tryGetRedirectionResponse(request,outParam)) {
        URI redirectUrl=outParam.getParam();
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectUrl.getHost()));
        host=redirectUrl.getHost();
      }
 else {
        endpoints.setParam(this.getEndpointsFromHttpWebResponse(request));
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",endpoints.getParam().toString()));
        return true;
      }
    }
  finally {
      if (request != null) {
        try {
          request.close();
        }
 catch (        Exception e) {
        }
      }
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new MaximumRedirectionHopsExceededException();
}","/** 
 * Gets the enabled autodiscover endpoints on a specific host.
 * @param host      The host.
 * @param endpoints Endpoints found for host.
 * @return Flags indicating which endpoints are enabled.
 * @throws Exception the exception
 */
private boolean tryGetEnabledEndpointsForHost(String host,OutParam<EnumSet<AutodiscoverEndpoints>> endpoints) throws Exception {
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",host));
  for (int currentHop=0; currentHop < AutodiscoverMaxRedirections; currentHop++) {
    URI autoDiscoverUrl=new URI(String.format(AutodiscoverLegacyHttpsUrl,host));
    endpoints.setParam(EnumSet.of(AutodiscoverEndpoints.None));
    HttpWebRequest request=null;
    try {
      request=new HttpClientWebRequest(httpClient,httpContext);
      request.setProxy(getWebProxy());
      try {
        request.setUrl(autoDiscoverUrl.toURL());
      }
 catch (      MalformedURLException e) {
        String strErr=String.format(""String_Node_Str"",url);
        throw new ServiceLocalException(strErr);
      }
      request.setRequestMethod(""String_Node_Str"");
      request.setAllowAutoRedirect(false);
      request.setPreAuthenticate(false);
      request.setUseDefaultCredentials(this.getUseDefaultCredentials());
      prepareCredentials(request);
      request.prepareConnection();
      try {
        request.executeRequest();
      }
 catch (      IOException e) {
        return false;
      }
      OutParam<URI> outParam=new OutParam<URI>();
      if (this.tryGetRedirectionResponse(request,outParam)) {
        URI redirectUrl=outParam.getParam();
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectUrl.getHost()));
        host=redirectUrl.getHost();
      }
 else {
        endpoints.setParam(this.getEndpointsFromHttpWebResponse(request));
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",endpoints.getParam().toString()));
        return true;
      }
    }
  finally {
      if (request != null) {
        try {
          request.close();
        }
 catch (        Exception e) {
        }
      }
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new MaximumRedirectionHopsExceededException();
}"
3920,"/** 
 * Gets a redirection URL to an SSL-enabled Autodiscover service from the standard non-SSL Autodiscover URL.
 * @param domainName the domain name
 * @return A valid SSL-enabled redirection URL. (May be null)
 * @throws EWSHttpException the eWS http exception
 * @throws XMLStreamException the XML stream exception
 * @throws IOException Signals that an I/O exception has occurred.
 * @throws ServiceLocalException the service local exception
 * @throws URISyntaxException the uRI syntax exception
 */
private URI getRedirectUrl(String domainName) throws EWSHttpException, XMLStreamException, IOException, ServiceLocalException, URISyntaxException {
  String url=String.format(AutodiscoverLegacyHttpUrl,""String_Node_Str"" + domainName);
  traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",url));
  HttpWebRequest request=null;
  try {
    request=new HttpClientWebRequest(httpClient,httpContext);
    try {
      request.setUrl(URI.create(url).toURL());
    }
 catch (    MalformedURLException e) {
      String strErr=String.format(""String_Node_Str"",url);
      throw new ServiceLocalException(strErr);
    }
    request.setRequestMethod(""String_Node_Str"");
    request.setAllowAutoRedirect(false);
    request.setAllowAuthentication(false);
    prepareCredentials(request);
    request.prepareConnection();
    try {
      request.executeRequest();
    }
 catch (    IOException e) {
      traceMessage(TraceFlags.AutodiscoverConfiguration,""String_Node_Str"");
      return null;
    }
    OutParam<URI> outParam=new OutParam<URI>();
    if (tryGetRedirectionResponse(request,outParam)) {
      return outParam.getParam();
    }
  }
  finally {
    if (request != null) {
      try {
        request.close();
      }
 catch (      Exception e) {
      }
    }
  }
  traceMessage(TraceFlags.AutodiscoverConfiguration,""String_Node_Str"");
  return null;
}","/** 
 * Gets a redirection URL to an SSL-enabled Autodiscover service from the standard non-SSL Autodiscover URL.
 * @param domainName the domain name
 * @return A valid SSL-enabled redirection URL. (May be null)
 * @throws EWSHttpException the eWS http exception
 * @throws XMLStreamException the XML stream exception
 * @throws IOException Signals that an I/O exception has occurred.
 * @throws ServiceLocalException the service local exception
 * @throws URISyntaxException the uRI syntax exception
 */
private URI getRedirectUrl(String domainName) throws EWSHttpException, XMLStreamException, IOException, ServiceLocalException, URISyntaxException {
  String url=String.format(AutodiscoverLegacyHttpUrl,""String_Node_Str"" + domainName);
  traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",url));
  HttpWebRequest request=null;
  try {
    request=new HttpClientWebRequest(httpClient,httpContext);
    request.setProxy(getWebProxy());
    try {
      request.setUrl(URI.create(url).toURL());
    }
 catch (    MalformedURLException e) {
      String strErr=String.format(""String_Node_Str"",url);
      throw new ServiceLocalException(strErr);
    }
    request.setRequestMethod(""String_Node_Str"");
    request.setAllowAutoRedirect(false);
    request.setAllowAuthentication(false);
    prepareCredentials(request);
    request.prepareConnection();
    try {
      request.executeRequest();
    }
 catch (    IOException e) {
      traceMessage(TraceFlags.AutodiscoverConfiguration,""String_Node_Str"");
      return null;
    }
    OutParam<URI> outParam=new OutParam<URI>();
    if (tryGetRedirectionResponse(request,outParam)) {
      return outParam.getParam();
    }
  }
  finally {
    if (request != null) {
      try {
        request.close();
      }
 catch (      Exception e) {
      }
    }
  }
  traceMessage(TraceFlags.AutodiscoverConfiguration,""String_Node_Str"");
  return null;
}"
3921,"/** 
 * Gets the autodiscover url.
 * @param emailAddress                   the email address
 * @param requestedServerVersion         the Exchange version
 * @param validateRedirectionUrlCallback the validate redirection url callback
 * @return the autodiscover url
 * @throws Exception the exception
 */
private URI getAutodiscoverUrl(String emailAddress,ExchangeVersion requestedServerVersion,IAutodiscoverRedirectionUrl validateRedirectionUrlCallback) throws Exception {
  AutodiscoverService autodiscoverService=new AutodiscoverService(this,requestedServerVersion);
  autodiscoverService.setRedirectionUrlValidationCallback(validateRedirectionUrlCallback);
  autodiscoverService.setEnableScpLookup(this.getEnableScpLookup());
  GetUserSettingsResponse response=autodiscoverService.getUserSettings(emailAddress,UserSettingName.InternalEwsUrl,UserSettingName.ExternalEwsUrl);
switch (response.getErrorCode()) {
case NoError:
    return this.getEwsUrlFromResponse(response,autodiscoverService.isExternal().TRUE);
case InvalidUser:
  throw new ServiceRemoteException(String.format(""String_Node_Str"",emailAddress));
case InvalidRequest:
throw new ServiceRemoteException(String.format(""String_Node_Str"",response.getErrorMessage()));
default :
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"" + ""String_Node_Str"",emailAddress,response.getErrorCode()));
throw new ServiceRemoteException(response.getErrorMessage());
}
}","/** 
 * Gets the autodiscover url.
 * @param emailAddress                   the email address
 * @param requestedServerVersion         the Exchange version
 * @param validateRedirectionUrlCallback the validate redirection url callback
 * @return the autodiscover url
 * @throws Exception the exception
 */
private URI getAutodiscoverUrl(String emailAddress,ExchangeVersion requestedServerVersion,IAutodiscoverRedirectionUrl validateRedirectionUrlCallback) throws Exception {
  AutodiscoverService autodiscoverService=new AutodiscoverService(this,requestedServerVersion);
  autodiscoverService.setWebProxy(getWebProxy());
  autodiscoverService.setRedirectionUrlValidationCallback(validateRedirectionUrlCallback);
  autodiscoverService.setEnableScpLookup(this.getEnableScpLookup());
  GetUserSettingsResponse response=autodiscoverService.getUserSettings(emailAddress,UserSettingName.InternalEwsUrl,UserSettingName.ExternalEwsUrl);
switch (response.getErrorCode()) {
case NoError:
    return this.getEwsUrlFromResponse(response,autodiscoverService.isExternal().TRUE);
case InvalidUser:
  throw new ServiceRemoteException(String.format(""String_Node_Str"",emailAddress));
case InvalidRequest:
throw new ServiceRemoteException(String.format(""String_Node_Str"",response.getErrorMessage()));
default :
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"" + ""String_Node_Str"",emailAddress,response.getErrorCode()));
throw new ServiceRemoteException(response.getErrorMessage());
}
}"
3922,"/** 
 * Creates an HttpWebRequest instance and initialises it with the appropriate parameters, based on the configuration of this service object.
 * @param url                The URL that the HttpWebRequest should target.
 * @param acceptGzipEncoding If true, ask server for GZip compressed content.
 * @param allowAutoRedirect  If true, redirection response will be automatically followed.
 * @return An initialised instance of HttpWebRequest.
 * @throws microsoft.exchange.webservices.data.exception.ServiceLocalException       the service local exception
 * @throws java.net.URISyntaxException the uRI syntax exception
 */
protected HttpWebRequest prepareHttpWebRequestForUrl(URI url,boolean acceptGzipEncoding,boolean allowAutoRedirect) throws ServiceLocalException, URISyntaxException {
  String scheme=url.getScheme();
  if (!scheme.equalsIgnoreCase(EWSConstants.HTTP_SCHEME) && !scheme.equalsIgnoreCase(EWSConstants.HTTPS_SCHEME)) {
    String strErr=String.format(""String_Node_Str"",scheme);
    throw new ServiceLocalException(strErr);
  }
  request=new HttpClientWebRequest(httpClient,httpContext);
  try {
    request.setUrl(url.toURL());
  }
 catch (  MalformedURLException e) {
    String strErr=String.format(""String_Node_Str"",url);
    throw new ServiceLocalException(strErr);
  }
  request.setPreAuthenticate(preAuthenticate);
  request.setTimeout(timeout);
  request.setContentType(""String_Node_Str"");
  request.setAccept(""String_Node_Str"");
  request.setUserAgent(userAgent);
  request.setAllowAutoRedirect(allowAutoRedirect);
  request.setAcceptGzipEncoding(acceptGzipEncoding);
  request.setHeaders(getHttpHeaders());
  prepareCredentials(request);
  request.prepareConnection();
  httpResponseHeaders.clear();
  return request;
}","/** 
 * Creates an HttpWebRequest instance and initialises it with the appropriate parameters, based on the configuration of this service object.
 * @param url                The URL that the HttpWebRequest should target.
 * @param acceptGzipEncoding If true, ask server for GZip compressed content.
 * @param allowAutoRedirect  If true, redirection response will be automatically followed.
 * @return An initialised instance of HttpWebRequest.
 * @throws microsoft.exchange.webservices.data.exception.ServiceLocalException       the service local exception
 * @throws java.net.URISyntaxException the uRI syntax exception
 */
protected HttpWebRequest prepareHttpWebRequestForUrl(URI url,boolean acceptGzipEncoding,boolean allowAutoRedirect) throws ServiceLocalException, URISyntaxException {
  String scheme=url.getScheme();
  if (!scheme.equalsIgnoreCase(EWSConstants.HTTP_SCHEME) && !scheme.equalsIgnoreCase(EWSConstants.HTTPS_SCHEME)) {
    String strErr=String.format(""String_Node_Str"",scheme);
    throw new ServiceLocalException(strErr);
  }
  request=new HttpClientWebRequest(httpClient,httpContext);
  request.setProxy(getWebProxy());
  try {
    request.setUrl(url.toURL());
  }
 catch (  MalformedURLException e) {
    String strErr=String.format(""String_Node_Str"",url);
    throw new ServiceLocalException(strErr);
  }
  request.setPreAuthenticate(preAuthenticate);
  request.setTimeout(timeout);
  request.setContentType(""String_Node_Str"");
  request.setAccept(""String_Node_Str"");
  request.setUserAgent(userAgent);
  request.setAllowAutoRedirect(allowAutoRedirect);
  request.setAcceptGzipEncoding(acceptGzipEncoding);
  request.setHeaders(getHttpHeaders());
  prepareCredentials(request);
  request.prepareConnection();
  httpResponseHeaders.clear();
  return request;
}"
3923,"/** 
 * Parses the.
 * @param < T >   the generic type
 * @param cls   the cls
 * @param value the value
 * @return the t
 * @throws InstantiationException   the instantiation exception
 * @throws IllegalAccessException   the illegal access exception
 * @throws java.text.ParseException the parse exception
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T parse(Class<T> cls,String value) throws InstantiationException, IllegalAccessException, ParseException {
  if (cls.isEnum()) {
    final Map<Class<?>,Map<String,String>> member=SCHEMA_TO_ENUM_DICTIONARIES.getMember();
    String val=value;
    final Map<String,String> stringToEnumDict=member.get(cls);
    if (stringToEnumDict != null) {
      final String strEnumName=stringToEnumDict.get(value);
      if (strEnumName != null) {
        val=strEnumName;
      }
    }
    for (    T o : cls.getEnumConstants()) {
      if (o.toString().equals(val)) {
        return o;
      }
    }
    return null;
  }
 else   if (cls.isAssignableFrom(Double.class)) {
    return (T)((Double)Double.parseDouble(value));
  }
 else   if (cls.isAssignableFrom(Number.class)) {
    return (T)((Integer)Integer.parseInt(value));
  }
 else   if (cls.isAssignableFrom(Date.class)) {
    DateFormat df=createDateFormat(XML_SCHEMA_DATE_TIME_FORMAT);
    return (T)df.parse(value);
  }
 else   if (cls.isAssignableFrom(Boolean.class)) {
    return (T)((Boolean)Boolean.parseBoolean(value));
  }
 else   if (cls.isAssignableFrom(String.class)) {
    return (T)value;
  }
  return null;
}","/** 
 * Parses the.
 * @param < T >   the generic type
 * @param cls   the cls
 * @param value the value
 * @return the t
 * @throws java.text.ParseException the parse exception
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T parse(Class<T> cls,String value) throws ParseException {
  if (cls.isEnum()) {
    final Map<Class<?>,Map<String,String>> member=SCHEMA_TO_ENUM_DICTIONARIES.getMember();
    String val=value;
    final Map<String,String> stringToEnumDict=member.get(cls);
    if (stringToEnumDict != null) {
      final String strEnumName=stringToEnumDict.get(value);
      if (strEnumName != null) {
        val=strEnumName;
      }
    }
    for (    T o : cls.getEnumConstants()) {
      if (o.toString().equals(val)) {
        return o;
      }
    }
    return null;
  }
 else   if (Number.class.isAssignableFrom(cls)) {
    if (Double.class.isAssignableFrom(cls)) {
      return (T)((Double)Double.parseDouble(value));
    }
 else     if (Integer.class.isAssignableFrom(cls)) {
      return (T)((Integer)Integer.parseInt(value));
    }
 else     if (Long.class.isAssignableFrom(cls)) {
      return (T)((Long)Long.parseLong(value));
    }
 else     if (Float.class.isAssignableFrom(cls)) {
      return (T)((Float)Float.parseFloat(value));
    }
 else     if (Byte.class.isAssignableFrom(cls)) {
      return (T)((Byte)Byte.parseByte(value));
    }
 else     if (Short.class.isAssignableFrom(cls)) {
      return (T)((Short)Short.parseShort(value));
    }
 else     if (BigInteger.class.isAssignableFrom(cls)) {
      return (T)(new BigInteger(value));
    }
 else     if (BigDecimal.class.isAssignableFrom(cls)) {
      return (T)(new BigDecimal(value));
    }
  }
 else   if (Date.class.isAssignableFrom(cls)) {
    DateFormat df=createDateFormat(XML_SCHEMA_DATE_TIME_FORMAT);
    return (T)df.parse(value);
  }
 else   if (Boolean.class.isAssignableFrom(cls)) {
    return (T)((Boolean)Boolean.parseBoolean(value));
  }
 else   if (String.class.isAssignableFrom(cls)) {
    return (T)value;
  }
  return null;
}"
3924,"@Test public void testGetItemTypeFromXmlElementName(){
  Assert.assertEquals(Task.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(EmailMessage.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(PostItem.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(SearchFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(Conversation.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(Folder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(CalendarFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(MeetingMessage.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(Contact.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(Item.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(Appointment.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(ContactsFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(MeetingRequest.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(TasksFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(MeetingCancellation.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(MeetingResponse.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  Assert.assertEquals(ContactGroup.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
}","@Test public void testGetItemTypeFromXmlElementName(){
  assertEquals(Task.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(EmailMessage.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(PostItem.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(SearchFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(Conversation.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(Folder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(CalendarFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(MeetingMessage.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(Contact.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(Item.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(Appointment.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(ContactsFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(MeetingRequest.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(TasksFolder.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(MeetingCancellation.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(MeetingResponse.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
  assertEquals(ContactGroup.class,EwsUtilities.getItemTypeFromXmlElementName(""String_Node_Str""));
}"
3925,"@Test public void testGetBuildVersion(){
  Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",EwsUtilities.getBuildVersion());
}","@Test public void testGetBuildVersion(){
  assertEquals(""String_Node_Str"",""String_Node_Str"",EwsUtilities.getBuildVersion());
}"
3926,"@Test public void testEwsAssert(){
  EwsUtilities.EwsAssert(true,null,null);
  try {
    EwsUtilities.EwsAssert(false,""String_Node_Str"",""String_Node_Str"");
  }
 catch (  final RuntimeException ex) {
    Assert.assertEquals(""String_Node_Str"",ex.getMessage());
  }
}","@Test public void testEwsAssert(){
  EwsUtilities.EwsAssert(true,null,null);
  try {
    EwsUtilities.EwsAssert(false,""String_Node_Str"",""String_Node_Str"");
  }
 catch (  final RuntimeException ex) {
    assertEquals(""String_Node_Str"",ex.getMessage());
  }
}"
3927,"/** 
 * Reads attribute from XML.
 * @param writer the writer
 * @throws microsoft.exchange.webservices.data.exception.ServiceXmlSerializationException the service xml serialization exception
 */
public void writeAttributesToXml(EwsServiceXmlWriter writer) throws ServiceXmlSerializationException {
  writer.writeAttributeValue(XmlAttributeNames.BodyType,this.bodyType);
}","/** 
 * Writes attributes from XML.
 * @param writer the writer
 * @throws microsoft.exchange.webservices.data.exception.ServiceXmlSerializationException the service xml serialization exception
 */
public void writeAttributesToXml(EwsServiceXmlWriter writer) throws ServiceXmlSerializationException {
  writer.writeAttributeValue(XmlAttributeNames.BodyType,this.bodyType);
}"
3928,"/** 
 * Reads attribute from XML.
 * @param reader the reader
 * @throws javax.xml.stream.XMLStreamException the xML stream exception
 * @throws ServiceXmlDeserializationException  the service xml deserialization exception
 */
public void readTextValueFromXml(EwsServiceXmlReader reader) throws XMLStreamException, ServiceXmlDeserializationException {
  this.text=reader.readValue();
}","/** 
 * Reads attribute from XML.
 * @param reader the reader
 * @throws javax.xml.stream.XMLStreamException the xml stream exception
 * @throws ServiceXmlDeserializationException  the service xml deserialization exception
 */
public void readTextValueFromXml(EwsServiceXmlReader reader) throws XMLStreamException, ServiceXmlDeserializationException {
  this.text=reader.readValue();
}"
3929,"/** 
 * Gets an attachment.
 * @param attachments          the attachments
 * @param bodyType             the body type
 * @param additionalProperties the additional properties
 * @param errorHandling        the error handling
 * @throws Exception the exception
 */
private ServiceResponseCollection<GetAttachmentResponse> internalGetAttachments(Iterable<Attachment> attachments,BodyType bodyType,Iterable<PropertyDefinitionBase> additionalProperties,ServiceErrorHandling errorHandling) throws Exception {
  GetAttachmentRequest request=new GetAttachmentRequest(this,errorHandling);
  Iterator<Attachment> it=attachments.iterator();
  while (it.hasNext()) {
    ((ArrayList<Attachment>)request.getAttachments()).add(it.next());
  }
  request.setBodyType(bodyType);
  if (additionalProperties != null) {
    List<PropertyDefinitionBase> propsArray=new ArrayList<PropertyDefinitionBase>();
    for (    PropertyDefinitionBase propertyDefinitionBase : additionalProperties) {
      propsArray.add(propertyDefinitionBase);
    }
    request.getAdditionalProperties().addAll(propsArray);
  }
  return request.execute();
}","/** 
 * Gets an attachment.
 * @param attachments          the attachments
 * @param bodyType             the body type
 * @param additionalProperties the additional properties
 * @param errorHandling        the error handling
 * @throws Exception the exception
 */
private ServiceResponseCollection<GetAttachmentResponse> internalGetAttachments(Iterable<Attachment> attachments,BodyType bodyType,Iterable<PropertyDefinitionBase> additionalProperties,ServiceErrorHandling errorHandling) throws Exception {
  GetAttachmentRequest request=new GetAttachmentRequest(this,errorHandling);
  Iterator<Attachment> it=attachments.iterator();
  while (it.hasNext()) {
    request.getAttachments().add(it.next());
  }
  request.setBodyType(bodyType);
  if (additionalProperties != null) {
    List<PropertyDefinitionBase> propsArray=new ArrayList<PropertyDefinitionBase>();
    for (    PropertyDefinitionBase propertyDefinitionBase : additionalProperties) {
      propsArray.add(propertyDefinitionBase);
    }
    request.getAdditionalProperties().addAll(propsArray);
  }
  return request.execute();
}"
3930,"/** 
 * Loads the content of the file attachment into the specified file. Calling this method results in a call to EWS.
 * @param fileName the file name
 * @throws Exception the exception
 */
public void load(String fileName) throws Exception {
  File fileStream=new File(fileName);
  FileOutputStream fos=new FileOutputStream(fileStream);
  this.loadToStream=fos;
  try {
    this.load();
  }
  finally {
    this.loadToStream.flush();
    this.loadToStream=null;
  }
  this.fileName=fileName;
  this.content=null;
  this.contentStream=null;
}","/** 
 * Loads the content of the file attachment into the specified file. Calling this method results in a call to EWS.
 * @param fileName the file name
 * @throws Exception the exception
 */
public void load(String fileName) throws Exception {
  File fileStream=new File(fileName);
  try {
    this.loadToStream=new FileOutputStream(fileStream);
    this.load();
    this.loadToStream.flush();
  }
  finally {
    try {
      this.loadToStream.close();
    }
 catch (    Exception e) {
    }
    this.loadToStream=null;
  }
  this.fileName=fileName;
  this.content=null;
  this.contentStream=null;
}"
3931,"/** 
 * Sets the recurrence.
 * @param value the new recurrence
 * @throws Exception the exception
 */
public void setRecurrence(Recurrence value) throws Exception {
  if (value != null) {
    if (value.isRegenerationPattern()) {
      throw new ServiceLocalException(Strings.RegenerationPatternsOnlyValidForTasks);
    }
  }
  this.getPropertyBag().setObjectFromPropertyDefinition(AppointmentSchema.Recurrence,value);
}","/** 
 * Sets the recurrence.
 * @param value the new recurrence
 * @throws Exception the exception
 */
public void setRecurrence(Recurrence value) throws Exception {
  if (value != null) {
    if (value.isRegenerationPattern()) {
      throw new ServiceLocalException(""String_Node_Str"");
    }
  }
  this.getPropertyBag().setObjectFromPropertyDefinition(AppointmentSchema.Recurrence,value);
}"
3932,"/** 
 * Validates this instance.
 * @throws Exception
 */
@Override protected void validate() throws Exception {
  super.validate();
  if ((this.getService().getRequestedServerVersion() == ExchangeVersion.Exchange2007_SP1) && !(this.getService().getExchange2007CompatibilityMode())) {
    if (this.getPropertyBag().isPropertyUpdated(AppointmentSchema.Start) || this.getPropertyBag().isPropertyUpdated(AppointmentSchema.End) || this.getPropertyBag().isPropertyUpdated(AppointmentSchema.IsAllDayEvent)|| this.getPropertyBag().isPropertyUpdated(AppointmentSchema.Recurrence)) {
      if (!this.getPropertyBag().contains(AppointmentSchema.StartTimeZone)) {
        throw new ServiceLocalException(Strings.StartTimeZoneRequired);
      }
      this.setStartTimeZone(this.getStartTimeZone());
    }
  }
}","/** 
 * Validates this instance.
 * @throws Exception
 */
@Override protected void validate() throws Exception {
  super.validate();
  if ((this.getService().getRequestedServerVersion() == ExchangeVersion.Exchange2007_SP1) && !(this.getService().getExchange2007CompatibilityMode())) {
    if (this.getPropertyBag().isPropertyUpdated(AppointmentSchema.Start) || this.getPropertyBag().isPropertyUpdated(AppointmentSchema.End) || this.getPropertyBag().isPropertyUpdated(AppointmentSchema.IsAllDayEvent)|| this.getPropertyBag().isPropertyUpdated(AppointmentSchema.Recurrence)) {
      if (!this.getPropertyBag().contains(AppointmentSchema.StartTimeZone)) {
        throw new ServiceLocalException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
      this.setStartTimeZone(this.getStartTimeZone());
    }
  }
}"
3933,"/** 
 * Sets the occurrence index.
 * @param occurrenceIndex the new occurrence index
 */
public void setOccurrenceIndex(int occurrenceIndex){
  if (occurrenceIndex < 1) {
    throw new IllegalArgumentException(Strings.OccurrenceIndexMustBeGreaterThanZero);
  }
  this.occurrenceIndex=occurrenceIndex;
}","/** 
 * Sets the occurrence index.
 * @param occurrenceIndex the new occurrence index
 */
public void setOccurrenceIndex(int occurrenceIndex){
  if (occurrenceIndex < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.occurrenceIndex=occurrenceIndex;
}"
3934,"public static <T extends SimpleServiceRequestBase>T extractServiceRequest(ExchangeService exchangeService,Future<?> asyncResult) throws Exception {
  EwsUtilities.validateParam(asyncResult,""String_Node_Str"");
  AsyncRequestResult asyncRequestResult=(AsyncRequestResult)asyncResult;
  if (asyncRequestResult == null) {
    throw new ArgumentException(Strings.InvalidAsyncResult,""String_Node_Str"");
  }
  if (asyncRequestResult.serviceRequest == null) {
    throw new ArgumentException(Strings.InvalidAsyncResult,""String_Node_Str"");
  }
  if (!asyncRequestResult.serviceRequest.getService().equals(exchangeService)) {
    throw new ArgumentException(Strings.InvalidAsyncResult,""String_Node_Str"");
  }
  T serviceRequest=(T)asyncRequestResult.getServiceRequest();
  if (serviceRequest == null) {
    throw new ArgumentException(Strings.InvalidAsyncResult,""String_Node_Str"");
  }
  return serviceRequest;
}","public static <T extends SimpleServiceRequestBase>T extractServiceRequest(ExchangeService exchangeService,Future<?> asyncResult) throws Exception {
  EwsUtilities.validateParam(asyncResult,""String_Node_Str"");
  AsyncRequestResult asyncRequestResult=(AsyncRequestResult)asyncResult;
  if (asyncRequestResult == null) {
    throw new ArgumentException(""String_Node_Str"",""String_Node_Str"");
  }
  if (asyncRequestResult.serviceRequest == null) {
    throw new ArgumentException(""String_Node_Str"",""String_Node_Str"");
  }
  if (!asyncRequestResult.serviceRequest.getService().equals(exchangeService)) {
    throw new ArgumentException(""String_Node_Str"",""String_Node_Str"");
  }
  T serviceRequest=(T)asyncRequestResult.getServiceRequest();
  if (serviceRequest == null) {
    throw new ArgumentException(""String_Node_Str"",""String_Node_Str"");
  }
  return serviceRequest;
}"
3935,"/** 
 * Throws exception if this is not a new service object.
 */
protected void throwIfThisIsNotNew(){
  if (!this.isNew()) {
    throw new UnsupportedOperationException(Strings.AttachmentCannotBeUpdated);
  }
}","/** 
 * Throws exception if this is not a new service object.
 */
protected void throwIfThisIsNotNew(){
  if (!this.isNew()) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}"
3936,"/** 
 * Calls the DeleteAttachment web method to delete a list of attachments.
 * @param attachments the attachments
 * @throws Exception the exception
 */
private void internalDeleteAttachments(Iterable<Attachment> attachments) throws Exception {
  ServiceResponseCollection<DeleteAttachmentResponse> responses=this.owner.getService().deleteAttachments(attachments);
  Enumeration<DeleteAttachmentResponse> enumerator=responses.getEnumerator();
  while (enumerator.hasMoreElements()) {
    DeleteAttachmentResponse response=enumerator.nextElement();
    if (response.getResult() != ServiceResult.Error) {
      this.removeFromChangeLog(response.getAttachment());
    }
  }
  if (responses.getOverallResult() == ServiceResult.Error) {
    throw new DeleteAttachmentException(responses,Strings.AtLeastOneAttachmentCouldNotBeDeleted);
  }
}","/** 
 * Calls the DeleteAttachment web method to delete a list of attachments.
 * @param attachments the attachments
 * @throws Exception the exception
 */
private void internalDeleteAttachments(Iterable<Attachment> attachments) throws Exception {
  ServiceResponseCollection<DeleteAttachmentResponse> responses=this.owner.getService().deleteAttachments(attachments);
  Enumeration<DeleteAttachmentResponse> enumerator=responses.getEnumerator();
  while (enumerator.hasMoreElements()) {
    DeleteAttachmentResponse response=enumerator.nextElement();
    if (response.getResult() != ServiceResult.Error) {
      this.removeFromChangeLog(response.getAttachment());
    }
  }
  if (responses.getOverallResult() == ServiceResult.Error) {
    throw new DeleteAttachmentException(responses,""String_Node_Str"");
  }
}"
3937,"/** 
 * Calls the CreateAttachment web method to create a list of attachments.
 * @param parentItemId the parent item id
 * @param attachments  the attachments
 * @throws Exception the exception
 */
private void internalCreateAttachments(String parentItemId,Iterable<Attachment> attachments) throws Exception {
  ServiceResponseCollection<CreateAttachmentResponse> responses=this.owner.getService().createAttachments(parentItemId,attachments);
  Enumeration<CreateAttachmentResponse> enumerator=responses.getEnumerator();
  while (enumerator.hasMoreElements()) {
    CreateAttachmentResponse response=enumerator.nextElement();
    if (response.getResult() != ServiceResult.Error) {
      this.removeFromChangeLog(response.getAttachment());
    }
  }
  if (responses.getOverallResult() == ServiceResult.Error) {
    throw new CreateAttachmentException(responses,Strings.AttachmentCreationFailed);
  }
}","/** 
 * Calls the CreateAttachment web method to create a list of attachments.
 * @param parentItemId the parent item id
 * @param attachments  the attachments
 * @throws Exception the exception
 */
private void internalCreateAttachments(String parentItemId,Iterable<Attachment> attachments) throws Exception {
  ServiceResponseCollection<CreateAttachmentResponse> responses=this.owner.getService().createAttachments(parentItemId,attachments);
  Enumeration<CreateAttachmentResponse> enumerator=responses.getEnumerator();
  while (enumerator.hasMoreElements()) {
    CreateAttachmentResponse response=enumerator.nextElement();
    if (response.getResult() != ServiceResult.Error) {
      this.removeFromChangeLog(response.getAttachment());
    }
  }
  if (responses.getOverallResult() == ServiceResult.Error) {
    throw new CreateAttachmentException(responses,""String_Node_Str"");
  }
}"
3938,"/** 
 * Removes the attachment at the specified index.
 * @param index Index of the attachment to remove.
 */
public void removeAt(int index){
  if (index < 0 || index >= this.getCount()) {
    throw new IllegalArgumentException(""String_Node_Str"" + Strings.IndexIsOutOfRange);
  }
  this.internalRemoveAt(index);
}","/** 
 * Removes the attachment at the specified index.
 * @param index Index of the attachment to remove.
 */
public void removeAt(int index){
  if (index < 0 || index >= this.getCount()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.internalRemoveAt(index);
}"
3939,"/** 
 * Validates this instance.
 * @throws Exception the exception
 */
public void validate() throws Exception {
  if (this.owner.isNew() && this.owner.getService().getRequestedServerVersion().ordinal() >= ExchangeVersion.Exchange2010_SP2.ordinal()) {
    boolean contactPhotoFound=false;
    for (int attachmentIndex=0; attachmentIndex < this.getAddedItems().size(); attachmentIndex++) {
      final Attachment attachment=this.getAddedItems().get(attachmentIndex);
      if (attachment != null && attachment.isNew() && attachment instanceof FileAttachment) {
        if (((FileAttachment)attachment).isContactPhoto()) {
          if (contactPhotoFound) {
            throw new ServiceValidationException(Strings.MultipleContactPhotosInAttachment);
          }
          contactPhotoFound=true;
        }
      }
      attachment.validate(attachmentIndex);
    }
  }
}","/** 
 * Validates this instance.
 * @throws Exception the exception
 */
public void validate() throws Exception {
  if (this.owner.isNew() && this.owner.getService().getRequestedServerVersion().ordinal() >= ExchangeVersion.Exchange2010_SP2.ordinal()) {
    boolean contactPhotoFound=false;
    for (int attachmentIndex=0; attachmentIndex < this.getAddedItems().size(); attachmentIndex++) {
      final Attachment attachment=this.getAddedItems().get(attachmentIndex);
      if (attachment != null && attachment.isNew() && attachment instanceof FileAttachment) {
        if (((FileAttachment)attachment).isContactPhoto()) {
          if (contactPhotoFound) {
            throw new ServiceValidationException(""String_Node_Str"");
          }
          contactPhotoFound=true;
        }
      }
      attachment.validate(attachmentIndex);
    }
  }
}"
3940,"/** 
 * Removes an attendee from the collection.
 * @param index the index
 */
public void removeAt(int index){
  if (index < 0 || index >= this.getCount()) {
    throw new IllegalArgumentException(""String_Node_Str"" + Strings.IndexIsOutOfRange);
  }
  this.internalRemoveAt(index);
}","/** 
 * Removes an attendee from the collection.
 * @param index the index
 */
public void removeAt(int index){
  if (index < 0 || index >= this.getCount()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.internalRemoveAt(index);
}"
3941,"/** 
 * Executes this instance.
 * @return the autodiscover response
 * @throws ServiceLocalException the service local exception
 * @throws Exception             the exception
 */
protected AutodiscoverResponse internalExecute() throws ServiceLocalException, Exception {
  this.validate();
  HttpWebRequest request=null;
  try {
    request=this.service.prepareHttpWebRequestForUrl(this.url);
    this.service.traceHttpRequestHeaders(TraceFlags.AutodiscoverRequestHttpHeaders,request);
    boolean needSignature=this.getService().getCredentials() != null && this.getService().getCredentials().isNeedSignature();
    boolean needTrace=this.getService().isTraceEnabledFor(TraceFlags.AutodiscoverRequest);
    OutputStream urlOutStream=request.getOutputStream();
    ByteArrayOutputStream memoryStream=new ByteArrayOutputStream();
    EwsServiceXmlWriter writer=new EwsServiceXmlWriter(this.getService(),memoryStream);
    writer.setRequireWSSecurityUtilityNamespace(needSignature);
    this.writeSoapRequest(this.url,writer);
    if (needSignature) {
      this.service.getCredentials().sign(memoryStream);
    }
    if (needTrace) {
      memoryStream.flush();
      this.service.traceXml(TraceFlags.AutodiscoverRequest,memoryStream);
    }
    memoryStream.writeTo(urlOutStream);
    urlOutStream.flush();
    urlOutStream.close();
    memoryStream.close();
    request.executeRequest();
    request.getResponseCode();
    if (AutodiscoverRequest.isRedirectionResponse(request)) {
      AutodiscoverResponse response=this.createRedirectionResponse(request);
      if (response != null) {
        return response;
      }
 else {
        throw new ServiceRemoteException(Strings.InvalidRedirectionResponseReturned);
      }
    }
    memoryStream=new ByteArrayOutputStream();
    InputStream serviceResponseStream=request.getInputStream();
    while (true) {
      int data=serviceResponseStream.read();
      if (-1 == data) {
        break;
      }
 else {
        memoryStream.write(data);
      }
    }
    memoryStream.flush();
    serviceResponseStream.close();
    if (this.service.isTraceEnabled()) {
      this.service.traceResponse(request,memoryStream);
    }
    ByteArrayInputStream memoryStreamIn=new ByteArrayInputStream(memoryStream.toByteArray());
    EwsXmlReader ewsXmlReader=new EwsXmlReader(memoryStreamIn);
    ewsXmlReader.read();
    if (ewsXmlReader.getNodeType().getNodeType() == XmlNodeType.START_DOCUMENT) {
      ewsXmlReader.readStartElement(XmlNamespace.Soap,XmlElementNames.SOAPEnvelopeElementName);
    }
 else     if ((ewsXmlReader.getNodeType().getNodeType() != XmlNodeType.START_ELEMENT) || (!ewsXmlReader.getLocalName().equals(XmlElementNames.SOAPEnvelopeElementName)) || (!ewsXmlReader.getNamespaceUri().equals(EwsUtilities.getNamespaceUri(XmlNamespace.Soap)))) {
      throw new ServiceXmlDeserializationException(Strings.InvalidAutodiscoverServiceResponse);
    }
    this.readSoapHeaders(ewsXmlReader);
    AutodiscoverResponse response=this.readSoapBody(ewsXmlReader);
    ewsXmlReader.readEndElement(XmlNamespace.Soap,XmlElementNames.SOAPEnvelopeElementName);
    if (response.getErrorCode() == AutodiscoverErrorCode.NoError) {
      return response;
    }
 else {
      throw new AutodiscoverResponseException(response.getErrorCode(),response.getErrorMessage());
    }
  }
 catch (  XMLStreamException ex) {
    this.service.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",ex.getMessage()));
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,ex.getMessage()),ex);
  }
catch (  IOException ex) {
    this.service.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",ex.getMessage()));
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,ex.getMessage()),ex);
  }
catch (  Exception ex) {
    if (null != request && request.getResponseCode() == 7) {
      if (AutodiscoverRequest.isRedirectionResponse(request)) {
        this.service.processHttpResponseHeaders(TraceFlags.AutodiscoverResponseHttpHeaders,request);
        AutodiscoverResponse response=this.createRedirectionResponse(request);
        if (response != null) {
          return response;
        }
      }
 else {
        this.processWebException(ex,request);
      }
    }
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,ex.getMessage()),ex);
  }
 finally {
    try {
      if (request != null) {
        request.close();
      }
    }
 catch (    Exception e) {
    }
  }
}","/** 
 * Executes this instance.
 * @return the autodiscover response
 * @throws ServiceLocalException the service local exception
 * @throws Exception             the exception
 */
protected AutodiscoverResponse internalExecute() throws ServiceLocalException, Exception {
  this.validate();
  HttpWebRequest request=null;
  try {
    request=this.service.prepareHttpWebRequestForUrl(this.url);
    this.service.traceHttpRequestHeaders(TraceFlags.AutodiscoverRequestHttpHeaders,request);
    boolean needSignature=this.getService().getCredentials() != null && this.getService().getCredentials().isNeedSignature();
    boolean needTrace=this.getService().isTraceEnabledFor(TraceFlags.AutodiscoverRequest);
    OutputStream urlOutStream=request.getOutputStream();
    ByteArrayOutputStream memoryStream=new ByteArrayOutputStream();
    EwsServiceXmlWriter writer=new EwsServiceXmlWriter(this.getService(),memoryStream);
    writer.setRequireWSSecurityUtilityNamespace(needSignature);
    this.writeSoapRequest(this.url,writer);
    if (needSignature) {
      this.service.getCredentials().sign(memoryStream);
    }
    if (needTrace) {
      memoryStream.flush();
      this.service.traceXml(TraceFlags.AutodiscoverRequest,memoryStream);
    }
    memoryStream.writeTo(urlOutStream);
    urlOutStream.flush();
    urlOutStream.close();
    memoryStream.close();
    request.executeRequest();
    request.getResponseCode();
    if (AutodiscoverRequest.isRedirectionResponse(request)) {
      AutodiscoverResponse response=this.createRedirectionResponse(request);
      if (response != null) {
        return response;
      }
 else {
        throw new ServiceRemoteException(""String_Node_Str"");
      }
    }
    memoryStream=new ByteArrayOutputStream();
    InputStream serviceResponseStream=request.getInputStream();
    while (true) {
      int data=serviceResponseStream.read();
      if (-1 == data) {
        break;
      }
 else {
        memoryStream.write(data);
      }
    }
    memoryStream.flush();
    serviceResponseStream.close();
    if (this.service.isTraceEnabled()) {
      this.service.traceResponse(request,memoryStream);
    }
    ByteArrayInputStream memoryStreamIn=new ByteArrayInputStream(memoryStream.toByteArray());
    EwsXmlReader ewsXmlReader=new EwsXmlReader(memoryStreamIn);
    ewsXmlReader.read();
    if (ewsXmlReader.getNodeType().getNodeType() == XmlNodeType.START_DOCUMENT) {
      ewsXmlReader.readStartElement(XmlNamespace.Soap,XmlElementNames.SOAPEnvelopeElementName);
    }
 else     if ((ewsXmlReader.getNodeType().getNodeType() != XmlNodeType.START_ELEMENT) || (!ewsXmlReader.getLocalName().equals(XmlElementNames.SOAPEnvelopeElementName)) || (!ewsXmlReader.getNamespaceUri().equals(EwsUtilities.getNamespaceUri(XmlNamespace.Soap)))) {
      throw new ServiceXmlDeserializationException(""String_Node_Str"");
    }
    this.readSoapHeaders(ewsXmlReader);
    AutodiscoverResponse response=this.readSoapBody(ewsXmlReader);
    ewsXmlReader.readEndElement(XmlNamespace.Soap,XmlElementNames.SOAPEnvelopeElementName);
    if (response.getErrorCode() == AutodiscoverErrorCode.NoError) {
      return response;
    }
 else {
      throw new AutodiscoverResponseException(response.getErrorCode(),response.getErrorMessage());
    }
  }
 catch (  XMLStreamException ex) {
    this.service.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",ex.getMessage()));
    throw new ServiceRequestException(String.format(""String_Node_Str"",ex.getMessage()),ex);
  }
catch (  IOException ex) {
    this.service.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",ex.getMessage()));
    throw new ServiceRequestException(String.format(""String_Node_Str"",ex.getMessage()),ex);
  }
catch (  Exception ex) {
    if (null != request && request.getResponseCode() == 7) {
      if (AutodiscoverRequest.isRedirectionResponse(request)) {
        this.service.processHttpResponseHeaders(TraceFlags.AutodiscoverResponseHttpHeaders,request);
        AutodiscoverResponse response=this.createRedirectionResponse(request);
        if (response != null) {
          return response;
        }
      }
 else {
        this.processWebException(ex,request);
      }
    }
    throw new ServiceRequestException(String.format(""String_Node_Str"",ex.getMessage()),ex);
  }
 finally {
    try {
      if (request != null) {
        request.close();
      }
    }
 catch (    Exception e) {
    }
  }
}"
3942,"/** 
 * Gets user or domain settings using Autodiscover SOAP service.
 * @param < TGetSettingsResponseCollection > the generic type
 * @param < TSettingName >                   the generic type
 * @param cls                              the cls
 * @param cls1                             the cls1
 * @param identities                       Either the domains or the SMTP addresses of the users.
 * @param settings                         The settings.
 * @param requestedVersion                 Requested version of the Exchange service.
 * @param getSettingsMethod                The method to use.
 * @param getDomainMethod                  The method to calculate the domain value.
 * @return TGetSettingsResponse Collection.
 * @throws Exception the exception
 */
private <TGetSettingsResponseCollection,TSettingName>TGetSettingsResponseCollection getSettings(Class<TGetSettingsResponseCollection> cls,Class<TSettingName> cls1,List<String> identities,List<TSettingName> settings,ExchangeVersion requestedVersion,IFunctionDelegate<List<String>,List<TSettingName>,TGetSettingsResponseCollection> getSettingsMethod,IFuncDelegate<String> getDomainMethod) throws Exception {
  TGetSettingsResponseCollection response;
  if (this.getRequestedServerVersion().compareTo(MinimumRequestVersionForAutoDiscoverSoapService) < 0) {
    throw new ServiceVersionException(String.format(Strings.AutodiscoverServiceIncompatibleWithRequestVersion,MinimumRequestVersionForAutoDiscoverSoapService));
  }
  if (this.url != null) {
    URI autodiscoverUrl=this.url;
    response=getSettingsMethod.func(identities,settings,requestedVersion,this.url);
    this.url=autodiscoverUrl;
    return response;
  }
 else   if (!(this.domain == null || this.domain.isEmpty())) {
    URI autodiscoverUrl=this.getAutodiscoverEndpointUrl(this.domain);
    response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
    this.url=autodiscoverUrl;
    return response;
  }
 else {
    this.isExternal=true;
    URI autodiscoverUrl;
    String domainName=getDomainMethod.func();
    int scpHostCount;
    OutParam<Integer> outParam=new OutParam<Integer>();
    List<String> hosts=this.getAutodiscoverServiceHosts(domainName,outParam);
    scpHostCount=outParam.getParam();
    if (hosts.size() == 0) {
      throw new ServiceValidationException(Strings.AutodiscoverServiceRequestRequiresDomainOrUrl);
    }
    for (int currentHostIndex=0; currentHostIndex < hosts.size(); currentHostIndex++) {
      String host=hosts.get(currentHostIndex);
      boolean isScpHost=currentHostIndex < scpHostCount;
      OutParam<URI> outParams=new OutParam<URI>();
      if (this.tryGetAutodiscoverEndpointUrl(host,outParams)) {
        autodiscoverUrl=outParams.getParam();
        response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
        this.url=autodiscoverUrl;
        if (isScpHost) {
          this.isExternal=false;
        }
        return response;
      }
    }
    autodiscoverUrl=this.getRedirectUrl(domainName);
    OutParam<URI> outParamUrl=new OutParam<URI>();
    if ((autodiscoverUrl != null) && this.callRedirectionUrlValidationCallback(autodiscoverUrl.toString()) && this.tryGetAutodiscoverEndpointUrl(autodiscoverUrl.getHost(),outParamUrl)) {
      autodiscoverUrl=outParamUrl.getParam();
      response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
      this.url=autodiscoverUrl;
      return response;
    }
    autodiscoverUrl=this.getRedirectionUrlFromDnsSrvRecord(domainName);
    if ((autodiscoverUrl != null) && this.callRedirectionUrlValidationCallback(autodiscoverUrl.toString()) && this.tryGetAutodiscoverEndpointUrl(autodiscoverUrl.getHost(),outParamUrl)) {
      autodiscoverUrl=outParamUrl.getParam();
      response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
      this.url=autodiscoverUrl;
      return response;
    }
 else {
      throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
    }
  }
}","/** 
 * Gets user or domain settings using Autodiscover SOAP service.
 * @param < TGetSettingsResponseCollection > the generic type
 * @param < TSettingName >                   the generic type
 * @param cls                              the cls
 * @param cls1                             the cls1
 * @param identities                       Either the domains or the SMTP addresses of the users.
 * @param settings                         The settings.
 * @param requestedVersion                 Requested version of the Exchange service.
 * @param getSettingsMethod                The method to use.
 * @param getDomainMethod                  The method to calculate the domain value.
 * @return TGetSettingsResponse Collection.
 * @throws Exception the exception
 */
private <TGetSettingsResponseCollection,TSettingName>TGetSettingsResponseCollection getSettings(Class<TGetSettingsResponseCollection> cls,Class<TSettingName> cls1,List<String> identities,List<TSettingName> settings,ExchangeVersion requestedVersion,IFunctionDelegate<List<String>,List<TSettingName>,TGetSettingsResponseCollection> getSettingsMethod,IFuncDelegate<String> getDomainMethod) throws Exception {
  TGetSettingsResponseCollection response;
  if (this.getRequestedServerVersion().compareTo(MinimumRequestVersionForAutoDiscoverSoapService) < 0) {
    throw new ServiceVersionException(String.format(""String_Node_Str"",MinimumRequestVersionForAutoDiscoverSoapService));
  }
  if (this.url != null) {
    URI autodiscoverUrl=this.url;
    response=getSettingsMethod.func(identities,settings,requestedVersion,this.url);
    this.url=autodiscoverUrl;
    return response;
  }
 else   if (!(this.domain == null || this.domain.isEmpty())) {
    URI autodiscoverUrl=this.getAutodiscoverEndpointUrl(this.domain);
    response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
    this.url=autodiscoverUrl;
    return response;
  }
 else {
    this.isExternal=true;
    URI autodiscoverUrl;
    String domainName=getDomainMethod.func();
    int scpHostCount;
    OutParam<Integer> outParam=new OutParam<Integer>();
    List<String> hosts=this.getAutodiscoverServiceHosts(domainName,outParam);
    scpHostCount=outParam.getParam();
    if (hosts.size() == 0) {
      throw new ServiceValidationException(""String_Node_Str"");
    }
    for (int currentHostIndex=0; currentHostIndex < hosts.size(); currentHostIndex++) {
      String host=hosts.get(currentHostIndex);
      boolean isScpHost=currentHostIndex < scpHostCount;
      OutParam<URI> outParams=new OutParam<URI>();
      if (this.tryGetAutodiscoverEndpointUrl(host,outParams)) {
        autodiscoverUrl=outParams.getParam();
        response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
        this.url=autodiscoverUrl;
        if (isScpHost) {
          this.isExternal=false;
        }
        return response;
      }
    }
    autodiscoverUrl=this.getRedirectUrl(domainName);
    OutParam<URI> outParamUrl=new OutParam<URI>();
    if ((autodiscoverUrl != null) && this.callRedirectionUrlValidationCallback(autodiscoverUrl.toString()) && this.tryGetAutodiscoverEndpointUrl(autodiscoverUrl.getHost(),outParamUrl)) {
      autodiscoverUrl=outParamUrl.getParam();
      response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
      this.url=autodiscoverUrl;
      return response;
    }
    autodiscoverUrl=this.getRedirectionUrlFromDnsSrvRecord(domainName);
    if ((autodiscoverUrl != null) && this.callRedirectionUrlValidationCallback(autodiscoverUrl.toString()) && this.tryGetAutodiscoverEndpointUrl(autodiscoverUrl.getHost(),outParamUrl)) {
      autodiscoverUrl=outParamUrl.getParam();
      response=getSettingsMethod.func(identities,settings,requestedVersion,autodiscoverUrl);
      this.url=autodiscoverUrl;
      return response;
    }
 else {
      throw new AutodiscoverLocalException(""String_Node_Str"");
    }
  }
}"
3943,"/** 
 * Retrieves the specified settings for a set of users.
 * @param userSmtpAddresses the user smtp addresses
 * @param userSettingNames  The user setting names.
 * @return A GetUserSettingsResponseCollection object containing theresponses for each individual user.
 * @throws Exception the exception
 */
public GetUserSettingsResponseCollection getUsersSettings(Iterable<String> userSmtpAddresses,UserSettingName... userSettingNames) throws Exception {
  if (this.getRequestedServerVersion().compareTo(MinimumRequestVersionForAutoDiscoverSoapService) < 0) {
    throw new ServiceVersionException(String.format(Strings.AutodiscoverServiceIncompatibleWithRequestVersion,MinimumRequestVersionForAutoDiscoverSoapService));
  }
  List<String> smtpAddresses=new ArrayList<String>();
  smtpAddresses.addAll((Collection<? extends String>)userSmtpAddresses);
  List<UserSettingName> settings=new ArrayList<UserSettingName>();
  settings.addAll(Arrays.asList(userSettingNames));
  return this.getUserSettings(smtpAddresses,settings);
}","/** 
 * Retrieves the specified settings for a set of users.
 * @param userSmtpAddresses the user smtp addresses
 * @param userSettingNames  The user setting names.
 * @return A GetUserSettingsResponseCollection object containing theresponses for each individual user.
 * @throws Exception the exception
 */
public GetUserSettingsResponseCollection getUsersSettings(Iterable<String> userSmtpAddresses,UserSettingName... userSettingNames) throws Exception {
  if (this.getRequestedServerVersion().compareTo(MinimumRequestVersionForAutoDiscoverSoapService) < 0) {
    throw new ServiceVersionException(String.format(""String_Node_Str"",MinimumRequestVersionForAutoDiscoverSoapService));
  }
  List<String> smtpAddresses=new ArrayList<String>();
  smtpAddresses.addAll((Collection<? extends String>)userSmtpAddresses);
  List<UserSettingName> settings=new ArrayList<UserSettingName>();
  settings.addAll(Arrays.asList(userSettingNames));
  return this.getUserSettings(smtpAddresses,settings);
}"
3944,"/** 
 * Gets the autodiscover endpoint URL.
 * @param host The host.
 * @return URI The URI.
 * @throws Exception the exception
 */
private URI getAutodiscoverEndpointUrl(String host) throws Exception {
  URI autodiscoverUrl=null;
  OutParam<URI> outParam=new OutParam<URI>();
  if (this.tryGetAutodiscoverEndpointUrl(host,outParam)) {
    return autodiscoverUrl;
  }
 else {
    throw new AutodiscoverLocalException(Strings.NoSoapOrWsSecurityEndpointAvailable);
  }
}","/** 
 * Gets the autodiscover endpoint URL.
 * @param host The host.
 * @return URI The URI.
 * @throws Exception the exception
 */
private URI getAutodiscoverEndpointUrl(String host) throws Exception {
  URI autodiscoverUrl=null;
  OutParam<URI> outParam=new OutParam<URI>();
  if (this.tryGetAutodiscoverEndpointUrl(host,outParam)) {
    return autodiscoverUrl;
  }
 else {
    throw new AutodiscoverLocalException(""String_Node_Str"");
  }
}"
3945,"/** 
 * Default implementation of AutodiscoverRedirectionUrlValidationCallback. Always returns true indicating that the URL can be used.
 * @param redirectionUrl the redirection url
 * @return Returns true.
 * @throws AutodiscoverLocalException the autodiscover local exception
 */
private boolean defaultAutodiscoverRedirectionUrlValidationCallback(String redirectionUrl) throws AutodiscoverLocalException {
  throw new AutodiscoverLocalException(String.format(Strings.AutodiscoverRedirectBlocked,redirectionUrl));
}","/** 
 * Default implementation of AutodiscoverRedirectionUrlValidationCallback. Always returns true indicating that the URL can be used.
 * @param redirectionUrl the redirection url
 * @return Returns true.
 * @throws AutodiscoverLocalException the autodiscover local exception
 */
private boolean defaultAutodiscoverRedirectionUrlValidationCallback(String redirectionUrl) throws AutodiscoverLocalException {
  throw new AutodiscoverLocalException(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",redirectionUrl));
}"
3946,"/** 
 * Gets settings for one or more users.
 * @param smtpAddresses    The SMTP addresses of the users.
 * @param settings         The settings.
 * @param requestedVersion Requested version of the Exchange service.
 * @param autodiscoverUrl  The autodiscover URL.
 * @return GetUserSettingsResponse collection.
 * @throws ServiceLocalException the service local exception
 * @throws Exception             the exception
 */
private GetUserSettingsResponseCollection internalGetUserSettings(List<String> smtpAddresses,List<UserSettingName> settings,ExchangeVersion requestedVersion,URI autodiscoverUrl) throws ServiceLocalException, Exception {
  for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
    GetUserSettingsRequest request=new GetUserSettingsRequest(this,autodiscoverUrl);
    request.setSmtpAddresses(smtpAddresses);
    request.setSettings(settings);
    GetUserSettingsResponseCollection response=request.execute();
    if (response.getErrorCode() == AutodiscoverErrorCode.RedirectUrl && response.getRedirectionUrl() != null) {
      this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",autodiscoverUrl.toString(),response.getRedirectionUrl()));
      autodiscoverUrl=response.getRedirectionUrl();
    }
 else {
      return response;
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new AutodiscoverLocalException(Strings.MaximumRedirectionHopsExceeded);
}","/** 
 * Gets settings for one or more users.
 * @param smtpAddresses    The SMTP addresses of the users.
 * @param settings         The settings.
 * @param requestedVersion Requested version of the Exchange service.
 * @param autodiscoverUrl  The autodiscover URL.
 * @return GetUserSettingsResponse collection.
 * @throws ServiceLocalException the service local exception
 * @throws Exception             the exception
 */
private GetUserSettingsResponseCollection internalGetUserSettings(List<String> smtpAddresses,List<UserSettingName> settings,ExchangeVersion requestedVersion,URI autodiscoverUrl) throws ServiceLocalException, Exception {
  for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
    GetUserSettingsRequest request=new GetUserSettingsRequest(this,autodiscoverUrl);
    request.setSmtpAddresses(smtpAddresses);
    request.setSettings(settings);
    GetUserSettingsResponseCollection response=request.execute();
    if (response.getErrorCode() == AutodiscoverErrorCode.RedirectUrl && response.getRedirectionUrl() != null) {
      this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",autodiscoverUrl.toString(),response.getRedirectionUrl()));
      autodiscoverUrl=response.getRedirectionUrl();
    }
 else {
      return response;
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new MaximumRedirectionHopsExceededException();
}"
3947,"/** 
 * Retrieves the specified settings for single SMTP address.
 * @param userSmtpAddress  The SMTP addresses of the user.
 * @param userSettingNames The user setting names.
 * @return A UserResponse object containing the requested settings for thespecified user.
 * @throws Exception the exception<p/> This method handles will run the entire Autodiscover ""discovery"" algorithm and will follow address and URL redirections.
 */
public GetUserSettingsResponse getUserSettings(String userSmtpAddress,UserSettingName... userSettingNames) throws Exception {
  List<UserSettingName> requestedSettings=new ArrayList<UserSettingName>();
  requestedSettings.addAll(Arrays.asList(userSettingNames));
  if (userSmtpAddress == null || userSmtpAddress.isEmpty()) {
    throw new ServiceValidationException(Strings.InvalidAutodiscoverSmtpAddress);
  }
  if (requestedSettings.size() == 0) {
    throw new ServiceValidationException(Strings.InvalidAutodiscoverSettingsCount);
  }
  if (this.getRequestedServerVersion().compareTo(MinimumRequestVersionForAutoDiscoverSoapService) < 0) {
    return this.internalGetLegacyUserSettings(userSmtpAddress,requestedSettings);
  }
 else {
    return this.internalGetSoapUserSettings(userSmtpAddress,requestedSettings);
  }
}","/** 
 * Retrieves the specified settings for single SMTP address.
 * @param userSmtpAddress  The SMTP addresses of the user.
 * @param userSettingNames The user setting names.
 * @return A UserResponse object containing the requested settings for thespecified user.
 * @throws Exception the exception<p/> This method handles will run the entire Autodiscover ""discovery"" algorithm and will follow address and URL redirections.
 */
public GetUserSettingsResponse getUserSettings(String userSmtpAddress,UserSettingName... userSettingNames) throws Exception {
  List<UserSettingName> requestedSettings=new ArrayList<UserSettingName>();
  requestedSettings.addAll(Arrays.asList(userSettingNames));
  if (userSmtpAddress == null || userSmtpAddress.isEmpty()) {
    throw new ServiceValidationException(""String_Node_Str"");
  }
  if (requestedSettings.size() == 0) {
    throw new ServiceValidationException(""String_Node_Str"");
  }
  if (this.getRequestedServerVersion().compareTo(MinimumRequestVersionForAutoDiscoverSoapService) < 0) {
    return this.internalGetLegacyUserSettings(userSmtpAddress,requestedSettings);
  }
 else {
    return this.internalGetSoapUserSettings(userSmtpAddress,requestedSettings);
  }
}"
3948,"/** 
 * Tries to get Autodiscover settings using redirection Url.
 * @param < TSettings >    the generic type
 * @param cls            the cls
 * @param emailAddress   The email address.
 * @param redirectionUrl Redirection Url.
 * @param settings       The settings.
 * @return boolean The boolean.
 * @throws AutodiscoverLocalException  the autodiscover local exception
 * @throws AutodiscoverRemoteException the autodiscover remote exception
 * @throws Exception                   the exception
 */
private <TSettings extends ConfigurationSettingsBase>boolean tryLastChanceHostRedirection(Class<TSettings> cls,String emailAddress,URI redirectionUrl,OutParam<TSettings> settings) throws AutodiscoverLocalException, AutodiscoverRemoteException, Exception {
  List<String> redirectionEmailAddresses=new ArrayList<String>();
  if (this.callRedirectionUrlValidationCallback(redirectionUrl.toString())) {
    for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
      try {
        settings.setParam(this.getLegacyUserSettingsAtUrl(cls,emailAddress,redirectionUrl));
switch (settings.getParam().getResponseType()) {
case Success:
          return true;
case Error:
        throw new AutodiscoverRemoteException(Strings.AutodiscoverError,settings.getParam().getError());
case RedirectAddress:
      this.disableScpLookupIfDuplicateRedirection(settings.getParam().getRedirectTarget(),redirectionEmailAddresses);
    OutParam<Integer> outParam=new OutParam<Integer>();
  outParam.setParam(currentHop);
settings.setParam(this.internalGetLegacyUserSettings(cls,emailAddress,redirectionEmailAddresses,outParam));
currentHop=outParam.getParam();
return true;
case RedirectUrl:
try {
redirectionUrl=new URI(settings.getParam().getRedirectTarget());
}
 catch (URISyntaxException ex) {
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",settings.getParam().getRedirectTarget()));
return false;
}
break;
default :
String failureMessage=String.format(""String_Node_Str"",redirectionUrl,settings.getParam().getResponseType(),settings.getParam().getRedirectTarget());
this.traceMessage(TraceFlags.AutodiscoverConfiguration,failureMessage);
return false;
}
}
 catch (XMLStreamException ex) {
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectionUrl.toString(),ex.getMessage()));
return false;
}
catch (IOException ex) {
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectionUrl,ex.getMessage()));
return false;
}
catch (Exception ex) {
HttpWebRequest response=null;
OutParam<URI> outParam=new OutParam<URI>();
if ((response != null) && this.tryGetRedirectionResponse(response,outParam)) {
redirectionUrl=outParam.getParam();
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",redirectionUrl));
}
 else {
if (response != null) {
this.processHttpErrorResponse(response,ex);
}
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",url,ex.getClass().getName(),ex.getMessage()));
return false;
}
}
}
}
return false;
}","/** 
 * Tries to get Autodiscover settings using redirection Url.
 * @param < TSettings >    the generic type
 * @param cls            the cls
 * @param emailAddress   The email address.
 * @param redirectionUrl Redirection Url.
 * @param settings       The settings.
 * @return boolean The boolean.
 * @throws AutodiscoverLocalException  the autodiscover local exception
 * @throws AutodiscoverRemoteException the autodiscover remote exception
 * @throws Exception                   the exception
 */
private <TSettings extends ConfigurationSettingsBase>boolean tryLastChanceHostRedirection(Class<TSettings> cls,String emailAddress,URI redirectionUrl,OutParam<TSettings> settings) throws AutodiscoverLocalException, AutodiscoverRemoteException, Exception {
  List<String> redirectionEmailAddresses=new ArrayList<String>();
  if (this.callRedirectionUrlValidationCallback(redirectionUrl.toString())) {
    for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
      try {
        settings.setParam(this.getLegacyUserSettingsAtUrl(cls,emailAddress,redirectionUrl));
switch (settings.getParam().getResponseType()) {
case Success:
          return true;
case Error:
        throw new AutodiscoverRemoteException(""String_Node_Str"",settings.getParam().getError());
case RedirectAddress:
      this.disableScpLookupIfDuplicateRedirection(settings.getParam().getRedirectTarget(),redirectionEmailAddresses);
    OutParam<Integer> outParam=new OutParam<Integer>();
  outParam.setParam(currentHop);
settings.setParam(this.internalGetLegacyUserSettings(cls,emailAddress,redirectionEmailAddresses,outParam));
currentHop=outParam.getParam();
return true;
case RedirectUrl:
try {
redirectionUrl=new URI(settings.getParam().getRedirectTarget());
}
 catch (URISyntaxException ex) {
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",settings.getParam().getRedirectTarget()));
return false;
}
break;
default :
String failureMessage=String.format(""String_Node_Str"",redirectionUrl,settings.getParam().getResponseType(),settings.getParam().getRedirectTarget());
this.traceMessage(TraceFlags.AutodiscoverConfiguration,failureMessage);
return false;
}
}
 catch (XMLStreamException ex) {
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectionUrl.toString(),ex.getMessage()));
return false;
}
catch (IOException ex) {
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectionUrl,ex.getMessage()));
return false;
}
catch (Exception ex) {
HttpWebRequest response=null;
OutParam<URI> outParam=new OutParam<URI>();
if ((response != null) && this.tryGetRedirectionResponse(response,outParam)) {
redirectionUrl=outParam.getParam();
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",redirectionUrl));
}
 else {
if (response != null) {
this.processHttpErrorResponse(response,ex);
}
this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",url,ex.getClass().getName(),ex.getMessage()));
return false;
}
}
}
}
return false;
}"
3949,"/** 
 * Gets the enabled autodiscover endpoints on a specific host.
 * @param host      The host.
 * @param endpoints Endpoints found for host.
 * @return Flags indicating which endpoints are enabled.
 * @throws Exception the exception
 */
private boolean tryGetEnabledEndpointsForHost(String host,OutParam<EnumSet<AutodiscoverEndpoints>> endpoints) throws Exception {
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",host));
  for (int currentHop=0; currentHop < AutodiscoverMaxRedirections; currentHop++) {
    URI autoDiscoverUrl=new URI(String.format(AutodiscoverLegacyHttpsUrl,host));
    endpoints.setParam(EnumSet.of(AutodiscoverEndpoints.None));
    HttpWebRequest request=null;
    try {
      request=new HttpClientWebRequest(httpClient,httpContext);
      try {
        request.setUrl(autoDiscoverUrl.toURL());
      }
 catch (      MalformedURLException e) {
        String strErr=String.format(""String_Node_Str"",url);
        throw new ServiceLocalException(strErr);
      }
      request.setRequestMethod(""String_Node_Str"");
      request.setAllowAutoRedirect(false);
      request.setPreAuthenticate(false);
      request.setUseDefaultCredentials(this.getUseDefaultCredentials());
      prepareCredentials(request);
      request.prepareConnection();
      try {
        request.executeRequest();
      }
 catch (      IOException e) {
        return false;
      }
      OutParam<URI> outParam=new OutParam<URI>();
      if (this.tryGetRedirectionResponse(request,outParam)) {
        URI redirectUrl=outParam.getParam();
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectUrl.getHost()));
        host=redirectUrl.getHost();
      }
 else {
        endpoints.setParam(this.getEndpointsFromHttpWebResponse(request));
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",endpoints.getParam().toString()));
        return true;
      }
    }
  finally {
      if (request != null) {
        try {
          request.close();
        }
 catch (        Exception e) {
        }
      }
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new AutodiscoverLocalException(Strings.MaximumRedirectionHopsExceeded);
}","/** 
 * Gets the enabled autodiscover endpoints on a specific host.
 * @param host      The host.
 * @param endpoints Endpoints found for host.
 * @return Flags indicating which endpoints are enabled.
 * @throws Exception the exception
 */
private boolean tryGetEnabledEndpointsForHost(String host,OutParam<EnumSet<AutodiscoverEndpoints>> endpoints) throws Exception {
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",host));
  for (int currentHop=0; currentHop < AutodiscoverMaxRedirections; currentHop++) {
    URI autoDiscoverUrl=new URI(String.format(AutodiscoverLegacyHttpsUrl,host));
    endpoints.setParam(EnumSet.of(AutodiscoverEndpoints.None));
    HttpWebRequest request=null;
    try {
      request=new HttpClientWebRequest(httpClient,httpContext);
      try {
        request.setUrl(autoDiscoverUrl.toURL());
      }
 catch (      MalformedURLException e) {
        String strErr=String.format(""String_Node_Str"",url);
        throw new ServiceLocalException(strErr);
      }
      request.setRequestMethod(""String_Node_Str"");
      request.setAllowAutoRedirect(false);
      request.setPreAuthenticate(false);
      request.setUseDefaultCredentials(this.getUseDefaultCredentials());
      prepareCredentials(request);
      request.prepareConnection();
      try {
        request.executeRequest();
      }
 catch (      IOException e) {
        return false;
      }
      OutParam<URI> outParam=new OutParam<URI>();
      if (this.tryGetRedirectionResponse(request,outParam)) {
        URI redirectUrl=outParam.getParam();
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",redirectUrl.getHost()));
        host=redirectUrl.getHost();
      }
 else {
        endpoints.setParam(this.getEndpointsFromHttpWebResponse(request));
        this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",endpoints.getParam().toString()));
        return true;
      }
    }
  finally {
      if (request != null) {
        try {
          request.close();
        }
 catch (        Exception e) {
        }
      }
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new MaximumRedirectionHopsExceededException();
}"
3950,"/** 
 * Calls the SOAP Autodiscover service for user settings for a single SMTP address.
 * @param smtpAddress       SMTP address.
 * @param requestedSettings The requested settings.
 * @return GetUserSettingsResponse
 */
protected GetUserSettingsResponse internalGetSoapUserSettings(String smtpAddress,List<UserSettingName> requestedSettings) throws Exception {
  List<String> smtpAddresses=new ArrayList<String>();
  smtpAddresses.add(smtpAddress);
  List<String> redirectionEmailAddresses=new ArrayList<String>();
  redirectionEmailAddresses.add(smtpAddress.toLowerCase());
  for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
    GetUserSettingsResponse response=this.getUserSettings(smtpAddresses,requestedSettings).getTResponseAtIndex(0);
switch (response.getErrorCode()) {
case RedirectAddress:
      this.traceMessage(TraceFlags.AutodiscoverResponse,String.format(""String_Node_Str"",response.getRedirectTarget()));
    smtpAddresses.clear();
  smtpAddresses.add(response.getRedirectTarget().toLowerCase());
this.url=null;
this.domain=null;
this.disableScpLookupIfDuplicateRedirection(response.getRedirectTarget(),redirectionEmailAddresses);
break;
case RedirectUrl:
this.traceMessage(TraceFlags.AutodiscoverResponse,String.format(""String_Node_Str"",response.getRedirectTarget()));
this.url=this.getCredentials().adjustUrl(new URI(response.getRedirectTarget()));
break;
case NoError:
default :
return response;
}
}
throw new AutodiscoverLocalException(Strings.AutodiscoverCouldNotBeLocated);
}","/** 
 * Calls the SOAP Autodiscover service for user settings for a single SMTP address.
 * @param smtpAddress       SMTP address.
 * @param requestedSettings The requested settings.
 * @return GetUserSettingsResponse
 */
protected GetUserSettingsResponse internalGetSoapUserSettings(String smtpAddress,List<UserSettingName> requestedSettings) throws Exception {
  List<String> smtpAddresses=new ArrayList<String>();
  smtpAddresses.add(smtpAddress);
  List<String> redirectionEmailAddresses=new ArrayList<String>();
  redirectionEmailAddresses.add(smtpAddress.toLowerCase());
  for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
    GetUserSettingsResponse response=this.getUserSettings(smtpAddresses,requestedSettings).getTResponseAtIndex(0);
switch (response.getErrorCode()) {
case RedirectAddress:
      this.traceMessage(TraceFlags.AutodiscoverResponse,String.format(""String_Node_Str"",response.getRedirectTarget()));
    smtpAddresses.clear();
  smtpAddresses.add(response.getRedirectTarget().toLowerCase());
this.url=null;
this.domain=null;
this.disableScpLookupIfDuplicateRedirection(response.getRedirectTarget(),redirectionEmailAddresses);
break;
case RedirectUrl:
this.traceMessage(TraceFlags.AutodiscoverResponse,String.format(""String_Node_Str"",response.getRedirectTarget()));
this.url=this.getCredentials().adjustUrl(new URI(response.getRedirectTarget()));
break;
case NoError:
default :
return response;
}
}
throw new AutodiscoverLocalException(""String_Node_Str"");
}"
3951,"/** 
 * Gets settings for one or more domains.
 * @param domains          The domains.
 * @param settings         The settings.
 * @param requestedVersion Requested version of the Exchange service.
 * @param autodiscoverUrl  The autodiscover URL.
 * @return GetDomainSettingsResponse Collection.
 * @throws ServiceLocalException the service local exception
 * @throws Exception             the exception
 */
private GetDomainSettingsResponseCollection internalGetDomainSettings(List<String> domains,List<DomainSettingName> settings,ExchangeVersion requestedVersion,URI autodiscoverUrl) throws ServiceLocalException, Exception {
  for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
    GetDomainSettingsRequest request=new GetDomainSettingsRequest(this,autodiscoverUrl);
    request.setDomains(domains);
    request.setSettings(settings);
    request.setRequestedVersion(requestedVersion);
    GetDomainSettingsResponseCollection response=request.execute();
    if (response.getErrorCode() == AutodiscoverErrorCode.RedirectUrl && response.getRedirectionUrl() != null) {
      autodiscoverUrl=response.getRedirectionUrl();
    }
 else {
      return response;
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new AutodiscoverLocalException(Strings.MaximumRedirectionHopsExceeded);
}","/** 
 * Gets settings for one or more domains.
 * @param domains          The domains.
 * @param settings         The settings.
 * @param requestedVersion Requested version of the Exchange service.
 * @param autodiscoverUrl  The autodiscover URL.
 * @return GetDomainSettingsResponse Collection.
 * @throws ServiceLocalException the service local exception
 * @throws Exception             the exception
 */
private GetDomainSettingsResponseCollection internalGetDomainSettings(List<String> domains,List<DomainSettingName> settings,ExchangeVersion requestedVersion,URI autodiscoverUrl) throws ServiceLocalException, Exception {
  for (int currentHop=0; currentHop < AutodiscoverService.AutodiscoverMaxRedirections; currentHop++) {
    GetDomainSettingsRequest request=new GetDomainSettingsRequest(this,autodiscoverUrl);
    request.setDomains(domains);
    request.setSettings(settings);
    request.setRequestedVersion(requestedVersion);
    GetDomainSettingsResponseCollection response=request.execute();
    if (response.getErrorCode() == AutodiscoverErrorCode.RedirectUrl && response.getRedirectionUrl() != null) {
      autodiscoverUrl=response.getRedirectionUrl();
    }
 else {
      return response;
    }
  }
  this.traceMessage(TraceFlags.AutodiscoverConfiguration,String.format(""String_Node_Str"",AutodiscoverMaxRedirections));
  throw new MaximumRedirectionHopsExceededException();
}"
3952,"/** 
 * Gets user settings from Autodiscover legacy endpoint.
 * @param emailAddress      The email address to use.
 * @param requestedSettings The requested settings.
 * @return GetUserSettingsResponse
 */
protected GetUserSettingsResponse internalGetLegacyUserSettings(String emailAddress,List<UserSettingName> requestedSettings) throws Exception {
  if ((this.getCredentials() != null) && (this.getCredentials() instanceof WSSecurityBasedCredentials)) {
    throw new AutodiscoverLocalException(Strings.WLIDCredentialsCannotBeUsedWithLegacyAutodiscover);
  }
  OutlookConfigurationSettings settings=this.getLegacyUserSettings(OutlookConfigurationSettings.class,emailAddress);
  return settings.convertSettings(emailAddress,requestedSettings);
}","/** 
 * Gets user settings from Autodiscover legacy endpoint.
 * @param emailAddress      The email address to use.
 * @param requestedSettings The requested settings.
 * @return GetUserSettingsResponse
 */
protected GetUserSettingsResponse internalGetLegacyUserSettings(String emailAddress,List<UserSettingName> requestedSettings) throws Exception {
  if ((this.getCredentials() != null) && (this.getCredentials() instanceof WSSecurityBasedCredentials)) {
    throw new AutodiscoverLocalException(""String_Node_Str"");
  }
  OutlookConfigurationSettings settings=this.getLegacyUserSettings(OutlookConfigurationSettings.class,emailAddress);
  return settings.convertSettings(emailAddress,requestedSettings);
}"
3953,"/** 
 * This method doesn't handle 500 ISE errors. This is handled by the caller since 500 ISE typically indicates that a SOAP fault has occurred and the handling of a SOAP fault is currently service specific.
 * @throws Exception
 */
protected void internalProcessHttpErrorResponse(HttpWebRequest httpWebResponse,Exception webException,TraceFlags responseHeadersTraceFlag,TraceFlags responseTraceFlag) throws Exception {
  EwsUtilities.EwsAssert(500 != httpWebResponse.getResponseCode(),""String_Node_Str"",""String_Node_Str"");
  this.processHttpResponseHeaders(responseHeadersTraceFlag,httpWebResponse);
  if (httpWebResponse.getResponseCode() == 456) {
    String location=httpWebResponse.getResponseContentType();
    URI accountUnlockUrl=null;
    if (checkURIPath(location)) {
      accountUnlockUrl=new URI(location);
    }
    this.traceMessage(responseTraceFlag,String.format(""String_Node_Str"",accountUnlockUrl));
    throw new AccountIsLockedException(String.format(Strings.AccountIsLocked,accountUnlockUrl),accountUnlockUrl,webException);
  }
}","/** 
 * This method doesn't handle 500 ISE errors. This is handled by the caller since 500 ISE typically indicates that a SOAP fault has occurred and the handling of a SOAP fault is currently service specific.
 * @throws Exception
 */
protected void internalProcessHttpErrorResponse(HttpWebRequest httpWebResponse,Exception webException,TraceFlags responseHeadersTraceFlag,TraceFlags responseTraceFlag) throws Exception {
  EwsUtilities.EwsAssert(500 != httpWebResponse.getResponseCode(),""String_Node_Str"",""String_Node_Str"");
  this.processHttpResponseHeaders(responseHeadersTraceFlag,httpWebResponse);
  if (httpWebResponse.getResponseCode() == 456) {
    String location=httpWebResponse.getResponseContentType();
    URI accountUnlockUrl=null;
    if (checkURIPath(location)) {
      accountUnlockUrl=new URI(location);
    }
    final String message=String.format(Strings.AccountIsLocked,accountUnlockUrl);
    this.traceMessage(responseTraceFlag,message);
    throw new AccountIsLockedException(message,accountUnlockUrl,webException);
  }
}"
3954,"/** 
 * Initializes a new instance of the MapiTypeConverterMapEntry class.
 * @param type The type. y default, converting a type to string is done bycalling value.ToString. Instances can override this behavior. <p/> By default, converting a string to the appropriate value type is done by calling Convert.ChangeType Instances may override this behavior.
 */
protected MapiTypeConverterMapEntry(Class<?> type){
  EwsUtilities.EwsAssert(defaultValueMap.getMember().containsKey(type),""String_Node_Str"",String.format(""String_Node_Str"",type.getName()));
  this.type=type;
  this.convertToString=new IFunction<Object,String>(){
    public String func(    Object o){
      return String.valueOf(o);
    }
  }
;
  this.parse=new IFunction<String,Object>(){
    public Object func(    String o){
      return o;
    }
  }
;
}","/** 
 * Initializes a new instance of the MapiTypeConverterMapEntry class.
 * @param type The type. y default, converting a type to string is done bycalling value.ToString. Instances can override this behavior. <p/> By default, converting a string to the appropriate value type is done by calling Convert.ChangeType Instances may override this behavior.
 */
protected MapiTypeConverterMapEntry(Class<?> type){
  EwsUtilities.EwsAssert(defaultValueMap.getMember().containsKey(type),""String_Node_Str"",""String_Node_Str"" + type.getName());
  this.type=type;
  this.convertToString=new IFunction<Object,String>(){
    public String func(    Object o){
      return String.valueOf(o);
    }
  }
;
  this.parse=new IFunction<String,Object>(){
    public Object func(    String o){
      return o;
    }
  }
;
}"
3955,"/** 
 * Returns string that represents the current instance.
 * @return String representation of instance.
 */
@Override public String toString(){
  String addressPart;
  if (null == this.getAddress() || this.getAddress().isEmpty()) {
    return ""String_Node_Str"";
  }
  if (null != this.getRoutingType() && this.getRoutingType().isEmpty()) {
    addressPart=this.getRoutingType() + ""String_Node_Str"" + this.getAddress();
  }
 else {
    addressPart=this.getAddress();
  }
  if (null != this.getName() && this.getName().isEmpty()) {
    return this.getName() + ""String_Node_Str"" + addressPart+ ""String_Node_Str"";
  }
 else {
    return addressPart;
  }
}","/** 
 * Returns string that represents the current instance.
 * @return String representation of instance.
 */
@Override public String toString(){
  String addressPart;
  if (null == this.getAddress() || this.getAddress().isEmpty()) {
    return ""String_Node_Str"";
  }
  if (null != this.getRoutingType() && this.getRoutingType().isEmpty()) {
    addressPart=this.getRoutingType() + ""String_Node_Str"" + this.getAddress();
  }
 else {
    addressPart=this.getAddress();
  }
  if (null != this.getName() && !this.getName().isEmpty()) {
    return this.getName() + ""String_Node_Str"" + addressPart+ ""String_Node_Str"";
  }
 else {
    return addressPart;
  }
}"
3956,"/** 
 * Returns string that represents the current instance.
 * @return String representation of instance.
 */
@Override public String toString(){
  String addressPart;
  if (null == this.getAddress() || this.getAddress().isEmpty()) {
    return ""String_Node_Str"";
  }
  if (null != this.getRoutingType() && this.getRoutingType().isEmpty()) {
    addressPart=this.getRoutingType() + ""String_Node_Str"" + this.getAddress();
  }
 else {
    addressPart=this.getAddress();
  }
  if (null != this.getName() && this.getName().isEmpty()) {
    return this.getName() + ""String_Node_Str"" + addressPart+ ""String_Node_Str"";
  }
 else {
    return addressPart;
  }
}","/** 
 * Returns string that represents the current instance.
 * @return String representation of instance.
 */
@Override public String toString(){
  String addressPart;
  if (null == this.getAddress() || this.getAddress().isEmpty()) {
    return ""String_Node_Str"";
  }
  if (null != this.getRoutingType() && this.getRoutingType().isEmpty()) {
    addressPart=this.getRoutingType() + ""String_Node_Str"" + this.getAddress();
  }
 else {
    addressPart=this.getAddress();
  }
  if (null != this.getName() && !this.getName().isEmpty()) {
    return this.getName() + ""String_Node_Str"" + addressPart+ ""String_Node_Str"";
  }
 else {
    return addressPart;
  }
}"
3957,"/** 
 * Validates request parameters, and emits the request to the server.
 * @param request The request.
 * @return The response returned by the server.
 */
protected HttpWebRequest validateAndEmitRequest() throws ServiceLocalException, Exception {
  this.validate();
  HttpWebRequest request=this.buildEwsHttpWebRequest();
  return this.getEwsHttpWebResponse(request);
}","/** 
 * Validates request parameters, and emits the request to the server.
 * @return The response returned by the server.
 */
protected HttpWebRequest validateAndEmitRequest() throws ServiceLocalException, Exception {
  this.validate();
  HttpWebRequest request=this.buildEwsHttpWebRequest();
  try {
    return this.getEwsHttpWebResponse(request);
  }
 catch (  HttpErrorException e) {
    processWebException(e,request);
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,e.getMessage()),e);
  }
}"
3958,"/** 
 * Gets the IEwsHttpWebRequest object from the specifiedHttpWebRequest object with exception handling
 * @param request The specified HttpWebRequest
 * @return An HttpWebResponse instance
 */
protected HttpWebRequest getEwsHttpWebResponse(HttpWebRequest request) throws Exception {
  int code;
  try {
    code=request.executeRequest();
  }
 catch (  HttpErrorException ex) {
    if (ex.getHttpErrorCode() == WebExceptionStatus.ProtocolError.ordinal() && ex.getMessage() != null) {
      this.processWebException(ex,request);
    }
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,ex.getMessage()),ex);
  }
catch (  IOException e) {
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,e.getMessage()),e);
  }
  return request;
}","/** 
 * Gets the IEwsHttpWebRequest object from the specifiedHttpWebRequest object with exception handling
 * @param request The specified HttpWebRequest
 * @return An HttpWebResponse instance
 */
protected HttpWebRequest getEwsHttpWebResponse(HttpWebRequest request) throws Exception {
  try {
    request.executeRequest();
    if (request.getResponseCode() >= 400) {
      throw new HttpErrorException(""String_Node_Str"" + request.getResponseCode() + ""String_Node_Str""+ request.getResponseText(),request.getResponseCode());
    }
  }
 catch (  IOException e) {
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,e.getMessage()),e);
  }
  return request;
}"
3959,"/** 
 * Executes this request. 
 * @throws Exception 
 * @throws microsoft.exchange.webservices.data.ServiceLocalException
 */
protected Object internalExecute() throws ServiceLocalException, Exception {
  HttpWebRequest response=this.validateAndEmitRequest();
  try {
    return this.readResponse(response);
  }
 catch (  IOException ex) {
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,ex.getMessage(),ex));
  }
catch (  Exception e) {
    if (response != null) {
      this.getService().processHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders,response);
    }
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,e.getMessage()),e);
  }
 finally {
    try {
      response.close();
    }
 catch (    Exception e2) {
      response=null;
    }
  }
}","/** 
 * Executes this request. 
 * @throws Exception 
 * @throws microsoft.exchange.webservices.data.ServiceLocalException
 */
protected Object internalExecute() throws ServiceLocalException, Exception {
  HttpWebRequest response=null;
  try {
    response=this.validateAndEmitRequest();
    return this.readResponse(response);
  }
 catch (  IOException ex) {
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,ex.getMessage(),ex));
  }
catch (  Exception e) {
    if (response != null) {
      this.getService().processHttpResponseHeaders(TraceFlags.EwsResponseHttpHeaders,response);
    }
    throw new ServiceRequestException(String.format(Strings.ServiceRequestFailed,e.getMessage()),e);
  }
 finally {
    try {
      if (response != null) {
        response.close();
      }
    }
 catch (    Exception e2) {
      response=null;
    }
  }
}"
3960,"/** 
 * Converts a string to value consistent with type (or uses the default value if the string is null or empty).
 * @param String to convert to a value.
 * @return Value.
 * @throws microsoft.exchange.webservices.data.FormatException
 * @throws ServiceXmlDeserializationException 
 */
protected Object ConvertToValueOrDefault(String stringValue) throws ServiceXmlDeserializationException, FormatException {
  return (stringValue == null || stringValue.isEmpty()) ? this.getDefaultValue() : this.convertToValue(stringValue);
}","/** 
 * Converts a string to value consistent with type (or uses the default value if the string is null or empty).
 * @param stringValue to convert to a value.
 * @return Value.
 * @throws microsoft.exchange.webservices.data.FormatException
 * @throws ServiceXmlDeserializationException 
 */
protected Object ConvertToValueOrDefault(String stringValue) throws ServiceXmlDeserializationException, FormatException {
  return (stringValue == null || stringValue.isEmpty()) ? this.getDefaultValue() : this.convertToValue(stringValue);
}"
3961,"/** 
 * Case insensitive check if the collection contains the string.
 * @param collectionThe collection of objects, only strings are checked
 * @param match String to match
 * @return true, if match contained in the collection
 */
protected static boolean caseInsensitiveContains(ArrayList collection,String match){
  for (  Object obj : collection) {
    String str=(String)obj;
    if (str != null) {
      if (str.equalsIgnoreCase(match)) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Case insensitive check if the collection contains the string.
 * @param collection The collection of objects, only strings are checked
 * @param match String to match
 * @return true, if match contained in the collection
 */
protected static boolean caseInsensitiveContains(ArrayList collection,String match){
  for (  Object obj : collection) {
    String str=(String)obj;
    if (str != null) {
      if (str.equalsIgnoreCase(match)) {
        return true;
      }
    }
  }
  return false;
}"
3962,"/** 
 * Determines whether every element in the collection  matches the conditions defined by the specified predicate.
 * @param typeparam T Entry type.
 * @param collection The collection.
 * @param predicate Predicate that defines the conditions  to check against the elements.
 * @return  True if every element in the collection matches the conditions defined by the specified predicate; otherwise, false.
 * @throws ServiceLocalException 
 */
protected static <T>boolean trueForAll(Iterable<T> collection,IPredicate<T> predicate) throws ServiceLocalException {
  for (  T entry : collection) {
    if (!predicate.predicate(entry)) {
      return false;
    }
  }
  return true;
}","/** 
 * Determines whether every element in the collection  matches the conditions defined by the specified predicate.
 * @param < T >           Entry type.
 * @param collection    The collection.
 * @param predicate     Predicate that defines the conditions to check against the elements.
 * @return  True if every element in the collection matches the conditions defined by the specified predicate; otherwise, false.
 * @throws ServiceLocalException 
 */
protected static <T>boolean trueForAll(Iterable<T> collection,IPredicate<T> predicate) throws ServiceLocalException {
  for (  T entry : collection) {
    if (!predicate.predicate(entry)) {
      return false;
    }
  }
  return true;
}"
3963,"/** 
 * Validates string parameter to be  non-empty string (null value not allowed).
 * @param paramThe string parameter.	
 * @param paramName Name of the parameter.	 
 * @throws ArgumentNullException 
 * @throws ArgumentException 
 * @throws ServiceLocalException 
 */
protected static void validateNonBlankStringParam(String param,String paramName) throws ArgumentNullException, ArgumentException, ServiceLocalException {
  if (param == null) {
    throw new ArgumentNullException(paramName);
  }
  validateNonBlankStringParamAllowNull(param,paramName);
}","/** 
 * Validates string parameter to be  non-empty string (null value not allowed).
 * @param param The string parameter.
 * @param paramName Name of the parameter.	 
 * @throws ArgumentNullException 
 * @throws ArgumentException 
 * @throws ServiceLocalException 
 */
protected static void validateNonBlankStringParam(String param,String paramName) throws ArgumentNullException, ArgumentException, ServiceLocalException {
  if (param == null) {
    throw new ArgumentNullException(paramName);
  }
  validateNonBlankStringParamAllowNull(param,paramName);
}"
3964,"/** 
 * Call an action for each member of a collection.
 * @param typeparam T Collection element type.
 * @param collection The collection.
 * @param action The action to apply.
 */
protected static <T>void forEach(Iterable<T> collection,IAction<T> action){
  for (  T entry : collection) {
    action.action(entry);
  }
}","/** 
 * Call an action for each member of a collection.
 * @param < T >           Collection element type.
 * @param collection    The collection.
 * @param action        The action to apply.
 */
protected static <T>void forEach(Iterable<T> collection,IAction<T> action){
  for (  T entry : collection) {
    action.action(entry);
  }
}"
3965,"/** 
 * Copies source stream to target.
 * @param source The source. 
 * @param name target The target.
 */
protected static void copyStream(ByteArrayOutputStream source,ByteArrayOutputStream target) throws Exception {
  ByteArrayOutputStream memContentStream=source;
  if (memContentStream != null) {
    memContentStream.writeTo(target);
    memContentStream.flush();
  }
 else {
    int c;
    ByteArrayInputStream inStream=new ByteArrayInputStream(source.toByteArray());
    while ((c=inStream.read()) != -1) {
      target.write((char)c);
    }
  }
}","/** 
 * Copies source stream to target.
 * @param source The source stream.
 * @param target The target stream.
 */
protected static void copyStream(ByteArrayOutputStream source,ByteArrayOutputStream target) throws Exception {
  ByteArrayOutputStream memContentStream=source;
  if (memContentStream != null) {
    memContentStream.writeTo(target);
    memContentStream.flush();
  }
 else {
    int c;
    ByteArrayInputStream inStream=new ByteArrayInputStream(source.toByteArray());
    while ((c=inStream.read()) != -1) {
      target.write((char)c);
    }
  }
}"
3966,"/** 
 * Empties the folder. Calling this method results in a call to EWS.
 * @param deletemode the delete mode	 
 * @throws deleteSubFolders Indicates whether sub-folders should also be deleted.
 * @throws Exception 
 */
public void empty(DeleteMode deletemode,boolean deleteSubFolders) throws Exception {
  this.throwIfThisIsNew();
  this.getService().emptyFolder(this.getId(),deletemode,deleteSubFolders);
}","/** 
 * Empties the folder. Calling this method results in a call to EWS.
 * @param deletemode the delete mode	 
 * @param deleteSubFolders Indicates whether sub-folders should also be deleted.
 * @throws Exception 
 */
public void empty(DeleteMode deletemode,boolean deleteSubFolders) throws Exception {
  this.throwIfThisIsNew();
  this.getService().emptyFolder(this.getId(),deletemode,deleteSubFolders);
}"
3967,"/** 
 * Sets the credentials.
 * @param emailAddress the email-id
 * @param pwd the password
 */
public void setCredentials(String domain,String user,String pwd){
  this.domain=domain;
  this.userName=user;
  this.password=pwd;
}","/** 
 * Sets the credentials.
 * @param domain user domain
 * @param user   user name
 * @param pwd    password
 */
public void setCredentials(String domain,String user,String pwd){
  this.domain=domain;
  this.userName=user;
  this.password=pwd;
}"
3968,"/** 
 * Sets the Headers.
 * @param contentType the new content type
 */
public void setHeaders(Map<String,String> headers){
  this.headers=headers;
}","/** 
 * Sets the Headers.
 * @param headers The headers
 */
public void setHeaders(Map<String,String> headers){
  this.headers=headers;
}"
3969,"/** 
 * Reads an XML Schema from the supplied stream.
 * @param array The character array containing the name to add.
 * @param offset Zero-based index into the array specifying the first character of the name.
 * @param length The number of characters in the name.
 * @return The new atomized String or the existing one if it already exists.If length is zero, String.Empty is returned
 * @throws System.IndexOutOfRangeException 0 > offset -or- offset >= array.Length -or- length > array.Length The above conditions do not cause an exception to be thrown if length =0.
 * @throws System.ArgumentOutOfRangeException length < 0.
 */
public abstract String Add(char[] array,int offset,int length);","/** 
 * Reads an XML Schema from the supplied stream.
 * @param array The character array containing the name to add.
 * @param offset Zero-based index into the array specifying the first character of the name.
 * @param length The number of characters in the name.
 * @return The new atomized String or the existing one if it already exists.If length is zero, String.Empty is returned
 * @throws ArgumentOutOfRangeException 0 > offset -or- offset >= array.Length -or- length > array.Length The above conditions do not cause an exception to be thrown if length =0.
 * @throws ArgumentOutOfRangeException length < 0.
 */
public abstract String Add(char[] array,int offset,int length);"
3970,"/** 
 * When overridden in a derived class, gets the atomized String containing the same characters as the specified range of characters in the given array.
 * @param array The character array containing the name to add.
 * @param offset Zero-based index into the array specifying the first character of the name.
 * @param length The number of characters in the name.
 * @return The atomized String or null if the String has not already beenatomized. If length is zero, String.Empty is returned
 * @throws System.IndexOutOfRangeException 0 > offset -or- offset >= array.Length -or- length > array.Length The above conditions do not cause an exception to be thrown if length =0.
 * @throws System.ArgumentOutOfRangeException length < 0.
 */
public abstract String Get(char[] array,int offset,int length);","/** 
 * When overridden in a derived class, gets the atomized String containing the same characters as the specified range of characters in the given array.
 * @param array The character array containing the name to add.
 * @param offset Zero-based index into the array specifying the first character of the name.
 * @param length The number of characters in the name.
 * @return The atomized String or null if the String has not already beenatomized. If length is zero, String.Empty is returned
 * @throws ArgumentOutOfRangeException 0 > offset -or- offset >= array.Length -or- length > array.Length The above conditions do not cause an exception to be thrown if length =0.
 * @throws ArgumentOutOfRangeException length < 0.
 */
public abstract String Get(char[] array,int offset,int length);"
3971,"/** 
 * Gets the property instance. 
 * @param propertyBag The property bag. 
 * @param complexProperty The property instance. 
 * @return True if the instance is newly created.
 */
private boolean getPropertyInstance(PropertyBag propertyBag,OutParam<Object> complexProperty){
  boolean retValue=false;
  if (!propertyBag.tryGetValue(this,complexProperty) || !this.hasFlag(PropertyDefinitionFlags.ReuseInstance,propertyBag.getOwner().getService().getRequestedServerVersion()))   ;
{
    complexProperty.setParam(this.createPropertyInstance(propertyBag.getOwner()));
    retValue=true;
  }
  return retValue;
}","/** 
 * Gets the property instance. 
 * @param propertyBag The property bag. 
 * @param complexProperty The property instance. 
 * @return True if the instance is newly created.
 */
private boolean getPropertyInstance(PropertyBag propertyBag,OutParam<Object> complexProperty){
  boolean retValue=false;
  if (!propertyBag.tryGetValue(this,complexProperty) || !this.hasFlag(PropertyDefinitionFlags.ReuseInstance,propertyBag.getOwner().getService().getRequestedServerVersion())) {
    complexProperty.setParam(this.createPropertyInstance(propertyBag.getOwner()));
    retValue=true;
  }
  return retValue;
}"
3972,"/** 
 * Convert DateTime to XML Schema date.
 * @param date the date
 * @return String representation of DateTime.
 */
static String dateTimeToXSDate(Date date){
  String format=""String_Node_Str"";
  DateFormat utcFormatter=new SimpleDateFormat(format);
  return utcFormatter.format(date);
}","/** 
 * Convert DateTime to XML Schema date.
 * @param date the date
 * @return String representation of DateTime.
 */
static String dateTimeToXSDate(Date date){
  String format=""String_Node_Str"";
  DateFormat utcFormatter=new SimpleDateFormat(format);
  utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  return utcFormatter.format(date);
}"
3973,"/** 
 * Dates the DateTime into an XML schema date time.
 * @param date the date
 * @return String representation of DateTime.
 */
protected static String dateTimeToXSDateTime(Date date){
  String format=""String_Node_Str"";
  DateFormat utcFormatter=new SimpleDateFormat(format);
  return utcFormatter.format(date);
}","/** 
 * Dates the DateTime into an XML schema date time.
 * @param date the date
 * @return String representation of DateTime.
 */
protected static String dateTimeToXSDateTime(Date date){
  String format=""String_Node_Str"";
  DateFormat utcFormatter=new SimpleDateFormat(format);
  utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  return utcFormatter.format(date);
}"
3974,"/** 
 * Parses the.
 * @param < T > the generic type
 * @param cls the cls
 * @param value the value
 * @return the t
 * @throws InstantiationException the instantiation exception
 * @throws IllegalAccessException the illegal access exception
 * @throws java.text.ParseException the parse exception
 */
protected static <T>T parse(Class<T> cls,String value) throws InstantiationException, IllegalAccessException, ParseException {
  if (cls.isEnum()) {
    Map<String,String> stringToEnumDict;
    if (schemaToEnumDictionaries.getMember().containsKey(cls)) {
      stringToEnumDict=schemaToEnumDictionaries.getMember().get(cls);
      if (stringToEnumDict.containsKey(value)) {
        String strEnumName=stringToEnumDict.get(value);
        for (        Object o : cls.getEnumConstants()) {
          if (o.toString().equals(strEnumName)) {
            return (T)o;
          }
        }
        return null;
      }
 else {
        for (        Object o : cls.getEnumConstants()) {
          if (o.toString().equals(value)) {
            return (T)o;
          }
        }
        return null;
      }
    }
 else {
      for (      Object o : cls.getEnumConstants()) {
        if (o.toString().equals(value)) {
          return (T)o;
        }
      }
      return null;
    }
  }
 else   if (cls.isInstance(Integer.valueOf(0))) {
    Object o=null;
    o=Integer.parseInt(value);
    return (T)o;
  }
 else   if (cls.isInstance(new Date())) {
    Object o=null;
    DateFormat df=new SimpleDateFormat(""String_Node_Str"");
    return (T)df.parse(value);
  }
 else   if (cls.isInstance(Boolean.valueOf(false))) {
    Object o=null;
    o=Boolean.parseBoolean(value);
    return (T)o;
  }
 else   if (cls.isInstance(new String())) {
    return (T)value;
  }
 else   if (cls.isInstance(Double.valueOf(0.0))) {
    Object o=null;
    o=Double.parseDouble(value);
    return (T)o;
  }
  return null;
}","/** 
 * Parses the.
 * @param < T > the generic type
 * @param cls the cls
 * @param value the value
 * @return the t
 * @throws InstantiationException the instantiation exception
 * @throws IllegalAccessException the illegal access exception
 * @throws java.text.ParseException the parse exception
 */
protected static <T>T parse(Class<T> cls,String value) throws InstantiationException, IllegalAccessException, ParseException {
  if (cls.isEnum()) {
    Map<String,String> stringToEnumDict;
    if (schemaToEnumDictionaries.getMember().containsKey(cls)) {
      stringToEnumDict=schemaToEnumDictionaries.getMember().get(cls);
      if (stringToEnumDict.containsKey(value)) {
        String strEnumName=stringToEnumDict.get(value);
        for (        Object o : cls.getEnumConstants()) {
          if (o.toString().equals(strEnumName)) {
            return (T)o;
          }
        }
        return null;
      }
 else {
        for (        Object o : cls.getEnumConstants()) {
          if (o.toString().equals(value)) {
            return (T)o;
          }
        }
        return null;
      }
    }
 else {
      for (      Object o : cls.getEnumConstants()) {
        if (o.toString().equals(value)) {
          return (T)o;
        }
      }
      return null;
    }
  }
 else   if (cls.isInstance(Integer.valueOf(0))) {
    Object o=null;
    o=Integer.parseInt(value);
    return (T)o;
  }
 else   if (cls.isInstance(new Date())) {
    Object o=null;
    DateFormat df=new SimpleDateFormat(""String_Node_Str"");
    df.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
    return (T)df.parse(value);
  }
 else   if (cls.isInstance(Boolean.valueOf(false))) {
    Object o=null;
    o=Boolean.parseBoolean(value);
    return (T)o;
  }
 else   if (cls.isInstance(new String())) {
    return (T)value;
  }
 else   if (cls.isInstance(Double.valueOf(0.0))) {
    Object o=null;
    o=Double.parseDouble(value);
    return (T)o;
  }
  return null;
}"
3975,"/** 
 * Converts the date time to universal date time string.
 * @param dt the date
 * @return String representation of DateTime in yyyy-MM-ddTHH:mm:ssZ format.
 */
protected String convertDateTimeToUniversalDateTimeString(Date dt){
  DateFormat utcFormatter=null;
  String utcPattern=""String_Node_Str"";
  utcFormatter=new SimpleDateFormat(utcPattern);
  return utcFormatter.format(dt);
}","/** 
 * Converts the date time to universal date time string.
 * @param dt the date
 * @return String representation of DateTime in yyyy-MM-ddTHH:mm:ssZ format.
 */
protected String convertDateTimeToUniversalDateTimeString(Date dt){
  String utcPattern=""String_Node_Str"";
  DateFormat utcFormatter=new SimpleDateFormat(utcPattern);
  utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  return utcFormatter.format(dt);
}"
3976,"/** 
 * Converts the universal date time string to local date time.
 * @param dateString The value.
 * @return DateTime Returned date is always in UTC date.
 */
protected Date convertUniversalDateTimeStringToDate(String dateString){
  String localTimeRegex=""String_Node_Str"";
  Pattern localTimePattern=Pattern.compile(localTimeRegex);
  String timeRegex=""String_Node_Str"";
  Pattern timePattern=Pattern.compile(timeRegex);
  String utcPattern=""String_Node_Str"";
  String utcPattern1=""String_Node_Str"";
  String localPattern=""String_Node_Str"";
  String localPattern1=""String_Node_Str"";
  String pattern=""String_Node_Str"";
  String localPattern2=""String_Node_Str"";
  DateFormat utcFormatter=null;
  Date dt=null;
  String errMsg=String.format(""String_Node_Str"",dateString);
  if (dateString == null || dateString.isEmpty()) {
    return null;
  }
 else {
    if (dateString.endsWith(""String_Node_Str"")) {
      utcFormatter=new SimpleDateFormat(utcPattern);
      try {
        dt=utcFormatter.parse(dateString);
      }
 catch (      ParseException e) {
        utcFormatter=new SimpleDateFormat(pattern);
        try {
          dt=utcFormatter.parse(dateString);
        }
 catch (        ParseException e1) {
          utcFormatter=new SimpleDateFormat(localPattern1);
          try {
            dt=utcFormatter.parse(dateString);
          }
 catch (          ParseException ex) {
            utcFormatter=new SimpleDateFormat(utcPattern1);
          }
          try {
            dt=utcFormatter.parse(dateString);
          }
 catch (          ParseException e2) {
            throw new IllegalArgumentException(errMsg,e);
          }
        }
      }
    }
 else     if (dateString.endsWith(""String_Node_Str"")) {
      utcFormatter=new SimpleDateFormat(""String_Node_Str"");
      try {
        dt=utcFormatter.parse(dateString);
      }
 catch (      ParseException e) {
        throw new IllegalArgumentException(e);
      }
    }
 else {
      Matcher localTimeMatcher=localTimePattern.matcher(dateString);
      if (localTimeMatcher.find()) {
        System.out.println(""String_Node_Str"");
        String date=localTimeMatcher.group(1);
        String zone=localTimeMatcher.group(2);
        dateString=String.format(""String_Node_Str"",date,zone);
        try {
          utcFormatter=new SimpleDateFormat(localPattern);
          dt=utcFormatter.parse(dateString);
        }
 catch (        ParseException e) {
          try {
            utcFormatter=new SimpleDateFormat(pattern);
            dt=utcFormatter.parse(dateString);
          }
 catch (          ParseException ex) {
            throw new IllegalArgumentException(ex);
          }
        }
      }
 else {
        utcFormatter=new SimpleDateFormat(localPattern2);
        try {
          dt=utcFormatter.parse(dateString);
        }
 catch (        ParseException e) {
          e.printStackTrace();
          throw new IllegalArgumentException(errMsg);
        }
      }
    }
    return dt;
  }
}","/** 
 * Converts the universal date time string to local date time.
 * @param dateString The value.
 * @return DateTime Returned date is always in UTC date.
 */
protected Date convertUniversalDateTimeStringToDate(String dateString){
  String localTimeRegex=""String_Node_Str"";
  Pattern localTimePattern=Pattern.compile(localTimeRegex);
  String timeRegex=""String_Node_Str"";
  Pattern timePattern=Pattern.compile(timeRegex);
  String utcPattern=""String_Node_Str"";
  String utcPattern1=""String_Node_Str"";
  String localPattern=""String_Node_Str"";
  String localPattern1=""String_Node_Str"";
  String pattern=""String_Node_Str"";
  String localPattern2=""String_Node_Str"";
  DateFormat utcFormatter=null;
  Date dt=null;
  String errMsg=String.format(""String_Node_Str"",dateString);
  if (dateString == null || dateString.isEmpty()) {
    return null;
  }
 else {
    if (dateString.endsWith(""String_Node_Str"")) {
      utcFormatter=new SimpleDateFormat(utcPattern);
      utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
      try {
        dt=utcFormatter.parse(dateString);
      }
 catch (      ParseException e) {
        utcFormatter=new SimpleDateFormat(pattern);
        utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
        try {
          dt=utcFormatter.parse(dateString);
        }
 catch (        ParseException e1) {
          utcFormatter=new SimpleDateFormat(localPattern1);
          utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
          try {
            dt=utcFormatter.parse(dateString);
          }
 catch (          ParseException ex) {
            utcFormatter=new SimpleDateFormat(utcPattern1);
            utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
          }
          try {
            dt=utcFormatter.parse(dateString);
          }
 catch (          ParseException e2) {
            throw new IllegalArgumentException(errMsg,e);
          }
        }
      }
    }
 else     if (dateString.endsWith(""String_Node_Str"")) {
      utcFormatter=new SimpleDateFormat(""String_Node_Str"");
      utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
      try {
        dt=utcFormatter.parse(dateString);
      }
 catch (      ParseException e) {
        throw new IllegalArgumentException(e);
      }
    }
 else {
      Matcher localTimeMatcher=localTimePattern.matcher(dateString);
      if (localTimeMatcher.find()) {
        System.out.println(""String_Node_Str"");
        String date=localTimeMatcher.group(1);
        String zone=localTimeMatcher.group(2);
        dateString=String.format(""String_Node_Str"",date,zone);
        try {
          utcFormatter=new SimpleDateFormat(localPattern);
          utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
          dt=utcFormatter.parse(dateString);
        }
 catch (        ParseException e) {
          try {
            utcFormatter=new SimpleDateFormat(pattern);
            utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
            dt=utcFormatter.parse(dateString);
          }
 catch (          ParseException ex) {
            throw new IllegalArgumentException(ex);
          }
        }
      }
 else {
        utcFormatter=new SimpleDateFormat(localPattern2);
        utcFormatter.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
        try {
          dt=utcFormatter.parse(dateString);
        }
 catch (        ParseException e) {
          e.printStackTrace();
          throw new IllegalArgumentException(errMsg);
        }
      }
    }
    return dt;
  }
}"
3977,"/** 
 * Tries to read element from XML.
 * @param reader the reader
 * @return True if element was read
 * @throws Exception the exception
 */
protected boolean tryReadElementFromXml(EwsServiceXmlReader reader) throws Exception {
  if (super.tryReadElementFromXml(reader)) {
    return true;
  }
 else {
    if (reader.getLocalName().equals(XmlElementNames.EndDate)) {
      Date temp=reader.readElementValueAsDateTime();
      if (temp != null) {
        this.endDate=temp;
      }
      return true;
    }
 else {
      return false;
    }
  }
}","/** 
 * Tries to read element from XML.
 * @param reader the reader
 * @return True if element was read
 * @throws Exception the exception
 */
protected boolean tryReadElementFromXml(EwsServiceXmlReader reader) throws Exception {
  if (super.tryReadElementFromXml(reader)) {
    return true;
  }
 else {
    if (reader.getLocalName().equals(XmlElementNames.EndDate)) {
      Date temp=reader.readElementValueAsUnspecifiedDate();
      if (temp != null) {
        this.endDate=temp;
      }
      return true;
    }
 else {
      return false;
    }
  }
}"
3978,"/** 
 * Setups the recurrence.
 * @param recurrence the new up recurrence
 * @throws Exception the exception
 */
protected void setupRecurrence(Recurrence recurrence) throws Exception {
  super.setupRecurrence(recurrence);
  this.endDate=recurrence.getEndDate();
}","/** 
 * Setups the recurrence.
 * @param recurrence the new up recurrence
 * @throws Exception the exception
 */
protected void setupRecurrence(Recurrence recurrence) throws Exception {
  super.setupRecurrence(recurrence);
  recurrence.setEndDate(this.endDate);
}"
3979,"/** 
 * Setups the recurrence.
 * @param recurrence the new up recurrence
 * @throws Exception the exception
 */
protected void setupRecurrence(Recurrence recurrence) throws Exception {
  super.setupRecurrence(recurrence);
  this.numberOfOccurrences=recurrence.getNumberOfOccurrences();
}","/** 
 * Setups the recurrence.
 * @param recurrence the new up recurrence
 * @throws Exception the exception
 */
protected void setupRecurrence(Recurrence recurrence) throws Exception {
  super.setupRecurrence(recurrence);
  recurrence.setNumberOfOccurrences(this.numberOfOccurrences);
}"
3980,"/** 
 * * Writes the Id encapsulated in the wrapper to XML.
 * @param writer the writer
 * @throws Exception the exception
 */
protected abstract void writeToXml(EwsServiceXmlWriter writer) throws Exception ;","/** 
 * Writes the Id encapsulated in the wrapper to XML.
 * @param writer the writer
 * @throws Exception the exception
 */
protected abstract void writeToXml(EwsServiceXmlWriter writer) throws Exception ;"
3981,"/** 
 * * Initializes a new instance of the class.
 */
protected AbstractItemIdWrapper(){
}","/** 
 * Initializes a new instance of the class.
 */
protected AbstractItemIdWrapper(){
}"
3982,"/** 
 * * Initializes a new instance of the class.
 * @param service the service
 * @throws Exception 
 */
protected AddDelegateRequest(ExchangeService service) throws Exception {
  super(service);
}","/** 
 * Initializes a new instance of the class.
 * @param service the service
 * @throws Exception 
 */
protected AddDelegateRequest(ExchangeService service) throws Exception {
  super(service);
}"
3983,"/** 
 * * Gets the delegate users. <value>The delegate users.</value>
 * @return the delegate users
 */
public List<DelegateUser> getDelegateUsers(){
  return this.delegateUsers;
}","/** 
 * Gets the delegate users. <value>The delegate users.</value>
 * @return the delegate users
 */
public List<DelegateUser> getDelegateUsers(){
  return this.delegateUsers;
}"
3984,"/** 
 * * Writes the elements to XML.
 * @param writer the writer
 * @throws Exception the exception
 */
@Override protected void writeElementsToXml(EwsServiceXmlWriter writer) throws Exception {
  super.writeElementsToXml(writer);
  writer.writeStartElement(XmlNamespace.Messages,XmlElementNames.DelegateUsers);
  for (  DelegateUser delegateUser : this.getDelegateUsers()) {
    delegateUser.writeToXml(writer,XmlElementNames.DelegateUser);
  }
  writer.writeEndElement();
  if (this.getMeetingRequestsDeliveryScope() != null) {
    writer.writeElementValue(XmlNamespace.Messages,XmlElementNames.DeliverMeetingRequests,this.getMeetingRequestsDeliveryScope());
  }
}","/** 
 * Writes the elements to XML.
 * @param writer the writer
 * @throws Exception the exception
 */
@Override protected void writeElementsToXml(EwsServiceXmlWriter writer) throws Exception {
  super.writeElementsToXml(writer);
  writer.writeStartElement(XmlNamespace.Messages,XmlElementNames.DelegateUsers);
  for (  DelegateUser delegateUser : this.getDelegateUsers()) {
    delegateUser.writeToXml(writer,XmlElementNames.DelegateUser);
  }
  writer.writeEndElement();
  if (this.getMeetingRequestsDeliveryScope() != null) {
    writer.writeElementValue(XmlNamespace.Messages,XmlElementNames.DeliverMeetingRequests,this.getMeetingRequestsDeliveryScope());
  }
}"
3985,"/** 
 * * Gets the meeting requests delivery scope. <value>The meeting requests delivery scope.</value>
 * @return the meeting requests delivery scope
 */
public MeetingRequestsDeliveryScope getMeetingRequestsDeliveryScope(){
  return this.meetingRequestsDeliveryScope;
}","/** 
 * Gets the meeting requests delivery scope. <value>The meeting requests delivery scope.</value>
 * @return the meeting requests delivery scope
 */
public MeetingRequestsDeliveryScope getMeetingRequestsDeliveryScope(){
  return this.meetingRequestsDeliveryScope;
}"
3986,"/** 
 * * Initializes a new instance of the class.
 * @throws Exception the exception
 */
@Override protected void validate() throws Exception {
  super.validate();
  EwsUtilities.validateParamCollection(this.getDelegateUsers().iterator(),""String_Node_Str"");
  for (  DelegateUser delegateUser : this.getDelegateUsers()) {
    delegateUser.validateUpdateDelegate();
  }
  if (this.meetingRequestsDeliveryScope != null) {
    EwsUtilities.validateEnumVersionValue(this.getMeetingRequestsDeliveryScope(),this.getService().getRequestedServerVersion());
  }
}","/** 
 * Initializes a new instance of the class.
 * @throws Exception the exception
 */
@Override protected void validate() throws Exception {
  super.validate();
  EwsUtilities.validateParamCollection(this.getDelegateUsers().iterator(),""String_Node_Str"");
  for (  DelegateUser delegateUser : this.getDelegateUsers()) {
    delegateUser.validateUpdateDelegate();
  }
  if (this.meetingRequestsDeliveryScope != null) {
    EwsUtilities.validateEnumVersionValue(this.getMeetingRequestsDeliveryScope(),this.getService().getRequestedServerVersion());
  }
}"
3987,"/** 
 * * Initializes a new instance.
 * @param owner The owner.
 */
protected Attachment(Item owner){
  this.owner=owner;
}","/** 
 * Initializes a new instance.
 * @param owner The owner.
 */
protected Attachment(Item owner){
  this.owner=owner;
}"
3988,"/** 
 * * Adds a file attachment to the collection.
 * @param name the name
 * @param content accepts byte byte arrays representing the content of the attachment.
 * @return FileAttachment
 */
public FileAttachment addFileAttachment(String name,byte[] content){
  FileAttachment fileAttachment=new FileAttachment(this.owner);
  fileAttachment.setName(name);
  fileAttachment.setContent(content);
  this.internalAdd(fileAttachment);
  return fileAttachment;
}","/** 
 * Adds a file attachment to the collection.
 * @param name the name
 * @param content accepts byte byte arrays representing the content of the attachment.
 * @return FileAttachment
 */
public FileAttachment addFileAttachment(String name,byte[] content){
  FileAttachment fileAttachment=new FileAttachment(this.owner);
  fileAttachment.setName(name);
  fileAttachment.setContent(content);
  this.internalAdd(fileAttachment);
  return fileAttachment;
}"
3989,"/** 
 * * Adds an item attachment to the collection.
 * @param < TItem > the generic type
 * @param cls the cls
 * @return An ItemAttachment instance.
 * @throws Exception the exception
 */
public <TItem extends Item>GenericItemAttachment<TItem> addItemAttachment(Class<TItem> cls) throws Exception {
  if (cls.getDeclaredFields().length == 0) {
    throw new InvalidOperationException(String.format(""String_Node_Str"",cls.getName()));
  }
  GenericItemAttachment<TItem> itemAttachment=new GenericItemAttachment<TItem>(this.owner);
  itemAttachment.setTItem((TItem)EwsUtilities.createItemFromItemClass(itemAttachment,cls,true));
  this.internalAdd(itemAttachment);
  return itemAttachment;
}","/** 
 * Adds an item attachment to the collection.
 * @param < TItem > the generic type
 * @param cls the cls
 * @return An ItemAttachment instance.
 * @throws Exception the exception
 */
public <TItem extends Item>GenericItemAttachment<TItem> addItemAttachment(Class<TItem> cls) throws Exception {
  if (cls.getDeclaredFields().length == 0) {
    throw new InvalidOperationException(String.format(""String_Node_Str"",cls.getName()));
  }
  GenericItemAttachment<TItem> itemAttachment=new GenericItemAttachment<TItem>(this.owner);
  itemAttachment.setTItem((TItem)EwsUtilities.createItemFromItemClass(itemAttachment,cls,true));
  this.internalAdd(itemAttachment);
  return itemAttachment;
}"
3990,"/** 
 * * Gets the type of response the attendee gave to the meeting invitation it received.
 * @return the response type
 */
public MeetingResponseType getResponseType(){
  return responseType;
}","/** 
 * Gets the type of response the attendee gave to the meeting invitation it received.
 * @return the response type
 */
public MeetingResponseType getResponseType(){
  return responseType;
}"
3991,"/** 
 * * Writes the elements to XML.
 * @param writer the writer
 * @throws Exception the exception
 */
protected void writeElementsToXml(EwsServiceXmlWriter writer) throws Exception {
  writer.writeStartElement(this.getNamespace(),XmlElementNames.Mailbox);
  super.writeElementsToXml(writer);
  writer.writeEndElement();
}","/** 
 * Writes the elements to XML.
 * @param writer the writer
 * @throws Exception the exception
 */
protected void writeElementsToXml(EwsServiceXmlWriter writer) throws Exception {
  writer.writeStartElement(this.getNamespace(),XmlElementNames.Mailbox);
  super.writeElementsToXml(writer);
  writer.writeEndElement();
}"
3992,"/** 
 * * Initializes a new instance of the Attendee class.
 * @param mailbox the mailbox
 * @throws Exception the exception
 */
public Attendee(EmailAddress mailbox) throws Exception {
  super(mailbox);
}","/** 
 * Initializes a new instance of the Attendee class.
 * @param mailbox the mailbox
 * @throws Exception the exception
 */
public Attendee(EmailAddress mailbox) throws Exception {
  super(mailbox);
}"
3993,"/** 
 * * Tries to read element from XML.
 * @param reader the reader
 * @return True if element was read.
 * @throws Exception the exception
 */
protected boolean tryReadElementFromXml(EwsServiceXmlReader reader) throws Exception {
  if (reader.getLocalName().equalsIgnoreCase(XmlElementNames.Mailbox)) {
    this.loadFromXml(reader,reader.getLocalName());
    return true;
  }
 else   if (reader.getLocalName().equalsIgnoreCase(XmlElementNames.ResponseType)) {
    this.responseType=reader.readElementValue(MeetingResponseType.class);
    return true;
  }
 else   if (reader.getLocalName().equalsIgnoreCase(XmlElementNames.LastResponseTime)) {
    this.lastResponseTime=reader.readElementValueAsDateTime();
    return true;
  }
 else {
    return super.tryReadElementFromXml(reader);
  }
}","/** 
 * Tries to read element from XML.
 * @param reader the reader
 * @return True if element was read.
 * @throws Exception the exception
 */
protected boolean tryReadElementFromXml(EwsServiceXmlReader reader) throws Exception {
  if (reader.getLocalName().equalsIgnoreCase(XmlElementNames.Mailbox)) {
    this.loadFromXml(reader,reader.getLocalName());
    return true;
  }
 else   if (reader.getLocalName().equalsIgnoreCase(XmlElementNames.ResponseType)) {
    this.responseType=reader.readElementValue(MeetingResponseType.class);
    return true;
  }
 else   if (reader.getLocalName().equalsIgnoreCase(XmlElementNames.LastResponseTime)) {
    this.lastResponseTime=reader.readElementValueAsDateTime();
    return true;
  }
 else {
    return super.tryReadElementFromXml(reader);
  }
}"
3994,"public Object call(org.mozilla.javascript.Context cx,Scriptable scope,Scriptable thisObj,final Object[] args){
  Activity activity=(Activity)mContext;
  activity.runOnUiThread(new Runnable(){
    @Override public void run(){
      toast((String)args[0]);
    }
  }
);
  return null;
}","public Object call(org.mozilla.javascript.Context cx,Scriptable scope,Scriptable thisObj,final Object[] args){
  Activity activity=(Activity)mContext;
  activity.runOnUiThread(new Runnable(){
    @Override public void run(){
      toast(((org.mozilla.javascript.ConsString)args[0]).toString());
    }
  }
);
  return null;
}"
3995,"public static void toast(String message){
  if (mInstance.currentToast != null) {
    mInstance.currentToast.cancel();
  }
  mInstance.currentToast=Toast.makeText(mInstance.mContext,message,Toast.LENGTH_SHORT);
  mInstance.currentToast.show();
}","public static void toast(final String message){
  if (mInstance.currentToast != null) {
    mInstance.currentToast.cancel();
  }
  mInstance.currentToast=Toast.makeText(mInstance.mContext,message,Toast.LENGTH_SHORT);
  mInstance.currentToast.show();
}"
3996,"@Override public void run(){
  toast((String)args[0]);
}","@Override public void run(){
  toast(((org.mozilla.javascript.ConsString)args[0]).toString());
}"
3997,"private static int vn(byte[] x,final int xoff,final int xlen,byte[] y,final int yoff,final int ylen,int n){
  int i, d=0;
  for (i=0; i < n; i++)   d|=x[i + xoff] ^ y[i + yoff];
  return (1 & ((d - 1) >>> 8)) - 1;
}","private static int vn(byte[] x,final int xoff,final int xlen,byte[] y,final int yoff,final int ylen,int n){
  int i, d=0;
  for (i=0; i < n; i++)   d|=(x[i + xoff] ^ y[i + yoff]) & 0xff;
  return (1 & ((d - 1) >>> 8)) - 1;
}"
3998,"private static int vn(byte[] x,final int xoff,byte[] y,final int yoff,int n){
  int i, d=0;
  for (i=0; i < n; i++)   d|=x[i + xoff] ^ y[i + yoff];
  return (1 & ((d - 1) >>> 8)) - 1;
}","private static int vn(byte[] x,final int xoff,byte[] y,final int yoff,int n){
  int i, d=0;
  for (i=0; i < n; i++)   d|=(x[i + xoff] ^ y[i + yoff]) & 0xff;
  return (1 & ((d - 1) >>> 8)) - 1;
}"
3999,"/** 
 * Sends a close instruction to the remote party.
 * @throws Exception 
 * @api public
 */
protected boolean close(int code,Object data,boolean mask) throws Exception {
  if (code > 0) {
    if (!ErrorCodes.isValidErrorCode(code))     throw new Exception(""String_Node_Str"");
  }
  code=code > 0 ? code : 1000;
  ByteBuffer dataBuffer=ByteBuffer.allocate(2 + (data != null ? Util.chunkByteLength(data,""String_Node_Str"") : 0));
  dataBuffer.order(ByteOrder.BIG_ENDIAN).putShort(0,(short)(code & 0xffff));
  if (dataBuffer.capacity() > 2)   dataBuffer.put(Util.chunkToBuffer(data,""String_Node_Str""));
  return this.frameAndSend(0x8,dataBuffer,true,mask,null);
}","/** 
 * Sends a close instruction to the remote party.
 * @throws Exception 
 * @api public
 */
protected boolean close(int code,Object data,boolean mask) throws Exception {
  Log.d(TAG,""String_Node_Str"" + code + ""String_Node_Str""+ data+ ""String_Node_Str""+ mask);
  if (code > 0) {
    if (!ErrorCodes.isValidErrorCode(code))     throw new Exception(""String_Node_Str"");
  }
  code=code > 0 ? code : 1000;
  ByteBuffer dataBuffer=ByteBuffer.allocate(2 + (data != null ? Util.chunkByteLength(data,""String_Node_Str"") : 0));
  dataBuffer.order(ByteOrder.BIG_ENDIAN).putShort(0,(short)(code & 0xffff));
  if (dataBuffer.capacity() > 2)   BufferUtil.fastCopy(dataBuffer.capacity() - 2,Util.chunkToBuffer(data,""String_Node_Str""),dataBuffer,2);
  return this.frameAndSend(0x8,dataBuffer,true,mask,null);
}"
4000,"/** 
 * Frames and sends a piece of data according to the HyBi WebSocket protocol.
 * @throws Exception 
 * @api private
 */
private boolean frameAndSend(int opcode,Object data,boolean finalFragment,boolean maskData,WriteCB cb) throws Exception {
  Log.d(TAG,""String_Node_Str"");
  boolean canModifyData=false;
  boolean out=false;
  if (data == null) {
    ByteBuffer tbw;
    if (maskData) {
      tbw=ByteBuffer.allocate(6);
      tbw.put((byte)(opcode | (finalFragment ? 0x80 : 0)));
      tbw.put((byte)(0 | (maskData ? 0x80 : 0)));
      tbw.putInt(0);
    }
 else {
      tbw=ByteBuffer.allocate(2);
      tbw.put((byte)(opcode | (finalFragment ? 0x80 : 0)));
      tbw.put((byte)(0 | (maskData ? 0x80 : 0)));
    }
    tbw.flip();
    try {
      out=this._socket.write(tbw,null,cb);
    }
 catch (    Exception e) {
      if (cb != null)       cb.writeDone(e.toString());
 else       this.emit(""String_Node_Str"",e.toString());
    }
    return out;
  }
  if (!Util.isBuffer(data)) {
    if (Util.isString(data)) {
      canModifyData=true;
      data=Util.chunkToBuffer(data,""String_Node_Str"");
    }
 else {
      if (cb != null)       cb.writeDone(""String_Node_Str"");
 else       this.emit(""String_Node_Str"",""String_Node_Str"");
      return out;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  int dataLength=Util.chunkByteLength(data,null);
  int dataOffset=maskData ? 6 : 2;
  int secondByte=dataLength;
  if (dataLength >= 65536) {
    dataOffset+=8;
    secondByte=127;
  }
 else   if (dataLength > 125) {
    dataOffset+=2;
    secondByte=126;
  }
  boolean mergeBuffers=dataLength < 32768 || (maskData && !canModifyData);
  int totalLength=mergeBuffers ? dataLength + dataOffset : dataOffset;
  ByteBuffer outputBuffer=ByteBuffer.allocate(totalLength);
  outputBuffer.put(0,(byte)(finalFragment ? opcode | 0x80 : opcode));
switch (secondByte) {
case 126:
    outputBuffer.order(ByteOrder.BIG_ENDIAN).putShort(2,(short)dataLength);
  break;
case 127:
outputBuffer.order(ByteOrder.BIG_ENDIAN).putInt(2,0);
outputBuffer.order(ByteOrder.BIG_ENDIAN).putInt(6,dataLength);
break;
}
if (maskData) {
outputBuffer.put(1,(byte)(secondByte | 0x80));
byte[] mask=this._randomMask != null ? this._randomMask : (this._randomMask=getRandomMask());
outputBuffer.put(dataOffset - 4,mask[0]);
outputBuffer.put(dataOffset - 3,mask[1]);
outputBuffer.put(dataOffset - 2,mask[2]);
outputBuffer.put(dataOffset - 1,mask[3]);
if (mergeBuffers) {
BufferUtil.mask((ByteBuffer)data,mask,outputBuffer,dataOffset,dataLength);
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
out=this._socket.write(outputBuffer,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
 else {
BufferUtil.mask((ByteBuffer)data,mask,(ByteBuffer)data,0,dataLength);
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
this._socket.write(outputBuffer,null,null);
BufferUtil.renewBuffer((ByteBuffer)data);
Log.d(TAG,""String_Node_Str"" + (ByteBuffer)data);
out=this._socket.write(data,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
}
 else {
outputBuffer.put(1,(byte)secondByte);
if (mergeBuffers) {
ByteBuffer tfc=(ByteBuffer)data;
BufferUtil.fastCopy(tfc.capacity(),tfc,outputBuffer,dataOffset);
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
out=this._socket.write(outputBuffer,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
 else {
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
this._socket.write(outputBuffer,null,null);
BufferUtil.renewBuffer((ByteBuffer)data);
Log.d(TAG,""String_Node_Str"" + (ByteBuffer)data);
out=this._socket.write(data,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
}
Log.d(TAG,""String_Node_Str"");
return out;
}","/** 
 * Frames and sends a piece of data according to the HyBi WebSocket protocol.
 * @throws Exception 
 * @api private
 */
private boolean frameAndSend(int opcode,Object data,boolean finalFragment,boolean maskData,WriteCB cb) throws Exception {
  Log.d(TAG,""String_Node_Str"" + opcode + ""String_Node_Str""+ data+ ""String_Node_Str""+ maskData);
  if (data != null && data instanceof ByteBuffer) {
    ByteBuffer bd=(ByteBuffer)data;
    String dstr=""String_Node_Str"";
    for (int i=0; i < bd.capacity(); i++)     dstr+=""String_Node_Str"" + bd.get(i);
    Log.d(TAG,dstr);
  }
  boolean canModifyData=false;
  boolean out=false;
  if (data == null) {
    ByteBuffer tbw;
    if (maskData) {
      tbw=ByteBuffer.allocate(6);
      tbw.put((byte)(opcode | (finalFragment ? 0x80 : 0)));
      tbw.put((byte)(0 | (maskData ? 0x80 : 0)));
      tbw.putInt(0);
    }
 else {
      tbw=ByteBuffer.allocate(2);
      tbw.put((byte)(opcode | (finalFragment ? 0x80 : 0)));
      tbw.put((byte)(0 | (maskData ? 0x80 : 0)));
    }
    tbw.flip();
    try {
      out=this._socket.write(tbw,null,cb);
    }
 catch (    Exception e) {
      if (cb != null)       cb.writeDone(e.toString());
 else       this.emit(""String_Node_Str"",e.toString());
    }
    return out;
  }
  if (!Util.isBuffer(data)) {
    if (Util.isString(data)) {
      canModifyData=true;
      data=Util.chunkToBuffer(data,""String_Node_Str"");
    }
 else {
      if (cb != null)       cb.writeDone(""String_Node_Str"");
 else       this.emit(""String_Node_Str"",""String_Node_Str"");
      return out;
    }
  }
  Log.d(TAG,""String_Node_Str"" + data.toString());
  int dataLength=Util.chunkByteLength(data,null);
  int dataOffset=maskData ? 6 : 2;
  int secondByte=dataLength;
  if (dataLength >= 65536) {
    dataOffset+=8;
    secondByte=127;
  }
 else   if (dataLength > 125) {
    dataOffset+=2;
    secondByte=126;
  }
  boolean mergeBuffers=dataLength < 32768 || (maskData && !canModifyData);
  int totalLength=mergeBuffers ? dataLength + dataOffset : dataOffset;
  ByteBuffer outputBuffer=ByteBuffer.allocate(totalLength);
  outputBuffer.put(0,(byte)(finalFragment ? opcode | 0x80 : opcode));
switch (secondByte) {
case 126:
    outputBuffer.order(ByteOrder.BIG_ENDIAN).putShort(2,(short)dataLength);
  break;
case 127:
outputBuffer.order(ByteOrder.BIG_ENDIAN).putInt(2,0);
outputBuffer.order(ByteOrder.BIG_ENDIAN).putInt(6,dataLength);
break;
}
if (maskData) {
outputBuffer.put(1,(byte)(secondByte | 0x80));
byte[] mask=this._randomMask != null ? this._randomMask : (this._randomMask=getRandomMask());
outputBuffer.put(dataOffset - 4,mask[0]);
outputBuffer.put(dataOffset - 3,mask[1]);
outputBuffer.put(dataOffset - 2,mask[2]);
outputBuffer.put(dataOffset - 1,mask[3]);
if (mergeBuffers) {
BufferUtil.mask((ByteBuffer)data,mask,outputBuffer,dataOffset,dataLength);
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
out=this._socket.write(outputBuffer,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
 else {
BufferUtil.mask((ByteBuffer)data,mask,(ByteBuffer)data,0,dataLength);
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
this._socket.write(outputBuffer,null,null);
BufferUtil.renewBuffer((ByteBuffer)data);
Log.d(TAG,""String_Node_Str"" + (ByteBuffer)data);
out=this._socket.write(data,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
}
 else {
outputBuffer.put(1,(byte)secondByte);
if (mergeBuffers) {
ByteBuffer tfc=(ByteBuffer)data;
BufferUtil.fastCopy(tfc.capacity(),tfc,outputBuffer,dataOffset);
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
out=this._socket.write(outputBuffer,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
 else {
try {
BufferUtil.renewBuffer(outputBuffer);
Log.d(TAG,""String_Node_Str"" + outputBuffer);
this._socket.write(outputBuffer,null,null);
BufferUtil.renewBuffer((ByteBuffer)data);
Log.d(TAG,""String_Node_Str"" + (ByteBuffer)data);
out=this._socket.write(data,null,cb);
}
 catch (Exception e) {
if (cb != null) cb.writeDone(e.toString());
 else this.emit(""String_Node_Str"",e.toString());
}
}
}
Log.d(TAG,""String_Node_Str"");
return out;
}"
