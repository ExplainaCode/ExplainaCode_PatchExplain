record_number,buggy_code,fixed_code
18001,"private void printMissingRecs(SolrQueryResponse rsp){
  printInfo(rsp);
  BitSet missing=queue.getMissing();
  BitSet present=queue.getPresent();
  if (missing == null) {
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    return;
  }
 else {
    rsp.add(""String_Node_Str"",""String_Node_Str"");
  }
  rsp.add(""String_Node_Str"",present.cardinality());
  rsp.add(""String_Node_Str"",missing.cardinality());
  ArrayList<Integer> tbd=new ArrayList<Integer>(missing.cardinality());
  rsp.add(""String_Node_Str"",tbd);
  int j=0;
  for (int i=missing.nextSetBit(0); i >= 0; i=missing.nextSetBit(i + 1)) {
    tbd.add(i);
  }
}","private void printMissingRecs(SolrQueryResponse rsp){
  BitSet missing=queue.getMissing();
  BitSet present=queue.getPresent();
  if (missing == null) {
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    return;
  }
 else {
    rsp.add(""String_Node_Str"",""String_Node_Str"");
  }
  rsp.add(""String_Node_Str"",present.cardinality());
  rsp.add(""String_Node_Str"",missing.cardinality());
  ArrayList<Integer> tbd=new ArrayList<Integer>(missing.cardinality());
  rsp.add(""String_Node_Str"",tbd);
  int j=0;
  for (int i=missing.nextSetBit(0); i >= 0; i=missing.nextSetBit(i + 1)) {
    tbd.add(i);
  }
}"
18002,"public String getWorkerMessage(){
  StringBuilder out=new StringBuilder();
  for (  String msg : workerMessage) {
    out.append(msg);
    out.append(""String_Node_Str"");
  }
  return out.toString();
}","public String getWorkerMessage(){
  StringBuilder out=new StringBuilder();
  for (  String msg : workerMessage) {
    out.append(msg);
    out.append(""String_Node_Str"");
  }
  workerMessage.clear();
  return out.toString();
}"
18003,"public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws IOException, InterruptedException {
  SolrParams params=req.getParams();
  String command=params.get(""String_Node_Str"",""String_Node_Str"");
  if (command.equals(""String_Node_Str"")) {
    queue.registerFailedDoc(params.get(""String_Node_Str""));
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.registerFailedBatch(params.get(""String_Node_Str""));
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.registerNewBatch(params.get(""String_Node_Str""));
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.stop();
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.reset();
  }
 else   if (command.equals(""String_Node_Str"")) {
    printInfo(rsp);
  }
 else   if (command.equals(""String_Node_Str"")) {
    printDetailedInfo(rsp);
  }
 else   if (command.equals(""String_Node_Str"")) {
    printMissingRecs(rsp);
  }
 else   if (command.equals(""String_Node_Str"")) {
    if (isBusy()) {
      rsp.add(""String_Node_Str"",""String_Node_Str"");
      rsp.add(""String_Node_Str"",""String_Node_Str"");
      printInfo(rsp);
      return;
    }
    workerMessage.clear();
    setBusy(true);
    if (isAsynchronous()) {
      runAsynchronously(req);
    }
 else {
      runSynchronously(queue,req);
      setBusy(false);
    }
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.registerNewBatch(""String_Node_Str"" + params.get(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    rsp.add(""String_Node_Str"",""String_Node_Str"" + command);
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    printInfo(rsp);
  }
  rsp.add(""String_Node_Str"",isBusy() ? ""String_Node_Str"" : ""String_Node_Str"");
}","public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws IOException, InterruptedException {
  SolrParams params=req.getParams();
  String command=params.get(""String_Node_Str"",""String_Node_Str"");
  if (command.equals(""String_Node_Str"")) {
    queue.registerFailedDoc(params.get(""String_Node_Str""));
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.registerFailedBatch(params.get(""String_Node_Str""));
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.registerNewBatch(params.get(""String_Node_Str""));
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.stop();
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.reset();
  }
 else   if (command.equals(""String_Node_Str"")) {
    printDetailedInfo(rsp);
  }
 else   if (command.equals(""String_Node_Str"")) {
    printMissingRecs(rsp);
  }
 else   if (command.equals(""String_Node_Str"")) {
    if (isBusy()) {
      rsp.add(""String_Node_Str"",""String_Node_Str"");
      rsp.add(""String_Node_Str"",""String_Node_Str"");
      printInfo(rsp);
      return;
    }
    queue.start();
    workerMessage.clear();
    setBusy(true);
    if (isAsynchronous()) {
      runAsynchronously(req);
    }
 else {
      runSynchronously(queue,req);
      setBusy(false);
    }
  }
 else   if (command.equals(""String_Node_Str"")) {
    queue.registerNewBatch(""String_Node_Str"" + params.get(""String_Node_Str"",""String_Node_Str""));
  }
 else {
    rsp.add(""String_Node_Str"",""String_Node_Str"" + command);
    rsp.add(""String_Node_Str"",""String_Node_Str"");
  }
  rsp.add(""String_Node_Str"",isBusy() ? ""String_Node_Str"" : ""String_Node_Str"");
  printInfo(rsp);
}"
18004,"public AqpAdsabsNodeProcessorPipeline(QueryConfigHandler queryConfig){
  super(queryConfig);
  QueryConfigHandler config=getQueryConfigHandler();
  add(new AqpDEFOPMarkPlainNodes());
  add(new AqpDEFOPProcessor());
  add(new AqpTreeRewriteProcessor());
  add(new AqpAdsabsFixQPOSITIONProcessor());
  add(new AqpAdsabsQPOSITIONProcessor());
  add(new AqpQFUNCProcessor());
  add(new AqpCOMMAProcessor());
  add(new AqpAdsabsMODIFIERProcessor());
  add(new AqpOPERATORProcessor());
  add(new AqpCLAUSEProcessor());
  add(new AqpTMODIFIERProcessor());
  add(new AqpBOOSTProcessor());
  add(new AqpFUZZYProcessor());
  add(new AqpQRANGEINProcessor());
  add(new AqpQDATEProcessor());
  add(new AqpQPHRASEProcessor());
  add(new AqpAdsabsQNORMALProcessor());
  add(new AqpQPHRASETRUNCProcessor());
  add(new AqpAdsabsQTRUNCATEDProcessor());
  add(new AqpQANYTHINGProcessor());
  add(new AqpQIDENTIFIERProcessor());
  add(new AqpFIELDProcessor());
  add(new AqpBibcodeProcessor());
  add(new AqpFuzzyModifierProcessor());
  add(new WildcardQueryNodeProcessor());
  add(new MultiFieldQueryNodeProcessor());
  add(new AqpNullDefaultFieldProcessor());
  add(new FuzzyQueryNodeProcessor());
  add(new MatchAllDocsQueryNodeProcessor());
  add(new AqpAdsabsFieldNodePreAnalysisProcessor());
  add(new AqpFieldMapperProcessor());
  add(new AqpMultiWordProcessor());
  if (config.get(AqpAdsabsQueryConfigHandler.ConfigurationKeys.SOLR_READY) == true) {
    add(new AqpUnfieldedSearchProcessor());
  }
  add(new NumericQueryNodeProcessor());
  add(new NumericRangeQueryNodeProcessor());
  add(new TermRangeQueryNodeProcessor());
  add(new AqpAdsabsRegexNodeProcessor());
  add(new AqpAdsabsSynonymNodeProcessor());
  add(new AqpAdsabsAuthorPreProcessor());
  add(new AqpAdsabsAnalyzerProcessor());
  add(new LowercaseExpandedTermsQueryNodeProcessor());
  add(new AqpAdsabsCarefulAnalyzerProcessor());
  add(new AqpAdsabsExpandAuthorSearchProcessor());
  add(new AqpAdsabsFieldMapperProcessorPostAnalysis());
  add(new PhraseSlopQueryNodeProcessor());
  add(new AllowLeadingWildcardProcessor());
  add(new NoChildOptimizationQueryNodeProcessor());
  add(new RemoveDeletedQueryNodesProcessor());
  add(new RemoveEmptyNonLeafQueryNodeProcessor());
  add(new BooleanSingleChildOptimizationQueryNodeProcessor());
  add(new DefaultPhraseSlopQueryNodeProcessor());
  add(new BoostQueryNodeProcessor());
  add(new MultiTermRewriteMethodProcessor());
  add(new AqpGroupQueryOptimizerProcessor());
  add(new AqpOptimizationProcessor());
}","public AqpAdsabsNodeProcessorPipeline(QueryConfigHandler queryConfig){
  super(queryConfig);
  QueryConfigHandler config=getQueryConfigHandler();
  add(new AqpDEFOPMarkPlainNodes());
  add(new AqpDEFOPProcessor());
  add(new AqpTreeRewriteProcessor());
  add(new AqpAdsabsFixQPOSITIONProcessor());
  add(new AqpAdsabsQPOSITIONProcessor());
  add(new AqpQFUNCProcessor());
  add(new AqpAdsabsCOMMAProcessor());
  add(new AqpAdsabsMODIFIERProcessor());
  add(new AqpOPERATORProcessor());
  add(new AqpCLAUSEProcessor());
  add(new AqpTMODIFIERProcessor());
  add(new AqpBOOSTProcessor());
  add(new AqpFUZZYProcessor());
  add(new AqpQRANGEINProcessor());
  add(new AqpQDATEProcessor());
  add(new AqpQPHRASEProcessor());
  add(new AqpAdsabsQNORMALProcessor());
  add(new AqpQPHRASETRUNCProcessor());
  add(new AqpAdsabsQTRUNCATEDProcessor());
  add(new AqpQANYTHINGProcessor());
  add(new AqpQIDENTIFIERProcessor());
  add(new AqpFIELDProcessor());
  add(new AqpBibcodeProcessor());
  add(new AqpFuzzyModifierProcessor());
  add(new WildcardQueryNodeProcessor());
  add(new MultiFieldQueryNodeProcessor());
  add(new AqpNullDefaultFieldProcessor());
  add(new FuzzyQueryNodeProcessor());
  add(new MatchAllDocsQueryNodeProcessor());
  add(new AqpAdsabsFieldNodePreAnalysisProcessor());
  add(new AqpFieldMapperProcessor());
  add(new AqpMultiWordProcessor());
  if (config.get(AqpAdsabsQueryConfigHandler.ConfigurationKeys.SOLR_READY) == true) {
    add(new AqpUnfieldedSearchProcessor());
  }
  add(new NumericQueryNodeProcessor());
  add(new NumericRangeQueryNodeProcessor());
  add(new TermRangeQueryNodeProcessor());
  add(new AqpAdsabsRegexNodeProcessor());
  add(new AqpAdsabsSynonymNodeProcessor());
  add(new AqpAdsabsAuthorPreProcessor());
  add(new AqpAdsabsAnalyzerProcessor());
  add(new LowercaseExpandedTermsQueryNodeProcessor());
  add(new AqpAdsabsCarefulAnalyzerProcessor());
  add(new AqpAdsabsExpandAuthorSearchProcessor());
  add(new AqpAdsabsFieldMapperProcessorPostAnalysis());
  add(new PhraseSlopQueryNodeProcessor());
  add(new AllowLeadingWildcardProcessor());
  add(new NoChildOptimizationQueryNodeProcessor());
  add(new RemoveDeletedQueryNodesProcessor());
  add(new RemoveEmptyNonLeafQueryNodeProcessor());
  add(new BooleanSingleChildOptimizationQueryNodeProcessor());
  add(new DefaultPhraseSlopQueryNodeProcessor());
  add(new BoostQueryNodeProcessor());
  add(new MultiTermRewriteMethodProcessor());
  add(new AqpGroupQueryOptimizerProcessor());
  add(new AqpOptimizationProcessor());
}"
18005,"public Query reParse(Query query,QParser qp,Class<?>... types) throws ParseException {
  parser=qp;
  qtypes=types;
  swimDeep(query);
  return query;
}","public Query reParse(Query query,QParser qp,Class<?>... types) throws ParseException {
  parsingLock.lock();
  try {
    parser=qp;
    qtypes=types;
    swimDeep(query);
    return query;
  }
  finally {
    parser=null;
    qtypes=null;
    parsingLock.unlock();
  }
}"
18006,"private void runSynchronously(RequestQueue queue,SolrQueryRequest req) throws MalformedURLException, IOException, InterruptedException {
  SolrCore core=req.getCore();
  IndexSchema schema=req.getSchema();
  RequestData data=queue.pop();
  if (!allowed.matcher(data.sourceField).matches()) {
    data.msg(""String_Node_Str"" + data.sourceField);
    queue.registerFailedBatch(data);
  }
  SchemaField field=core.getSchema().getFieldOrNull(data.sourceField);
  if (field == null || !field.stored()) {
    data.msg(""String_Node_Str"" + data.sourceField);
    queue.registerFailedBatch(data);
  }
  final Analyzer analyzer=core.getSchema().getQueryAnalyzer();
  SchemaField targetField=core.getSchema().getFieldOrNull(data.targetField);
  if (targetField == null) {
    data.msg(""String_Node_Str"" + data.targetField);
    queue.registerFailedBatch(data);
  }
  final String targetAnalyzer=data.targetField;
  DirectoryReader ir=req.getSearcher().getIndexReader();
  SolrIndexSearcher se=req.getSearcher();
  final HashSet<String> fieldsToLoad=new HashSet<String>();
  fieldsToLoad.add(data.sourceField);
  se.search(new MatchAllDocsQuery(),new Collector(){
    private int baseDoc;
    private AtomicReader reader;
    @Override public boolean acceptsDocsOutOfOrder(){
      return true;
    }
    @Override public void collect(    int i){
      Document d;
      try {
        d=reader.document(this.baseDoc + i,fieldsToLoad);
        for (        String f : fieldsToLoad) {
          String[] vals=d.getValues(f);
          for (          String s : vals) {
            TokenStream ts=analyzer.tokenStream(targetAnalyzer,new StringReader(s));
            ts.reset();
            while (ts.incrementToken()) {
            }
          }
        }
      }
 catch (      IOException e) {
      }
    }
    @Override public void setNextReader(    AtomicReaderContext context){
      this.baseDoc=context.docBase;
      this.reader=context.reader();
    }
    @Override public void setScorer(    org.apache.lucene.search.Scorer scorer){
    }
  }
);
  TokenStream ts=analyzer.tokenStream(data.targetField,new StringReader(""String_Node_Str""));
  ts.reset();
  ts.reset();
  ts.reset();
}","private void runSynchronously(RequestQueue queue,SolrQueryRequest req) throws MalformedURLException, IOException, InterruptedException {
  SolrCore core=req.getCore();
  IndexSchema schema=req.getSchema();
  RequestData data=queue.pop();
  if (!allowed.matcher(data.sourceField).matches()) {
    data.msg(""String_Node_Str"" + data.sourceField);
    queue.registerFailedBatch(data);
  }
  SchemaField field=core.getSchema().getFieldOrNull(data.sourceField);
  if (field == null || !field.stored()) {
    data.msg(""String_Node_Str"" + data.sourceField);
    queue.registerFailedBatch(data);
  }
  final Analyzer analyzer=core.getSchema().getQueryAnalyzer();
  SchemaField targetField=core.getSchema().getFieldOrNull(data.targetField);
  if (targetField == null) {
    data.msg(""String_Node_Str"" + data.targetField);
    queue.registerFailedBatch(data);
  }
  final String targetAnalyzer=data.targetField;
  DirectoryReader ir=req.getSearcher().getIndexReader();
  SolrIndexSearcher se=req.getSearcher();
  final HashSet<String> fieldsToLoad=new HashSet<String>();
  fieldsToLoad.add(data.sourceField);
  se.search(new MatchAllDocsQuery(),new Collector(){
    private int baseDoc;
    private AtomicReader reader;
    @Override public boolean acceptsDocsOutOfOrder(){
      return true;
    }
    @Override public void collect(    int i){
      Document d;
      try {
        d=reader.document(i,fieldsToLoad);
        for (        String f : fieldsToLoad) {
          String[] vals=d.getValues(f);
          for (          String s : vals) {
            TokenStream ts=analyzer.tokenStream(targetAnalyzer,new StringReader(s));
            ts.reset();
            while (ts.incrementToken()) {
            }
          }
        }
      }
 catch (      IOException e) {
      }
    }
    @Override public void setNextReader(    AtomicReaderContext context){
      this.baseDoc=context.docBase;
      this.reader=context.reader();
    }
    @Override public void setScorer(    org.apache.lucene.search.Scorer scorer){
    }
  }
);
  TokenStream ts=analyzer.tokenStream(data.targetField,new StringReader(""String_Node_Str""));
  ts.reset();
  ts.reset();
  ts.reset();
}"
18007,"@Override public void collect(int i){
  Document d;
  try {
    d=reader.document(this.baseDoc + i,fieldsToLoad);
    for (    String f : fieldsToLoad) {
      String[] vals=d.getValues(f);
      for (      String s : vals) {
        TokenStream ts=analyzer.tokenStream(targetAnalyzer,new StringReader(s));
        ts.reset();
        while (ts.incrementToken()) {
        }
      }
    }
  }
 catch (  IOException e) {
  }
}","@Override public void collect(int i){
  Document d;
  try {
    d=reader.document(i,fieldsToLoad);
    for (    String f : fieldsToLoad) {
      String[] vals=d.getValues(f);
      for (      String s : vals) {
        TokenStream ts=analyzer.tokenStream(targetAnalyzer,new StringReader(s));
        ts.reset();
        while (ts.incrementToken()) {
        }
      }
    }
  }
 catch (  IOException e) {
  }
}"
18008,"private void doExpansion(NameInfo origNameInfo,QueryNode node,List<QueryNode> parentChildren){
  if (node instanceof TextableQueryNode) {
    if (node instanceof FuzzyQueryNode || node instanceof RegexpQueryNode || node instanceof WildcardQueryNode) {
      return;
    }
    FieldQueryNode fqn=((FieldQueryNode)node);
    if (fields.containsKey(fqn.getFieldAsString())) {
      String v=fqn.getTextAsString();
      String[] nameParts=fqn.getTextAsString().split(""String_Node_Str"");
      if (nameParts.length == 1) {
        if (nameParts.length < origNameInfo.noOfParts)         return;
        if (origNameInfo.containsOnlySurname) {
          parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
        }
 else {
        }
      }
 else {
        if (nameParts.length < origNameInfo.noOfParts)         return;
        if (origNameInfo.containsOnlySurname) {
          parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
        }
 else {
          if (origNameInfo.lastPartWasAcronym) {
            if (nameParts[nameParts.length - 1].length() == 1) {
              parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
            }
 else {
              parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
            }
          }
 else {
            parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
          }
        }
      }
      return;
    }
  }
  expandNodes(node,origNameInfo);
}","private void doExpansion(NameInfo origNameInfo,QueryNode node,List<QueryNode> parentChildren){
  if (node instanceof TextableQueryNode) {
    if (node instanceof FuzzyQueryNode || node instanceof RegexpQueryNode || node instanceof WildcardQueryNode) {
      return;
    }
    FieldQueryNode fqn=((FieldQueryNode)node);
    if (fields.containsKey(fqn.getFieldAsString())) {
      String v=fqn.getTextAsString();
      String[] nameParts=fqn.getTextAsString().split(""String_Node_Str"");
      if (nameParts.length == 1) {
        if (nameParts.length < origNameInfo.noOfParts)         return;
        if (origNameInfo.containsOnlySurname) {
          parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
        }
 else {
        }
      }
 else {
        if (nameParts.length < origNameInfo.noOfParts)         return;
        if (origNameInfo.containsOnlySurname) {
          parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
        }
 else {
          if (origNameInfo.lastPartWasAcronym) {
            if (nameParts[nameParts.length - 1].length() == 1) {
              parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
            }
 else {
              parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
            }
          }
 else {
            parentChildren.add(new PrefixWildcardQueryNode(fqn.getField(),v + ""String_Node_Str"",fqn.getBegin(),fqn.getEnd()));
          }
        }
      }
      return;
    }
  }
  if (!node.isLeaf())   expandNodes(node,origNameInfo);
}"
18009,"@Override public void reset() throws IOException {
  super.reset();
  tokenBuffer.clear();
  authorInput=null;
  resetCounter++;
  if (resetCounter > 2) {
    synMap.persist();
  }
}","@Override public void reset() throws IOException {
  super.reset();
  addTokensToSynMap();
  resetCounter++;
  if (resetCounter > 2) {
    synMap.persist();
  }
}"
18010,"@Override public boolean incrementToken() throws IOException {
  resetCounter=0;
  if (!input.incrementToken()) {
    addTokensToSynMap();
    return false;
  }
  if (authorInput != null) {
    if (tokenTypes.contains(typeAtt.type())) {
      tokenBuffer.add(termAtt.toString());
      if (emitTokens) {
        return true;
      }
      while (input.incrementToken()) {
        if (tokenTypes.contains(typeAtt.type())) {
          tokenBuffer.add(termAtt.toString());
        }
 else {
          if (typeAtt.type().equals(AuthorUtils.AUTHOR_INPUT)) {
            addTokensToSynMap();
            authorInput=termAtt.toString();
            tokenBuffer.clear();
          }
          return true;
        }
      }
    }
  }
  if (typeAtt.type().equals(AuthorUtils.AUTHOR_INPUT)) {
    authorInput=termAtt.toString();
  }
  return true;
}","@Override public boolean incrementToken() throws IOException {
  resetCounter=0;
  if (!input.incrementToken()) {
    return false;
  }
  if (authorInput != null && tokenTypes.contains(typeAtt.type())) {
    tokenBuffer.add(termAtt.toString());
    if (emitTokens) {
      return true;
    }
    while (input.incrementToken()) {
      if (tokenTypes.contains(typeAtt.type())) {
        tokenBuffer.add(termAtt.toString());
      }
 else {
        if (typeAtt.type().equals(AuthorUtils.AUTHOR_INPUT)) {
          addTokensToSynMap();
          authorInput=termAtt.toString();
        }
        return true;
      }
    }
    return false;
  }
  if (typeAtt.type().equals(AuthorUtils.AUTHOR_INPUT)) {
    authorInput=termAtt.toString();
  }
  return true;
}"
18011,"public void init(Context context,Properties initProps){
  super.init(context,initProps);
  mongoDocIdField=initProps.getProperty(MONGO_DOC_ID);
  mongoHost=initProps.getProperty(MONGO_HOST);
  mongoPort=initProps.getProperty(MONGO_PORT);
  mongoDBName=initProps.getProperty(MONGO_DB_NAME);
  mongoCollectionName=initProps.getProperty(MONGO_COLLECTION_NAME);
  List<Map<String,String>> fields=context.getAllEntityFields();
  fieldColumnMap=new HashMap<String,String>();
  mongoFields=new BasicDBObject();
  mongoFields.put(""String_Node_Str"",0);
  for (  Map<String,String> field : fields) {
    if (""String_Node_Str"".equals(field.get(MONGO_FIELD_ATTR))) {
      String mongoFieldName=field.get(MONGO_FIELD_NAME_ATTR);
      String columnName=field.get(FIELD_COLUMN_ATTR);
      if (mongoFieldName == null) {
        mongoFieldName=columnName;
      }
      mongoFields.put(mongoFieldName,1);
      fieldColumnMap.put(columnName,mongoFieldName);
    }
  }
}","@Override public void init(Context context,Properties initProps){
  super.init(context,initProps);
  mongoDocIdField=initProps.getProperty(MONGO_DOC_ID);
  mongoHost=initProps.getProperty(MONGO_HOST);
  mongoPort=initProps.getProperty(MONGO_PORT);
  mongoDBName=initProps.getProperty(MONGO_DB_NAME);
  mongoCollectionName=initProps.getProperty(MONGO_COLLECTION_NAME);
  List<Map<String,String>> fields=context.getAllEntityFields();
  fieldColumnMap=new HashMap<String,String>();
  mongoFields=new BasicDBObject();
  mongoFields.put(""String_Node_Str"",0);
  for (  Map<String,String> field : fields) {
    if (""String_Node_Str"".equals(field.get(MONGO_FIELD_ATTR))) {
      String mongoFieldName=field.get(MONGO_FIELD_NAME_ATTR);
      String columnName=field.get(FIELD_COLUMN_ATTR);
      if (mongoFieldName == null) {
        mongoFieldName=columnName;
      }
      mongoFields.put(mongoFieldName,1);
      fieldColumnMap.put(columnName,mongoFieldName);
    }
  }
}"
18012,"public void dumpDoc(Integer docId,String... fields) throws Exception {
  SolrQueryRequest sr=req();
  IndexReader reader=sr.getSearcher().getTopReaderContext().reader();
  int[] docs;
  if (docId == null) {
    docs=new int[reader.numDocs()];
    for (int i=0; i < docs.length; i++) {
      docs[i]=i;
    }
  }
 else {
    docs=new int[]{docId};
  }
  DocReconstructor reconstructor=new DocReconstructor(reader);
  Reconstructed d;
  for (  Integer dd : docs) {
    d=reconstructor.reconstruct(dd);
    Set<String> fldMap=new HashSet<String>();
    for (    String f : fields) {
      fldMap.add(f);
    }
    System.out.println(""String_Node_Str"");
    Map<String,GrowableStringArray> rf=d.getReconstructedFields();
    for (    Entry<String,GrowableStringArray> es : rf.entrySet()) {
      String fld=es.getKey();
      if (fldMap.size() > 0 && !fldMap.contains(fld)) {
        continue;
      }
      System.out.println(fld);
      System.out.println(docToString(es.getValue(),""String_Node_Str""));
    }
    if (true)     continue;
    System.out.println(""String_Node_Str"");
    Map<String,IndexableField[]> sf=d.getStoredFields();
    for (    Entry<String,IndexableField[]> es : sf.entrySet()) {
      String fld=es.getKey();
      if (fldMap.size() > 0 && !fldMap.contains(fld)) {
        continue;
      }
      System.out.println(fld);
      IndexableField[] val=es.getValue();
      int j=0;
      for (      IndexableField v : val) {
        System.out.println(""String_Node_Str"" + j + ""String_Node_Str""+ v.stringValue());
        j++;
      }
    }
  }
  sr.close();
}","public void dumpDoc(Integer docId,String... fields) throws Exception {
  SolrQueryRequest sr=req();
  IndexReader reader=sr.getSearcher().getTopReaderContext().reader();
  int[] docs;
  if (docId == null) {
    docs=new int[reader.numDocs()];
    for (int i=0; i < docs.length; i++) {
      docs[i]=i;
    }
  }
 else {
    docs=new int[]{docId};
  }
  DocReconstructor reconstructor=new DocReconstructor(reader,fields,10);
  Reconstructed d;
  for (  Integer dd : docs) {
    d=reconstructor.reconstruct(dd);
    Set<String> fldMap=new HashSet<String>();
    for (    String f : fields) {
      fldMap.add(f);
    }
    System.out.println(""String_Node_Str"" + dd);
    Map<String,GrowableStringArray> rf=d.getReconstructedFields();
    for (    Entry<String,GrowableStringArray> es : rf.entrySet()) {
      String fld=es.getKey();
      if (fldMap.size() > 0 && !fldMap.contains(fld)) {
        continue;
      }
      System.out.println(fld);
      System.out.println(docToString(es.getValue(),""String_Node_Str""));
    }
    if (true)     continue;
    System.out.println(""String_Node_Str"" + dd);
    Map<String,IndexableField[]> sf=d.getStoredFields();
    for (    Entry<String,IndexableField[]> es : sf.entrySet()) {
      String fld=es.getKey();
      if (fldMap.size() > 0 && !fldMap.contains(fld)) {
        continue;
      }
      System.out.println(fld);
      IndexableField[] val=es.getValue();
      int j=0;
      for (      IndexableField v : val) {
        System.out.println(""String_Node_Str"" + j + ""String_Node_Str""+ v.stringValue());
        j++;
      }
    }
  }
  sr.close();
}"
18013,"public void testImport() throws Exception {
  String testDir=MontySolrSetup.getMontySolrHome() + ""String_Node_Str"";
  SolrRequestHandler handler=h.getCore().getRequestHandler(""String_Node_Str"");
  SolrCore core=h.getCore();
  String url=""String_Node_Str"" + MontySolrSetup.getMontySolrHome() + ""String_Node_Str"";
  SolrQueryRequest req=req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",testDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",url);
  SolrQueryResponse rsp=new SolrQueryResponse();
  core.execute(handler,req,rsp);
  commit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  req=req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",testDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rsp=new SolrQueryResponse();
  core.execute(handler,req,rsp);
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DirectSolrConnection direct=getDirectServer();
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}","public void testImport() throws Exception {
  String testDir=MontySolrSetup.getMontySolrHome() + ""String_Node_Str"";
  SolrRequestHandler handler=h.getCore().getRequestHandler(""String_Node_Str"");
  SolrCore core=h.getCore();
  String url=""String_Node_Str"" + MontySolrSetup.getMontySolrHome() + ""String_Node_Str"";
  SolrQueryRequest req=req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",testDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",url);
  SolrQueryResponse rsp=new SolrQueryResponse();
  core.execute(handler,req,rsp);
  commit(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  req=req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",testDir,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rsp=new SolrQueryResponse();
  core.execute(handler,req,rsp);
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  DirectSolrConnection direct=getDirectServer();
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assertQ(req(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}"
18014,"protected void runProcessingAdded(int[] recids,SolrQueryRequest req) throws IOException {
  IndexSchema schema=req.getSchema();
  UpdateHandler updateHandler=req.getCore().getUpdateHandler();
  String uniqField=schema.getUniqueKeyField().getName();
  SolrParams params=req.getParams();
  AddUpdateCommand addCmd=new AddUpdateCommand(req);
  addCmd.commitWithin=params.getInt(UpdateParams.COMMIT_WITHIN,-1);
  addCmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);
  if (recids.length > 0) {
    SolrInputDocument doc=new SolrInputDocument();
    for (int i=0; i < recids.length; i++) {
      doc.clear();
      doc.addField(uniqField,recids[i]);
      addCmd.solrDoc=doc;
      updateHandler.addDoc(addCmd);
    }
  }
}","protected void runProcessingAdded(int[] recids,SolrQueryRequest req) throws IOException {
  IndexSchema schema=req.getSchema();
  UpdateHandler updateHandler=req.getCore().getUpdateHandler();
  String uniqField=schema.getUniqueKeyField().getName();
  AddUpdateCommand addCmd=new AddUpdateCommand(req);
  if (recids.length > 0) {
    for (int i=0; i < recids.length; i++) {
      addCmd.clear();
      addCmd.solrDoc=new SolrInputDocument();
      addCmd.solrDoc.addField(uniqField,recids[i]);
      updateHandler.addDoc(addCmd);
    }
  }
}"
18015,"private void runSynchronously(Map<String,Object> data,SolrQueryRequest req) throws MalformedURLException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  log.info(data.toString());
  log.info(req.toString());
  log.info(req.getParamString());
  log.info(""String_Node_Str"");
  SolrParams params=req.getParams();
  SolrCore core=req.getCore();
  String importurl=params.get(PARAM_IMPORT,null);
  String updateurl=params.get(PARAM_UPDATE,null);
  String deleteurl=params.get(PARAM_DELETE,null);
  @SuppressWarnings(""String_Node_Str"") HashMap<String,int[]> dictData=(HashMap<String,int[]>)data.get(""String_Node_Str"");
  Properties prop=(Properties)req.getContext().get(IKRU_PROPERTIES);
  if (dictData.containsKey(ADDED) && dictData.get(ADDED).length > 0) {
    setWorkerMessage(""String_Node_Str"" + dictData.get(ADDED).length);
    if (importurl != null) {
      if (importurl.equals(""String_Node_Str"")) {
        runProcessingAdded(dictData.get(ADDED),req);
      }
 else {
        runProcessing(core,importurl,dictData.get(ADDED),req);
      }
    }
  }
  if (dictData.containsKey(UPDATED) && dictData.get(UPDATED).length > 0) {
    setWorkerMessage(""String_Node_Str"" + dictData.get(UPDATED).length);
    if (updateurl != null) {
      if (updateurl.equals(""String_Node_Str"")) {
        runProcessingUpdated(dictData.get(UPDATED),req);
      }
 else {
        runProcessing(core,updateurl,dictData.get(UPDATED),req);
      }
    }
  }
  if (dictData.containsKey(DELETED) && dictData.get(DELETED).length > 0) {
    setWorkerMessage(""String_Node_Str"" + dictData.get(DELETED).length);
    if (deleteurl != null) {
      if (deleteurl.equals(""String_Node_Str"")) {
        runProcessingDeleted(dictData.get(DELETED),req);
      }
 else {
        runProcessing(core,deleteurl,dictData.get(DELETED),req);
      }
    }
  }
  prop.put(LAST_UPDATE,(String)data.get(LAST_UPDATE));
  prop.put(LAST_RECID,String.valueOf((Integer)data.get(LAST_RECID)));
  prop.remove(PARAM_BATCHSIZE);
  prop.remove(PARAM_MAXIMPORT);
  prop.remove(PARAM_TOKEN);
  saveProperties(prop);
  if (params.getBool(PARAM_COMMIT,false)) {
    System.err.println(""String_Node_Str"");
    setWorkerMessage(""String_Node_Str"");
    CommitUpdateCommand updateCmd=new CommitUpdateCommand(req,false);
    req.getCore().getUpdateHandler().commit(updateCmd);
  }
}","private void runSynchronously(Map<String,Object> data,SolrQueryRequest req) throws MalformedURLException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  log.info(data.toString());
  log.info(req.toString());
  log.info(req.getParamString());
  log.info(""String_Node_Str"");
  SolrParams params=req.getParams();
  SolrCore core=req.getCore();
  String importurl=params.get(PARAM_IMPORT,null);
  String updateurl=params.get(PARAM_UPDATE,null);
  String deleteurl=params.get(PARAM_DELETE,null);
  @SuppressWarnings(""String_Node_Str"") HashMap<String,int[]> dictData=(HashMap<String,int[]>)data.get(""String_Node_Str"");
  Properties prop=(Properties)req.getContext().get(IKRU_PROPERTIES);
  if (dictData.containsKey(ADDED) && dictData.get(ADDED).length > 0) {
    setWorkerMessage(""String_Node_Str"" + dictData.get(ADDED).length);
    if (importurl != null) {
      if (importurl.equals(""String_Node_Str"")) {
        runProcessingAdded(dictData.get(ADDED),req);
      }
 else {
        runProcessing(core,importurl,dictData.get(ADDED),req);
      }
    }
  }
  if (dictData.containsKey(UPDATED) && dictData.get(UPDATED).length > 0) {
    setWorkerMessage(""String_Node_Str"" + dictData.get(UPDATED).length);
    if (updateurl != null) {
      if (updateurl.equals(""String_Node_Str"")) {
        runProcessingUpdated(dictData.get(UPDATED),req);
      }
 else {
        runProcessing(core,updateurl,dictData.get(UPDATED),req);
      }
    }
  }
  if (dictData.containsKey(DELETED) && dictData.get(DELETED).length > 0) {
    setWorkerMessage(""String_Node_Str"" + dictData.get(DELETED).length);
    if (deleteurl != null) {
      if (deleteurl.equals(""String_Node_Str"")) {
        runProcessingDeleted(dictData.get(DELETED),req);
      }
 else {
        runProcessing(core,deleteurl,dictData.get(DELETED),req);
      }
    }
  }
  prop.put(LAST_UPDATE,(String)data.get(LAST_UPDATE));
  prop.put(LAST_RECID,String.valueOf((Integer)data.get(LAST_RECID)));
  prop.remove(PARAM_BATCHSIZE);
  prop.remove(PARAM_MAXIMPORT);
  prop.remove(PARAM_TOKEN);
  saveProperties(prop);
  if (params.getBool(PARAM_COMMIT,false)) {
    setWorkerMessage(""String_Node_Str"");
    CommitUpdateCommand updateCmd=new CommitUpdateCommand(req,false);
    req.getCore().getUpdateHandler().commit(updateCmd);
  }
}"
18016,"protected void runProcessingUpdated(int[] recids,SolrQueryRequest req) throws IOException {
  IndexSchema schema=req.getSchema();
  UpdateHandler updateHandler=req.getCore().getUpdateHandler();
  String uniqField=schema.getUniqueKeyField().getName();
  SolrParams params=req.getParams();
  AddUpdateCommand addCmd=new AddUpdateCommand(req);
  addCmd.commitWithin=params.getInt(UpdateParams.COMMIT_WITHIN,-1);
  addCmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);
  if (recids.length > 0) {
    Map<Integer,Integer> map=DictionaryRecIdCache.INSTANCE.getTranslationCache(req.getSearcher().getAtomicReader(),uniqField);
    SolrInputDocument doc=new SolrInputDocument();
    for (int i=0; i < recids.length; i++) {
      if (!map.containsKey(recids[i])) {
        doc.clear();
        doc.addField(uniqField,recids[i]);
        addCmd.solrDoc=doc;
        updateHandler.addDoc(addCmd);
      }
    }
  }
}","protected void runProcessingUpdated(int[] recids,SolrQueryRequest req) throws IOException {
  IndexSchema schema=req.getSchema();
  UpdateHandler updateHandler=req.getCore().getUpdateHandler();
  String uniqField=schema.getUniqueKeyField().getName();
  AddUpdateCommand addCmd=new AddUpdateCommand(req);
  if (recids.length > 0) {
    for (int i=0; i < recids.length; i++) {
      addCmd.clear();
      addCmd.solrDoc=new SolrInputDocument();
      addCmd.solrDoc.addField(uniqField,recids[i]);
      updateHandler.addDoc(addCmd);
    }
  }
}"
18017,"protected void runProcessingDeleted(int[] recids,SolrQueryRequest req) throws IOException {
  IndexSchema schema=req.getSchema();
  UpdateHandler updateHandler=req.getCore().getUpdateHandler();
  SolrParams params=req.getParams();
  DeleteUpdateCommand delCmd=new DeleteUpdateCommand(req);
  delCmd.commitWithin=params.getInt(UpdateParams.COMMIT_WITHIN,-1);
  delCmd.setFlags(UpdateCommand.IGNORE_AUTOCOMMIT);
  if (recids.length > 0) {
    for (int i=0; i < recids.length; i++) {
      delCmd.id=Integer.toString(recids[i]);
      updateHandler.delete(delCmd);
    }
  }
}","protected void runProcessingDeleted(int[] recids,SolrQueryRequest req) throws IOException {
  UpdateHandler updateHandler=req.getCore().getUpdateHandler();
  DeleteUpdateCommand delCmd=new DeleteUpdateCommand(req);
  if (recids.length > 0) {
    for (int i=0; i < recids.length; i++) {
      delCmd.clear();
      delCmd.id=Integer.toString(recids[i]);
      updateHandler.delete(delCmd);
    }
  }
}"
18018,"private void runSynchronously(RequestQueue queue,SolrQueryRequest req) throws MalformedURLException, IOException, InterruptedException {
  SolrCore core=req.getCore();
  SolrRequestHandler handler=req.getCore().getRequestHandler(handlerName);
  SolrQueryResponse rsp=new SolrQueryResponse();
  RequestData data=queue.pop();
  LocalSolrQueryRequest locReq=new LocalSolrQueryRequest(req.getCore(),data.getReqParams());
  log.warn(""String_Node_Str"" + handlerName + ""String_Node_Str""+ locReq.getParamString());
  core.execute(handler,locReq,rsp);
  setWorkerMessage(""String_Node_Str"" + handlerName + ""String_Node_Str""+ locReq.getParamString()+ ""String_Node_Str""+ rsp.getValues().toString());
}","private void runSynchronously(RequestQueue queue,SolrQueryRequest req) throws MalformedURLException, IOException, InterruptedException {
  SolrCore core=req.getCore();
  SolrRequestHandler handler=req.getCore().getRequestHandler(handlerName);
  RequestData data=queue.pop();
  LocalSolrQueryRequest locReq=new LocalSolrQueryRequest(req.getCore(),data.getReqParams());
  setWorkerMessage(""String_Node_Str"" + handlerName + ""String_Node_Str""+ locReq.getParamString());
  SolrQueryResponse rsp;
  boolean repeat=false;
  do {
    rsp=new SolrQueryResponse();
    core.execute(handler,locReq,rsp);
    String is=(String)rsp.getValues().get(""String_Node_Str"");
    if (is.equals(""String_Node_Str"")) {
      repeat=true;
      Thread.sleep(sleepTime);
      setWorkerMessage(""String_Node_Str"" + handlerName);
    }
  }
 while (repeat);
  setWorkerMessage(""String_Node_Str"" + handlerName + ""String_Node_Str""+ locReq.getParamString()+ ""String_Node_Str""+ rsp.getValues().toString());
}"
18019,"@SuppressWarnings(""String_Node_Str"") public void init(NamedList args){
  super.init(args);
  if (args.get(""String_Node_Str"") == null) {
    return;
  }
  NamedList defs=(NamedList)args.get(""String_Node_Str"");
  if (defs.get(""String_Node_Str"") != null) {
    handlerName=(String)defs.get(""String_Node_Str"");
  }
}","@SuppressWarnings(""String_Node_Str"") public void init(NamedList args){
  super.init(args);
  if (args.get(""String_Node_Str"") == null) {
    return;
  }
  NamedList defs=(NamedList)args.get(""String_Node_Str"");
  if (defs.get(""String_Node_Str"") != null) {
    handlerName=(String)defs.get(""String_Node_Str"");
  }
  if (defs.get(""String_Node_Str"") != null) {
    sleepTime=Long.parseLong((String)defs.get(""String_Node_Str""));
  }
}"
18020,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof PositionSearchFunction))   return false;
  PositionSearchFunction that=(PositionSearchFunction)o;
  if (this.hashCode() != that.hashCode())   return false;
  return false;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (!(o instanceof PositionSearchFunction))   return false;
  PositionSearchFunction that=(PositionSearchFunction)o;
  if (this.hashCode() == that.hashCode())   return true;
  return false;
}"
18021,"/** 
 * Almost finished: 17Apr TODO: x NEAR/2 y x:four -field:(-one +two x:three) ""\""func(*) AND that\"""" (should not be analyzed; AND becomes and)
 * @throws Exception
 */
public void testBasics() throws Exception {
  WhitespaceAnalyzer wsa=new WhitespaceAnalyzer(Version.LUCENE_CURRENT);
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"",PhraseQuery.class);
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"",PhraseQuery.class);
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"",TermQuery.class);
}","/** 
 * Almost finished: 17Apr TODO: x NEAR/2 y x:four -field:(-one +two x:three) ""\""func(*) AND that\"""" (should not be analyzed; AND becomes and)
 * @throws Exception
 */
public void testBasics() throws Exception {
  WhitespaceAnalyzer wsa=new WhitespaceAnalyzer(Version.LUCENE_CURRENT);
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  setDebug(true);
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",null,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"",PhraseQuery.class);
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"",PhraseQuery.class);
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"");
  assertQueryEquals(""String_Node_Str"",wsa,""String_Node_Str"",TermQuery.class);
}"
18022,"@Override protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
  if (node instanceof AqpANTLRNode && ((AqpANTLRNode)node).getTokenLabel().equals(""String_Node_Str"")) {
    if (node.getChildren().size() == 1) {
      return node.getChildren().get(0);
    }
    String modifier=((AqpANTLRNode)node.getChildren().get(0)).getTokenName();
    QueryNode childNode=node.getChildren().get(node.getChildren().size() - 1);
    if (modifier.equals(""String_Node_Str"")) {
      return new ModifierQueryNode(childNode,ModifierQueryNode.Modifier.MOD_REQ);
    }
 else     if (modifier.equals(""String_Node_Str"")) {
      return new ModifierQueryNode(childNode,ModifierQueryNode.Modifier.MOD_REQ);
    }
 else {
      throw new QueryNodeException(new MessageImpl(QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR,""String_Node_Str"" + modifier + ""String_Node_Str""+ node.toString()));
    }
  }
  return node;
}","@Override protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
  if (node instanceof AqpANTLRNode && ((AqpANTLRNode)node).getTokenLabel().equals(""String_Node_Str"")) {
    if (node.getChildren().size() == 1) {
      return node.getChildren().get(0);
    }
    String modifier=((AqpANTLRNode)node.getChildren().get(0)).getTokenName();
    QueryNode childNode=node.getChildren().get(node.getChildren().size() - 1);
    if (modifier.equals(""String_Node_Str"")) {
      return new ModifierQueryNode(childNode,ModifierQueryNode.Modifier.MOD_REQ);
    }
 else     if (modifier.equals(""String_Node_Str"")) {
      return new ModifierQueryNode(childNode,ModifierQueryNode.Modifier.MOD_NOT);
    }
 else {
      throw new QueryNodeException(new MessageImpl(QueryParserMessages.LUCENE_QUERY_CONVERSION_ERROR,""String_Node_Str"" + modifier + ""String_Node_Str""+ node.toString()));
    }
  }
  return node;
}"
18023,"public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws IOException, InterruptedException {
  if (isBusy()) {
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  setBusy(true);
  SolrParams params=req.getParams();
  long start=System.currentTimeMillis();
  Properties prop=loadProperties(params);
  Map<String,Object> dictData=null;
  try {
    dictData=retrieveRecids(prop,req,rsp);
  }
 catch (  RuntimeException e) {
    setBusy(false);
    throw e;
  }
  if (dictData == null) {
    setBusy(false);
    return;
  }
  LocalSolrQueryRequest locReq=new LocalSolrQueryRequest(req.getCore(),params);
  locReq.getContext().put(IKRU_PROPERTIES,prop);
  if (isAsynchronous()) {
    runAsynchronously(dictData,locReq);
  }
 else {
    runSynchronously(dictData,locReq);
    locReq.close();
  }
  long end=System.currentTimeMillis();
  rsp.add(""String_Node_Str"",isBusy() ? ""String_Node_Str"" : ""String_Node_Str"");
  rsp.add(""String_Node_Str"",end - start);
}","public void handleRequestBody(SolrQueryRequest req,SolrQueryResponse rsp) throws IOException, InterruptedException {
  if (isBusy()) {
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    rsp.add(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  setBusy(true);
  SolrParams params=req.getParams();
  long start=System.currentTimeMillis();
  Properties prop=loadProperties(params);
  Map<String,Object> dictData=null;
  try {
    dictData=retrieveRecids(prop,req,rsp);
  }
 catch (  RuntimeException e) {
    setBusy(false);
    throw e;
  }
  if (dictData == null) {
    setBusy(false);
    return;
  }
  LocalSolrQueryRequest locReq=new LocalSolrQueryRequest(req.getCore(),params);
  locReq.getContext().put(IKRU_PROPERTIES,prop);
  if (isAsynchronous()) {
    runAsynchronously(dictData,locReq);
  }
 else {
    runSynchronously(dictData,locReq);
    locReq.close();
    setBusy(false);
  }
  long end=System.currentTimeMillis();
  rsp.add(""String_Node_Str"",isBusy() ? ""String_Node_Str"" : ""String_Node_Str"");
  rsp.add(""String_Node_Str"",end - start);
}"
18024,"protected String getFetchURL(String importurl,String inveniourl,String queryPart,Integer maximport) throws UnsupportedEncodingException {
  String sign=importurl.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  return importurl + sign + ""String_Node_Str""+ java.net.URLEncoder.encode(inveniourl + ""String_Node_Str"" + queryPart+ ""String_Node_Str""+ maximport+ ""String_Node_Str"",""String_Node_Str"");
}","protected String getFetchURL(String importurl,String inveniourl,String queryPart,Integer maximport) throws UnsupportedEncodingException {
  String sign=importurl.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  return importurl + sign + ""String_Node_Str""+ java.net.URLEncoder.encode(inveniourl + ""String_Node_Str"" + java.net.URLEncoder.encode(queryPart,""String_Node_Str"")+ ""String_Node_Str""+ maximport+ ""String_Node_Str"",""String_Node_Str"");
}"
18025,"protected String getFetchURL(String importurl,String inveniourl,String queryPart,Integer maximport) throws UnsupportedEncodingException {
  String sign=importurl.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  return importurl + sign + ""String_Node_Str""+ java.net.URLEncoder.encode(inveniourl + ""String_Node_Str"" + queryPart+ ""String_Node_Str""+ maximport+ ""String_Node_Str"",""String_Node_Str"");
}","protected String getFetchURL(String importurl,String inveniourl,String queryPart,Integer maximport) throws UnsupportedEncodingException {
  String sign=importurl.contains(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"";
  return importurl + sign + ""String_Node_Str""+ java.net.URLEncoder.encode(inveniourl + ""String_Node_Str"" + java.net.URLEncoder.encode(queryPart,""String_Node_Str"")+ ""String_Node_Str""+ maximport+ ""String_Node_Str"",""String_Node_Str"");
}"
18026,"private void ban(BanType type,String targetName,String targetUUID,String senderName,String senderUUID,String reason,String duration,String measure){
  if (targetName == null || senderName == null) {
    return;
  }
  String targetIP=""String_Node_Str"";
  if (type != BanType.UNBAN) {
    final Player target=Bukkit.getPlayerExact(targetName);
    targetIP=(target != null) ? target.getAddress().getAddress().getHostAddress() : ""String_Node_Str"";
  }
  Ban banControl=new Ban(plugin,type.getActionName(),targetName,targetIP,senderName,reason,duration,measure);
  Thread triggerThread=new Thread(banControl);
  triggerThread.start();
}","private void ban(BanType type,String targetName,String targetUUID,String senderName,String senderUUID,String reason,String duration,String measure){
  if (targetName == null || senderName == null) {
    return;
  }
  String targetIP=""String_Node_Str"";
  if (type != BanType.UNBAN) {
    final Player target=Bukkit.getPlayerExact(targetName);
    targetIP=(target != null) ? target.getAddress().getAddress().getHostAddress() : ""String_Node_Str"";
  }
  Ban banControl=new Ban(plugin,type.getActionName(),targetName,targetUUID,targetIP,senderName,senderUUID,reason,duration,measure,null,false);
  Thread triggerThread=new Thread(banControl);
  triggerThread.start();
}"
18027,"private void bukkitBan(final boolean flag){
  OfflinePlayer target=plugin.getServer().getOfflinePlayer(playerName);
  if (target == null) {
    return;
  }
  if (flag) {
    if (!target.isBanned()) {
      target.setBanned(true);
      this.kickPlayer(playerName,_(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.IP,playerIP));
    }
  }
 else {
    if (target.isBanned()) {
      target.setBanned(false);
    }
  }
  if (!target.isBanned()) {
    target.setBanned(true);
  }
}","private void bukkitBan(final boolean flag){
  OfflinePlayer target=plugin.getServer().getOfflinePlayer(playerName);
  if (target == null) {
    return;
  }
  if (flag) {
    if (!target.isBanned()) {
      target.setBanned(true);
      this.kickPlayer(playerName,_(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.IP,playerIP));
    }
  }
 else {
    if (target.isBanned()) {
      target.setBanned(false);
    }
  }
}"
18028,"public void startSync(){
  if (plugin.syncRunning) {
    return;
  }
  plugin.syncRunning=true;
  boolean goNext=true;
  int f=1;
  while (goNext) {
    long startID=plugin.lastID;
    JsonHandler webHandle=new JsonHandler(plugin);
    HashMap<String,String> url_items=new HashMap<String,String>();
    url_items.put(""String_Node_Str"",String.valueOf(plugin.lastID));
    url_items.put(""String_Node_Str"",""String_Node_Str"");
    JSONObject response=webHandle.hdl_jobj(url_items);
    try {
      if (response.has(""String_Node_Str"")) {
        if (response.getJSONArray(""String_Node_Str"").length() > 0) {
          for (int v=0; v < response.getJSONArray(""String_Node_Str"").length(); v++) {
            String[] plyer=response.getJSONArray(""String_Node_Str"").getString(v).split(""String_Node_Str"");
            OfflinePlayer d=plugin.getServer().getOfflinePlayer(plyer[0]);
            if (d.isBanned()) {
              if (plyer[1].equals(""String_Node_Str"")) {
                d.setBanned(false);
              }
            }
 else {
              if (plyer[1].equals(""String_Node_Str"")) {
                d.setBanned(true);
              }
            }
          }
        }
      }
      if (response.has(""String_Node_Str"")) {
        long h=response.getLong(""String_Node_Str"");
        if (h != 0) {
          plugin.lastID=h;
        }
      }
      if (response.has(""String_Node_Str"")) {
        goNext=true;
      }
 else {
        goNext=false;
      }
    }
 catch (    NullPointerException e) {
      if (plugin.getConfigs().isDebug()) {
        e.printStackTrace();
      }
    }
catch (    JSONException e) {
      if (plugin.getConfigs().isDebug()) {
        e.printStackTrace();
      }
    }
    if (plugin.lastID == startID) {
      f++;
    }
 else {
      f=1;
    }
    if (f > 5) {
      goNext=false;
    }
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException ignore) {
    }
  }
  plugin.syncRunning=false;
}","public void startSync(){
  if (plugin.syncRunning) {
    return;
  }
  plugin.syncRunning=true;
  try {
    boolean goNext=true;
    int f=1;
    while (goNext) {
      long startID=plugin.lastID;
      JsonHandler webHandle=new JsonHandler(plugin);
      HashMap<String,String> url_items=new HashMap<String,String>();
      url_items.put(""String_Node_Str"",String.valueOf(plugin.lastID));
      url_items.put(""String_Node_Str"",""String_Node_Str"");
      JSONObject response=webHandle.hdl_jobj(url_items);
      try {
        if (response.has(""String_Node_Str"")) {
          if (response.getJSONArray(""String_Node_Str"").length() > 0) {
            for (int v=0; v < response.getJSONArray(""String_Node_Str"").length(); v++) {
              String[] plyer=response.getJSONArray(""String_Node_Str"").getString(v).split(""String_Node_Str"");
              OfflinePlayer d=plugin.getServer().getOfflinePlayer(plyer[0]);
              if (d.isBanned()) {
                if (plyer[1].equals(""String_Node_Str"")) {
                  d.setBanned(false);
                }
              }
 else {
                if (plyer[1].equals(""String_Node_Str"")) {
                  d.setBanned(true);
                }
              }
            }
          }
        }
        if (response.has(""String_Node_Str"")) {
          long h=response.getLong(""String_Node_Str"");
          if (h != 0) {
            plugin.lastID=h;
          }
        }
        if (response.has(""String_Node_Str"")) {
          goNext=true;
        }
 else {
          goNext=false;
        }
      }
 catch (      NullPointerException e) {
        if (plugin.getConfigs().isDebug()) {
          e.printStackTrace();
        }
      }
catch (      JSONException e) {
        if (plugin.getConfigs().isDebug()) {
          e.printStackTrace();
        }
      }
      if (plugin.lastID == startID) {
        f++;
      }
 else {
        f=1;
      }
      if (f > 5) {
        goNext=false;
      }
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException ignore) {
      }
    }
  }
  finally {
    plugin.syncRunning=false;
  }
}"
18029,"public void initialSync(){
  if (plugin.syncRunning) {
    return;
  }
  plugin.syncRunning=true;
  boolean goNext=true;
  int f=1;
  while (goNext) {
    long startID=plugin.lastID;
    JsonHandler webHandle=new JsonHandler(plugin);
    HashMap<String,String> url_items=new HashMap<String,String>();
    url_items.put(""String_Node_Str"",String.valueOf(plugin.lastID));
    url_items.put(""String_Node_Str"",String.valueOf(plugin.timeRecieved));
    url_items.put(""String_Node_Str"",""String_Node_Str"");
    JSONObject response=webHandle.hdl_jobj(url_items);
    try {
      if (response.has(""String_Node_Str"")) {
        if (response.getJSONArray(""String_Node_Str"").length() > 0) {
          for (int v=0; v < response.getJSONArray(""String_Node_Str"").length(); v++) {
            String[] plyer=response.getJSONArray(""String_Node_Str"").getString(v).split(""String_Node_Str"");
            OfflinePlayer d=plugin.getServer().getOfflinePlayer(plyer[0]);
            if (d.isBanned()) {
              if (plyer[1].equals(""String_Node_Str"")) {
                d.setBanned(false);
              }
            }
 else {
              if (plyer[1].equals(""String_Node_Str"")) {
                d.setBanned(true);
              }
            }
          }
        }
      }
      if (plugin.lastID == 0) {
        if (response.has(""String_Node_Str"")) {
          plugin.timeRecieved=response.getLong(""String_Node_Str"");
        }
      }
      if (response.has(""String_Node_Str"")) {
        plugin.lastID=response.getLong(""String_Node_Str"");
      }
      if (response.has(""String_Node_Str"")) {
        goNext=true;
      }
 else {
        goNext=false;
      }
    }
 catch (    JSONException e) {
      if (plugin.getConfigs().isDebug()) {
        e.printStackTrace();
      }
    }
catch (    NullPointerException e) {
      if (plugin.getConfigs().isDebug()) {
        e.printStackTrace();
      }
    }
    if (plugin.lastID == startID) {
      f++;
    }
 else {
      f=1;
    }
    if (f > 5) {
      goNext=false;
    }
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException ignore) {
    }
  }
  plugin.syncRunning=false;
}","public void initialSync(){
  if (plugin.syncRunning) {
    return;
  }
  plugin.syncRunning=true;
  try {
    boolean goNext=true;
    int f=1;
    while (goNext) {
      long startID=plugin.lastID;
      JsonHandler webHandle=new JsonHandler(plugin);
      HashMap<String,String> url_items=new HashMap<String,String>();
      url_items.put(""String_Node_Str"",String.valueOf(plugin.lastID));
      url_items.put(""String_Node_Str"",String.valueOf(plugin.timeRecieved));
      url_items.put(""String_Node_Str"",""String_Node_Str"");
      JSONObject response=webHandle.hdl_jobj(url_items);
      try {
        if (response.has(""String_Node_Str"")) {
          if (response.getJSONArray(""String_Node_Str"").length() > 0) {
            for (int v=0; v < response.getJSONArray(""String_Node_Str"").length(); v++) {
              String[] plyer=response.getJSONArray(""String_Node_Str"").getString(v).split(""String_Node_Str"");
              OfflinePlayer d=plugin.getServer().getOfflinePlayer(plyer[0]);
              if (d.isBanned()) {
                if (plyer[1].equals(""String_Node_Str"")) {
                  d.setBanned(false);
                }
              }
 else {
                if (plyer[1].equals(""String_Node_Str"")) {
                  d.setBanned(true);
                }
              }
            }
          }
        }
        if (plugin.lastID == 0) {
          if (response.has(""String_Node_Str"")) {
            plugin.timeRecieved=response.getLong(""String_Node_Str"");
          }
        }
        if (response.has(""String_Node_Str"")) {
          plugin.lastID=response.getLong(""String_Node_Str"");
        }
        if (response.has(""String_Node_Str"")) {
          goNext=true;
        }
 else {
          goNext=false;
        }
      }
 catch (      JSONException e) {
        if (plugin.getConfigs().isDebug()) {
          e.printStackTrace();
        }
      }
catch (      NullPointerException e) {
        if (plugin.getConfigs().isDebug()) {
          e.printStackTrace();
        }
      }
      if (plugin.lastID == startID) {
        f++;
      }
 else {
        f=1;
      }
      if (f > 5) {
        goNext=false;
      }
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException ignore) {
      }
    }
  }
  finally {
    plugin.syncRunning=false;
  }
}"
18030,"@Override public void run(){
  if (plugin.syncRunning) {
    Util.message(commandSend,ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
  plugin.syncRunning=true;
  boolean goNext=true;
  int f=1;
  plugin.last_req=0;
  plugin.lastID=0;
  plugin.timeRecieved=0;
  while (goNext) {
    long startID=plugin.lastID;
    JsonHandler webHandle=new JsonHandler(plugin);
    HashMap<String,String> url_items=new HashMap<String,String>();
    url_items.put(""String_Node_Str"",String.valueOf(plugin.lastID));
    url_items.put(""String_Node_Str"",String.valueOf(plugin.timeRecieved));
    url_items.put(""String_Node_Str"",""String_Node_Str"");
    JSONObject response=webHandle.hdl_jobj(url_items);
    try {
      if (response.has(""String_Node_Str"")) {
        if (response.getJSONArray(""String_Node_Str"").length() > 0) {
          for (int v=0; v < response.getJSONArray(""String_Node_Str"").length(); v++) {
            String[] plyer=response.getJSONArray(""String_Node_Str"").getString(v).split(""String_Node_Str"");
            OfflinePlayer d=plugin.getServer().getOfflinePlayer(plyer[0]);
            if (d.isBanned()) {
              if (plyer[1].equals(""String_Node_Str"")) {
                d.setBanned(false);
              }
            }
 else {
              if (plyer[1].equals(""String_Node_Str"")) {
                d.setBanned(true);
              }
            }
          }
        }
      }
      if (plugin.lastID == 0) {
        if (response.has(""String_Node_Str"")) {
          plugin.timeRecieved=response.getLong(""String_Node_Str"");
        }
      }
      if (response.has(""String_Node_Str"")) {
        plugin.lastID=response.getLong(""String_Node_Str"");
      }
      goNext=response.has(""String_Node_Str"");
    }
 catch (    JSONException e) {
      if (plugin.getConfigs().isDebug()) {
        e.printStackTrace();
      }
    }
catch (    NullPointerException e) {
      if (plugin.getConfigs().isDebug()) {
        e.printStackTrace();
      }
    }
    if (plugin.lastID == startID) {
      f++;
    }
 else {
      f=1;
    }
    if (f > 5) {
      goNext=false;
    }
    try {
      Thread.sleep(500);
    }
 catch (    InterruptedException ignore) {
    }
  }
  plugin.syncRunning=false;
  Util.message(commandSend,ChatColor.GREEN + ""String_Node_Str"");
  this.save();
}","@Override public void run(){
  if (plugin.syncRunning) {
    Util.message(commandSend,ChatColor.GREEN + ""String_Node_Str"");
    return;
  }
  plugin.syncRunning=true;
  try {
    boolean goNext=true;
    int f=1;
    plugin.last_req=0;
    plugin.lastID=0;
    plugin.timeRecieved=0;
    while (goNext) {
      long startID=plugin.lastID;
      JsonHandler webHandle=new JsonHandler(plugin);
      HashMap<String,String> url_items=new HashMap<String,String>();
      url_items.put(""String_Node_Str"",String.valueOf(plugin.lastID));
      url_items.put(""String_Node_Str"",String.valueOf(plugin.timeRecieved));
      url_items.put(""String_Node_Str"",""String_Node_Str"");
      JSONObject response=webHandle.hdl_jobj(url_items);
      try {
        if (response.has(""String_Node_Str"")) {
          if (response.getJSONArray(""String_Node_Str"").length() > 0) {
            for (int v=0; v < response.getJSONArray(""String_Node_Str"").length(); v++) {
              String[] plyer=response.getJSONArray(""String_Node_Str"").getString(v).split(""String_Node_Str"");
              OfflinePlayer d=plugin.getServer().getOfflinePlayer(plyer[0]);
              if (d.isBanned()) {
                if (plyer[1].equals(""String_Node_Str"")) {
                  d.setBanned(false);
                }
              }
 else {
                if (plyer[1].equals(""String_Node_Str"")) {
                  d.setBanned(true);
                }
              }
            }
          }
        }
        if (plugin.lastID == 0) {
          if (response.has(""String_Node_Str"")) {
            plugin.timeRecieved=response.getLong(""String_Node_Str"");
          }
        }
        if (response.has(""String_Node_Str"")) {
          plugin.lastID=response.getLong(""String_Node_Str"");
        }
        goNext=response.has(""String_Node_Str"");
      }
 catch (      JSONException e) {
        if (plugin.getConfigs().isDebug()) {
          e.printStackTrace();
        }
      }
catch (      NullPointerException e) {
        if (plugin.getConfigs().isDebug()) {
          e.printStackTrace();
        }
      }
      if (plugin.lastID == startID) {
        f++;
      }
 else {
        f=1;
      }
      if (f > 5) {
        goNext=false;
      }
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException ignore) {
      }
    }
  }
  finally {
    plugin.syncRunning=false;
  }
  Util.message(commandSend,ChatColor.GREEN + ""String_Node_Str"");
  this.save();
}"
18031,"public void tempBan(){
  PlayerTempBanEvent tBanEvent=new PlayerTempBanEvent(playerName,playerIP,senderName,reason,duration,measure);
  plugin.getServer().getPluginManager().callEvent(tBanEvent);
  if (tBanEvent.isCancelled()) {
    return;
  }
  senderName=tBanEvent.getSenderName();
  reason=tBanEvent.getReason();
  duration=tBanEvent.getDuration();
  measure=tBanEvent.getMeasure();
  JsonHandler webHandle=new JsonHandler(plugin);
  HashMap<String,String> url_items=new HashMap<String,String>();
  url_items.put(""String_Node_Str"",playerName);
  url_items.put(""String_Node_Str"",playerIP);
  url_items.put(""String_Node_Str"",reason);
  url_items.put(""String_Node_Str"",senderName);
  url_items.put(""String_Node_Str"",duration);
  url_items.put(""String_Node_Str"",measure);
  if (actionData != null) {
    url_items.put(""String_Node_Str"",actionData.toString());
  }
  url_items.put(""String_Node_Str"",""String_Node_Str"");
  HashMap<String,String> response=webHandle.mainRequest(url_items);
  try {
    if (response.containsKey(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + ""String_Node_Str"" + response.get(""String_Node_Str""));
      return;
    }
    if (!response.containsKey(""String_Node_Str"")) {
      bukkitBan();
      return;
    }
    if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      this.kickPlayer(playerName,_(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
      Util.broadcastMessage(ChatColor.GREEN + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
      plugin.getServer().getPluginManager().callEvent(new PlayerBannedEvent(playerName,playerIP,senderName,reason,action_id,duration,measure));
      log.info(playerName + ""String_Node_Str"" + reason+ ""String_Node_Str""+ senderName+ ""String_Node_Str"");
      return;
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
    }
    log.info(senderName + ""String_Node_Str"" + playerName+ ""String_Node_Str""+ reason+ ""String_Node_Str"");
  }
 catch (  Exception ex) {
    bukkitBan();
    log.warning(""String_Node_Str"");
    ex.printStackTrace();
  }
}","public void tempBan(){
  PlayerTempBanEvent tBanEvent=new PlayerTempBanEvent(playerName,playerIP,senderName,reason,duration,measure);
  plugin.getServer().getPluginManager().callEvent(tBanEvent);
  if (tBanEvent.isCancelled()) {
    return;
  }
  senderName=tBanEvent.getSenderName();
  reason=tBanEvent.getReason();
  duration=tBanEvent.getDuration();
  measure=tBanEvent.getMeasure();
  JsonHandler webHandle=new JsonHandler(plugin);
  HashMap<String,String> url_items=new HashMap<String,String>();
  url_items.put(""String_Node_Str"",playerName);
  url_items.put(""String_Node_Str"",playerIP);
  url_items.put(""String_Node_Str"",reason);
  url_items.put(""String_Node_Str"",senderName);
  url_items.put(""String_Node_Str"",duration);
  url_items.put(""String_Node_Str"",measure);
  if (actionData != null) {
    url_items.put(""String_Node_Str"",actionData.toString());
  }
  url_items.put(""String_Node_Str"",""String_Node_Str"");
  HashMap<String,String> response=webHandle.mainRequest(url_items);
  try {
    if (response.containsKey(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + ""String_Node_Str"" + response.get(""String_Node_Str""));
      return;
    }
    if (!response.containsKey(""String_Node_Str"")) {
      bukkitBan();
      return;
    }
    if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      this.kickPlayer(playerName,_(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
      Util.broadcastMessage(ChatColor.GREEN + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
      plugin.getServer().getPluginManager().callEvent(new PlayerBannedEvent(playerName,playerIP,senderName,reason,action_id,duration,measure));
      log.info(playerName + ""String_Node_Str"" + reason+ ""String_Node_Str""+ senderName+ ""String_Node_Str"");
      return;
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      if (response.get(""String_Node_Str"") != null) {
        Util.message(senderName,ChatColor.DARK_RED + response.get(""String_Node_Str""));
      }
 else {
        Util.message(senderName,ChatColor.DARK_RED + _(""String_Node_Str"",I18n.PLAYER,playerName,I18n.SENDER,senderName,I18n.REASON,reason,I18n.PLAYERIP,playerIP));
      }
    }
    log.info(senderName + ""String_Node_Str"" + playerName+ ""String_Node_Str""+ reason+ ""String_Node_Str"");
  }
 catch (  Exception ex) {
    bukkitBan();
    log.warning(""String_Node_Str"");
    ex.printStackTrace();
  }
}"
18032,"public static MCBansAPI getHandle(final MCBans plugin,final Plugin otherPlugin){
  if (otherPlugin == null)   return null;
  MCBansAPI api=apiHandles.get(plugin);
  if (api == null) {
    api=new MCBansAPI(plugin,otherPlugin.getName());
    apiHandles.put(plugin,api);
  }
  return api;
}","public static MCBansAPI getHandle(final MCBans plugin,final Plugin otherPlugin){
  if (otherPlugin == null)   return null;
  MCBansAPI api=apiHandles.get(otherPlugin);
  if (api == null) {
    api=new MCBansAPI(plugin,otherPlugin.getName());
    apiHandles.put(otherPlugin,api);
  }
  return api;
}"
18033,"public boolean run(final BukkitInterface plugin,final CommandSender sender,final String cmd,final String[] preArgs){
  if (name == null) {
    plugin.broadcastPlayer(sender,""String_Node_Str"");
    return true;
  }
  this.plugin=plugin;
  this.config=plugin.settings;
  this.sender=sender;
  this.command=cmd;
  args.clear();
  for (  String arg : preArgs)   args.add(arg);
  if (argLength > args.size()) {
    plugin.broadcastPlayer(sender,ChatColor.DARK_RED + plugin.language.getFormat(""String_Node_Str""));
    return true;
  }
  if (bePlayer && !(sender instanceof Player)) {
    plugin.broadcastPlayer(sender,""String_Node_Str"");
    return true;
  }
  if (sender instanceof Player) {
    player=(Player)sender;
    senderName=player.getName();
    isPlayer=true;
  }
  if (!permission(sender)) {
    plugin.broadcastPlayer(sender,plugin.language.getFormat(""String_Node_Str""));
    return true;
  }
  if (banning && args.size() > 0) {
    target=args.get(0).trim();
    final Player targetPlayer=Bukkit.getPlayerExact(target);
    if (targetPlayer != null && targetPlayer.isOnline()) {
      targetIP=targetPlayer.getAddress().getAddress().getHostAddress();
    }
  }
  try {
    execute();
  }
 catch (  CommandException ex) {
    Throwable error=ex;
    while (error instanceof Exception) {
      plugin.broadcastPlayer(sender,error.getMessage());
      error=error.getCause();
    }
  }
  return true;
}","public boolean run(final BukkitInterface plugin,final CommandSender sender,final String cmd,final String[] preArgs){
  if (name == null) {
    plugin.broadcastPlayer(sender,""String_Node_Str"");
    return true;
  }
  init();
  this.plugin=plugin;
  this.config=plugin.settings;
  this.sender=sender;
  this.command=cmd;
  for (  String arg : preArgs)   args.add(arg);
  if (argLength > args.size()) {
    plugin.broadcastPlayer(sender,ChatColor.DARK_RED + plugin.language.getFormat(""String_Node_Str""));
    return true;
  }
  if (bePlayer && !(sender instanceof Player)) {
    plugin.broadcastPlayer(sender,""String_Node_Str"");
    return true;
  }
  if (sender instanceof Player) {
    player=(Player)sender;
    senderName=player.getName();
    isPlayer=true;
  }
  if (!permission(sender)) {
    plugin.broadcastPlayer(sender,plugin.language.getFormat(""String_Node_Str""));
    return true;
  }
  if (banning && args.size() > 0) {
    target=args.get(0).trim();
    final Player targetPlayer=Bukkit.getPlayerExact(target);
    if (targetPlayer != null && targetPlayer.isOnline()) {
      targetIP=targetPlayer.getAddress().getAddress().getHostAddress();
    }
  }
  try {
    execute();
  }
 catch (  CommandException ex) {
    Throwable error=ex;
    while (error instanceof Exception) {
      plugin.broadcastPlayer(sender,error.getMessage());
      error=error.getCause();
    }
  }
  return true;
}"
18034,"private static void extractLanguageFile(final String locale,final File langDir,final boolean force){
  FileStructure.extractResource(""String_Node_Str"" + locale,langDir,force,true);
}","private static void extractLanguageFile(final String locale,final File langDir,final boolean force){
  FileStructure.extractResource(""String_Node_Str"" + locale + ""String_Node_Str"",langDir,force,true);
}"
18035,"/** 
 * Setup and select rollback method
 * @return true if integration plugin found
 */
public boolean setupHandler(){
  PluginManager pm=plugin.getServer().getPluginManager();
  Plugin check=pm.getPlugin(""String_Node_Str"");
  if (check != null) {
    logblock=(LogBlock)check;
    method=RollbackMethod.LOGBLOCK;
    plugin.log(LogLevels.INFO,""String_Node_Str"");
    return true;
  }
  check=pm.getPlugin(""String_Node_Str"");
  if (check != null) {
    hawkeye=(HawkEye)check;
    method=RollbackMethod.HAWKEYE;
    plugin.log(LogLevels.INFO,""String_Node_Str"");
    return true;
  }
  method=null;
  return false;
}","/** 
 * Setup and select rollback method
 * @return true if integration plugin found
 */
public boolean setupHandler(){
  PluginManager pm=plugin.getServer().getPluginManager();
  Plugin checkLb=pm.getPlugin(""String_Node_Str"");
  if (checkLb != null && checkLb.isEnabled()) {
    method=new LbRollback(plugin);
    plugin.log(LogLevels.INFO,""String_Node_Str"");
    return true;
  }
  Plugin checkHe=pm.getPlugin(""String_Node_Str"");
  if (checkHe != null && checkHe.isEnabled()) {
    method=new HeRollback(plugin);
    plugin.log(LogLevels.INFO,""String_Node_Str"");
    return true;
  }
  plugin.log(LogLevels.INFO,""String_Node_Str"");
  method=null;
  return false;
}"
18036,"/** 
 * Rollback with detected rollback method
 */
public boolean rollback(final String admin,final String target,final int time){
  if (method == null) {
    return false;
  }
  worlds=plugin.Settings.getString(""String_Node_Str"").split(""String_Node_Str"");
  CommandSender sender=plugin.getServer().getPlayer(admin);
  if (sender == null)   sender=plugin.getServer().getPlayer(target);
  if (sender == null)   sender=plugin.getServer().getConsoleSender();
switch (method) {
case LOGBLOCK:
    return rb_logblock(sender,admin,target,time);
case HAWKEYE:
  return rb_hawkeye(sender,admin,target);
}
return false;
}","/** 
 * Rollback with detected rollback method
 */
public boolean rollback(final String admin,final String target,final int time){
  if (method == null) {
    return false;
  }
  CommandSender sender=plugin.getServer().getPlayer(admin);
  if (sender == null)   sender=plugin.getServer().getPlayer(target);
  if (sender == null)   sender=plugin.getServer().getConsoleSender();
  return method.rollback(sender,admin,target,time);
}"
18037,"public void globalBan(){
  jsonHandler webHandle=new jsonHandler(MCBans);
  HashMap<String,String> url_items=new HashMap<String,String>();
  url_items.put(""String_Node_Str"",PlayerName);
  url_items.put(""String_Node_Str"",PlayerIP);
  url_items.put(""String_Node_Str"",Reason);
  url_items.put(""String_Node_Str"",PlayerAdmin);
  url_items.put(""String_Node_Str"",""String_Node_Str"");
  HashMap<String,String> response=webHandle.mainRequest(url_items);
  try {
    if (!response.containsKey(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
      return;
    }
    if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.log.write(PlayerName + ""String_Node_Str"" + Reason+ ""String_Node_Str""+ PlayerAdmin+ ""String_Node_Str"");
      if (MCBans.getServer().getPlayer(PlayerName) != null) {
        MCBans.getServer().getPlayer(PlayerName).kickPlayer(MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
      }
      MCBans.broadcastAll(ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
      MCBans.Backup.add(PlayerName);
      return;
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
    MCBans.log.write(PlayerAdmin + ""String_Node_Str"" + PlayerName+ ""String_Node_Str""+ Reason+ ""String_Node_Str"");
  }
 catch (  NullPointerException e) {
  }
}","public void globalBan(){
  jsonHandler webHandle=new jsonHandler(MCBans);
  HashMap<String,String> url_items=new HashMap<String,String>();
  url_items.put(""String_Node_Str"",PlayerName);
  url_items.put(""String_Node_Str"",PlayerIP);
  url_items.put(""String_Node_Str"",Reason);
  url_items.put(""String_Node_Str"",PlayerAdmin);
  url_items.put(""String_Node_Str"",""String_Node_Str"");
  HashMap<String,String> response=webHandle.mainRequest(url_items);
  try {
    if (!response.containsKey(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
      return;
    }
    if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.log.write(PlayerName + ""String_Node_Str"" + Reason+ ""String_Node_Str""+ PlayerAdmin+ ""String_Node_Str"");
      if (MCBans.getServer().getPlayer(PlayerName) != null) {
        MCBans.getServer().getPlayer(PlayerName).kickPlayer(MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
      }
      MCBans.broadcastAll(ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
      MCBans.Backup.add(PlayerName);
      return;
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
 else     if (response.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      MCBans.broadcastPlayer(PlayerAdmin,ChatColor.DARK_RED + MCBans.Language.getFormat(""String_Node_Str"",PlayerName,PlayerAdmin,Reason,PlayerIP));
    }
    MCBans.log.write(PlayerAdmin + ""String_Node_Str"" + PlayerName+ ""String_Node_Str""+ Reason+ ""String_Node_Str"");
  }
 catch (  NullPointerException e) {
  }
}"
18038,"public Media getMedia(long mediaId){
  return get(buildUri(MEDIA_ENDPOINT + Long.toString(mediaId) + ""String_Node_Str""),Media.class);
}","public Media getMedia(long mediaId){
  return get(buildUri(MEDIA_ENDPOINT + Long.toString(mediaId) + ""String_Node_Str""),MediaContainer.class).getMedia();
}"
18039,"public InstagramProfile getUser(long userId){
  return get(buildUri(USERS_ENDPOINT + Long.toString(userId) + ""String_Node_Str""),InstagramProfile.class);
}","public InstagramProfile getUser(long userId){
  return get(buildUri(USERS_ENDPOINT + Long.toString(userId) + ""String_Node_Str""),InstagramProfileContainer.class).getProfile();
}"
18040,"@Test public void getMedia(){
  mockServer.expect(requestTo(""String_Node_Str"")).andExpect(method(GET)).andRespond(withResponse(new ClassPathResource(""String_Node_Str"",getClass()),responseHeaders));
  Media media=instagram.mediaOperations().getMedia(48904105);
  mockServer.verify();
}","@Test public void getMedia(){
  mockServer.expect(requestTo(""String_Node_Str"")).andExpect(method(GET)).andRespond(withResponse(new ClassPathResource(""String_Node_Str"",getClass()),responseHeaders));
  Media media=instagram.mediaOperations().getMedia(48904105);
  assertEquals(48904105,media.getId());
  mockServer.verify();
}"
18041,"@Test public void getUser(){
  mockServer.expect(requestTo(""String_Node_Str"")).andExpect(method(GET)).andRespond(withResponse(new ClassPathResource(""String_Node_Str"",getClass()),responseHeaders));
  InstagramProfile user=instagram.userOperations().getUser();
  mockServer.verify();
}","@Test public void getUser(){
  mockServer.expect(requestTo(""String_Node_Str"")).andExpect(method(GET)).andRespond(withResponse(new ClassPathResource(""String_Node_Str"",getClass()),responseHeaders));
  InstagramProfile user=instagram.userOperations().getUser();
  assertEquals(""String_Node_Str"",user.getUsername());
  mockServer.verify();
}"
18042,"@Test public void getSpecificUser(){
  mockServer.expect(requestTo(""String_Node_Str"")).andExpect(method(GET)).andRespond(withResponse(new ClassPathResource(""String_Node_Str"",getClass()),responseHeaders));
  InstagramProfile user=instagram.userOperations().getUser(12345);
  mockServer.verify();
}","@Test public void getSpecificUser(){
  mockServer.expect(requestTo(""String_Node_Str"")).andExpect(method(GET)).andRespond(withResponse(new ClassPathResource(""String_Node_Str"",getClass()),responseHeaders));
  InstagramProfile user=instagram.userOperations().getUser(12345);
  assertEquals(""String_Node_Str"",user.getUsername());
  mockServer.verify();
}"
18043,"@Override protected void doWakefulWork(Intent intent){
  context=getApplicationContext();
  new Thread(this).start();
}","@Override protected void doWakefulWork(Intent intent){
  context=getApplicationContext();
  if (!intent.getBooleanExtra(""String_Node_Str"",false))   new Thread(this).start();
}"
18044,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  bindService();
  bindList();
}","@Override public void onCreate(Bundle savedInstanceState){
  activity=this;
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  bindService();
  bindList();
}"
18045,"@Override public void onReceive(Context context,Intent intent){
  Bundle extras=intent.getExtras();
  boolean success=extras.getBoolean(WebService.EXTRAS_SUCCESS,false);
  String message=extras.getString(WebService.EXTRAS_RESPONSE_MESSAGE);
  if (message == null)   message=""String_Node_Str"";
  if (success) {
    try {
      loadData();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
  }
  if (dialog != null && dialog.isShowing())   dialog.dismiss();
}","@Override public void onReceive(Context context,Intent intent){
  Bundle extras=intent.getExtras();
  boolean success=extras.getBoolean(WebService.EXTRAS_SUCCESS,false);
  String message=extras.getString(WebService.EXTRAS_RESPONSE_MESSAGE);
  if (message == null)   message=""String_Node_Str"";
  if (success) {
    try {
      loadData();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else {
    AlertDialog.Builder builder=new AlertDialog.Builder(activity);
    builder.setMessage(message).setCancelable(false).setNeutralButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialog,      int id){
        dialog.cancel();
      }
    }
);
    final AlertDialog alert=builder.create();
  }
  if (dialog != null && dialog.isShowing())   dialog.dismiss();
}"
18046,"@Override public void onPause(){
  super.onPause();
  mLocalActivityManager.dispatchResume();
}","@Override public void onPause(){
  super.onPause();
  mLocalActivityManager.dispatchPause(getActivity().isFinishing());
}"
18047,"@Override public boolean onQueryTextSubmit(String query){
  return false;
}","@Override public boolean onQueryTextSubmit(String query){
  Log.e(""String_Node_Str"",query);
  return false;
}"
18048,"private void addCompatSearch(Menu menu){
  MenuItem item=menu.add(""String_Node_Str"");
  item.setIcon(android.R.drawable.ic_menu_search);
  item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
  SearchView sv=new SearchView(this);
  sv.setQuery(""String_Node_Str"",false);
  sv.setOnQueryTextListener(this);
  item.setActionView(sv);
}","private void addCompatSearch(Menu menu){
  MenuItem item=menu.add(""String_Node_Str"");
  item.setIcon(android.R.drawable.ic_menu_search);
  item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
  SearchView sv=new SearchView(this);
  sv.setQuery(""String_Node_Str"",false);
  sv.setOnQueryTextListener(this);
  sv.setSubmitButtonEnabled(true);
  sv.setQueryHint(""String_Node_Str"");
  item.setActionView(sv);
}"
18049,"@Override public boolean onQueryTextChange(String newText){
  return false;
}","@Override public boolean onQueryTextChange(String newText){
  Log.e(""String_Node_Str"",newText);
  return false;
}"
18050,"public static final double[] inv(double[] x){
  double[] z=new double[2];
  if (x[1] != 0.0) {
    double scalar;
    if (Math.abs(x[0]) >= Math.abs(z[1])) {
      scalar=1.0 / (x[0] + x[1] * (x[1] / x[0]));
      z[0]=scalar;
      z[1]=scalar * (-x[1] / x[0]);
    }
 else {
      scalar=1.0 / (x[0] * (x[0] / x[1]) + x[1]);
      z[0]=scalar * (x[0] / x[1]);
      z[1]=-scalar;
    }
  }
 else {
    z[0]=1 / x[0];
    z[1]=0;
  }
  return z;
}","public static final double[] inv(double[] x){
  double[] z=new double[2];
  if (x[1] != 0.0) {
    double scalar;
    if (Math.abs(x[0]) >= Math.abs(x[1])) {
      scalar=1.0 / (x[0] + x[1] * (x[1] / x[0]));
      z[0]=scalar;
      z[1]=scalar * (-x[1] / x[0]);
    }
 else {
      scalar=1.0 / (x[0] * (x[0] / x[1]) + x[1]);
      z[0]=scalar * (x[0] / x[1]);
      z[1]=-scalar;
    }
  }
 else {
    z[0]=1 / x[0];
    z[1]=0;
  }
  return z;
}"
18051,"public static final float[] inv(float[] x){
  float[] z=new float[2];
  if (x[1] != 0.0) {
    float scalar;
    if (Math.abs(x[0]) >= Math.abs(z[1])) {
      scalar=(float)(1.0 / (x[0] + x[1] * (x[1] / x[0])));
      z[0]=scalar;
      z[1]=scalar * (-x[1] / x[0]);
    }
 else {
      scalar=(float)(1.0 / (x[0] * (x[0] / x[1]) + x[1]));
      z[0]=scalar * (x[0] / x[1]);
      z[1]=-scalar;
    }
  }
 else {
    z[0]=1 / x[0];
    z[1]=0;
  }
  return z;
}","public static final float[] inv(float[] x){
  float[] z=new float[2];
  if (x[1] != 0.0) {
    float scalar;
    if (Math.abs(x[0]) >= Math.abs(x[1])) {
      scalar=(float)(1.0 / (x[0] + x[1] * (x[1] / x[0])));
      z[0]=scalar;
      z[1]=scalar * (-x[1] / x[0]);
    }
 else {
      scalar=(float)(1.0 / (x[0] * (x[0] / x[1]) + x[1]));
      z[0]=scalar * (x[0] / x[1]);
      z[1]=-scalar;
    }
  }
 else {
    z[0]=1 / x[0];
    z[1]=0;
  }
  return z;
}"
18052,"public void initializeProvider() throws InitializationFailedException {
  try {
    client=ModelControllerClient.Factory.create(InetAddress.getLocalHost(),9999);
  }
 catch (  Exception e) {
    throw new InitializationFailedException();
  }
catch (  NoClassDefFoundError e) {
    throw new InitializationFailedException();
  }
}","public void initializeProvider() throws InitializationFailedException {
  try {
    client=ModelControllerClient.Factory.create(""String_Node_Str"",9999);
  }
 catch (  Exception e) {
    throw new InitializationFailedException();
  }
catch (  NoClassDefFoundError e) {
    throw new InitializationFailedException();
  }
}"
18053,"@Override public void encodeEnd(FacesContext context) throws IOException {
  ResponseWriter writer=context.getResponseWriter();
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",this.getClientId(context),null);
  writer.writeAttribute(""String_Node_Str"",this.getStyleClass(),null);
  writer.writeAttribute(""String_Node_Str"",this.getStyle(),null);
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",new StringBuffer().append(""String_Node_Str"").append(this.getSourceType()),null);
  renderContent(context);
  writer.endElement(""String_Node_Str"");
  JSFunction function=new JSFunction(""String_Node_Str"");
  writer.startElement(""String_Node_Str"",null);
  writer.write(""String_Node_Str"" + this.getClientId(context).replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(function.toScript());
  writer.endElement(""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
}","@Override public void encodeEnd(FacesContext context) throws IOException {
  ResponseWriter writer=context.getResponseWriter();
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",this.getClientId(context),null);
  writer.writeAttribute(""String_Node_Str"",this.getStyleClass(),null);
  writer.writeAttribute(""String_Node_Str"",this.getStyle(),null);
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",new StringBuffer().append(""String_Node_Str"").append(this.getSourceType()),null);
  renderContent(context);
  writer.endElement(""String_Node_Str"");
  JSFunction function=new JSFunction(""String_Node_Str"");
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.write(""String_Node_Str"" + this.getClientId(context).replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(function.toScript());
  writer.endElement(""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
}"
18054,"@Override public void onPageStarted(WebView view,String url,Bitmap favicon){
  try {
    URI uri=new URI(url);
    String[] segments=uri.getPath().split(""String_Node_Str"");
    String filename=segments[segments.length - 1];
    if (filename.contains(""String_Node_Str"")) {
      currentPage=Integer.parseInt(filename.substring(0,filename.indexOf(""String_Node_Str"")));
    }
 else {
      currentPage=Integer.parseInt(filename.substring(0,filename.indexOf(""String_Node_Str"")));
    }
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
  System.out.println(currentPage + ""String_Node_Str"" + url);
}","@Override public void onPageStarted(WebView view,String url,Bitmap favicon){
  try {
    URI uri=new URI(url);
    String[] segments=uri.getPath().split(""String_Node_Str"");
    String filename=segments[segments.length - 1];
    currentPage=htmlMap.get(filename);
  }
 catch (  URISyntaxException e) {
    e.printStackTrace();
  }
  System.out.println(currentPage + ""String_Node_Str"" + url);
}"
18055,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(final Bundle savedInstanceState){
  System.out.println(""String_Node_Str"");
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  htmlFiles=loadBook();
  totalPages=htmlFiles.size();
  webView=(WebView)findViewById(R.id.webview);
  webView.setWebViewClient(new FriarWebViewClient());
  webView.getSettings().setJavaScriptEnabled(false);
  gestureDetector=new GestureDetector(gestureListener);
  webView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View wv,    MotionEvent event){
      gestureDetector.onTouchEvent(event);
      return false;
    }
  }
);
  webView.loadUrl(BASE_URL + htmlFiles.get(currentPage));
  System.out.println(BASE_URL + htmlFiles.get(currentPage));
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(final Bundle savedInstanceState){
  System.out.println(""String_Node_Str"");
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  htmlFiles=loadBook();
  totalPages=htmlFiles.size();
  int count=0;
  for (  String filename : htmlFiles) {
    htmlMap.put(filename,count++);
  }
  webView=(WebView)findViewById(R.id.webview);
  webView.setWebViewClient(new FriarWebViewClient());
  webView.getSettings().setJavaScriptEnabled(false);
  gestureDetector=new GestureDetector(gestureListener);
  webView.setOnTouchListener(new View.OnTouchListener(){
    public boolean onTouch(    View wv,    MotionEvent event){
      gestureDetector.onTouchEvent(event);
      return false;
    }
  }
);
  webView.loadUrl(BASE_URL + htmlFiles.get(currentPage));
  System.out.println(BASE_URL + htmlFiles.get(currentPage));
}"
18056,"private List<String> loadBook(){
  List<String> htmlFiles=new ArrayList<String>();
  try {
    String[] files=getAssets().list(""String_Node_Str"");
    for (    String file : files) {
      if (file.endsWith(""String_Node_Str"")) {
        htmlFiles.add(file);
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  Collections.sort(htmlFiles,new AlphanumComparator());
  return htmlFiles;
}","private List<String> loadBook(){
  try {
    String[] files=getAssets().list(""String_Node_Str"");
    for (    String file : files) {
      if (file.endsWith(""String_Node_Str"")) {
        htmlFiles.add(file);
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  Collections.sort(htmlFiles,new AlphanumComparator());
  return htmlFiles;
}"
18057,"@Override public boolean onFling(MotionEvent e1,MotionEvent e2,float velocityX,float velocityY){
  final float xDistance=Math.abs(e1.getX() - e2.getX());
  final float yDistance=Math.abs(e1.getY() - e2.getY());
  if (xDistance > this.SWIPE_MAX_DISTANCE || yDistance > this.SWIPE_MAX_DISTANCE) {
    return false;
  }
  velocityX=Math.abs(velocityX);
  velocityY=Math.abs(velocityY);
  if (velocityX > this.SWIPE_MIN_VELOCITY && xDistance > this.SWIPE_MIN_DISTANCE) {
    if (e1.getX() > e2.getX()) {
      if (currentPage + 1 > totalPages) {
        showToast(""String_Node_Str"");
      }
 else {
        showUrl(++currentPage);
        return true;
      }
    }
 else {
      if (currentPage - 1 < 0) {
        showToast(""String_Node_Str"");
      }
 else {
        showUrl(--currentPage);
        return true;
      }
    }
  }
  return false;
}","@Override public boolean onFling(MotionEvent e1,MotionEvent e2,float velocityX,float velocityY){
  final float xDistance=Math.abs(e1.getX() - e2.getX());
  final float yDistance=Math.abs(e1.getY() - e2.getY());
  if (xDistance > this.SWIPE_MAX_DISTANCE || yDistance > this.SWIPE_MAX_DISTANCE) {
    return false;
  }
  velocityX=Math.abs(velocityX);
  velocityY=Math.abs(velocityY);
  if (velocityX > this.SWIPE_MIN_VELOCITY && xDistance > this.SWIPE_MIN_DISTANCE) {
    if (e1.getX() > e2.getX()) {
      if (currentPage + 1 >= totalPages) {
        showToast(""String_Node_Str"");
      }
 else {
        showUrl(++currentPage);
        return true;
      }
    }
 else {
      if (currentPage - 1 < 0) {
        showToast(""String_Node_Str"");
      }
 else {
        showUrl(--currentPage);
        return true;
      }
    }
  }
  return false;
}"
18058,"private ProcessDescriptor(Configuration config,int localId){
  this.localId=localId;
  this.config=config;
  this.numReplicas=config.getN();
  this.windowSize=config.getIntProperty(WINDOW_SIZE,DEFAULT_WINDOW_SIZE);
  this.batchingLevel=config.getIntProperty(BATCH_SIZE,DEFAULT_BATCH_SIZE);
  this.maxUdpPacketSize=config.getIntProperty(MAX_UDP_PACKET_SIZE,DEFAULT_MAX_UDP_PACKET_SIZE);
  this.maxBatchDelay=config.getIntProperty(MAX_BATCH_DELAY,DEFAULT_MAX_BATCH_DELAY);
  this.clientIDGenerator=config.getProperty(CLIENT_ID_GENERATOR,DEFAULT_CLIENT_ID_GENERATOR);
  this.network=config.getProperty(NETWORK,DEFAULT_NETWORK);
  this.logPath=config.getProperty(LOG_PATH,DEFAULT_LOG_PATH);
  this.firstSnapshotSizeEstimate=config.getIntProperty(FIRST_SNAPSHOT_SIZE_ESTIMATE,DEFAULT_FIRST_SNAPSHOT_SIZE_ESTIMATE);
  this.snapshotMinLogSize=Math.max(1,config.getIntProperty(SNAPSHOT_MIN_LOG_SIZE,DEFAULT_SNAPSHOT_MIN_LOG_SIZE));
  this.snapshotAskRatio=config.getDoubleProperty(SNAPSHOT_ASK_RATIO,DEFAULT_SNAPSHOT_ASK_RATIO);
  this.snapshotForceRatio=config.getDoubleProperty(SNAPSHOT_FORCE_RATIO,DEFAULT_SNAPSHOT_FORCE_RATIO);
  this.minSnapshotSampling=config.getIntProperty(MIN_SNAPSHOT_SAMPLING,DEFAULT_MIN_SNAPSHOT_SAMPLING);
  this.retransmitTimeout=config.getLongProperty(RETRANSMIT_TIMEOUT,DEFAULT_RETRANSMIT_TIMEOUT);
  this.tcpReconnectTimeout=config.getLongProperty(TCP_RECONNECT_TIMEOUT,DEFAULT_TCP_RECONNECT_TIMEOUT);
  this.fdSuspectTimeout=config.getIntProperty(FD_SUSPECT_TO,DEFAULT_FD_SUSPECT_TO);
  this.fdSendTimeout=config.getIntProperty(FD_SEND_TO,DEFAULT_FD_SEND_TO);
  this.forwardBatchMaxDelay=config.getIntProperty(FORWARD_MAX_BATCH_DELAY,DEFAULT_FORWARD_MAX_BATCH_DELAY);
  this.forwardBatchMaxSize=config.getIntProperty(FORWARD_MAX_BATCH_SIZE,DEFAULT_FORWARD_MAX_BATCH_SIZE);
  this.selectorThreadCount=config.getIntProperty(SELECTOR_THREADS,DEFAULT_SELECTOR_THREADS);
  this.clientRequestBufferSize=config.getIntProperty(CLIENT_REQUEST_BUFFER_SIZE,DEFAULT_CLIENT_REQUEST_BUFFER_SIZE);
  this.maxBatchFetchingTimeoutMs=config.getIntProperty(MAX_BATCH_FETCHING_TIME_MS,DEFAULT_MAX_BATCH_FETCHING_TIME_MS);
  this.multicastPort=config.getIntProperty(MULTICAST_PORT,DEFAULT_MULTICAST_PORT);
  this.multicastIpAddress=config.getProperty(MULTICAST_IP_ADDRESS,DEFAULT_MULTICAST_IP_ADDRESS);
  this.mtu=config.getIntProperty(MTU,DEFAULT_MTU);
  this.indirectConsensus=config.getBooleanProperty(INDIRECT_CONSENSUS,DEFAULT_INDIRECT_CONSENSUS);
  this.augmentedPaxos=config.getBooleanProperty(AUGMENTED_PAXOS,DEFAULT_AUGMENTED_PAXOS);
  String crash=config.getProperty(CRASH_MODEL,DEFAULT_CRASH_MODEL.toString());
  CrashModel crashModel;
  try {
    crashModel=CrashModel.valueOf(crash);
  }
 catch (  IllegalArgumentException e) {
    throw new RuntimeException(""String_Node_Str"" + crash + ""String_Node_Str"");
  }
  this.crashModel=crashModel;
  majority=(numReplicas + 1) / 2;
  printProcessDescriptor(config,crashModel);
}","private ProcessDescriptor(Configuration config,int localId){
  this.localId=localId;
  this.config=config;
  this.numReplicas=config.getN();
  this.windowSize=config.getIntProperty(WINDOW_SIZE,DEFAULT_WINDOW_SIZE);
  this.batchingLevel=config.getIntProperty(BATCH_SIZE,DEFAULT_BATCH_SIZE);
  this.maxUdpPacketSize=config.getIntProperty(MAX_UDP_PACKET_SIZE,DEFAULT_MAX_UDP_PACKET_SIZE);
  this.maxBatchDelay=config.getIntProperty(MAX_BATCH_DELAY,DEFAULT_MAX_BATCH_DELAY);
  this.clientIDGenerator=config.getProperty(CLIENT_ID_GENERATOR,DEFAULT_CLIENT_ID_GENERATOR);
  this.network=config.getProperty(NETWORK,DEFAULT_NETWORK);
  this.logPath=config.getProperty(LOG_PATH,DEFAULT_LOG_PATH);
  this.firstSnapshotSizeEstimate=config.getIntProperty(FIRST_SNAPSHOT_SIZE_ESTIMATE,DEFAULT_FIRST_SNAPSHOT_SIZE_ESTIMATE);
  this.snapshotMinLogSize=Math.max(1,config.getIntProperty(SNAPSHOT_MIN_LOG_SIZE,DEFAULT_SNAPSHOT_MIN_LOG_SIZE));
  this.snapshotAskRatio=config.getDoubleProperty(SNAPSHOT_ASK_RATIO,DEFAULT_SNAPSHOT_ASK_RATIO);
  this.snapshotForceRatio=config.getDoubleProperty(SNAPSHOT_FORCE_RATIO,DEFAULT_SNAPSHOT_FORCE_RATIO);
  this.minSnapshotSampling=config.getIntProperty(MIN_SNAPSHOT_SAMPLING,DEFAULT_MIN_SNAPSHOT_SAMPLING);
  this.retransmitTimeout=config.getLongProperty(RETRANSMIT_TIMEOUT,DEFAULT_RETRANSMIT_TIMEOUT);
  this.tcpReconnectTimeout=config.getLongProperty(TCP_RECONNECT_TIMEOUT,DEFAULT_TCP_RECONNECT_TIMEOUT);
  this.fdSuspectTimeout=config.getIntProperty(FD_SUSPECT_TO,DEFAULT_FD_SUSPECT_TO);
  this.fdSendTimeout=config.getIntProperty(FD_SEND_TO,DEFAULT_FD_SEND_TO);
  this.forwardBatchMaxDelay=config.getIntProperty(FORWARD_MAX_BATCH_DELAY,DEFAULT_FORWARD_MAX_BATCH_DELAY);
  this.forwardBatchMaxSize=config.getIntProperty(FORWARD_MAX_BATCH_SIZE,DEFAULT_FORWARD_MAX_BATCH_SIZE);
  this.selectorThreadCount=config.getIntProperty(SELECTOR_THREADS,DEFAULT_SELECTOR_THREADS);
  this.clientRequestBufferSize=config.getIntProperty(CLIENT_REQUEST_BUFFER_SIZE,DEFAULT_CLIENT_REQUEST_BUFFER_SIZE);
  this.maxBatchFetchingTimeoutMs=config.getIntProperty(MAX_BATCH_FETCHING_TIME_MS,DEFAULT_MAX_BATCH_FETCHING_TIME_MS);
  this.multicastPort=config.getIntProperty(MULTICAST_PORT,DEFAULT_MULTICAST_PORT);
  this.multicastIpAddress=config.getProperty(MULTICAST_IP_ADDRESS,DEFAULT_MULTICAST_IP_ADDRESS);
  this.mtu=config.getIntProperty(MTU,DEFAULT_MTU);
  this.indirectConsensus=config.getBooleanProperty(INDIRECT_CONSENSUS,DEFAULT_INDIRECT_CONSENSUS);
  this.augmentedPaxos=config.getBooleanProperty(AUGMENTED_PAXOS,DEFAULT_AUGMENTED_PAXOS);
  String crash=config.getProperty(CRASH_MODEL,DEFAULT_CRASH_MODEL.toString());
  CrashModel crashModel;
  try {
    crashModel=CrashModel.valueOf(crash);
  }
 catch (  IllegalArgumentException e) {
    throw new RuntimeException(""String_Node_Str"" + crash + ""String_Node_Str"");
  }
  this.crashModel=crashModel;
  majority=(numReplicas + 1) / 2;
  printProcessDescriptor(config,crashModel);
  logMark_Benchmark.add(logMark_OldBenchmark);
}"
18059,"private void onClientRequest(ClientRequest request,ClientProxy client) throws InterruptedException {
  RequestId reqId=request.getRequestId();
  Reply lastReply=lastReplies.get(reqId.getClientId());
  boolean newRequest=lastReply == null || reqId.getSeqNumber() > lastReply.getRequestId().getSeqNumber();
  if (newRequest) {
    logger.debug(processDescriptor.logMark_OldBenchmark,""String_Node_Str"",request);
    if (USE_FLOW_CONTROL)     if (!pendingClientProxies.containsKey(reqId))     pendingRequestsSem.acquire();
    if (client != null)     pendingClientProxies.put(reqId,client);
 else     if (USE_FLOW_CONTROL)     pendingClientProxies.put(reqId,NULL_CLIENT_PROXY);
    if (paxos.isLeader()) {
      paxos.enqueueRequest(request);
    }
 else {
      cBatcher.enqueueRequest(request);
    }
  }
 else {
    if (client == null)     return;
    if (lastReply.getRequestId().equals(reqId)) {
      client.send(new ClientReply(Result.OK,lastReply.toByteArray()));
    }
 else {
      String errorMsg=""String_Node_Str"" + request.getRequestId() + ""String_Node_Str""+ lastReply.getRequestId();
      logger.error(errorMsg);
      client.send(new ClientReply(Result.NACK,errorMsg.getBytes()));
    }
  }
}","private void onClientRequest(ClientRequest request,ClientProxy client) throws InterruptedException {
  RequestId reqId=request.getRequestId();
  Reply lastReply=lastReplies.get(reqId.getClientId());
  boolean newRequest=lastReply == null || reqId.getSeqNumber() > lastReply.getRequestId().getSeqNumber();
  if (newRequest) {
    logger.debug(processDescriptor.logMark_OldBenchmark,""String_Node_Str"",request);
    if (USE_FLOW_CONTROL)     if (!pendingClientProxies.containsKey(reqId))     pendingRequestsSem.acquire();
    if (client != null)     pendingClientProxies.put(reqId,client);
 else     if (USE_FLOW_CONTROL)     pendingClientProxies.put(reqId,NULL_CLIENT_PROXY);
    if (!processDescriptor.indirectConsensus && paxos.isLeader()) {
      paxos.enqueueRequest(request);
    }
 else {
      cBatcher.enqueueRequest(request);
    }
  }
 else {
    if (client == null)     return;
    if (lastReply.getRequestId().equals(reqId)) {
      client.send(new ClientReply(Result.OK,lastReply.toByteArray()));
    }
 else {
      String errorMsg=""String_Node_Str"" + request.getRequestId() + ""String_Node_Str""+ lastReply.getRequestId();
      logger.error(errorMsg);
      client.send(new ClientReply(Result.NACK,errorMsg.getBytes()));
    }
  }
}"
18060,"public EchoService(){
  super();
  random=new Random(System.currentTimeMillis() + this.hashCode());
}","public EchoService(){
  super();
  random=new Random(System.currentTimeMillis() + this.hashCode());
  Executors.newSingleThreadScheduledExecutor(new ThreadFactory(){
    public Thread newThread(    Runnable r){
      Thread thread=new Thread(r,""String_Node_Str"");
      thread.setDaemon(true);
      return thread;
    }
  }
).scheduleAtFixedRate(new Runnable(){
    private int lastSeenSeqNo=0;
    public void run(){
      int lastSeqNoSnapshot=lastSeqNo;
      logger.info(ProcessDescriptor.processDescriptor.logMark_Benchmark,""String_Node_Str"",(lastSeqNoSnapshot - lastSeenSeqNo) * (1000 / SAMPLING_MS));
      lastSeenSeqNo=lastSeqNoSnapshot;
    }
  }
,SAMPLING_MS,SAMPLING_MS,TimeUnit.MILLISECONDS);
}"
18061,"public byte[] execute(byte[] value,int seqNo){
  logger.info(""String_Node_Str"",seqNo);
  if (random.nextInt(10) == 0) {
    assert(last != null);
    fireSnapshotMade(seqNo + 1,new byte[]{1},value);
    logger.info(""String_Node_Str"");
  }
  last=value;
  if (seqNo % 10000 == 0) {
    long now=System.currentTimeMillis();
    System.err.println(""String_Node_Str"" + (10000.0 * 1000) / (now - lastTs));
    lastTs=now;
  }
  return value;
}","public byte[] execute(byte[] value,int seqNo){
  logger.info(""String_Node_Str"",seqNo);
  if (random.nextInt(10000) == 0) {
    assert(last != null);
    fireSnapshotMade(seqNo + 1,new byte[]{1},value);
    logger.info(""String_Node_Str"");
  }
  last=value;
  lastSeqNo=seqNo;
  return value;
}"
18062,"public Thread newThread(Runnable r){
  lastCreatedThread=new Thread(r,name);
  return lastCreatedThread;
}","public Thread newThread(Runnable r){
}"
18063,"public void run(){
  logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
  Storage storage=paxos.getStorage();
  if (storage.getEpoch()[sender] > recovery.getEpoch()) {
    logger.info(""String_Node_Str"",sender,recovery);
    return;
  }
  if (paxos.getLeaderId() == sender) {
    paxos.getProposer().prepareNextView();
    onMessageReceived(recovery,sender);
    return;
  }
  if (paxos.isLeader() && paxos.getProposer().getState() == ProposerState.PREPARING) {
    paxos.getProposer().executeOnPrepared(new Proposer.Task(){
      public void onPrepared(){
        onMessageReceived(recovery,sender);
      }
      public void onFailedToPrepare(){
        onMessageReceived(recovery,sender);
      }
    }
);
    return;
  }
  storage.updateEpoch(recovery.getEpoch(),sender);
  RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getEpoch(),storage.getLog().getNextId());
  paxos.getNetwork().sendMessage(answer,sender);
}","public void run(){
  Storage storage=paxos.getStorage();
  if (storage.getEpoch()[sender] > recovery.getEpoch()) {
    logger.info(""String_Node_Str"",sender,recovery);
    return;
  }
  if (paxos.getLeaderId() == sender) {
    logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
    paxos.getProposer().prepareNextView();
    onMessageReceived(recovery,sender);
    return;
  }
  logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
  if (paxos.isLeader() && paxos.getProposer().getState() == ProposerState.PREPARING) {
    paxos.getProposer().executeOnPrepared(new Proposer.Task(){
      public void onPrepared(){
        onMessageReceived(recovery,sender);
      }
      public void onFailedToPrepare(){
        onMessageReceived(recovery,sender);
      }
    }
);
    return;
  }
  storage.updateEpoch(recovery.getEpoch(),sender);
  RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getEpoch(),storage.getLog().getNextId());
  paxos.getNetwork().sendMessage(answer,sender);
}"
18064,"public void onMessageReceived(Message message,final int sender){
  final Recovery recovery=(Recovery)message;
  paxos.getDispatcher().submit(new Runnable(){
    public void run(){
      logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
      Storage storage=paxos.getStorage();
      if (storage.getEpoch()[sender] > recovery.getEpoch()) {
        logger.info(""String_Node_Str"",sender,recovery);
        return;
      }
      if (paxos.getLeaderId() == sender) {
        paxos.getProposer().prepareNextView();
        onMessageReceived(recovery,sender);
        return;
      }
      if (paxos.isLeader() && paxos.getProposer().getState() == ProposerState.PREPARING) {
        paxos.getProposer().executeOnPrepared(new Proposer.Task(){
          public void onPrepared(){
            onMessageReceived(recovery,sender);
          }
          public void onFailedToPrepare(){
            onMessageReceived(recovery,sender);
          }
        }
);
        return;
      }
      storage.updateEpoch(recovery.getEpoch(),sender);
      RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getEpoch(),storage.getLog().getNextId());
      paxos.getNetwork().sendMessage(answer,sender);
    }
  }
);
}","public void onMessageReceived(Message message,final int sender){
  final Recovery recovery=(Recovery)message;
  paxos.getDispatcher().submit(new Runnable(){
    public void run(){
      Storage storage=paxos.getStorage();
      if (storage.getEpoch()[sender] > recovery.getEpoch()) {
        logger.info(""String_Node_Str"",sender,recovery);
        return;
      }
      if (paxos.getLeaderId() == sender) {
        logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
        paxos.getProposer().prepareNextView();
        onMessageReceived(recovery,sender);
        return;
      }
      logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
      if (paxos.isLeader() && paxos.getProposer().getState() == ProposerState.PREPARING) {
        paxos.getProposer().executeOnPrepared(new Proposer.Task(){
          public void onPrepared(){
            onMessageReceived(recovery,sender);
          }
          public void onFailedToPrepare(){
            onMessageReceived(recovery,sender);
          }
        }
);
        return;
      }
      storage.updateEpoch(recovery.getEpoch(),sender);
      RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getEpoch(),storage.getLog().getNextId());
      paxos.getNetwork().sendMessage(answer,sender);
    }
  }
);
}"
18065,"public void run(){
  logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
  Storage storage=paxos.getStorage();
  Proposer proposer=paxos.getProposer();
  if (paxos.getLeaderId() == sender || recovery.getView() >= storage.getView()) {
    if (proposer.getState() != ProposerState.INACTIVE)     proposer.stopProposer();
    proposer.prepareNextView();
    onMessageReceived(recovery,sender);
    return;
  }
  if (paxos.isLeader() && proposer.getState() == ProposerState.PREPARING) {
    proposer.executeOnPrepared(new Proposer.Task(){
      public void onPrepared(){
        onMessageReceived(recovery,sender);
      }
      public void onFailedToPrepare(){
        onMessageReceived(recovery,sender);
      }
    }
);
    return;
  }
  RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getLog().getNextId());
  paxos.getNetwork().sendMessage(answer,sender);
}","public void run(){
  Storage storage=paxos.getStorage();
  Proposer proposer=paxos.getProposer();
  if (paxos.getLeaderId() == sender || recovery.getView() >= storage.getView()) {
    logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
    if (proposer.getState() != ProposerState.INACTIVE)     proposer.stopProposer();
    proposer.prepareNextView();
    onMessageReceived(recovery,sender);
    return;
  }
  if (paxos.isLeader() && proposer.getState() == ProposerState.PREPARING) {
    logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
    proposer.executeOnPrepared(new Proposer.Task(){
      public void onPrepared(){
        onMessageReceived(recovery,sender);
      }
      public void onFailedToPrepare(){
        onMessageReceived(recovery,sender);
      }
    }
);
    return;
  }
  logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
  RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getLog().getNextId());
  paxos.getNetwork().sendMessage(answer,sender);
}"
18066,"public void onMessageReceived(Message msg,final int sender){
  final Recovery recovery=(Recovery)msg;
  paxos.getDispatcher().submit(new Runnable(){
    public void run(){
      logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
      Storage storage=paxos.getStorage();
      Proposer proposer=paxos.getProposer();
      if (paxos.getLeaderId() == sender || recovery.getView() >= storage.getView()) {
        if (proposer.getState() != ProposerState.INACTIVE)         proposer.stopProposer();
        proposer.prepareNextView();
        onMessageReceived(recovery,sender);
        return;
      }
      if (paxos.isLeader() && proposer.getState() == ProposerState.PREPARING) {
        proposer.executeOnPrepared(new Proposer.Task(){
          public void onPrepared(){
            onMessageReceived(recovery,sender);
          }
          public void onFailedToPrepare(){
            onMessageReceived(recovery,sender);
          }
        }
);
        return;
      }
      RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getLog().getNextId());
      paxos.getNetwork().sendMessage(answer,sender);
    }
  }
);
}","public void onMessageReceived(Message msg,final int sender){
  final Recovery recovery=(Recovery)msg;
  paxos.getDispatcher().submit(new Runnable(){
    public void run(){
      Storage storage=paxos.getStorage();
      Proposer proposer=paxos.getProposer();
      if (paxos.getLeaderId() == sender || recovery.getView() >= storage.getView()) {
        logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
        if (proposer.getState() != ProposerState.INACTIVE)         proposer.stopProposer();
        proposer.prepareNextView();
        onMessageReceived(recovery,sender);
        return;
      }
      if (paxos.isLeader() && proposer.getState() == ProposerState.PREPARING) {
        logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
        proposer.executeOnPrepared(new Proposer.Task(){
          public void onPrepared(){
            onMessageReceived(recovery,sender);
          }
          public void onFailedToPrepare(){
            onMessageReceived(recovery,sender);
          }
        }
);
        return;
      }
      logger.info(processDescriptor.logMark_Benchmark,""String_Node_Str"",recovery);
      RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getLog().getNextId());
      paxos.getNetwork().sendMessage(answer,sender);
    }
  }
);
}"
18067,"private void finished(){
  ScheduledFuture<?> sf=taskToFuture.remove(this);
  sf.cancel(false);
  dispatcher.remove(this);
  dispatcher.purge();
  if (hook != null)   hook.hook();
}","private void finished(){
  ScheduledFuture<?> sf=taskToFuture.remove(this);
  if (sf != null)   sf.cancel(false);
  dispatcher.remove(this);
  dispatcher.purge();
  if (hook != null)   hook.hook();
}"
18068,"public ClientThread() throws IOException {
  setDaemon(true);
  client=new Client();
  sends=new ArrayBlockingQueue<Integer>(128);
  request=new byte[requestSize];
}","public ClientThread() throws IOException {
  setDaemon(true);
  client=new Client(configuration);
  sends=new ArrayBlockingQueue<Integer>(128);
  request=new byte[requestSize];
}"
18069,"public GenericMultiClient(int requestSize,boolean randomRequests){
  this.requestSize=requestSize;
  this.randomRequests=randomRequests;
}","public GenericMultiClient(int requestSize,boolean randomRequests) throws IOException {
  this.configuration=new Configuration();
  this.requestSize=requestSize;
  this.randomRequests=randomRequests;
}"
18070,"/** 
 * Creates a new TCP connection to specified replica.
 * @param network - related <code>TcpNetwork</code>.
 * @param replica - replica to connect to.
 * @param peerId - ID of the replica on the other end of connection
 * @param active - initiates connection if true; waits for remote connectionotherwise.
 */
public TcpConnection(TcpNetwork network,final PID replica,int peerId,boolean active){
  this.network=network;
  this.replica=replica;
  this.peerId=peerId;
  this.active=active;
  logger.info(""String_Node_Str"",replica,active);
  receiverThread=new Thread(new ReceiverThread(),""String_Node_Str"" + replica.getId());
  senderThread=new Thread(new Sender(),""String_Node_Str"" + replica.getId());
  receiverThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
  senderThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
  receiverThread.setDaemon(true);
  senderThread.setDaemon(true);
}","/** 
 * Creates a new TCP connection to specified replica.
 * @param network - related <code>TcpNetwork</code>.
 * @param replica - replica to connect to.
 * @param peerId - ID of the replica on the other end of connection
 * @param active - initiates connection if true; waits for remote connectionotherwise.
 */
public TcpConnection(TcpNetwork network,final PID replica,int peerId,boolean active){
  this.network=network;
  this.replica=replica;
  this.peerId=peerId;
  this.active=active;
  logger.info(""String_Node_Str"",replica,active);
  receiverThread=new Thread(new ReceiverThread(),""String_Node_Str"" + replica.getId());
  senderThread=new Thread(new Sender(),""String_Node_Str"" + replica.getId());
  receiverThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
  senderThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
  receiverThread.setDaemon(true);
  senderThread.setDaemon(true);
  senderThread.setPriority(Thread.MAX_PRIORITY);
}"
18071,"/** 
 * Sends specified binary packet using underlying TCP connection.
 * @param message - binary packet to send
 * @return true if sending message was successful
 */
public void send(byte[] message){
  try {
    if (connected) {
      long start=System.currentTimeMillis();
      sendQueue.put(message);
      int delta=(int)(System.currentTimeMillis() - start);
      if (delta > 10) {
        logger.warn(""String_Node_Str"",delta);
      }
    }
 else {
      while (!sendQueue.offer(message)) {
        sendQueue.poll();
      }
    }
  }
 catch (  InterruptedException e) {
    if (!closing) {
      throw new RuntimeException(""String_Node_Str"",e);
    }
  }
}","/** 
 * Sends specified binary packet using underlying TCP connection.
 * @param message - binary packet to send
 * @return true if sending message was successful
 */
public void send(byte[] message){
  if (connected) {
    if (sendQueue.remainingCapacity() == 0)     Thread.yield();
    while (!sendQueue.offer(message)) {
      byte[] discarded=sendQueue.poll();
      logger.warn(""String_Node_Str"",discarded,message);
    }
  }
 else {
    while (!sendQueue.offer(message)) {
      sendQueue.poll();
    }
  }
}"
18072,"private void onClientRequest(ClientRequest request,ClientProxy client) throws InterruptedException {
  RequestId reqId=request.getRequestId();
  Reply lastReply=lastReplies.get(reqId.getClientId());
  boolean newRequest=lastReply == null || reqId.getSeqNumber() > lastReply.getRequestId().getSeqNumber();
  if (newRequest) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(""String_Node_Str"" + request);
    }
    if (USE_FLOW_CONTROL)     if (!pendingClientProxies.containsKey(reqId))     pendingRequestsSem.acquire();
    if (client != null)     pendingClientProxies.put(reqId,client);
 else     if (USE_FLOW_CONTROL)     pendingClientProxies.put(reqId,NULL_CLIENT_PROXY);
    if (!processDescriptor.indirectConsensus && paxos.isLeader()) {
      paxos.enqueueRequest(request);
    }
 else {
      cBatcher.enqueueRequest(request);
    }
  }
 else {
    if (client == null)     return;
    if (lastReply.getRequestId().equals(reqId)) {
      client.send(new ClientReply(Result.OK,lastReply.toByteArray()));
    }
 else {
      String errorMsg=""String_Node_Str"" + request.getRequestId() + ""String_Node_Str""+ lastReply.getRequestId();
      logger.warning(errorMsg);
      client.send(new ClientReply(Result.NACK,errorMsg.getBytes()));
    }
  }
}","private void onClientRequest(ClientRequest request,ClientProxy client) throws InterruptedException {
  RequestId reqId=request.getRequestId();
  Reply lastReply=lastReplies.get(reqId.getClientId());
  boolean newRequest=lastReply == null || reqId.getSeqNumber() > lastReply.getRequestId().getSeqNumber();
  if (newRequest) {
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(""String_Node_Str"" + request);
    }
    if (USE_FLOW_CONTROL)     if (!pendingClientProxies.containsKey(reqId))     pendingRequestsSem.acquire();
    if (client != null)     pendingClientProxies.put(reqId,client);
 else     if (USE_FLOW_CONTROL)     pendingClientProxies.put(reqId,NULL_CLIENT_PROXY);
    if (paxos.isLeader()) {
      paxos.enqueueRequest(request);
    }
 else {
      cBatcher.enqueueRequest(request);
    }
  }
 else {
    if (client == null)     return;
    if (lastReply.getRequestId().equals(reqId)) {
      client.send(new ClientReply(Result.OK,lastReply.toByteArray()));
    }
 else {
      String errorMsg=""String_Node_Str"" + request.getRequestId() + ""String_Node_Str""+ lastReply.getRequestId();
      logger.warning(errorMsg);
      client.send(new ClientReply(Result.NACK,errorMsg.getBytes()));
    }
  }
}"
18073,"/** 
 * Scheadules a task to be executed as soon as the proposer is prepared
 */
public void executeOnPrepared(final Runnable task);","/** 
 * Schedules a task to be executed as soon as the proposer is prepared
 */
public void executeOnPrepared(final Task task);"
18074,"public void executeOnPrepared(final Runnable task){
}","public void executeOnPrepared(final Task task){
}"
18075,"public void run(){
  onMessageReceived(recovery,sender);
}","@Override public void run(){
  onMessageReceived(recovery,sender);
}"
18076,"public void onMessageReceived(Message msg,final int sender){
  final Recovery recovery=(Recovery)msg;
  paxos.getDispatcher().submit(new Runnable(){
    public void run(){
      logger.info(""String_Node_Str"" + recovery);
      if (paxos.getLeaderId() == sender) {
        paxos.suspect(paxos.getLeaderId());
        return;
      }
      if (paxos.isLeader() && paxos.getProposer().getState() == ProposerState.PREPARING) {
        paxos.getProposer().executeOnPrepared(new Runnable(){
          public void run(){
            onMessageReceived(recovery,sender);
          }
        }
);
        return;
      }
      Storage storage=paxos.getStorage();
      if (recovery.getView() >= storage.getView()) {
        int newView=recovery.getView() + 1;
        if (processDescriptor.isLocalProcessLeader(newView)) {
          newView++;
        }
        paxos.advanceView(newView);
        paxos.suspect(newView);
        onMessageReceived(recovery,sender);
        return;
      }
      RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getLog().getNextId());
      paxos.getNetwork().sendMessage(answer,sender);
    }
  }
);
}","public void onMessageReceived(Message msg,final int sender){
  final Recovery recovery=(Recovery)msg;
  paxos.getDispatcher().submit(new Runnable(){
    public void run(){
      logger.info(""String_Node_Str"" + recovery);
      if (paxos.getLeaderId() == sender) {
        paxos.suspect(paxos.getLeaderId());
        paxos.getDispatcher().schedule(new Runnable(){
          @Override public void run(){
            onMessageReceived(recovery,sender);
          }
        }
,1,TimeUnit.MILLISECONDS);
        return;
      }
      if (paxos.isLeader() && paxos.getProposer().getState() == ProposerState.PREPARING) {
        paxos.getProposer().executeOnPrepared(new Proposer.Task(){
          public void onPrepared(){
            onMessageReceived(recovery,sender);
          }
          public void onFailedToPrepare(){
            onMessageReceived(recovery,sender);
          }
        }
);
        return;
      }
      Storage storage=paxos.getStorage();
      if (recovery.getView() >= storage.getView()) {
        int newView=recovery.getView() + 1;
        if (processDescriptor.isLocalProcessLeader(newView)) {
          newView++;
        }
        paxos.advanceView(newView);
        paxos.suspect(newView);
        onMessageReceived(recovery,sender);
        return;
      }
      RecoveryAnswer answer=new RecoveryAnswer(storage.getView(),storage.getLog().getNextId());
      paxos.getNetwork().sendMessage(answer,sender);
    }
  }
);
}"
18077,"public InternalClient(SingleThreadDispatcher replicaDispatcher,ClientRequestManager clientRequestManager){
  this.replicaDispatcher=replicaDispatcher;
  this.clientRequestManager=clientRequestManager;
}","public InternalClient(SingleThreadDispatcher replicaDispatcher,ClientRequestManager clientRequestManager){
  internalClientDispatcher=new SingleThreadDispatcher(""String_Node_Str"");
  this.clientRequestManager=clientRequestManager;
}"
18078,"/** 
 * @throws InterruptedException in case the replica has been interruptedwhile waiting to put the request on propose queue
 */
public void executeNonFifo(byte[] request){
  RequestId reqId=freeIds.poll();
  if (reqId == null)   reqId=new RequestId(NioClientProxy.idGenerator.next(),0);
  ClientRequest cr=new ClientRequest(reqId,request);
  ClientCommand cc=new ClientCommand(CommandType.REQUEST,cr);
  InternalClientProxy icp=new InternalClientProxy(reqId);
  RequestRepeater rr=new RequestRepeater(cc,icp);
  icp.setRepeater(rr,replicaDispatcher.schedule(rr,(long)(3 * averageRequestTime.get()),TimeUnit.MILLISECONDS));
  if (logger.isLoggable(Level.FINE))   logger.fine(""String_Node_Str"" + reqId);
  clientRequestManager.dispatchOnClientRequest(cc,icp);
}","/** 
 * @throws InterruptedException in case the replica has been interruptedwhile waiting to put the request on propose queue
 */
public void executeNonFifo(final byte[] request){
  internalClientDispatcher.execute(new Runnable(){
    public void run(){
      executeNonFifoInternal(request);
    }
  }
);
}"
18079,"public void run(){
  if (!shouldRepeat())   return;
  if (logger.isLoggable(Level.FINE))   logger.fine(""String_Node_Str"" + cc.getRequest().getRequestId());
  icp.setRepeater(this,replicaDispatcher.schedule(this,(long)(3 * averageRequestTime.get()),TimeUnit.MILLISECONDS));
  clientRequestManager.dispatchOnClientRequest(cc,icp);
}","public void run(){
  internalClientDispatcher.checkInDispatcher();
  if (!shouldRepeat())   return;
  if (logger.isLoggable(Level.FINER))   logger.finer(""String_Node_Str"" + cc.getRequest().getRequestId());
  icp.sf=internalClientDispatcher.schedule(this,(long)(3 * averageRequestTime.get()),TimeUnit.MILLISECONDS);
  clientRequestManager.dispatchOnClientRequest(cc,icp);
}"
18080,"/** 
 * Called upon generating the answer for previous request 
 */
public void send(ClientReply clientReply){
  if (logger.isLoggable(Level.FINE))   logger.fine(""String_Node_Str"" + cliId + ""String_Node_Str""+ seqNo);
  averageRequestTime.add(System.currentTimeMillis() - startTime);
  freeIds.add(new RequestId(cliId,seqNo + 1));
  replicaDispatcher.remove(repeater);
  sf.cancel(false);
}","/** 
 * Called upon generating the answer for previous request 
 */
public void send(ClientReply clientReply){
}"
18081,"protected final void onValueChange(){
  for (  ClientBatchID cbid : Batcher.unpack(value)) {
    ClientBatchStore.instance.associateWithInstance(cbid);
  }
}","protected final void onValueChange(){
  if (value == null)   return;
  for (  ClientBatchID cbid : Batcher.unpack(value)) {
    ClientBatchStore.instance.associateWithInstance(cbid);
  }
}"
18082,"/** 
 * Sets new value holding by this instance. Each value has view in which it is valid, so it has to be set here also.
 * @param view - the view number in which value is valid
 * @param value - the value which was accepted by this instance
 */
private void setValue(int view,byte[] value){
}","/** 
 * Sets new value holding by this instance. Each value has view in which it is valid, so it has to be set here also.
 * @param view - the view number in which value is valid
 * @param value - the value which was accepted by this instance
 */
protected void setValue(int view,byte[] value){
}"
18083,"/** 
 * Handles exceptions thrown by the executed tasks. Kills the process on exception as tasks shouldn't throw exceptions under normal conditions.
 */
protected void afterExecute(Runnable r,Throwable t){
}","/** 
 * Handles exceptions thrown by the executed tasks. Kills the process on exception as tasks shouldn't throw exceptions under normal conditions.
 */
protected void afterExecute(Runnable r,Throwable t){
  super.afterExecute(r,t);
  if (t == null && r instanceof FutureTask<?>) {
    FutureTask<?> fTask=(FutureTask<?>)r;
    if (!fTask.isDone()) {
      return;
    }
 else {
      try {
        fTask.get(0,TimeUnit.MILLISECONDS);
      }
 catch (      CancellationException ce) {
        logger.info(""String_Node_Str"" + r);
      }
catch (      ExecutionException ee) {
        t=ee.getCause();
      }
catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
catch (      TimeoutException e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + r,e);
      }
    }
  }
  if (t != null) {
    if (printErrorsToConsole) {
      t.printStackTrace();
      printErrorsToConsole=false;
    }
    logger.log(Level.SEVERE,""String_Node_Str"",t);
  }
}"
18084,"public void start(){
  latch.countDown();
}","public void start(){
}"
18085,"public void startProposing(){
  final Set<ClientBatchID> decided=new HashSet<ClientBatchID>();
  final Set<ClientBatchID> known=new HashSet<ClientBatchID>();
  Storage storage=paxos.getStorage();
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(""String_Node_Str"" + storage.getFirstUncommitted() + ""String_Node_Str""+ storage.getLog().getNextId());
  }
  for (int i=storage.getFirstUncommitted(); i < storage.getLog().getNextId(); i++) {
    ConsensusInstance ci=storage.getLog().getInstance(i);
    if (ci.getValue() != null) {
      Deque<ClientBatch> reqs=batcher.unpack(ci.getValue());
switch (ci.getState()) {
case DECIDED:
        for (        ClientBatch replicaRequest : reqs) {
          decided.add(replicaRequest.getRequestId());
        }
      break;
case KNOWN:
    for (    ClientBatch replicaRequest : reqs) {
      known.add(replicaRequest.getRequestId());
    }
  break;
case UNKNOWN:
default :
break;
}
}
}
cliBManagerDispatcher.submit(new Runnable(){
@Override public void run(){
batchStore.onViewChange(known,decided);
batchStore.setProposerActive(true);
}
}
);
}","public void startProposing(final int view){
  final Set<ClientBatchID> decided=new HashSet<ClientBatchID>();
  final Set<ClientBatchID> known=new HashSet<ClientBatchID>();
  Storage storage=paxos.getStorage();
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(""String_Node_Str"" + storage.getFirstUncommitted() + ""String_Node_Str""+ storage.getLog().getNextId());
  }
  for (int i=storage.getFirstUncommitted(); i < storage.getLog().getNextId(); i++) {
    ConsensusInstance ci=storage.getLog().getInstance(i);
    if (ci.getValue() != null) {
      Deque<ClientBatch> reqs=batcher.unpack(ci.getValue());
switch (ci.getState()) {
case DECIDED:
        for (        ClientBatch replicaRequest : reqs) {
          decided.add(replicaRequest.getBatchId());
        }
      break;
case KNOWN:
    for (    ClientBatch replicaRequest : reqs) {
      known.add(replicaRequest.getBatchId());
    }
  break;
case UNKNOWN:
default :
break;
}
}
}
cliBManagerDispatcher.submit(new Runnable(){
@Override public void run(){
batchStore.onViewChange(view,known,decided);
}
}
);
}"
18086,"public void onBatchDecided(final int instance,final Deque<ClientBatch> batch){
  cliBManagerDispatcher.execute(new Runnable(){
    @Override public void run(){
      innerOnBatchDecided(instance,batch);
    }
  }
);
}","public void onBatchDecided(final int instance,final Deque<ClientBatch> batch){
  cliBManagerDispatcher.submit(new Runnable(){
    @Override public void run(){
      innerOnBatchDecided(instance,batch);
    }
  }
);
}"
18087,"public void stopProposing(){
  batchStore.setProposerActive(false);
}","public void stopProposing(){
  cliBManagerDispatcher.submit(new Runnable(){
    @Override public void run(){
      batchStore.stopProposing();
    }
  }
);
}"
18088,"void innerOnBatchDecided(int instance,Deque<ClientBatch> batch){
  if (logger.isLoggable(Level.INFO)) {
    logger.info(""String_Node_Str"" + instance + ""String_Node_Str""+ batch.toString());
  }
  for (  ClientBatch req : batch) {
    ClientBatchID rid=req.getRequestId();
    ClientBatchInfo rInfo=batchStore.getRequestInfo(rid);
    if (rInfo == null) {
      rInfo=batchStore.newRequestInfo(req.getRequestId());
      batchStore.setRequestInfo(rid,rInfo);
    }
    rInfo.state=State.Decided;
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(rInfo.toString());
    }
    if (logger.isLoggable(Level.INFO)) {
      if (rid.replicaID == localId) {
        logger.info(""String_Node_Str"" + rid + ""String_Node_Str""+ (System.currentTimeMillis() - rInfo.timeStamp));
      }
    }
    executionQueue.add(rInfo);
  }
  executionQueue.add(instance);
  executeRequests();
  batchStore.pruneLogs();
}","void innerOnBatchDecided(int instance,Deque<ClientBatch> batch){
  if (logger.isLoggable(Level.INFO)) {
    logger.info(""String_Node_Str"" + instance + ""String_Node_Str""+ batch.toString());
  }
  for (  ClientBatch req : batch) {
    ClientBatchID rid=req.getBatchId();
    if (rid.sn < batchStore.getLowerBound(rid.replicaID)) {
      logger.warning(""String_Node_Str"" + rid);
      continue;
    }
    ClientBatchInfo rInfo=batchStore.getRequestInfo(rid);
    if (rInfo == null) {
      rInfo=batchStore.newRequestInfo(req.getBatchId());
      batchStore.setRequestInfo(rid,rInfo);
    }
 else     if (rInfo.state == BatchState.Decided || rInfo.state == BatchState.Executed) {
      logger.warning(""String_Node_Str"" + rInfo);
      continue;
    }
    rInfo.state=BatchState.Decided;
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(rInfo.toString());
    }
    if (logger.isLoggable(Level.INFO)) {
      if (rid.replicaID == localId) {
        logger.info(""String_Node_Str"" + rid + ""String_Node_Str""+ (System.currentTimeMillis() - rInfo.timeStamp));
      }
    }
    executionQueue.add(rInfo);
  }
  executionQueue.add(instance);
  executeRequests();
  batchStore.pruneLogs();
}"
18089,"@Override public void onMessageReceived(final Message msg,final int sender){
  cliBManagerDispatcher.execute(new Runnable(){
    @Override public void run(){
      try {
        if (msg instanceof ForwardClientBatch) {
          onForwardClientBatch((ForwardClientBatch)msg,sender);
        }
 else         if (msg instanceof AckForwardClientBatch) {
          onAckForwardClientBatch((AckForwardClientBatch)msg,sender);
        }
 else {
          throw new AssertionError(""String_Node_Str"" + msg);
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
);
}","@Override public void onMessageReceived(final Message msg,final int sender){
  cliBManagerDispatcher.submit(new Runnable(){
    @Override public void run(){
      try {
        if (msg instanceof ForwardClientBatch) {
          onForwardClientBatch((ForwardClientBatch)msg,sender);
        }
 else         if (msg instanceof AckForwardClientBatch) {
          onAckForwardClientBatch((AckForwardClientBatch)msg,sender);
        }
 else {
          throw new AssertionError(""String_Node_Str"" + msg);
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
);
}"
18090,"/** 
 * Creates a <code>Message</code> from serialized byte array.
 * @param message - serialized byte array with message content
 * @return deserialized message
 */
public static Message readByteArray(byte[] message){
  DataInputStream input=new DataInputStream(new ByteArrayInputStream(message));
  return create(input);
}","/** 
 * Creates a <code>Message</code> from serialized byte array.
 * @param message - serialized byte array with message content
 * @return deserialized message
 * @throws ClassNotFoundException 
 * @throws IOException 
 */
public static Message readByteArray(byte[] message) throws IOException, ClassNotFoundException {
  DataInputStream input=new DataInputStream(new ByteArrayInputStream(message));
  return create(input);
}"
18091,"/** 
 * Reads byte array and creates message from it. Byte array must have been written by Message::toByteArray().
 * @param input - the input stream with serialized message inside
 * @return correct object from one of message subclasses
 * @throws IllegalArgumentException if a correct message could not be readfrom input
 */
private static Message createMine(DataInputStream input){
  MessageType type;
  Message message;
  try {
    type=MessageType.values()[input.readUnsignedByte()];
    message=createMessage(type,input);
  }
 catch (  EOFException e) {
    throw new IllegalArgumentException(e);
  }
catch (  Exception e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  return message;
}","/** 
 * Reads byte array and creates message from it. Byte array must have been written by Message::toByteArray().
 * @param input - the input stream with serialized message inside
 * @return correct object from one of message subclasses
 * @throws IOException 
 * @throws IllegalArgumentException if a correct message could not be readfrom input
 */
private static Message createMine(DataInputStream input) throws IOException {
  MessageType type=MessageType.values()[input.readUnsignedByte()];
  Message message=createMessage(type,input);
  return message;
}"
18092,"/** 
 * Creates a <code>Message</code> from input stream.
 * @param input - the input stream with serialized message
 * @return deserialized message
 */
public static Message create(DataInputStream input){
  if (Config.JAVA_SERIALIZATION) {
    try {
      return (Message)(new ObjectInputStream(input).readObject());
    }
 catch (    IOException e) {
      throw new IllegalArgumentException(""String_Node_Str"",e);
    }
catch (    ClassNotFoundException e) {
      throw new IllegalArgumentException(""String_Node_Str"",e);
    }
  }
  return createMine(input);
}","/** 
 * Creates a <code>Message</code> from input stream.
 * @param input - the input stream with serialized message
 * @return deserialized message
 */
public static Message create(DataInputStream input) throws IOException, ClassNotFoundException {
  if (Config.JAVA_SERIALIZATION) {
    return (Message)(new ObjectInputStream(input).readObject());
  }
  return createMine(input);
}"
18093,"public void run(){
  while (true) {
    logger.info(""String_Node_Str"" + replica.getId());
    try {
      connect();
    }
 catch (    InterruptedException e) {
      logger.severe(""String_Node_Str"");
      break;
    }
    logger.info(""String_Node_Str"" + replica.getId());
    while (true) {
      if (Thread.interrupted()) {
        logger.severe(""String_Node_Str"");
        close();
        return;
      }
      Message message;
      try {
        message=MessageFactory.create(input);
      }
 catch (      IllegalArgumentException e) {
        logger.log(Level.SEVERE,""String_Node_Str"",e);
        close();
        break;
      }
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + replica.getId() + ""String_Node_Str""+ message+ ""String_Node_Str""+ message.byteSize());
      }
      network.fireReceiveMessage(message,replica.getId());
    }
  }
}","public void run(){
  while (true) {
    logger.info(""String_Node_Str"" + replica.getId());
    try {
      connect();
    }
 catch (    InterruptedException e) {
      logger.severe(""String_Node_Str"");
      break;
    }
    logger.info(""String_Node_Str"" + replica.getId());
    while (true) {
      if (Thread.interrupted()) {
        logger.severe(""String_Node_Str"");
        close();
        return;
      }
      Message message;
      try {
        message=MessageFactory.create(input);
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"",e);
        close();
        break;
      }
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + replica.getId() + ""String_Node_Str""+ message+ ""String_Node_Str""+ message.byteSize());
      }
      network.fireReceiveMessage(message,replica.getId());
    }
  }
}"
18094,"/** 
 * Establishes connection to host specified by this object. If this is active connection then it will try to connect to other side. Otherwise we will wait until connection will be set-up using <code>setConnection</code> method. This method will return only if the connection is established and initialized properly.
 * @throws InterruptedException
 */
private void connect() throws InterruptedException {
  if (active) {
    while (true) {
      try {
        socket=new Socket();
        socket.setReceiveBufferSize(128 * 1024);
        socket.setSendBufferSize(128 * 1024);
        logger.fine(""String_Node_Str"" + socket.getReceiveBufferSize() + ""String_Node_Str""+ socket.getSendBufferSize());
        socket.setTcpNoDelay(true);
        logger.info(""String_Node_Str"" + replica);
        try {
          socket.connect(new InetSocketAddress(replica.getHostname(),replica.getReplicaPort()));
        }
 catch (        ConnectException e) {
          logger.warning(""String_Node_Str"" + replica.getId() + ""String_Node_Str"");
          Thread.sleep(ProcessDescriptor.getInstance().tcpReconnectTimeout);
          continue;
        }
        input=new DataInputStream(new BufferedInputStream(socket.getInputStream()));
        output=new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
        output.writeInt(ProcessDescriptor.getInstance().localId);
        output.flush();
        break;
      }
 catch (      IOException e) {
        logger.log(Level.WARNING,""String_Node_Str"" + replica,e);
      }
      Thread.sleep(ProcessDescriptor.getInstance().tcpReconnectTimeout);
    }
synchronized (this) {
      connected=true;
      notifyAll();
    }
  }
 else {
synchronized (this) {
      while (!connected) {
        wait();
      }
    }
  }
}","/** 
 * Establishes connection to host specified by this object. If this is active connection then it will try to connect to other side. Otherwise we will wait until connection will be set-up using <code>setConnection</code> method. This method will return only if the connection is established and initialized properly.
 * @throws InterruptedException
 */
private void connect() throws InterruptedException {
  if (active) {
    while (true) {
      try {
        socket=new Socket();
        socket.setReceiveBufferSize(128 * 1024);
        socket.setSendBufferSize(128 * 1024);
        logger.fine(""String_Node_Str"" + socket.getReceiveBufferSize() + ""String_Node_Str""+ socket.getSendBufferSize());
        socket.setTcpNoDelay(true);
        logger.info(""String_Node_Str"" + replica);
        try {
          socket.connect(new InetSocketAddress(replica.getHostname(),replica.getReplicaPort()));
        }
 catch (        ConnectException e) {
          logger.warning(""String_Node_Str"" + replica.getId() + ""String_Node_Str"");
          Thread.sleep(ProcessDescriptor.getInstance().tcpReconnectTimeout);
          continue;
        }
        input=new DataInputStream(new BufferedInputStream(socket.getInputStream()));
        output=new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
        output.writeInt(ProcessDescriptor.getInstance().localId);
        output.flush();
        break;
      }
 catch (      IOException e) {
        long sleepTime=ProcessDescriptor.getInstance().tcpReconnectTimeout;
        logger.log(Level.WARNING,""String_Node_Str"" + replica + ""String_Node_Str""+ sleepTime,e);
        Thread.sleep(sleepTime);
      }
    }
synchronized (this) {
      connected=true;
      notifyAll();
    }
  }
 else {
synchronized (this) {
      while (!connected) {
        wait();
      }
    }
  }
}"
18095,"public void run(){
  logger.info(Thread.currentThread().getName() + ""String_Node_Str"");
  try {
    while (true) {
      byte[] buffer=new byte[p.maxUdpPacketSize + 4];
      DatagramPacket dp=new DatagramPacket(buffer,buffer.length);
      datagramSocket.receive(dp);
      ByteArrayInputStream bais=new ByteArrayInputStream(dp.getData(),dp.getOffset(),dp.getLength());
      DataInputStream dis=new DataInputStream(bais);
      int sender=dis.readInt();
      byte[] data=new byte[dp.getLength() - 4];
      dis.read(data);
      Message message=MessageFactory.readByteArray(data);
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + sender + ""String_Node_Str""+ message);
      }
      fireReceiveMessage(message,sender);
    }
  }
 catch (  IOException e) {
    logger.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","public void run(){
  logger.info(Thread.currentThread().getName() + ""String_Node_Str"");
  try {
    while (true) {
      byte[] buffer=new byte[p.maxUdpPacketSize + 4];
      DatagramPacket dp=new DatagramPacket(buffer,buffer.length);
      datagramSocket.receive(dp);
      ByteArrayInputStream bais=new ByteArrayInputStream(dp.getData(),dp.getOffset(),dp.getLength());
      DataInputStream dis=new DataInputStream(bais);
      int sender=dis.readInt();
      byte[] data=new byte[dp.getLength() - 4];
      dis.read(data);
      try {
        Message message=MessageFactory.readByteArray(data);
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + sender + ""String_Node_Str""+ message);
        }
        fireReceiveMessage(message,sender);
      }
 catch (      ClassNotFoundException e) {
        logger.log(Level.WARNING,""String_Node_Str"",e);
      }
    }
  }
 catch (  IOException e) {
    logger.log(Level.SEVERE,""String_Node_Str"",e);
  }
}"
18096,"/** 
 * Starts the replica. <p> First the recovery phase is started and after that the replica joins the Paxos protocol and starts the client manager and the underlying service.
 * @throws IOException if some I/O error occurs
 */
public void start() throws IOException {
  logger.info(""String_Node_Str"");
  RecoveryAlgorithm recovery=createRecoveryAlgorithm(descriptor.crashModel);
  paxos=recovery.getPaxos();
  recovery.addRecoveryListener(new InnerRecoveryListener());
  recovery.start();
}","/** 
 * Starts the replica. <p> First the recovery phase is started and after that the replica joins the Paxos protocol and starts the client manager and the underlying service.
 * @throws IOException if some I/O error occurs
 */
public void start() throws IOException {
  logger.info(""String_Node_Str"");
  RecoveryAlgorithm recovery=createRecoveryAlgorithm(descriptor.crashModel);
  paxos=recovery.getPaxos();
  paxos.getDispatcher().start();
  paxos.getNetwork().start();
  paxos.getCatchup().start();
  recovery.addRecoveryListener(new InnerRecoveryListener());
  recovery.start();
}"
18097,"private ProcessDescriptor(Configuration config,int localId){
  this.localId=localId;
  this.config=config;
  this.numReplicas=config.getN();
  this.windowSize=config.getIntProperty(Config.WINDOW_SIZE,Config.DEFAULT_WINDOW_SIZE);
  this.batchingLevel=config.getIntProperty(Config.BATCH_SIZE,Config.DEFAULT_BATCH_SIZE);
  this.maxUdpPacketSize=config.getIntProperty(Config.MAX_UDP_PACKET_SIZE,Config.DEFAULT_MAX_UDP_PACKET_SIZE);
  this.busyThreshold=config.getIntProperty(Config.BUSY_THRESHOLD,Config.DEFAULT_BUSY_THRESHOLD);
  this.mayShareSnapshots=config.getBooleanProperty(Config.MAY_SHARE_SNAPSHOTS,Config.DEFAULT_MAY_SHARE_SNAPSHOTS);
  this.maxBatchDelay=config.getIntProperty(Config.MAX_BATCH_DELAY,Config.DEFAULT_MAX_BATCH_DELAY);
  this.clientIDGenerator=config.getProperty(Config.CLIENT_ID_GENERATOR,Config.DEFAULT_CLIENT_ID_GENERATOR);
  this.benchmarkRun=config.getBooleanProperty(Config.BENCHMARK_RUN,Config.DEFAULT_BENCHMARK_RUN);
  this.network=config.getProperty(Config.NETWORK,Config.DEFAULT_NETWORK);
  this.logPath=config.getProperty(Config.LOG_PATH,Config.DEFAULT_LOG_PATH);
  String defCrash=Config.DEFAULT_CRASH_MODEL.toString();
  String crash=config.getProperty(Config.CRASH_MODEL,defCrash);
  CrashModel crashModel;
  try {
    crashModel=Replica.CrashModel.valueOf(crash);
  }
 catch (  IllegalArgumentException e) {
    crashModel=Config.DEFAULT_CRASH_MODEL;
    logger.severe(""String_Node_Str"");
    logger.severe(""String_Node_Str"");
    logger.severe(""String_Node_Str"" + crash + ""String_Node_Str"");
    logger.severe(""String_Node_Str"" + crashModel);
    logger.severe(""String_Node_Str"");
    logger.severe(""String_Node_Str"");
  }
  this.crashModel=crashModel;
  this.firstSnapshotSizeEstimate=config.getIntProperty(Config.FIRST_SNAPSHOT_SIZE_ESTIMATE,Config.DEFAULT_FIRST_SNAPSHOT_SIZE_ESTIMATE);
  this.snapshotMinLogSize=config.getIntProperty(Config.SNAPSHOT_MIN_LOG_SIZE,Config.DEFAULT_SNAPSHOT_MIN_LOG_SIZE);
  this.snapshotAskRatio=config.getDoubleProperty(Config.SNAPSHOT_ASK_RATIO,Config.DEFAULT_SNAPSHOT_ASK_RATIO);
  this.snapshotForceRatio=config.getDoubleProperty(Config.SNAPSHOT_FORCE_RATIO,Config.DEFAULT_SNAPSHOT_FORCE_RATIO);
  this.minSnapshotSampling=config.getIntProperty(Config.MIN_SNAPSHOT_SAMPLING,Config.DEFAULT_MIN_SNAPSHOT_SAMPLING);
  this.retransmitTimeout=config.getLongProperty(Config.RETRANSMIT_TIMEOUT,Config.DEFAULT_RETRANSMIT_TIMEOUT);
  this.periodicCatchupTimeout=config.getLongProperty(Config.PERIODIC_CATCHUP_TIMEOUT,Config.DEFAULT_PERIODIC_CATCHUP_TIMEOUT);
  this.tcpReconnectTimeout=config.getLongProperty(Config.TCP_RECONNECT_TIMEOUT,Config.DEFAULT_TCP_RECONNECT_TIMEOUT);
  logger.config(""String_Node_Str"" + Config.WINDOW_SIZE + ""String_Node_Str""+ windowSize+ ""String_Node_Str""+ Config.BATCH_SIZE+ ""String_Node_Str""+ batchingLevel+ ""String_Node_Str""+ Config.MAX_BATCH_DELAY+ ""String_Node_Str""+ maxBatchDelay+ ""String_Node_Str""+ Config.MAX_UDP_PACKET_SIZE+ ""String_Node_Str""+ maxUdpPacketSize+ ""String_Node_Str""+ Config.NETWORK+ ""String_Node_Str""+ network+ ""String_Node_Str""+ Config.BUSY_THRESHOLD+ ""String_Node_Str""+ busyThreshold+ ""String_Node_Str""+ Config.MAY_SHARE_SNAPSHOTS+ ""String_Node_Str""+ mayShareSnapshots+ ""String_Node_Str""+ Config.BENCHMARK_RUN+ ""String_Node_Str""+ benchmarkRun+ ""String_Node_Str""+ Config.CLIENT_ID_GENERATOR+ ""String_Node_Str""+ clientIDGenerator);
  logger.config(""String_Node_Str"" + crashModel + ""String_Node_Str""+ logPath);
  logger.config(Config.FIRST_SNAPSHOT_SIZE_ESTIMATE + ""String_Node_Str"" + firstSnapshotSizeEstimate+ ""String_Node_Str""+ Config.SNAPSHOT_MIN_LOG_SIZE+ ""String_Node_Str""+ snapshotMinLogSize+ ""String_Node_Str""+ Config.SNAPSHOT_ASK_RATIO+ ""String_Node_Str""+ snapshotAskRatio+ ""String_Node_Str""+ Config.SNAPSHOT_FORCE_RATIO+ ""String_Node_Str""+ snapshotForceRatio+ ""String_Node_Str""+ Config.MIN_SNAPSHOT_SAMPLING+ ""String_Node_Str""+ minSnapshotSampling);
  logger.config(Config.RETRANSMIT_TIMEOUT + ""String_Node_Str"" + retransmitTimeout+ ""String_Node_Str""+ Config.PERIODIC_CATCHUP_TIMEOUT+ ""String_Node_Str""+ periodicCatchupTimeout+ ""String_Node_Str""+ Config.TCP_RECONNECT_TIMEOUT+ ""String_Node_Str""+ tcpReconnectTimeout);
}","private ProcessDescriptor(Configuration config,int localId){
  this.localId=localId;
  this.config=config;
  this.numReplicas=config.getN();
  this.windowSize=config.getIntProperty(Config.WINDOW_SIZE,Config.DEFAULT_WINDOW_SIZE);
  this.batchingLevel=config.getIntProperty(Config.BATCH_SIZE,Config.DEFAULT_BATCH_SIZE);
  this.maxUdpPacketSize=config.getIntProperty(Config.MAX_UDP_PACKET_SIZE,Config.DEFAULT_MAX_UDP_PACKET_SIZE);
  this.busyThreshold=config.getIntProperty(Config.BUSY_THRESHOLD,Config.DEFAULT_BUSY_THRESHOLD);
  this.mayShareSnapshots=config.getBooleanProperty(Config.MAY_SHARE_SNAPSHOTS,Config.DEFAULT_MAY_SHARE_SNAPSHOTS);
  this.maxBatchDelay=config.getIntProperty(Config.MAX_BATCH_DELAY,Config.DEFAULT_MAX_BATCH_DELAY);
  this.clientIDGenerator=config.getProperty(Config.CLIENT_ID_GENERATOR,Config.DEFAULT_CLIENT_ID_GENERATOR);
  this.benchmarkRun=config.getBooleanProperty(Config.BENCHMARK_RUN,Config.DEFAULT_BENCHMARK_RUN);
  this.network=config.getProperty(Config.NETWORK,Config.DEFAULT_NETWORK);
  this.logPath=config.getProperty(Config.LOG_PATH,Config.DEFAULT_LOG_PATH);
  String defCrash=Config.DEFAULT_CRASH_MODEL.toString();
  String crash=config.getProperty(Config.CRASH_MODEL,defCrash);
  CrashModel crashModel;
  try {
    crashModel=Replica.CrashModel.valueOf(crash);
  }
 catch (  IllegalArgumentException e) {
    crashModel=Config.DEFAULT_CRASH_MODEL;
    logger.severe(""String_Node_Str"");
    logger.severe(""String_Node_Str"");
    logger.severe(""String_Node_Str"" + crash + ""String_Node_Str"");
    logger.severe(""String_Node_Str"" + crashModel);
    logger.severe(""String_Node_Str"");
    logger.severe(""String_Node_Str"");
  }
  this.crashModel=crashModel;
  this.firstSnapshotSizeEstimate=config.getIntProperty(Config.FIRST_SNAPSHOT_SIZE_ESTIMATE,Config.DEFAULT_FIRST_SNAPSHOT_SIZE_ESTIMATE);
  this.snapshotMinLogSize=Math.max(1,config.getIntProperty(Config.SNAPSHOT_MIN_LOG_SIZE,Config.DEFAULT_SNAPSHOT_MIN_LOG_SIZE));
  this.snapshotAskRatio=config.getDoubleProperty(Config.SNAPSHOT_ASK_RATIO,Config.DEFAULT_SNAPSHOT_ASK_RATIO);
  this.snapshotForceRatio=config.getDoubleProperty(Config.SNAPSHOT_FORCE_RATIO,Config.DEFAULT_SNAPSHOT_FORCE_RATIO);
  this.minSnapshotSampling=config.getIntProperty(Config.MIN_SNAPSHOT_SAMPLING,Config.DEFAULT_MIN_SNAPSHOT_SAMPLING);
  this.retransmitTimeout=config.getLongProperty(Config.RETRANSMIT_TIMEOUT,Config.DEFAULT_RETRANSMIT_TIMEOUT);
  this.periodicCatchupTimeout=config.getLongProperty(Config.PERIODIC_CATCHUP_TIMEOUT,Config.DEFAULT_PERIODIC_CATCHUP_TIMEOUT);
  this.tcpReconnectTimeout=config.getLongProperty(Config.TCP_RECONNECT_TIMEOUT,Config.DEFAULT_TCP_RECONNECT_TIMEOUT);
  logger.config(""String_Node_Str"" + Config.WINDOW_SIZE + ""String_Node_Str""+ windowSize+ ""String_Node_Str""+ Config.BATCH_SIZE+ ""String_Node_Str""+ batchingLevel+ ""String_Node_Str""+ Config.MAX_BATCH_DELAY+ ""String_Node_Str""+ maxBatchDelay+ ""String_Node_Str""+ Config.MAX_UDP_PACKET_SIZE+ ""String_Node_Str""+ maxUdpPacketSize+ ""String_Node_Str""+ Config.NETWORK+ ""String_Node_Str""+ network+ ""String_Node_Str""+ Config.BUSY_THRESHOLD+ ""String_Node_Str""+ busyThreshold+ ""String_Node_Str""+ Config.MAY_SHARE_SNAPSHOTS+ ""String_Node_Str""+ mayShareSnapshots+ ""String_Node_Str""+ Config.BENCHMARK_RUN+ ""String_Node_Str""+ benchmarkRun+ ""String_Node_Str""+ Config.CLIENT_ID_GENERATOR+ ""String_Node_Str""+ clientIDGenerator);
  logger.config(""String_Node_Str"" + crashModel + ""String_Node_Str""+ logPath);
  logger.config(Config.FIRST_SNAPSHOT_SIZE_ESTIMATE + ""String_Node_Str"" + firstSnapshotSizeEstimate+ ""String_Node_Str""+ Config.SNAPSHOT_MIN_LOG_SIZE+ ""String_Node_Str""+ snapshotMinLogSize+ ""String_Node_Str""+ Config.SNAPSHOT_ASK_RATIO+ ""String_Node_Str""+ snapshotAskRatio+ ""String_Node_Str""+ Config.SNAPSHOT_FORCE_RATIO+ ""String_Node_Str""+ snapshotForceRatio+ ""String_Node_Str""+ Config.MIN_SNAPSHOT_SAMPLING+ ""String_Node_Str""+ minSnapshotSampling);
  logger.config(Config.RETRANSMIT_TIMEOUT + ""String_Node_Str"" + retransmitTimeout+ ""String_Node_Str""+ Config.PERIODIC_CATCHUP_TIMEOUT+ ""String_Node_Str""+ periodicCatchupTimeout+ ""String_Node_Str""+ Config.TCP_RECONNECT_TIMEOUT+ ""String_Node_Str""+ tcpReconnectTimeout);
}"
18098,"protected void ensureSnapshot(){
  if (snapshot == null) {
    snapshot=sha512.digest();
    snapshotSeqNo=lastExecuteSeqNo;
  }
}","protected void ensureSnapshot(){
  if (snapshot == null) {
    snapshot=previousDigest;
    snapshotSeqNo=lastExecuteSeqNo;
  }
}"
18099,"public synchronized byte[] execute(byte[] value,int executeSeqNo){
  lastExecuteSeqNo=executeSeqNo;
  byte[] digest=sha512.digest(value);
  StringBuffer sb=new StringBuffer();
  sb.append(executeSeqNo);
  sb.append(' ');
  sb.append(localId);
  sb.append(' ');
  sb.append(Arrays.toString(value).hashCode());
  sb.append(' ');
  sb.append(Arrays.toString(digest).hashCode());
  sb.append('\n');
  try {
    decisionsFile.writeBytes(sb.toString());
    decisionsFile.flush();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (random.nextInt(100) < 10) {
    snapshotSeqNo=executeSeqNo;
    snapshot=digest;
    if (random.nextInt(100) < 10) {
      fireSnapshotMade(snapshotSeqNo + 1,snapshot,digest);
    }
  }
  return digest;
}","public synchronized byte[] execute(byte[] value,int executeSeqNo){
  lastExecuteSeqNo=executeSeqNo;
  sha512.update(previousDigest);
  byte[] digest=sha512.digest(value);
  StringBuffer sb=new StringBuffer();
  sb.append(executeSeqNo);
  sb.append(' ');
  sb.append(localId);
  sb.append(' ');
  sb.append(Arrays.toString(value).hashCode());
  sb.append(' ');
  sb.append(Arrays.toString(digest).hashCode());
  sb.append('\n');
  try {
    decisionsFile.writeBytes(sb.toString());
    decisionsFile.flush();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (random.nextInt(100) < 10) {
    snapshotSeqNo=executeSeqNo;
    snapshot=digest;
    if (random.nextInt(100) < 10) {
      fireSnapshotMade(snapshotSeqNo + 1,snapshot,digest);
    }
  }
  previousDigest=digest;
  return digest;
}"
18100,"public void updateToSnapshot(int requestSeqNo,byte[] snapshot){
  sha512.reset();
  sha512.update(snapshot);
}","public void updateToSnapshot(int nextRequestSeqNo,byte[] snapshot){
  previousDigest=snapshot;
  this.snapshot=snapshot;
  snapshotSeqNo=nextRequestSeqNo - 1;
}"
18101,"public byte[] execute(byte[] value,int seqNo){
  Logger.getLogger(this.getClass().getCanonicalName()).info(""String_Node_Str"" + seqNo);
  if (random.nextInt(10) == 0) {
    assert(last != null);
    fireSnapshotMade(seqNo,last,value);
    Logger.getLogger(this.getClass().getCanonicalName()).info(""String_Node_Str"");
  }
  last=value;
  return value;
}","public byte[] execute(byte[] value,int seqNo){
  Logger.getLogger(this.getClass().getCanonicalName()).info(""String_Node_Str"" + seqNo);
  if (random.nextInt(10) == 0) {
    assert(last != null);
    fireSnapshotMade(seqNo + 1,last,value);
    Logger.getLogger(this.getClass().getCanonicalName()).info(""String_Node_Str"");
  }
  last=value;
  return value;
}"
18102,"/** 
 * Restores the service state from snapshot
 * @param requestSeqNo (last executed request sequential number + 1) beforesnapshot was made (i.e. next request to be executed no)
 * @param snapshot the snapshot itself
 */
void updateToSnapshot(int requestSeqNo,byte[] snapshot);","/** 
 * Restores the service state from snapshot
 * @param requestSeqNo (last executed request sequential number + 1) beforesnapshot was made (i.e. next request to be executed no)
 * @param snapshot the snapshot itself
 */
void updateToSnapshot(int nextRequestSeqNo,byte[] snapshot);"
18103,"public void onSnapshotMade(final Snapshot snapshot){
  dispatcher.checkInDispatcher();
  if (snapshot.getValue() == null)   throw new RuntimeException(""String_Node_Str"");
  Map<Long,Reply> requestHistory=new HashMap<Long,Reply>(executedRequests);
  for (int i=executeUB - 1; i >= snapshot.getNextInstanceId(); i--) {
    List<Reply> ides=executedDifference.get(i);
    if (ides == null)     continue;
    for (    Reply reply : ides) {
      requestHistory.put(reply.getRequestId().getClientId(),reply);
    }
  }
  while (!executedDifference.isEmpty() && executedDifference.firstKey() < snapshot.getNextInstanceId()) {
    executedDifference.pollFirstEntry();
  }
  snapshot.setLastReplyForClient(requestHistory);
  paxos.onSnapshotMade(snapshot);
}","public void onSnapshotMade(final Snapshot snapshot){
  dispatcher.checkInDispatcher();
  if (snapshot.getValue() == null)   throw new RuntimeException(""String_Node_Str"");
  Map<Long,Reply> requestHistory=new HashMap<Long,Reply>(previousSnapshotExecutedRequests);
  int prevSnapshotNextInstId;
  Snapshot lastSnapshot=paxos.getStorage().getLastSnapshot();
  if (lastSnapshot != null)   prevSnapshotNextInstId=lastSnapshot.getNextInstanceId();
 else   prevSnapshotNextInstId=0;
  for (int i=prevSnapshotNextInstId; i < snapshot.getNextInstanceId(); ++i) {
    List<Reply> ides=executedDifference.remove(i);
    if (ides == null)     continue;
    for (    Reply reply : ides) {
      requestHistory.put(reply.getRequestId().getClientId(),reply);
    }
  }
  snapshot.setLastReplyForClient(requestHistory);
  previousSnapshotExecutedRequests.clear();
  previousSnapshotExecutedRequests.putAll(requestHistory);
  paxos.onSnapshotMade(snapshot);
}"
18104,"/** 
 * Notifies this service proxy that all request from specified consensus instance has been executed.
 * @param instanceId - the id of executed consensus instance
 */
public void instanceExecuted(int instanceId){
  startingSeqNo.put(instanceId + 1,nextSeqNo);
}","/** 
 * Notifies this service proxy that all request from specified consensus instance has been executed.
 * @param instanceId - the id of executed consensus instance
 */
public void instanceExecuted(int instanceId){
  startingSeqNo.add(new Pair<Integer,Integer>(instanceId + 1,nextSeqNo));
}"
18105,"/** 
 * Creates new <code>ServiceProxy</code> instance.
 * @param service - the service wrapped by this proxy
 * @param responsesCache - the cache of responses from service
 * @param replicaDispatcher - the dispatcher used in replica
 */
public ServiceProxy(Service service,Map<Integer,List<Reply>> responsesCache,SingleThreadDispatcher replicaDispatcher){
  this.service=service;
  this.replicaDispatcher=replicaDispatcher;
  service.addSnapshotListener(this);
  this.responsesCache=responsesCache;
}","/** 
 * Creates new <code>ServiceProxy</code> instance.
 * @param service - the service wrapped by this proxy
 * @param responsesCache - the cache of responses from service
 * @param replicaDispatcher - the dispatcher used in replica
 */
public ServiceProxy(Service service,Map<Integer,List<Reply>> responsesCache,SingleThreadDispatcher replicaDispatcher){
  this.service=service;
  this.replicaDispatcher=replicaDispatcher;
  service.addSnapshotListener(this);
  this.responsesCache=responsesCache;
  startingSeqNo.add(new Pair<Integer,Integer>(0,0));
}"
18106,"/** 
 * Updates states of underlying service to specified snapshot.
 * @param snapshot - the snapshot with newer service state
 */
public void updateToSnapshot(Snapshot snapshot){
  lastSnapshotNextSeqNo=snapshot.getNextRequestSeqNo();
  nextSeqNo=snapshot.getStartingRequestSeqNo();
  skip=snapshot.getNextRequestSeqNo() - nextSeqNo;
  skippedCache=new LinkedList<Reply>(snapshot.getPartialResponseCache());
  startingSeqNo.put(snapshot.getNextInstanceId(),snapshot.getStartingRequestSeqNo());
  service.updateToSnapshot(lastSnapshotNextSeqNo,snapshot.getValue());
}","/** 
 * Updates states of underlying service to specified snapshot.
 * @param snapshot - the snapshot with newer service state
 */
public void updateToSnapshot(Snapshot snapshot){
  lastSnapshotNextSeqNo=snapshot.getNextRequestSeqNo();
  nextSeqNo=snapshot.getStartingRequestSeqNo();
  skip=snapshot.getNextRequestSeqNo() - nextSeqNo;
  skippedCache=new LinkedList<Reply>(snapshot.getPartialResponseCache());
  if (!startingSeqNo.isEmpty() && startingSeqNo.getLast().getValue() > nextSeqNo) {
    truncateStartingSeqNo(nextSeqNo);
  }
 else {
    startingSeqNo.clear();
    startingSeqNo.add(new Pair<Integer,Integer>(snapshot.getNextInstanceId(),snapshot.getStartingRequestSeqNo()));
  }
  service.updateToSnapshot(lastSnapshotNextSeqNo,snapshot.getValue());
}"
18107,"public void newSnapshot(Snapshot snapshot){
}","public void newSnapshot(Snapshot snapshot){
  try {
    String oldSnapshotFileName=snapshotFileName();
    snapshotFileNumber++;
    String newSnapshotFileName=snapshotFileName();
    DataOutputStream snapshotStream=new DataOutputStream(new FileOutputStream(newSnapshotFileName,false));
    snapshot.writeTo(snapshotStream);
    snapshotStream.close();
    ByteBuffer buffer=ByteBuffer.allocate(1 + 4);
    buffer.put(SNAPSHOT);
    buffer.putInt(snapshotFileNumber);
    logStream.write(buffer.array());
    if (new File(oldSnapshotFileName).exists())     new File(oldSnapshotFileName).delete();
    this.snapshot=snapshot;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
18108,"public Collection<ConsensusInstance> load() throws IOException {
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  List<Integer> numbers=new ArrayList<Integer>();
  for (  String fileName : directory.list()) {
    Matcher matcher=pattern.matcher(fileName);
    if (matcher.find()) {
      int x=Integer.parseInt(matcher.group(1));
      numbers.add(x);
    }
  }
  Collections.sort(numbers);
  Map<Integer,ConsensusInstance> instances=new TreeMap<Integer,ConsensusInstance>();
  for (  Integer number : numbers) {
    String fileName=""String_Node_Str"" + number + ""String_Node_Str"";
    loadInstances(new File(directoryPath + ""String_Node_Str"" + fileName),instances);
  }
  if (previousSnapshotId == null)   return instances.values();
  DataInputStream snapshotStream=new DataInputStream(new FileInputStream(snapshotFileNameForRequest(previousSnapshotId)));
  snapshot=new Snapshot(snapshotStream);
  return instances.values();
}","public Collection<ConsensusInstance> load() throws IOException {
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  List<Integer> numbers=new ArrayList<Integer>();
  for (  String fileName : directory.list()) {
    Matcher matcher=pattern.matcher(fileName);
    if (matcher.find()) {
      int x=Integer.parseInt(matcher.group(1));
      numbers.add(x);
    }
  }
  Collections.sort(numbers);
  Map<Integer,ConsensusInstance> instances=new TreeMap<Integer,ConsensusInstance>();
  for (  Integer number : numbers) {
    String fileName=""String_Node_Str"" + number + ""String_Node_Str"";
    loadInstances(new File(directoryPath + ""String_Node_Str"" + fileName),instances);
  }
  if (snapshotFileNumber == -1)   return instances.values();
  DataInputStream snapshotStream=new DataInputStream(new FileInputStream(snapshotFileName()));
  snapshot=new Snapshot(snapshotStream);
  snapshotStream.close();
  return instances.values();
}"
18109,"@Test public void shouldHandleSnapshotFromServiceCalledWithinExecuteMethod(){
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(0);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(1);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  SnapshotListener2 snapshotListener2=mock(SnapshotListener2.class);
  serviceProxy.addSnapshotListener(snapshotListener2);
  responsesCache.put(2,Arrays.asList(ReplyGenerator.generate(),ReplyGenerator.generate()));
  Request lastRequest=RequestGenerator.generate();
  serviceProxy.execute(lastRequest);
  serviceProxy.onSnapshotMade(8,new byte[]{1,2,3},new byte[]{1,2,3,4});
  executeDispatcher();
  ArgumentCaptor<Snapshot> snapshotCaptor=ArgumentCaptor.forClass(Snapshot.class);
  verify(snapshotListener2).onSnapshotMade(snapshotCaptor.capture());
  Snapshot snapshot=snapshotCaptor.getValue();
  assertArrayEquals(new byte[]{1,2,3},snapshot.getValue());
  assertEquals(2,(int)snapshot.getNextInstanceId());
  assertEquals(8,snapshot.getNextRequestSeqNo());
  assertEquals(5,snapshot.getStartingRequestSeqNo());
  assertEquals(3,snapshot.getPartialResponseCache().size());
}","@Test public void shouldHandleSnapshotFromServiceCalledWithinExecuteMethod(){
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(0);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(1);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  SnapshotListener2 snapshotListener2=mock(SnapshotListener2.class);
  serviceProxy.addSnapshotListener(snapshotListener2);
  responsesCache.put(2,Arrays.asList(ReplyGenerator.generate(),ReplyGenerator.generate()));
  Request lastRequest=RequestGenerator.generate();
  serviceProxy.execute(lastRequest);
  serviceProxy.onSnapshotMade(8,new byte[]{1,2,3},new byte[]{1,2,3,4});
  executeDispatcher();
  ArgumentCaptor<Snapshot> snapshotCaptor=ArgumentCaptor.forClass(Snapshot.class);
  verify(snapshotListener2).onSnapshotMade(snapshotCaptor.capture());
  Snapshot snapshot=snapshotCaptor.getValue();
  assertArrayEquals(new byte[]{1,2,3},snapshot.getValue());
  assertEquals(2,snapshot.getNextInstanceId());
  assertEquals(8,snapshot.getNextRequestSeqNo());
  assertEquals(5,snapshot.getStartingRequestSeqNo());
  assertEquals(3,snapshot.getPartialResponseCache().size());
}"
18110,"@Test public void shouldHandleSnapshotFromServiceAfterInstanceIsExecuted(){
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(0);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(1);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(2);
  SnapshotListener2 snapshotListener2=mock(SnapshotListener2.class);
  serviceProxy.addSnapshotListener(snapshotListener2);
  serviceProxy.onSnapshotMade(8,new byte[]{1,2,3},null);
  executeDispatcher();
  ArgumentCaptor<Snapshot> snapshotCaptor=ArgumentCaptor.forClass(Snapshot.class);
  verify(snapshotListener2).onSnapshotMade(snapshotCaptor.capture());
  Snapshot snapshot=snapshotCaptor.getValue();
  assertArrayEquals(new byte[]{1,2,3},snapshot.getValue());
  assertEquals(3,(int)snapshot.getNextInstanceId());
  assertEquals(8,snapshot.getNextRequestSeqNo());
  assertEquals(8,snapshot.getStartingRequestSeqNo());
  assertEquals(0,snapshot.getPartialResponseCache().size());
}","@Test public void shouldHandleSnapshotFromServiceAfterInstanceIsExecuted(){
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(0);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(1);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(2);
  SnapshotListener2 snapshotListener2=mock(SnapshotListener2.class);
  serviceProxy.addSnapshotListener(snapshotListener2);
  serviceProxy.onSnapshotMade(8,new byte[]{1,2,3},null);
  executeDispatcher();
  ArgumentCaptor<Snapshot> snapshotCaptor=ArgumentCaptor.forClass(Snapshot.class);
  verify(snapshotListener2).onSnapshotMade(snapshotCaptor.capture());
  Snapshot snapshot=snapshotCaptor.getValue();
  assertArrayEquals(new byte[]{1,2,3},snapshot.getValue());
  assertEquals(3,snapshot.getNextInstanceId());
  assertEquals(8,snapshot.getNextRequestSeqNo());
  assertEquals(8,snapshot.getStartingRequestSeqNo());
  assertEquals(0,snapshot.getPartialResponseCache().size());
}"
18111,"@Test public void shouldHandleSnapshotFromService(){
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(0);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(1);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  responsesCache.put(2,Arrays.asList(ReplyGenerator.generate(),ReplyGenerator.generate(),ReplyGenerator.generate()));
  SnapshotListener2 snapshotListener2=mock(SnapshotListener2.class);
  serviceProxy.addSnapshotListener(snapshotListener2);
  serviceProxy.onSnapshotMade(8,new byte[]{1,2,3},null);
  executeDispatcher();
  ArgumentCaptor<Snapshot> snapshotCaptor=ArgumentCaptor.forClass(Snapshot.class);
  verify(snapshotListener2).onSnapshotMade(snapshotCaptor.capture());
  Snapshot snapshot=snapshotCaptor.getValue();
  assertArrayEquals(new byte[]{1,2,3},snapshot.getValue());
  assertEquals(2,(int)snapshot.getNextInstanceId());
  assertEquals(8,snapshot.getNextRequestSeqNo());
  assertEquals(5,snapshot.getStartingRequestSeqNo());
  assertEquals(responsesCache.get(2),snapshot.getPartialResponseCache());
}","@Test public void shouldHandleSnapshotFromService(){
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(0);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.instanceExecuted(1);
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  serviceProxy.execute(RequestGenerator.generate());
  responsesCache.put(2,Arrays.asList(ReplyGenerator.generate(),ReplyGenerator.generate(),ReplyGenerator.generate()));
  SnapshotListener2 snapshotListener2=mock(SnapshotListener2.class);
  serviceProxy.addSnapshotListener(snapshotListener2);
  serviceProxy.onSnapshotMade(8,new byte[]{1,2,3},null);
  executeDispatcher();
  ArgumentCaptor<Snapshot> snapshotCaptor=ArgumentCaptor.forClass(Snapshot.class);
  verify(snapshotListener2).onSnapshotMade(snapshotCaptor.capture());
  Snapshot snapshot=snapshotCaptor.getValue();
  assertArrayEquals(new byte[]{1,2,3},snapshot.getValue());
  assertEquals(2,snapshot.getNextInstanceId());
  assertEquals(8,snapshot.getNextRequestSeqNo());
  assertEquals(5,snapshot.getStartingRequestSeqNo());
  assertEquals(responsesCache.get(2),snapshot.getPartialResponseCache());
}"
18112,"public void onSnapshotMade(final Snapshot snapshot){
  dispatcher.checkInDispatcher();
  if (snapshot.getValue() == null)   throw new RuntimeException(""String_Node_Str"");
  Map<Long,Reply> requestHistory=new HashMap<Long,Reply>(executedRequests);
  for (int i=executeUB - 1; i >= snapshot.getNextInstanceId(); i--) {
    List<Reply> ides=executedDifference.get(i);
    if (ides == null)     continue;
    for (    Reply reply : ides) {
      requestHistory.put(reply.getRequestId().getClientId(),reply);
    }
  }
  while (executedDifference.firstKey() < snapshot.getNextInstanceId()) {
    executedDifference.pollFirstEntry();
  }
  snapshot.setLastReplyForClient(requestHistory);
  paxos.onSnapshotMade(snapshot);
}","public void onSnapshotMade(final Snapshot snapshot){
  dispatcher.checkInDispatcher();
  if (snapshot.getValue() == null)   throw new RuntimeException(""String_Node_Str"");
  Map<Long,Reply> requestHistory=new HashMap<Long,Reply>(executedRequests);
  for (int i=executeUB - 1; i >= snapshot.getNextInstanceId(); i--) {
    List<Reply> ides=executedDifference.get(i);
    if (ides == null)     continue;
    for (    Reply reply : ides) {
      requestHistory.put(reply.getRequestId().getClientId(),reply);
    }
  }
  while (!executedDifference.isEmpty() && executedDifference.firstKey() < snapshot.getNextInstanceId()) {
    executedDifference.pollFirstEntry();
  }
  snapshot.setLastReplyForClient(requestHistory);
  paxos.onSnapshotMade(snapshot);
}"
18113,"/** 
 * Main procedure for the replica responding to query. The replica checks if the requested instances are decided by it, and if yes - it appends them to response.
 */
private void handleQuery(CatchUpQuery query,int sender){
  if (query.isSnapshotRequest()) {
    Message m;
    Snapshot lastSnapshot=storage.getLastSnapshot();
    if (lastSnapshot != null)     m=new CatchUpSnapshot(storage.getView(),query.getSentTime(),lastSnapshot);
 else     m=new CatchUpResponse(storage.getView(),query.getSentTime(),new Vector<ConsensusInstance>());
    network.sendMessage(m,sender);
    logger.info(""String_Node_Str"" + query.toString() + ""String_Node_Str""+ sender+ ""String_Node_Str"");
    return;
  }
  SortedMap<Integer,ConsensusInstance> log=storage.getLog().getInstanceMap();
  if (log.isEmpty()) {
    if (storage.getLastSnapshot() != null)     sendSnapshotOnlyResponse(query,sender);
    return;
  }
  Integer lastKey=log.lastKey();
  InnerResponseSender responseSender=new InnerResponseSender(query,sender);
  int i;
  for (  Pair<Integer,Integer> range : query.getInstanceIdRangeArray()) {
    for (i=range.key(); i <= range.value() && i <= lastKey; ++i) {
      ConsensusInstance consensusInstance=log.get(i);
      if (consensusInstance == null) {
        sendSnapshotOnlyResponse(query,sender);
        return;
      }
      if (consensusInstance.getState() == LogEntryState.DECIDED)       responseSender.add(consensusInstance);
    }
  }
  for (  int instanceId : query.getInstanceIdArray()) {
    if (instanceId >= lastKey)     continue;
    ConsensusInstance consensusInstance=log.get(instanceId);
    if (consensusInstance == null) {
      sendSnapshotOnlyResponse(query,sender);
      return;
    }
    if (consensusInstance.getState() == LogEntryState.DECIDED)     responseSender.add(consensusInstance);
  }
  responseSender.flush();
  logger.info(""String_Node_Str"" + query.toString() + ""String_Node_Str""+ sender+ ""String_Node_Str"");
}","/** 
 * Main procedure for the replica responding to query. The replica checks if the requested instances are decided by it, and if yes - it appends them to response.
 */
private void handleQuery(CatchUpQuery query,int sender){
  if (query.isSnapshotRequest()) {
    Message m;
    Snapshot lastSnapshot=storage.getLastSnapshot();
    if (lastSnapshot != null)     m=new CatchUpSnapshot(storage.getView(),query.getSentTime(),lastSnapshot);
 else     m=new CatchUpResponse(storage.getView(),query.getSentTime(),new Vector<ConsensusInstance>());
    network.sendMessage(m,sender);
    logger.info(""String_Node_Str"" + query.toString() + ""String_Node_Str""+ sender+ ""String_Node_Str"");
    return;
  }
  SortedMap<Integer,ConsensusInstance> log=storage.getLog().getInstanceMap();
  if (log.isEmpty()) {
    if (storage.getLastSnapshot() != null)     sendSnapshotOnlyResponse(query,sender);
    return;
  }
  Integer lastKey=log.lastKey();
  InnerResponseSender responseSender=new InnerResponseSender(query,sender);
  int i;
  for (  Pair<Integer,Integer> range : query.getInstanceIdRangeArray()) {
    for (i=range.key(); i <= range.value() && i <= lastKey; ++i) {
      ConsensusInstance consensusInstance=log.get(i);
      if (consensusInstance == null) {
        sendSnapshotOnlyResponse(query,sender);
        return;
      }
      if (consensusInstance.getState() == LogEntryState.DECIDED)       responseSender.add(consensusInstance);
    }
  }
  for (  int instanceId : query.getInstanceIdArray()) {
    if (instanceId > lastKey)     continue;
    ConsensusInstance consensusInstance=log.get(instanceId);
    if (consensusInstance == null) {
      sendSnapshotOnlyResponse(query,sender);
      return;
    }
    if (consensusInstance.getState() == LogEntryState.DECIDED)     responseSender.add(consensusInstance);
  }
  responseSender.flush();
  logger.info(""String_Node_Str"" + query.toString() + ""String_Node_Str""+ sender+ ""String_Node_Str"");
}"
18114,"private void stop(int i){
  prepared.set(i);
  prepareRetransmitter.stop();
}","private void stop(int i){
  prepared.set(i);
  prepareRetransmitter.stop(i);
}"
18115,"public void update(PrepareOK message,int sender){
  storage.updateEpoch(message.getEpoch());
  prepareEpoch[sender]=Math.max(prepareEpoch[sender],message.getEpoch()[sender]);
  for (int i=0; i < numReplicas; i++) {
    if (prepareEpoch[i] == storage.getEpoch()[i])     stop(i);
 else     start(i);
  }
  prepareRetransmitter.stop(sender);
}","public void update(PrepareOK message,int sender){
  storage.updateEpoch(message.getEpoch());
  prepareEpoch[sender]=Math.max(prepareEpoch[sender],message.getEpoch()[sender]);
  for (int i=0; i < numReplicas; i++) {
    if (prepareEpoch[i] == storage.getEpoch()[i])     stop(i);
 else     start(i);
  }
}"
18116,"public String toString(){
  return ""String_Node_Str"" + super.toString() + ""String_Node_Str""+ Arrays.toString(epoch)+ ""String_Node_Str"";
}","public String toString(){
  return ""String_Node_Str"" + super.toString() + ""String_Node_Str""+ Arrays.toString(epoch)+ ""String_Node_Str""+ nextId+ ""String_Node_Str"";
}"
18117,"/** 
 * Adds a new message listener for a certain type of message or all messages ( see   {@link MessageType}). The listener cannot be added twice for the same message - this causes a   {@link RuntimeException}.
 */
final public static void addMessageListener(MessageType mType,MessageHandler handler){
  CopyOnWriteArrayList<MessageHandler> handlers=_msgListeners.get(mType);
  boolean wasAdded=handlers.addIfAbsent(handler);
  if (!wasAdded) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Adds a new message listener for a certain type of message or all messages ( see   {@link MessageType}). The listener cannot be added twice for the same message - this causes a   {@link RuntimeException}.
 */
final public static void addMessageListener(MessageType mType,MessageHandler handler){
  CopyOnWriteArrayList<MessageHandler> handlers=msgListeners.get(mType);
  boolean wasAdded=handlers.addIfAbsent(handler);
  if (!wasAdded) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
18118,"/** 
 * Removes a previously registered listener. Throws   {@link RuntimeException}if the listener is not on list.
 */
final public static void removeMessageListener(MessageType mType,MessageHandler handler){
  CopyOnWriteArrayList<MessageHandler> handlers=_msgListeners.get(mType);
  boolean wasPresent=handlers.remove(handler);
  if (!wasPresent) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Removes a previously registered listener. Throws   {@link RuntimeException}if the listener is not on list.
 */
final public static void removeMessageListener(MessageType mType,MessageHandler handler){
  CopyOnWriteArrayList<MessageHandler> handlers=msgListeners.get(mType);
  boolean wasPresent=handlers.remove(handler);
  if (!wasPresent) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
18119,"/** 
 * Informs all listeners waiting for the message type about the message. Parameter type is needed in order to support MessageType.ANY value. Returns if there was at least one listener.
 */
private final boolean broadcastToListeners(MessageType type,Message msg,int sender){
  List<MessageHandler> handlers=_msgListeners.get(type);
  boolean handled=false;
  for (  MessageHandler listener : handlers) {
    listener.onMessageReceived(msg,sender);
    handled=true;
  }
  return handled;
}","/** 
 * Informs all listeners waiting for the message type about the message. Parameter type is needed in order to support MessageType.ANY value. Returns if there was at least one listener.
 */
private final boolean broadcastToListeners(MessageType type,Message msg,int sender){
  List<MessageHandler> handlers=msgListeners.get(type);
  boolean handled=false;
  for (  MessageHandler listener : handlers) {
    listener.onMessageReceived(msg,sender);
    handled=true;
  }
  return handled;
}"
18120,"/** 
 * Notifies all active network listeners that message was sent.
 */
protected final void fireSentMessage(Message msg,BitSet dest){
  List<MessageHandler> handlers=_msgListeners.get(MessageType.SENT);
  for (  MessageHandler listener : handlers) {
    listener.onMessageSent(msg,dest);
  }
}","/** 
 * Notifies all active network listeners that message was sent.
 */
protected final void fireSentMessage(Message msg,BitSet dest){
  List<MessageHandler> handlers=msgListeners.get(MessageType.SENT);
  for (  MessageHandler listener : handlers) {
    listener.onMessageSent(msg,dest);
  }
}"
18121,"public synchronized void start(){
  receiverThread.start();
  senderThread.start();
}","/** 
 * Starts the receiver and sender thread.
 */
public synchronized void start(){
  receiverThread.start();
  senderThread.start();
}"
18122,"/** 
 * Creates a new TCP connection to specified replica.
 * @param network - related <code>TcpNetwork</code>
 * @param replica - replica to connect to
 * @param active - Initiate connection or wait for remote connection
 */
public TcpConnection(TcpNetwork network,PID replica,boolean active){
  this.network=network;
  this.replica=replica;
  this.active=active;
  _logger.info(""String_Node_Str"" + replica + ""String_Node_Str""+ active);
  this.receiverThread=new Thread(new ReceiverThread(),""String_Node_Str"" + this.replica.getId());
  this.senderThread=new Thread(new Sender(),""String_Node_Str"" + this.replica.getId());
  receiverThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
  senderThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
}","/** 
 * Creates a new TCP connection to specified replica.
 * @param network - related <code>TcpNetwork</code>.
 * @param replica - replica to connect to.
 * @param active - initiates connection if true; waits for remote connectionotherwise.
 */
public TcpConnection(TcpNetwork network,PID replica,boolean active){
  this.network=network;
  this.replica=replica;
  this.active=active;
  _logger.info(""String_Node_Str"" + replica + ""String_Node_Str""+ active);
  this.receiverThread=new Thread(new ReceiverThread(),""String_Node_Str"" + this.replica.getId());
  this.senderThread=new Thread(new Sender(),""String_Node_Str"" + this.replica.getId());
  receiverThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
  senderThread.setUncaughtExceptionHandler(new KillOnExceptionHandler());
}"
18123,"public void run(){
  while (true) {
    _logger.info(""String_Node_Str"" + replica.getId());
    connect();
    _logger.info(""String_Node_Str"" + replica.getId());
    while (true) {
      if (Thread.interrupted()) {
        _logger.log(Level.SEVERE,""String_Node_Str"");
        close();
        return;
      }
      Message message;
      try {
        message=MessageFactory.create(input);
      }
 catch (      IllegalArgumentException e) {
        _logger.log(Level.SEVERE,""String_Node_Str"",e);
        close();
        break;
      }
      if (_logger.isLoggable(Level.FINE)) {
        _logger.fine(""String_Node_Str"" + replica.getId() + ""String_Node_Str""+ message+ ""String_Node_Str""+ message.byteSize());
      }
      network.fireReceiveMessage(message,replica.getId());
    }
  }
}","public void run(){
  while (true) {
    _logger.info(""String_Node_Str"" + replica.getId());
    try {
      connect();
    }
 catch (    InterruptedException e) {
      _logger.severe(""String_Node_Str"");
      break;
    }
    _logger.info(""String_Node_Str"" + replica.getId());
    while (true) {
      if (Thread.interrupted()) {
        _logger.severe(""String_Node_Str"");
        close();
        return;
      }
      Message message;
      try {
        message=MessageFactory.create(input);
      }
 catch (      IllegalArgumentException e) {
        _logger.log(Level.SEVERE,""String_Node_Str"",e);
        close();
        break;
      }
      if (_logger.isLoggable(Level.FINE)) {
        _logger.fine(""String_Node_Str"" + replica.getId() + ""String_Node_Str""+ message+ ""String_Node_Str""+ message.byteSize());
      }
      network.fireReceiveMessage(message,replica.getId());
    }
  }
}"
18124,"/** 
 * Closes the connection clean.
 */
private synchronized void close(){
  try {
    _logger.info(""String_Node_Str"");
    if (socket != null) {
      socket.shutdownOutput();
      socket.close();
      socket=null;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  connected=false;
}","/** 
 * Closes the connection.
 */
private synchronized void close(){
  try {
    _logger.info(""String_Node_Str"");
    if (socket != null && socket.isConnected()) {
      socket.shutdownOutput();
      socket.close();
      socket=null;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  connected=false;
  _logger.info(""String_Node_Str"");
}"
18125,"/** 
 * Establishes connection to host specified by this object. If this is active connection then it will try to connect to other side. Otherwise we will wait until connection will be set-up using <code>setConnection</code> method. This method will return only if the connection is established and initialized properly.
 */
private synchronized void connect(){
}","/** 
 * Establishes connection to host specified by this object. If this is active connection then it will try to connect to other side. Otherwise we will wait until connection will be set-up using <code>setConnection</code> method. This method will return only if the connection is established and initialized properly.
 * @throws InterruptedException
 */
private void connect() throws InterruptedException {
}"
18126,"public AfterCatchupSnapshotEvent(Snapshot snapshot,Storage storage,final Object snapshotLock){
  _snapshot=snapshot;
  this.snapshotLock=snapshotLock;
  _stableStorage=storage.getStableStorage();
  _storage=storage;
}","public AfterCatchupSnapshotEvent(Snapshot snapshot,Storage storage,Object snapshotLock){
  this.snapshot=snapshot;
  this.snapshotLock=snapshotLock;
  this.storage=storage;
  stableStorage=storage.getStableStorage();
}"
18127,"public void run(){
  int oldInstanceId=_stableStorage.getLastSnapshot().nextIntanceId;
  if (oldInstanceId >= _snapshot.nextIntanceId) {
synchronized (snapshotLock) {
      snapshotLock.notify();
    }
    return;
  }
  _stableStorage.setLastSnapshot(_snapshot);
  _stableStorage.getLog().truncateBelow(oldInstanceId);
  _stableStorage.getLog().clearUndecidedBelow(_snapshot.nextIntanceId);
  _storage.updateFirstUncommitted();
synchronized (snapshotLock) {
    snapshotLock.notify();
  }
}","public void run(){
  Snapshot lastSnapshot=stableStorage.getLastSnapshot();
  if (lastSnapshot != null && lastSnapshot.nextIntanceId >= snapshot.nextIntanceId) {
synchronized (snapshotLock) {
      snapshotLock.notify();
    }
    return;
  }
  stableStorage.setLastSnapshot(snapshot);
  if (lastSnapshot != null) {
    stableStorage.getLog().truncateBelow(lastSnapshot.nextIntanceId);
  }
  stableStorage.getLog().clearUndecidedBelow(snapshot.nextIntanceId);
  storage.updateFirstUncommitted();
synchronized (snapshotLock) {
    snapshotLock.notify();
  }
}"
18128,"/** 
 * Get Element name for rendering ( imj , a , object, applet ).
 */
@Attribute public abstract String getElement();","/** 
 * Get the Element name for rendering ( img , a , object, applet ).
 */
@Attribute public abstract String getElement();"
18129,"/** 
 * The label for the Add button.
 */
@Attribute public abstract String getUploadLabel();","/** 
 * The label for the Upload button.
 */
@Attribute public abstract String getUploadLabel();"
18130,"private int getColumnCount(List<UIComponent> components){
  int result=0;
  for (  UIComponent component : components) {
    if (component instanceof AbstractToolbarGroup) {
      result+=component.getChildren().size();
    }
 else {
      result++;
    }
  }
  return result;
}","private int getColumnCount(List<UIComponent> components){
  int result=0;
  for (  UIComponent component : components) {
    if (component instanceof AbstractToolbarGroup) {
      result+=((AbstractToolbarGroup)component).getRenderedChildren().size();
    }
 else {
      result++;
    }
  }
  return result;
}"
18131,"@Override protected boolean isSubmitted(FacesContext context,AbstractTogglePanel panel){
  String activePanelName=panel.getSubmittedActiveItem();
  int itemIndex=panel.getIndexByName(activePanelName);
  if (itemIndex < 0) {
    return false;
  }
  UIComponent item=(UIComponent)panel.getItem(activePanelName);
  Map<String,String> parameterMap=context.getExternalContext().getRequestParameterMap();
  return parameterMap.get(item.getClientId(context)) != null;
}","@Override protected boolean isSubmitted(FacesContext context,AbstractTogglePanel panel){
  String activePanelName=panel.getSubmittedActiveItem();
  int itemIndex=panel.getIndexByName(activePanelName);
  if (itemIndex < 0) {
    return false;
  }
  Map<String,String> parameterMap=context.getExternalContext().getRequestParameterMap();
  return parameterMap.get(activePanelName) != null;
}"
18132,"/** 
 * Find all instances of the   {@link UIRichMessages} and update list of the rendered messages.
 * @param context
 * @param component
 * @param messages
 */
protected void findRichMessages(FacesContext context,UIComponent component,String id,Set<UIComponent> messages){
  Iterator<UIComponent> facetsAndChildren=component.getFacetsAndChildren();
  while (facetsAndChildren.hasNext()) {
    UIComponent child=(UIComponent)facetsAndChildren.next();
    if (child instanceof ClientSideMessage) {
      ClientSideMessage richMessage=(ClientSideMessage)child;
      if (null == richMessage.getFor()) {
        richMessage.updateMessages(context,id);
        messages.add(child);
      }
    }
 else {
      findRichMessages(context,child,id,messages);
    }
  }
}","/** 
 * Find all instances of the   {@link org.richfaces.component.UIRichMessages} and update list of the rendered messages.
 * @param context
 * @param component
 * @param messages
 */
protected void findRichMessages(FacesContext context,UIComponent component,String id,Set<UIComponent> messages){
  Iterator<UIComponent> facetsAndChildren=component.getFacetsAndChildren();
  while (facetsAndChildren.hasNext()) {
    UIComponent child=(UIComponent)facetsAndChildren.next();
    if (child instanceof ClientSideMessage) {
      ClientSideMessage richMessage=(ClientSideMessage)child;
      if (null == richMessage.getFor()) {
        richMessage.updateMessages(context,id);
        messages.add(child);
      }
    }
 else {
      findRichMessages(context,child,id,messages);
    }
  }
}"
18133,"@Test public void testSubmitTooShortValue() throws Exception {
  HtmlPage page=submitValueAndCheckMessage(""String_Node_Str"",equalTo(GraphBean.SHORT_MSG));
  checkMessage(page,""String_Node_Str"",containsString(GraphBean.SHORT_MSG));
  checkMessage(page,""String_Node_Str"",equalTo(""String_Node_Str""));
}","@Test public void testSubmitTooShortValue() throws Exception {
  HtmlPage page=submitValueAndCheckMessage(""String_Node_Str"",containsString(GraphBean.SHORT_MSG));
  checkMessage(page,""String_Node_Str"",containsString(GraphBean.SHORT_MSG));
  checkMessage(page,""String_Node_Str"",equalTo(""String_Node_Str""));
}"
18134,"protected HtmlPage submitValueAndCheckMessage(String value,Matcher<String> matcher) throws Exception {
  HtmlPage page=requestPage();
  HtmlInput input=getInput(page);
  page=(HtmlPage)input.setValueAttribute(value);
  page=submit(page);
  checkMessage(page,""String_Node_Str"",matcher);
  return page;
}","protected HtmlPage submitValueAndCheckMessage(String value,Matcher<String> matcher) throws Exception {
  HtmlPage page=requestPage();
  HtmlInput input=getInput(page);
  page=(HtmlPage)input.setValueAttribute(value);
  page=submit(page);
  System.out.println(page.asXml());
  checkMessage(page,""String_Node_Str"",matcher);
  return page;
}"
18135,"@Attribute(events=@EventName(""String_Node_Str"")) public abstract String getOnblur();","/** 
 * Javascript code executed when this element loses focus.
 */
@Attribute(events=@EventName(""String_Node_Str"")) public abstract String getOnblur();"
18136,"@Attribute(events=@EventName(""String_Node_Str"")) public abstract String getOnfocus();","/** 
 * Javascript code executed when this element receives focus.
 */
@Attribute(events=@EventName(""String_Node_Str"")) public abstract String getOnfocus();"
18137,"private static LibraryFunction getScriptFromAnnotation(Class<?> javaClass) throws ScriptNotFoundException {
  if (javaClass.isAnnotationPresent(ClientSideScript.class)) {
    ClientSideScript clientSideScript=javaClass.getAnnotation(ClientSideScript.class);
    List<ResourceKey> resources=Lists.newArrayList();
    for (    ResourceDependency dependency : clientSideScript.resources()) {
      resources.add(ResourceKey.create(dependency.name(),dependency.library()));
    }
    return new LibraryFunctionImplementation(clientSideScript.function(),resources);
  }
 else {
    throw new ScriptNotFoundException();
  }
}","private static LibraryFunction getScriptFromAnnotation(Class<?> javaClass){
  if (javaClass.isAnnotationPresent(ClientSideScript.class)) {
    ClientSideScript clientSideScript=javaClass.getAnnotation(ClientSideScript.class);
    List<ResourceKey> resources=Lists.newArrayList();
    for (    ResourceDependency dependency : clientSideScript.resources()) {
      resources.add(ResourceKey.create(dependency.name(),dependency.library()));
    }
    return new LibraryFunctionImplementation(clientSideScript.function(),resources);
  }
 else {
    return NO_SCRIPT;
  }
}"
18138,"private static LibraryFunction getScriptResource(FacesContext facesContext,Class<?> javaClass) throws ScriptNotFoundException {
  ResourceHandler resourceHandler=facesContext.getApplication().getResourceHandler();
  String resourceName=javaClass.getSimpleName() + ""String_Node_Str"";
  Resource facesResource=resourceHandler.createResource(resourceName,ORG_RICHFACES_CSV,TEXT_JAVASCRIPT);
  if (null != facesResource) {
    final String functionName=Strings.firstToLowerCase(javaClass.getSimpleName());
    return new LibraryFunctionImplementation(functionName,resourceName,ORG_RICHFACES_CSV);
  }
 else {
    throw new ScriptNotFoundException();
  }
}","private static LibraryFunction getScriptResource(FacesContext facesContext,Class<?> javaClass){
  ResourceHandler resourceHandler=facesContext.getApplication().getResourceHandler();
  String resourceName=javaClass.getSimpleName() + ""String_Node_Str"";
  Resource facesResource=resourceHandler.createResource(resourceName,ORG_RICHFACES_CSV,TEXT_JAVASCRIPT);
  if (null != facesResource) {
    final String functionName=Strings.firstToLowerCase(javaClass.getSimpleName());
    return new LibraryFunctionImplementation(functionName,resourceName,ORG_RICHFACES_CSV);
  }
 else {
    return NO_SCRIPT;
  }
}"
18139,"private LibraryFunction getFromComputationMap(ConcurrentMap<Class<?>,LibraryFunction> map,Class<?> clazz) throws ScriptNotFoundException {
  try {
    return map.get(clazz);
  }
 catch (  ComputationException e) {
    Throwable cause=e.getCause();
    if (cause instanceof ScriptNotFoundException) {
      ScriptNotFoundException snfe=(ScriptNotFoundException)cause;
      throw snfe;
    }
    throw e;
  }
}","private LibraryFunction getFromComputationMap(ConcurrentMap<Class<?>,LibraryFunction> map,Class<?> clazz){
  try {
    return map.get(clazz);
  }
 catch (  ComputationException e) {
    Throwable cause=e.getCause();
    throw new FacesException(cause);
  }
}"
18140,"public LibraryFunction getScript(FacesContext facesContext,Class<?> javaClass) throws ScriptNotFoundException {
  if (null == facesContext || null == javaClass) {
    throw new NullPointerException();
  }
  LibraryFunction function;
  try {
    function=getFromComputationMap(resourcesMapping,javaClass);
  }
 catch (  ScriptNotFoundException e) {
    if (defaultMapping.containsKey(javaClass)) {
      function=defaultMapping.get(javaClass);
    }
 else {
      function=getFromComputationMap(annotationsMapping,javaClass);
    }
  }
  return function;
}","public LibraryFunction getScript(FacesContext facesContext,Class<?> javaClass) throws ScriptNotFoundException {
  if (null == facesContext || null == javaClass) {
    throw new NullPointerException();
  }
  LibraryFunction function=getFromComputationMap(resourcesMapping,javaClass);
  if (NO_SCRIPT == function) {
    if (defaultMapping.containsKey(javaClass)) {
      function=defaultMapping.get(javaClass);
    }
 else {
      function=getFromComputationMap(annotationsMapping,javaClass);
    }
  }
  if (NO_SCRIPT == function) {
    throw new ScriptNotFoundException(""String_Node_Str"" + javaClass.getName());
  }
  return function;
}"
18141,public abstract Object getAutocompleteList();,@Attribute() public abstract Object getAutocompleteList();
18142,public abstract InplaceState getState();,@Attribute(hidden=true) public abstract InplaceState getState();
18143,public abstract InplaceState getState();,@Attribute(hidden=true) public abstract InplaceState getState();
18144,public abstract String getLeftIconClass();,@Attribute public abstract String getLeftIconClass();
18145,public abstract String getHoverClass();,@Attribute public abstract String getHoverClass();
18146,public abstract String getRightIconClass();,@Attribute public abstract String getRightIconClass();
18147,"protected String getOnClickFunction(FacesContext facesContext,UIComponent component){
  AbstractMenuItem menuItem=(AbstractMenuItem)component;
  Mode subminMode=resolveSubmitMode(menuItem);
  if (menuItem.isDisabled()) {
    return ""String_Node_Str"";
  }
 else   if (subminMode == null || Mode.server.equals(subminMode)) {
    return getServerSubmitFunction(menuItem);
  }
 else   if (Mode.ajax.equals(subminMode)) {
    return getOnClick(facesContext,menuItem);
  }
 else   if (Mode.client.equals(subminMode)) {
    return ""String_Node_Str"";
  }
  return ""String_Node_Str"";
}","protected String getOnClickFunction(FacesContext facesContext,UIComponent component){
  AbstractMenuItem menuItem=(AbstractMenuItem)component;
  Mode subminMode=resolveSubmitMode(menuItem);
  if (Mode.ajax.equals(subminMode)) {
    return getOnClick(facesContext,menuItem);
  }
 else {
    return ""String_Node_Str"";
  }
}"
18148,"protected Mode resolveSubmitMode(AbstractMenuItem menuItem){
  Mode submitMode=menuItem.getMode();
  if (null != submitMode) {
    return submitMode;
  }
  AbstractDropDownMenu parent=getDDMenu(menuItem);
  if (parent != null) {
    return parent.getMode();
  }
  return Mode.server;
}","protected Mode resolveSubmitMode(AbstractMenuItem menuItem){
  if (menuItem.getMode() != null) {
    return menuItem.getMode();
  }
  AbstractDropDownMenu parent=getDDMenu(menuItem);
  if (parent != null && parent.getMode() != null) {
    return parent.getMode();
  }
  return Mode.server;
}"
18149,"public DropEvent(UIComponent component,ClientDropBehavior behavior){
  super(component,behavior);
}","public DropEvent(UIComponent component,ClientDropBehavior behavior){
  super(component,behavior);
  this.dropComponent=component;
  this.dropBehavior=behavior;
}"
18150,"public UIComponent getDropComponent(){
  return getComponent();
}","public UIComponent getDropComponent(){
  return this.dropComponent;
}"
18151,"private boolean isImmediate(){
  boolean immediate=this.dropBehavior.isImmediate();
  if (!immediate) {
    if (dropSource instanceof EditableValueHolder) {
      immediate=((EditableValueHolder)dropSource).isImmediate();
    }
 else     if (dropSource instanceof ActionSource) {
      immediate=((ActionSource)dropSource).isImmediate();
    }
  }
  return immediate;
}","private boolean isImmediate(UIComponent component,ClientDropBehavior dropBehavior){
  boolean immediate=dropBehavior.isImmediate();
  if (!immediate) {
    if (component instanceof EditableValueHolder) {
      immediate=((EditableValueHolder)component).isImmediate();
    }
 else     if (component instanceof ActionSource) {
      immediate=((ActionSource)component).isImmediate();
    }
  }
  return immediate;
}"
18152,"@Override public void decode(FacesContext facesContext,UIComponent component,ClientBehavior behavior){
  if (null == facesContext || null == component || behavior == null) {
    throw new NullPointerException();
  }
  Map<String,String> requestParamMap=facesContext.getExternalContext().getRequestParameterMap();
  String dragSource=(String)requestParamMap.get(""String_Node_Str"");
  facesContext.getViewRoot().invokeOnComponent(facesContext,dragSource,new DropBehaviorContextCallBack(component,(ClientDropBehavior)behavior));
}","@Override public void decode(FacesContext facesContext,UIComponent component,ClientBehavior behavior){
  if (null == facesContext || null == component || behavior == null) {
    throw new NullPointerException();
  }
  Map<String,String> requestParamMap=facesContext.getExternalContext().getRequestParameterMap();
  String dragSource=(String)requestParamMap.get(""String_Node_Str"");
  DragBehaviorContextCallBack dragBehaviorContextCallBack=new DragBehaviorContextCallBack();
  facesContext.getViewRoot().invokeOnComponent(facesContext,dragSource,dragBehaviorContextCallBack);
  if (behavior instanceof ClientDropBehavior) {
    ClientDropBehavior dropBehavior=(ClientDropBehavior)behavior;
    DropEvent dropEvent=new DropEvent(component,dropBehavior);
    dropEvent.setDropValue(dropBehavior.getDropValue());
    dropEvent.setDragComponent(dragBehaviorContextCallBack.getDragComponent());
    dropEvent.setDragBehavior(dragBehaviorContextCallBack.getDragBehavior());
    dropEvent.setDragValue(dragBehaviorContextCallBack.getDragValue());
    queueEvent(dropEvent);
  }
}"
18153,"public void invokeContextCallback(FacesContext context,UIComponent target){
  ClientDragBehavior dragBehavior=getDragBehavior(target,""String_Node_Str"");
  if (dragBehavior != null) {
    DropEvent dropEvent=new DropEvent(dropSource,dropBehavior);
    dropEvent.setDragSource(dragBehavior);
    dropEvent.setDragComponent(target);
    queueDropEvent(dropEvent);
  }
 else {
  }
}","public void invokeContextCallback(FacesContext context,UIComponent target){
  ClientDragBehavior dragBehavior=getDragBehavior(target,""String_Node_Str"");
  this.dragValue=dragBehavior.getDragValue();
  this.dragBehavior=dragBehavior;
  this.dragComponent=target;
}"
18154,"private boolean isBypassUpdates(){
  boolean bypassUpdates=this.dropBehavior.isBypassUpdates();
  if (!bypassUpdates) {
    bypassUpdates=getUtils().isBooleanAttribute(this.dropSource,""String_Node_Str"");
  }
  return bypassUpdates;
}","private boolean isBypassUpdates(UIComponent component,ClientDropBehavior dropBehavior){
  boolean bypassUpdates=dropBehavior.isBypassUpdates();
  if (!bypassUpdates) {
    bypassUpdates=getUtils().isBooleanAttribute(component,""String_Node_Str"");
  }
  return bypassUpdates;
}"
18155,"@Override public Metadata applyRule(String name,TagAttribute attribute,MetadataTarget meta){
  if (meta.isTargetInstanceOf(ClientBehavior.class)) {
    if (!attribute.isLiteral()) {
      Class<?> type=meta.getPropertyType(name);
      if (type == null) {
        type=Object.class;
      }
      return new ValueExpressionMetadata(name,type,attribute);
    }
 else     if (meta != null && meta.getWriteMethod(name) == null) {
      if (log.isDebugEnabled()) {
        log.debug(attribute + ""String_Node_Str"" + name+ ""String_Node_Str""+ meta.getTargetClass().getName());
      }
      return new LiteralAttributeMetadata(name,attribute.getValue());
    }
  }
  return null;
}","@Override public Metadata applyRule(String name,TagAttribute attribute,MetadataTarget meta){
  if (meta.isTargetInstanceOf(ClientBehavior.class)) {
    if (!attribute.isLiteral()) {
      Class<?> type=meta.getPropertyType(name);
      if (type == null) {
        type=Object.class;
      }
      return new ValueExpressionMetadata(name,type,attribute);
    }
 else {
      return new LiteralAttributeMetadata(name,attribute.getValue());
    }
  }
  return null;
}"
18156,"@Override public void addToOptions(FacesContext facesContext,UIComponent component,Map<String,Object> options,Object additional){
  options.put(PopupConstants.OPTIONS_ITEM_CLASS,""String_Node_Str"");
  options.put(PopupConstants.OPTIONS_SELECT_ITEM_CLASS,""String_Node_Str"");
  options.put(OPTION_LIST_ITEMS,additional);
  String clientId=component.getClientId(facesContext);
  options.put(PopupConstants.OPTIONS_LIST_CORD,clientId + ""String_Node_Str"");
  options.put(PopupConstants.OPTIONS_LIST_CLASS,component.getAttributes().get(""String_Node_Str""));
  options.put(OPTIONS_SELECT_ITEM_VALUE_INPUT,clientId + ""String_Node_Str"");
  options.put(OPTIONS_VISIBLE,component.getAttributes().get(""String_Node_Str""));
}","@Override public void addToOptions(FacesContext facesContext,UIComponent component,Map<String,Object> options,Object additional){
  options.put(PopupConstants.OPTIONS_ITEM_CLASS,""String_Node_Str"");
  options.put(PopupConstants.OPTIONS_SELECT_ITEM_CLASS,""String_Node_Str"");
  String clientId=component.getClientId(facesContext);
  options.put(PopupConstants.OPTIONS_LIST_CORD,clientId + ""String_Node_Str"");
  options.put(PopupConstants.OPTIONS_LIST_CLASS,component.getAttributes().get(""String_Node_Str""));
  options.put(SelectHelper.OPTIONS_SELECT_ITEM_VALUE_INPUT,clientId + ""String_Node_Str"");
  options.put(SelectHelper.OPTIONS_LIST_ITEMS,additional);
  options.put(OPTIONS_VISIBLE,component.getAttributes().get(""String_Node_Str""));
}"
18157,"protected void doDecode(FacesContext context,UIComponent component){
  String clientId=component.getClientId(context);
  Map requestParameterMap=context.getExternalContext().getRequestParameterMap();
  String newValue=(String)requestParameterMap.get(clientId);
  if (null != newValue) {
    UIInput input=(UIInput)component;
    input.setSubmittedValue(newValue);
  }
}","protected void doDecode(FacesContext context,UIComponent component){
  String clientId=component.getClientId(context);
  Map<String,String> requestParameterMap=context.getExternalContext().getRequestParameterMap();
  String newValue=(String)requestParameterMap.get(clientId);
  if (null != newValue) {
    UIInput input=(UIInput)component;
    input.setSubmittedValue(newValue);
  }
}"
18158,"public static String getSelectInputLabel(FacesContext facesContext,UIComponent component){
  AbstractSelect select=(AbstractSelect)component;
  Object value=select.getSubmittedValue();
  if (value == null) {
    value=select.getValue();
    if (value != null) {
      List<SelectItem> items=SelectUtils.getSelectItems(facesContext,component);
      for (      SelectItem item : items) {
        if (value.equals(item.getValue())) {
          value=item.getLabel();
        }
      }
    }
  }
  return (String)value;
}","public static String getSelectInputLabel(FacesContext facesContext,UIComponent component){
  AbstractSelect select=(AbstractSelect)component;
  Object value=select.getSubmittedValue();
  String label=null;
  if (value == null) {
    value=select.getValue();
    if (value != null) {
      List<SelectItem> items=SelectUtils.getSelectItems(facesContext,component);
      for (      SelectItem item : items) {
        if (value.equals(item.getValue())) {
          label=item.getLabel();
        }
      }
    }
  }
  return label;
}"
18159,"public void buildScript(ResponseWriter writer,FacesContext facesContext,UIComponent component,List<ClientSelectItem> selectItems) throws IOException {
  if (!(component instanceof AbstractSelect)) {
    return;
  }
  AbstractSelect abstractSelect=(AbstractSelect)component;
  String scriptName=getScriptName();
  JSFunction function=new JSFunction(scriptName);
  String clientId=abstractSelect.getClientId(facesContext);
  Map<String,Object> options=new HashMap<String,Object>();
  options.put(SelectHelper.OPTIONS_SHOWCONTROL,abstractSelect.isShowButton());
  options.put(SelectHelper.OPTIONS_LIST_ITEMS,selectItems);
  options.put(PopupConstants.OPTIONS_ITEM_CLASS,abstractSelect.getItemCss());
  options.put(PopupConstants.OPTIONS_SELECT_ITEM_CLASS,abstractSelect.getSelectItemCss());
  options.put(PopupConstants.OPTIONS_LIST_CLASS,abstractSelect.getListCss());
  options.put(PopupConstants.OPTIONS_LIST_CORD,clientId + ""String_Node_Str"");
  function.addParameter(clientId);
  function.addParameter(options);
  writer.write(function.toString());
}","public void buildScript(ResponseWriter writer,FacesContext facesContext,UIComponent component,List<ClientSelectItem> selectItems) throws IOException {
  if (!(component instanceof AbstractSelect)) {
    return;
  }
  AbstractSelect abstractSelect=(AbstractSelect)component;
  String scriptName=getScriptName();
  JSFunction function=new JSFunction(scriptName);
  String clientId=abstractSelect.getClientId(facesContext);
  Map<String,Object> options=new HashMap<String,Object>();
  options.put(SelectHelper.OPTIONS_SHOWCONTROL,abstractSelect.isShowButton());
  options.put(SelectHelper.OPTIONS_LIST_ITEMS,selectItems);
  options.put(SelectHelper.OPTIONS_SELECT_ITEM_VALUE_INPUT,clientId + ""String_Node_Str"");
  options.put(PopupConstants.OPTIONS_ITEM_CLASS,abstractSelect.getItemCss());
  options.put(PopupConstants.OPTIONS_SELECT_ITEM_CLASS,abstractSelect.getSelectItemCss());
  options.put(PopupConstants.OPTIONS_LIST_CLASS,abstractSelect.getListCss());
  options.put(PopupConstants.OPTIONS_LIST_CORD,clientId + ""String_Node_Str"");
  function.addParameter(clientId);
  function.addParameter(options);
  writer.write(function.toString());
}"
18160,"@Override public void addToOptions(FacesContext facesContext,UIComponent component,Map<String,Object> options,Object additional){
  AbstractSelect abstractSelect=(AbstractSelect)component;
  SelectHelper.addSelectCssToOptions(abstractSelect,options,new String[]{ITEM_CSS,SELECT_ITEM_CSS,LIST_CSS});
  boolean openOnEdit=(Boolean)component.getAttributes().get(""String_Node_Str"");
  if (openOnEdit) {
    options.put(OPTIONS_VISIBLE,openOnEdit);
  }
  options.put(SelectHelper.OPTIONS_LIST_ITEMS,additional);
}","@Override public void addToOptions(FacesContext facesContext,UIComponent component,Map<String,Object> options,Object additional){
  AbstractSelect abstractSelect=(AbstractSelect)component;
  SelectHelper.addSelectCssToOptions(abstractSelect,options,new String[]{ITEM_CSS,SELECT_ITEM_CSS,LIST_CSS});
  boolean openOnEdit=(Boolean)component.getAttributes().get(""String_Node_Str"");
  boolean saveOnSelect=(Boolean)component.getAttributes().get(""String_Node_Str"");
  if (openOnEdit) {
    options.put(OPTIONS_OPEN_ON_EDIT,openOnEdit);
    options.put(OPTIONS_SAVE_ON_SELECT,saveOnSelect);
  }
  options.put(SelectHelper.OPTIONS_LIST_ITEMS,additional);
}"
18161,"public String getValue(FacesContext facesContext,UIComponent component) throws IOException {
  AbstractInplaceInput inplaceInput=(AbstractInplaceInput)component;
  String value=getInputValue(facesContext,inplaceInput);
  if (value == null || ""String_Node_Str"".equals(value)) {
    value=inplaceInput.getDefaultLabel();
  }
  return value;
}","public String getValue(FacesContext facesContext,UIComponent component) throws IOException {
  String value=getInputValue(facesContext,component);
  if (value == null || ""String_Node_Str"".equals(value)) {
    value=((InplaceComponent)component).getDefaultLabel();
  }
  return value;
}"
18162,"public String getReadyStyleClass(UIComponent component,InplaceState inplaceState){
  return (InplaceState.changed != inplaceState) ? READY_STATE_CSS : HtmlUtil.concatClasses(READY_STATE_CSS,CHANGED_STATE_CSS);
}","public String getReadyStyleClass(UIComponent component,InplaceState inplaceState){
  return (InplaceState.changed != inplaceState) ? getReadyStateCss() : HtmlUtil.concatClasses(getReadyStateCss(),getChangedStateCss());
}"
18163,"public InplaceState getInplaceState(UIComponent component){
  return ((AbstractInplaceInput)component).getState();
}","public InplaceState getInplaceState(UIComponent component){
  return ((InplaceComponent)component).getState();
}"
18164,"public String getEditStyleClass(UIComponent component,InplaceState inplaceState){
  return (InplaceState.edit != inplaceState) ? HtmlUtil.concatClasses(EDIT_STATE_CSS,NONE_CSS) : EDIT_STATE_CSS;
}","public String getEditStyleClass(UIComponent component,InplaceState inplaceState){
  return (InplaceState.edit != inplaceState) ? HtmlUtil.concatClasses(getEditStateCss(),getNoneCss()) : getEditStateCss();
}"
18165,"public void buildScript(ResponseWriter writer,FacesContext facesContext,UIComponent component) throws IOException {
  AbstractInplaceInput inplaceInput=(AbstractInplaceInput)component;
  JSFunction function=new JSFunction(""String_Node_Str"");
  function.addParameter(inplaceInput.getClientId(facesContext));
  String clientId=inplaceInput.getClientId(facesContext);
  Map<String,Object> options=new HashMap<String,Object>();
  options.put(OPTIONS_EDIT_EVENT,inplaceInput.getEditEvent());
  options.put(OPTIONS_NONE_CSS,NONE_CSS);
  options.put(OPTIONS_CHANGED_CSS,CHANGED_STATE_CSS);
  options.put(OPTIONS_EDIT_CONTAINER,clientId + ""String_Node_Str"");
  options.put(OPTIONS_INPUT,clientId + ""String_Node_Str"");
  options.put(OPTIONS_LABEL,clientId + ""String_Node_Str"");
  options.put(OPTIONS_FOCUS,clientId + ""String_Node_Str"");
  options.put(OPTIONS_DEFAULT_LABEL,inplaceInput.getDefaultLabel());
  boolean showControls=inplaceInput.isShowControls();
  options.put(OPTIONS_SHOWCONTROLS,showControls);
  if (showControls) {
    options.put(OPTIONS_BUTTON_OK,clientId + ""String_Node_Str"");
    options.put(OPTIONS_BUTTON_CANCEL,clientId + ""String_Node_Str"");
  }
  function.addParameter(options);
  writer.write(function.toString());
}","public void buildScript(ResponseWriter writer,FacesContext facesContext,UIComponent component,Object additional) throws IOException {
  if (!(component instanceof InplaceComponent)) {
    return;
  }
  String scriptName=getScriptName();
  JSFunction function=new JSFunction(scriptName);
  String clientId=component.getClientId(facesContext);
  Map<String,Object> options=createInplaceComponentOptions(clientId,(InplaceComponent)component);
  addToOptions(facesContext,component,options,additional);
  function.addParameter(clientId);
  function.addParameter(options);
  writer.write(function.toString());
}"
18166,"protected String getMarkupBody(FacesContext context,UIComponent component,boolean children) throws IOException {
  ResponseWriter writer=context.getResponseWriter();
  StringWriter dumpingWriter=new StringWriter();
  ResponseWriter clonedWriter=writer.cloneWithWriter(dumpingWriter);
  context.setResponseWriter(clonedWriter);
  try {
    if (children) {
      this.renderChildren(context,component);
    }
  }
  finally {
    clonedWriter.flush();
    context.setResponseWriter(writer);
  }
  return dumpingWriter.toString();
}","protected String getMarkupBody(FacesContext context,UIComponent component,boolean children) throws IOException {
  ResponseWriter writer=context.getResponseWriter();
  StringWriter dumpingWriter=new StringWriter();
  ResponseWriter clonedWriter=writer.cloneWithWriter(dumpingWriter);
  context.setResponseWriter(clonedWriter);
  try {
    if (children) {
      this.renderChildren(context,component);
    }
 else     if (component.getAttributes().get(""String_Node_Str"") != null) {
      clonedWriter.write(component.getAttributes().get(""String_Node_Str"").toString());
    }
  }
  finally {
    clonedWriter.flush();
    context.setResponseWriter(writer);
  }
  return dumpingWriter.toString();
}"
18167,"public String getScriptOptions(UIComponent component){
  Map<String,Object> attributes=component.getAttributes();
  Map<String,Object> options=new HashMap<String,Object>();
  RendererUtils utils=getUtils();
  utils.addToScriptHash(options,""String_Node_Str"",component.getClientId() + ""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  if (attributes.get(""String_Node_Str"") != null) {
    if (attributes.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      utils.addToScriptHash(options,""String_Node_Str"",false,""String_Node_Str"");
    }
 else     if (attributes.get(""String_Node_Str"").equals(""String_Node_Str"")) {
      utils.addToScriptHash(options,""String_Node_Str"",false,""String_Node_Str"");
    }
  }
  StringBuilder builder=new StringBuilder();
  builder.append(ScriptUtils.toScript(options));
  return builder.toString();
}","public String getScriptOptions(UIComponent component){
  Map<String,Object> attributes=component.getAttributes();
  Map<String,Object> options=new HashMap<String,Object>();
  RendererUtils utils=getUtils();
  utils.addToScriptHash(options,""String_Node_Str"",component.getClientId() + ""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""),""String_Node_Str"");
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  utils.addToScriptHash(options,""String_Node_Str"",attributes.get(""String_Node_Str""));
  String mode=(String)attributes.get(""String_Node_Str"");
  if (mode != null) {
    if (mode.equals(""String_Node_Str"")) {
      utils.addToScriptHash(options,""String_Node_Str"",false,""String_Node_Str"");
    }
 else     if (mode.equals(""String_Node_Str"") || mode.equals(""String_Node_Str"")) {
      utils.addToScriptHash(options,""String_Node_Str"",false,""String_Node_Str"");
      if (mode.equals(""String_Node_Str"")) {
        utils.addToScriptHash(options,""String_Node_Str"",true,""String_Node_Str"");
      }
    }
  }
  StringBuilder builder=new StringBuilder();
  builder.append(ScriptUtils.toScript(options));
  return builder.toString();
}"
18168,"protected void encodeItemsContainer(FacesContext facesContext,UIComponent component) throws IOException {
  AutocompleteEncodeStrategy strategy=getStrategy(component);
  Object mode=component.getAttributes().get(""String_Node_Str"");
  if (mode != null && mode.equals(""String_Node_Str"")) {
    List<Object> fetchValues=new ArrayList<Object>();
    this.encodeItems(facesContext,component,fetchValues);
  }
 else   if (mode != null && mode.equals(""String_Node_Str"")) {
    strategy.encodeItemsContainerBegin(facesContext,component);
    strategy.encodeItemsContainerEnd(facesContext,component);
  }
 else {
    strategy.encodeItemsContainerBegin(facesContext,component);
    strategy.encodeFakeItem(facesContext,component);
    strategy.encodeItemsContainerEnd(facesContext,component);
  }
}","protected void encodeItemsContainer(FacesContext facesContext,UIComponent component) throws IOException {
  AutocompleteEncodeStrategy strategy=getStrategy(component);
  Object mode=component.getAttributes().get(""String_Node_Str"");
  if (mode != null && mode.equals(""String_Node_Str"")) {
    List<Object> fetchValues=new ArrayList<Object>();
    this.encodeItems(facesContext,component,fetchValues);
  }
 else {
    strategy.encodeItemsContainerBegin(facesContext,component);
    strategy.encodeItemsContainerEnd(facesContext,component);
  }
}"
18169,"public void encodeItem(FacesContext facesContext,AbstractAutocomplete comboBox,Object item,AutocompleteEncodeStrategy strategy) throws IOException {
  strategy.encodeItemBegin(facesContext,comboBox);
  ResponseWriter writer=facesContext.getResponseWriter();
  writer.writeAttribute(HTML.CLASS_ATTRIBUTE,""String_Node_Str"",null);
  if (comboBox.getChildCount() > 0) {
    for (    UIComponent child : comboBox.getChildren()) {
      child.encodeAll(facesContext);
    }
  }
 else {
    if (item != null) {
      String value=null;
      if (comboBox.getItemConverter() != null) {
        value=comboBox.getItemConverter().getAsString(facesContext,comboBox,item);
      }
      if (value != null) {
        writer.writeText(value,null);
      }
      writer.writeText(item,null);
    }
  }
}","public void encodeItem(FacesContext facesContext,AbstractAutocomplete comboBox,Object item,AutocompleteEncodeStrategy strategy) throws IOException {
  strategy.encodeItemBegin(facesContext,comboBox);
  ResponseWriter writer=facesContext.getResponseWriter();
  writer.writeAttribute(HTML.CLASS_ATTRIBUTE,""String_Node_Str"",null);
  if (comboBox.getChildCount() > 0) {
    for (    UIComponent child : comboBox.getChildren()) {
      child.encodeAll(facesContext);
    }
  }
 else {
    if (item != null) {
      String value=null;
      if (comboBox.getItemConverter() != null) {
        value=comboBox.getItemConverter().getAsString(facesContext,comboBox,item);
      }
      if (value != null) {
        writer.writeText(value,null);
      }
      writer.writeText(item,null);
    }
  }
  strategy.encodeItemEnd(facesContext,comboBox);
}"
18170,"public AbstractTogglePanelItem getItem(String name){
  if (""String_Node_Str"".equals(name)) {
    return getFirstItem();
  }
 else   if (""String_Node_Str"".equals(name)) {
    return getPrevItem();
  }
 else   if (""String_Node_Str"".equals(name)) {
    return getNextItem();
  }
 else   if (""String_Node_Str"".equals(name)) {
    return getLastItem();
  }
 else {
    return getItemByIndex(getChildIndex(name));
  }
}","public AbstractTogglePanelItem getItem(String name){
  if (META_NAME_FIRST.equals(name)) {
    return getFirstItem();
  }
 else   if (META_NAME_PREV.equals(name)) {
    return getPrevItem();
  }
 else   if (META_NAME_NEXT.equals(name)) {
    return getNextItem();
  }
 else   if (META_NAME_LAST.equals(name)) {
    return getLastItem();
  }
 else {
    return getItemByIndex(getChildIndex(name));
  }
}"
18171,"protected static void hidePanelItem(UIComponent item){
  item.getAttributes().put(RendererUtils.HTML.STYLE_ATTRIBUTE,""String_Node_Str"");
}","protected static void hidePanelItem(UIComponent item){
  Map<String,Object> attrs=item.getAttributes();
  Object style=attrs.get(RendererUtils.HTML.STYLE_ATTRIBUTE);
  attrs.put(RendererUtils.HTML.STYLE_ATTRIBUTE,""String_Node_Str"" + style);
}"
18172,"public String getName(){
  return (String)getStateHelper().eval(PropertyKeys.name);
}","public String getName(){
  return (String)getStateHelper().eval(PropertyKeys.name,getId());
}"
18173,"public String getTargetItem(){
  return (String)getStateHelper().eval(PropertyKeys.targetItem);
}","public String getTargetItem(){
  return (String)getStateHelper().eval(PropertyKeys.targetItem,AbstractTogglePanel.META_NAME_NEXT);
}"
18174,"/** 
 * <p><span class=""changed_modified_2_0"">Call</span> through to the  {@link MethodExpression} passed in our constructor.  <spanclass=""changed_added_2_0"">First, try to invoke the <code>MethodExpression</code> passed to the constructor of this instance, passing the argument  {@link ItemChangeEvent} as theargument.  If a  {@link MethodNotFoundException} is thrown, callto the zero argument <code>MethodExpression</code> derived from the <code>MethodExpression</code> passed to the constructor of this instance.  If that fails for any reason, throw an  {@link AbortProcessingException}, including the cause of the failure.</span></p>
 * @throws NullPointerException {@inheritDoc}
 * @throws AbortProcessingException {@inheritDoc}
 */
public void processItemChange(ItemChangeEvent itemChangeEvent) throws AbortProcessingException {
  if (itemChangeEvent == null) {
    throw new NullPointerException();
  }
  FacesContext context=FacesContext.getCurrentInstance();
  ELContext elContext=context.getELContext();
  try {
    methodExpressionOneArg.invoke(elContext,new Object[]{itemChangeEvent});
  }
 catch (  MethodNotFoundException mnf) {
    if (null != methodExpressionZeroArg) {
      try {
        methodExpressionZeroArg.invoke(elContext,NO_PARAMS);
      }
 catch (      ELException e) {
        throw new AbortProcessingException(e.getMessage(),e.getCause());
      }
    }
  }
catch (  ELException e) {
    throw new AbortProcessingException(e.getMessage(),e.getCause());
  }
}","public void processItemChange(ItemChangeEvent itemChangeEvent) throws AbortProcessingException {
  processEvent(itemChangeEvent);
}"
18175,"/** 
 * <p>Construct a   {@link ItemChangeListener} that contains a {@link MethodExpression}.</p>
 * @param methodExpressionOneArg
 * @param methodExpressionZeroArg
 */
public MethodExpressionItemChangeListener(MethodExpression methodExpressionOneArg,MethodExpression methodExpressionZeroArg){
  super();
  this.methodExpressionOneArg=methodExpressionOneArg;
  this.methodExpressionZeroArg=methodExpressionZeroArg;
}","public MethodExpressionItemChangeListener(MethodExpression methodExprOneArg,MethodExpression methodExprZeroArg){
  super(methodExprOneArg,methodExprZeroArg);
}"
18176,"private void encodeHeader(FacesContext facesContext,UIComponent component,ResponseWriter writer,String state,Boolean isDisplay) throws IOException {
  writer.startElement(""String_Node_Str"",component);
  if (!isDisplay) {
    writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String name=""String_Node_Str"" + capitalize(state);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + state + ""String_Node_Str""+ attributeAsString(component,name),name);
  UIComponent headerFacet=component.getFacet(""String_Node_Str"" + capitalize(state));
  if (headerFacet != null && headerFacet.isRendered()) {
    headerFacet.encodeAll(facesContext);
  }
 else {
    Object headerText=component.getAttributes().get(""String_Node_Str"");
    if (headerText != null && !headerText.equals(""String_Node_Str"")) {
      writer.writeText(headerText,null);
    }
  }
  writer.endElement(""String_Node_Str"");
}","private void encodeHeader(FacesContext facesContext,AbstractTogglePanelTitledItem component,ResponseWriter writer,HeaderStates state,Boolean isDisplay) throws IOException {
  writer.startElement(""String_Node_Str"",component);
  if (!isDisplay) {
    writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String name=""String_Node_Str"" + capitalize(state.toString());
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + state + ""String_Node_Str""+ attributeAsString(component,name),name);
  UIComponent headerFacet=component.getHeaderFacet(state);
  if (headerFacet != null && headerFacet.isRendered()) {
    headerFacet.encodeAll(facesContext);
  }
 else {
    Object headerText=component.getAttributes().get(""String_Node_Str"");
    if (headerText != null && !headerText.equals(""String_Node_Str"")) {
      writer.writeText(headerText,null);
    }
  }
  writer.endElement(""String_Node_Str"");
}"
18177,"protected HeaderMappingsDesc loadHeaderMappings(String adminName,OptionList options,boolean inbound) throws ServiceCreationException {
  if (options == null) {
    return HeaderMappingsDesc.EMPTY_MAPPINGS;
  }
  List<NameValue> nameValueList=options.getOption();
  Map<String,String> headerMap=new HashMap<String,String>();
  Set<String> suppressHeaderSet=new HashSet<String>();
  for (  NameValue nv : nameValueList) {
    String rawname=nv.getName();
    String name=SOAHeaders.normalizeName(rawname,true);
    if (inbound && !SOAHeaders.isSOAHeader(name)) {
      throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_INVALID_HEADER_NAME,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,name}));
    }
    String value=nv.getValue();
    if (value.startsWith(""String_Node_Str"")) {
      if (!value.endsWith(""String_Node_Str"")) {
        throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_INVALID_MAPPING_VALUE,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,value}));
      }
      String indexval=value.substring(7,value.length() - 1);
      if (inbound) {
        if (headerMap.containsKey(indexval)) {
          throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_DUPLICATE_HEADER_KEY,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,indexval}));
        }
        headerMap.put(indexval,name);
      }
 else {
        if (headerMap.containsKey(indexval)) {
          throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_DUPLICATE_HEADER_KEY,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,indexval}));
        }
        headerMap.put(name,indexval);
      }
    }
 else     if (value.equals(""String_Node_Str"")) {
      suppressHeaderSet.add(name);
    }
 else {
      throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_INVALID_MAPPING_VALUE,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,value}));
    }
  }
  HeaderMappingsDesc result=new HeaderMappingsDesc(headerMap,suppressHeaderSet);
  return result;
}","protected HeaderMappingsDesc loadHeaderMappings(String adminName,OptionList options,boolean inbound) throws ServiceCreationException {
  if (options == null) {
    return HeaderMappingsDesc.EMPTY_MAPPINGS;
  }
  List<NameValue> nameValueList=options.getOption();
  Map<String,String> headerMap=new HashMap<String,String>();
  Set<String> suppressHeaderSet=new HashSet<String>();
  for (  NameValue nv : nameValueList) {
    String rawname=nv.getName();
    String name=SOAHeaders.normalizeName(rawname,true);
    if (inbound && !SOAHeaders.isSOAHeader(name)) {
      throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_INVALID_HEADER_NAME,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,name}));
    }
    String value=nv.getValue();
    if (value.startsWith(""String_Node_Str"")) {
      if (!value.endsWith(""String_Node_Str"")) {
        throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_INVALID_MAPPING_VALUE,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,value}));
      }
      String indexval=value.substring(7,value.length() - 1);
      if (inbound) {
        if (headerMap.containsKey(indexval)) {
          throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_DUPLICATE_HEADER_KEY,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,indexval}));
        }
        headerMap.put(indexval.toUpperCase(),name);
      }
 else {
        if (headerMap.containsKey(indexval)) {
          throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_DUPLICATE_HEADER_KEY,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,indexval}));
        }
        headerMap.put(name,indexval);
      }
    }
 else     if (value.equals(""String_Node_Str"")) {
      suppressHeaderSet.add(name);
    }
 else {
      throw new ServiceCreationException(ErrorDataFactory.createErrorData(ErrorConstants.SVC_FACTORY_INVALID_MAPPING_VALUE,ErrorConstants.ERRORDOMAIN,new Object[]{adminName,value}));
    }
  }
  HeaderMappingsDesc result=new HeaderMappingsDesc(headerMap,suppressHeaderSet);
  return result;
}"
18178,"@Test public void testPersistErrors() throws ServiceException {
  List<CommonErrorData> errorsToStore=createTestCommonErrorDataList(1);
  String serverName=""String_Node_Str"";
  String srvcAdminName=""String_Node_Str"";
  String opName=""String_Node_Str"";
  boolean serverSide=true;
  String consumerName=""String_Node_Str"";
  long now=System.currentTimeMillis();
  Map<String,String> options=createOptionsMap();
  InitContext ctx=new MockInitContext(options);
  logHandler.init(ctx);
  logHandler.persistErrors(errorsToStore,serverName,srvcAdminName,opName,serverSide,consumerName,now);
  ColumnSlice<Object,Object> errorColumnSlice=getColumnValues(kspace,""String_Node_Str"",new Long(0),StringSerializer.get(),StringSerializer.get(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertValues(errorColumnSlice,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ColumnSlice<Object,Object> longColumnSlice=getColumnValues(kspace,""String_Node_Str"",new Long(0),StringSerializer.get(),LongSerializer.get(),""String_Node_Str"");
  assertValues(longColumnSlice,""String_Node_Str"",new Long(0));
  ColumnSlice<Object,Object> categoryCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(categoryCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> categoryCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(categoryCountAllOpsColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(severityCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(severityCountAllOpsColumnSlice,now,""String_Node_Str"");
}","@Test public void testPersistErrors() throws ServiceException {
  List<CommonErrorData> errorsToStore=createTestCommonErrorDataList(1);
  String serverName=""String_Node_Str"";
  String srvcAdminName=""String_Node_Str"";
  String opName=""String_Node_Str"";
  boolean serverSide=true;
  String consumerName=""String_Node_Str"";
  long now=System.currentTimeMillis();
  Map<String,String> options=createOptionsMap();
  InitContext ctx=new MockInitContext(options);
  logHandler.init(ctx);
  logHandler.persistErrors(errorsToStore,serverName,srvcAdminName,opName,serverSide,consumerName,now);
  ColumnSlice<Object,Object> errorColumnSlice=getColumnValues(kspace,""String_Node_Str"",Long.valueOf(0),StringSerializer.get(),StringSerializer.get(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertValues(errorColumnSlice,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ColumnSlice<Object,Object> longColumnSlice=getColumnValues(kspace,""String_Node_Str"",Long.valueOf(0),StringSerializer.get(),LongSerializer.get(),""String_Node_Str"");
  assertValues(longColumnSlice,""String_Node_Str"",Long.valueOf(0));
  ColumnSlice<Object,Object> categoryCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(categoryCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> categoryCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(categoryCountAllOpsColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(severityCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(severityCountAllOpsColumnSlice,now,""String_Node_Str"");
}"
18179,"public List<CommonErrorData> createTestCommonErrorDataList(int errorQuantity){
  List<CommonErrorData> commonErrorDataList=new ArrayList<CommonErrorData>();
  for (int i=0; i < errorQuantity; i++) {
    CommonErrorData e=new CommonErrorData();
    e.setCategory(ErrorCategory.APPLICATION);
    e.setSeverity(ErrorSeverity.ERROR);
    e.setCause(""String_Node_Str"");
    e.setDomain(""String_Node_Str"");
    e.setSubdomain(""String_Node_Str"");
    e.setErrorName(""String_Node_Str"");
    e.setErrorId(new Long(i));
    e.setMessage(""String_Node_Str"" + i);
    e.setOrganization(""String_Node_Str"");
    commonErrorDataList.add(e);
  }
  return commonErrorDataList;
}","public List<CommonErrorData> createTestCommonErrorDataList(int errorQuantity){
  List<CommonErrorData> commonErrorDataList=new ArrayList<CommonErrorData>();
  for (int i=0; i < errorQuantity; i++) {
    CommonErrorData e=new CommonErrorData();
    e.setCategory(ErrorCategory.APPLICATION);
    e.setSeverity(ErrorSeverity.ERROR);
    e.setCause(""String_Node_Str"");
    e.setDomain(""String_Node_Str"");
    e.setSubdomain(""String_Node_Str"");
    e.setErrorName(""String_Node_Str"");
    e.setErrorId(Long.valueOf(i));
    e.setMessage(""String_Node_Str"" + i);
    e.setOrganization(""String_Node_Str"");
    commonErrorDataList.add(e);
  }
  return commonErrorDataList;
}"
18180,"@Test public void testSaveErrorCounts(){
  Long now=System.currentTimeMillis();
  Error errorToSave=new Error();
  errorToSave.setCategory(ErrorCategory.REQUEST.toString());
  errorToSave.setSeverity(ErrorSeverity.ERROR.toString());
  errorToSave.setDomain(""String_Node_Str"");
  errorToSave.setErrorId(new Long(123));
  errorToSave.setName(""String_Node_Str"");
  errorToSave.setOrganization(""String_Node_Str"");
  errorToSave.setSubDomain(""String_Node_Str"");
  ErrorValue errorValue=new ErrorValue();
  errorValue.setErrorId(new Long(123));
  errorValue.setConsumerName(""String_Node_Str"");
  errorValue.setErrorMessage(""String_Node_Str"");
  errorValue.setOperationName(""String_Node_Str"");
  errorValue.setServerName(""String_Node_Str"");
  errorValue.setServerSide(true);
  errorValue.setServiceAdminName(""String_Node_Str"");
  errorValue.setTimeStamp(now);
  int errorCountToStore=1;
  String errorValueKey=""String_Node_Str"";
  dao.saveErrorCounts(errorToSave,errorValue,errorValueKey,now,errorCountToStore);
  ColumnSlice<Object,Object> categoryCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(categoryCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> categoryCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(categoryCountAllOpsColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(severityCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),new Long(now));
  assertValues(severityCountAllOpsColumnSlice,now,""String_Node_Str"");
}","@Test public void testSaveErrorCounts(){
  Long now=System.currentTimeMillis();
  Error errorToSave=new Error();
  errorToSave.setCategory(ErrorCategory.REQUEST.toString());
  errorToSave.setSeverity(ErrorSeverity.ERROR.toString());
  errorToSave.setDomain(""String_Node_Str"");
  errorToSave.setErrorId(Long.valueOf(123));
  errorToSave.setName(""String_Node_Str"");
  errorToSave.setOrganization(""String_Node_Str"");
  errorToSave.setSubDomain(""String_Node_Str"");
  ErrorValue errorValue=new ErrorValue();
  errorValue.setErrorId(Long.valueOf(123));
  errorValue.setConsumerName(""String_Node_Str"");
  errorValue.setErrorMessage(""String_Node_Str"");
  errorValue.setOperationName(""String_Node_Str"");
  errorValue.setServerName(""String_Node_Str"");
  errorValue.setServerSide(true);
  errorValue.setServiceAdminName(""String_Node_Str"");
  errorValue.setTimeStamp(now);
  int errorCountToStore=1;
  String errorValueKey=""String_Node_Str"";
  dao.saveErrorCounts(errorToSave,errorValue,errorValueKey,now,errorCountToStore);
  ColumnSlice<Object,Object> categoryCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(categoryCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> categoryCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(categoryCountAllOpsColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(severityCountColumnSlice,now,""String_Node_Str"");
  ColumnSlice<Object,Object> severityCountAllOpsColumnSlice=getColumnValues(kspace,""String_Node_Str"",""String_Node_Str"",LongSerializer.get(),StringSerializer.get(),Long.valueOf(now));
  assertValues(severityCountAllOpsColumnSlice,now,""String_Node_Str"");
}"
18181,"@Test public void testJaxbXmlNoRoot() throws Exception {
  MyObject msg=new MyObject();
  msg.setId(12345);
  HashMap<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  ISerializerFactory serFactory=new XMLSerializerFactory();
  serFactory.init(new TestSerInitContext(options));
  IDeserializerFactory deserFactory=new XMLDeserializerFactory();
  deserFactory.init(new TestDeserInitContext(options));
  doTest(msg,BindingConstants.PAYLOAD_XML,SOAConstants.MIME_XML,serFactory,deserFactory,""String_Node_Str"");
}","@Test public void testJaxbXmlNoRoot() throws Exception {
  MyObject msg=new MyObject();
  msg.setId(12345);
  HashMap<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  ISerializerFactory serFactory=new XMLSerializerFactory();
  serFactory.init(new TestSerInitContext(options));
  IDeserializerFactory deserFactory=new XMLDeserializerFactory();
  deserFactory.init(new TestDeserInitContext(options));
  doTest(msg,BindingConstants.PAYLOAD_XML,SOAConstants.MIME_XML,serFactory,deserFactory,""String_Node_Str"" + Charset.defaultCharset().displayName() + ""String_Node_Str"");
}"
18182,"@Test public void testJaxbXmlNoRootFalse() throws Exception {
  MyObject msg=new MyObject();
  msg.setId(12345);
  HashMap<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  ISerializerFactory serFactory=new XMLSerializerFactory();
  serFactory.init(new TestSerInitContext(options));
  IDeserializerFactory deserFactory=new XMLDeserializerFactory();
  deserFactory.init(new TestDeserInitContext(options));
  doTest(msg,BindingConstants.PAYLOAD_XML,SOAConstants.MIME_XML,serFactory,deserFactory,""String_Node_Str"");
}","@Test public void testJaxbXmlNoRootFalse() throws Exception {
  MyObject msg=new MyObject();
  msg.setId(12345);
  HashMap<String,String> options=new HashMap<String,String>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  ISerializerFactory serFactory=new XMLSerializerFactory();
  serFactory.init(new TestSerInitContext(options));
  IDeserializerFactory deserFactory=new XMLDeserializerFactory();
  deserFactory.init(new TestDeserInitContext(options));
  doTest(msg,BindingConstants.PAYLOAD_XML,SOAConstants.MIME_XML,serFactory,deserFactory,""String_Node_Str"" + Charset.defaultCharset().displayName() + ""String_Node_Str"");
}"
18183,"private boolean ableToCreatePlayers(){
  StartDialog dialog=new StartDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
  dialog.open();
  if (dialog.getReturnCode() == Dialog.OK) {
    leftProgrammer.resetStats();
    rightProgrammer.resetStats();
    leftProgrammer.setName(dialog.getPlayerOneName());
    rightProgrammer.setName(dialog.getPlayerTwoName());
    leftProgrammer.setAvatar(dialog.getPlayerOneAvatar());
    rightProgrammer.setAvatar(dialog.getPlayerTwoAvatar());
    return true;
  }
  return false;
}","private boolean ableToCreatePlayers(){
  StartDialog dialog=new StartDialog(PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell());
  dialog.open();
  if (dialog.getReturnCode() == Dialog.OK) {
    leftProgrammer.resetStats();
    rightProgrammer.resetStats();
    leftProgrammer.setName(dialog.getPlayerOneName());
    rightProgrammer.setName(dialog.getPlayerTwoName());
    leftProgrammer.setAvatar(dialog.getPlayerOneAvatar());
    rightProgrammer.setAvatar(dialog.getPlayerTwoAvatar());
    scoreboard.resetStats();
    updateScore(scoreboard.getScore());
    return true;
  }
  return false;
}"
18184,"public Stream<JsonElement> map(BiFunction<String,JsonElement,JsonElement> f){
  return entrySet().stream().map(e -> f.apply(e.getKey(),e.getValue()));
}","public void map(BiFunction<String,JsonElement,JsonElement> f){
  entrySet().stream().forEach(e -> {
    put(e.getKey(),f.apply(e.getKey(),e.getValue()));
  }
);
}"
18185,"public void shouldRecurseOverAllNestedMapElements(){
  JsonObject object=object(field(""String_Node_Str"",""String_Node_Str""),field(""String_Node_Str"",""String_Node_Str""),field(""String_Node_Str"",array(object(field(""String_Node_Str"",1)))),field(""String_Node_Str"",object(field(""String_Node_Str"",42))));
  AtomicInteger counter=new AtomicInteger();
  object.forEachPrimitiveRecursive((k,v) -> {
    counter.incrementAndGet();
  }
);
  assertThat(counter.get()).isEqualTo(4);
}","public void shouldRecurseOverAllNestedMapElements(){
  JsonObject object=object(field(""String_Node_Str"",""String_Node_Str""),field(""String_Node_Str"",""String_Node_Str""),field(""String_Node_Str"",array(object(field(""String_Node_Str"",1)))),field(""String_Node_Str"",array(object(field(""String_Node_Str"",1)))),field(""String_Node_Str"",object(field(""String_Node_Str"",42))));
  AtomicInteger counter=new AtomicInteger();
  object.forEachPrimitiveRecursive((k,v) -> {
    counter.incrementAndGet();
  }
);
  assertThat(counter.get()).isEqualTo(5);
}"
18186,"/** 
 * @param t1
 * @param t2
 * @return true if t1 equals t2
 */
boolean equals(JsonElement t1,JsonElement t2);","/** 
 * @param t1 first element
 * @param t2 second element
 * @return true if t1 equals t2
 */
boolean equals(JsonElement t1,JsonElement t2);"
18187,"public JsonElement get(){
  return stack.getLast();
}","public JsonElement get(){
  if (stack.size() == 0) {
    throw new JsonParseException(""String_Node_Str"");
  }
  return stack.getLast();
}"
18188,"private JsonElement parseContent(com.fasterxml.jackson.core.JsonParser parser) throws IOException, com.fasterxml.jackson.core.JsonParseException {
  JsonHandler handler=new JsonHandler();
  LinkedList<Boolean> stack=new LinkedList<>();
  JsonToken nextToken;
  handler.startJSON();
  while ((nextToken=parser.nextToken()) != null) {
switch (nextToken) {
case START_OBJECT:
      handler.startObject();
    break;
case END_OBJECT:
  handler.endObject();
endObjEntryIfNeeded(handler,stack);
break;
case START_ARRAY:
handler.startArray();
stack.push(false);
break;
case END_ARRAY:
handler.endArray();
stack.pop();
endObjEntryIfNeeded(handler,stack);
break;
case FIELD_NAME:
handler.startObjectEntry(parser.getText());
stack.push(true);
break;
case VALUE_NUMBER_INT:
handler.primitive(parser.getLongValue());
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_NUMBER_FLOAT:
handler.primitive(parser.getDoubleValue());
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_STRING:
handler.primitive(parser.getText());
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_NULL:
handler.primitive(null);
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_TRUE:
handler.primitive(true);
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_FALSE:
handler.primitive(false);
endObjEntryIfNeeded(handler,stack);
break;
default :
throw new IllegalStateException(""String_Node_Str"" + nextToken);
}
}
handler.endJSON();
return handler.get();
}","private JsonElement parseContent(com.fasterxml.jackson.core.JsonParser parser) throws IOException, com.fasterxml.jackson.core.JsonParseException {
  JsonHandler handler=new JsonHandler();
  LinkedList<Boolean> stack=new LinkedList<>();
  JsonToken nextToken;
  handler.startJSON();
  while ((nextToken=parser.nextToken()) != null) {
switch (nextToken) {
case START_OBJECT:
      handler.startObject();
    break;
case END_OBJECT:
  handler.endObject();
endObjEntryIfNeeded(handler,stack);
break;
case START_ARRAY:
handler.startArray();
stack.push(false);
break;
case END_ARRAY:
handler.endArray();
stack.pop();
endObjEntryIfNeeded(handler,stack);
break;
case FIELD_NAME:
handler.startObjectEntry(parser.getText());
stack.push(true);
break;
case VALUE_NUMBER_INT:
handler.primitive(parser.getLongValue());
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_NUMBER_FLOAT:
handler.primitive(parser.getDoubleValue());
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_STRING:
handler.primitive(parser.getText());
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_NULL:
handler.primitive(null);
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_TRUE:
handler.primitive(true);
endObjEntryIfNeeded(handler,stack);
break;
case VALUE_FALSE:
handler.primitive(false);
endObjEntryIfNeeded(handler,stack);
break;
case NOT_AVAILABLE:
break;
case VALUE_EMBEDDED_OBJECT:
throw new IllegalStateException(""String_Node_Str"" + nextToken);
default :
throw new IllegalStateException(""String_Node_Str"" + nextToken);
}
}
handler.endJSON();
return handler.get();
}"
18189,"/** 
 * @param value
 * @return a JsonPrimitive with the value
 */
public static JsonPrimitive primitive(final Object value){
  return new JsonPrimitive(value);
}","/** 
 * @param value
 * @return a JsonPrimitive with the value
 */
public static JsonPrimitive primitive(final Object value){
  if (value instanceof JsonPrimitive) {
    return ((JsonPrimitive)value).deepClone();
  }
  return new JsonPrimitive(value);
}"
18190,"@Override public boolean equals(final Object o){
  if (o == null) {
    return false;
  }
  if (!(o instanceof JsonArray)) {
    return false;
  }
  JsonArray array=(JsonArray)o;
  if (size() != array.size()) {
    return false;
  }
  for (  JsonElement jsonElement : array) {
    if (!contains(jsonElement)) {
      return false;
    }
  }
  return true;
}","@Override public boolean equals(final Object o){
  if (o == null) {
    return false;
  }
  if (!(o instanceof JsonArray)) {
    return false;
  }
  JsonArray array=(JsonArray)o;
  if (size() != array.size()) {
    return false;
  }
  for (int i=0; i < size(); i++) {
    if (!get(i).equals(array.get(i))) {
      return false;
    }
  }
  return true;
}"
18191,"@Override public boolean endObjectEntry() throws ParseException, IOException {
  JsonElement value=stack.pollLast();
  JsonElement key=stack.pollLast();
  JsonObject container=stack.peekLast().asObject();
  container.put(key.toString(),value);
  return true;
}","@Override public boolean endObjectEntry() throws ParseException, IOException {
  JsonElement value=stack.pollLast();
  JsonElement e=stack.peekLast();
  if (e.isPrimitive()) {
    e=stack.pollLast();
    JsonElement last=stack.peekLast();
    if (last.isObject()) {
      JsonObject container=last.asObject();
      container.put(e.toString(),value);
    }
 else     if (last.isArray()) {
      System.out.println(""String_Node_Str"" + value + ""String_Node_Str""+ e+ ""String_Node_Str""+ last);
    }
  }
 else   if (e.isArray()) {
    e.asArray().add(value);
  }
 else {
    System.out.println(e);
  }
  return true;
}"
18192,"@Override public boolean endArray() throws ParseException, IOException {
  return true;
}","@Override public boolean endArray() throws ParseException, IOException {
  if (stack.size() > 3) {
    System.out.println(stack);
    JsonElement value=stack.pollLast();
    if (value.isArray()) {
      JsonElement e=stack.peekLast();
      if (e.isArray()) {
        e.asArray().add(value);
      }
 else {
        JsonPrimitive key=e.asPrimitive();
        JsonElement last=stack.peekLast();
        if (last.isObject()) {
          JsonObject container=last.asObject();
          container.put(key.toString(),value);
        }
 else {
          throw new IllegalStateException(""String_Node_Str"");
        }
      }
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  return true;
}"
18193,"@Override public boolean endObject() throws ParseException, IOException {
  return true;
}","@Override public boolean endObject() throws ParseException, IOException {
  if (stack.size() > 1 && stack.get(stack.size() - 2).isArray()) {
    JsonElement object=stack.pollLast();
    stack.peekLast().asArray().add(object);
  }
  return true;
}"
18194,"@DataProvider public Object[][] goodJson(){
  return new Object[][]{{object().put(""String_Node_Str"",1).get()},{object().put(""String_Node_Str"",true).get()},{object().put(""String_Node_Str"",""String_Node_Str"").get()},{object().put(""String_Node_Str"",""String_Node_Str"").get()},{object().put(""String_Node_Str"",(String)null).get()},{object().put(""String_Node_Str"",array(""String_Node_Str"")).get()},{object().put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).get()},{object().put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).put(""String_Node_Str"",""String_Node_Str"").get()},{object().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).get()},{object().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).put(""String_Node_Str"",object().get()).get()},{object().get()},{new JsonArray()},{primitive(true)},{primitive(false)},{primitive(42)},{primitive(42.0)},{primitive(""String_Node_Str"")},{array(""String_Node_Str"")},{array(""String_Node_Str"",""String_Node_Str"")}};
}","@DataProvider public Object[][] goodJson(){
  return new Object[][]{{object().put(""String_Node_Str"",1).get()},{object().put(""String_Node_Str"",true).get()},{object().put(""String_Node_Str"",""String_Node_Str"").get()},{object().put(""String_Node_Str"",""String_Node_Str"").get()},{object().put(""String_Node_Str"",(String)null).get()},{object().put(""String_Node_Str"",array(""String_Node_Str"")).get()},{object().put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).get()},{object().put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).put(""String_Node_Str"",""String_Node_Str"").get()},{object().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).get()},{object().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"")).put(""String_Node_Str"",object().get()).get()},{object().get()},{new JsonArray()},{primitive(true)},{primitive(false)},{primitive(42)},{primitive(42.0)},{primitive(""String_Node_Str"")},{array(""String_Node_Str"")},{array(""String_Node_Str"",""String_Node_Str"")},{object().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",array(primitive(""String_Node_Str""),primitive(""String_Node_Str""),object().put(""String_Node_Str"",""String_Node_Str"").get(),array(""String_Node_Str""))).put(""String_Node_Str"",42).put(""String_Node_Str"",42.0).put(""String_Node_Str"",true).put(""String_Node_Str"",nullValue()).put(""String_Node_Str"",array(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")).get()}};
}"
18195,"/** 
 * {@inheritDoc}
 * @see org.easysoa.frascati.api.FraSCAtiServiceItf#processComposite(java.lang.String)
 */
public Composite processComposite(String composite) throws FraSCAtiServiceException {
  return processComposite(composite,FraSCAtiServiceItf.all,null);
}","/** 
 * {@inheritDoc}
 * @see org.easysoa.frascati.api.FraSCAtiServiceItf#processComposite(java.lang.String)
 */
public Composite processComposite(String composite) throws FraSCAtiServiceException {
  return processComposite(composite,FraSCAtiServiceItf.all,new Properties());
}"
18196,"/** 
 * Start the filter
 * @param httpExchangeHandler The http exchange handler to use for exchange recording
 * @throws Exception If a problem occurs
 */
void start(HttpExchangeHandler httpExchangeHandler) throws Exception ;","/** 
 * Start the filter
 * @param httpExchangeHandler The http exchange handler to use for exchange recording
 * @throws Exception If a problem occurs
 */
void start(MessageHandler httpExchangeHandler) throws Exception ;"
18197,"/** 
 * Process the filter 
 */
public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  if (exchangeHandler != null) {
    logger.info(""String_Node_Str"");
    if (!(request instanceof CopyHttpServletResponse)) {
      request=new CopyHttpServletRequest((HttpServletRequest)request);
    }
    if (!(response instanceof CopyHttpServletResponse)) {
      response=new CopyHttpServletResponse((HttpServletResponse)response);
    }
  }
  chain.doFilter(request,response);
  if (exchangeHandler != null) {
    if (request instanceof HttpServletRequest) {
      try {
        InMessage inMessage=new InMessage((CopyHttpServletRequest)request);
        OutMessage outMessage=new OutMessage((CopyHttpServletResponse)response);
        this.exchangeHandler.handleMessage(inMessage,outMessage);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * Process the filter
 */
public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  if (exchangeHandler != null) {
    logger.info(""String_Node_Str"");
    if (!(request instanceof CopyHttpServletResponse)) {
      request=new CopyHttpServletRequest((HttpServletRequest)request);
    }
    if (!(response instanceof CopyHttpServletResponse)) {
      response=new CopyHttpServletResponse((HttpServletResponse)response);
    }
  }
  chain.doFilter(request,response);
  if (exchangeHandler != null) {
    if (request instanceof HttpServletRequest) {
      try {
        InMessage inMessage=new InMessage((CopyHttpServletRequest)request);
        OutMessage outMessage=new OutMessage((CopyHttpServletResponse)response);
        this.exchangeHandler.handleMessage(inMessage,outMessage);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}"
18198,"/** 
 * Start the mining
 */
public void start(HttpExchangeHandler exchangeHandler) throws Exception {
  if (singleton != null) {
    logger.info(""String_Node_Str"" + exchangeHandler.toString());
    singleton.exchangeHandler=exchangeHandler;
  }
 else {
    logger.warn(""String_Node_Str"");
  }
}","/** 
 * Start the mining
 */
public void start(MessageHandler exchangeHandler) throws Exception {
  if (singleton != null) {
    logger.info(""String_Node_Str"" + exchangeHandler.toString());
    singleton.exchangeHandler=exchangeHandler;
  }
 else {
    logger.warn(""String_Node_Str"");
  }
}"
18199,"public void handleExchange(HttpServletRequest request,HttpServletResponse response) throws Exception {
  if (enabled) {
    CopyHttpServletRequest requestWrapper=new CopyHttpServletRequest(request);
    CopyHttpServletResponse responseWrapper;
    if (response instanceof CopyHttpServletResponse) {
      responseWrapper=(CopyHttpServletResponse)response;
    }
 else {
      responseWrapper=new CopyHttpServletResponse(response);
    }
    InMessage inMessage=new InMessage(requestWrapper);
    OutMessage outMessage=new OutMessage(responseWrapper);
    this.handleMessage(inMessage,outMessage);
  }
}","@Deprecated public void handleExchange(HttpServletRequest request,HttpServletResponse response) throws Exception {
  if (enabled) {
    CopyHttpServletRequest requestWrapper=new CopyHttpServletRequest(request);
    CopyHttpServletResponse responseWrapper;
    if (response instanceof CopyHttpServletResponse) {
      responseWrapper=(CopyHttpServletResponse)response;
    }
 else {
      responseWrapper=new CopyHttpServletResponse(response);
    }
    InMessage inMessage=new InMessage(requestWrapper);
    OutMessage outMessage=new OutMessage(responseWrapper);
    this.handleMessage(inMessage,outMessage);
  }
}"
18200,"/** 
 * Test the EasySOAv1SOAPDiscoveryMessageHandler with a SOAP Post request
 * @throws Exception
 */
@Test public void SoapDiscoveryMessageHandlerTest() throws Exception {
  Component comp=frascati.getComposite(""String_Node_Str"");
  HandlerManager handler=frascati.getService(comp,""String_Node_Str"",HandlerManager.class);
  PropertyManager pm=new PropertyManager(""String_Node_Str"");
  String soapRequestContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ProxyConfiguration proxyConf=new ProxyConfiguration();
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.ENVIRONMENT_PARAM_NAME,""String_Node_Str"");
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.PROJECTID_PARAM_NAME,""String_Node_Str"");
  ExchangeRecord record=new ExchangeRecord();
  record.setExchange(new Exchange());
  record.setInMessage(new InMessage());
  record.setOutMessage(new OutMessage());
  record.getInMessage().setProtocol(""String_Node_Str"");
  record.getInMessage().setMethod(""String_Node_Str"");
  record.getInMessage().setPath(""String_Node_Str"");
  record.getInMessage().setServer(""String_Node_Str"");
  record.getInMessage().setRemoteHost(""String_Node_Str"");
  record.getInMessage().setRemoteAddress(""String_Node_Str"");
  MessageContent messageContent=new MessageContent();
  messageContent.setRawContent(soapRequestContent);
  record.getInMessage().setMessageContent(messageContent);
  handler.setHandlerConfiguration(proxyConf);
  Map<String,HandlerResponse> handlerResponses=handler.handleMessage(record.getInMessage(),record.getOutMessage());
  Assert.assertEquals(5,handlerResponses.size());
}","/** 
 * Test the EasySOAv1SOAPDiscoveryMessageHandler with a SOAP Post request
 * @throws Exception
 */
@Test public void SoapDiscoveryMessageHandlerTest() throws Exception {
  Component comp=frascati.getComposite(""String_Node_Str"");
  HandlerManager handler=frascati.getService(comp,""String_Node_Str"",HandlerManager.class);
  PropertyManager pm=new PropertyManager(""String_Node_Str"");
  String soapRequestContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ProxyConfiguration proxyConf=new ProxyConfiguration();
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.ENVIRONMENT_PARAM_NAME,""String_Node_Str"");
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.PROJECTID_PARAM_NAME,""String_Node_Str"");
  ExchangeRecord record=new ExchangeRecord();
  record.setExchange(new Exchange());
  record.setInMessage(new InMessage());
  record.setOutMessage(new OutMessage());
  record.getInMessage().setProtocol(""String_Node_Str"");
  record.getInMessage().setMethod(""String_Node_Str"");
  record.getInMessage().setPath(""String_Node_Str"");
  record.getInMessage().setServer(""String_Node_Str"");
  record.getInMessage().setRemoteHost(""String_Node_Str"");
  record.getInMessage().setRemoteAddress(""String_Node_Str"");
  MessageContent messageContent=new MessageContent();
  messageContent.setRawContent(soapRequestContent);
  record.getInMessage().setMessageContent(messageContent);
  handler.setHandlerConfiguration(proxyConf);
  Map<String,HandlerResponse> handlerResponses=handler.handleMessage(record.getInMessage(),record.getOutMessage());
  Assert.assertEquals(4,handlerResponses.size());
}"
18201,"@Override public void handleMessage(InMessage inMessage,OutMessage outMessage) throws Exception {
  if (enabled && hasValidConfiguration()) {
    boolean isSoapMessage=checkForSoapMessage(inMessage);
    boolean isGetWsdlMessage=!isSoapMessage || checkForWsdlMessage(inMessage);
    if (isSoapMessage || isGetWsdlMessage) {
      if (registryClient == null) {
        RegistryJerseyClientConfiguration jerseyClient=new RegistryJerseyClientConfiguration();
        registryClient=jerseyClient.getClient();
      }
      RegistryApi registryApi=registryClient.constructRegistryApi();
      Map<String,Serializable> properties=new HashMap<String,Serializable>();
      List<SoaNodeId> parents=new ArrayList<SoaNodeId>();
      URI uriToNormalize=new URI(inMessage.buildCompleteUrl());
      String messageUrl=uriToNormalize.normalize().toString();
      String endpointUrl=isSoapMessage ? messageUrl : messageUrl.substring(0,messageUrl.length() - 5);
      String wsdlUrl=isGetWsdlMessage ? messageUrl : messageUrl + ""String_Node_Str"";
      properties.put(Endpoint.XPATH_URL,endpointUrl);
      properties.put(Endpoint.XPATH_TITLE,environment + ""String_Node_Str"" + endpointUrl);
      properties.put(Endpoint.XPATH_ENDP_ENVIRONMENT,environment);
      properties.put(Subproject.XPATH_SUBPROJECT,projectId);
      String endpointSoaName=environment + ':' + endpointUrl;
      if (isSoapMessage) {
        Map<String,Serializable> ecProperties=new HashMap<String,Serializable>();
        List<SoaNodeId> ecParents=new ArrayList<SoaNodeId>();
        String consumerHost=environment + ':' + inMessage.getRemoteHost();
        ecProperties.put(EndpointConsumption.XPATH_CONSUMER_HOST,inMessage.getRemoteHost());
        ecProperties.put(EndpointConsumption.XPATH_CONSUMER_IP,inMessage.getRemoteAddress());
        for (        Header header : inMessage.getHeaders().getHeaderList()) {
          System.out.println(""String_Node_Str"" + header.getName() + ""String_Node_Str""+ header.getValue());
        }
        ecProperties.put(EndpointConsumption.XPATH_CONSUMED_URL,endpointUrl);
        ecProperties.put(EndpointConsumption.XPATH_CONSUMED_ENVIRONMENT,environment);
        ecProperties.put(ResourceDownloadInfo.XPATH_URL,wsdlUrl);
        String ecSoaName=consumerHost + '>' + endpointSoaName;
        SoaNodeId ecSoaNodeId=new SoaNodeId(projectId,EndpointConsumption.DOCTYPE,ecSoaName);
        SoaNodeInformation ecSoaNodeInfo=new SoaNodeInformation(ecSoaNodeId,ecProperties,ecParents);
        OperationResult ecResult=registryApi.post(ecSoaNodeInfo);
        if (!ecResult.isSuccessful()) {
          logger.warn(""String_Node_Str"" + ecResult.getMessage());
          throw new Exception(""String_Node_Str"" + ecResult.getMessage());
        }
 else {
          parents.add(ecSoaNodeId);
        }
      }
      properties.put(ResourceDownloadInfo.XPATH_URL,wsdlUrl);
      properties.put(ResourceDownloadInfo.XPATH_PROBE_TYPE,DISCOVERY_PROBE_TYPE);
      properties.put(ResourceDownloadInfo.XPATH_PROBE_INSTANCEID,getConfiguration().getId());
      SoaNodeId soaNodeId=new SoaNodeId(projectId,Endpoint.DOCTYPE,endpointSoaName);
      SoaNodeInformation soaNodeInfo=new SoaNodeInformation(soaNodeId,properties,parents);
      OperationResult result=registryApi.post(soaNodeInfo);
      logger.debug(""String_Node_Str"" + result.isSuccessful());
      logger.debug(""String_Node_Str"" + result.getMessage());
      if (result.isSuccessful()) {
        logger.info(""String_Node_Str"");
      }
 else {
        logger.error(""String_Node_Str"" + result.getMessage());
        throw new Exception(""String_Node_Str"" + result.getMessage());
      }
    }
 else {
      logger.info(""String_Node_Str"");
    }
  }
 else {
    logger.info(""String_Node_Str"");
  }
}","@Override public void handleMessage(InMessage inMessage,OutMessage outMessage) throws Exception {
  if (enabled && hasValidConfiguration()) {
    boolean isSoapMessage=checkForSoapMessage(inMessage);
    boolean isGetWsdlMessage=!isSoapMessage || checkForWsdlMessage(inMessage);
    if (isSoapMessage || isGetWsdlMessage) {
      if (registryClient == null) {
        RegistryJerseyClientConfiguration jerseyClient=new RegistryJerseyClientConfiguration();
        registryClient=jerseyClient.getClient();
      }
      RegistryApi registryApi=registryClient.constructRegistryApi();
      Map<String,Serializable> properties=new HashMap<String,Serializable>();
      List<SoaNodeId> parents=new ArrayList<SoaNodeId>();
      URI uriToNormalize=new URI(inMessage.buildCompleteUrl());
      String messageUrl=uriToNormalize.normalize().toString();
      String endpointUrl=isSoapMessage ? messageUrl : messageUrl.substring(0,messageUrl.length() - 5);
      String wsdlUrl=isGetWsdlMessage ? messageUrl : messageUrl + ""String_Node_Str"";
      properties.put(Endpoint.XPATH_URL,endpointUrl);
      properties.put(Endpoint.XPATH_TITLE,environment + ""String_Node_Str"" + endpointUrl);
      properties.put(Endpoint.XPATH_ENDP_ENVIRONMENT,environment);
      properties.put(Subproject.XPATH_SUBPROJECT,projectId);
      String endpointSoaName=environment + ':' + endpointUrl;
      if (isSoapMessage) {
        Map<String,Serializable> ecProperties=new HashMap<String,Serializable>();
        List<SoaNodeId> ecParents=new ArrayList<SoaNodeId>();
        String consumerHost=environment + ':' + inMessage.getRemoteHost();
        ecProperties.put(EndpointConsumption.XPATH_CONSUMER_HOST,inMessage.getRemoteHost());
        ecProperties.put(EndpointConsumption.XPATH_CONSUMER_IP,inMessage.getRemoteAddress());
        for (        Header header : inMessage.getHeaders().getHeaderList()) {
          System.out.println(""String_Node_Str"" + header.getName() + ""String_Node_Str""+ header.getValue());
        }
        ecProperties.put(EndpointConsumption.XPATH_CONSUMED_URL,endpointUrl);
        ecProperties.put(EndpointConsumption.XPATH_CONSUMED_ENVIRONMENT,environment);
        ecProperties.put(ResourceDownloadInfo.XPATH_URL,wsdlUrl);
        String ecSoaName=consumerHost + '>' + endpointSoaName;
        SoaNodeId ecSoaNodeId=new SoaNodeId(projectId,EndpointConsumption.DOCTYPE,ecSoaName);
        SoaNodeInformation ecSoaNodeInfo=new SoaNodeInformation(ecSoaNodeId,ecProperties,ecParents);
        OperationResult ecResult=registryApi.post(ecSoaNodeInfo);
        if (!ecResult.isSuccessful()) {
          logger.warn(""String_Node_Str"" + ecResult.getMessage());
          throw new Exception(""String_Node_Str"" + ecResult.getMessage());
        }
 else {
          parents.add(ecSoaNodeId);
        }
      }
      properties.put(ResourceDownloadInfo.XPATH_URL,wsdlUrl);
      properties.put(ResourceDownloadInfo.XPATH_PROBE_TYPE,DISCOVERY_PROBE_TYPE);
      properties.put(ResourceDownloadInfo.XPATH_PROBE_INSTANCEID,getConfiguration().getId());
      properties.put(Endpoint.XPATH_ENDP_HOST,inMessage.getRemoteHost());
      SoaNodeId soaNodeId=new SoaNodeId(projectId,Endpoint.DOCTYPE,endpointSoaName);
      SoaNodeInformation soaNodeInfo=new SoaNodeInformation(soaNodeId,properties,parents);
      OperationResult result=registryApi.post(soaNodeInfo);
      logger.debug(""String_Node_Str"" + result.isSuccessful());
      logger.debug(""String_Node_Str"" + result.getMessage());
      if (result.isSuccessful()) {
        logger.info(""String_Node_Str"");
      }
 else {
        logger.error(""String_Node_Str"" + result.getMessage());
        throw new Exception(""String_Node_Str"" + result.getMessage());
      }
    }
 else {
      logger.info(""String_Node_Str"");
    }
  }
 else {
    logger.info(""String_Node_Str"");
  }
}"
18202,"/** 
 * Test the EasySOAv1SOAPDiscoveryMessageHandler with a WSDL file get request
 * @throws Exception
 */
@Test public void WsdlDiscoveryMessageHandlerTest() throws Exception {
  EasySOAv1SOAPDiscoveryMessageHandler handler=new EasySOAv1SOAPDiscoveryMessageHandler();
  PropertyManager pm=new PropertyManager(""String_Node_Str"");
  ProxyConfiguration proxyConf=new ProxyConfiguration();
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.ENVIRONMENT_PARAM_NAME,""String_Node_Str"");
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.PROJECTID_PARAM_NAME,""String_Node_Str"");
  ExchangeRecord record=new ExchangeRecord();
  record.setExchange(new Exchange());
  record.setInMessage(new InMessage());
  record.setOutMessage(new OutMessage());
  record.getInMessage().setProtocol(""String_Node_Str"");
  record.getInMessage().setMethod(""String_Node_Str"");
  record.getInMessage().setPath(""String_Node_Str"");
  record.getInMessage().setServer(""String_Node_Str"");
  handler.setHandlerConfiguration(proxyConf);
  handler.handleMessage(record.getInMessage(),record.getOutMessage());
}","/** 
 * Test the EasySOAv1SOAPDiscoveryMessageHandler with a WSDL file get request
 * @throws Exception
 */
@Test public void WsdlDiscoveryMessageHandlerTest() throws Exception {
  EasySOAv1SOAPDiscoveryMessageHandler handler=new EasySOAv1SOAPDiscoveryMessageHandler();
  PropertyManager pm=new PropertyManager(""String_Node_Str"");
  ProxyConfiguration proxyConf=new ProxyConfiguration();
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.ENVIRONMENT_PARAM_NAME,""String_Node_Str"");
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.PROJECTID_PARAM_NAME,""String_Node_Str"");
  ExchangeRecord record=new ExchangeRecord();
  record.setExchange(new Exchange());
  record.setInMessage(new InMessage());
  record.setOutMessage(new OutMessage());
  record.getInMessage().setProtocol(""String_Node_Str"");
  record.getInMessage().setMethod(""String_Node_Str"");
  record.getInMessage().setPath(""String_Node_Str"");
  record.getInMessage().setServer(""String_Node_Str"");
  record.getInMessage().setRemoteHost(""String_Node_Str"");
  record.getInMessage().setRemoteAddress(""String_Node_Str"");
  handler.setHandlerConfiguration(proxyConf);
  handler.handleMessage(record.getInMessage(),record.getOutMessage());
}"
18203,"/** 
 * Test the EasySOAv1SOAPDiscoveryMessageHandler with a SOAP Post request
 * @throws Exception
 */
@Test public void SoapDiscoveryMessageHandlerTest() throws Exception {
  EasySOAv1SOAPDiscoveryMessageHandler handler=new EasySOAv1SOAPDiscoveryMessageHandler();
  PropertyManager pm=new PropertyManager(""String_Node_Str"");
  String soapRequestContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ProxyConfiguration proxyConf=new ProxyConfiguration();
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.ENVIRONMENT_PARAM_NAME,""String_Node_Str"");
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.PROJECTID_PARAM_NAME,""String_Node_Str"");
  ExchangeRecord record=new ExchangeRecord();
  record.setExchange(new Exchange());
  record.setInMessage(new InMessage());
  record.setOutMessage(new OutMessage());
  record.getInMessage().setProtocol(""String_Node_Str"");
  record.getInMessage().setMethod(""String_Node_Str"");
  record.getInMessage().setPath(""String_Node_Str"");
  record.getInMessage().setServer(""String_Node_Str"");
  MessageContent messageContent=new MessageContent();
  messageContent.setRawContent(soapRequestContent);
  record.getInMessage().setMessageContent(messageContent);
  handler.setHandlerConfiguration(proxyConf);
  handler.handleMessage(record.getInMessage(),record.getOutMessage());
}","/** 
 * Test the EasySOAv1SOAPDiscoveryMessageHandler with a SOAP Post request
 * @throws Exception
 */
@Test public void SoapDiscoveryMessageHandlerTest() throws Exception {
  EasySOAv1SOAPDiscoveryMessageHandler handler=new EasySOAv1SOAPDiscoveryMessageHandler();
  PropertyManager pm=new PropertyManager(""String_Node_Str"");
  String soapRequestContent=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ProxyConfiguration proxyConf=new ProxyConfiguration();
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.ENVIRONMENT_PARAM_NAME,""String_Node_Str"");
  proxyConf.addParameter(EasySOAGeneratedAppConfiguration.PROJECTID_PARAM_NAME,""String_Node_Str"");
  ExchangeRecord record=new ExchangeRecord();
  record.setExchange(new Exchange());
  record.setInMessage(new InMessage());
  record.setOutMessage(new OutMessage());
  record.getInMessage().setProtocol(""String_Node_Str"");
  record.getInMessage().setMethod(""String_Node_Str"");
  record.getInMessage().setPath(""String_Node_Str"");
  record.getInMessage().setServer(""String_Node_Str"");
  record.getInMessage().setRemoteHost(""String_Node_Str"");
  record.getInMessage().setRemoteAddress(""String_Node_Str"");
  MessageContent messageContent=new MessageContent();
  messageContent.setRawContent(soapRequestContent);
  record.getInMessage().setMessageContent(messageContent);
  handler.setHandlerConfiguration(proxyConf);
  handler.handleMessage(record.getInMessage(),record.getOutMessage());
}"
18204,"/** 
 * Return the list of warning messages thrown during the last  processing process
 * @return the list of warning messages
 */
public List<String> getWarningMessages(){
  return warningMessages;
}","/** 
 * Return the list of warning messages thrown during the last processing process
 * @return the list of warning messages
 */
public List<String> getWarningMessages(){
  return warningMessages;
}"
18205,"/** 
 * Return the list of error messages thrown during the last  processing process
 * @return the list of error messages
 */
public List<String> getErrorMessages(){
  return errorMessages;
}","/** 
 * Return the list of error messages thrown during the last processing process
 * @return the list of error messages
 */
public List<String> getErrorMessages(){
  return errorMessages;
}"
18206,"@Override public Collection<SoaNodeInformation> findWSImplementations(JavaSource[] sources,Map<String,JavaServiceInterfaceInformation> wsInterfaces,MavenDeliverableInformation mavenDeliverable,CodeDiscoveryRegistryClient registryClient,Log log) throws Exception {
  List<SoaNodeInformation> discoveredNodes=new ArrayList<SoaNodeInformation>();
  for (  JavaSource source : sources) {
    JavaClass[] classes=source.getClasses();
    for (    JavaClass c : classes) {
      if (!c.isInterface() && (ParsingUtils.hasAnnotation(c,ANN_WS) || getWsItf(c,wsInterfaces) != null)) {
        JavaClass itfClass=getWsItf(c,wsInterfaces);
        implsToInterfaces.put(c.asType(),itfClass.asType());
        JavaServiceImplementationInformation serviceImpl=new JavaServiceImplementationInformation(c.getFullyQualifiedName());
        serviceImpl.setTitle(c.getName());
        serviceImpl.setProperty(JavaServiceImplementation.XPATH_TECHNOLOGY,""String_Node_Str"");
        serviceImpl.setProperty(JavaServiceImplementation.XPATH_ISMOCK,c.getSource().getURL().getPath().contains(""String_Node_Str""));
        serviceImpl.setProperty(JavaServiceImplementation.XPATH_IMPLEMENTEDINTERFACE,itfClass.getFullyQualifiedName());
        serviceImpl.addParentDocument(mavenDeliverable.getSoaNodeId());
        discoveredNodes.add(serviceImpl);
        ServiceInformation serviceDef=new ServiceInformation(itfClass.getName());
        serviceImpl.addParentDocument(serviceDef.getSoaNodeId());
        serviceImpl.setProperty(JavaServiceImplementation.XPATH_DOCUMENTATION,itfClass.getComment());
        discoveredNodes.add(serviceDef);
        List<OperationImplementation> operations=serviceImpl.getOperations();
        for (        JavaMethod method : itfClass.getMethods()) {
          if (ParsingUtils.hasAnnotation(method,ANN_WEBRESULT)) {
            Annotation webResultAnn=ParsingUtils.getAnnotation(method,ANN_WEBRESULT);
            StringBuilder parametersInfo=new StringBuilder();
            for (            JavaParameter parameter : method.getParameters()) {
              Annotation webParamAnn=ParsingUtils.getAnnotation(parameter,ANN_WEBPARAM);
              parametersInfo.append(webParamAnn.getProperty(""String_Node_Str"").getParameterValue() + ""String_Node_Str"" + parameter.getType().toString()+ ""String_Node_Str"");
            }
            operations.add(new OperationImplementation(webResultAnn.getProperty(""String_Node_Str"").toString(),parametersInfo.delete(parametersInfo.length() - 2,parametersInfo.length()).toString(),method.getComment()));
          }
        }
        serviceImpl.setOperations(operations);
      }
    }
  }
  return discoveredNodes;
}","@Override public Collection<SoaNodeInformation> findWSImplementations(JavaSource[] sources,Map<String,JavaServiceInterfaceInformation> wsInterfaces,MavenDeliverableInformation mavenDeliverable,CodeDiscoveryRegistryClient registryClient,Log log) throws Exception {
  List<SoaNodeInformation> discoveredNodes=new ArrayList<SoaNodeInformation>();
  for (  JavaSource source : sources) {
    JavaClass[] classes=source.getClasses();
    for (    JavaClass c : classes) {
      if (!c.isInterface() && (ParsingUtils.hasAnnotation(c,ANN_WS) || getWsItf(c,wsInterfaces) != null)) {
        JavaClass itfClass=getWsItf(c,wsInterfaces);
        if (itfClass != null) {
          implsToInterfaces.put(c.asType(),itfClass.asType());
        }
 else {
          log.warn(""String_Node_Str"" + c.getFullyQualifiedName());
        }
        JavaServiceImplementationInformation serviceImpl=new JavaServiceImplementationInformation(c.getFullyQualifiedName());
        serviceImpl.setTitle(c.getName());
        serviceImpl.setProperty(JavaServiceImplementation.XPATH_TECHNOLOGY,""String_Node_Str"");
        serviceImpl.setProperty(JavaServiceImplementation.XPATH_ISMOCK,c.getSource().getURL().getPath().contains(""String_Node_Str""));
        if (itfClass != null) {
          serviceImpl.setProperty(JavaServiceImplementation.XPATH_IMPLEMENTEDINTERFACE,itfClass.getFullyQualifiedName());
        }
        serviceImpl.addParentDocument(mavenDeliverable.getSoaNodeId());
        discoveredNodes.add(serviceImpl);
        if (itfClass != null) {
          ServiceInformation serviceDef=new ServiceInformation(itfClass.getName());
          serviceImpl.addParentDocument(serviceDef.getSoaNodeId());
          serviceImpl.setProperty(JavaServiceImplementation.XPATH_DOCUMENTATION,itfClass.getComment());
          discoveredNodes.add(serviceDef);
          List<OperationImplementation> operations=serviceImpl.getOperations();
          for (          JavaMethod method : itfClass.getMethods()) {
            if (ParsingUtils.hasAnnotation(method,ANN_WEBRESULT)) {
              Annotation webResultAnn=ParsingUtils.getAnnotation(method,ANN_WEBRESULT);
              StringBuilder parametersInfo=new StringBuilder();
              for (              JavaParameter parameter : method.getParameters()) {
                Annotation webParamAnn=ParsingUtils.getAnnotation(parameter,ANN_WEBPARAM);
                parametersInfo.append(webParamAnn.getProperty(""String_Node_Str"").getParameterValue() + ""String_Node_Str"" + parameter.getType().toString()+ ""String_Node_Str"");
              }
              operations.add(new OperationImplementation(webResultAnn.getProperty(""String_Node_Str"").toString(),parametersInfo.delete(parametersInfo.length() - 2,parametersInfo.length()).toString(),method.getComment()));
            }
          }
          serviceImpl.setOperations(operations);
        }
      }
    }
  }
  return discoveredNodes;
}"
18207,"@Override public Map<String,JavaServiceInterfaceInformation> findWSInterfaces(CodeDiscoveryMojo codeDiscovery,JavaSource[] sources,MavenDeliverableInformation mavenDeliverable,CodeDiscoveryRegistryClient registryClient,Log log) throws Exception {
  Map<String,JavaServiceInterfaceInformation> wsInjectableTypeSet=new HashMap<String,JavaServiceInterfaceInformation>();
  for (  JavaSource source : sources) {
    JavaClass[] classes=source.getClasses();
    for (    JavaClass c : classes) {
      boolean isWs=ParsingUtils.hasAnnotation(c,ANN_WS);
      boolean isInterface=c.isInterface();
      if (isWs && isInterface || ParsingUtils.hasAnnotation(c,ANN_XML_WSCLIENT) || ParsingUtils.hasAnnotation(c,ANN_WSPROVIDER) || ParsingUtils.hasAnnotation(c,ANN_XML_WSPROVIDER)) {
        wsInjectableTypeSet.put(c.getFullyQualifiedName(),new JavaServiceInterfaceInformation(mavenDeliverable.getGroupId(),mavenDeliverable.getArtifactId(),c.getFullyQualifiedName()));
      }
    }
  }
  Map<Type,MavenDeliverableInformation> mavenInfos=new HashMap<Type,MavenDeliverableInformation>();
  MavenProject mavenProject=codeDiscovery.getMavenProject();
  if (mavenProject != null) {
    for (    Object dependencyObject : mavenProject.getDependencyArtifacts()) {
      Artifact dependency=(Artifact)dependencyObject;
      URLClassLoader jarClassloader=new URLClassLoader(new URL[]{dependency.getFile().toURI().toURL()});
      Enumeration<URL> resources=jarClassloader.getResources(""String_Node_Str"");
      wsInjectableTypeSet.putAll(exploreResourcesForInterfaces(jarClassloader,resources));
    }
  }
  return wsInjectableTypeSet;
}","@Override public Map<String,JavaServiceInterfaceInformation> findWSInterfaces(CodeDiscoveryMojo codeDiscovery,JavaSource[] sources,MavenDeliverableInformation mavenDeliverable,CodeDiscoveryRegistryClient registryClient,Log log) throws Exception {
  Map<String,JavaServiceInterfaceInformation> wsInjectableTypeSet=new HashMap<String,JavaServiceInterfaceInformation>();
  for (  JavaSource source : sources) {
    JavaClass[] classes=source.getClasses();
    for (    JavaClass c : classes) {
      boolean isWs=ParsingUtils.hasAnnotation(c,ANN_WS);
      boolean isInterface=c.isInterface();
      if (isWs && isInterface || ParsingUtils.hasAnnotation(c,ANN_XML_WSCLIENT) || ParsingUtils.hasAnnotation(c,ANN_WSPROVIDER) || ParsingUtils.hasAnnotation(c,ANN_XML_WSPROVIDER)) {
        wsInjectableTypeSet.put(c.getFullyQualifiedName(),new JavaServiceInterfaceInformation(mavenDeliverable.getGroupId(),mavenDeliverable.getArtifactId(),c.getFullyQualifiedName()));
      }
    }
  }
  return wsInjectableTypeSet;
}"
18208,"private void addConsumerFoundInInjectedMember(List<JavaServiceConsumptionInformation> discoveredConsumptions,AbstractJavaEntity injectedMember,Type injectedType,String beanPropertyName,HashSet<String> injectedBeanProperties,Map<String,JavaServiceInterfaceInformation> serviceInterfaces,MavenDeliverable mavenDeliverable) throws Exception {
  if (injectedBeanProperties.contains(beanPropertyName)) {
    return;
  }
  String injectionAnnotation=getInjectionAnnotation(injectedMember);
  if (allInjected || injectionAnnotation != null) {
    if (serviceInterfaces.containsKey(injectedType)) {
      discoveredConsumptions.add(new JavaServiceConsumptionInformation(mavenDeliverable.getSoaNodeId(),null,injectedType.toGenericString(),injectedType.getJavaClass().getSource().getURL().toString()));
      injectedBeanProperties.add(beanPropertyName);
    }
  }
}","private void addConsumerFoundInInjectedMember(List<JavaServiceConsumptionInformation> discoveredConsumptions,AbstractJavaEntity injectedMember,Type injectedType,String beanPropertyName,HashSet<String> injectedBeanProperties,Map<String,JavaServiceInterfaceInformation> serviceInterfaces,MavenDeliverable mavenDeliverable) throws Exception {
  if (injectedBeanProperties.contains(beanPropertyName)) {
    return;
  }
  String injectionAnnotation=getInjectionAnnotation(injectedMember);
  if (allInjected || injectionAnnotation != null) {
    if (serviceInterfaces.containsKey(injectedType.getFullyQualifiedName())) {
      discoveredConsumptions.add(new JavaServiceConsumptionInformation(mavenDeliverable.getSoaNodeId(),null,injectedType.toGenericString(),injectedType.getJavaClass().getSource().getURL().toString()));
      injectedBeanProperties.add(beanPropertyName);
    }
  }
}"
18209,"public List<JavaServiceConsumptionInformation> find(JavaClass c,MavenDeliverable mavenDeliverable,Map<String,JavaServiceInterfaceInformation> serviceInterfaces) throws Exception {
  List<JavaServiceConsumptionInformation> foundConsumptions=new ArrayList<JavaServiceConsumptionInformation>();
  for (  String importedClassName : c.getSource().getImports()) {
    Type importedClassType=new Type(importedClassName);
    for (    String serviceInterface : serviceInterfaces.keySet()) {
      if (importedClassType.equals(serviceInterface)) {
        foundConsumptions.add(new JavaServiceConsumptionInformation(mavenDeliverable.getSoaNodeId(),c.getFullyQualifiedName(),importedClassName,serviceInterface));
      }
    }
  }
  return foundConsumptions;
}","public List<JavaServiceConsumptionInformation> find(JavaClass c,MavenDeliverable mavenDeliverable,Map<String,JavaServiceInterfaceInformation> serviceInterfaces) throws Exception {
  List<JavaServiceConsumptionInformation> foundConsumptions=new ArrayList<JavaServiceConsumptionInformation>();
  for (  String importedClassName : c.getSource().getImports()) {
    Type importedClassType=new Type(importedClassName);
    for (    String serviceInterface : serviceInterfaces.keySet()) {
      if (importedClassType.getFullyQualifiedName().equals(serviceInterface)) {
        foundConsumptions.add(new JavaServiceConsumptionInformation(mavenDeliverable.getSoaNodeId(),c.getFullyQualifiedName(),importedClassName,serviceInterface));
      }
    }
  }
  return foundConsumptions;
}"
18210,"@Override public void handleEvent(Event event) throws ClientException {
  EventContext context=event.getContext();
  if (!(context instanceof DocumentEventContext)) {
    return;
  }
  DocumentEventContext documentContext=(DocumentEventContext)context;
  DocumentModel sourceDocument=documentContext.getSourceDocument();
  if (!sourceDocument.hasFacet(""String_Node_Str"")) {
    return;
  }
  try {
    CoreSession documentManager=documentContext.getCoreSession();
    DocumentService documentService=Framework.getService(DocumentService.class);
    String sourceFolderPath=documentService.getSourceFolderPath(sourceDocument.getType());
    DocumentModel parentModel=documentManager.getDocument(sourceDocument.getParentRef());
    if (!sourceDocument.isProxy() && !sourceDocument.getPathAsString().startsWith(sourceFolderPath) || sourceDocument.isProxy() && parentModel.hasFacet(SoaNode.FACET) && !sourceDocument.getPathAsString().startsWith(Repository.REPOSITORY_PATH)) {
      documentService.ensureSourceFolderExists(documentManager,sourceDocument.getType());
      String soaName=(String)sourceDocument.getPropertyValue(SoaNode.XPATH_SOANAME);
      if (soaName == null || soaName.isEmpty()) {
        sourceDocument.setPropertyValue(SoaNode.XPATH_SOANAME,sourceDocument.getName());
      }
      PathRef sourcePathRef=new PathRef(documentService.getSourcePath(documentService.createSoaNodeId(sourceDocument)));
      DocumentModel repositoryDocument;
      if (documentManager.exists(sourcePathRef)) {
        repositoryDocument=documentManager.getDocument(sourcePathRef);
        repositoryDocument.copyContent(sourceDocument);
        documentManager.saveDocument(repositoryDocument);
        documentManager.save();
        documentManager.removeDocument(sourceDocument.getRef());
      }
 else {
        repositoryDocument=documentManager.move(sourceDocument.getRef(),new PathRef(sourceFolderPath),sourceDocument.getName());
      }
      if (documentService.isSoaNode(documentManager,parentModel.getType())) {
        parentModel=documentService.find(documentManager,documentService.createSoaNodeId(parentModel));
      }
      documentManager.createProxy(repositoryDocument.getRef(),parentModel.getRef());
    }
    documentManager.save();
    IntelligentSystemTreeService intelligentSystemTreeServiceCache=Framework.getService(IntelligentSystemTreeService.class);
    intelligentSystemTreeServiceCache.handleDocumentModel(documentManager,sourceDocument,!DocumentEventTypes.DOCUMENT_CREATED.equals(event.getName()));
    documentManager.save();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","@Override public void handleEvent(Event event) throws ClientException {
  EventContext context=event.getContext();
  if (!(context instanceof DocumentEventContext)) {
    return;
  }
  DocumentEventContext documentContext=(DocumentEventContext)context;
  DocumentModel sourceDocument=documentContext.getSourceDocument();
  if (!sourceDocument.hasFacet(""String_Node_Str"")) {
    return;
  }
  try {
    CoreSession documentManager=documentContext.getCoreSession();
    DocumentService documentService=Framework.getService(DocumentService.class);
    String sourceFolderPath=documentService.getSourceFolderPath(sourceDocument.getType());
    DocumentModel parentModel=documentManager.getDocument(sourceDocument.getParentRef());
    if (!sourceDocument.isProxy() && !parentModel.getPathAsString().equals(sourceFolderPath) || sourceDocument.isProxy() && parentModel.hasFacet(SoaNode.FACET) && !sourceDocument.getPathAsString().startsWith(Repository.REPOSITORY_PATH)) {
      documentService.ensureSourceFolderExists(documentManager,sourceDocument.getType());
      String soaName=(String)sourceDocument.getPropertyValue(SoaNode.XPATH_SOANAME);
      if (soaName == null || soaName.isEmpty()) {
        sourceDocument.setPropertyValue(SoaNode.XPATH_SOANAME,sourceDocument.getName());
      }
      PathRef sourcePathRef=new PathRef(documentService.getSourcePath(documentService.createSoaNodeId(sourceDocument)));
      DocumentModel repositoryDocument;
      if (documentManager.exists(sourcePathRef)) {
        repositoryDocument=documentManager.getDocument(sourcePathRef);
        repositoryDocument.copyContent(sourceDocument);
        documentManager.saveDocument(repositoryDocument);
        documentManager.save();
        documentManager.removeDocument(sourceDocument.getRef());
      }
 else {
        repositoryDocument=documentManager.move(sourceDocument.getRef(),new PathRef(sourceFolderPath),sourceDocument.getName());
      }
      if (documentService.isSoaNode(documentManager,parentModel.getType())) {
        parentModel=documentService.find(documentManager,documentService.createSoaNodeId(parentModel));
      }
      documentManager.createProxy(repositoryDocument.getRef(),parentModel.getRef());
    }
    documentManager.save();
    IntelligentSystemTreeService intelligentSystemTreeServiceCache=Framework.getService(IntelligentSystemTreeService.class);
    intelligentSystemTreeServiceCache.handleDocumentModel(documentManager,sourceDocument,!DocumentEventTypes.DOCUMENT_CREATED.equals(event.getName()));
    documentManager.save();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}"
18211,"@Override public List<String> getStoreList(String path){
  File folder=new File(path);
  File[] listOfFiles=folder.listFiles();
  List<String> storeList=new ArrayList<String>();
  for (  File file : listOfFiles) {
    if (file.isDirectory()) {
      storeList.add(file.getName());
    }
  }
  return storeList;
}","@Override public List<String> getStoreList(String path){
  File folder=new File(path);
  File[] listOfFiles=folder.listFiles();
  List<String> storeList=new ArrayList<String>();
  if (listOfFiles != null) {
    for (    File file : listOfFiles) {
      if (file.isDirectory()) {
        storeList.add(file.getName());
      }
    }
  }
  return storeList;
}"
18212,"private boolean maintainInternalProperties(CoreSession session,DocumentModel appliImplModel,String environment){
  try {
    String url=(String)appliImplModel.getProperty(SCHEMA,PROP_URL);
    String server=(String)appliImplModel.getProperty(SCHEMA,PROP_SERVER);
    if (url != null && !url.isEmpty() && !AppliImpl.DEFAULT_APPLIIMPL_URL.equals(url) && (server == null || server.isEmpty())) {
      try {
        url=PropertyNormalizer.normalizeUrl(url);
        appliImplModel.setProperty(SCHEMA,PROP_URL,url);
        server=new URL(url).getHost();
        appliImplModel.setProperty(SCHEMA,PROP_SERVER,server);
        appliImplModel.setProperty(SCHEMA,PROP_SERVERENTRY,environment + ""String_Node_Str"" + server);
      }
 catch (      MalformedURLException e) {
        log.warn(""String_Node_Str"" + url + ""String_Node_Str"");
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return false;
  }
  return true;
}","private boolean maintainInternalProperties(CoreSession session,DocumentModel appliImplModel,String environment){
  try {
    String url=(String)appliImplModel.getProperty(SCHEMA,PROP_URL);
    String server=(String)appliImplModel.getProperty(SCHEMA,PROP_SERVER);
    if (url != null && !url.isEmpty() && !""String_Node_Str"".equals(url) && !AppliImpl.DEFAULT_APPLIIMPL_URL.equals(url) && (server == null || server.isEmpty())) {
      try {
        url=PropertyNormalizer.normalizeUrl(url);
        appliImplModel.setProperty(SCHEMA,PROP_URL,url);
        server=new URL(url).getHost();
        appliImplModel.setProperty(SCHEMA,PROP_SERVER,server);
        appliImplModel.setProperty(SCHEMA,PROP_SERVERENTRY,environment + ""String_Node_Str"" + server);
      }
 catch (      MalformedURLException e) {
        log.warn(""String_Node_Str"" + url + ""String_Node_Str"");
      }
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return false;
  }
  return true;
}"
18213,"private static String extractApplicationNameFromUrl(URL url) throws Exception {
  HttpDownloaderService httpDownloaderService=Framework.getService(HttpDownloaderService.class);
  HttpDownloader siteRootFile=httpDownloaderService.createHttpDownloader(url);
  siteRootFile.download();
  TagNode siteRootCleanHtml=cleaner.clean(siteRootFile.getFile());
  return extractApplicationName(siteRootCleanHtml);
}","private static String extractApplicationNameFromUrl(URL url) throws Exception {
  HttpDownloaderService httpDownloaderService=Framework.getService(HttpDownloaderService.class);
  HttpDownloader siteRootFile=httpDownloaderService.createHttpDownloader(url);
  siteRootFile.download();
  try {
    TagNode siteRootCleanHtml=cleaner.clean(siteRootFile.getFile());
    return extractApplicationName(siteRootCleanHtml);
  }
 catch (  StackOverflowError e) {
    log.warn(""String_Node_Str"" + url + ""String_Node_Str"");
    return null;
  }
}"
18214,"@Override public List<FoundService> findFromContext(BrowsingContext context) throws Exception {
  List<FoundService> foundServices=new LinkedList<FoundService>();
  URL url=context.getURL();
  String urlString=url.toString();
  if (urlString.toLowerCase().endsWith(""String_Node_Str"")) {
    WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
    Description desc=reader.read(url);
    String serviceName=desc.getQName().getLocalPart();
    foundServices.add(new FoundService(serviceName,urlString));
  }
  return foundServices;
}","@Override public List<FoundService> findFromContext(BrowsingContext context) throws Exception {
  List<FoundService> foundServices=new LinkedList<FoundService>();
  URL url=context.getURL();
  String urlString=url.toString();
  if (urlString.toLowerCase().endsWith(""String_Node_Str"")) {
    WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
    Description desc=reader.read(url);
    String serviceName=null;
    try {
      serviceName=desc.getQName().getLocalPart();
    }
 catch (    Exception e) {
      String[] splitUrl=urlString.toLowerCase().split(""String_Node_Str"");
      serviceName=(splitUrl[splitUrl.length - 1].contains(""String_Node_Str"")) ? splitUrl[splitUrl.length - 2] : splitUrl[splitUrl.length - 1];
    }
    foundServices.add(new FoundService(serviceName,urlString));
  }
  return foundServices;
}"
18215,"@Override public List<FoundService> findFromContext(BrowsingContext context) throws Exception {
  List<FoundService> foundServices=new LinkedList<FoundService>();
  if (context.getData() != null) {
    URL url=context.getURL();
    HtmlCleaner cleaner=new HtmlCleaner();
    TagNode cleanHtml=cleaner.clean(context.getData());
    String applicationName=guessApplicationName(url);
    List<String> foundServicesNames=new LinkedList<String>();
    Object[] links=cleanHtml.evaluateXPath(""String_Node_Str"");
    changeToAbsolutePath(links,""String_Node_Str"",url);
    for (    Object o : links) {
      TagNode link=(TagNode)o;
      try {
        String ref=new URL(url,link.getAttributeByName(""String_Node_Str"")).toString();
        String name=(link.getText() != null) ? link.getText().toString() : ref;
        if (name.contains(""String_Node_Str"")) {
          String[] nameParts=name.split(""String_Node_Str"");
          name=nameParts[nameParts.length - 1].replaceAll(""String_Node_Str"",""String_Node_Str"");
        }
        int i=1;
        if (ref != null && ref.toLowerCase().endsWith(""String_Node_Str"")) {
          while (foundServicesNames.contains(name)) {
            name=(i == 1 ? name + i++ : name.substring(0,name.length() - 1)) + i++;
          }
          name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
          foundServices.add(new FoundService(name,ref,applicationName));
          foundServicesNames.add(name);
        }
      }
 catch (      MalformedURLException e) {
      }
    }
  }
  return foundServices;
}","@Override public List<FoundService> findFromContext(BrowsingContext context) throws Exception {
  List<FoundService> foundServices=new LinkedList<FoundService>();
  if (context.getData() != null) {
    URL url=context.getURL();
    HtmlCleaner cleaner=new HtmlCleaner();
    TagNode cleanHtml=null;
    try {
      cleanHtml=cleaner.clean(context.getData());
    }
 catch (    StackOverflowError e) {
      log.warn(""String_Node_Str"" + url + ""String_Node_Str"");
      return foundServices;
    }
    String applicationName=guessApplicationName(url);
    List<String> foundServicesNames=new LinkedList<String>();
    Object[] links=cleanHtml.evaluateXPath(""String_Node_Str"");
    changeToAbsolutePath(links,""String_Node_Str"",url);
    for (    Object o : links) {
      TagNode link=(TagNode)o;
      try {
        String ref=new URL(url,link.getAttributeByName(""String_Node_Str"")).toString();
        String name=(link.getText() != null) ? link.getText().toString() : ref;
        if (name.contains(""String_Node_Str"")) {
          String[] nameParts=name.split(""String_Node_Str"");
          name=nameParts[nameParts.length - 1].replaceAll(""String_Node_Str"",""String_Node_Str"");
        }
        int i=1;
        if (ref != null && ref.toLowerCase().endsWith(""String_Node_Str"")) {
          while (foundServicesNames.contains(name)) {
            name=(i == 1 ? name + i++ : name.substring(0,name.length() - 1)) + i++;
          }
          name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
          foundServices.add(new FoundService(name,ref,applicationName));
          foundServicesNames.add(name);
        }
      }
 catch (      MalformedURLException e) {
      }
    }
  }
  return foundServices;
}"
18216,"/** 
 * Constructor
 * @param response
 * @throws IOException 
 * @throws UnsupportedEncodingException 
 */
public HttpMessageResponseWrapper(HttpServletResponse response) throws UnsupportedEncodingException, IOException {
  super(response);
  writer=new CopyWriter(new OutputStreamWriter(response.getOutputStream(),response.getCharacterEncoding()));
}","/** 
 * Constructor
 * @param response
 * @throws IOException 
 * @throws UnsupportedEncodingException 
 */
public HttpMessageResponseWrapper(HttpServletResponse response) throws UnsupportedEncodingException, IOException {
  super(response);
}"
18217,"/** 
 * @return
 */
public PrintWriter getWriter(){
  return this.writer;
}","/** 
 * @return
 */
public PrintWriter getWriter() throws IOException {
  copyOut=new CopyOutputStream(this.getResponse().getOutputStream());
  writer=new PrintWriter(new OutputStreamWriter(copyOut,this.getCharacterEncoding()));
  return this.writer;
}"
18218,"public ServletOutputStream getOutputStream(){
  return new ServletOutputStream(){
    private ByteArrayOutputStream bos=new ByteArrayOutputStream();
    @Override public void write(    int b) throws IOException {
      bos.write(writer.getCopy().getBytes());
    }
  }
;
}","public ServletOutputStream getOutputStream() throws IOException {
  copyOut=new CopyOutputStream(this.getResponse().getOutputStream());
  writer=new PrintWriter(new OutputStreamWriter(copyOut,this.getCharacterEncoding()));
  return new ServletOutputStream(){
    @Override public void write(    int b) throws IOException {
      copyOut.write(b);
    }
  }
;
}"
18219,"/** 
 * @return
 */
public String getMessageContent(){
  return this.writer.getCopy();
}","/** 
 * @return
 */
public String getMessageContent(){
  return new String(this.copyOut.getCopy(),Charset.forName(this.getCharacterEncoding()));
}"
18220,"@Override public void write(int b) throws IOException {
  bos.write(writer.getCopy().getBytes());
}","@Override public void write(int b) throws IOException {
  copyOut.write(b);
}"
18221,"/** 
 * Process the filter 
 */
public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  logger.info(""String_Node_Str"");
  if (exchangeHandler != null) {
    if (request instanceof HttpServletRequest) {
      HttpMessageRequestWrapper requestWrapper=new HttpMessageRequestWrapper((HttpServletRequest)request);
      HttpMessageResponseWrapper responseWrapper=new HttpMessageResponseWrapper((HttpServletResponse)response);
      try {
        exchangeHandler.handleExchange(requestWrapper,responseWrapper);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  chain.doFilter(request,response);
}","/** 
 * Process the filter 
 */
public void doFilter(ServletRequest request,ServletResponse response,FilterChain chain) throws IOException, ServletException {
  logger.info(""String_Node_Str"");
  if (exchangeHandler != null) {
    response=new HttpMessageResponseWrapper((HttpServletResponse)response);
  }
  chain.doFilter(request,response);
  if (exchangeHandler != null) {
    if (request instanceof HttpServletRequest) {
      try {
        exchangeHandler.handleExchange((HttpServletRequest)request,(HttpServletResponse)response);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}"
18222,"public void handleExchange(HttpServletRequest request,HttpServletResponse response) throws Exception {
  HttpMessageRequestWrapper requestWrapper=new HttpMessageRequestWrapper(request);
  HttpMessageResponseWrapper responseWrapper=new HttpMessageResponseWrapper(response);
  InMessage inMessage=new InMessage(requestWrapper);
  OutMessage outMessage=new OutMessage(responseWrapper);
  this.handleMessage(inMessage,outMessage);
}","public void handleExchange(HttpServletRequest request,HttpServletResponse response) throws Exception {
  HttpMessageRequestWrapper requestWrapper=new HttpMessageRequestWrapper(request);
  HttpMessageResponseWrapper responseWrapper;
  if (response instanceof HttpMessageResponseWrapper) {
    responseWrapper=(HttpMessageResponseWrapper)response;
  }
 else {
    responseWrapper=new HttpMessageResponseWrapper(response);
  }
  InMessage inMessage=new InMessage(requestWrapper);
  OutMessage outMessage=new OutMessage(responseWrapper);
  this.handleMessage(inMessage,outMessage);
}"
18223,"/** 
 * Prefer   {@link EasySOAApiFraSCAti#getInstance()} static method instead(constructor only made public to let the Nuxeo framework instanciate it)
 */
public EasySOAApiFraSCAti() throws InstantiationException {
  if (instance != null) {
    throw new InstantiationException(""String_Node_Str"");
  }
  try {
    remoteProvider=new RemoteFraSCAtiServiceProvider(LIBRARIES_DIRECTORY);
    this.frascati=remoteProvider.getFraSCAtiService();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  instance=this;
}","/** 
 * Hidden constructor Use   {@link EasySOAApiFraSCAti#getInstance()} staticmethod instead
 */
protected EasySOAApiFraSCAti(){
  try {
    remoteProvider=new RemoteFraSCAtiServiceProvider(null);
    this.frascati=remoteProvider.getFraSCAtiService();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
18224,"/** 
 * Return the singleton instance of EasySOAApiFraSCAti
 * @return the EasySOAApiFraSCAti singleton
 */
public static final EasySOAApiFraSCAti getInstance(){
  if (instance == null) {
    try {
      instance=new EasySOAApiFraSCAti();
    }
 catch (    InstantiationException e) {
      e.printStackTrace();
    }
  }
  return instance;
}","/** 
 * Return the singleton instance of EasySOAApiFraSCAti
 * @return the EasySOAApiFraSCAti singleton
 */
public static final EasySOAApiFraSCAti getInstance(){
  if (instance == null) {
    instance=new EasySOAApiFraSCAti();
  }
  return instance;
}"
18225,"/** 
 * Register a new event receiver
 * @param eventReceiver The RunManagerEventReciver to register
 */
public void addEventReceiver(RunManagerEventReceiver eventReceiver){
  if (eventReceiver != null) {
    runManagerEventReceiverList.add(eventReceiver);
  }
}","/** 
 * Register a new event receiver
 * @param eventReceiver The RunManagerEventReceiver to register
 */
public static void addEventReceiver(RunManagerEventReceiver eventReceiver){
  if (eventReceiver != null) {
    runManagerEventReceiverList.add(eventReceiver);
  }
}"
18226,"/** 
 * Send a REST request
 * @param inMessage The request to send
 * @return <code>OutMessage</code> the response as an OutMessage object
 * @throws IOException 
 * @throws ClientProtocolException 
 */
private OutMessage sendRestRequest(InMessage inMessage) throws ClientProtocolException, IOException {
  DefaultHttpClient httpClient=new DefaultHttpClient();
  if (retryHandler != null) {
    httpClient.setHttpRequestRetryHandler(retryHandler);
  }
  HttpParams httpParams=httpClient.getParams();
  if (forwardHttpConnexionTimeoutMs > 0) {
    HttpConnectionParams.setConnectionTimeout(httpParams,this.forwardHttpConnexionTimeoutMs);
  }
  if (forwardHttpSocketTimeoutMs > 0) {
    HttpConnectionParams.setSoTimeout(httpParams,this.forwardHttpSocketTimeoutMs);
  }
  StringBuffer requestUrlBuffer=new StringBuffer();
  requestUrlBuffer.append(inMessage.buildCompleteUrl());
  if (inMessage.getQueryString() != null) {
    requestUrlBuffer.append(""String_Node_Str"");
    boolean firstParam=true;
    for (    QueryParam queryParam : inMessage.getQueryString().getQueryParams()) {
      if (!firstParam) {
        requestUrlBuffer.append(""String_Node_Str"");
      }
      requestUrlBuffer.append(queryParam.getName());
      requestUrlBuffer.append(""String_Node_Str"");
      requestUrlBuffer.append(queryParam.getValue().replace(""String_Node_Str"",""String_Node_Str""));
      firstParam=false;
    }
  }
  logger.debug(""String_Node_Str"" + requestUrlBuffer.toString());
  HttpEntity httpEntity=new StringEntity(inMessage.getMessageContent().getRawContent());
  HttpUriRequest httpUriRequest;
  if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpGet(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    HttpPut httpPut=new HttpPut(requestUrlBuffer.toString());
    httpPut.setEntity(httpEntity);
    httpUriRequest=httpPut;
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpDelete(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpOptions(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpOptions(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpOptions(requestUrlBuffer.toString());
  }
 else {
    HttpPost httpPost=new HttpPost(requestUrlBuffer.toString());
    httpPost.setEntity(httpEntity);
    httpUriRequest=httpPost;
  }
  setHeaders(inMessage,httpUriRequest);
  Date requestSendDate=new Date();
  HttpResponse clientResponse=httpClient.execute(httpUriRequest);
  Date responseSendDate=new Date();
  OutMessage outMessage=new OutMessage(clientResponse.getStatusLine().getStatusCode(),clientResponse.getStatusLine().getReasonPhrase());
  inMessage.setRequestTimeStamp(requestSendDate.getTime());
  outMessage.setResponseTimeStamp(responseSendDate.getTime());
  MessageContent messageContent=new MessageContent();
  InputStreamReader in=new InputStreamReader(clientResponse.getEntity().getContent());
  BufferedReader bin=new BufferedReader(in);
  StringBuffer responseBuffer=new StringBuffer();
  String line;
  do {
    line=bin.readLine();
    if (line != null) {
      responseBuffer.append(line);
    }
  }
 while (line != null);
  messageContent.setRawContent(responseBuffer.toString());
  messageContent.setSize(clientResponse.getEntity().getContentLength());
  if (clientResponse.getEntity().getContentType() != null) {
    messageContent.setMimeType(clientResponse.getEntity().getContentType().getValue());
  }
  outMessage.setMessageContent(messageContent);
  messageContent.setEncoding(clientResponse.getEntity().getContentEncoding().getValue());
  return outMessage;
}","/** 
 * Send a REST request
 * @param inMessage The request to send
 * @return <code>OutMessage</code> the response as an OutMessage object
 * @throws IOException 
 * @throws ClientProtocolException 
 */
private OutMessage sendRestRequest(InMessage inMessage) throws ClientProtocolException, IOException {
  DefaultHttpClient httpClient=new DefaultHttpClient();
  if (retryHandler != null) {
    httpClient.setHttpRequestRetryHandler(retryHandler);
  }
  HttpParams httpParams=httpClient.getParams();
  if (forwardHttpConnexionTimeoutMs > 0) {
    HttpConnectionParams.setConnectionTimeout(httpParams,this.forwardHttpConnexionTimeoutMs);
  }
  if (forwardHttpSocketTimeoutMs > 0) {
    HttpConnectionParams.setSoTimeout(httpParams,this.forwardHttpSocketTimeoutMs);
  }
  StringBuffer requestUrlBuffer=new StringBuffer();
  requestUrlBuffer.append(inMessage.buildCompleteUrl());
  if (inMessage.getQueryString() != null) {
    requestUrlBuffer.append(""String_Node_Str"");
    boolean firstParam=true;
    for (    QueryParam queryParam : inMessage.getQueryString().getQueryParams()) {
      if (!firstParam) {
        requestUrlBuffer.append(""String_Node_Str"");
      }
      requestUrlBuffer.append(queryParam.getName());
      requestUrlBuffer.append(""String_Node_Str"");
      requestUrlBuffer.append(queryParam.getValue().replace(""String_Node_Str"",""String_Node_Str""));
      firstParam=false;
    }
  }
  logger.debug(""String_Node_Str"" + requestUrlBuffer.toString());
  HttpEntity httpEntity=new StringEntity(inMessage.getMessageContent().getRawContent());
  HttpUriRequest httpUriRequest;
  if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpGet(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    HttpPut httpPut=new HttpPut(requestUrlBuffer.toString());
    httpPut.setEntity(httpEntity);
    httpUriRequest=httpPut;
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpDelete(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpOptions(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpOptions(requestUrlBuffer.toString());
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(inMessage.getMethod())) {
    httpUriRequest=new HttpOptions(requestUrlBuffer.toString());
  }
 else {
    HttpPost httpPost=new HttpPost(requestUrlBuffer.toString());
    httpPost.setEntity(httpEntity);
    httpUriRequest=httpPost;
  }
  setHeaders(inMessage,httpUriRequest);
  Date requestSendDate=new Date();
  HttpResponse clientResponse=httpClient.execute(httpUriRequest);
  Date responseSendDate=new Date();
  OutMessage outMessage=new OutMessage(clientResponse.getStatusLine().getStatusCode(),clientResponse.getStatusLine().getReasonPhrase());
  inMessage.setRequestTimeStamp(requestSendDate.getTime());
  outMessage.setResponseTimeStamp(responseSendDate.getTime());
  MessageContent messageContent=new MessageContent();
  InputStreamReader in=new InputStreamReader(clientResponse.getEntity().getContent());
  BufferedReader bin=new BufferedReader(in);
  StringBuffer responseBuffer=new StringBuffer();
  String line;
  do {
    line=bin.readLine();
    if (line != null) {
      responseBuffer.append(line);
    }
  }
 while (line != null);
  messageContent.setRawContent(responseBuffer.toString());
  messageContent.setSize(clientResponse.getEntity().getContentLength());
  if (clientResponse.getEntity().getContentType() != null) {
    messageContent.setMimeType(clientResponse.getEntity().getContentType().getValue());
  }
  outMessage.setMessageContent(messageContent);
  return outMessage;
}"
18227,"/** 
 * @param templateField
 * @return
 */
private boolean match(AbstractTemplateField inputField,AbstractTemplateField recordedField){
  boolean match=false;
  if (recordedField.getFieldName().equals(inputField.getFieldName()) && recordedField.getDefaultValue().equals(inputField.getDefaultValue()) && recordedField.getFieldType().equals(inputField.getFieldType())) {
    match=true;
  }
  return match;
}","/** 
 * @param templateField
 * @return
 */
private boolean match(AbstractTemplateField inputField,AbstractTemplateField recordedField){
  boolean match=false;
  if (inputField.getFieldName().equals(recordedField.getFieldName()) && inputField.getDefaultValue().equals(recordedField.getDefaultValue()) && inputField.getFieldType().equals(recordedField.getFieldType())) {
    match=true;
  }
  return match;
}"
18228,"/** 
 * @param defaultValue
 */
public void setDefaultValue(String defaultValue){
  this.defaultValue=defaultValue;
}","/** 
 * @param defaultValue
 */
public void setDefaultValue(String defaultValue){
  this.defaultValue=defaultValue.replace(""String_Node_Str"",""String_Node_Str"");
}"
18229,public abstract void setPathParamPosition(int pathParamPosition);,"/** 
 * Number to define the parameter position in url path (eg : for http://localhost:8088/1/users/show/FR3Aquitaine.xml, the param user correspond to number 4 (FR3Aquitaine.xml)), the first '/' represent the root of the path. 
 * @param pathParamPosition
 */
public void setPathParamPosition(int pathParamPosition){
  this.pathParamPosition=pathParamPosition;
}"
18230,"/** 
 * Default constructor
 */
public AbstractTemplateField(){
  fieldName=""String_Node_Str"";
  fieldType=""String_Node_Str"";
  defaultValue=""String_Node_Str"";
  setFieldEquality(true);
}","/** 
 * Default constructor
 */
public AbstractTemplateField(){
  fieldName=""String_Node_Str"";
  fieldType=""String_Node_Str"";
  defaultValue=""String_Node_Str"";
  setFieldEquality(true);
  pathParamPosition=0;
}"
18231,public abstract int getPathParamPosition();,"/** 
 * @return
 */
public int getPathParamPosition(){
  return pathParamPosition;
}"
18232,"@Override public String renderRes(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  logger.warn(""String_Node_Str"");
  String renderedTemplate=template.renderRes(templatePath,runName,fieldValues);
  return renderedTemplate;
}","@Override public String renderRes(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  logger.warn(""String_Node_Str"");
  String renderedTemplate=template.renderRes(templatePath,runName,fieldValues);
  logger.debug(""String_Node_Str"" + renderedTemplate);
  return renderedTemplate;
}"
18233,"@Override public OutMessage renderReq(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  String renderedTemplate=template.renderReq(templatePath,runName,fieldValues);
  TemplateExecutor executor=new TemplateExecutor();
  return executor.execute(renderedTemplate);
}","@Override public OutMessage renderReq(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  String renderedTemplate=template.renderReq(templatePath,runName,fieldValues);
  logger.debug(""String_Node_Str"" + renderedTemplate);
  TemplateExecutor executor=new TemplateExecutor();
  return executor.execute(renderedTemplate);
}"
18234,"public String getResponsetemplate(){
  JSONObject jsonRecord=JSONObject.fromObject(customRecord.getOutMessage());
  return VELOCIMACRO_RESPONSE_PREFIX + ""String_Node_Str"" + jsonRecord.toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ VELOCIMACRO_SUFFIX;
}","public String getResponsetemplate(){
  JSONObject jsonRecord=JSONObject.fromObject(customRecord.getOutMessage());
  return VELOCIMACRO_RESPONSE_PREFIX + ""String_Node_Str"" + jsonRecord.toString()+ ""String_Node_Str""+ VELOCIMACRO_SUFFIX;
}"
18235,"public String getRequestTemplate(){
  JSONObject jsonRecord=JSONObject.fromObject(customRecord.getInMessage());
  return VELOCIMACRO_REQUEST_PREFIX + ""String_Node_Str"" + jsonRecord.toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ VELOCIMACRO_SUFFIX;
}","public String getRequestTemplate(){
  JSONObject jsonRecord=JSONObject.fromObject(customRecord.getInMessage());
  String jsonString;
  if (customRecord.getInMessage().getMessageContent().isXMLContent()) {
    jsonString=jsonRecord.toString();
  }
 else {
    jsonString=jsonRecord.toString().replace(""String_Node_Str"",""String_Node_Str"");
  }
  return VELOCIMACRO_REQUEST_PREFIX + ""String_Node_Str"" + jsonString+ ""String_Node_Str""+ VELOCIMACRO_SUFFIX;
}"
18236,"/** 
 * To get the Twitter URL data set
 * @return The Twitter URL data set
 */
public ArrayList<String> getTwitterUrlData(String baseUrl){
  if (baseUrl == null || ""String_Node_Str"".equals(baseUrl)) {
    logger.warn(""String_Node_Str"");
    baseUrl=""String_Node_Str"";
  }
  twitterTestSet=new ArrayList<String>();
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  return twitterTestSet;
}","/** 
 * To get the Twitter URL data set
 * @return The Twitter URL data set
 */
public ArrayList<String> getTwitterUrlData(String baseUrl){
  if (baseUrl == null || ""String_Node_Str"".equals(baseUrl)) {
    logger.warn(""String_Node_Str"");
    baseUrl=""String_Node_Str"";
  }
  twitterTestSet=new ArrayList<String>();
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  twitterTestSet.add(""String_Node_Str"" + baseUrl + ""String_Node_Str"");
  return twitterTestSet;
}"
18237,"/** 
 * Sets the text.
 * @param text The text to set.
 */
public void setRawContent(String rawContent){
  if (rawContent != null) {
    rawContent.replace(""String_Node_Str"",""String_Node_Str"");
    this.rawContent=rawContent;
    this.contentType=ContentChecker.checkJsonXmlContent(rawContent);
    if (ContentType.JSON.equals(contentType)) {
      this.JSONContent=JSONSerializer.toJSON(this.rawContent);
      this.XMLContent=null;
    }
 else     if (ContentType.XML.equals(contentType)) {
      try {
        DocumentBuilderFactory docFactory=DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder=docFactory.newDocumentBuilder();
        this.XMLContent=docBuilder.parse(new InputSource(new StringReader(this.rawContent)));
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        this.contentType=ContentType.Undefined;
        this.XMLContent=null;
      }
      this.JSONContent=null;
    }
 else {
      this.JSONContent=null;
      this.XMLContent=null;
    }
  }
 else {
    this.rawContent=""String_Node_Str"";
    this.contentType=ContentChecker.ContentType.Undefined;
  }
}","/** 
 * Sets the text.
 * @param text The text to set.
 */
public void setRawContent(String rawContent){
  if (rawContent != null) {
    this.rawContent=rawContent;
    this.contentType=ContentChecker.checkJsonXmlContent(rawContent);
    if (ContentType.JSON.equals(contentType)) {
      this.JSONContent=JSONSerializer.toJSON(rawContent);
      this.XMLContent=null;
    }
 else     if (ContentType.XML.equals(contentType)) {
      try {
        DocumentBuilderFactory docFactory=DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder=docFactory.newDocumentBuilder();
        this.XMLContent=docBuilder.parse(new InputSource(new StringReader(rawContent)));
      }
 catch (      Exception ex) {
        ex.printStackTrace();
        this.contentType=ContentType.Undefined;
        this.XMLContent=null;
      }
      this.JSONContent=null;
    }
 else {
      this.JSONContent=null;
      this.XMLContent=null;
    }
  }
 else {
    this.rawContent=""String_Node_Str"";
    this.contentType=ContentChecker.ContentType.Undefined;
  }
}"
18238,"/** 
 * Take the content params (eg : HTML form POST params) from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputContentParam(InMessage inMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getMessageContent().getRawContent(),""String_Node_Str"");
  String token;
  while (tokenizer.hasMoreTokens()) {
    token=tokenizer.nextToken();
    candidateField=new CandidateField(token.substring(0,token.indexOf(""String_Node_Str"")),token.substring(token.indexOf(""String_Node_Str"")));
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * Take the content params (eg : HTML form POST params) from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputContentParam(InMessage inMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getMessageContent().getRawContent(),""String_Node_Str"");
  String token;
  while (tokenizer.hasMoreTokens()) {
    token=tokenizer.nextToken();
    candidateField=new CandidateField(token.substring(0,token.indexOf(""String_Node_Str"")),token.substring(token.indexOf(""String_Node_Str"")));
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18239,"/** 
 * Take the query params from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters 
 */
public HashMap<String,CandidateField> getInputQueryParams(InMessage inMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  for (  QueryParam queryParam : inMessage.getQueryString().getQueryParams()) {
    candidateField=new CandidateField(queryParam.getName(),queryParam.getValue());
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * Take the query params from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters 
 */
public HashMap<String,CandidateField> getInputQueryParams(InMessage inMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  for (  QueryParam queryParam : inMessage.getQueryString().getQueryParams()) {
    candidateField=new CandidateField(queryParam.getName(),queryParam.getValue());
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18240,"/** 
 * Extract params from the url path
 * @param inMessage
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputPathParams(InMessage inMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField field;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getPath(),""String_Node_Str"");
  int pathPos=0;
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    field=new CandidateField(""String_Node_Str"" + pathPos,token);
    field.setKind(""String_Node_Str"");
    fieldMap.put(""String_Node_Str"" + pathPos,field);
    pathPos++;
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * Extract params from the url path
 * @param inMessage
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputPathParams(InMessage inMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField field;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getPath(),""String_Node_Str"");
  int pathPos=0;
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    field=new CandidateField(""String_Node_Str"" + pathPos,token);
    field.setKind(""String_Node_Str"");
    fieldMap.put(""String_Node_Str"" + pathPos,field);
    pathPos++;
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18241,"/** 
 * @param outMessage
 * @return
 */
public HashMap<String,CandidateField> getOutputFields(OutMessage outMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  List<TemplateParser> templateParserList=new ArrayList<TemplateParser>();
  templateParserList.add(new JSONParser());
  templateParserList.add(new XMLParser());
  try {
    for (    TemplateParser parser : templateParserList) {
      if (parser.canParse(outMessage)) {
        parser.parse(outMessage,fieldMap);
        break;
      }
    }
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * @param outMessage
 * @return
 */
public HashMap<String,CandidateField> getOutputFields(OutMessage outMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  logger.debug(""String_Node_Str"");
  List<TemplateParser> templateParserList=new ArrayList<TemplateParser>();
  templateParserList.add(new JSONParser());
  templateParserList.add(new XMLParser());
  try {
    for (    TemplateParser parser : templateParserList) {
      if (parser.canParse(outMessage)) {
        parser.parse(outMessage,fieldMap);
        break;
      }
    }
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18242,"@Override public SimulationStore getSimulationStoreFromSuggestion(String storeName,List<ExchangeRecord> exchangeRecordList){
  SimulationStore store=new SimulationStore(storeName);
  FieldExtractor extractor=new FieldExtractor();
  for (  ExchangeRecord exchangeRecord : exchangeRecordList) {
    TemplateFieldSuggestions suggestions=correlationEngine.correlateWithSubpath(exchangeRecord,extractor.getInputPathParams(exchangeRecord.getInMessage()),extractor.getInputQueryParams(exchangeRecord.getInMessage()),extractor.getInputContentParam(exchangeRecord.getInMessage()),extractor.getOutputFields(exchangeRecord.getOutMessage()));
    store.addRecordSuggestions(exchangeRecord,suggestions);
  }
  return store;
}","@Override public SimulationStore getSimulationStoreFromSuggestion(String storeName,List<ExchangeRecord> exchangeRecordList){
  SimulationStore store=new SimulationStore(storeName);
  FieldExtractor extractor=new FieldExtractor();
  for (  ExchangeRecord exchangeRecord : exchangeRecordList) {
    logger.debug(""String_Node_Str"" + exchangeRecord.getExchange().getExchangeID());
    TemplateFieldSuggestions suggestions=correlationEngine.correlateWithSubpath(exchangeRecord,extractor.getInputPathParams(exchangeRecord.getInMessage()),extractor.getInputQueryParams(exchangeRecord.getInMessage()),extractor.getInputContentParam(exchangeRecord.getInMessage()),extractor.getOutputFields(exchangeRecord.getOutMessage()));
    store.addRecordSuggestions(exchangeRecord,suggestions);
  }
  return store;
}"
18243,"@Override public ExchangeRecord simulate(ExchangeRecord exchangeRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions fieldSuggestions=correlationEngine.correlateWithSubpath(exchangeRecord,extractor.getInputPathParams(exchangeRecord.getInMessage()),extractor.getInputQueryParams(exchangeRecord.getInMessage()),extractor.getInputContentParam(exchangeRecord.getInMessage()),extractor.getOutputFields(exchangeRecord.getOutMessage()));
  templateEngine.generateTemplate(fieldSuggestions,exchangeRecord,simulationStore.getStoreName(),true);
  return method.simulate(exchangeRecord,fieldSuggestions,simulationStore,templateEngine,fieldValues);
}","@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions inputSuggestions=correlationEngine.correlateWithSubpath(inputRecord,extractor.getInputPathParams(inputRecord.getInMessage()),extractor.getInputQueryParams(inputRecord.getInMessage()),extractor.getInputContentParam(inputRecord.getInMessage()),extractor.getOutputFields(inputRecord.getOutMessage()));
  return method.simulate(inputRecord,inputSuggestions,simulationStore,templateEngine,fieldValues);
}"
18244,"@Override public boolean canParse(OutMessage outMessage){
  return outMessage.getMessageContent().isJSONContent();
}","@Override public boolean canParse(OutMessage outMessage){
  logger.debug(""String_Node_Str"" + outMessage.getMessageContent().isJSONContent());
  return outMessage.getMessageContent().isJSONContent();
}"
18245,"@Override public HashMap<String,CandidateField> parse(OutMessage outMessage,HashMap<String,CandidateField> fieldMap){
  JSONObject jsonOutObject=(JSONObject)JSONSerializer.toJSON(outMessage.getMessageContent().getRawContent());
  findJSONOutFields(""String_Node_Str"",jsonOutObject,-1,fieldMap);
  return fieldMap;
}","@Override public HashMap<String,CandidateField> parse(OutMessage outMessage,HashMap<String,CandidateField> fieldMap){
  logger.debug(""String_Node_Str"");
  JSONObject jsonOutObject=(JSONObject)JSONSerializer.toJSON(outMessage.getMessageContent().getRawContent());
  findJSONOutFields(""String_Node_Str"",jsonOutObject,-1,fieldMap);
  return fieldMap;
}"
18246,"@Override public boolean canParse(OutMessage outMessage){
  return outMessage.getMessageContent().isXMLContent();
}","@Override public boolean canParse(OutMessage outMessage){
  logger.debug(""String_Node_Str"" + outMessage.getMessageContent().isXMLContent());
  return outMessage.getMessageContent().isXMLContent();
}"
18247,"@Override public HashMap<String,CandidateField> parse(OutMessage outMessage,HashMap<String,CandidateField> fieldMap){
  Document content=outMessage.getMessageContent().getXMLContent();
  NodeList nodeList=content.getElementsByTagName(""String_Node_Str"");
  if (nodeList.getLength() > 0) {
    for (int index=0; index < nodeList.getLength(); index++) {
      Node node=nodeList.item(index);
      if (node.hasChildNodes() && node.getChildNodes().getLength() == 1) {
        CandidateField field=new CandidateField(node.getNodeName(),node.getTextContent());
        fieldMap.put(node.getNodeName(),field);
      }
    }
  }
  return fieldMap;
}","@Override public HashMap<String,CandidateField> parse(OutMessage outMessage,HashMap<String,CandidateField> fieldMap){
  logger.debug(""String_Node_Str"");
  Document content=outMessage.getMessageContent().getXMLContent();
  return fieldMap;
}"
18248,"/** 
 * Test the simulation engine
 * @throws Exception If a problem occurs
 */
@Test public void simulationEngineTest() throws Exception {
  String testStoreName=""String_Node_Str"";
  DefaultHttpClient httpClient=new DefaultHttpClient();
  HttpPost newRunPostRequest=new HttpPost(""String_Node_Str"" + testStoreName);
  assertEquals(""String_Node_Str"" + testStoreName + ""String_Node_Str"",httpClient.execute(newRunPostRequest,new BasicResponseHandler()));
  DefaultHttpClient httpProxyClient=new DefaultHttpClient();
  HttpHost proxy=new HttpHost(""String_Node_Str"",EasySOAConstants.HTTP_DISCOVERY_PROXY_PORT);
  httpProxyClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
  UrlMock urlMock=new UrlMock();
  HttpResponse response;
  HttpUriRequest httpUriRequest;
  for (  String url : urlMock.getTwitterUrlData(""String_Node_Str"" + EasySOAConstants.TWITTER_MOCK_PORT)) {
    logger.info(""String_Node_Str"" + url);
    httpUriRequest=new HttpGet(url);
    response=httpProxyClient.execute(httpUriRequest);
    ContentReader.read(response.getEntity().getContent());
  }
  HttpPost stopRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(stopRunPostRequest,new BasicResponseHandler()));
  HttpPost deleteRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(deleteRunPostRequest,new BasicResponseHandler()));
  ProxyFileStore fileStore=new ProxyFileStore();
  List<ExchangeRecord> recordList=fileStore.getExchangeRecordlist(testStoreName);
  ReplayEngine replayEngine=frascati.getService(componentList.get(0),""String_Node_Str"",org.easysoa.records.replay.ReplayEngine.class);
  SimulationEngine simulationEngine=replayEngine.getSimulationEngine();
  SimulationStore simulationStore=simulationEngine.getSimulationStoreFromSuggestion(""String_Node_Str"",recordList);
  fileStore.saveSimulationStore(simulationStore);
  for (  ExchangeRecord record : recordList) {
    Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
    ExchangeRecord simulatedResponse=simulationEngine.simulate(record,simulationStore,new SimpleSimulationMethod(),replayEngine.getTemplateEngine(),fieldValues);
    logger.debug(""String_Node_Str"" + simulatedResponse.getOutMessage().getMessageContent().getRawContent());
  }
}","/** 
 * Test the simulation engine
 * @throws Exception If a problem occurs
 */
@Test public void simulationEngineTest() throws Exception {
  String testStoreName=""String_Node_Str"";
  DefaultHttpClient httpClient=new DefaultHttpClient();
  HttpPost newRunPostRequest=new HttpPost(""String_Node_Str"" + testStoreName);
  assertEquals(""String_Node_Str"" + testStoreName + ""String_Node_Str"",httpClient.execute(newRunPostRequest,new BasicResponseHandler()));
  DefaultHttpClient httpProxyClient=new DefaultHttpClient();
  HttpHost proxy=new HttpHost(""String_Node_Str"",EasySOAConstants.HTTP_DISCOVERY_PROXY_PORT);
  httpProxyClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
  UrlMock urlMock=new UrlMock();
  HttpResponse response;
  HttpUriRequest httpUriRequest;
  for (  String url : urlMock.getTwitterUrlData(""String_Node_Str"" + EasySOAConstants.TWITTER_MOCK_PORT)) {
    logger.info(""String_Node_Str"" + url);
    httpUriRequest=new HttpGet(url);
    response=httpProxyClient.execute(httpUriRequest);
    ContentReader.read(response.getEntity().getContent());
  }
  HttpPost stopRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(stopRunPostRequest,new BasicResponseHandler()));
  HttpPost deleteRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(deleteRunPostRequest,new BasicResponseHandler()));
  ProxyFileStore fileStore=new ProxyFileStore();
  List<ExchangeRecord> recordList=fileStore.getExchangeRecordlist(testStoreName);
  ReplayEngine replayEngine=frascati.getService(componentList.get(0),""String_Node_Str"",org.easysoa.records.replay.ReplayEngine.class);
  SimulationEngine simulationEngine=replayEngine.getSimulationEngine();
  logger.debug(""String_Node_Str"");
  SimulationStore simulationStore=simulationEngine.getSimulationStoreFromSuggestion(""String_Node_Str"",recordList);
  for (  ExchangeRecord record : recordList) {
    Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
    ExchangeRecord simulatedResponse=simulationEngine.simulate(record,simulationStore,new SimpleSimulationMethod(),replayEngine.getTemplateEngine(),fieldValues);
    logger.debug(""String_Node_Str"" + simulatedResponse.getOutMessage().getMessageContent().getRawContent());
  }
}"
18249,"@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions inputSuggestions=correlationEngine.correlateWithSubpath(inputRecord,extractor.getInputPathParams(inputRecord.getInMessage()),extractor.getInputQueryParams(inputRecord.getInMessage()),extractor.getInputContentParam(inputRecord.getInMessage()),extractor.getOutputFields(inputRecord.getOutMessage()));
  return method.simulate(inputRecord,inputSuggestions,simulationStore,templateEngine,fieldValues);
}","@Override public ExchangeRecord simulate(ExchangeRecord exchangeRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions fieldSuggestions=correlationEngine.correlateWithSubpath(exchangeRecord,extractor.getInputPathParams(exchangeRecord.getInMessage()),extractor.getInputQueryParams(exchangeRecord.getInMessage()),extractor.getInputContentParam(exchangeRecord.getInMessage()),extractor.getOutputFields(exchangeRecord.getOutMessage()));
  templateEngine.generateTemplate(fieldSuggestions,exchangeRecord,simulationStore.getStoreName(),true);
  return method.simulate(exchangeRecord,fieldSuggestions,simulationStore,templateEngine,fieldValues);
}"
18250,"/** 
 * @param templateField
 * @return
 */
private boolean match(AbstractTemplateField inputField,AbstractTemplateField recordedField){
  boolean match=false;
  if (inputField.getFieldName().equals(recordedField.getFieldName()) && inputField.getDefaultValue().equals(recordedField.getDefaultValue()) && inputField.getFieldType().equals(recordedField.getFieldType())) {
    match=true;
  }
  return match;
}","/** 
 * @param templateField
 * @return
 */
private boolean match(AbstractTemplateField inputField,AbstractTemplateField recordedField){
  boolean match=false;
  if (recordedField.getFieldName().equals(inputField.getFieldName()) && recordedField.getDefaultValue().equals(inputField.getDefaultValue()) && recordedField.getFieldType().equals(inputField.getFieldType())) {
    match=true;
  }
  return match;
}"
18251,"@Override public HashMap<String,CandidateField> parse(OutMessage outMessage,HashMap<String,CandidateField> fieldMap){
  logger.debug(""String_Node_Str"");
  Document content=outMessage.getMessageContent().getXMLContent();
  return fieldMap;
}","@Override public HashMap<String,CandidateField> parse(OutMessage outMessage,HashMap<String,CandidateField> fieldMap){
  logger.debug(""String_Node_Str"");
  Document content=outMessage.getMessageContent().getXMLContent();
  NodeList nodeList=content.getElementsByTagName(""String_Node_Str"");
  if (nodeList.getLength() > 0) {
    for (int index=0; index < nodeList.getLength(); index++) {
      Node node=nodeList.item(index);
      if (node.hasChildNodes() && node.getChildNodes().getLength() == 1) {
        CandidateField field=new CandidateField(node.getNodeName(),node.getTextContent());
        fieldMap.put(node.getNodeName(),field);
      }
    }
  }
  return fieldMap;
}"
18252,"/** 
 * Test the simulation engine
 * @throws Exception If a problem occurs
 */
@Test public void simulationEngineTest() throws Exception {
  String testStoreName=""String_Node_Str"";
  DefaultHttpClient httpClient=new DefaultHttpClient();
  HttpPost newRunPostRequest=new HttpPost(""String_Node_Str"" + testStoreName);
  assertEquals(""String_Node_Str"" + testStoreName + ""String_Node_Str"",httpClient.execute(newRunPostRequest,new BasicResponseHandler()));
  DefaultHttpClient httpProxyClient=new DefaultHttpClient();
  HttpHost proxy=new HttpHost(""String_Node_Str"",EasySOAConstants.HTTP_DISCOVERY_PROXY_PORT);
  httpProxyClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
  UrlMock urlMock=new UrlMock();
  HttpResponse response;
  HttpUriRequest httpUriRequest;
  for (  String url : urlMock.getTwitterUrlData(""String_Node_Str"" + EasySOAConstants.TWITTER_MOCK_PORT)) {
    logger.info(""String_Node_Str"" + url);
    httpUriRequest=new HttpGet(url);
    response=httpProxyClient.execute(httpUriRequest);
    ContentReader.read(response.getEntity().getContent());
  }
  HttpPost stopRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(stopRunPostRequest,new BasicResponseHandler()));
  HttpPost deleteRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(deleteRunPostRequest,new BasicResponseHandler()));
  ProxyFileStore fileStore=new ProxyFileStore();
  List<ExchangeRecord> recordList=fileStore.getExchangeRecordlist(testStoreName);
  ReplayEngine replayEngine=frascati.getService(componentList.get(0),""String_Node_Str"",org.easysoa.records.replay.ReplayEngine.class);
  SimulationEngine simulationEngine=replayEngine.getSimulationEngine();
  logger.debug(""String_Node_Str"");
  SimulationStore simulationStore=simulationEngine.getSimulationStoreFromSuggestion(""String_Node_Str"",recordList);
  for (  ExchangeRecord record : recordList) {
    Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
    ExchangeRecord simulatedResponse=simulationEngine.simulate(record,simulationStore,new SimpleSimulationMethod(),replayEngine.getTemplateEngine(),fieldValues);
    logger.debug(""String_Node_Str"" + simulatedResponse.getOutMessage().getMessageContent().getRawContent());
  }
}","/** 
 * Test the simulation engine
 * @throws Exception If a problem occurs
 */
@Test public void simulationEngineTest() throws Exception {
  String testStoreName=""String_Node_Str"";
  DefaultHttpClient httpClient=new DefaultHttpClient();
  HttpPost newRunPostRequest=new HttpPost(""String_Node_Str"" + testStoreName);
  assertEquals(""String_Node_Str"" + testStoreName + ""String_Node_Str"",httpClient.execute(newRunPostRequest,new BasicResponseHandler()));
  DefaultHttpClient httpProxyClient=new DefaultHttpClient();
  HttpHost proxy=new HttpHost(""String_Node_Str"",EasySOAConstants.HTTP_DISCOVERY_PROXY_PORT);
  httpProxyClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
  UrlMock urlMock=new UrlMock();
  HttpResponse response;
  HttpUriRequest httpUriRequest;
  for (  String url : urlMock.getTwitterUrlData(""String_Node_Str"" + EasySOAConstants.TWITTER_MOCK_PORT)) {
    logger.info(""String_Node_Str"" + url);
    httpUriRequest=new HttpGet(url);
    response=httpProxyClient.execute(httpUriRequest);
    ContentReader.read(response.getEntity().getContent());
  }
  HttpPost stopRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(stopRunPostRequest,new BasicResponseHandler()));
  HttpPost deleteRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(deleteRunPostRequest,new BasicResponseHandler()));
  ProxyFileStore fileStore=new ProxyFileStore();
  List<ExchangeRecord> recordList=fileStore.getExchangeRecordlist(testStoreName);
  ReplayEngine replayEngine=frascati.getService(componentList.get(0),""String_Node_Str"",org.easysoa.records.replay.ReplayEngine.class);
  SimulationEngine simulationEngine=replayEngine.getSimulationEngine();
  logger.debug(""String_Node_Str"");
  SimulationStore simulationStore=simulationEngine.getSimulationStoreFromSuggestion(""String_Node_Str"",recordList);
  fileStore.saveSimulationStore(simulationStore);
  for (  ExchangeRecord record : recordList) {
    Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
    ExchangeRecord simulatedResponse=simulationEngine.simulate(record,simulationStore,new SimpleSimulationMethod(),replayEngine.getTemplateEngine(),fieldValues);
    logger.debug(""String_Node_Str"" + simulatedResponse.getOutMessage().getMessageContent().getRawContent());
  }
}"
18253,"/** 
 * Constructor
 */
public HttpDiscoveryProxy(){
  try {
    propertyManager=new ProxyPropertyManager(ProxyPropertyManager.PROPERTY_FILE_NAME,this.getClass().getResourceAsStream(""String_Node_Str"" + ProxyPropertyManager.PROPERTY_FILE_NAME));
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"");
    try {
      propertyManager=new ProxyPropertyManager();
    }
 catch (    Exception exc) {
      logger.error(""String_Node_Str"",exc);
    }
  }
}","/** 
 * Constructor
 */
public HttpDiscoveryProxy(){
  try {
    propertyManager=new ProxyPropertyManager();
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"");
    try {
      propertyManager=new ProxyPropertyManager(ProxyPropertyManager.PROPERTY_FILE_NAME,this.getClass().getResourceAsStream(""String_Node_Str"" + ProxyPropertyManager.PROPERTY_FILE_NAME));
    }
 catch (    Exception exc) {
      logger.error(""String_Node_Str"",exc);
    }
  }
}"
18254,"/** 
 * Save the current run
 */
@POST @Path(""String_Node_Str"") public void save();","/** 
 * Save the current run
 * @throws Exception 
 */
@POST @Path(""String_Node_Str"") public void save() throws Exception ;"
18255,"/** 
 * Constructor
 */
public HttpProxyDriverImpl(){
  try {
    propertyManager=new ProxyPropertyManager(ProxyPropertyManager.PROPERTY_FILE_NAME,this.getClass().getResourceAsStream(""String_Node_Str"" + ProxyPropertyManager.PROPERTY_FILE_NAME));
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"");
    try {
      propertyManager=new ProxyPropertyManager();
    }
 catch (    Exception exc) {
      logger.error(""String_Node_Str"",exc);
    }
  }
}","/** 
 * Constructor
 */
public HttpProxyDriverImpl(){
  try {
    propertyManager=new ProxyPropertyManager();
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"");
    try {
      propertyManager=new ProxyPropertyManager(ProxyPropertyManager.PROPERTY_FILE_NAME,this.getClass().getResourceAsStream(""String_Node_Str"" + ProxyPropertyManager.PROPERTY_FILE_NAME));
    }
 catch (    Exception exc) {
      logger.error(""String_Node_Str"",exc);
    }
  }
}"
18256,"public void save(){
}","public void save() throws Exception {
  runManager.save();
  runManager.getMonitoringService().registerDetectedServicesToNuxeo();
}"
18257,"public String stopCurrentRun(){
  logger.debug(""String_Node_Str"");
  try {
    runManager.stop();
    runManager.getMonitoringService().registerDetectedServicesToNuxeo();
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    return ex.getMessage();
  }
  return ""String_Node_Str"";
}","public String stopCurrentRun(){
  logger.debug(""String_Node_Str"");
  try {
    runManager.stop();
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
    return ex.getMessage();
  }
  return ""String_Node_Str"";
}"
18258,"/** 
 * To replay a customized exchange record using template, field suggestions and assertions files generated before.
 * @param formData
 * @param exchangeStoreName
 * @param exchangeRecordID
 * @param templateName
 * @return
 * @throws Exception
 */
@Override public OutMessage replayWithTemplate(Map<String,List<String>> formData,String exchangeStoreName,String exchangeRecordID) throws Exception {
  ProxyFileStore proxyFileStore=new ProxyFileStore();
  ExchangeRecord record=proxyFileStore.loadExchangeRecord(exchangeStoreName,exchangeRecordID,true);
  TemplateFieldSuggestions fieldSuggestions=templateEngine.suggestFields(record,exchangeStoreName,true);
  templateEngine.generateTemplate(fieldSuggestions,record,exchangeStoreName,true);
  OutMessage replayedResponse=templateEngine.renderTemplateAndReplay(exchangeStoreName,record,formData);
  AssertionSuggestions assertionSuggestions=assertionEngine.suggestAssertions(fieldSuggestions,record.getExchange().getExchangeID(),exchangeStoreName);
  List<AssertionResult> assertionResults=assertionEngine.executeAssertions(assertionSuggestions,record.getOutMessage(),replayedResponse);
  if (replaySessionName != null) {
    AssertionReport report=(AssertionReport)logEngine.getLogSession(replaySessionName).getReport();
    if (report != null) {
      report.AddAssertionResult(assertionResults);
    }
  }
  return replayedResponse;
}","/** 
 * To replay a customized exchange record using template, field suggestions and assertions files generated before.
 * @param formData
 * @param exchangeStoreName
 * @param exchangeRecordID
 * @param templateName
 * @return
 * @throws Exception
 */
@Override public OutMessage replayWithTemplate(Map<String,List<String>> formData,String exchangeStoreName,String exchangeRecordID) throws Exception {
  ProxyFileStore proxyFileStore=new ProxyFileStore();
  ExchangeRecord record=proxyFileStore.loadExchangeRecord(exchangeStoreName,exchangeRecordID,true);
  TemplateFieldSuggestions fieldSuggestions=templateEngine.suggestFields(record,exchangeStoreName,true);
  templateEngine.generateTemplate(fieldSuggestions,record,exchangeStoreName,true);
  OutMessage replayedResponse=templateEngine.renderTemplateAndReplay(exchangeStoreName,record,formData,false);
  AssertionSuggestions assertionSuggestions=assertionEngine.suggestAssertions(fieldSuggestions,record.getExchange().getExchangeID(),exchangeStoreName);
  List<AssertionResult> assertionResults=assertionEngine.executeAssertions(assertionSuggestions,record.getOutMessage(),replayedResponse);
  if (replaySessionName != null) {
    AssertionReport report=(AssertionReport)logEngine.getLogSession(replaySessionName).getReport();
    if (report != null) {
      report.AddAssertionResult(assertionResults);
    }
  }
  return replayedResponse;
}"
18259,"@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions inputSuggestions=correlationEngine.correlateWithSubpath(inputRecord,extractor.getInputPathParams(inputRecord.getInMessage()),extractor.getInputQueryParams(inputRecord.getInMessage()),extractor.getInputContentParam(inputRecord.getInMessage()),extractor.getOutputFields(inputRecord.getOutMessage()));
  return method.simulate(inputRecord,inputSuggestions,simulationStore,templateEngine,fieldValues);
}","@Override public ExchangeRecord simulate(ExchangeRecord exchangeRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions fieldSuggestions=correlationEngine.correlateWithSubpath(exchangeRecord,extractor.getInputPathParams(exchangeRecord.getInMessage()),extractor.getInputQueryParams(exchangeRecord.getInMessage()),extractor.getInputContentParam(exchangeRecord.getInMessage()),extractor.getOutputFields(exchangeRecord.getOutMessage()));
  templateEngine.generateTemplate(fieldSuggestions,exchangeRecord,simulationStore.getStoreName(),true);
  return method.simulate(exchangeRecord,fieldSuggestions,simulationStore,templateEngine,fieldValues);
}"
18260,"/** 
 * @param templateField
 * @return
 */
private boolean match(AbstractTemplateField inputField,AbstractTemplateField recordedField){
  boolean match=false;
  if (inputField.getFieldName().equals(recordedField.getFieldName()) && inputField.getDefaultValue().equals(recordedField.getDefaultValue())) {
    match=true;
  }
  return match;
}","/** 
 * @param templateField
 * @return
 */
private boolean match(AbstractTemplateField inputField,AbstractTemplateField recordedField){
  boolean match=false;
  if (recordedField.getFieldName().equals(inputField.getFieldName()) && recordedField.getDefaultValue().equals(inputField.getDefaultValue()) && recordedField.getFieldType().equals(inputField.getFieldType())) {
    match=true;
  }
  return match;
}"
18261,"@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,TemplateFieldSuggestions inputSuggestions,SimulationStore store,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  Iterator<ExchangeRecord> recordKeyIterator=store.getRecordList().keySet().iterator();
  while (recordKeyIterator.hasNext()) {
    ExchangeRecord record=recordKeyIterator.next();
    TemplateFieldSuggestions recordedSuggestions=store.getRecordList().get(record);
    if (matchAll(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues);
      inputRecord.setOutMessage(outMessage);
      break;
    }
 else     if (matchSome(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues);
      inputRecord.setOutMessage(outMessage);
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
  return inputRecord;
}","@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,TemplateFieldSuggestions inputSuggestions,SimulationStore store,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  Iterator<ExchangeRecord> recordKeyIterator=store.getRecordList().keySet().iterator();
  while (recordKeyIterator.hasNext()) {
    ExchangeRecord record=recordKeyIterator.next();
    TemplateFieldSuggestions recordedSuggestions=store.getRecordList().get(record);
    if (matchAll(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues,true);
      inputRecord.setOutMessage(outMessage);
      break;
    }
 else     if (matchSome(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues,true);
      inputRecord.setOutMessage(outMessage);
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
  return inputRecord;
}"
18262,"/** 
 * Generate templates for request and response part of an exchange record store in the template store : a customized record AND a velocity macro template 
 * @param fieldSuggestions Fields to replace by template expressions (Velocity expression in this case)
 * @param record The exchange record to templatize
 * @param runName The store name to save the template 
 * @return a templatized record
 * @throws Exception If a problem occurs
 */
public ExchangeRecord templatizeRecord(TemplateFieldSuggestions fieldSuggestions,ExchangeRecord record) throws Exception {
  if (fieldSuggestions == null || record == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  AbstractTemplateField field : fieldSuggestions.getTemplateFields()) {
    logger.debug(""String_Node_Str"" + field.getFieldName() + ""String_Node_Str""+ field.getDefaultValue());
    logger.debug(""String_Node_Str"" + field.getParamType() + ""String_Node_Str""+ field.getPathParamPosition());
    if (TemplateFieldType.IN_QUERY_PARAM.equals(field.getParamType())) {
      List<QueryParam> paramList=record.getInMessage().getQueryString().getQueryParams();
      for (      QueryParam param : paramList) {
        if (param.getName().equals(field.getFieldName())) {
          param.setValue(VARIABLE_BEAN_PREFIX + field.getFieldName() + VARIABLE_BEAN_SUFFIX);
          break;
        }
      }
    }
 else     if (TemplateFieldType.IN_PATH_PARAM.equals(field.getParamType())) {
      String path=record.getInMessage().getPath();
      record.getInMessage().setPath(path.replace(field.getDefaultValue(),VARIABLE_BEAN_PREFIX + field.getFieldName() + VARIABLE_BEAN_SUFFIX));
    }
 else     if (TemplateFieldType.IN_CONTENT_PARAM.equals(field.getParamType())) {
    }
 else     if (TemplateFieldType.IN_WSDL_PARAM.equals(field.getParamType())) {
    }
 else {
      logger.debug(""String_Node_Str"" + field.getParamType() + ""String_Node_Str"");
    }
  }
  return record;
}","/** 
 * Generate templates for request and response part of an exchange record store in the template store : a customized record AND a velocity macro template 
 * @param fieldSuggestions Fields to replace by template expressions (Velocity expression in this case)
 * @param record The exchange record to templatize
 * @param runName The store name to save the template 
 * @return a templatized record
 * @throws Exception If a problem occurs
 */
public ExchangeRecord templatizeRecord(TemplateFieldSuggestions fieldSuggestions,ExchangeRecord record) throws Exception {
  if (fieldSuggestions == null || record == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (  AbstractTemplateField field : fieldSuggestions.getTemplateFields()) {
    logger.debug(""String_Node_Str"" + field.getFieldName() + ""String_Node_Str""+ field.getDefaultValue());
    logger.debug(""String_Node_Str"" + field.getParamType() + ""String_Node_Str""+ field.getPathParamPosition());
    if (TemplateFieldType.IN_QUERY_PARAM.equals(field.getParamType())) {
      List<QueryParam> paramList=record.getInMessage().getQueryString().getQueryParams();
      for (      QueryParam param : paramList) {
        if (param.getName().equals(field.getFieldName())) {
          param.setValue(VARIABLE_BEAN_PREFIX + field.getFieldName() + VARIABLE_BEAN_SUFFIX);
          break;
        }
      }
    }
 else     if (TemplateFieldType.IN_PATH_PARAM.equals(field.getParamType())) {
      String path=record.getInMessage().getPath();
      record.getInMessage().setPath(path.replace(field.getDefaultValue(),VARIABLE_BEAN_PREFIX + field.getFieldName() + VARIABLE_BEAN_SUFFIX));
    }
 else     if (TemplateFieldType.IN_CONTENT_PARAM.equals(field.getParamType())) {
    }
 else     if (TemplateFieldType.IN_WSDL_PARAM.equals(field.getParamType())) {
    }
 else     if (TemplateFieldType.OUT_PARAM.equals(field.getParamType())) {
      String rawContent=record.getOutMessage().getMessageContent().getRawContent();
    }
 else {
      logger.debug(""String_Node_Str"" + field.getParamType() + ""String_Node_Str"");
    }
  }
  return record;
}"
18263,"/** 
 * Call the template renderer and replay the templatized record
 * @param storeName
 * @param recordID
 * @param fieldValues
 * @return the replayed response
 */
public abstract OutMessage renderTemplateAndReplay(String storeName,ExchangeRecord record,Map<String,List<String>> fieldValues) throws Exception ;","/** 
 * Call the template renderer and replay the templatized record
 * @param storeName The store name
 * @param recordID The record id
 * @param fieldValues The custom user field values
 * @param simulation true if we are in simulation mode, false otherwise
 * @return the replayed response
 */
public abstract OutMessage renderTemplateAndReplay(String storeName,ExchangeRecord record,Map<String,List<String>> fieldValues,boolean simulation) throws Exception ;"
18264,"@Override public OutMessage renderTemplateAndReplay(String storeName,ExchangeRecord record,Map<String,List<String>> fieldValues) throws Exception {
  String templatePath=""String_Node_Str"" + record.getExchange().getExchangeID() + ""String_Node_Str"";
  return templateRenderer.renderReq(templatePath,record,storeName,fieldValues);
}","@Override public OutMessage renderTemplateAndReplay(String storeName,ExchangeRecord record,Map<String,List<String>> fieldValues,boolean simulation) throws Exception {
  String templatePath;
  if (simulation) {
    templatePath=""String_Node_Str"" + record.getExchange().getExchangeID() + ""String_Node_Str"";
    return templateRenderer.renderRes(templatePath,record,storeName,fieldValues);
  }
 else {
    templatePath=""String_Node_Str"" + record.getExchange().getExchangeID() + ""String_Node_Str"";
    return templateRenderer.renderReq(templatePath,record,storeName,fieldValues);
  }
}"
18265,"/** 
 * Execute a rendered template and returns the response as an <code>OutMessage</code>
 * @param renderedTemplate The rendered template to execute
 * @return The response as an <code>OutMessage</code>
 * @throws Exception If a problem occurs
 */
public OutMessage execute(String renderedTemplate) throws Exception {
  JSONObject jsonInMessage=(JSONObject)JSONSerializer.toJSON(renderedTemplate);
  System.out.println(""String_Node_Str"" + jsonInMessage);
  HashMap<String,Class> classMap=new HashMap<String,Class>();
  classMap.put(""String_Node_Str"",Header.class);
  classMap.put(""String_Node_Str"",Header.class);
  classMap.put(""String_Node_Str"",CustomFields.class);
  classMap.put(""String_Node_Str"",CustomField.class);
  classMap.put(""String_Node_Str"",QueryString.class);
  classMap.put(""String_Node_Str"",QueryParam.class);
  InMessage inMessage=(InMessage)JSONObject.toBean(jsonInMessage,InMessage.class,classMap);
  RequestForwarder forwarder=new RequestForwarder();
  OutMessage outMessage=forwarder.send(inMessage);
  return outMessage;
}","/** 
 * Execute a rendered template and returns the response as an <code>OutMessage</code>
 * @param renderedTemplate The rendered template to execute
 * @return The response as an <code>OutMessage</code>
 * @throws Exception If a problem occurs
 */
public OutMessage execute(String renderedTemplate) throws Exception ;"
18266,"/** 
 * Render the response template by replacing template expression by provided values 
 * @param templatePath The response template
 * @param record The associated record
 * @param fieldValues Provided field values
 * @return The rendred template
 * @throws Exception If a problem occurs
 */
public String renderRes(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception ;","/** 
 * Render the response template by replacing template expression by provided values 
 * @param templatePath The response template
 * @param record The associated record
 * @param fieldValues Provided field values
 * @return The rendred template
 * @throws Exception If a problem occurs
 */
public OutMessage renderRes(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception ;"
18267,"@Override public String renderRes(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  logger.warn(""String_Node_Str"");
  String renderedTemplate=template.renderRes(templatePath,runName,fieldValues);
  logger.debug(""String_Node_Str"" + renderedTemplate);
  return renderedTemplate;
}","@Override public OutMessage renderRes(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  logger.warn(""String_Node_Str"");
  String renderedTemplate=template.renderRes(templatePath,runName,fieldValues);
  logger.debug(""String_Node_Str"" + renderedTemplate);
  TemplateExecutor executor=new ResponseTemplateExecutor();
  return executor.execute(renderedTemplate);
}"
18268,"@Override public OutMessage renderReq(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  String renderedTemplate=template.renderReq(templatePath,runName,fieldValues);
  logger.debug(""String_Node_Str"" + renderedTemplate);
  TemplateExecutor executor=new TemplateExecutor();
  return executor.execute(renderedTemplate);
}","@Override public OutMessage renderReq(String templatePath,ExchangeRecord record,String runName,Map<String,List<String>> fieldValues) throws Exception {
  String renderedTemplate=template.renderReq(templatePath,runName,fieldValues);
  logger.debug(""String_Node_Str"" + renderedTemplate);
  TemplateExecutor executor=new RequestTemplateExecutor();
  return executor.execute(renderedTemplate);
}"
18269,"/** 
 * Tests runtime discovery of services when FraSCAti starts an application. IMPORTANT since it should work in a ""remoted"" FraSCAti. PROBLEM : injected FraSCAti is the wrapper and not an actual ""remoted"" FraSCAti.
 * @throws FrascatiException
 * @throws Exception
 */
@Test public void testFraSCAtiRuntimeDiscovery() throws Exception {
  String scaZipFilePath=""String_Node_Str"" + ""String_Node_Str"";
  File scaZipFile=new File(scaZipFilePath);
  ApiRuntimeFraSCAtiScaImporter runtimeScaImporter=(ApiRuntimeFraSCAtiScaImporter)EasySOAApiFraSCAti.getInstance().newRuntimeScaImporter();
  frascati.setScaImporterRecipient(runtimeScaImporter);
  frascati.processComposite(""String_Node_Str"",FraSCAtiServiceItf.check,scaZipFile.toURI().toURL());
  checkExchanges(""String_Node_Str"");
}","/** 
 * Tests runtime discovery of services when FraSCAti starts an application. IMPORTANT since it should work in a ""remoted"" FraSCAti. PROBLEM : injected FraSCAti is the wrapper and not an actual ""remoted"" FraSCAti.
 * @throws FrascatiException
 * @throws Exception
 */
@Test public void testFraSCAtiRuntimeDiscovery() throws Exception {
  String scaZipFilePath=""String_Node_Str"" + ""String_Node_Str"";
  File scaZipFile=new File(scaZipFilePath);
  ApiRuntimeFraSCAtiScaImporter importer=(ApiRuntimeFraSCAtiScaImporter)EasySOAApiFraSCAti.getInstance().newRuntimeScaImporter();
  importer.setAppliImplURL(""String_Node_Str"");
  importer.setServiceStackType(""String_Node_Str"");
  importer.setServiceStackUrl(""String_Node_Str"");
  importer.compositeFile=new File(""String_Node_Str""){
    public String getName(){
      return ""String_Node_Str"";
    }
  }
;
  frascati.setScaImporterRecipient(importer);
  frascati.processComposite(""String_Node_Str"",FraSCAtiServiceItf.check,scaZipFile.toURI().toURL());
  checkExchanges(""String_Node_Str"");
}"
18270,"@After public void tearDown() throws Exception {
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  HttpAutomationClient client=new HttpAutomationClient(AUTOMATION_URL);
  Session session=client.getSession(""String_Node_Str"",""String_Node_Str"");
  OperationRequest request=session.newRequest(""String_Node_Str"");
  request.setHeader(""String_Node_Str"",""String_Node_Str"");
  request.set(""String_Node_Str"",""String_Node_Str"");
  logger.info(request.execute());
  session.close();
  client.shutdown();
  stopFraSCAti();
  JettyHTTPServerEngineFactory jettyFactory=BusFactory.getDefaultBus().getExtension(JettyHTTPServerEngineFactory.class);
  JettyHTTPServerEngine jettyServer=jettyFactory.retrieveJettyHTTPServerEngine(8080);
  Collection<Object> beans=jettyServer.getServer().getBeans();
  if (beans != null) {
    for (    Object bean : beans) {
      logger.info(""String_Node_Str"" + bean + ""String_Node_Str"");
      jettyServer.getServer().removeBean(bean);
    }
  }
  jettyFactory.destroyForPort(8080);
  logger.info(""String_Node_Str"");
}","@After public void tearDown() throws Exception {
  stopFraSCAti();
  JettyHTTPServerEngineFactory jettyFactory=BusFactory.getDefaultBus().getExtension(JettyHTTPServerEngineFactory.class);
  JettyHTTPServerEngine jettyServer=jettyFactory.retrieveJettyHTTPServerEngine(8080);
  Collection<Object> beans=jettyServer.getServer().getBeans();
  if (beans != null) {
    for (    Object bean : beans) {
      jettyServer.getServer().removeBean(bean);
    }
  }
  jettyFactory.destroyForPort(8080);
}"
18271,"/** 
 * Take the content params (eg : HTML form POST params) from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputContentParam(InMessage inMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getMessageContent().getRawContent(),""String_Node_Str"");
  String token;
  while (tokenizer.hasMoreTokens()) {
    token=tokenizer.nextToken();
    candidateField=new CandidateField(token.substring(0,token.indexOf(""String_Node_Str"")),token.substring(token.indexOf(""String_Node_Str"")));
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * Take the content params (eg : HTML form POST params) from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputContentParam(InMessage inMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getMessageContent().getRawContent(),""String_Node_Str"");
  String token;
  while (tokenizer.hasMoreTokens()) {
    token=tokenizer.nextToken();
    candidateField=new CandidateField(token.substring(0,token.indexOf(""String_Node_Str"")),token.substring(token.indexOf(""String_Node_Str"")));
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18272,"/** 
 * Take the query params from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters 
 */
public HashMap<String,CandidateField> getInputQueryParams(InMessage inMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  for (  QueryParam queryParam : inMessage.getQueryString().getQueryParams()) {
    candidateField=new CandidateField(queryParam.getName(),queryParam.getValue());
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * Take the query params from <code>InMessage</code> and fill an HashMap with them. 
 * @param inMessage <code>InMessage</code> containing query params
 * @return An <code>HashMap</code> filled with query parameters 
 */
public HashMap<String,CandidateField> getInputQueryParams(InMessage inMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField candidateField;
  for (  QueryParam queryParam : inMessage.getQueryString().getQueryParams()) {
    candidateField=new CandidateField(queryParam.getName(),queryParam.getValue());
    candidateField.setKind(""String_Node_Str"");
    fieldMap.put(candidateField.getPath(),candidateField);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18273,"/** 
 * Extract params from the url path
 * @param inMessage
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputPathParams(InMessage inMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField field;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getPath(),""String_Node_Str"");
  int pathPos=0;
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    field=new CandidateField(""String_Node_Str"" + pathPos,token);
    field.setKind(""String_Node_Str"");
    fieldMap.put(""String_Node_Str"" + pathPos,field);
    pathPos++;
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * Extract params from the url path
 * @param inMessage
 * @return An <code>HashMap</code> filled with query parameters
 */
public HashMap<String,CandidateField> getInputPathParams(InMessage inMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  CandidateField field;
  StringTokenizer tokenizer=new StringTokenizer(inMessage.getPath(),""String_Node_Str"");
  int pathPos=0;
  while (tokenizer.hasMoreTokens()) {
    String token=tokenizer.nextToken();
    field=new CandidateField(""String_Node_Str"" + pathPos,token);
    field.setKind(""String_Node_Str"");
    fieldMap.put(""String_Node_Str"" + pathPos,field);
    pathPos++;
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18274,"/** 
 * @param outMessage
 * @return
 */
public HashMap<String,CandidateField> getOutputFields(OutMessage outMessage){
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  logger.debug(""String_Node_Str"" + outMessage.getMessageContent().getRawContent());
  List<TemplateParser> templateParserList=new ArrayList<TemplateParser>();
  templateParserList.add(new JSONParser());
  templateParserList.add(new XMLParser());
  try {
    for (    TemplateParser parser : templateParserList) {
      if (parser.canParse(outMessage)) {
        parser.parse(outMessage,fieldMap);
        break;
      }
    }
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}","/** 
 * @param outMessage
 * @return
 */
public HashMap<String,CandidateField> getOutputFields(OutMessage outMessage){
  logger.debug(""String_Node_Str"");
  HashMap<String,CandidateField> fieldMap=new HashMap<String,CandidateField>();
  List<TemplateParser> templateParserList=new ArrayList<TemplateParser>();
  templateParserList.add(new JSONParser());
  templateParserList.add(new XMLParser());
  try {
    for (    TemplateParser parser : templateParserList) {
      if (parser.canParse(outMessage)) {
        parser.parse(outMessage,fieldMap);
        break;
      }
    }
  }
 catch (  Exception ex) {
    logger.warn(""String_Node_Str"",ex);
  }
  logger.debug(""String_Node_Str"" + fieldMap);
  return fieldMap;
}"
18275,"/** 
 * Process a simulation
 * @param inputRecord The input exchange record
 * @param simulationStore The simulation store to use for data matching
 * @param method The simulation method to use
 * @param templateEngine the template engine to use
 * @return A exchange record containing the simulated response
 * @throws Exception If a problem occurs
 */
public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine) throws Exception ;","/** 
 * Process a simulation
 * @param inputRecord The input exchange record
 * @param simulationStore The simulation store to use for data matching
 * @param method The simulation method to use
 * @param templateEngine the template engine to use
 * @return A exchange record containing the simulated response
 * @throws Exception If a problem occurs
 */
public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception ;"
18276,"@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions inputSuggestions=correlationEngine.correlateWithSubpath(inputRecord,extractor.getInputPathParams(inputRecord.getInMessage()),extractor.getInputQueryParams(inputRecord.getInMessage()),extractor.getInputContentParam(inputRecord.getInMessage()),extractor.getOutputFields(inputRecord.getOutMessage()));
  return method.simulate(inputRecord,inputSuggestions,simulationStore,templateEngine);
}","@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,SimulationStore simulationStore,SimulationMethod method,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  FieldExtractor extractor=new FieldExtractor();
  TemplateFieldSuggestions inputSuggestions=correlationEngine.correlateWithSubpath(inputRecord,extractor.getInputPathParams(inputRecord.getInMessage()),extractor.getInputQueryParams(inputRecord.getInMessage()),extractor.getInputContentParam(inputRecord.getInMessage()),extractor.getOutputFields(inputRecord.getOutMessage()));
  return method.simulate(inputRecord,inputSuggestions,simulationStore,templateEngine,fieldValues);
}"
18277,"/** 
 * Simulate the exchange
 * @param inputSuggestions 
 * @param templateEngine 
 * @throws Exception 
 */
public ExchangeRecord simulate(ExchangeRecord inputRecord,TemplateFieldSuggestions inputSuggestions,SimulationStore store,TemplateEngine templateEngine) throws Exception ;","/** 
 * Simulate the exchange
 * @param inputSuggestions 
 * @param templateEngine 
 * @throws Exception 
 */
public ExchangeRecord simulate(ExchangeRecord inputRecord,TemplateFieldSuggestions inputSuggestions,SimulationStore store,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception ;"
18278,"/** 
 * Match some field suggestions
 * @return
 */
private boolean matchSome(TemplateFieldSuggestions inputSuggestions,TemplateFieldSuggestions recordedSuggestions){
  return false;
}","/** 
 * Match some field suggestions
 * @return True if at least one match is found, false otherwise
 */
private boolean matchSome(TemplateFieldSuggestions inputSuggestions,TemplateFieldSuggestions recordedSuggestions){
  boolean matchSome=false;
  for (  AbstractTemplateField inputField : inputSuggestions.getTemplateFields()) {
    for (    AbstractTemplateField recordedField : recordedSuggestions.getTemplateFields()) {
      if (match(inputField,recordedField)) {
        matchSome=true;
      }
    }
  }
  logger.debug(""String_Node_Str"" + matchSome);
  return matchSome;
}"
18279,"@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,TemplateFieldSuggestions inputSuggestions,SimulationStore store,TemplateEngine templateEngine) throws Exception {
  ExchangeRecord outputRecord=new ExchangeRecord();
  Iterator<ExchangeRecord> recordKeyIterator=store.getRecordList().keySet().iterator();
  while (recordKeyIterator.hasNext()) {
    ExchangeRecord record=recordKeyIterator.next();
    TemplateFieldSuggestions recordedSuggestions=store.getRecordList().get(record);
    if (matchAll(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues);
      inputRecord.setOutMessage(outMessage);
      break;
    }
 else     if (matchSome(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues);
      inputRecord.setOutMessage(outMessage);
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
  return inputRecord;
}","@Override public ExchangeRecord simulate(ExchangeRecord inputRecord,TemplateFieldSuggestions inputSuggestions,SimulationStore store,TemplateEngine templateEngine,Map<String,List<String>> fieldValues) throws Exception {
  Iterator<ExchangeRecord> recordKeyIterator=store.getRecordList().keySet().iterator();
  while (recordKeyIterator.hasNext()) {
    ExchangeRecord record=recordKeyIterator.next();
    TemplateFieldSuggestions recordedSuggestions=store.getRecordList().get(record);
    if (matchAll(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues);
      inputRecord.setOutMessage(outMessage);
      break;
    }
 else     if (matchSome(inputSuggestions,recordedSuggestions)) {
      logger.debug(""String_Node_Str"");
      OutMessage outMessage=templateEngine.renderTemplateAndReplay(store.getStoreName(),inputRecord,fieldValues);
      inputRecord.setOutMessage(outMessage);
    }
 else {
      logger.debug(""String_Node_Str"");
    }
  }
  return inputRecord;
}"
18280,"/** 
 * Match all fields suggestions
 * @return
 */
private boolean matchAll(TemplateFieldSuggestions inputSuggestions,TemplateFieldSuggestions recordedSuggestions){
  boolean matchAll=true;
  for (  AbstractTemplateField inputField : inputSuggestions.getTemplateFields()) {
    for (    AbstractTemplateField recordedField : recordedSuggestions.getTemplateFields()) {
      if (match(inputField,recordedField)) {
        matchAll=matchAll & true;
      }
 else {
        matchAll=matchAll & false;
      }
    }
  }
  return false;
}","/** 
 * Match all fields suggestions
 * @return True if all fields match, false otherwise
 */
private boolean matchAll(TemplateFieldSuggestions inputSuggestions,TemplateFieldSuggestions recordedSuggestions){
  boolean matchAll=true;
  for (  AbstractTemplateField inputField : inputSuggestions.getTemplateFields()) {
    for (    AbstractTemplateField recordedField : recordedSuggestions.getTemplateFields()) {
      if (match(inputField,recordedField)) {
        matchAll=matchAll & true;
      }
 else {
        matchAll=matchAll & false;
      }
    }
  }
  logger.debug(""String_Node_Str"" + matchAll);
  return matchAll;
}"
18281,"/** 
 * Test the simulation engine
 * @throws Exception If a problem occurs
 */
@Test public void simulationEngineTest() throws Exception {
  String testStoreName=""String_Node_Str"";
  DefaultHttpClient httpClient=new DefaultHttpClient();
  HttpPost newRunPostRequest=new HttpPost(""String_Node_Str"" + testStoreName);
  assertEquals(""String_Node_Str"" + testStoreName + ""String_Node_Str"",httpClient.execute(newRunPostRequest,new BasicResponseHandler()));
  DefaultHttpClient httpProxyClient=new DefaultHttpClient();
  HttpHost proxy=new HttpHost(""String_Node_Str"",EasySOAConstants.HTTP_DISCOVERY_PROXY_PORT);
  httpProxyClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
  UrlMock urlMock=new UrlMock();
  HttpResponse response;
  HttpUriRequest httpUriRequest;
  for (  String url : urlMock.getTwitterUrlData(""String_Node_Str"" + EasySOAConstants.TWITTER_MOCK_PORT)) {
    logger.info(""String_Node_Str"" + url);
    httpUriRequest=new HttpGet(url);
    response=httpProxyClient.execute(httpUriRequest);
    ContentReader.read(response.getEntity().getContent());
  }
  HttpPost stopRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(stopRunPostRequest,new BasicResponseHandler()));
  HttpPost deleteRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(deleteRunPostRequest,new BasicResponseHandler()));
  ProxyFileStore fileStore=new ProxyFileStore();
  List<ExchangeRecord> recordList=fileStore.getExchangeRecordlist(testStoreName);
  ReplayEngine replayEngine=frascati.getService(componentList.get(0),""String_Node_Str"",org.easysoa.records.replay.ReplayEngine.class);
  SimulationEngine simulationEngine=replayEngine.getSimulationEngine();
  SimulationStore simulationStore=simulationEngine.getSimulationStoreFromSuggestion(""String_Node_Str"",recordList);
  fileStore.saveSimulationStore(simulationStore);
  for (  ExchangeRecord record : recordList) {
    ExchangeRecord simulatedResponse=simulationEngine.simulate(record,simulationStore,new SimpleSimulationMethod(),replayEngine.getTemplateEngine());
    logger.debug(""String_Node_Str"" + simulatedResponse.getOutMessage().getMessageContent().getRawContent());
  }
}","/** 
 * Test the simulation engine
 * @throws Exception If a problem occurs
 */
@Test public void simulationEngineTest() throws Exception {
  String testStoreName=""String_Node_Str"";
  DefaultHttpClient httpClient=new DefaultHttpClient();
  HttpPost newRunPostRequest=new HttpPost(""String_Node_Str"" + testStoreName);
  assertEquals(""String_Node_Str"" + testStoreName + ""String_Node_Str"",httpClient.execute(newRunPostRequest,new BasicResponseHandler()));
  DefaultHttpClient httpProxyClient=new DefaultHttpClient();
  HttpHost proxy=new HttpHost(""String_Node_Str"",EasySOAConstants.HTTP_DISCOVERY_PROXY_PORT);
  httpProxyClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY,proxy);
  UrlMock urlMock=new UrlMock();
  HttpResponse response;
  HttpUriRequest httpUriRequest;
  for (  String url : urlMock.getTwitterUrlData(""String_Node_Str"" + EasySOAConstants.TWITTER_MOCK_PORT)) {
    logger.info(""String_Node_Str"" + url);
    httpUriRequest=new HttpGet(url);
    response=httpProxyClient.execute(httpUriRequest);
    ContentReader.read(response.getEntity().getContent());
  }
  HttpPost stopRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(stopRunPostRequest,new BasicResponseHandler()));
  HttpPost deleteRunPostRequest=new HttpPost(""String_Node_Str"");
  assertEquals(""String_Node_Str"",httpClient.execute(deleteRunPostRequest,new BasicResponseHandler()));
  ProxyFileStore fileStore=new ProxyFileStore();
  List<ExchangeRecord> recordList=fileStore.getExchangeRecordlist(testStoreName);
  ReplayEngine replayEngine=frascati.getService(componentList.get(0),""String_Node_Str"",org.easysoa.records.replay.ReplayEngine.class);
  SimulationEngine simulationEngine=replayEngine.getSimulationEngine();
  SimulationStore simulationStore=simulationEngine.getSimulationStoreFromSuggestion(""String_Node_Str"",recordList);
  fileStore.saveSimulationStore(simulationStore);
  for (  ExchangeRecord record : recordList) {
    Map<String,List<String>> fieldValues=new HashMap<String,List<String>>();
    ExchangeRecord simulatedResponse=simulationEngine.simulate(record,simulationStore,new SimpleSimulationMethod(),replayEngine.getTemplateEngine(),fieldValues);
    logger.debug(""String_Node_Str"" + simulatedResponse.getOutMessage().getMessageContent().getRawContent());
  }
}"
18282,"@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Object doGetServiceJSONP(@Context HttpContext httpContext,@Context HttpServletRequest request,@QueryParam(""String_Node_Str"") String callback) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,List<String>> multiValuedParams=httpContext.getRequest().getQueryParameters();
  Map<String,String> params=new HashMap<String,String>();
  for (  Entry<String,List<String>> entry : multiValuedParams.entrySet()) {
    List<String> value=entry.getValue();
    if (value != null) {
      params.put(entry.getKey(),value.get(value.size() - 1));
    }
  }
  try {
    EasySOADocument doc=api.notifyService(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult(callback);
}","@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public Object doGetServiceJSONP(@Context HttpContext httpContext,@Context HttpServletRequest request,@QueryParam(""String_Node_Str"") String callback) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFirstValues2(httpContext.getRequest().getQueryParameters());
  try {
    EasySOADocument doc=api.notifyService(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult(callback);
}"
18283,"@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostApi(@Context HttpContext httpContext,@Context HttpServletRequest request,String body) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFormValues(body);
  try {
    EasySOADocument doc=api.notifyServiceApi(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}","@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostApi(@Context HttpContext httpContext,@Context HttpServletRequest request) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFirstValues(request.getParameterMap());
  try {
    EasySOADocument doc=api.notifyServiceApi(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}"
18284,"@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostService(@Context HttpContext httpContext,@Context HttpServletRequest request,String body) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  if (body != null && body.length() > 2) {
    body=body.substring(1,body.length() - 1);
  }
  Map<String,String> params=getFormValues(body);
  try {
    EasySOADocument doc=api.notifyService(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}","@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostService(@Context HttpContext httpContext,@Context HttpServletRequest request) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFirstValues(request.getParameterMap());
  try {
    EasySOADocument doc=api.notifyService(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}"
18285,"@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostAppliImpl(@Context HttpContext httpContext,@Context HttpServletRequest request,String body) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFormValues(body);
  try {
    EasySOADocument doc=api.notifyAppliImpl(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}","@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostAppliImpl(@Context HttpContext httpContext,@Context HttpServletRequest request) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFirstValues(request.getParameterMap());
  try {
    EasySOADocument doc=api.notifyAppliImpl(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}"
18286,"@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostServiceReference(@Context HttpContext httpContext,@Context HttpServletRequest request,String body) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFormValues(body);
  try {
    EasySOADocument doc=api.notifyServiceReference(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}","@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces(MediaType.APPLICATION_JSON) public Object doPostServiceReference(@Context HttpContext httpContext,@Context HttpServletRequest request,String body) throws Exception {
  EasySOAApiSession api=EasySOALocalApiFactory.createLocalApi(SessionFactory.getSession(request));
  Map<String,String> params=getFirstValues(request.getParameterMap());
  try {
    EasySOADocument doc=api.notifyServiceReference(params);
    result.put(""String_Node_Str"",doc.getId());
  }
 catch (  Exception e) {
    appendError(e.getMessage());
  }
  return getFormattedResult();
}"
18287,"@POST @Path(""String_Node_Str"") public Object doPost(@Context HttpContext httpContext,String body) throws Exception {
  Map<String,String> formValues=DiscoveryRest.getFormValues(body);
  BrowsingContext browsingContext=new BrowsingContext(new URL(formValues.get(""String_Node_Str"")),formValues.get(""String_Node_Str""));
  return findWSDls(browsingContext);
}","@POST @Path(""String_Node_Str"") public Object doPost(@Context HttpContext httpContext,@Context HttpServletRequest request) throws Exception {
  Map<String,String> formValues=DiscoveryRest.getFirstValues(request.getParameterMap());
  BrowsingContext browsingContext=new BrowsingContext(new URL(formValues.get(""String_Node_Str"")),formValues.get(""String_Node_Str""));
  return findWSDls(browsingContext);
}"
18288,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18289,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18290,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18291,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18292,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18293,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18294,"/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws FrascatiException {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}","/** 
 * Stop FraSCAti components
 * @throws FrascatiException
 */
@AfterClass public static void cleanUp() throws Exception {
  logger.info(""String_Node_Str"");
  stopFraSCAti();
}"
18295,"/** 
 * @throws FrascatiException
 */
protected static void stopFraSCAti() throws FrascatiException {
  logger.info(""String_Node_Str"");
  if (componentList != null) {
    for (    String component : componentList) {
      logger.debug(""String_Node_Str"" + component);
      frascati.stop(component);
    }
  }
  frascati=null;
}","/** 
 * @throws FrascatiException
 */
protected static void stopFraSCAti() throws Exception {
  logger.info(""String_Node_Str"");
  if (componentList != null) {
    for (    String component : componentList) {
      logger.debug(""String_Node_Str"" + component);
      frascati.stop(component);
    }
  }
  frascati=null;
}"
18296,"/** 
 * Start HTTP Proxy
 * @throws FrascatiException
 * @throws FraSCAtiServiceException 
 */
protected static void startHttpDiscoveryProxy(String composite,URL... urls) throws FrascatiException, FraSCAtiServiceException {
  logger.info(""String_Node_Str"");
  String component=frascati.processComposite(composite,FraSCAtiServiceItf.all,urls);
  componentList.add(component);
}","/** 
 * Start HTTP Proxy
 * @throws FrascatiException
 * @throws FraSCAtiServiceException 
 */
protected static void startHttpDiscoveryProxy(String composite,URL... urls) throws Exception {
  logger.info(""String_Node_Str"");
  String component=frascati.processComposite(composite,FraSCAtiServiceItf.all,urls);
  componentList.add(component);
}"
18297,"/** 
 * Start the services mock for tests (Meteo mock, twitter mock ...)
 * @param withNuxeoMock If true, the Nuxeo mock is started
 * @throws FrascatiException if a problem occurs during the start of composites
 * @throws FraSCAtiServiceException 
 */
protected static void startMockServices(boolean withNuxeoMock) throws FrascatiException, FraSCAtiServiceException {
  logger.info(""String_Node_Str"");
  componentList.add(frascati.processComposite(""String_Node_Str""));
  if (withNuxeoMock) {
    componentList.add(frascati.processComposite(""String_Node_Str""));
  }
  componentList.add(frascati.processComposite(""String_Node_Str""));
}","/** 
 * Start the services mock for tests (Meteo mock, twitter mock ...)
 * @param withNuxeoMock If true, the Nuxeo mock is started
 * @throws FrascatiException if a problem occurs during the start of composites
 * @throws FraSCAtiServiceException 
 */
protected static void startMockServices(boolean withNuxeoMock) throws Exception {
  logger.info(""String_Node_Str"");
  componentList.add(frascati.processComposite(""String_Node_Str""));
  if (withNuxeoMock) {
    componentList.add(frascati.processComposite(""String_Node_Str""));
  }
  componentList.add(frascati.processComposite(""String_Node_Str""));
}"
18298,"public void handleEvent(Event event){
  EventContext context=event.getContext();
  CoreSession session=context.getCoreSession();
  DocumentModel doc=((DocumentEventContext)context).getSourceDocument();
  try {
    DocumentService docService=Framework.getService(DocumentService.class);
    DocumentModel workspace=docService.getWorkspace(session,doc);
    ServiceValidationService validationService=Framework.getService(ServiceValidationService.class);
    Boolean wasValidated=(Boolean)workspace.getProperty(Workspace.SCHEMA,Workspace.PROP_ISVALIDATED);
    boolean isValidated;
    if (wasValidated != null && wasValidated) {
      isValidated=validationService.validateServices(session,doc).isEveryValidationPassed();
    }
 else {
      isValidated=validationService.validateServices(session,workspace).isEveryValidationPassed();
    }
    if (wasValidated == null || wasValidated != isValidated) {
      workspace.setProperty(Workspace.SCHEMA,Workspace.PROP_ISVALIDATED,isValidated);
      session.saveDocument(workspace);
    }
    session.save();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + doc.getType(),e);
  }
}","public void handleEvent(Event event){
  EventContext context=event.getContext();
  CoreSession session=context.getCoreSession();
  DocumentModel doc=((DocumentEventContext)context).getSourceDocument();
  try {
    DocumentService docService=Framework.getService(DocumentService.class);
    DocumentModel workspace=docService.getWorkspace(session,doc);
    ServiceValidationService validationService=Framework.getService(ServiceValidationService.class);
    boolean hasReferenceEnvironment=workspace.getProperty(Workspace.SCHEMA,Workspace.PROP_REFERENCEDENVIRONMENT) != null;
    if (hasReferenceEnvironment) {
      Boolean wasValidated=(Boolean)workspace.getProperty(Workspace.SCHEMA,Workspace.PROP_ISVALIDATED);
      boolean isValidated;
      if (wasValidated != null && wasValidated) {
        isValidated=validationService.validateServices(session,doc).isEveryValidationPassed();
      }
 else {
        isValidated=validationService.validateServices(session,workspace).isEveryValidationPassed();
      }
      if (wasValidated == null || wasValidated != isValidated) {
        workspace.setProperty(Workspace.SCHEMA,Workspace.PROP_ISVALIDATED,isValidated);
        session.saveDocument(workspace);
      }
      session.save();
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"" + doc.getType(),e);
  }
}"
18299,"private DocumentModel findFirstDocument(CoreSession session,String type,String field,String value) throws ClientException {
  DocumentModelList results=session.query(""String_Node_Str"" + type + ""String_Node_Str""+ field+ ""String_Node_Str""+ value+ ""String_Node_Str"",new Filter(){
    private static final long serialVersionUID=1L;
    public boolean accept(    DocumentModel docModel){
      try {
        return docModel.isLatestVersion() || !docModel.hasFacet(""String_Node_Str"");
      }
 catch (      ClientException e) {
        return false;
      }
    }
  }
);
  return (results != null && !results.isEmpty()) ? results.get(0) : null;
}","private DocumentModel findFirstDocument(CoreSession session,String type,String field,String value) throws ClientException {
  DocumentModelList results=session.query(""String_Node_Str"" + type + ""String_Node_Str""+ field+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  return (results != null && !results.isEmpty()) ? results.get(0) : null;
}"
18300,"@Override public void run(){
  LoginContext loginContext=null;
  HttpDownloaderService downloaderService=Framework.getLocalService(HttpDownloaderService.class);
  while (true) {
    boolean empty;
synchronized (parsingPool) {
      empty=parsingPool.isEmpty();
    }
    if (empty) {
      try {
synchronized (this) {
          wait();
        }
      }
 catch (      InterruptedException e) {
      }
    }
    WebFileParsingPoolEntry entry=null;
synchronized (parsingPool) {
      if (!parsingPool.isEmpty()) {
        entry=parsingPool.pop();
      }
    }
    if (entry != null) {
      try {
        HttpDownloader httpDownloader=downloaderService.createHttpDownloader(entry.getUrl());
        Blob blob=httpDownloader.download().getBlob();
        DocumentModel targetModel=entry.getTargetModel();
        String storageProp=entry.getStorageProp();
        if (storageProp != null) {
          targetModel.getProperty(storageProp).setValue(blob);
        }
        loginContext=Framework.login();
        RepositoryManager mgr=Framework.getService(RepositoryManager.class);
        Repository repository=mgr.getDefaultRepository();
        TransactionHelper.startTransaction();
        CoreSession coreSession=null;
        try {
          if (repository != null) {
            coreSession=repository.open();
          }
          if (coreSession != null) {
            for (            WebFileParser parser : parsers.values()) {
              parser.parse(coreSession,blob,targetModel,entry.getOptions());
            }
            coreSession.saveDocument(targetModel);
            coreSession.save();
          }
 else {
            throw new ClientException(""String_Node_Str"");
          }
        }
 catch (        Throwable t) {
          log.warn(""String_Node_Str"" + t.getMessage());
          TransactionHelper.setTransactionRollbackOnly();
        }
 finally {
          TransactionHelper.commitOrRollbackTransaction();
          CoreInstance.getInstance().close(coreSession);
          loginContext.logout();
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"",e);
      }
    }
  }
}","@Override public void run(){
  HttpDownloaderService downloaderService=Framework.getLocalService(HttpDownloaderService.class);
  while (true) {
    boolean empty;
synchronized (parsingPool) {
      empty=parsingPool.isEmpty();
    }
    if (empty) {
      try {
synchronized (this) {
          wait();
        }
      }
 catch (      InterruptedException e) {
      }
    }
    WebFileParsingPoolEntry entry=null;
synchronized (parsingPool) {
      if (!parsingPool.isEmpty()) {
        entry=parsingPool.pop();
      }
    }
    if (entry != null) {
      try {
        HttpDownloader httpDownloader=downloaderService.createHttpDownloader(entry.getUrl());
        Blob blob=httpDownloader.download().getBlob();
        DocumentModel targetModel=entry.getTargetModel();
        String storageProp=entry.getStorageProp();
        if (storageProp != null) {
          targetModel.getProperty(storageProp).setValue(blob);
        }
        try {
          loginContext=Framework.login();
          RepositoryManager mgr=Framework.getService(RepositoryManager.class);
          Repository repository=mgr.getDefaultRepository();
          TransactionHelper.startTransaction();
          coreSession=null;
          if (repository != null) {
            coreSession=repository.open();
          }
          if (coreSession != null) {
            for (            WebFileParser parser : parsers.values()) {
              parser.parse(coreSession,blob,targetModel,entry.getOptions());
            }
            coreSession.saveDocument(targetModel);
            coreSession.save();
          }
 else {
            throw new ClientException(""String_Node_Str"");
          }
        }
 catch (        Throwable t) {
          log.warn(""String_Node_Str"" + t.getMessage());
          TransactionHelper.setTransactionRollbackOnly();
        }
 finally {
          TransactionHelper.commitOrRollbackTransaction();
          if (coreSession != null) {
            CoreInstance.getInstance().close(coreSession);
          }
          if (loginContext != null) {
            loginContext.logout();
          }
        }
      }
 catch (      Exception e) {
        log.warn(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}"
18301,"@Override public void deactivate(ComponentContext context) throws Exception {
  if (parsingPoolThread != null) {
    parsingPoolThread.interrupt();
  }
}","@Override public void deactivate(ComponentContext context) throws Exception {
  if (parsingPoolThread != null) {
    parsingPoolThread.interrupt();
  }
  if (coreSession != null) {
    CoreInstance.getInstance().close(coreSession);
  }
  if (loginContext != null) {
    loginContext.logout();
  }
}"
18302,"@Override public void handleEvent(Event event) throws ClientException {
  try {
    CoreSession session=Framework.getService(RepositoryManager.class).getDefaultRepository().open();
    String environmentName=(String)event.getContext().getProperty(""String_Node_Str"");
    String tmpWorkspaceName=""String_Node_Str"" + environmentName + System.currentTimeMillis();
    DocumentModel environmentModel=docService.findEnvironment(session,environmentName);
    if (environmentModel != null) {
      DocumentModel tmpWorkspaceModel=null;
      ValidationResultList validationResults=null;
      try {
        tmpWorkspaceModel=publicationService.forkEnvironment(session,environmentModel,tmpWorkspaceName);
        validationResults=serviceValidationService.validateServices(session,tmpWorkspaceModel);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
 finally {
        if (tmpWorkspaceModel != null) {
          session.removeDocument(tmpWorkspaceModel.getRef());
        }
      }
      DocumentModel workspaceModel=docService.findWorkspace(session,environmentName);
    }
 else {
      log.error(""String_Node_Str"" + environmentName + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
}","@Override public void handleEvent(Event event) throws ClientException {
synchronized (log) {
    try {
      RepositoryManager mgr=Framework.getService(RepositoryManager.class);
      Repository repository=mgr.getDefaultRepository();
      TransactionHelper.startTransaction();
      session=repository.open();
      String environmentName=(String)event.getContext().getProperty(""String_Node_Str"");
      String tmpWorkspaceName=""String_Node_Str"" + environmentName + System.currentTimeMillis();
      DocumentModel environmentModel=docService.findEnvironment(session,environmentName);
      if (environmentModel != null) {
        DocumentModel tmpWorkspaceModel=null;
        ValidationResultList validationResults=null;
        try {
          tmpWorkspaceModel=publicationService.forkEnvironment(session,environmentModel,tmpWorkspaceName);
          validationResults=serviceValidationService.validateServices(session,tmpWorkspaceModel);
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"",e);
        }
 finally {
          if (tmpWorkspaceModel != null) {
            session.removeDocument(tmpWorkspaceModel.getRef());
          }
        }
        DocumentModel workspaceModel=docService.findWorkspace(session,environmentName);
      }
 else {
        log.error(""String_Node_Str"" + environmentName + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
 finally {
      TransactionHelper.commitOrRollbackTransaction();
      if (session != null) {
        CoreInstance.getInstance().close(session);
      }
    }
  }
}"
18303,"/** 
 * Check the recorded exchanges
 * @throws IOException
 */
public void checkExchanges(){
  boolean none=true;
  for (  ExchangeRecord record : recordList) {
    none=false;
    assertTrue(""String_Node_Str"",record.getInMessage().getMessageContent().getContent().contains(""String_Node_Str""));
  }
  assertTrue(""String_Node_Str"",none);
}","/** 
 * Check the recorded exchanges
 * @throws IOException
 */
public void checkExchanges(){
  boolean none=true;
  for (  ExchangeRecord record : recordList) {
    none=false;
    assertTrue(""String_Node_Str"",record.getInMessage().getMessageContent().getRawContent().contains(""String_Node_Str""));
  }
  assertTrue(""String_Node_Str"",none);
}"
18304,"/** 
 * Return the name of the object, which is also an   {@ŀink EObject}
 * @param t the object of which the name is to find
 * @return the name of the object passed on as parameter
 */
protected abstract String getName(T t);","/** 
 * Return the name of the object, which is also an   {@link EObject}
 * @param t the object of which the name is to find
 * @return the name of the object passed on as parameter
 */
protected abstract String getName(T t);"
18305,"/** 
 * Adds the given URL to an asynchronous download & parsing pool.
 * @param url The URL to download. Must not be null.
 * @param targetModel The target model on which to store extracted information. If null, will be guessed.
 * @param storageProp A property on which to store the downloaded blob (ex: file:content). If null, the blob won't be saved.
 * @param options Any options to pass to the file parsers.
 */
void append(URL url,DocumentModel targetModel,String storageProp,Map<String,String> options) throws InvalidArgumentException ;","/** 
 * Adds the given URL to an asynchronous download & parsing pool.
 * @param url The URL to download. Must not be null.
 * @param targetModel The target model on which to store extracted information. If null, will be guessed.
 * @param storageProp A property on which to store the downloaded blob (ex: file:content). If null, the blob won't be saved.
 * @param options Any options to pass to the file parsers.
 */
void append(URL url,DocumentModel targetModel,String storageProp,Map<String,String> options) throws IllegalArgumentException ;"
18306,"@Override public void append(URL url,DocumentModel targetModel,String storageProp,Map<String,String> options) throws InvalidArgumentException {
synchronized (parsingPool) {
    parsingPool.push(new WebFileParsingPoolEntry(url,targetModel,storageProp,options));
synchronized (this) {
      notifyAll();
    }
  }
}","@Override public void append(URL url,DocumentModel targetModel,String storageProp,Map<String,String> options) throws IllegalArgumentException {
synchronized (parsingPool) {
    parsingPool.push(new WebFileParsingPoolEntry(url,targetModel,storageProp,options));
synchronized (this) {
      notifyAll();
    }
  }
}"
18307,"public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel appliImplModel=((DocumentEventContext)ctx).getSourceDocument();
  if (appliImplModel == null) {
    return;
  }
  String type=appliImplModel.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  if (maintainInternalProperties(session,appliImplModel)) {
    setDefaultPropertyValues(session,appliImplModel);
  }
  try {
    updateVocabulary(session,(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER),(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_ENVIRONMENT));
  }
 catch (  ClientException e) {
    log.error(""String_Node_Str"",e);
  }
}","public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel appliImplModel=((DocumentEventContext)ctx).getSourceDocument();
  if (appliImplModel == null) {
    return;
  }
  String type=appliImplModel.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  if (event.getName().equals(DocumentEventTypes.DOCUMENT_UPDATED)) {
    Events.instance().raiseEvent(APPLI_IMPL_CHANGED,appliImplModel);
  }
 else {
    if (maintainInternalProperties(session,appliImplModel)) {
      setDefaultPropertyValues(session,appliImplModel);
    }
    try {
      updateVocabulary(session,(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER),(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_ENVIRONMENT));
    }
 catch (    ClientException e) {
      log.error(""String_Node_Str"",e);
    }
  }
}"
18308,"public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE) || doc.isProxy()) {
    return;
  }
  try {
    String title=(String)doc.getProperty(""String_Node_Str"",""String_Node_Str"");
    String url=(String)doc.getProperty(SCHEMA,PROP_URL);
    String fileUrl=(String)doc.getProperty(SCHEMA,PROP_FILEURL);
    if (fileUrl == null) {
      fileUrl=guessFileUrl(url);
    }
    if (fileUrl != null) {
      try {
        Blob blob=downloadBlob(fileUrl);
        if (blob == null && fileUrl != null && !fileUrl.equals(guessFileUrl(url))) {
          blob=downloadBlob(guessFileUrl(url));
        }
        if (blob != null) {
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",blob);
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",ApiUrlProcessor.computeServiceTitle(fileUrl) + ""String_Node_Str"");
          File tmpFile=File.createTempFile(doc.getId(),null);
          blob.transferTo(tmpFile);
          try {
            WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
            Description desc=reader.read(tmpFile.toURI().toURL());
            org.ow2.easywsdl.wsdl.api.Service firstService=(org.ow2.easywsdl.wsdl.api.Service)desc.getServices().get(0);
            String namespace=desc.getTargetNamespace();
            doc.setProperty(Service.SCHEMA,Service.PROP_WSDLNAMESPACE,namespace);
            Endpoint firstEndpoint=firstService.getEndpoints().get(0);
            url=PropertyNormalizer.normalizeUrl(firstEndpoint.getAddress());
            doc.setProperty(SCHEMA,PROP_URL,url);
            String serviceName=firstService.getQName().getLocalPart();
            doc.setProperty(Service.SCHEMA,Service.PROP_WSDLSERVICENAME,serviceName);
            if (title == null || title.isEmpty() || title.equals(fileUrl)) {
              doc.setProperty(""String_Node_Str"",""String_Node_Str"",serviceName);
            }
            if (doc.getParentRef() != null) {
              DocumentModel apiModel=session.getDocument(doc.getParentRef());
              String storedProtocol=(String)apiModel.getProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS);
              try {
                String protocol=((Binding)((Endpoint)firstService.getEndpoints().get(0)).getBinding()).getTransportProtocol();
                if (storedProtocol == null || !storedProtocol.contains(protocol)) {
                  if (storedProtocol == null || storedProtocol.isEmpty()) {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,protocol);
                  }
 else {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,storedProtocol + ""String_Node_Str"" + protocol);
                  }
                }
              }
 catch (              Exception e) {
                log.warn(""String_Node_Str"" + e.getMessage());
              }
              if (apiModel.getParentRef() != null) {
                DocumentModel appliImplModel=session.getDocument(apiModel.getParentRef());
                String existingServer=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER);
                String newServer=InetAddress.getByName(new URL(firstEndpoint.getAddress()).getHost()).getHostAddress();
                if (existingServer == null || !newServer.equals(existingServer)) {
                  appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER,newServer);
                }
                try {
                  String provider=new URL(((Endpoint)firstService.getEndpoints().get(0)).getAddress()).getAuthority();
                  String existingProvider=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER);
                  if (existingProvider == null || !provider.equals(existingProvider)) {
                    appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER,provider);
                  }
                }
 catch (                Exception e) {
                }
                session.saveDocument(appliImplModel);
              }
              session.saveDocument(apiModel);
            }
          }
 catch (          Exception e) {
            log.warn(""String_Node_Str"" + e.getMessage());
          }
 finally {
            tmpFile.delete();
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
    }
    session.save();
    if (url != null) {
      try {
        doc.setProperty(SCHEMA,PROP_URL,PropertyNormalizer.normalizeUrl(url));
      }
 catch (      MalformedURLException e) {
        log.warn(""String_Node_Str"",e);
      }
    }
    if (fileUrl != null) {
      if (fileUrl.contains(""String_Node_Str"")) {
        doc.setProperty(SCHEMA,PROP_FILEURL,""String_Node_Str"" + EasySOAConstants.HTML_FORM_GENERATOR_PORT + ""String_Node_Str"");
      }
 else {
        doc.setProperty(SCHEMA,PROP_FILEURL,PropertyNormalizer.normalizeUrl(fileUrl));
      }
    }
    String referencedService=(String)doc.getProperty(SCHEMA,PROP_REFERENCESERVICE);
    if (referencedService == null || !session.exists(new IdRef(referencedService))) {
      DocumentModel newReferenceService=null;
      ServiceValidationService validationService=Framework.getService(ServiceValidationService.class);
      SortedSet<CorrelationMatch> correlatedServices=validationService.findCorrelatedServices(session,doc);
      if (correlatedServices != null && !correlatedServices.isEmpty() && correlatedServices.first().getCorrelationRate() > 0.9) {
        newReferenceService=correlatedServices.first().getDocumentModel();
        doc.setProperty(SCHEMA,PROP_REFERENCESERVICE,newReferenceService.getId());
        doc.setProperty(SCHEMA,PROP_REFERENCESERVICEORIGIN,""String_Node_Str"" + correlatedServices.first().getCorrelationRateAsPercentageString() + ""String_Node_Str"");
      }
 else {
        doc.setProperty(SCHEMA,PROP_REFERENCESERVICE,null);
      }
    }
    DocumentModel oldDoc=session.getDocument(doc.getRef());
    Object wasDirty=oldDoc.getProperty(Service.SCHEMA,Service.PROP_VALIDATIONSTATEDIRTY);
    if (wasDirty == null || wasDirty.equals(doc.getProperty(Service.SCHEMA,Service.PROP_VALIDATIONSTATEDIRTY))) {
      doc.setProperty(Service.SCHEMA,Service.PROP_VALIDATIONSTATEDIRTY,true);
    }
    try {
      DocumentService docService=Framework.getService(DocumentService.class);
      DocumentModel workspace=docService.getWorkspace(session,doc);
      DocumentModelList existingServiceModels=session.query(""String_Node_Str"" + Service.DOCTYPE + ""String_Node_Str""+ ""String_Node_Str""+ workspace.getPathAsString()+ ""String_Node_Str""+ Service.SCHEMA_PREFIX+ Service.PROP_URL+ ""String_Node_Str""+ url+ ""String_Node_Str"");
      for (      DocumentModel existingServiceModel : existingServiceModels) {
        if (existingServiceModel != null && !existingServiceModel.getRef().equals(doc.getRef()) && !existingServiceModel.isProxy()) {
          docService.mergeDocument(session,existingServiceModel,doc,false);
        }
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
 catch (  Exception e) {
    log.error(e);
  }
}","public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE) || doc.isProxy()) {
    return;
  }
  try {
    String title=(String)doc.getProperty(""String_Node_Str"",""String_Node_Str"");
    String url=(String)doc.getProperty(SCHEMA,PROP_URL);
    String fileUrl=(String)doc.getProperty(SCHEMA,PROP_FILEURL);
    if (fileUrl == null) {
      fileUrl=guessFileUrl(url);
    }
    if (fileUrl != null) {
      try {
        Blob blob=downloadBlob(fileUrl);
        if (blob == null && fileUrl != null && !fileUrl.equals(guessFileUrl(url))) {
          blob=downloadBlob(guessFileUrl(url));
        }
        if (blob != null) {
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",blob);
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",ApiUrlProcessor.computeServiceTitle(fileUrl) + ""String_Node_Str"");
          File tmpFile=File.createTempFile(doc.getId(),null);
          blob.transferTo(tmpFile);
          try {
            WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
            Description desc=reader.read(tmpFile.toURI().toURL());
            org.ow2.easywsdl.wsdl.api.Service firstService=(org.ow2.easywsdl.wsdl.api.Service)desc.getServices().get(0);
            String namespace=desc.getTargetNamespace();
            doc.setProperty(Service.SCHEMA,Service.PROP_WSDLNAMESPACE,namespace);
            Endpoint firstEndpoint=firstService.getEndpoints().get(0);
            url=PropertyNormalizer.normalizeUrl(firstEndpoint.getAddress());
            doc.setProperty(SCHEMA,PROP_URL,url);
            String serviceName=firstService.getQName().getLocalPart();
            doc.setProperty(Service.SCHEMA,Service.PROP_WSDLSERVICENAME,serviceName);
            if (title == null || title.isEmpty() || title.equals(fileUrl)) {
              doc.setProperty(""String_Node_Str"",""String_Node_Str"",serviceName);
            }
            if (doc.getParentRef() != null) {
              DocumentModel apiModel=session.getDocument(doc.getParentRef());
              String storedProtocol=(String)apiModel.getProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS);
              try {
                String protocol=((Binding)((Endpoint)firstService.getEndpoints().get(0)).getBinding()).getTransportProtocol();
                if (storedProtocol == null || !storedProtocol.contains(protocol)) {
                  if (storedProtocol == null || storedProtocol.isEmpty()) {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,protocol);
                  }
 else {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,storedProtocol + ""String_Node_Str"" + protocol);
                  }
                }
              }
 catch (              Exception e) {
                log.warn(""String_Node_Str"" + e.getMessage());
              }
              if (apiModel.getParentRef() != null) {
                DocumentModel appliImplModel=session.getDocument(apiModel.getParentRef());
                String existingServer=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER);
                String newServer=InetAddress.getByName(new URL(firstEndpoint.getAddress()).getHost()).getHostAddress();
                if (existingServer == null || !newServer.equals(existingServer)) {
                  appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER,newServer);
                }
                try {
                  String provider=new URL(((Endpoint)firstService.getEndpoints().get(0)).getAddress()).getAuthority();
                  String existingProvider=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER);
                  if (existingProvider == null || !provider.equals(existingProvider)) {
                    appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER,provider);
                  }
                }
 catch (                Exception e) {
                }
                session.saveDocument(appliImplModel);
              }
              session.saveDocument(apiModel);
            }
          }
 catch (          Exception e) {
            log.warn(""String_Node_Str"" + e.getMessage());
          }
 finally {
            tmpFile.delete();
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
    }
    session.save();
    if (url != null) {
      try {
        doc.setProperty(SCHEMA,PROP_URL,PropertyNormalizer.normalizeUrl(url));
      }
 catch (      MalformedURLException e) {
        log.warn(""String_Node_Str"",e);
      }
    }
    if (fileUrl != null) {
      if (fileUrl.contains(""String_Node_Str"")) {
        doc.setProperty(SCHEMA,PROP_FILEURL,""String_Node_Str"" + EasySOAConstants.HTML_FORM_GENERATOR_PORT + ""String_Node_Str"");
      }
 else {
        doc.setProperty(SCHEMA,PROP_FILEURL,PropertyNormalizer.normalizeUrl(fileUrl));
      }
    }
    String referencedService=(String)doc.getProperty(SCHEMA,PROP_REFERENCESERVICE);
    if (referencedService == null || !session.exists(new IdRef(referencedService))) {
      DocumentModel newReferenceService=null;
      ServiceValidationService validationService=Framework.getService(ServiceValidationService.class);
      SortedSet<CorrelationMatch> correlatedServices=validationService.findCorrelatedServices(session,doc);
      if (correlatedServices != null && !correlatedServices.isEmpty() && correlatedServices.first().getCorrelationRate() > 0.9) {
        newReferenceService=correlatedServices.first().getDocumentModel();
        doc.setProperty(SCHEMA,PROP_REFERENCESERVICE,newReferenceService.getId());
        doc.setProperty(SCHEMA,PROP_REFERENCESERVICEORIGIN,""String_Node_Str"" + correlatedServices.first().getCorrelationRateAsPercentageString() + ""String_Node_Str"");
      }
 else {
        doc.setProperty(SCHEMA,PROP_REFERENCESERVICE,null);
      }
    }
    DocumentModel oldDoc=session.getDocument(doc.getRef());
    Object wasDirty=oldDoc.getProperty(Service.SCHEMA,Service.PROP_VALIDATIONSTATEDIRTY);
    if (wasDirty == null || wasDirty.equals(doc.getProperty(Service.SCHEMA,Service.PROP_VALIDATIONSTATEDIRTY))) {
      doc.setProperty(Service.SCHEMA,Service.PROP_VALIDATIONSTATEDIRTY,true);
    }
    try {
      DocumentService docService=Framework.getService(DocumentService.class);
      DocumentModel workspace=docService.getWorkspace(session,doc);
      DocumentModelList existingServiceModels=session.query(""String_Node_Str"" + Service.DOCTYPE + ""String_Node_Str""+ ""String_Node_Str""+ workspace.getPathAsString()+ ""String_Node_Str""+ Service.SCHEMA_PREFIX+ Service.PROP_URL+ ""String_Node_Str""+ url+ ""String_Node_Str""+ ""String_Node_Str"");
      for (      DocumentModel existingServiceModel : existingServiceModels) {
        if (existingServiceModel != null && !existingServiceModel.getRef().equals(doc.getRef()) && !existingServiceModel.isProxy()) {
          docService.mergeDocument(session,existingServiceModel,doc,false);
        }
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
 catch (  Exception e) {
    log.error(e);
  }
}"
18309,"public BrowsingContext(URL url) throws Exception {
  if (url != null) {
    HttpDownloaderService httpDownloaderService=Framework.getService(HttpDownloaderService.class);
    HttpDownloader file=httpDownloaderService.createHttpDownloader(url);
    try {
      file.download();
      FileInputStream fis=new FileInputStream(file.getFile());
      StringBuffer dataBuffer=new StringBuffer();
      char c;
      while ((c=(char)fis.read()) != -1) {
        dataBuffer.append(c);
      }
      data=dataBuffer.toString();
    }
 catch (    Exception e) {
      data=null;
    }
 finally {
      file.delete();
    }
  }
}","public BrowsingContext(URL url) throws Exception {
  if (url != null) {
    this.url=url;
    HttpDownloaderService httpDownloaderService=Framework.getService(HttpDownloaderService.class);
    HttpDownloader file=httpDownloaderService.createHttpDownloader(url);
    try {
      file.download();
      FileInputStream fis=new FileInputStream(file.getFile());
      StringBuffer dataBuffer=new StringBuffer();
      int c;
      while ((c=fis.read()) != -1) {
        dataBuffer.append((char)c);
      }
      data=dataBuffer.toString();
    }
 catch (    Exception e) {
      data=null;
    }
 finally {
      file.delete();
    }
  }
}"
18310,"@GET @Path(""String_Node_Str"") public Object doGet(@Context UriInfo uriInfo) throws Exception {
  URL url=null;
  String callback=null;
  try {
    String restServiceURL=uriInfo.getBaseUri().toString() + ""String_Node_Str"";
    url=new URL(uriInfo.getRequestUri().toString().substring(restServiceURL.length()));
    if (url.getQuery().contains(""String_Node_Str"")) {
      List<NameValuePair> queryTokens=URLEncodedUtils.parse(url.toURI(),""String_Node_Str"");
      for (      NameValuePair token : queryTokens) {
        if (token.getName().equals(""String_Node_Str"")) {
          callback=token.getValue();
        }
      }
    }
  }
 catch (  MalformedURLException e) {
    return ""String_Node_Str"" + formatError(e) + ""String_Node_Str"";
  }
  if (callback != null) {
    return callback + '(' + findWSDls(new BrowsingContext(url))+ ')';
  }
 else {
    return findWSDls(new BrowsingContext(url));
  }
}","@GET @Path(""String_Node_Str"") public Object doGet(@Context UriInfo uriInfo) throws Exception {
  URL url=null;
  String callback=null;
  try {
    String restServiceURL=uriInfo.getBaseUri().toString() + ""String_Node_Str"";
    url=new URL(uriInfo.getRequestUri().toString().substring(restServiceURL.length()));
    if (url.getQuery() != null && url.getQuery().contains(""String_Node_Str"")) {
      List<NameValuePair> queryTokens=URLEncodedUtils.parse(url.toURI(),""String_Node_Str"");
      for (      NameValuePair token : queryTokens) {
        if (token.getName().equals(""String_Node_Str"")) {
          callback=token.getValue();
        }
      }
    }
  }
 catch (  MalformedURLException e) {
    return ""String_Node_Str"" + formatError(e) + ""String_Node_Str"";
  }
  if (callback != null) {
    return callback + '(' + findWSDls(new BrowsingContext(url))+ ')';
  }
 else {
    return findWSDls(new BrowsingContext(url));
  }
}"
18311,"HttpDownloader download() throws IOException, URISyntaxException ;","/** 
 * Downloads the page at the given URL.
 * @return
 * @throws Exception
 */
HttpDownloader download() throws Exception ;"
18312,boolean isDownloaded();,"/** 
 * Checks if the page has been successfully downloaded. (note: you must explicitly call download() to fetch the page)
 * @return
 */
boolean isDownloaded();"
18313,boolean isURLAvailable();,"/** 
 * Checks if the given URL is available.
 * @return
 */
boolean isURLAvailable();"
18314,void delete();,"/** 
 * Deletes all stored data (including the eventual file) if the page has been downloaded. 
 */
void delete();"
18315,File getFile();,"/** 
 * Returns the downloaded page as a file, or null if it has not been downloaded, or the export to a file failed.
 * @return
 * @throws IOException
 */
File getFile() throws IOException ;"
18316,Blob getBlob();,"/** 
 * Returns the downloaded page as a blob (ready for storage in a Nuxeo document), or null if it has not been downloaded.
 * @return
 */
Blob getBlob();"
18317,"@Override public HttpDownloader download() throws IOException, URISyntaxException {
  this.file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  FileOutputStream fos=new FileOutputStream(this.file);
  try {
    GetMethod getMethod=new GetMethod(url.toString());
    int responseCode=client.executeMethod(getMethod);
    if (responseCode == 200) {
      byte[] body=getMethod.getResponseBody();
      fos.write(body);
      fos.flush();
    }
  }
  finally {
    fos.close();
  }
  return this;
}","@Override public HttpDownloader download() throws Exception {
  GetMethod getMethod=new GetMethod(url.toString());
  int responseCode=client.executeMethod(getMethod);
  if (responseCode == 200) {
    this.bytes=getMethod.getResponseBody();
  }
  return this;
}"
18318,"@Override public boolean isDownloaded(){
  return (this.file != null) && (this.file.exists());
}","@Override public boolean isDownloaded(){
  return this.bytes != null;
}"
18319,"@Override public void delete(){
  if (isDownloaded()) {
    this.file.delete();
  }
}","@Override public void delete(){
  if (this.file != null) {
    this.file.delete();
  }
  this.bytes=null;
}"
18320,"@Override public File getFile(){
  return this.file;
}","@Override public File getFile() throws IOException {
  if (this.file == null && this.bytes != null) {
    FileOutputStream fos=null;
    try {
      this.file=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
      fos=new FileOutputStream(this.file);
      fos.write(this.bytes);
      fos.flush();
    }
 catch (    Exception e) {
      if (this.file != null) {
        this.file.delete();
      }
      this.file=null;
    }
 finally {
      if (fos != null) {
        fos.close();
      }
    }
  }
  return this.file;
}"
18321,"@Override public Blob getBlob(){
  return isDownloaded() ? new FileBlob(this.file) : null;
}","@Override public Blob getBlob(){
  return this.bytes != null ? new ByteArrayBlob(this.bytes) : null;
}"
18322,"@SuppressWarnings(""String_Node_Str"") @Test public void test() throws FrascatiException {
  Trip tripService=frascati.getService(componentList.get(0),""String_Node_Str"",Trip.class);
  Trip spyTripService=spy(tripService);
  logger.info(""String_Node_Str"");
  String tripServiceResponse=spyTripService.process(""String_Node_Str"",""String_Node_Str"",10);
  logger.info(""String_Node_Str"" + tripServiceResponse);
  verify(((Delegated<CurrencyServerWebServiceSoap>)(server.getCurrencyImplementor())).getDelegate()).getCurrencyValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  verify(server.getMeteoImplementor().getDelegate()).getWeather(""String_Node_Str"",""String_Node_Str"");
  verify(server.getTranslateImplementor().getDelegate()).translate(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  verify(spyTripService).process(""String_Node_Str"",""String_Node_Str"",10);
}","@SuppressWarnings(""String_Node_Str"") @Test public void test() throws FrascatiException {
  Trip tripService=frascati.getService(componentList.get(0),""String_Node_Str"",Trip.class);
  Trip spyTripService=spy(tripService);
  logger.info(""String_Node_Str"");
  String tripServiceResponse=spyTripService.process(""String_Node_Str"",""String_Node_Str"",10);
  logger.info(""String_Node_Str"" + tripServiceResponse);
  verify(server.getCurrencyImplementor().getDelegate()).getCurrencyValue(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  verify(server.getMeteoImplementor().getDelegate()).getWeather(""String_Node_Str"",""String_Node_Str"");
  verify(server.getTranslateImplementor().getDelegate()).translate(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  verify(spyTripService).process(""String_Node_Str"",""String_Node_Str"",10);
}"
18323,"@Override public void visit(BindingInfoProvider bindingInfoProvider) throws ClientException, IOException {
  RestNotificationFactory factory=new RestNotificationFactory();
  String refUrl=bindingInfoProvider.getBindingUrl();
}","@Override public void visit(BindingInfoProvider bindingInfoProvider) throws ClientException, IOException {
}"
18324,"@Override public void importSCA() throws Exception {
  String scaFileName=compositeFile.getFilename();
  log.debug(""String_Node_Str"" + compositeFile.getFilename());
  if (scaFileName.endsWith(""String_Node_Str"")) {
    importSCAComposite();
  }
 else   if (scaFileName.endsWith(""String_Node_Str"") || scaFileName.endsWith(""String_Node_Str"")) {
    importSCAZip();
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
}","@Override public void importSCA() throws Exception {
  log.debug(""String_Node_Str"" + compositeFile.getFilename());
  if (compositeFile.getFilename() == null || ""String_Node_Str"".equals(compositeFile.getFilename())) {
    throw new Exception(""String_Node_Str"");
  }
  String scaFileName=compositeFile.getFilename();
  if (scaFileName.endsWith(""String_Node_Str"")) {
    importSCAComposite();
  }
 else   if (scaFileName.endsWith(""String_Node_Str"") || scaFileName.endsWith(""String_Node_Str"")) {
    importSCAZip();
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
}"
18325,"public void validateUrl(FacesContext context,UIComponent component,Object value){
  try {
    new URL((String)value);
  }
 catch (  MalformedURLException e) {
    throw new ValidatorException(new FacesMessage(""String_Node_Str""),e);
  }
}","public void validateUrl(FacesContext context,UIComponent component,Object value){
  String urlString=(String)value;
  if (urlString.equals(urlString.trim())) {
    try {
      new URL((String)value);
    }
 catch (    MalformedURLException e) {
      throw new ValidatorException(ERROR_MESSAGE,e);
    }
  }
 else {
    throw new ValidatorException(ERROR_MESSAGE);
  }
}"
18326,"/** 
 * Creates or update an API given the specified properties. Properties require at least application's URL (PROP_URL) ; the parent document URL (PROP_PARENTURL) is also recommended if known.
 * @param session
 * @param properties A set of properties of the document, among the ServiceAPI.PROP_XXX constants.
 * @return The created/updated API
 * @throws ClientException
 * @throws MalformedURLException 
 */
public final DocumentModel notifyServiceApi(CoreSession session,Map<String,String> properties) throws ClientException, MalformedURLException {
  String url=properties.get(Service.PROP_URL);
  if (url != null && !url.isEmpty()) {
    String parentUrl=properties.get(ServiceAPI.PROP_PARENTURL), title=properties.get(""String_Node_Str"");
    if (title == null || title.isEmpty()) {
      title=url;
      properties.put(""String_Node_Str"",title);
    }
    DocumentService docService=Framework.getRuntime().getService(DocumentService.class);
    DocumentModel parentModel=docService.findServiceApi(session,parentUrl);
    if (parentModel == null)     parentModel=docService.findAppliImpl(session,parentUrl);
    if (parentModel == null) {
      if (parentUrl == null) {
        parentModel=docService.getDefaultAppliImpl(session);
      }
 else {
        parentModel=docService.createAppliImpl(session,parentUrl);
      }
      session.save();
    }
    DocumentModel apiModel=docService.findServiceApi(session,url);
    if (apiModel == null) {
      apiModel=docService.createServiceAPI(session,parentModel.getPathAsString(),url);
    }
    if (!parentModel.getRef().equals(apiModel.getParentRef())) {
      apiModel=session.move(apiModel.getRef(),parentModel.getRef(),null);
    }
    if (url.toLowerCase().contains(""String_Node_Str"")) {
      try {
        HttpFile f=new HttpFile(new URL(url));
        f.download();
        apiModel.setProperty(""String_Node_Str"",""String_Node_Str"",f.getBlob());
      }
 catch (      Exception e) {
        throw new ClientException(""String_Node_Str"",e);
      }
    }
    setPropertiesIfNotNull(apiModel,ServiceAPI.SCHEMA,ServiceAPI.getPropertyList(),properties);
    session.saveDocument(apiModel);
    session.save();
    return apiModel;
  }
 else {
    throw new ClientException(""String_Node_Str"");
  }
}","/** 
 * Creates or update an API given the specified properties. Properties require at least application's URL (PROP_URL) ; the parent document URL (PROP_PARENTURL) is also recommended if known.
 * @param session
 * @param properties A set of properties of the document, among the ServiceAPI.PROP_XXX constants.
 * @return The created/updated API
 * @throws ClientException
 * @throws MalformedURLException 
 */
public final DocumentModel notifyServiceApi(CoreSession session,Map<String,String> properties) throws ClientException, MalformedURLException {
  String url=properties.get(Service.PROP_URL);
  if (url != null && !url.isEmpty()) {
    String parentUrl=properties.get(ServiceAPI.PROP_PARENTURL), title=properties.get(""String_Node_Str"");
    if (title == null || title.isEmpty()) {
      title=url;
      properties.put(""String_Node_Str"",title);
    }
    DocumentService docService=Framework.getRuntime().getService(DocumentService.class);
    DocumentModel parentModel=docService.findAppliImpl(session,parentUrl);
    if (parentModel == null) {
      parentModel=docService.findServiceApi(session,parentUrl);
    }
    if (parentModel == null) {
      if (parentUrl == null) {
        parentModel=docService.getDefaultAppliImpl(session);
      }
 else {
        parentModel=docService.createAppliImpl(session,parentUrl);
      }
      session.save();
    }
    DocumentModel apiModel=docService.findServiceApi(session,url);
    if (apiModel == null) {
      apiModel=docService.createServiceAPI(session,parentModel.getPathAsString(),url);
    }
    if (!parentModel.getRef().equals(apiModel.getParentRef())) {
      apiModel=session.move(apiModel.getRef(),parentModel.getRef(),null);
    }
    if (url.toLowerCase().contains(""String_Node_Str"")) {
      try {
        HttpFile f=new HttpFile(new URL(url));
        f.download();
        apiModel.setProperty(""String_Node_Str"",""String_Node_Str"",f.getBlob());
      }
 catch (      Exception e) {
        throw new ClientException(""String_Node_Str"",e);
      }
    }
    setPropertiesIfNotNull(apiModel,ServiceAPI.SCHEMA,ServiceAPI.getPropertyList(),properties);
    session.saveDocument(apiModel);
    session.save();
    return apiModel;
  }
 else {
    throw new ClientException(""String_Node_Str"");
  }
}"
18327,"public void activate(ComponentContext context) throws Exception {
  RepositoryManager repoService=Framework.getService(RepositoryManager.class);
  String defaultRepository=repoService.getDefaultRepository().getName();
  if (defaultRepository != null) {
    new DomainInit(defaultRepository).runUnrestricted();
  }
 else {
    log.warn(""String_Node_Str"");
  }
  new UserInit(defaultRepository).runUnrestricted();
}","public void activate(ComponentContext context) throws Exception {
  RepositoryManager repoService=Framework.getService(RepositoryManager.class);
  Repository defaultRepository=repoService.getDefaultRepository();
  try {
    new DomainInit(defaultRepository.toString()).runUnrestricted();
    new UserInit(defaultRepository.toString()).runUnrestricted();
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + e.getMessage());
  }
}"
18328,"public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  String url=null, server=null, environment=null;
  try {
    url=(String)doc.getProperty(SCHEMA,PROP_URL);
    server=(String)doc.getProperty(SCHEMA,PROP_SERVER);
    environment=(String)doc.getProperty(SCHEMA,PROP_ENVIRONMENT);
    if (url != null && !url.isEmpty() && (server == null || server.isEmpty())) {
      try {
        url=PropertyNormalizer.normalizeUrl(url);
        doc.setProperty(SCHEMA,PROP_URL,url);
        server=new URL(url).getHost();
        doc.setProperty(SCHEMA,PROP_SERVER,server);
        doc.setProperty(SCHEMA,PROP_SERVERENTRY,doc.getProperty(SCHEMA,PROP_ENVIRONMENT) + ""String_Node_Str"" + server);
      }
 catch (      MalformedURLException e) {
        log.error(""String_Node_Str"" + url + ""String_Node_Str"");
      }
    }
    if (environment == null || environment.isEmpty()) {
      doc.setProperty(SCHEMA,PROP_ENVIRONMENT,DEFAULT_ENVIRONMENT);
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
  try {
    if (environment == null) {
      environment=DEFAULT_ENVIRONMENT;
    }
    VocabularyHelper vocService=Framework.getRuntime().getService(VocabularyHelper.class);
    if (!vocService.entryExists(session,VocabularyHelper.VOCABULARY_ENVIRONMENT,environment)) {
      vocService.addEntry(session,VocabularyHelper.VOCABULARY_ENVIRONMENT,environment,environment);
    }
    if (server != null && !server.isEmpty() && !vocService.entryExists(session,VocabularyHelper.VOCABULARY_SERVER,server)) {
      vocService.addEntry(session,VocabularyHelper.VOCABULARY_SERVER,server,server,environment);
    }
  }
 catch (  ClientException e) {
    log.error(""String_Node_Str"",e);
  }
}","public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  String url=null, server=null, environment=null;
  try {
    url=(String)doc.getProperty(SCHEMA,PROP_URL);
    server=(String)doc.getProperty(SCHEMA,PROP_SERVER);
    environment=(String)doc.getProperty(SCHEMA,PROP_ENVIRONMENT);
    if (url != null && !url.isEmpty() && (server == null || server.isEmpty())) {
      try {
        url=PropertyNormalizer.normalizeUrl(url);
        doc.setProperty(SCHEMA,PROP_URL,url);
        server=new URL(url).getHost();
        doc.setProperty(SCHEMA,PROP_SERVER,server);
        doc.setProperty(SCHEMA,PROP_SERVERENTRY,doc.getProperty(SCHEMA,PROP_ENVIRONMENT) + ""String_Node_Str"" + server);
      }
 catch (      MalformedURLException e) {
        log.warn(""String_Node_Str"" + url + ""String_Node_Str"");
      }
    }
    if (environment == null || environment.isEmpty()) {
      doc.setProperty(SCHEMA,PROP_ENVIRONMENT,DEFAULT_ENVIRONMENT);
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
  try {
    if (environment == null) {
      environment=DEFAULT_ENVIRONMENT;
    }
    VocabularyHelper vocService=Framework.getRuntime().getService(VocabularyHelper.class);
    if (!vocService.entryExists(session,VocabularyHelper.VOCABULARY_ENVIRONMENT,environment)) {
      vocService.addEntry(session,VocabularyHelper.VOCABULARY_ENVIRONMENT,environment,environment);
    }
    if (server != null && !server.isEmpty() && !vocService.entryExists(session,VocabularyHelper.VOCABULARY_SERVER,server)) {
      vocService.addEntry(session,VocabularyHelper.VOCABULARY_SERVER,server,server,environment);
    }
  }
 catch (  ClientException e) {
    log.error(""String_Node_Str"",e);
  }
}"
18329,"public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  try {
    String title=(String)doc.getProperty(""String_Node_Str"",""String_Node_Str"");
    String url=(String)doc.getProperty(SCHEMA,PROP_URL);
    String fileUrl=(String)doc.getProperty(SCHEMA,PROP_FILEURL);
    if (fileUrl != null) {
      try {
        Blob blob=null;
        try {
          blob=new HttpFile(fileUrl).download().getBlob();
        }
 catch (        IOException e) {
          log.info(""String_Node_Str"" + fileUrl + ""String_Node_Str""+ e.getMessage());
        }
catch (        Exception e) {
          log.info(""String_Node_Str"" + fileUrl + ""String_Node_Str""+ e.getMessage());
        }
        if (blob != null) {
          NotificationService notifService=Framework.getService(NotificationService.class);
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",blob);
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",notifService.computeServiceTitle(fileUrl) + ""String_Node_Str"");
          File tmpFile=File.createTempFile(doc.getId(),null);
          blob.transferTo(tmpFile);
          try {
            WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
            Description desc=reader.read(tmpFile.toURI().toURL());
            org.ow2.easywsdl.wsdl.api.Service firstService=(org.ow2.easywsdl.wsdl.api.Service)desc.getServices().get(0);
            Endpoint firstEndpoint=firstService.getEndpoints().get(0);
            url=PropertyNormalizer.normalizeUrl(firstEndpoint.getAddress());
            doc.setProperty(SCHEMA,PROP_URL,url);
            if (title == null || title.isEmpty() || title.equals(fileUrl)) {
              title=firstService.getQName().getLocalPart();
              doc.setProperty(""String_Node_Str"",""String_Node_Str"",title);
            }
            if (doc.getParentRef() != null) {
              DocumentModel apiModel=session.getDocument(doc.getParentRef());
              String storedProtocol=(String)apiModel.getProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS);
              try {
                String protocol=((Binding)((Endpoint)firstService.getEndpoints().get(0)).getBinding()).getTransportProtocol();
                if (storedProtocol == null || !storedProtocol.contains(protocol)) {
                  if (storedProtocol == null || storedProtocol.isEmpty()) {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,protocol);
                  }
 else {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,storedProtocol + ""String_Node_Str"" + protocol);
                  }
                }
              }
 catch (              Exception e) {
                log.warn(""String_Node_Str"" + e.getMessage());
              }
              if (apiModel.getParentRef() != null) {
                DocumentModel appliImplModel=session.getDocument(apiModel.getParentRef());
                String existingServer=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER);
                String newServer=InetAddress.getByName(new URL(firstEndpoint.getAddress()).getHost()).getHostAddress();
                if (existingServer == null || !newServer.equals(existingServer)) {
                  appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER,newServer);
                }
                try {
                  String provider=new URL(((Endpoint)firstService.getEndpoints().get(0)).getAddress()).getAuthority();
                  String existingProvider=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER);
                  if (existingProvider == null || !provider.equals(existingProvider)) {
                    appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER,provider);
                  }
                }
 catch (                Exception e) {
                }
                session.saveDocument(appliImplModel);
              }
              session.saveDocument(apiModel);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"",e);
          }
 finally {
            tmpFile.delete();
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
    }
    if (url != null) {
      try {
        doc.setProperty(SCHEMA,PROP_URL,PropertyNormalizer.normalizeUrl(url));
      }
 catch (      MalformedURLException e) {
        log.error(""String_Node_Str"",e);
      }
      if (url.contains(""String_Node_Str"")) {
        doc.setProperty(SCHEMA,PROP_LIGHTURL,""String_Node_Str"");
      }
 else       if (url.contains(""String_Node_Str"")) {
        doc.setProperty(SCHEMA,PROP_LIGHTURL,""String_Node_Str"");
      }
    }
    if (fileUrl != null) {
      doc.setProperty(SCHEMA,PROP_FILEURL,PropertyNormalizer.normalizeUrl(fileUrl));
    }
    session.save();
    try {
      DocumentService docService=Framework.getService(DocumentService.class);
      DocumentModelList existingServiceModels=session.query(""String_Node_Str"" + url + ""String_Node_Str"");
      for (      DocumentModel existingServiceModel : existingServiceModels) {
        if (existingServiceModel != null && !existingServiceModel.getRef().equals(doc.getRef())) {
          docService.mergeDocument(session,existingServiceModel,doc,false);
        }
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
 catch (  Exception e) {
    log.error(e);
  }
}","public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  try {
    String title=(String)doc.getProperty(""String_Node_Str"",""String_Node_Str"");
    String url=(String)doc.getProperty(SCHEMA,PROP_URL);
    String fileUrl=(String)doc.getProperty(SCHEMA,PROP_FILEURL);
    if (fileUrl != null) {
      try {
        Blob blob=null;
        try {
          blob=new HttpFile(fileUrl).download().getBlob();
        }
 catch (        IOException e) {
          log.info(""String_Node_Str"" + fileUrl + ""String_Node_Str""+ e.getMessage());
        }
catch (        Exception e) {
          log.info(""String_Node_Str"" + fileUrl + ""String_Node_Str""+ e.getMessage());
        }
        if (blob != null) {
          NotificationService notifService=Framework.getService(NotificationService.class);
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",blob);
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",notifService.computeServiceTitle(fileUrl) + ""String_Node_Str"");
          File tmpFile=File.createTempFile(doc.getId(),null);
          blob.transferTo(tmpFile);
          try {
            WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
            Description desc=reader.read(tmpFile.toURI().toURL());
            org.ow2.easywsdl.wsdl.api.Service firstService=(org.ow2.easywsdl.wsdl.api.Service)desc.getServices().get(0);
            Endpoint firstEndpoint=firstService.getEndpoints().get(0);
            url=PropertyNormalizer.normalizeUrl(firstEndpoint.getAddress());
            doc.setProperty(SCHEMA,PROP_URL,url);
            if (title == null || title.isEmpty() || title.equals(fileUrl)) {
              title=firstService.getQName().getLocalPart();
              doc.setProperty(""String_Node_Str"",""String_Node_Str"",title);
            }
            if (doc.getParentRef() != null) {
              DocumentModel apiModel=session.getDocument(doc.getParentRef());
              String storedProtocol=(String)apiModel.getProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS);
              try {
                String protocol=((Binding)((Endpoint)firstService.getEndpoints().get(0)).getBinding()).getTransportProtocol();
                if (storedProtocol == null || !storedProtocol.contains(protocol)) {
                  if (storedProtocol == null || storedProtocol.isEmpty()) {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,protocol);
                  }
 else {
                    apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,storedProtocol + ""String_Node_Str"" + protocol);
                  }
                }
              }
 catch (              Exception e) {
                log.warn(""String_Node_Str"" + e.getMessage());
              }
              if (apiModel.getParentRef() != null) {
                DocumentModel appliImplModel=session.getDocument(apiModel.getParentRef());
                String existingServer=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER);
                String newServer=InetAddress.getByName(new URL(firstEndpoint.getAddress()).getHost()).getHostAddress();
                if (existingServer == null || !newServer.equals(existingServer)) {
                  appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER,newServer);
                }
                try {
                  String provider=new URL(((Endpoint)firstService.getEndpoints().get(0)).getAddress()).getAuthority();
                  String existingProvider=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER);
                  if (existingProvider == null || !provider.equals(existingProvider)) {
                    appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER,provider);
                  }
                }
 catch (                Exception e) {
                }
                session.saveDocument(appliImplModel);
              }
              session.saveDocument(apiModel);
            }
          }
 catch (          Exception e) {
            log.error(""String_Node_Str"",e);
          }
 finally {
            tmpFile.delete();
          }
        }
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
    }
    if (url != null) {
      try {
        doc.setProperty(SCHEMA,PROP_URL,PropertyNormalizer.normalizeUrl(url));
      }
 catch (      MalformedURLException e) {
        log.warn(""String_Node_Str"",e);
      }
      if (url.contains(""String_Node_Str"")) {
        doc.setProperty(SCHEMA,PROP_LIGHTURL,""String_Node_Str"");
      }
 else       if (url.contains(""String_Node_Str"")) {
        doc.setProperty(SCHEMA,PROP_LIGHTURL,""String_Node_Str"");
      }
    }
    if (fileUrl != null) {
      doc.setProperty(SCHEMA,PROP_FILEURL,PropertyNormalizer.normalizeUrl(fileUrl));
    }
    session.save();
    try {
      DocumentService docService=Framework.getService(DocumentService.class);
      DocumentModelList existingServiceModels=session.query(""String_Node_Str"" + url + ""String_Node_Str"");
      for (      DocumentModel existingServiceModel : existingServiceModels) {
        if (existingServiceModel != null && !existingServiceModel.getRef().equals(doc.getRef())) {
          docService.mergeDocument(session,existingServiceModel,doc,false);
        }
      }
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
 catch (  Exception e) {
    log.error(e);
  }
}"
18330,"public void activate(ComponentContext context) throws Exception {
  RepositoryManager repoService=Framework.getService(RepositoryManager.class);
  try {
    String defaultRepoName=repoService.getDefaultRepository().getName();
    new DomainInit(defaultRepoName).runUnrestricted();
  }
 catch (  Exception e) {
    Log.warn(""String_Node_Str"" + e.getMessage());
  }
}","public void activate(ComponentContext context) throws Exception {
  RepositoryManager repoService=Framework.getService(RepositoryManager.class);
  try {
    String defaultRepoName=repoService.getDefaultRepository().getName();
    new DomainInit(defaultRepoName).runUnrestricted();
  }
 catch (  Exception e) {
    log.warn(""String_Node_Str"" + e.getMessage());
  }
}"
18331,"public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  try {
    String title=(String)doc.getProperty(""String_Node_Str"",""String_Node_Str"");
    String url=(String)doc.getProperty(SCHEMA,PROP_URL);
    String fileUrl=(String)doc.getProperty(SCHEMA_COMMON,PROP_FILEURL);
    if (fileUrl != null) {
      Blob blob=new HttpFile(fileUrl).download().getBlob();
      if (blob == null) {
        return;
      }
      File tmpFile=File.createTempFile(doc.getId(),null);
      blob.transferTo(tmpFile);
      try {
        WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
        Description desc=reader.read(tmpFile.toURI().toURL());
        org.ow2.easywsdl.wsdl.api.Service firstService=(org.ow2.easywsdl.wsdl.api.Service)desc.getServices().get(0);
        Endpoint firstEndpoint=firstService.getEndpoints().get(0);
        url=firstEndpoint.getAddress();
        doc.setProperty(SCHEMA,PROP_URL,PropertyNormalizer.normalizeUrl(url));
        if (title == null || title.isEmpty() || title.equals(url)) {
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",firstService.getQName().getLocalPart());
        }
        if (url.contains(""String_Node_Str"")) {
          doc.setProperty(SCHEMA,PROP_LIGHTURL,""String_Node_Str"");
        }
        DocumentModel apiModel=session.getDocument(doc.getParentRef());
        String protocol=((Binding)((Endpoint)firstService.getEndpoints().get(0)).getBinding()).getTransportProtocol();
        String storedProtocol=(String)apiModel.getProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS);
        if (storedProtocol == null || !storedProtocol.contains(protocol)) {
          if (storedProtocol == null || storedProtocol.isEmpty()) {
            apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,protocol);
          }
 else {
            apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,storedProtocol + ""String_Node_Str"" + protocol);
          }
        }
        DocumentModel appliImplModel=session.getDocument(apiModel.getParentRef());
        String existingServer=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER);
        String newServer=InetAddress.getByName(new URL(firstEndpoint.getAddress()).getHost()).getHostAddress();
        if (existingServer == null || !newServer.equals(existingServer)) {
          appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER,newServer);
        }
        try {
          String provider=new URL(((Endpoint)firstService.getEndpoints().get(0)).getAddress()).getAuthority();
          String existingProvider=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER);
          if (existingProvider == null || !provider.equals(existingProvider)) {
            appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER,provider);
          }
        }
 catch (        Exception e) {
        }
        session.saveDocument(apiModel);
        session.saveDocument(appliImplModel);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
 finally {
        tmpFile.delete();
      }
    }
    if (title == null || title.isEmpty() || title.equals(url)) {
      doc.setProperty(""String_Node_Str"",""String_Node_Str"",url.substring(title.lastIndexOf('/') + 1));
    }
    session.save();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
}","public void handleEvent(Event event){
  EventContext ctx=event.getContext();
  if (!(ctx instanceof DocumentEventContext)) {
    return;
  }
  CoreSession session=ctx.getCoreSession();
  DocumentModel doc=((DocumentEventContext)ctx).getSourceDocument();
  if (doc == null) {
    return;
  }
  String type=doc.getType();
  if (!type.equals(DOCTYPE)) {
    return;
  }
  try {
    String title=(String)doc.getProperty(""String_Node_Str"",""String_Node_Str"");
    String url=(String)doc.getProperty(SCHEMA,PROP_URL);
    String fileUrl=(String)doc.getProperty(SCHEMA_COMMON,PROP_FILEURL);
    if (fileUrl != null) {
      Blob blob=new HttpFile(fileUrl).download().getBlob();
      if (blob == null) {
        return;
      }
      File tmpFile=File.createTempFile(doc.getId(),null);
      blob.transferTo(tmpFile);
      try {
        WSDLReader reader=WSDLFactory.newInstance().newWSDLReader();
        Description desc=reader.read(tmpFile.toURI().toURL());
        org.ow2.easywsdl.wsdl.api.Service firstService=(org.ow2.easywsdl.wsdl.api.Service)desc.getServices().get(0);
        Endpoint firstEndpoint=firstService.getEndpoints().get(0);
        url=firstEndpoint.getAddress();
        doc.setProperty(SCHEMA,PROP_URL,PropertyNormalizer.normalizeUrl(url));
        DocumentService docService=Framework.getService(DocumentService.class);
        DocumentModel existingServiceModel=docService.findService(session,url);
        if (existingServiceModel != null && !existingServiceModel.getRef().equals(doc.getRef())) {
          docService.mergeDocument(session,existingServiceModel,doc,false);
        }
        if (title == null || title.isEmpty() || title.equals(url)) {
          doc.setProperty(""String_Node_Str"",""String_Node_Str"",firstService.getQName().getLocalPart());
        }
        if (url.contains(""String_Node_Str"")) {
          doc.setProperty(SCHEMA,PROP_LIGHTURL,""String_Node_Str"");
        }
        DocumentModel apiModel=session.getDocument(doc.getParentRef());
        String protocol=((Binding)((Endpoint)firstService.getEndpoints().get(0)).getBinding()).getTransportProtocol();
        String storedProtocol=(String)apiModel.getProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS);
        if (storedProtocol == null || !storedProtocol.contains(protocol)) {
          if (storedProtocol == null || storedProtocol.isEmpty()) {
            apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,protocol);
          }
 else {
            apiModel.setProperty(ServiceAPI.SCHEMA,ServiceAPI.PROP_PROTOCOLS,storedProtocol + ""String_Node_Str"" + protocol);
          }
        }
        DocumentModel appliImplModel=session.getDocument(apiModel.getParentRef());
        String existingServer=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER);
        String newServer=InetAddress.getByName(new URL(firstEndpoint.getAddress()).getHost()).getHostAddress();
        if (existingServer == null || !newServer.equals(existingServer)) {
          appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_SERVER,newServer);
        }
        try {
          String provider=new URL(((Endpoint)firstService.getEndpoints().get(0)).getAddress()).getAuthority();
          String existingProvider=(String)appliImplModel.getProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER);
          if (existingProvider == null || !provider.equals(existingProvider)) {
            appliImplModel.setProperty(AppliImpl.SCHEMA,AppliImpl.PROP_PROVIDER,provider);
          }
        }
 catch (        Exception e) {
        }
        session.saveDocument(apiModel);
        session.saveDocument(appliImplModel);
      }
 catch (      Exception e) {
        log.error(""String_Node_Str"",e);
      }
 finally {
        tmpFile.delete();
      }
    }
    if (title == null || title.isEmpty() || title.equals(url)) {
      doc.setProperty(""String_Node_Str"",""String_Node_Str"",url.substring(title.lastIndexOf('/') + 1));
    }
    session.save();
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
  }
}"
18332,"/** 
 * Merges properties from a document to another, i.e. copies properties from a source model to the destination. The source document is deleted, and the destination saved.
 * @param from
 * @param to
 * @param overwrite If destination properties have to be overwritten
 * @return
 * @throws ClientException
 */
public boolean mergeDocument(CoreSession session,DocumentModel from,DocumentModel to,boolean overwrite) throws ClientException {
  if (from.getType().equals(to.getType())) {
    for (    String dataModelKey : from.getDataModels().keySet()) {
      String schema=from.getDataModels().get(dataModelKey).getSchema();
      Map<String,Object> schemaPropertiesFrom=from.getProperties(schema);
      Map<String,Object> schemaPropertiesTo=to.getProperties(schema);
      for (      String property : schemaPropertiesFrom.keySet()) {
        Serializable fromValue=(Serializable)schemaPropertiesFrom.get(property);
        if (fromValue != null && (schemaPropertiesTo.get(property) == null || overwrite)) {
          to.setPropertyValue(property,fromValue);
        }
      }
    }
    session.saveDocument(to);
    session.save();
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Merges properties from a document to another, i.e. copies properties from a source model to the destination. The source document is deleted, and the destination saved.
 * @param from
 * @param to
 * @param overwrite If destination properties have to be overwritten
 * @return
 * @throws ClientException
 */
public boolean mergeDocument(CoreSession session,DocumentModel from,DocumentModel to,boolean overwrite) throws ClientException {
  if (from.getType().equals(to.getType())) {
    for (    String dataModelKey : from.getDataModels().keySet()) {
      String schema=from.getDataModels().get(dataModelKey).getSchema();
      Map<String,Object> schemaPropertiesFrom=from.getProperties(schema);
      Map<String,Object> schemaPropertiesTo=to.getProperties(schema);
      for (      String property : schemaPropertiesFrom.keySet()) {
        Serializable fromValue=(Serializable)schemaPropertiesFrom.get(property);
        if (fromValue != null && (schemaPropertiesTo.get(property) == null || overwrite)) {
          to.setPropertyValue(property,fromValue);
        }
      }
    }
    session.removeDocument(from.getRef());
    return true;
  }
 else {
    return false;
  }
}"
18333,"private String getNewCallcount(DocumentModel serviceModel,String newCalls){
  Long previousCallcount, newCallsLong;
  try {
    previousCallcount=(Long)serviceModel.getProperty(Service.SCHEMA,Service.PROP_CALLCOUNT);
  }
 catch (  ClientException e) {
    previousCallcount=new Long(0);
  }
  if (previousCallcount == null) {
    previousCallcount=new Long(0);
  }
  if (newCalls == null) {
    newCallsLong=new Long(0);
  }
 else {
    newCallsLong=Long.parseLong(newCalls);
  }
  return ((Long)(newCallsLong + previousCallcount)).toString();
}","private String getNewCallcount(DocumentModel serviceModel,String newCalls){
  Long previousCallcount, newCallsLong;
  try {
    previousCallcount=(Long)serviceModel.getProperty(Service.SCHEMA,Service.PROP_CALLCOUNT);
  }
 catch (  Exception e) {
    previousCallcount=new Long(0);
  }
  if (previousCallcount == null) {
    previousCallcount=new Long(0);
  }
  try {
    newCallsLong=Long.parseLong(newCalls);
  }
 catch (  Exception e) {
    newCallsLong=new Long(0);
  }
  return ((Long)(newCallsLong + previousCallcount)).toString();
}"
18334,"/** 
 * Creates or update a Service given the specified properties. Properties require at least application's URL (PROP_URL) and parent API URL (PROP_PARENTURL). If parent API is unknown, you can use the   {@link #computeApiUrl} function.
 * @param session
 * @param properties A set of properties of the document, among the Service.PROP_XXX constants.
 * @return The created/updated Service
 * @throws ClientException
 * @throws MalformedURLException 
 */
public final DocumentModel notifyService(CoreSession session,Map<String,String> properties) throws ClientException, MalformedURLException {
  if (properties.get(Service.PROP_URL) != null) {
    String url=properties.get(Service.PROP_URL), parentUrl=properties.get(Service.PROP_PARENTURL);
    if (parentUrl == null) {
      parentUrl=computeApiUrl(url);
    }
    DocumentService docService=Framework.getRuntime().getService(DocumentService.class);
    DocumentModel apiModel=docService.findServiceApi(session,parentUrl);
    if (apiModel == null) {
      apiModel=docService.createServiceAPI(session,null,parentUrl);
      String serviceTitle=properties.get(Service.PROP_URL);
      if (serviceTitle != null) {
        apiModel.setProperty(""String_Node_Str"",""String_Node_Str"",serviceTitle + ""String_Node_Str"");
      }
      session.saveDocument(apiModel);
      session.save();
    }
    DocumentModel serviceModel=docService.findService(session,url);
    if (serviceModel == null)     serviceModel=docService.createService(session,apiModel.getPathAsString(),url);
    setPropertiesIfNotNull(serviceModel,Service.SCHEMA,Service.getPropertyList(),properties);
    properties.put(Service.PROP_CALLCOUNT,getNewCallcount(serviceModel,properties.get(Service.PROP_CALLCOUNT)));
    if (!apiModel.getRef().equals(serviceModel.getParentRef())) {
      serviceModel=session.move(serviceModel.getRef(),apiModel.getRef(),null);
    }
    session.saveDocument(serviceModel);
    session.save();
    return serviceModel;
  }
 else {
    throw new ClientException(""String_Node_Str"");
  }
}","/** 
 * Creates or update a Service given the specified properties. Properties require at least application's URL (PROP_URL) and parent API URL (PROP_PARENTURL). If parent API is unknown, you can use the   {@link #computeApiUrl} function.
 * @param session
 * @param properties A set of properties of the document, among the Service.PROP_XXX constants.
 * @return The created/updated Service
 * @throws ClientException
 * @throws MalformedURLException 
 */
public final DocumentModel notifyService(CoreSession session,Map<String,String> properties) throws ClientException, MalformedURLException {
  if (properties.get(Service.PROP_URL) != null) {
    String url=properties.get(Service.PROP_URL), parentUrl=properties.get(Service.PROP_PARENTURL);
    if (parentUrl == null) {
      parentUrl=computeApiUrl(url);
    }
    DocumentService docService=Framework.getRuntime().getService(DocumentService.class);
    DocumentModel apiModel=docService.findServiceApi(session,parentUrl);
    if (apiModel == null) {
      apiModel=docService.createServiceAPI(session,null,parentUrl);
      String serviceTitle=properties.get(Service.PROP_URL);
      if (serviceTitle != null) {
        apiModel.setProperty(""String_Node_Str"",""String_Node_Str"",serviceTitle + ""String_Node_Str"");
      }
      session.saveDocument(apiModel);
      session.save();
    }
    DocumentModel serviceModel=docService.findService(session,url);
    if (serviceModel == null)     serviceModel=docService.createService(session,apiModel.getPathAsString(),url);
    properties.put(Service.PROP_CALLCOUNT,getNewCallcount(serviceModel,properties.get(Service.PROP_CALLCOUNT)));
    setPropertiesIfNotNull(serviceModel,Service.SCHEMA,Service.getPropertyList(),properties);
    if (!apiModel.getRef().equals(serviceModel.getParentRef())) {
      serviceModel=session.move(serviceModel.getRef(),apiModel.getRef(),null);
    }
    session.saveDocument(serviceModel);
    session.save();
    return serviceModel;
  }
 else {
    throw new ClientException(""String_Node_Str"");
  }
}"
18335,"public AbstractNotificationTest() throws Exception {
  FileInputStream isProps=new FileInputStream(""String_Node_Str"");
  Properties props=new Properties();
  props.load(isProps);
  isProps.close();
  if (Boolean.parseBoolean(props.getProperty(""String_Node_Str"")))   throw new UnsupportedOperationException(""String_Node_Str"");
  String nuxeoHost=props.getProperty(""String_Node_Str"");
  String nuxeoPort=props.getProperty(""String_Node_Str"");
  if (nuxeoHost == null || nuxeoPort == null) {
    log.warn(""String_Node_Str"" + RestNotificationFactory.NUXEO_URL_LOCALHOST);
    nuxeoUrl=RestNotificationFactory.NUXEO_URL_LOCALHOST;
  }
 else {
    nuxeoUrl=""String_Node_Str"" + nuxeoHost + ""String_Node_Str""+ nuxeoPort+ ""String_Node_Str"";
  }
  notificationFactory=new RestNotificationFactory(nuxeoUrl);
  automation=new AutomationHelper(nuxeoUrl);
}","public AbstractNotificationTest() throws Exception {
  FileInputStream isProps=new FileInputStream(""String_Node_Str"");
  Properties props=new Properties();
  props.load(isProps);
  isProps.close();
  if (Boolean.parseBoolean(props.getProperty(""String_Node_Str"")))   throw new UnsupportedOperationException(""String_Node_Str"");
  String nuxeoHost=props.getProperty(""String_Node_Str"");
  String nuxeoPort=props.getProperty(""String_Node_Str"");
  if (nuxeoHost == null || nuxeoPort == null) {
    log.warn(""String_Node_Str"" + RestNotificationFactory.NUXEO_URL_LOCALHOST);
    nuxeoUrl=RestNotificationFactory.NUXEO_URL_LOCALHOST;
  }
 else {
    nuxeoUrl=""String_Node_Str"" + nuxeoHost + ""String_Node_Str""+ nuxeoPort+ ""String_Node_Str"";
  }
  notificationFactory=new RestNotificationFactory(nuxeoUrl);
  try {
    automation=new AutomationHelper(nuxeoUrl);
  }
 catch (  Exception e) {
    automation=null;
  }
}"
18336,"/** 
 * Creates an Appli Impl.
 * @throws Exception
 */
@Test public void createAppliImpl() throws Exception {
  String url=""String_Node_Str"", title=""String_Node_Str"";
  RestNotificationRequest notification=notificationFactory.createNotification(RestNotificationAPI.APPLIIMPL);
  notification.setProperty(AppliImpl.PROP_TITLE,title);
  notification.setProperty(AppliImpl.PROP_URL,url);
  notification.send();
  assertFalse(automation.findDocumentByUrl(AppliImpl.DOCTYPE,url).isEmpty());
}","/** 
 * Creates an Appli Impl.
 * @throws Exception
 */
@Test public void createAppliImpl() throws Exception {
  String url=""String_Node_Str"", title=""String_Node_Str"";
  RestNotificationRequest notification=notificationFactory.createNotification(RestNotificationAPI.APPLIIMPL);
  notification.setProperty(AppliImpl.PROP_TITLE,title);
  notification.setProperty(AppliImpl.PROP_URL,url);
  Assume.assumeTrue(notification.send());
  assertFalse(automation.findDocumentByUrl(AppliImpl.DOCTYPE,url).isEmpty());
}"
18337,"/** 
 * Sends the notification.
 * @throws IOException When the request failed.
 * @throws ProtocolException When the request returned an error.
 */
public void send() throws IOException, ProtocolException ;","/** 
 * Sends the notification.
 * @throws IOException When the request failed.
 * @throws ProtocolException When the request returned an error.
 * @return If the notification was successfully send
 */
public boolean send() throws IOException, ProtocolException ;"
18338,"/** 
 * Creates or update a Service given the specified properties. Properties require at least application's URL (PROP_URL) and parent API URL (PROP_PARENTURL). If parent API is unknown, you can use the   {@link #computeApiUrl} function.
 * @param session
 * @param properties A set of properties of the document, among the Service.PROP_XXX constants.
 * @return The created/updated Service
 * @throws ClientException
 * @throws MalformedURLException 
 */
public final DocumentModel notifyService(CoreSession session,Map<String,String> properties) throws ClientException, MalformedURLException {
  if (properties.get(Service.PROP_URL) != null) {
    String url=properties.get(Service.PROP_URL), parentUrl=properties.get(Service.PROP_PARENTURL);
    if (parentUrl == null) {
      parentUrl=computeApiUrl(url);
    }
    DocumentService docService=Framework.getRuntime().getService(DocumentService.class);
    DocumentModel apiModel=docService.findServiceApi(session,parentUrl);
    if (apiModel == null) {
      apiModel=docService.createServiceAPI(session,null,parentUrl);
      String serviceTitle=properties.get(Service.PROP_URL);
      if (serviceTitle != null) {
        apiModel.setProperty(""String_Node_Str"",""String_Node_Str"",serviceTitle + ""String_Node_Str"");
      }
      session.saveDocument(apiModel);
      session.save();
    }
    DocumentModel serviceModel=docService.findService(session,url);
    if (serviceModel == null)     serviceModel=docService.createService(session,apiModel.getPathAsString(),url);
    if (!apiModel.getRef().equals(serviceModel.getParentRef())) {
      session.move(serviceModel.getRef(),apiModel.getRef(),null);
    }
    int newCallcount;
    try {
      newCallcount=Integer.parseInt((String)serviceModel.getProperty(Service.SCHEMA,Service.PROP_CALLCOUNT));
    }
 catch (    Exception e) {
      newCallcount=0;
    }
    try {
      newCallcount+=(properties.get(Service.PROP_CALLCOUNT) != null) ? Integer.parseInt(properties.get(Service.PROP_CALLCOUNT)) : 0;
    }
 catch (    NumberFormatException e) {
    }
    properties.put(Service.PROP_CALLCOUNT,Integer.toString(newCallcount));
    setPropertiesIfNotNull(serviceModel,Service.SCHEMA,Service.getPropertyList(),properties);
    session.saveDocument(serviceModel);
    session.save();
    return serviceModel;
  }
 else {
    throw new ClientException(""String_Node_Str"");
  }
}","/** 
 * Creates or update a Service given the specified properties. Properties require at least application's URL (PROP_URL) and parent API URL (PROP_PARENTURL). If parent API is unknown, you can use the   {@link #computeApiUrl} function.
 * @param session
 * @param properties A set of properties of the document, among the Service.PROP_XXX constants.
 * @return The created/updated Service
 * @throws ClientException
 * @throws MalformedURLException 
 */
public final DocumentModel notifyService(CoreSession session,Map<String,String> properties) throws ClientException, MalformedURLException {
  if (properties.get(Service.PROP_URL) != null) {
    String url=properties.get(Service.PROP_URL), parentUrl=properties.get(Service.PROP_PARENTURL);
    if (parentUrl == null) {
      parentUrl=computeApiUrl(url);
    }
    DocumentService docService=Framework.getRuntime().getService(DocumentService.class);
    DocumentModel apiModel=docService.findServiceApi(session,parentUrl);
    if (apiModel == null) {
      apiModel=docService.createServiceAPI(session,null,parentUrl);
      String serviceTitle=properties.get(Service.PROP_URL);
      if (serviceTitle != null) {
        apiModel.setProperty(""String_Node_Str"",""String_Node_Str"",serviceTitle + ""String_Node_Str"");
      }
      session.saveDocument(apiModel);
      session.save();
    }
    DocumentModel serviceModel=docService.findService(session,url);
    if (serviceModel == null)     serviceModel=docService.createService(session,apiModel.getPathAsString(),url);
    if (!apiModel.getRef().equals(serviceModel.getParentRef())) {
      session.move(serviceModel.getRef(),apiModel.getRef(),null);
    }
    properties.put(Service.PROP_CALLCOUNT,getNewCallcount(serviceModel,Long.parseLong(properties.get(Service.PROP_CALLCOUNT))));
    setPropertiesIfNotNull(serviceModel,Service.SCHEMA,Service.getPropertyList(),properties);
    session.saveDocument(serviceModel);
    session.save();
    return serviceModel;
  }
 else {
    throw new ClientException(""String_Node_Str"");
  }
}"
18339,"private static DocumentModel findFirstDocument(CoreSession session,String type,String field,String value) throws ClientException {
  DocumentModelList apis=session.query(""String_Node_Str"" + type + ""String_Node_Str""+ field+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  return (apis != null) ? apis.get(0) : null;
}","private static DocumentModel findFirstDocument(CoreSession session,String type,String field,String value) throws ClientException {
  DocumentModelList apis=session.query(""String_Node_Str"" + type + ""String_Node_Str""+ field+ ""String_Node_Str""+ value+ ""String_Node_Str"");
  return (apis != null && apis.size() > 0) ? apis.get(0) : null;
}"
18340,"public static DocumentModel findAppliImpl(CoreSession session,String appliUrl) throws ClientException {
  return findFirstDocument(session,SERVICEAPI_DOCTYPE,""String_Node_Str"",appliUrl);
}","public static DocumentModel findAppliImpl(CoreSession session,String appliUrl) throws ClientException {
  return findFirstDocument(session,APPLIIMPL_DOCTYPE,""String_Node_Str"",appliUrl);
}"
18341,"protected Resource createDynamicResource(ResourceKey resourceKey,boolean useDependencyInjection){
  Resource result=null;
  Map<String,String> params=null;
  MappedResourceData mappedResourceData=mappedResourceDataMap.get(resourceKey);
  ResourceKey actualKey;
  if (mappedResourceData != null) {
    actualKey=mappedResourceData.getResourceKey();
    if (useDependencyInjection) {
      params=mappedResourceData.getParams();
    }
  }
 else {
    actualKey=resourceKey;
    if (useDependencyInjection) {
      params=Collections.<String,String>emptyMap();
    }
  }
  if (Strings.isNullOrEmpty(resourceKey.getResourceName())) {
    return null;
  }
  if (actualKey.getResourceName().endsWith(""String_Node_Str"")) {
    result=createCompiledCSSResource(actualKey);
  }
 else {
    result=createHandlerDependentResource(actualKey,params);
  }
  if (result != null) {
    result.setLibraryName(resourceKey.getLibraryName());
    result.setResourceName(resourceKey.getResourceName());
  }
 else   if (mappedResourceData == null) {
    result=defaultHandler.createResource(actualKey.getResourceName(),actualKey.getLibraryName());
  }
  return result;
}","protected Resource createDynamicResource(ResourceKey resourceKey,boolean useDependencyInjection){
  Resource result=null;
  Map<String,String> params=null;
  MappedResourceData mappedResourceData=mappedResourceDataMap.get(resourceKey);
  ResourceKey actualKey;
  if (mappedResourceData != null) {
    actualKey=mappedResourceData.getResourceKey();
    if (useDependencyInjection) {
      params=mappedResourceData.getParams();
    }
  }
 else {
    actualKey=resourceKey;
    if (useDependencyInjection) {
      params=Collections.<String,String>emptyMap();
    }
  }
  if (Strings.isNullOrEmpty(resourceKey.getResourceName())) {
    return null;
  }
  if (actualKey.getResourceName().endsWith(""String_Node_Str"")) {
    result=createCompiledCSSResource(actualKey);
  }
 else {
    result=createHandlerDependentResource(actualKey,params);
  }
  if (result != null) {
    result.setLibraryName(resourceKey.getLibraryName());
    result.setResourceName(resourceKey.getResourceName());
  }
 else   if (mappedResourceData != null) {
    result=defaultHandler.createResource(actualKey.getResourceName(),actualKey.getLibraryName());
  }
  return result;
}"
18342,"protected Resource createDynamicResource(ResourceKey resourceKey,boolean useDependencyInjection){
  Resource result=null;
  Map<String,String> params=null;
  MappedResourceData mappedResourceData=mappedResourceDataMap.get(resourceKey);
  ResourceKey actualKey;
  if (mappedResourceData != null) {
    actualKey=mappedResourceData.getResourceKey();
    if (useDependencyInjection) {
      params=mappedResourceData.getParams();
    }
  }
 else {
    actualKey=resourceKey;
    if (useDependencyInjection) {
      params=Collections.<String,String>emptyMap();
    }
  }
  if (Strings.isNullOrEmpty(resourceKey.getResourceName())) {
    return null;
  }
  if (actualKey.getResourceName().endsWith(""String_Node_Str"")) {
    result=createCompiledCSSResource(actualKey);
  }
 else {
    result=createHandlerDependentResource(actualKey,params);
  }
  if (result != null) {
    result.setLibraryName(resourceKey.getLibraryName());
    result.setResourceName(resourceKey.getResourceName());
  }
 else   if (mappedResourceData == null) {
    result=defaultHandler.createResource(actualKey.getResourceName(),actualKey.getLibraryName());
  }
  return result;
}","protected Resource createDynamicResource(ResourceKey resourceKey,boolean useDependencyInjection){
  Resource result=null;
  Map<String,String> params=null;
  MappedResourceData mappedResourceData=mappedResourceDataMap.get(resourceKey);
  ResourceKey actualKey;
  if (mappedResourceData != null) {
    actualKey=mappedResourceData.getResourceKey();
    if (useDependencyInjection) {
      params=mappedResourceData.getParams();
    }
  }
 else {
    actualKey=resourceKey;
    if (useDependencyInjection) {
      params=Collections.<String,String>emptyMap();
    }
  }
  if (Strings.isNullOrEmpty(resourceKey.getResourceName())) {
    return null;
  }
  if (actualKey.getResourceName().endsWith(""String_Node_Str"")) {
    result=createCompiledCSSResource(actualKey);
  }
 else {
    result=createHandlerDependentResource(actualKey,params);
  }
  if (result != null) {
    result.setLibraryName(resourceKey.getLibraryName());
    result.setResourceName(resourceKey.getResourceName());
  }
 else   if (mappedResourceData != null) {
    result=defaultHandler.createResource(actualKey.getResourceName(),actualKey.getLibraryName());
  }
  return result;
}"
18343,"public RequestImpl(Meteor meteor,Session session){
  super();
  this.meteor=meteor;
  meteor.addListener(this);
  this.session=session;
}","public RequestImpl(Meteor meteor,Session session){
  super();
  this.meteor=meteor;
  meteor.addListener(this);
  this.session=session;
  policy=new BroadcasterLifeCyclePolicy.Builder().policy(BroadcasterLifeCyclePolicy.ATMOSPHERE_RESOURCE_POLICY.EMPTY_DESTROY).build();
  this.meteor.getBroadcaster().setBroadcasterLifeCyclePolicy(policy);
}"
18344,"@Override public void removeRepository(String groupName,String repo,boolean uninstall) throws Exception {
  Group group=groupManager.findGroupByName(groupName);
  if (group == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + groupName + ""String_Node_Str"");
  }
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<String,String> clusterRepositories=clusterManager.getMap(Constants.REPOSITORIES_MAP + Configurations.SEPARATOR + groupName);
  Map<FeatureState,Boolean> clusterFeatures=clusterManager.getMap(Constants.FEATURES_MAP + Configurations.SEPARATOR + groupName);
  ClassLoader originalClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
    List<String> urls=new ArrayList<String>();
    Pattern pattern=Pattern.compile(repo);
    for (    String repositoryUrl : clusterRepositories.keySet()) {
      String repositoryName=clusterRepositories.get(repositoryUrl);
      if (repositoryName != null && !repositoryName.isEmpty()) {
        Matcher nameMatcher=pattern.matcher(repositoryName);
        if (nameMatcher.matches()) {
          urls.add(repositoryUrl);
        }
 else {
          Matcher uriMatcher=pattern.matcher(repositoryUrl);
          if (uriMatcher.matches()) {
            urls.add(repositoryUrl);
          }
        }
      }
 else {
        Matcher uriMatcher=pattern.matcher(repositoryUrl);
        if (uriMatcher.matches()) {
          urls.add(repositoryUrl);
        }
      }
    }
    for (    String url : urls) {
      boolean found=false;
      for (      String repository : clusterRepositories.keySet()) {
        if (repository.equals(repository)) {
          found=true;
          break;
        }
      }
      if (found) {
        Features repositoryModel=JaxbUtil.unmarshal(url,true);
        clusterRepositories.remove(url);
        for (        Feature feature : repositoryModel.getFeature()) {
          clusterFeatures.remove(feature.getName() + ""String_Node_Str"" + feature.getVersion());
        }
        ClusterRepositoryEvent event=new ClusterRepositoryEvent(url,RepositoryEvent.EventType.RepositoryRemoved);
        event.setUninstall(uninstall);
        event.setSourceGroup(group);
        event.setSourceNode(clusterManager.getNode());
        eventProducer.produce(event);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + url + ""String_Node_Str""+ groupName);
      }
    }
  }
  finally {
    Thread.currentThread().setContextClassLoader(originalClassLoader);
  }
}","@Override public void removeRepository(String groupName,String repo,boolean uninstall) throws Exception {
  Group group=groupManager.findGroupByName(groupName);
  if (group == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + groupName + ""String_Node_Str"");
  }
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<String,String> clusterRepositories=clusterManager.getMap(Constants.REPOSITORIES_MAP + Configurations.SEPARATOR + groupName);
  Map<FeatureState,Boolean> clusterFeatures=clusterManager.getMap(Constants.FEATURES_MAP + Configurations.SEPARATOR + groupName);
  ClassLoader originalClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
    List<String> urls=new ArrayList<String>();
    Pattern pattern=Pattern.compile(repo);
    for (    String repositoryUrl : clusterRepositories.keySet()) {
      String repositoryName=clusterRepositories.get(repositoryUrl);
      if (repositoryName != null && !repositoryName.isEmpty()) {
        Matcher nameMatcher=pattern.matcher(repositoryName);
        if (nameMatcher.matches()) {
          urls.add(repositoryUrl);
        }
 else {
          Matcher uriMatcher=pattern.matcher(repositoryUrl);
          if (uriMatcher.matches()) {
            urls.add(repositoryUrl);
          }
        }
      }
 else {
        Matcher uriMatcher=pattern.matcher(repositoryUrl);
        if (uriMatcher.matches()) {
          urls.add(repositoryUrl);
        }
      }
    }
    for (    String url : urls) {
      boolean found=false;
      for (      String repository : clusterRepositories.keySet()) {
        if (repository.equals(url)) {
          found=true;
          break;
        }
      }
      if (found) {
        Features repositoryModel=JaxbUtil.unmarshal(url,true);
        clusterRepositories.remove(url);
        for (        Feature feature : repositoryModel.getFeature()) {
          clusterFeatures.remove(feature.getName() + ""String_Node_Str"" + feature.getVersion());
        }
        ClusterRepositoryEvent event=new ClusterRepositoryEvent(url,RepositoryEvent.EventType.RepositoryRemoved);
        event.setUninstall(uninstall);
        event.setSourceGroup(group);
        event.setSourceNode(clusterManager.getNode());
        eventProducer.produce(event);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + url + ""String_Node_Str""+ groupName);
      }
    }
  }
  finally {
    Thread.currentThread().setContextClassLoader(originalClassLoader);
  }
}"
18345,"@Override protected Object doExecute() throws Exception {
  Group group=groupManager.findGroupByName(groupName);
  if (group == null) {
    System.err.println(""String_Node_Str"" + groupName + ""String_Node_Str"");
    return null;
  }
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    System.err.println(""String_Node_Str"");
    return null;
  }
  Map<String,String> clusterRepositories=clusterManager.getMap(Constants.REPOSITORIES_MAP + Configurations.SEPARATOR + groupName);
  Map<String,FeatureState> clusterFeatures=clusterManager.getMap(Constants.FEATURES_MAP + Configurations.SEPARATOR + groupName);
  ClassLoader originalClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
    List<String> urls=new ArrayList<String>();
    Pattern pattern=Pattern.compile(repository);
    for (    String repositoryUrl : clusterRepositories.keySet()) {
      String repositoryName=clusterRepositories.get(repositoryUrl);
      if (repositoryName != null && !repositoryName.isEmpty()) {
        Matcher nameMatcher=pattern.matcher(repositoryName);
        if (nameMatcher.matches()) {
          urls.add(repositoryUrl);
        }
 else {
          Matcher uriMatcher=pattern.matcher(repositoryUrl);
          if (uriMatcher.matches()) {
            urls.add(repositoryUrl);
          }
        }
      }
 else {
        Matcher uriMatcher=pattern.matcher(repositoryUrl);
        if (uriMatcher.matches()) {
          urls.add(repositoryUrl);
        }
      }
    }
    for (    String url : urls) {
      boolean found=false;
      for (      String repository : clusterRepositories.keySet()) {
        if (this.repository.equals(repository)) {
          found=true;
          break;
        }
      }
      if (found) {
        Features repositoryModel=JaxbUtil.unmarshal(url,true);
        clusterRepositories.remove(url);
        for (        Feature feature : repositoryModel.getFeature()) {
          clusterFeatures.remove(feature.getName() + ""String_Node_Str"" + feature.getVersion());
        }
        ClusterRepositoryEvent event=new ClusterRepositoryEvent(url,RepositoryEvent.EventType.RepositoryRemoved);
        event.setUninstall(uninstall);
        event.setSourceGroup(group);
        event.setSourceNode(clusterManager.getNode());
        eventProducer.produce(event);
      }
 else {
        System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ groupName);
      }
    }
  }
  finally {
    Thread.currentThread().setContextClassLoader(originalClassLoader);
  }
  return null;
}","@Override protected Object doExecute() throws Exception {
  Group group=groupManager.findGroupByName(groupName);
  if (group == null) {
    System.err.println(""String_Node_Str"" + groupName + ""String_Node_Str"");
    return null;
  }
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    System.err.println(""String_Node_Str"");
    return null;
  }
  Map<String,String> clusterRepositories=clusterManager.getMap(Constants.REPOSITORIES_MAP + Configurations.SEPARATOR + groupName);
  Map<String,FeatureState> clusterFeatures=clusterManager.getMap(Constants.FEATURES_MAP + Configurations.SEPARATOR + groupName);
  ClassLoader originalClassLoader=Thread.currentThread().getContextClassLoader();
  try {
    Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
    List<String> urls=new ArrayList<String>();
    Pattern pattern=Pattern.compile(repository);
    for (    String repositoryUrl : clusterRepositories.keySet()) {
      String repositoryName=clusterRepositories.get(repositoryUrl);
      if (repositoryName != null && !repositoryName.isEmpty()) {
        Matcher nameMatcher=pattern.matcher(repositoryName);
        if (nameMatcher.matches()) {
          urls.add(repositoryUrl);
        }
 else {
          Matcher uriMatcher=pattern.matcher(repositoryUrl);
          if (uriMatcher.matches()) {
            urls.add(repositoryUrl);
          }
        }
      }
 else {
        Matcher uriMatcher=pattern.matcher(repositoryUrl);
        if (uriMatcher.matches()) {
          urls.add(repositoryUrl);
        }
      }
    }
    for (    String url : urls) {
      boolean found=false;
      for (      String repository : clusterRepositories.keySet()) {
        if (this.repository.equals(url)) {
          found=true;
          break;
        }
      }
      if (found) {
        Features repositoryModel=JaxbUtil.unmarshal(url,true);
        clusterRepositories.remove(url);
        for (        Feature feature : repositoryModel.getFeature()) {
          clusterFeatures.remove(feature.getName() + ""String_Node_Str"" + feature.getVersion());
        }
        ClusterRepositoryEvent event=new ClusterRepositoryEvent(url,RepositoryEvent.EventType.RepositoryRemoved);
        event.setUninstall(uninstall);
        event.setSourceGroup(group);
        event.setSourceNode(clusterManager.getNode());
        eventProducer.produce(event);
      }
 else {
        System.err.println(""String_Node_Str"" + url + ""String_Node_Str""+ groupName);
      }
    }
  }
  finally {
    Thread.currentThread().setContextClassLoader(originalClassLoader);
  }
  return null;
}"
18346,"/** 
 * Copy the configuration of a cluster   {@link Group}. <b>1.</b> Updates configuration admin from Hazelcast using source config. <b>2.</b> Creates target configuration both on Hazelcast and configuration admin.
 * @param sourceGroupName the source cluster group.
 * @param targetGroupName the target cluster group.
 */
public void copyGroupConfiguration(String sourceGroupName,String targetGroupName){
  try {
    Configuration conf=configurationAdmin.getConfiguration(Configurations.GROUP,null);
    if (conf != null) {
      Dictionary configAdminProperties=conf.getProperties();
      if (configAdminProperties == null) {
        configAdminProperties=new Properties();
      }
      Map<String,String> sourceGropConfig=instance.getMap(GROUPS_CONFIG);
      for (      Map.Entry<String,String> parentEntry : sourceGropConfig.entrySet()) {
        configAdminProperties.put(parentEntry.getKey(),parentEntry.getValue());
      }
      Dictionary updatedProperties=new Properties();
      Enumeration keyEnumeration=configAdminProperties.keys();
      while (keyEnumeration.hasMoreElements()) {
        String key=(String)keyEnumeration.nextElement();
        String value=(String)configAdminProperties.get(key);
        if (key.startsWith(sourceGroupName)) {
          String newKey=key.replace(sourceGroupName,targetGroupName);
          updatedProperties.put(newKey,value);
          sourceGropConfig.put(key,value);
        }
        updatedProperties.put(key,value);
      }
      conf.update(updatedProperties);
    }
  }
 catch (  IOException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","/** 
 * Copy the configuration of a cluster   {@link Group}. <b>1.</b> Updates configuration admin from Hazelcast using source config. <b>2.</b> Creates target configuration both on Hazelcast and configuration admin.
 * @param sourceGroupName the source cluster group.
 * @param targetGroupName the target cluster group.
 */
public void copyGroupConfiguration(String sourceGroupName,String targetGroupName){
  try {
    Configuration conf=configurationAdmin.getConfiguration(Configurations.GROUP,null);
    if (conf != null) {
      Dictionary configAdminProperties=conf.getProperties();
      if (configAdminProperties == null) {
        configAdminProperties=new Properties();
      }
      Map<String,String> sourceGroupConfig=instance.getMap(GROUPS_CONFIG);
      for (      Map.Entry<String,String> parentEntry : sourceGroupConfig.entrySet()) {
        configAdminProperties.put(parentEntry.getKey(),parentEntry.getValue());
      }
      Dictionary updatedProperties=new Properties();
      Enumeration keyEnumeration=configAdminProperties.keys();
      while (keyEnumeration.hasMoreElements()) {
        String key=(String)keyEnumeration.nextElement();
        String value=configAdminProperties.get(key).toString();
        if (key.startsWith(sourceGroupName)) {
          String newKey=key.replace(sourceGroupName,targetGroupName);
          updatedProperties.put(newKey,value);
          sourceGroupConfig.put(key,value);
        }
        updatedProperties.put(key,value);
      }
      conf.update(updatedProperties);
    }
  }
 catch (  IOException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
18347,"/** 
 * Handle local configuration events. If the event is a pending event stop it. Else broadcast it to the cluster.
 * @param event
 */
public void configurationEvent(ConfigurationEvent event){
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    LOGGER.warn(""String_Node_Str"");
    return;
  }
  String pid=event.getPid();
  Configuration conf=null;
  try {
    conf=configurationAdmin.getConfiguration(pid);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",pid,e);
    return;
  }
  Dictionary localDictionary=conf.getProperties();
  if (localDictionary.get(Constants.SYNC_PROPERTY) != null) {
    Long syncTimestamp=new Long((String)localDictionary.get(Constants.SYNC_PROPERTY));
    Long currentTimestamp=System.currentTimeMillis();
    if ((currentTimestamp - syncTimestamp) <= SYNC_TIMEOUT) {
      return;
    }
  }
  Set<Group> groups=groupManager.listLocalGroups();
  if (groups != null && !groups.isEmpty()) {
    for (    Group group : groups) {
      if (isAllowed(group,Constants.CATEGORY,pid,EventType.OUTBOUND)) {
        Map<String,Properties> configurationTable=clusterManager.getMap(Constants.CONFIGURATION_MAP + Configurations.SEPARATOR + group.getName());
        try {
          if (event.getType() == ConfigurationEvent.CM_DELETED) {
            configurationTable.remove(pid);
          }
 else {
            Properties localProperties=dictionaryToProperties(filter(localDictionary));
            configurationTable.put(pid,localProperties);
            RemoteConfigurationEvent remoteConfigurationEvent=new RemoteConfigurationEvent(pid);
            remoteConfigurationEvent.setSourceGroup(group);
            eventProducer.produce(remoteConfigurationEvent);
          }
        }
 catch (        Exception e) {
          LOGGER.error(""String_Node_Str"",pid,e);
        }
      }
 else       LOGGER.warn(""String_Node_Str"",pid);
    }
  }
}","/** 
 * Handle local configuration events. If the event is a pending event stop it. Else broadcast it to the cluster.
 * @param event
 */
public void configurationEvent(ConfigurationEvent event){
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    LOGGER.warn(""String_Node_Str"");
    return;
  }
  String pid=event.getPid();
  Dictionary localDictionary=null;
  if (event.getType() != ConfigurationEvent.CM_DELETED) {
    Configuration conf=null;
    try {
      conf=configurationAdmin.getConfiguration(pid);
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"",pid,e);
      return;
    }
    localDictionary=conf.getProperties();
    if (localDictionary.get(Constants.SYNC_PROPERTY) != null) {
      Long syncTimestamp=new Long((String)localDictionary.get(Constants.SYNC_PROPERTY));
      Long currentTimestamp=System.currentTimeMillis();
      if ((currentTimestamp - syncTimestamp) <= SYNC_TIMEOUT) {
        return;
      }
    }
  }
  Set<Group> groups=groupManager.listLocalGroups();
  if (groups != null && !groups.isEmpty()) {
    for (    Group group : groups) {
      if (isAllowed(group,Constants.CATEGORY,pid,EventType.OUTBOUND)) {
        Map<String,Properties> configurationTable=clusterManager.getMap(Constants.CONFIGURATION_MAP + Configurations.SEPARATOR + group.getName());
        try {
          if (event.getType() == ConfigurationEvent.CM_DELETED) {
            configurationTable.remove(pid);
          }
 else {
            Properties localProperties=dictionaryToProperties(filter(localDictionary));
            configurationTable.put(pid,localProperties);
            RemoteConfigurationEvent remoteConfigurationEvent=new RemoteConfigurationEvent(pid);
            remoteConfigurationEvent.setSourceGroup(group);
            eventProducer.produce(remoteConfigurationEvent);
          }
        }
 catch (        Exception e) {
          LOGGER.error(""String_Node_Str"",pid,e);
        }
      }
 else       LOGGER.warn(""String_Node_Str"",pid);
    }
  }
}"
18348,"/** 
 * Handle local configuration events. If the event is a pending event stop it. Else broadcast it to the cluster.
 * @param event
 */
public void configurationEvent(ConfigurationEvent event){
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    LOGGER.warn(""String_Node_Str"");
    return;
  }
  String pid=event.getPid();
  Configuration conf=null;
  try {
    conf=configurationAdmin.getConfiguration(pid);
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",pid,e);
    return;
  }
  Dictionary localDictionary=conf.getProperties();
  if (localDictionary.get(Constants.SYNC_PROPERTY) != null) {
    Long syncTimestamp=new Long((String)localDictionary.get(Constants.SYNC_PROPERTY));
    Long currentTimestamp=System.currentTimeMillis();
    if ((currentTimestamp - syncTimestamp) <= SYNC_TIMEOUT) {
      return;
    }
  }
  Set<Group> groups=groupManager.listLocalGroups();
  if (groups != null && !groups.isEmpty()) {
    for (    Group group : groups) {
      if (isAllowed(group,Constants.CATEGORY,pid,EventType.OUTBOUND)) {
        Map<String,Properties> configurationTable=clusterManager.getMap(Constants.CONFIGURATION_MAP + Configurations.SEPARATOR + group.getName());
        try {
          if (event.getType() == ConfigurationEvent.CM_DELETED) {
            configurationTable.remove(pid);
          }
 else {
            Properties localProperties=dictionaryToProperties(filter(localDictionary));
            configurationTable.put(pid,localProperties);
            RemoteConfigurationEvent remoteConfigurationEvent=new RemoteConfigurationEvent(pid);
            remoteConfigurationEvent.setSourceGroup(group);
            eventProducer.produce(remoteConfigurationEvent);
          }
        }
 catch (        Exception e) {
          LOGGER.error(""String_Node_Str"",pid,e);
        }
      }
 else       LOGGER.warn(""String_Node_Str"",pid);
    }
  }
}","/** 
 * Handle local configuration events. If the event is a pending event stop it. Else broadcast it to the cluster.
 * @param event
 */
public void configurationEvent(ConfigurationEvent event){
  if (eventProducer.getSwitch().getStatus().equals(SwitchStatus.OFF)) {
    LOGGER.warn(""String_Node_Str"");
    return;
  }
  String pid=event.getPid();
  Dictionary localDictionary=null;
  if (event.getType() != ConfigurationEvent.CM_DELETED) {
    Configuration conf=null;
    try {
      conf=configurationAdmin.getConfiguration(pid);
    }
 catch (    Exception e) {
      LOGGER.error(""String_Node_Str"",pid,e);
      return;
    }
    localDictionary=conf.getProperties();
    if (localDictionary.get(Constants.SYNC_PROPERTY) != null) {
      Long syncTimestamp=new Long((String)localDictionary.get(Constants.SYNC_PROPERTY));
      Long currentTimestamp=System.currentTimeMillis();
      if ((currentTimestamp - syncTimestamp) <= SYNC_TIMEOUT) {
        return;
      }
    }
  }
  Set<Group> groups=groupManager.listLocalGroups();
  if (groups != null && !groups.isEmpty()) {
    for (    Group group : groups) {
      if (isAllowed(group,Constants.CATEGORY,pid,EventType.OUTBOUND)) {
        Map<String,Properties> configurationTable=clusterManager.getMap(Constants.CONFIGURATION_MAP + Configurations.SEPARATOR + group.getName());
        try {
          if (event.getType() == ConfigurationEvent.CM_DELETED) {
            configurationTable.remove(pid);
          }
 else {
            Properties localProperties=dictionaryToProperties(filter(localDictionary));
            configurationTable.put(pid,localProperties);
            RemoteConfigurationEvent remoteConfigurationEvent=new RemoteConfigurationEvent(pid);
            remoteConfigurationEvent.setSourceGroup(group);
            eventProducer.produce(remoteConfigurationEvent);
          }
        }
 catch (        Exception e) {
          LOGGER.error(""String_Node_Str"",pid,e);
        }
      }
 else       LOGGER.warn(""String_Node_Str"",pid);
    }
  }
}"
18349,"@Override protected Object doExecute() throws Exception {
  Group sourceGroup=groupManager.findGroupByName(sourceGroupName);
  if (sourceGroup == null) {
    System.err.println(""String_Node_Str"" + sourceGroupName + ""String_Node_Str"");
    return null;
  }
  Group targetGroup=groupManager.findGroupByName(targetGroupName);
  if (targetGroup == null) {
    System.err.println(""String_Node_Str"" + targetGroupName + ""String_Node_Str"");
    return null;
  }
  Set<Node> groupMembers=sourceGroup.getNodes();
  int i=0;
  for (  Node node : groupMembers) {
    if (i >= count)     break;
    List<String> recipients=new LinkedList<String>();
    recipients.add(node.getId());
    doExecute(ManageGroupAction.SET,targetGroupName,sourceGroup,recipients);
    i++;
  }
  return doExecute(ManageGroupAction.LIST,null,null,new ArrayList(),false);
}","@Override protected Object doExecute() throws Exception {
  Group sourceGroup=groupManager.findGroupByName(sourceGroupName);
  if (sourceGroup == null) {
    System.err.println(""String_Node_Str"" + sourceGroupName + ""String_Node_Str"");
    return null;
  }
  Group targetGroup=groupManager.findGroupByName(targetGroupName);
  if (targetGroup == null) {
    System.err.println(""String_Node_Str"" + targetGroupName + ""String_Node_Str"");
    return null;
  }
  Set<Node> groupMembers=sourceGroup.getNodes();
  if (count > groupMembers.size())   count=groupMembers.size();
  int i=0;
  for (  Node node : groupMembers) {
    if (i >= count)     break;
    List<String> recipients=new LinkedList<String>();
    recipients.add(node.getId());
    doExecute(ManageGroupAction.SET,targetGroupName,sourceGroup,recipients);
    i++;
  }
  return doExecute(ManageGroupAction.LIST,null,null,new ArrayList(),false);
}"
18350,"@Override protected Object doExecute() throws Exception {
  Group sourceGroup=groupManager.findGroupByName(sourceGroupName);
  if (sourceGroup == null) {
    System.err.println(""String_Node_Str"" + sourceGroupName + ""String_Node_Str"");
    return null;
  }
  Group targetGroup=groupManager.findGroupByName(targetGroupName);
  if (targetGroup == null) {
    System.err.println(""String_Node_Str"" + targetGroupName + ""String_Node_Str"");
    return null;
  }
  Set<Node> groupMembers=sourceGroup.getNodes();
  int i=0;
  for (  Node node : groupMembers) {
    if (i >= count)     break;
    List<String> recipients=new LinkedList<String>();
    recipients.add(node.getId());
    doExecute(ManageGroupAction.SET,targetGroupName,sourceGroup,recipients);
    i++;
  }
  return doExecute(ManageGroupAction.LIST,null,null,new ArrayList(),false);
}","@Override protected Object doExecute() throws Exception {
  Group sourceGroup=groupManager.findGroupByName(sourceGroupName);
  if (sourceGroup == null) {
    System.err.println(""String_Node_Str"" + sourceGroupName + ""String_Node_Str"");
    return null;
  }
  Group targetGroup=groupManager.findGroupByName(targetGroupName);
  if (targetGroup == null) {
    System.err.println(""String_Node_Str"" + targetGroupName + ""String_Node_Str"");
    return null;
  }
  Set<Node> groupMembers=sourceGroup.getNodes();
  if (count > groupMembers.size())   count=groupMembers.size();
  int i=0;
  for (  Node node : groupMembers) {
    if (i >= count)     break;
    List<String> recipients=new LinkedList<String>();
    recipients.add(node.getId());
    doExecute(ManageGroupAction.SET,targetGroupName,sourceGroup,recipients);
    i++;
  }
  return doExecute(ManageGroupAction.LIST,null,null,new ArrayList(),false);
}"
18351,"public void updateMemberList(){
  HazelcastInstance instance=lookupInstance();
  if (instance != null) {
    try {
      instance.getConfig().setGroupConfig(buildGroupConfig());
      instance.getConfig().getNetworkConfig().getJoin().setMulticastConfig(buildMulticastConfig());
      instance.getConfig().getNetworkConfig().getJoin().setTcpIpConfig(buildTcpIpConfig());
      instance.getLifecycleService().restart();
    }
 catch (    Exception ex) {
      LOGGER.error(""String_Node_Str"",ex);
    }
  }
}","public void updateMemberList(){
  HazelcastInstance instance=getInstance();
  if (instance != null) {
    try {
      instance.getConfig().setGroupConfig(buildGroupConfig());
      instance.getConfig().getNetworkConfig().getJoin().setMulticastConfig(buildMulticastConfig());
      instance.getConfig().getNetworkConfig().getJoin().setTcpIpConfig(buildTcpIpConfig());
      instance.getLifecycleService().restart();
    }
 catch (    Exception ex) {
      LOGGER.error(""String_Node_Str"",ex);
    }
  }
}"
18352,"public void init(){
  scheduler.scheduleAtFixedRate(discoveryTask,0,10,TimeUnit.SECONDS);
  if (combinedClassLoader != null) {
    combinedClassLoader.addBundle(bundleContext.getBundle());
  }
}","public void init(){
  if (discoveryTask != null) {
    scheduler.scheduleAtFixedRate(discoveryTask,0,10,TimeUnit.SECONDS);
  }
 else {
    LOGGER.warn(""String_Node_Str"");
  }
  if (combinedClassLoader != null) {
    combinedClassLoader.addBundle(bundleContext.getBundle());
  }
  createInstance();
}"
18353,"/** 
 * Builds a   {@link HazelcastInstance}
 * @return
 */
public HazelcastInstance buildInstance(){
  if (combinedClassLoader != null) {
    Thread.currentThread().setContextClassLoader(combinedClassLoader);
  }
  try {
    semaphore.acquire();
  }
 catch (  InterruptedException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return Hazelcast.newHazelcastInstance(buildConfig());
}","/** 
 * Builds a   {@link HazelcastInstance}
 * @return
 */
private HazelcastInstance buildInstance(){
  if (combinedClassLoader != null) {
    Thread.currentThread().setContextClassLoader(combinedClassLoader);
  }
  return Hazelcast.newHazelcastInstance(buildConfig());
}"
18354,"public void updateMemberList(){
  HazelcastInstance instance=lookupInstance();
  if (instance != null) {
    try {
      instance.getConfig().setGroupConfig(buildGroupConfig());
      instance.getConfig().getNetworkConfig().getJoin().setMulticastConfig(buildMulticastConfig());
      instance.getConfig().getNetworkConfig().getJoin().setTcpIpConfig(buildTcpIpConfig());
      instance.getLifecycleService().restart();
    }
 catch (    Exception ex) {
      LOGGER.error(""String_Node_Str"",ex);
    }
  }
}","public void updateMemberList(){
  HazelcastInstance instance=getInstance();
  if (instance != null) {
    try {
      instance.getConfig().setGroupConfig(buildGroupConfig());
      instance.getConfig().getNetworkConfig().getJoin().setMulticastConfig(buildMulticastConfig());
      instance.getConfig().getNetworkConfig().getJoin().setTcpIpConfig(buildTcpIpConfig());
      instance.getLifecycleService().restart();
    }
 catch (    Exception ex) {
      LOGGER.error(""String_Node_Str"",ex);
    }
  }
}"
18355,"public void init(){
  scheduler.scheduleAtFixedRate(discoveryTask,0,10,TimeUnit.SECONDS);
  if (combinedClassLoader != null) {
    combinedClassLoader.addBundle(bundleContext.getBundle());
  }
}","public void init(){
  if (discoveryTask != null) {
    scheduler.scheduleAtFixedRate(discoveryTask,0,10,TimeUnit.SECONDS);
  }
 else {
    LOGGER.warn(""String_Node_Str"");
  }
  if (combinedClassLoader != null) {
    combinedClassLoader.addBundle(bundleContext.getBundle());
  }
  createInstance();
}"
18356,"/** 
 * Builds a   {@link HazelcastInstance}
 * @return
 */
public HazelcastInstance buildInstance(){
  if (combinedClassLoader != null) {
    Thread.currentThread().setContextClassLoader(combinedClassLoader);
  }
  try {
    semaphore.acquire();
  }
 catch (  InterruptedException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return Hazelcast.newHazelcastInstance(buildConfig());
}","/** 
 * Builds a   {@link HazelcastInstance}
 * @return
 */
private HazelcastInstance buildInstance(){
  if (combinedClassLoader != null) {
    Thread.currentThread().setContextClassLoader(combinedClassLoader);
  }
  return Hazelcast.newHazelcastInstance(buildConfig());
}"
18357,"/** 
 * OSGi container code needs to register these outside of  TransformerRegistryLoader.registerOOTBTransformers() due to the fact that  descriptors cannot be parsed directly from the class path.
 */
private void registerOOTBTransformers() throws Exception {
  Collection<ServiceReference<TransformSource>> refs=_bundleContext.getServiceReferences(TransformSource.class,null);
  for (  final ServiceReference<TransformSource> ref : refs) {
    TransformerRegistryLoader loader=new TransformerRegistryLoader(_domain.getTransformerRegistry()){
      @Override protected Class<?> getClass(      String className){
        Class<?> clazz=null;
        try {
          clazz=ref.getBundle().loadClass(className);
        }
 catch (        ClassNotFoundException ex) {
          logger.warn(""String_Node_Str"" + className + ""String_Node_Str""+ ref.getBundle().getSymbolicName());
        }
        return clazz;
      }
    }
;
    TransformSource trs=_bundleContext.getService(ref);
    InputStream tStream=null;
    try {
      tStream=trs.getTransformsURL().openStream();
      Element tConfig=new ElementPuller().pull(tStream);
      Set<URI> tNamespaces=findNamespaces(new HashSet<URI>(),tConfig);
      NamespaceHandlerSet tHandlers=_extender.getNamespaceHandlerRegistry().getNamespaceHandlers(tNamespaces,getBundle());
      TransformsModel tm=new ModelPuller<TransformsModel>(new OsgiDescriptor(tHandlers)).pull(tConfig);
      loader.registerTransformers(tm);
    }
 catch (    final DuplicateTransformerException e) {
      logger.debug(e.getMessage());
    }
catch (    Exception ex) {
      logger.warn(""String_Node_Str"" + ref.getBundle().getSymbolicName(),ex);
    }
 finally {
      if (tStream != null) {
        tStream.close();
      }
      _bundleContext.ungetService(ref);
    }
  }
}","/** 
 * OSGi container code needs to register these outside of  TransformerRegistryLoader.registerOOTBTransformers() due to the fact that  descriptors cannot be parsed directly from the class path.
 */
private void registerOOTBTransformers() throws Exception {
  Collection<ServiceReference<TransformSource>> refs=_bundleContext.getServiceReferences(TransformSource.class,null);
  for (  final ServiceReference<TransformSource> ref : refs) {
    TransformerRegistryLoader loader=new TransformerRegistryLoader(_domain.getTransformerRegistry()){
      @Override protected Class<?> getClass(      String className){
        Class<?> clazz=null;
        try {
          clazz=ref.getBundle().loadClass(className);
        }
 catch (        ClassNotFoundException ex) {
          logger.warn(""String_Node_Str"" + className + ""String_Node_Str""+ ref.getBundle().getSymbolicName());
        }
        return clazz;
      }
    }
;
    TransformSource trs=_bundleContext.getService(ref);
    InputStream tStream=null;
    try {
      tStream=trs.getTransformsURL().openStream();
      Element tConfig=new ElementPuller().pull(tStream);
      Set<URI> tNamespaces=findNamespaces(new HashSet<URI>(),tConfig);
      NamespaceHandlerSet tHandlers=_extender.getNamespaceHandlerRegistry().getNamespaceHandlers(tNamespaces,getBundle());
      TransformsModel tm=new ModelPuller<TransformsModel>(new OsgiDescriptor(tHandlers)).pull(tConfig);
      loader.registerTransformers(tm,false);
    }
 catch (    final DuplicateTransformerException e) {
      logger.debug(e.getMessage());
    }
catch (    Exception ex) {
      logger.warn(""String_Node_Str"" + ref.getBundle().getSymbolicName(),ex);
    }
 finally {
      if (tStream != null) {
        tStream.close();
      }
      _bundleContext.ungetService(ref);
    }
  }
}"
18358,"/** 
 * {@inheritDoc}
 */
public void stop(){
}","/** 
 * {@inheritDoc}
 */
public void stop(){
  if (_context != null) {
    Registry registry=(Registry)_context.getServletContext().getAttribute(Registry.class.getName());
    if (registry != null) {
      for (      Class<?> clazz : _classes) {
        LOG.debug(""String_Node_Str"" + clazz);
        registry.removeRegistrations(clazz);
      }
      if ((registry.getSize() == 0) && (!_context.getPath().equals(""String_Node_Str""))) {
        try {
          Container container=_context.getParent();
          container.removeChild(_context);
          _context.stop();
          _context.destroy();
          LOG.info(""String_Node_Str"" + _context.getPath());
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"",e);
        }
      }
    }
  }
}"
18359,"/** 
 * {@inheritDoc}
 */
public Resource publish(String context,List<Object> instances) throws Exception {
  Host host=ServerUtil.getDefaultHost().getHost();
  StandardContext serverContext=(StandardContext)host.findChild(""String_Node_Str"" + context);
  if (serverContext == null) {
    serverContext=new StandardContext();
    serverContext.setPath(""String_Node_Str"" + context);
    File docBase=new File(SERVER_TEMP_DIR,context);
    if (!docBase.exists()) {
      docBase.mkdirs();
    }
    serverContext.setDocBase(docBase.getPath());
    serverContext.addLifecycleListener(new ContextConfig());
    final Loader loader=new WebCtxLoader(instances.get(0).getClass().getClassLoader());
    loader.setContainer(host);
    serverContext.setLoader(loader);
    serverContext.setInstanceManager(new LocalInstanceManager());
    Wrapper wrapper=serverContext.createWrapper();
    wrapper.setName(SERVLET_NAME);
    wrapper.setServletClass(SERVLET_CLASS);
    wrapper.setLoadOnStartup(1);
    serverContext.addChild(wrapper);
    serverContext.addServletMapping(""String_Node_Str"",SERVLET_NAME);
    serverContext.addApplicationListener(LISTENER_CLASS);
    host.addChild(serverContext);
    serverContext.create();
    serverContext.start();
  }
  Registry registry=(Registry)serverContext.getServletContext().getAttribute(Registry.class.getName());
  for (  Object instance : instances) {
    LOG.debug(""String_Node_Str"" + instance);
    registry.addSingletonResource(instance);
  }
  return new RESTEasyResource();
}","/** 
 * {@inheritDoc}
 */
public Resource publish(String context,List<Object> instances) throws Exception {
  Host host=ServerUtil.getDefaultHost().getHost();
  StandardContext serverContext=(StandardContext)host.findChild(""String_Node_Str"" + context);
  if (serverContext == null) {
    serverContext=new StandardContext();
    serverContext.setPath(""String_Node_Str"" + context);
    File docBase=new File(SERVER_TEMP_DIR,context);
    if (!docBase.exists()) {
      docBase.mkdirs();
    }
    serverContext.setDocBase(docBase.getPath());
    serverContext.addLifecycleListener(new ContextConfig());
    final Loader loader=new WebCtxLoader(instances.get(0).getClass().getClassLoader());
    loader.setContainer(host);
    serverContext.setLoader(loader);
    serverContext.setInstanceManager(new LocalInstanceManager());
    Wrapper wrapper=serverContext.createWrapper();
    wrapper.setName(SERVLET_NAME);
    wrapper.setServletClass(SERVLET_CLASS);
    wrapper.setLoadOnStartup(1);
    serverContext.addChild(wrapper);
    serverContext.addServletMapping(""String_Node_Str"",SERVLET_NAME);
    serverContext.addApplicationListener(LISTENER_CLASS);
    host.addChild(serverContext);
    serverContext.create();
    serverContext.start();
    LOG.info(""String_Node_Str"" + serverContext.getPath());
  }
  Registry registry=(Registry)serverContext.getServletContext().getAttribute(Registry.class.getName());
  List<Class<?>> classes=new ArrayList<Class<?>>();
  for (  Object instance : instances) {
    LOG.debug(""String_Node_Str"" + instance);
    registry.addSingletonResource(instance);
    classes.add(instance.getClass());
  }
  RESTEasyResource resource=new RESTEasyResource();
  resource.setClasses(classes);
  resource.setContext(serverContext);
  return resource;
}"
18360,"@Override public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();
  if (!SwitchYardDeploymentMarker.isSwitchYardDeployment(deploymentUnit)) {
    return;
  }
  LOG.info(""String_Node_Str"" + deploymentUnit.getName() + ""String_Node_Str"");
  ServiceDomainManager domainManager=(ServiceDomainManager)phaseContext.getServiceRegistry().getRequiredService(SwitchYardServiceDomainManagerService.SERVICE_NAME).getService().getValue();
  SwitchYardMetaData metaData=deploymentUnit.getAttachment(SwitchYardMetaData.ATTACHMENT_KEY);
  SwitchYardDeployment deployment=new SwitchYardDeployment(deploymentUnit,metaData.geSwitchYardModel(),domainManager);
  SwitchYardService container=new SwitchYardService(deployment);
  final ServiceTarget serviceTarget=phaseContext.getServiceTarget();
  final ServiceName switchyardServiceName=deploymentUnit.getServiceName().append(SwitchYardService.SERVICE_NAME);
  final ServiceBuilder<SwitchYardDeployment> switchyardServiceBuilder=serviceTarget.addService(switchyardServiceName,container);
  switchyardServiceBuilder.addDependency(SwitchYardComponentService.SERVICE_NAME,List.class,container.getComponents());
  switchyardServiceBuilder.addDependency(JndiNamingDependencyProcessor.serviceName(deploymentUnit));
  final EEModuleDescription moduleDescription=deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);
  if (moduleDescription != null) {
    container.getNamespaceSelector().setValue(new ImmediateValue<NamespaceContextSelector>(moduleDescription.getNamespaceContextSelector()));
  }
  if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
    final ServiceName beanManagerServiceName=deploymentUnit.getServiceName().append(BeanManagerService.NAME);
    switchyardServiceBuilder.addDependency(beanManagerServiceName);
  }
  switchyardServiceBuilder.setInitialMode(Mode.ACTIVE);
  switchyardServiceBuilder.install();
}","@Override public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
  final DeploymentUnit deploymentUnit=phaseContext.getDeploymentUnit();
  if (!SwitchYardDeploymentMarker.isSwitchYardDeployment(deploymentUnit)) {
    return;
  }
  LOG.info(""String_Node_Str"" + deploymentUnit.getName() + ""String_Node_Str"");
  ServiceDomainManager domainManager=(ServiceDomainManager)phaseContext.getServiceRegistry().getRequiredService(SwitchYardServiceDomainManagerService.SERVICE_NAME).getService().getValue();
  SwitchYardMetaData metaData=deploymentUnit.getAttachment(SwitchYardMetaData.ATTACHMENT_KEY);
  SwitchYardDeployment deployment=new SwitchYardDeployment(deploymentUnit,metaData.geSwitchYardModel(),domainManager);
  SwitchYardService container=new SwitchYardService(deployment);
  final ServiceTarget serviceTarget=phaseContext.getServiceTarget();
  final ServiceName switchyardServiceName=deploymentUnit.getServiceName().append(SwitchYardService.SERVICE_NAME);
  final ServiceBuilder<SwitchYardDeployment> switchyardServiceBuilder=serviceTarget.addService(switchyardServiceName,container);
  switchyardServiceBuilder.addDependency(SwitchYardComponentService.SERVICE_NAME,List.class,container.getComponents());
  switchyardServiceBuilder.addDependency(JndiNamingDependencyProcessor.serviceName(deploymentUnit));
  final EEModuleDescription moduleDescription=deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);
  if (moduleDescription != null) {
    container.getNamespaceSelector().setValue(new ImmediateValue<NamespaceContextSelector>(moduleDescription.getNamespaceContextSelector()));
  }
  if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
    final ServiceName beanManagerServiceName=deploymentUnit.getServiceName().append(BeanManagerService.NAME);
    switchyardServiceBuilder.addDependency(beanManagerServiceName);
  }
  switchyardServiceBuilder.setInitialMode(Mode.ACTIVE);
synchronized (this) {
    switchyardServiceBuilder.install();
    if (WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException ex) {
        ex.getMessage();
      }
    }
  }
}"
18361,"/** 
 * Mark the top level deployment as being a SwitchYard deployment. If the deployment is not a top level deployment the parent is marked instead
 * @param unit the deployment unit.
 */
public static void mark(DeploymentUnit unit){
  if (unit.getParent() == null) {
    unit.putAttachment(MARKER,Boolean.TRUE);
  }
 else {
    unit.getParent().putAttachment(MARKER,Boolean.TRUE);
  }
}","/** 
 * Mark the top level deployment as being a SwitchYard deployment. If the deployment is not a top level deployment the parent is marked instead
 * @param unit the deployment unit.
 */
public static void mark(DeploymentUnit unit){
  unit.putAttachment(MARKER,Boolean.TRUE);
}"
18362,"private void flushInputDocuments(boolean force) throws SolrServerException, IOException {
  if (force || (_inputDocs.size() >= MAX_DOCS_PER_ADD)) {
    Thread reporterThread=new Thread(){
      @Override public void run(){
        while (!isInterrupted()) {
          _progress.progress();
          try {
            sleep(10 * 1000);
          }
 catch (          InterruptedException e) {
            interrupt();
          }
        }
      }
    }
;
    reporterThread.start();
    try {
      _solrServer.add(_inputDocs);
      if (force) {
        _solrServer.commit(true,true);
        _solrServer.optimize(true,true,_maxSegments);
      }
    }
 catch (    SolrServerException e) {
      throw new IOException(e);
    }
 finally {
      _inputDocs.clear();
      reporterThread.interrupt();
    }
  }
}","private void flushInputDocuments(boolean force) throws SolrServerException, IOException {
  if (force || (_inputDocs.size() >= MAX_DOCS_PER_ADD)) {
    Thread reporterThread=startProgressThread();
    try {
      _solrServer.add(_inputDocs);
      if (force) {
        _solrServer.commit(true,true);
        _solrServer.optimize(true,true,_maxSegments);
      }
    }
 catch (    SolrServerException e) {
      throw new IOException(e);
    }
 finally {
      _inputDocs.clear();
      reporterThread.interrupt();
    }
  }
}"
18363,"@Override public void close(final Reporter reporter) throws IOException {
  try {
    flushInputDocuments(true);
    _coreContainer.shutdown();
    _solrServer=null;
    File indexDir=new File(_localIndexDir,""String_Node_Str"");
    LOGGER.info(String.format(""String_Node_Str"",_localIndexDir,_outputPath));
    removeCrcFiles(indexDir);
    _outputFS.copyFromLocalFile(true,new Path(indexDir.getAbsolutePath()),_outputPath);
  }
 catch (  SolrServerException e) {
    throw new IOException(e);
  }
}","@Override public void close(final Reporter reporter) throws IOException {
  try {
    flushInputDocuments(true);
    _coreContainer.shutdown();
    _solrServer=null;
  }
 catch (  SolrServerException e) {
    throw new IOException(e);
  }
  copyToHDFS();
}"
18364,"/** 
 * Set the original feature of FSTTerminals, because the tree is composed and this information would be lost.
 */
private void setOriginalFeatureName(FSTNonTerminal node,String feature){
  if (node.getType().equals(""String_Node_Str"")) {
    feature=node.getName();
  }
  for (  FSTNode child : node.getChildren()) {
    if (child instanceof FSTNonTerminal) {
      setOriginalFeatureName((FSTNonTerminal)child,feature);
    }
 else     if (child instanceof FSTTerminal) {
      ((FSTTerminal)child).setOriginalFeatureName(feature);
    }
  }
}","/** 
 * Set the original feature of FSTTerminals, because the tree is composed and this information would be lost.
 */
protected void setOriginalFeatureName(FSTNonTerminal node,String feature){
  if (node.getType().equals(""String_Node_Str"")) {
    feature=node.getName();
  }
  for (  FSTNode child : node.getChildren()) {
    if (child instanceof FSTNonTerminal) {
      setOriginalFeatureName((FSTNonTerminal)child,feature);
    }
 else     if (child instanceof FSTTerminal) {
      ((FSTTerminal)child).setOriginalFeatureName(feature);
    }
  }
}"
18365,"private FSTNode composeMeta(List<FSTNonTerminal> tl){
  FSTNode composed=null;
  for (  FSTNode current : tl) {
    if (metaproduct) {
      preProcessSubtree(current);
    }
    if (composed != null) {
      composed=compose(current,composed);
    }
 else     composed=current;
  }
  if (metaproduct) {
    postProcess(composed);
  }
  return composed;
}","private FSTNode composeMeta(List<FSTNonTerminal> tl){
  FSTNode composed=null;
  for (  FSTNode current : tl) {
    if (metaproduct) {
      preProcessSubtree(current);
    }
    setOriginalFeatureName((FSTNonTerminal)current,""String_Node_Str"");
    if (composed != null) {
      composed=compose(current,composed);
    }
 else     composed=current;
  }
  if (metaproduct) {
    postProcess(composed);
  }
  return composed;
}"
18366,"private static void specializeModifiers(FSTTerminal terminalA,FSTTerminal terminalB){
  if (terminalA.getBody().contains(""String_Node_Str"") || terminalB.getBody().contains(""String_Node_Str""))   return;
  StringTokenizer stA=new StringTokenizer(terminalA.getBody(),""String_Node_Str"");
  StringTokenizer stB=new StringTokenizer(terminalB.getBody(),""String_Node_Str"");
  if (stA.hasMoreTokens() && stB.hasMoreTokens()) {
    stA=new StringTokenizer(stA.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetA=new LinkedHashSet<String>();
    while (stA.hasMoreTokens()) {
      modifierSetA.add(stA.nextToken());
    }
    stB=new StringTokenizer(stB.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetB=new LinkedHashSet<String>();
    while (stB.hasMoreTokens()) {
      modifierSetB.add(stB.nextToken());
    }
    String[] modifierArrayA=new String[modifierSetA.size()];
    modifierSetA.toArray(modifierArrayA);
    String[] modifierArrayB=new String[modifierSetB.size()];
    modifierSetB.toArray(modifierArrayB);
    if (modifierArrayA.length <= 1 || modifierArrayB.length <= 1)     return;
    if (!modifierArrayA[modifierArrayA.length - 2].equals(modifierArrayB[modifierArrayB.length - 2])) {
      System.err.println(""String_Node_Str"" + modifierArrayA[modifierArrayA.length - 1] + ""String_Node_Str""+ modifierArrayA[modifierArrayA.length - 2]+ ""String_Node_Str""+ modifierArrayB[modifierArrayB.length - 2]);
    }
    String removedDuplicates=new String();
    String[] modifierArrayRes=new String[modifierArrayA.length + modifierArrayB.length - 2];
    System.arraycopy(modifierArrayB,0,modifierArrayRes,0,modifierArrayB.length - 2);
    System.arraycopy(modifierArrayA,0,modifierArrayRes,modifierArrayB.length - 2,modifierArrayA.length);
    boolean isPublic=false;
    boolean isProtected=false;
    boolean isPrivate=false;
    boolean isAbstract=false;
    boolean isFinal=false;
    LinkedList<String> otherModifiers=new LinkedList<String>();
    for (int i=0; i < modifierArrayRes.length; i++) {
      String modifier=modifierArrayRes[i].trim();
      if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected&& !isPrivate) {
        isPrivate=true;
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected) {
        isProtected=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic) {
        isPublic=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
        if (modifier.equals(""String_Node_Str"")) {
          isAbstract=true;
          removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
          removedDuplicates+=modifier + ""String_Node_Str"";
        }
 else         if (modifier.equals(""String_Node_Str"") && !isAbstract && !isFinal) {
          removedDuplicates+=modifier + ""String_Node_Str"";
          isFinal=true;
        }
 else         if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
          boolean in=false;
          for (          String otherModifier : otherModifiers) {
            if (otherModifier.equals(modifier))             in=true;
          }
          if (!in) {
            removedDuplicates+=modifier + ""String_Node_Str"";
            otherModifiers.add(modifier);
          }
        }
      }
    }
    if (terminalA.getBody().contains(""String_Node_Str""))     terminalA.setBody(removedDuplicates + ""String_Node_Str"" + terminalA.getBody().substring(terminalA.getBody().indexOf(""String_Node_Str"")));
    if (terminalB.getBody().contains(""String_Node_Str""))     terminalB.setBody(removedDuplicates + ""String_Node_Str"" + terminalB.getBody().substring(terminalB.getBody().indexOf(""String_Node_Str"")));
  }
}","private static void specializeModifiers(FSTTerminal terminalA,FSTTerminal terminalB){
  if (terminalA.getBody().contains(""String_Node_Str"") || terminalB.getBody().contains(""String_Node_Str""))   return;
  StringTokenizer stA=new StringTokenizer(terminalA.getBody(),""String_Node_Str"");
  StringTokenizer stB=new StringTokenizer(terminalB.getBody(),""String_Node_Str"");
  if (stA.hasMoreTokens() && stB.hasMoreTokens()) {
    stA=new StringTokenizer(stA.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetA=new LinkedHashSet<String>();
    while (stA.hasMoreTokens()) {
      modifierSetA.add(stA.nextToken());
    }
    stB=new StringTokenizer(stB.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetB=new LinkedHashSet<String>();
    while (stB.hasMoreTokens()) {
      modifierSetB.add(stB.nextToken());
    }
    String[] modifierArrayA=new String[modifierSetA.size()];
    modifierSetA.toArray(modifierArrayA);
    String[] modifierArrayB=new String[modifierSetB.size()];
    modifierSetB.toArray(modifierArrayB);
    if (modifierArrayA.length <= 1 || modifierArrayB.length <= 1)     return;
    if (!modifierArrayA[modifierArrayA.length - 2].equals(modifierArrayB[modifierArrayB.length - 2])) {
      System.err.println(""String_Node_Str"" + modifierArrayA[modifierArrayA.length - 1] + ""String_Node_Str""+ modifierArrayA[modifierArrayA.length - 2]+ ""String_Node_Str""+ modifierArrayB[modifierArrayB.length - 2]);
    }
    String removedDuplicates=new String();
    String[] modifierArrayRes=new String[modifierArrayA.length + modifierArrayB.length - 2];
    System.arraycopy(modifierArrayB,0,modifierArrayRes,0,modifierArrayB.length - 2);
    System.arraycopy(modifierArrayA,0,modifierArrayRes,modifierArrayB.length - 2,modifierArrayA.length);
    boolean isPublic=false;
    boolean isProtected=false;
    boolean isPrivate=false;
    boolean isAbstract=false;
    boolean isFinal=false;
    LinkedList<String> otherModifiers=new LinkedList<String>();
    for (int i=0; i < modifierArrayRes.length; i++) {
      String modifier=modifierArrayRes[i].trim();
      if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected&& !isPrivate) {
        isPrivate=true;
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected) {
        isProtected=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic) {
        isPublic=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
        if (modifier.equals(""String_Node_Str"") && !isAbstract) {
          isAbstract=true;
          removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
          removedDuplicates+=modifier + ""String_Node_Str"";
        }
 else         if (modifier.equals(""String_Node_Str"") && !isAbstract && !isFinal) {
          removedDuplicates+=modifier + ""String_Node_Str"";
          isFinal=true;
        }
 else         if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
          boolean in=false;
          for (          String otherModifier : otherModifiers) {
            if (otherModifier.equals(modifier))             in=true;
          }
          if (!in) {
            removedDuplicates+=modifier + ""String_Node_Str"";
            otherModifiers.add(modifier);
          }
        }
      }
    }
    if (terminalA.getBody().contains(""String_Node_Str""))     terminalA.setBody(removedDuplicates + ""String_Node_Str"" + terminalA.getBody().substring(terminalA.getBody().indexOf(""String_Node_Str"")));
    if (terminalB.getBody().contains(""String_Node_Str""))     terminalB.setBody(removedDuplicates + ""String_Node_Str"" + terminalB.getBody().substring(terminalB.getBody().indexOf(""String_Node_Str"")));
  }
}"
18367,"@Test public void testDefaultComposition(){
}","@Test public void testDefaultComposition(){
  try {
    String expression=""String_Node_Str"";
    String outputDir=""String_Node_Str"";
    compose(expression,outputDir,null,null);
    assertEquals(""String_Node_Str"",Checksum.calculateChecksum(new File(outputDir)));
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable t) {
    System.err.println(t.getMessage());
    t.printStackTrace();
    throw t;
  }
}"
18368,"@Test public void testAbstractKeywordComposition() throws IOException {
}","@Test public void testAbstractKeywordComposition() throws IOException {
  try {
    List<Feature> features=new ArrayList<Feature>();
    Feature a=new Feature(""String_Node_Str"");
    features.add(a);
    a.addFile(""String_Node_Str"",""String_Node_Str"");
    Feature b=new Feature(""String_Node_Str"");
    features.add(b);
    a.addFile(""String_Node_Str"",""String_Node_Str"");
    File mainDir=setupProductLineFeatures(features);
    File outputDir=new File(mainDir,""String_Node_Str"");
    compose(new File(mainDir,""String_Node_Str"").getAbsolutePath(),outputDir.getAbsolutePath(),new File(mainDir,""String_Node_Str"").getAbsolutePath(),null);
    assertEquals(""String_Node_Str"" + mainDir.getAbsolutePath(),""String_Node_Str"",Checksum.calculateChecksum(outputDir));
    deleteDirWithContents(mainDir);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable t) {
    System.err.println(t.getMessage());
    t.printStackTrace();
    throw t;
  }
}"
18369,"public void process(){
  headerContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  for (  String feature : meta.getFeatures()) {
    headerContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  cFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  cFileContents+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  for (  String feature : meta.getFeatures()) {
    cFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  cFileContents+=""String_Node_Str"";
  processRestrictions();
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
}","public void process(){
  headerContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Set<String> featureSet=new HashSet<String>(meta.getFeatures());
  for (  String feature : featureSet) {
    headerContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  cFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  cFileContents+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  for (  String feature : featureSet) {
    cFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  cFileContents+=""String_Node_Str"";
  processRestrictions();
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
  headerContents+=""String_Node_Str"";
}"
18370,"public void process(){
  javaFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  HashSet<String> processedFeatures=new HashSet<String>();
  for (  String feature : meta.getFeatures()) {
    if (!processedFeatures.contains(feature)) {
      processedFeatures.add(feature);
      if (addJPF_BDD_Annotation)       javaFileContents+=""String_Node_Str"";
      javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
    }
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str""+ feature+ ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  javaFileContents+=""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"";
  processRestrictions();
  javaFileContents+=""String_Node_Str"";
}","public void process(){
  javaFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  HashSet<String> processedFeatures=new HashSet<String>();
  Set<String> featureSet=new HashSet<String>(meta.getFeatures());
  for (  String feature : featureSet) {
    if (!processedFeatures.contains(feature)) {
      processedFeatures.add(feature);
      if (addJPF_BDD_Annotation)       javaFileContents+=""String_Node_Str"";
      javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
    }
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str""+ feature+ ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  javaFileContents+=""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"";
  processRestrictions();
  javaFileContents+=""String_Node_Str"";
}"
18371,"public void process(){
  javaFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  HashSet<String> processedFeatures=new HashSet<String>();
  Set<String> featureSet=new HashSet<String>(meta.getFeatures());
  for (  String feature : featureSet) {
    if (!processedFeatures.contains(feature)) {
      processedFeatures.add(feature);
      if (addJPF_BDD_Annotation)       javaFileContents+=""String_Node_Str"";
      javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
    }
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str""+ feature+ ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  javaFileContents+=""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"";
  processRestrictions();
  javaFileContents+=""String_Node_Str"";
}","public void process(){
  javaFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  List<String> features=meta.getFeatures();
  for (  String feature : features) {
    if (addJPF_BDD_Annotation)     javaFileContents+=""String_Node_Str"";
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  for (  String feature : features) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str""+ feature+ ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  javaFileContents+=""String_Node_Str"";
  for (  String feature : features) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"";
  processRestrictions();
  javaFileContents+=""String_Node_Str"";
}"
18372,"public List<String> getFeatures(){
  return new ArrayList<String>(features);
}","/** 
 * Returns a list of all feature names of the subject system.  Each name occurs only once in the list. We chose a List instead of a Set because the order of the features is important (same order as in the expression file).
 */
public List<String> getFeatures(){
  return new ArrayList<String>(features);
}"
18373,"public void addFeature(String feature){
  features.add(feature);
}","public void addFeature(String feature){
  if (!features.contains(feature))   features.add(feature);
}"
18374,"private void build(String[] args,String[] featuresArg,boolean compose){
  meta.clearFeatures();
  cmd.parseCmdLineArguments(args);
  compositionRules=new ArrayList<CompositionRule>();
  if (cmd.lifting) {
    if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new CRuntimeReplacement());
      compositionRules.add(new CRuntimeFunctionRefinement());
      subtreeRewriterC=new CRuntimeSubtreeIntegration();
    }
 else     if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new JavaRuntimeReplacement());
      compositionRules.add(new JavaRuntimeFunctionRefinement());
      subtreeRewriterJava=new JavaRuntimeSubtreeIntegration();
    }
 else {
      throw new InternalError(""String_Node_Str"" + cmd.lifting_language + ""String_Node_Str"");
    }
  }
 else {
    compositionRules.add(new Replacement());
    compositionRules.add(new JavaMethodOverridingMeta());
  }
  compositionRules.add(new InvariantCompositionMeta());
  compositionRules.add(new ContractCompositionMeta(cmd.contract_style,modelInfo));
  compositionRules.add(new StringConcatenation());
  compositionRules.add(new ImplementsListMerging());
  compositionRules.add(new CSharpMethodOverriding());
  compositionRules.add(new ConstructorConcatenationMeta());
  compositionRules.add(new ModifierListSpecialization());
  compositionRules.add(new FieldOverridingMeta());
  compositionRules.add(new ExpansionOverriding());
  compositionRules.add(new CompositionError());
  try {
    try {
      fileLoader.loadFiles(cmd.equationFileName,cmd.equationBaseDirectoryName,cmd.isAheadEquationFile,featuresArg);
    }
 catch (    cide.gparser.ParseException e1) {
      System.out.println(""String_Node_Str"");
      fireParseErrorOccured(e1);
      e1.printStackTrace();
    }
    String outputDir=cmd.equationBaseDirectoryName;
    if (cmd.outputDirectoryName != null)     outputDir=cmd.outputDirectoryName;
    if (outputDir.endsWith(File.separator))     outputDir=outputDir.substring(0,outputDir.length() - 1);
    featureVisitor.setWorkingDir(outputDir);
    featureVisitor.setExpressionName(cmd.equationFileName);
    for (    ArtifactBuilderInterface builder : getArtifactBuilders()) {
      LinkedList<FSTNonTerminal> features=builder.getFeatures();
      if (cmd.isCount && (builder instanceof JavaBuilder || builder instanceof CApproxBuilder)) {
        Counter counter=new Counter();
        for (        FSTNonTerminal feature : features) {
          counter.collect(feature);
        }
        if (features.size() > 0)         counter.writeFile(new File(cmd.equationFileName + ""String_Node_Str""));
      }
      for (      FSTNonTerminal feature : features) {
        meta.addFeature(feature.getName());
      }
      if (compose) {
        FSTNode composition=composeMeta(features);
        try {
          featureVisitor.visit((FSTNonTerminal)composition);
        }
 catch (        PrintVisitorException e) {
          e.printStackTrace();
        }
      }
    }
    setFstnodes(AbstractFSTParser.fstnodes);
    if (!compose) {
      return;
    }
    try {
      String exp=new File(cmd.equationFileName).getName();
      exp=exp.substring(0,exp.length() - 4);
      meta.saveToFile(outputDir + File.separator + ""String_Node_Str"");
      if (cmd.lifting) {
        File cnfFile=new File(cmd.equationBaseDirectoryName,""String_Node_Str"");
        System.err.println(""String_Node_Str"" + cnfFile.getAbsolutePath());
        if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new CRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator + ""String_Node_Str"");
        }
 else         if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new JavaRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator + cmd.equationFileName+ File.separator);
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 catch (  FileNotFoundException e1) {
  }
}","private void build(String[] args,String[] featuresArg,boolean compose){
  meta.clearFeatures();
  cmd.parseCmdLineArguments(args);
  compositionRules=new ArrayList<CompositionRule>();
  if (cmd.lifting) {
    if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new CRuntimeReplacement());
      compositionRules.add(new CRuntimeFunctionRefinement());
      subtreeRewriterC=new CRuntimeSubtreeIntegration();
    }
 else     if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new JavaRuntimeReplacement());
      compositionRules.add(new JavaRuntimeFunctionRefinement());
      subtreeRewriterJava=new JavaRuntimeSubtreeIntegration();
    }
 else {
      throw new InternalError(""String_Node_Str"" + cmd.lifting_language + ""String_Node_Str"");
    }
  }
 else {
    compositionRules.add(new Replacement());
    compositionRules.add(new JavaMethodOverridingMeta());
  }
  compositionRules.add(new InvariantCompositionMeta());
  compositionRules.add(new ContractCompositionMeta(cmd.contract_style,modelInfo));
  compositionRules.add(new StringConcatenation());
  compositionRules.add(new ImplementsListMerging());
  compositionRules.add(new CSharpMethodOverriding());
  compositionRules.add(new ConstructorConcatenationMeta());
  compositionRules.add(new ModifierListSpecialization());
  compositionRules.add(new FieldOverridingMeta());
  compositionRules.add(new ExpansionOverriding());
  compositionRules.add(new CompositionError());
  try {
    try {
      fileLoader.loadFiles(cmd.equationFileName,cmd.equationBaseDirectoryName,cmd.isAheadEquationFile,featuresArg);
    }
 catch (    cide.gparser.ParseException e1) {
      System.out.println(""String_Node_Str"");
      fireParseErrorOccured(e1);
      e1.printStackTrace();
    }
    String outputDir=cmd.equationBaseDirectoryName;
    if (cmd.outputDirectoryName != null)     outputDir=cmd.outputDirectoryName;
    if (outputDir.endsWith(File.separator))     outputDir=outputDir.substring(0,outputDir.length() - 1);
    featureVisitor.setWorkingDir(outputDir);
    featureVisitor.setExpressionName(cmd.equationFileName);
    for (    ArtifactBuilderInterface builder : getArtifactBuilders()) {
      LinkedList<FSTNonTerminal> features=builder.getFeatures();
      if (cmd.isCount && (builder instanceof JavaBuilder || builder instanceof CApproxBuilder)) {
        Counter counter=new Counter();
        for (        FSTNonTerminal feature : features) {
          counter.collect(feature);
        }
        if (features.size() > 0)         counter.writeFile(new File(cmd.equationFileName + ""String_Node_Str""));
      }
      for (      FSTNonTerminal feature : features) {
        meta.addFeature(feature.getName());
      }
      modelInfo.clearFeatureNodes();
      if (features.size() > 0)       modelInfo.addFeatureNodes(features);
      if (compose) {
        FSTNode composition=composeMeta(features);
        try {
          featureVisitor.visit((FSTNonTerminal)composition);
        }
 catch (        PrintVisitorException e) {
          e.printStackTrace();
        }
      }
    }
    setFstnodes(AbstractFSTParser.fstnodes);
    if (!compose) {
      return;
    }
    try {
      String exp=new File(cmd.equationFileName).getName();
      exp=exp.substring(0,exp.length() - 4);
      meta.saveToFile(outputDir + File.separator + ""String_Node_Str"");
      if (cmd.lifting) {
        File cnfFile=new File(cmd.equationBaseDirectoryName,""String_Node_Str"");
        System.err.println(""String_Node_Str"" + cnfFile.getAbsolutePath());
        if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new CRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator + ""String_Node_Str"");
        }
 else         if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new JavaRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator + cmd.equationFileName+ File.separator);
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 catch (  FileNotFoundException e1) {
  }
}"
18375,"protected String getOriginalReplacement(String[] baseCases,int caseId,String prefix){
  StringBuffer result=new StringBuffer();
  if (caseId >= baseCases.length)   throw new RuntimeException(""String_Node_Str"" + caseId);
  String[] prefixes=new String[baseCases.length];
  for (int i=0; i < baseCases.length; i++) {
    prefixes[i]=prefixes[i] + ""String_Node_Str"";
    String baseCase=baseCases[i].replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
    if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=""String_Node_Str"";
      baseCase=baseCase.substring(7);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=""String_Node_Str"";
      baseCase=baseCase.substring(8);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=""String_Node_Str"";
      baseCase=baseCase.substring(10);
    }
    if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=prefixes[i] + ""String_Node_Str"";
      baseCase=baseCase.substring(9);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=prefixes[i] + ""String_Node_Str"";
      baseCase=baseCase.substring(16);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=prefixes[i] + ""String_Node_Str"";
      baseCase=baseCase.substring(21);
    }
    baseCases[caseId]=baseCase;
  }
  System.out.println(""String_Node_Str"" + baseCases[caseId]);
  Pattern p=Pattern.compile(""String_Node_Str"",Pattern.DOTALL);
  Matcher m=p.matcher(baseCases[caseId]);
  while (m.find()) {
    for (int i=2; i <= m.groupCount(); i++) {
      StringBuilder sb=new StringBuilder(baseCases[caseId]);
      sb.setCharAt(m.start(i),'�');
      baseCases[caseId]=sb.toString();
    }
    System.out.println(""String_Node_Str"" + baseCases[caseId]);
  }
  String[] clausesA=baseCases[caseId].trim().split(""String_Node_Str"");
  boolean append=false;
  for (int i=0; i < clausesA.length; i++) {
    if (clausesA[i].trim().startsWith(prefix + ""String_Node_Str"")) {
      result.append(""String_Node_Str"" + clausesA[i].trim().replaceFirst(prefix,""String_Node_Str"") + ""String_Node_Str"");
      result.append(""String_Node_Str"");
      append=true;
    }
  }
  if (append)   result.setLength(result.length() - 4);
  return result.toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
}","protected String getOriginalReplacement(String[] baseCases,int caseId,String prefix){
  StringBuffer result=new StringBuffer();
  if (caseId >= baseCases.length)   throw new RuntimeException(""String_Node_Str"" + caseId);
  String[] prefixes=new String[baseCases.length];
  for (int i=0; i < baseCases.length; i++) {
    prefixes[i]=prefixes[i] + ""String_Node_Str"";
    String baseCase=baseCases[i].replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
    if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=""String_Node_Str"";
      baseCase=baseCase.substring(7);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=""String_Node_Str"";
      baseCase=baseCase.substring(8);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=""String_Node_Str"";
      baseCase=baseCase.substring(10);
    }
    if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=prefixes[i] + ""String_Node_Str"";
      baseCase=baseCase.substring(9);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=prefixes[i] + ""String_Node_Str"";
      baseCase=baseCase.substring(16);
    }
 else     if (baseCase.startsWith(""String_Node_Str"")) {
      prefixes[i]=prefixes[i] + ""String_Node_Str"";
      baseCase=baseCase.substring(21);
    }
    baseCases[caseId]=baseCase;
  }
  System.out.println(""String_Node_Str"" + baseCases[caseId]);
  Pattern p=Pattern.compile(""String_Node_Str"",Pattern.DOTALL);
  Matcher m=p.matcher(baseCases[caseId]);
  while (m.find()) {
    for (int i=2; i <= m.groupCount(); i++) {
      StringBuilder sb=new StringBuilder(baseCases[caseId]);
      sb.setCharAt(m.start(i),'�');
      baseCases[caseId]=sb.toString();
    }
    m=p.matcher(baseCases[caseId]);
    System.out.println(""String_Node_Str"" + baseCases[caseId]);
  }
  String[] clausesA=baseCases[caseId].trim().split(""String_Node_Str"");
  boolean append=false;
  for (int i=0; i < clausesA.length; i++) {
    if (clausesA[i].trim().startsWith(prefix + ""String_Node_Str"")) {
      result.append(""String_Node_Str"" + clausesA[i].trim().replaceFirst(prefix,""String_Node_Str"") + ""String_Node_Str"");
      result.append(""String_Node_Str"");
      append=true;
    }
  }
  if (append)   result.setLength(result.length() - 4);
  return result.toString().replaceAll(""String_Node_Str"",""String_Node_Str"");
}"
18376,"@Override public void compose(FSTTerminal terminalA,FSTTerminal terminalB,FSTTerminal terminalComp,FSTNonTerminal nonterminalParent){
  FSTTerminal terminalComp2=(FSTTerminal)terminalB.getDeepClone();
  FSTTerminal terminalComp3=(FSTTerminal)terminalB.getDeepClone();
  nonterminalParent.addChild(terminalComp2);
  nonterminalParent.addChild(terminalComp3);
  Signature sigB=Signature.fromString(terminalB.getBody());
  String toReplace=""String_Node_Str"";
  String featureName=getFeatureName(terminalA);
  String beforeFunctionName=sigB.name + ""String_Node_Str"" + featureName;
  String roleFunctionName=sigB.name + ""String_Node_Str"" + featureName;
  String newBody=terminalComp.getBody().replaceAll(toReplace,beforeFunctionName + ""String_Node_Str"");
  newBody=replaceFunctionName(roleFunctionName,sigB.name,newBody);
  terminalComp3.setBody(newBody);
  terminalComp3.setName(roleFunctionName);
  String newBody2=replaceFunctionName(beforeFunctionName,sigB.name,terminalComp2.getBody());
  terminalComp2.setBody(newBody2);
  terminalComp2.setName(beforeFunctionName);
  System.out.println(terminalA.getName());
  String switchIdentifier=""String_Node_Str"" + featureName;
  String newBody3=sigB.toString() + ""String_Node_Str"" + ""String_Node_Str""+ switchIdentifier+ ""String_Node_Str""+ ""String_Node_Str""+ roleFunctionName+ sigB.arglist+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ beforeFunctionName+ sigB.arglist+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  terminalComp.setBody(newBody3);
}","@Override public void compose(FSTTerminal terminalA,FSTTerminal terminalB,FSTTerminal terminalComp,FSTNonTerminal nonterminalParent){
  FSTTerminal terminalComp2=(FSTTerminal)terminalB.getDeepClone();
  FSTTerminal terminalComp3=(FSTTerminal)terminalB.getDeepClone();
  nonterminalParent.addChild(terminalComp2);
  nonterminalParent.addChild(terminalComp3);
  Signature sigB=Signature.fromString(terminalB.getBody());
  String toReplace=""String_Node_Str"";
  String featureName=getFeatureName(terminalA);
  String beforeFunctionName=sigB.name + ""String_Node_Str"" + featureName;
  String roleFunctionName=sigB.name + ""String_Node_Str"" + featureName;
  String newBody=terminalComp.getBody().replaceAll(toReplace,beforeFunctionName + ""String_Node_Str"");
  newBody=replaceFunctionName(roleFunctionName,sigB.name,newBody);
  terminalComp3.setBody(newBody);
  terminalComp3.setName(roleFunctionName);
  String newBody2=replaceFunctionName(beforeFunctionName,sigB.name,terminalComp2.getBody());
  terminalComp2.setBody(newBody2);
  terminalComp2.setName(beforeFunctionName);
  System.out.println(terminalA.getName());
  String switchIdentifier=""String_Node_Str"" + featureName;
  String newBody3=""String_Node_Str"";
  if (sigB.returnType.trim().equals(""String_Node_Str"")) {
    newBody3=sigB.toString() + ""String_Node_Str"" + ""String_Node_Str""+ switchIdentifier+ ""String_Node_Str""+ ""String_Node_Str""+ roleFunctionName+ sigB.arglist+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ beforeFunctionName+ sigB.arglist+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
 else {
    newBody3=sigB.toString() + ""String_Node_Str"" + ""String_Node_Str""+ switchIdentifier+ ""String_Node_Str""+ ""String_Node_Str""+ roleFunctionName+ sigB.arglist+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ beforeFunctionName+ sigB.arglist+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  }
  terminalComp.setBody(newBody3);
}"
18377,"/** 
 * Creates a new XMINode
 * @param node the XMI node
 * @param root the XMI root node
 * @param ignoreID <tt>true</tt>, to enable ignore mode
 * @param copyMode <tt>true</tt>, to enable copyMode
 */
public XMINode(Node node,Element root,boolean ignoreID,boolean copyMode){
  super(node.getNodeName(),""String_Node_Str"");
  this.root=root;
  this.node=node;
  this.ignoreID=ignoreID;
  this.copyMode=copyMode;
  String name=""String_Node_Str"";
  String type=""String_Node_Str"";
  String id=""String_Node_Str"";
  String ref=""String_Node_Str"";
  type=node.getNodeName();
  NamedNodeMap map=node.getAttributes();
  if (map != null) {
    for (int i=0; i < map.getLength(); i++) {
      Node subNode=map.item(i);
      String nodeName=subNode.getNodeName();
      String nodeValue=subNode.getNodeValue();
      if (nodeName.equals(""String_Node_Str"")) {
        id=nodeValue;
      }
 else       if (nodeName.equals(""String_Node_Str"")) {
        ref=nodeValue;
      }
 else       if (nodeName.equals(""String_Node_Str"")) {
        name=nodeValue;
      }
 else {
        setNodeAttribute(nodeName,nodeValue);
      }
    }
    if (copyMode) {
      if (!id.isEmpty()) {
        setNodeAttribute(""String_Node_Str"",id);
        setName(id);
      }
      if (!name.isEmpty()) {
        setNodeAttribute(""String_Node_Str"",name);
      }
      if (!ref.isEmpty()) {
        setNodeAttribute(""String_Node_Str"",type + IdToElement(ref,type));
      }
    }
 else {
      if (name.equals(""String_Node_Str"")) {
        if (!id.equals(""String_Node_Str"")) {
          if (!ignoreID) {
            setNodeAttribute(""String_Node_Str"",id);
            setName(id);
          }
        }
      }
 else {
        setName(name);
        setNodeAttribute(""String_Node_Str"",name);
        if (type.equals(""String_Node_Str"") | type.equals(""String_Node_Str"") | type.equals(""String_Node_Str"")) {
        }
 else         if (ignoreID) {
        }
 else         if (!id.equals(""String_Node_Str"")) {
          setNodeAttribute(""String_Node_Str"",type + name);
        }
      }
      if (!ref.equals(""String_Node_Str"")) {
        String newRef=IdToElement(ref,type);
        if (newRef.equals(""String_Node_Str"")) {
          setNodeAttribute(""String_Node_Str"",ref);
        }
 else {
          setNodeAttribute(""String_Node_Str"",type + newRef);
        }
      }
    }
    if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
      setName(""String_Node_Str"");
    }
    if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
      this.ignoreID=true;
    }
    if (type.equals(""String_Node_Str"")) {
      this.copyMode=true;
    }
  }
}","/** 
 * Creates a new XMINode
 * @param node the XMI node
 * @param root the XMI root node
 * @param ignoreID <tt>true</tt>, to enable ignore mode
 * @param copyMode <tt>true</tt>, to enable copyMode
 */
public XMINode(Node node,Element root,boolean ignoreID,boolean copyMode){
  super(node.getNodeName(),""String_Node_Str"");
  this.root=root;
  this.node=node;
  this.ignoreID=ignoreID;
  this.copyMode=copyMode;
  String name=""String_Node_Str"";
  String type=""String_Node_Str"";
  String id=""String_Node_Str"";
  String ref=""String_Node_Str"";
  type=node.getNodeName();
  NamedNodeMap map=node.getAttributes();
  if (map != null) {
    for (int i=0; i < map.getLength(); i++) {
      Node subNode=map.item(i);
      String nodeName=subNode.getNodeName();
      String nodeValue=subNode.getNodeValue();
      if (nodeName.equals(""String_Node_Str"")) {
        id=nodeValue;
      }
 else       if (nodeName.equals(""String_Node_Str"")) {
        ref=nodeValue;
      }
 else       if (nodeName.equals(""String_Node_Str"")) {
        name=nodeValue;
      }
 else {
        setNodeAttribute(nodeName,nodeValue);
      }
    }
    if (copyMode) {
      if (!id.isEmpty()) {
        setNodeAttribute(""String_Node_Str"",id);
        setName(id);
      }
      if (!name.isEmpty()) {
        setNodeAttribute(""String_Node_Str"",name);
      }
      if (!ref.isEmpty()) {
        setNodeAttribute(""String_Node_Str"",type + IdToElement(ref,type));
      }
    }
 else {
      if (name.equals(""String_Node_Str"")) {
        if (!id.equals(""String_Node_Str"")) {
          if (!ignoreID) {
            setNodeAttribute(""String_Node_Str"",id);
            setName(id);
          }
        }
      }
 else {
        setName(name);
        setNodeAttribute(""String_Node_Str"",name);
        if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
        }
 else         if (ignoreID) {
        }
 else         if (!id.equals(""String_Node_Str"")) {
          setNodeAttribute(""String_Node_Str"",type + name);
        }
      }
      if (!ref.equals(""String_Node_Str"")) {
        String newRef=IdToElement(ref,type);
        if (newRef.equals(""String_Node_Str"")) {
          setNodeAttribute(""String_Node_Str"",ref);
        }
 else {
          setNodeAttribute(""String_Node_Str"",type + newRef);
        }
      }
    }
    if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
      setName(""String_Node_Str"");
    }
    if (type.equals(""String_Node_Str"") || type.equals(""String_Node_Str"")) {
      this.ignoreID=true;
    }
    if (type.equals(""String_Node_Str"")) {
      this.copyMode=true;
    }
  }
}"
18378,"private static void specializeModifiers(FSTTerminal terminalA,FSTTerminal terminalB){
  if (terminalA.getBody().contains(""String_Node_Str"") || terminalB.getBody().contains(""String_Node_Str""))   return;
  StringTokenizer stA=new StringTokenizer(terminalA.getBody(),""String_Node_Str"");
  StringTokenizer stB=new StringTokenizer(terminalB.getBody(),""String_Node_Str"");
  if (stA.hasMoreTokens() && stB.hasMoreTokens()) {
    stA=new StringTokenizer(stA.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetA=new LinkedHashSet<String>();
    while (stA.hasMoreTokens()) {
      modifierSetA.add(stA.nextToken());
    }
    stB=new StringTokenizer(stB.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetB=new LinkedHashSet<String>();
    while (stB.hasMoreTokens()) {
      modifierSetB.add(stB.nextToken());
    }
    String[] modifierArrayA=new String[modifierSetA.size()];
    modifierSetA.toArray(modifierArrayA);
    String[] modifierArrayB=new String[modifierSetB.size()];
    modifierSetB.toArray(modifierArrayB);
    if (modifierArrayA.length <= 1 || modifierArrayB.length <= 1)     return;
    if (!modifierArrayA[modifierArrayA.length - 2].equals(modifierArrayB[modifierArrayB.length - 2])) {
      System.err.println(""String_Node_Str"" + modifierArrayA[modifierArrayA.length - 1] + ""String_Node_Str""+ modifierArrayA[modifierArrayA.length - 2]+ ""String_Node_Str""+ modifierArrayB[modifierArrayB.length - 2]);
    }
    String removedDuplicates=new String();
    String[] modifierArrayRes=new String[modifierArrayA.length + modifierArrayB.length - 2];
    System.arraycopy(modifierArrayB,0,modifierArrayRes,0,modifierArrayB.length - 2);
    System.arraycopy(modifierArrayA,0,modifierArrayRes,modifierArrayB.length - 2,modifierArrayA.length);
    boolean isPublic=false;
    boolean isProtected=false;
    boolean isPrivate=false;
    boolean isAbstract=false;
    LinkedList<String> otherModifiers=new LinkedList<String>();
    for (int i=0; i < modifierArrayRes.length; i++) {
      String modifier=modifierArrayRes[i].trim();
      if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected&& !isPrivate) {
        isPrivate=true;
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected) {
        isProtected=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic) {
        isPublic=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
        if (modifier.equals(""String_Node_Str"")) {
          isAbstract=true;
          removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
          removedDuplicates+=modifier + ""String_Node_Str"";
        }
 else         if (modifier.equals(""String_Node_Str"") && !isAbstract) {
          removedDuplicates+=modifier + ""String_Node_Str"";
        }
 else         if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
          boolean in=false;
          for (          String otherModifier : otherModifiers) {
            if (otherModifier.equals(modifier))             in=true;
          }
          if (!in) {
            removedDuplicates+=modifier + ""String_Node_Str"";
            otherModifiers.add(modifier);
          }
        }
      }
    }
    if (terminalA.getBody().contains(""String_Node_Str""))     terminalA.setBody(removedDuplicates + ""String_Node_Str"" + terminalA.getBody().substring(terminalA.getBody().indexOf(""String_Node_Str"")));
    if (terminalB.getBody().contains(""String_Node_Str""))     terminalB.setBody(removedDuplicates + ""String_Node_Str"" + terminalB.getBody().substring(terminalB.getBody().indexOf(""String_Node_Str"")));
  }
}","private static void specializeModifiers(FSTTerminal terminalA,FSTTerminal terminalB){
  if (terminalA.getBody().contains(""String_Node_Str"") || terminalB.getBody().contains(""String_Node_Str""))   return;
  StringTokenizer stA=new StringTokenizer(terminalA.getBody(),""String_Node_Str"");
  StringTokenizer stB=new StringTokenizer(terminalB.getBody(),""String_Node_Str"");
  if (stA.hasMoreTokens() && stB.hasMoreTokens()) {
    stA=new StringTokenizer(stA.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetA=new LinkedHashSet<String>();
    while (stA.hasMoreTokens()) {
      modifierSetA.add(stA.nextToken());
    }
    stB=new StringTokenizer(stB.nextToken(),""String_Node_Str"");
    LinkedHashSet<String> modifierSetB=new LinkedHashSet<String>();
    while (stB.hasMoreTokens()) {
      modifierSetB.add(stB.nextToken());
    }
    String[] modifierArrayA=new String[modifierSetA.size()];
    modifierSetA.toArray(modifierArrayA);
    String[] modifierArrayB=new String[modifierSetB.size()];
    modifierSetB.toArray(modifierArrayB);
    if (modifierArrayA.length <= 1 || modifierArrayB.length <= 1)     return;
    if (!modifierArrayA[modifierArrayA.length - 2].equals(modifierArrayB[modifierArrayB.length - 2])) {
      System.err.println(""String_Node_Str"" + modifierArrayA[modifierArrayA.length - 1] + ""String_Node_Str""+ modifierArrayA[modifierArrayA.length - 2]+ ""String_Node_Str""+ modifierArrayB[modifierArrayB.length - 2]);
    }
    String removedDuplicates=new String();
    String[] modifierArrayRes=new String[modifierArrayA.length + modifierArrayB.length - 2];
    System.arraycopy(modifierArrayB,0,modifierArrayRes,0,modifierArrayB.length - 2);
    System.arraycopy(modifierArrayA,0,modifierArrayRes,modifierArrayB.length - 2,modifierArrayA.length);
    boolean isPublic=false;
    boolean isProtected=false;
    boolean isPrivate=false;
    boolean isAbstract=false;
    boolean isFinal=false;
    LinkedList<String> otherModifiers=new LinkedList<String>();
    for (int i=0; i < modifierArrayRes.length; i++) {
      String modifier=modifierArrayRes[i].trim();
      if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected&& !isPrivate) {
        isPrivate=true;
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic && !isProtected) {
        isProtected=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (modifier.equals(""String_Node_Str"") && !isPublic) {
        isPublic=true;
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
        removedDuplicates+=modifier + ""String_Node_Str"";
      }
 else       if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
        if (modifier.equals(""String_Node_Str"")) {
          isAbstract=true;
          removedDuplicates=removedDuplicates.replaceAll(""String_Node_Str"",""String_Node_Str"");
          removedDuplicates+=modifier + ""String_Node_Str"";
        }
 else         if (modifier.equals(""String_Node_Str"") && !isAbstract && !isFinal) {
          removedDuplicates+=modifier + ""String_Node_Str"";
          isFinal=true;
        }
 else         if (!modifier.equals(""String_Node_Str"") && !modifier.equals(""String_Node_Str"")) {
          boolean in=false;
          for (          String otherModifier : otherModifiers) {
            if (otherModifier.equals(modifier))             in=true;
          }
          if (!in) {
            removedDuplicates+=modifier + ""String_Node_Str"";
            otherModifiers.add(modifier);
          }
        }
      }
    }
    if (terminalA.getBody().contains(""String_Node_Str""))     terminalA.setBody(removedDuplicates + ""String_Node_Str"" + terminalA.getBody().substring(terminalA.getBody().indexOf(""String_Node_Str"")));
    if (terminalB.getBody().contains(""String_Node_Str""))     terminalB.setBody(removedDuplicates + ""String_Node_Str"" + terminalB.getBody().substring(terminalB.getBody().indexOf(""String_Node_Str"")));
  }
}"
18379,"public void run(String[] args){
  cmd.parseCmdLineArguments(args);
  compositionRules=new ArrayList<CompositionRule>();
  if (cmd.lifting) {
    if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new CRuntimeReplacement());
      compositionRules.add(new CRuntimeFunctionRefinement());
      subtreeRewriterC=new CRuntimeSubtreeIntegration();
    }
 else     if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new JavaRuntimeReplacement());
      compositionRules.add(new JavaRuntimeFunctionRefinement());
      subtreeRewriterJava=new JavaRuntimeSubtreeIntegration();
    }
 else {
      throw new InternalError(""String_Node_Str"" + cmd.lifting_language + ""String_Node_Str"");
    }
  }
 else {
    compositionRules.add(new Replacement());
    compositionRules.add(new JavaMethodOverriding());
  }
  compositionRules.add(new StringConcatenation());
  compositionRules.add(new ImplementsListMerging());
  compositionRules.add(new CSharpMethodOverriding());
  compositionRules.add(new ConstructorConcatenation());
  compositionRules.add(new ModifierListSpecialization());
  compositionRules.add(new FieldOverriding());
  compositionRules.add(new ExpansionOverriding());
  compositionRules.add(new CompositionError());
  try {
    try {
      fileLoader.loadFiles(cmd.equationFileName,cmd.equationBaseDirectoryName,cmd.isAheadEquationFile);
    }
 catch (    cide.gparser.ParseException e1) {
      System.out.println(""String_Node_Str"");
      fireParseErrorOccured(e1);
      e1.printStackTrace();
    }
    String outputDir=cmd.equationBaseDirectoryName;
    if (cmd.outputDirectoryName != null)     outputDir=cmd.outputDirectoryName;
    if (outputDir.endsWith(File.separator))     outputDir=outputDir.substring(0,outputDir.length() - 1);
    featureVisitor.setWorkingDir(outputDir);
    featureVisitor.setExpressionName(cmd.equationFileName);
    for (    ArtifactBuilderInterface builder : getArtifactBuilders()) {
      LinkedList<FSTNonTerminal> features=builder.getFeatures();
      if (cmd.isCount && (builder instanceof JavaBuilder || builder instanceof CApproxBuilder)) {
        Counter counter=new Counter();
        for (        FSTNonTerminal feature : features) {
          counter.collect(feature);
        }
        if (features.size() > 0)         counter.writeFile(new File(cmd.equationFileName + ""String_Node_Str""));
      }
      for (      FSTNonTerminal feature : features) {
        meta.addFeature(feature.getName());
      }
      FSTNode composition=compose(features);
      try {
        featureVisitor.visit((FSTNonTerminal)composition);
      }
 catch (      PrintVisitorException e) {
        e.printStackTrace();
      }
    }
    setFstnodes(AbstractFSTParser.fstnodes);
    try {
      String exp=new File(cmd.equationFileName).getName();
      exp=exp.substring(0,exp.length() - 4);
      meta.saveToFile(outputDir + File.separator + ""String_Node_Str"");
      if (cmd.lifting) {
        File cnfFile=new File(cmd.equationBaseDirectoryName,""String_Node_Str"");
        System.err.println(""String_Node_Str"" + cnfFile.getAbsolutePath());
        if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new CRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator + ""String_Node_Str"");
        }
 else         if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new JavaRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator);
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 catch (  FileNotFoundException e1) {
  }
}","public void run(String[] args){
  meta.clearFeatures();
  cmd.parseCmdLineArguments(args);
  compositionRules=new ArrayList<CompositionRule>();
  if (cmd.lifting) {
    if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new CRuntimeReplacement());
      compositionRules.add(new CRuntimeFunctionRefinement());
      subtreeRewriterC=new CRuntimeSubtreeIntegration();
    }
 else     if (cmd.lifting_language.equals(""String_Node_Str"")) {
      compositionRules.add(new JavaRuntimeReplacement());
      compositionRules.add(new JavaRuntimeFunctionRefinement());
      subtreeRewriterJava=new JavaRuntimeSubtreeIntegration();
    }
 else {
      throw new InternalError(""String_Node_Str"" + cmd.lifting_language + ""String_Node_Str"");
    }
  }
 else {
    compositionRules.add(new Replacement());
    compositionRules.add(new JavaMethodOverriding());
  }
  compositionRules.add(new StringConcatenation());
  compositionRules.add(new ImplementsListMerging());
  compositionRules.add(new CSharpMethodOverriding());
  compositionRules.add(new ConstructorConcatenation());
  compositionRules.add(new ModifierListSpecialization());
  compositionRules.add(new FieldOverriding());
  compositionRules.add(new ExpansionOverriding());
  compositionRules.add(new CompositionError());
  try {
    try {
      fileLoader.loadFiles(cmd.equationFileName,cmd.equationBaseDirectoryName,cmd.isAheadEquationFile);
    }
 catch (    cide.gparser.ParseException e1) {
      System.out.println(""String_Node_Str"");
      fireParseErrorOccured(e1);
      e1.printStackTrace();
    }
    String outputDir=cmd.equationBaseDirectoryName;
    if (cmd.outputDirectoryName != null)     outputDir=cmd.outputDirectoryName;
    if (outputDir.endsWith(File.separator))     outputDir=outputDir.substring(0,outputDir.length() - 1);
    featureVisitor.setWorkingDir(outputDir);
    featureVisitor.setExpressionName(cmd.equationFileName);
    for (    ArtifactBuilderInterface builder : getArtifactBuilders()) {
      LinkedList<FSTNonTerminal> features=builder.getFeatures();
      if (cmd.isCount && (builder instanceof JavaBuilder || builder instanceof CApproxBuilder)) {
        Counter counter=new Counter();
        for (        FSTNonTerminal feature : features) {
          counter.collect(feature);
        }
        if (features.size() > 0)         counter.writeFile(new File(cmd.equationFileName + ""String_Node_Str""));
      }
      for (      FSTNonTerminal feature : features) {
        meta.addFeature(feature.getName());
      }
      FSTNode composition=compose(features);
      try {
        featureVisitor.visit((FSTNonTerminal)composition);
      }
 catch (      PrintVisitorException e) {
        e.printStackTrace();
      }
    }
    setFstnodes(AbstractFSTParser.fstnodes);
    try {
      String exp=new File(cmd.equationFileName).getName();
      exp=exp.substring(0,exp.length() - 4);
      meta.saveToFile(outputDir + File.separator + ""String_Node_Str"");
      if (cmd.lifting) {
        File cnfFile=new File(cmd.equationBaseDirectoryName,""String_Node_Str"");
        System.err.println(""String_Node_Str"" + cnfFile.getAbsolutePath());
        if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new CRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator + ""String_Node_Str"");
        }
 else         if (cmd.lifting_language.equals(""String_Node_Str"")) {
          new JavaRuntimeFeatureSelection(meta,cnfFile).saveTo(outputDir + File.separator);
        }
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
 catch (  FileNotFoundException e1) {
  }
}"
18380,"public void processRestrictions(){
  Scanner scanner=null;
  try {
    scanner=new Scanner(cnfFile);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + cnfFile);
    throw new RuntimeException();
  }
  scanner.useDelimiter(""String_Node_Str"");
  String cnf=scanner.next();
  scanner.close();
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  Pattern varsRegEx=Pattern.compile(""String_Node_Str"");
  Matcher matcher=varsRegEx.matcher(cnf);
  Set<String> variables=new HashSet<String>();
  Set<String> nonterminals=new HashSet<String>();
  if (!matcher.find()) {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException();
  }
  String rootProduction=matcher.group();
  matcher.reset();
  while (matcher.find()) {
    variables.add(matcher.group());
  }
  for (  String var : variables) {
    String replacement;
    if (var.equals(rootProduction)) {
      replacement=""String_Node_Str"";
    }
 else     if (meta.getFeatures().contains(var)) {
      replacement=""String_Node_Str"" + var;
    }
 else {
      replacement=""String_Node_Str"" + var;
      nonterminals.add(replacement);
    }
    cnf=cnf.replaceAll(' ' + var + ' ',' ' + replacement + ' ');
  }
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  headerContents+=""String_Node_Str"";
  for (  String nt : nonterminals) {
    headerContents+=""String_Node_Str"" + nt + ""String_Node_Str"";
  }
  StringBuffer res=new StringBuffer();
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  for (  String nt : nonterminals) {
    res.append(""String_Node_Str"" + nt + ""String_Node_Str"");
  }
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"" + cnf + ""String_Node_Str"");
  res.append(""String_Node_Str"");
  cFileContents+=res.toString();
}","public void processRestrictions(){
  Scanner scanner=null;
  try {
    scanner=new Scanner(cnfFile);
  }
 catch (  FileNotFoundException e) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + cnfFile);
    throw new RuntimeException();
  }
  scanner.useDelimiter(""String_Node_Str"");
  String cnf=scanner.next();
  scanner.close();
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  Pattern varsRegEx=Pattern.compile(""String_Node_Str"");
  Matcher matcher=varsRegEx.matcher(cnf);
  Set<String> variables=new HashSet<String>();
  Set<String> nonterminals=new HashSet<String>();
  if (!matcher.find()) {
    System.out.println(""String_Node_Str"");
    throw new RuntimeException();
  }
  matcher.reset();
  while (matcher.find()) {
    variables.add(matcher.group());
  }
  for (  String var : variables) {
    String replacement;
    if (meta.getFeatures().contains(var)) {
      replacement=""String_Node_Str"" + var;
    }
 else {
      replacement=""String_Node_Str"" + var;
      nonterminals.add(replacement);
    }
    cnf=cnf.replaceAll(' ' + var + ' ',' ' + replacement + ' ');
  }
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  cnf=cnf.replaceAll(""String_Node_Str"",""String_Node_Str"");
  headerContents+=""String_Node_Str"";
  for (  String nt : nonterminals) {
    headerContents+=""String_Node_Str"" + nt + ""String_Node_Str"";
  }
  StringBuffer res=new StringBuffer();
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  for (  String nt : nonterminals) {
    res.append(""String_Node_Str"" + nt + ""String_Node_Str"");
  }
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"" + cnf + ""String_Node_Str"");
  res.append(""String_Node_Str"");
  cFileContents+=res.toString();
}"
18381,"public void process(){
  javaFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  HashSet<String> processedFeatures=new HashSet<String>();
  for (  String feature : meta.getFeatures()) {
    if (!processedFeatures.contains(feature)) {
      processedFeatures.add(feature);
      javaFileContents+=""String_Node_Str"";
      javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
    }
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str""+ feature+ ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  javaFileContents+=""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"";
  processRestrictions();
  javaFileContents+=""String_Node_Str"";
}","public void process(){
  javaFileContents=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  HashSet<String> processedFeatures=new HashSet<String>();
  for (  String feature : meta.getFeatures()) {
    if (!processedFeatures.contains(feature)) {
      processedFeatures.add(feature);
      if (addJPF_BDD_Annotation)       javaFileContents+=""String_Node_Str"";
      javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
    }
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str""+ feature+ ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"" + ""String_Node_Str"";
  javaFileContents+=""String_Node_Str"";
  for (  String feature : processedFeatures) {
    javaFileContents+=""String_Node_Str"" + feature + ""String_Node_Str"";
  }
  javaFileContents+=""String_Node_Str"";
  processRestrictions();
  javaFileContents+=""String_Node_Str"";
}"
18382,"public void processNode(FSTNonTerminal parent,StringTokenizer st,File inputFile) throws FileNotFoundException, ParseException {
  FSTNonTerminal rootDocument=new FSTNonTerminal(""String_Node_Str"",st.nextToken());
  parent.addChild(rootDocument);
  PythonParser p=new PythonParser(new OffsetCharStream(new FileInputStream(inputFile)));
  p.file_input(false);
  rootDocument.addChild(p.getRoot());
}","public void processNode(FSTNonTerminal parent,StringTokenizer st,File inputFile) throws FileNotFoundException, ParseException {
  FSTNonTerminal rootDocument=new FSTNonTerminal(""String_Node_Str"",st.nextToken());
  parent.addChild(rootDocument);
  PythonParser p=new PythonParser(new OffsetCharStream(new FileInputStream(inputFile)));
  p.file_input(false);
  rootDocument.addChild(p.getRoot());
  if (isPreprocessNode()) {
    for (    FSTNode child : rootDocument.getChildren()) {
      SimplePrintVisitor visitor;
      try {
        visitor=new SimplePrintVisitor(new PrintStream(inputFile));
        visitor.visit((FSTNonTerminal)child);
        visitor.getResult();
      }
 catch (      FileNotFoundException e) {
      }
    }
  }
}"
18383,"public void parseCmdLineArguments(String[] args){
  boolean errorOccured=false;
  if (args != null && args.length > 0) {
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(INPUT_OPTION_EQUATIONFILE)) {
        i++;
        if (i < args.length) {
          equationFileName=args[i];
          if (!isBaseDirectoryName)           equationBaseDirectoryName=getDirectoryName(new File(equationFileName)) + File.separator;
          equationFileName=equationFileName.replace(""String_Node_Str"",File.separator);
          equationFileName=equationFileName.replace(""String_Node_Str"",File.separator);
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_EQUATIONFILE);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_BASE_DIRECTORY)) {
        i++;
        if (i < args.length) {
          equationBaseDirectoryName=args[i];
          equationBaseDirectoryName=equationBaseDirectoryName.replace(""String_Node_Str"",File.separator);
          equationBaseDirectoryName=equationBaseDirectoryName.replace(""String_Node_Str"",File.separator);
          isBaseDirectoryName=true;
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_BASE_DIRECTORY);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_OUTPUT_DIRECTORY)) {
        i++;
        if (i < args.length) {
          outputDirectoryName=args[i];
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_OUTPUT_DIRECTORY);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_HELP)) {
        printHelp(false);
      }
 else {
        errorOccured=true;
      }
    }
  }
 else {
    errorOccured=true;
  }
  if (errorOccured) {
    printHelp(errorOccured);
  }
}","public void parseCmdLineArguments(String[] args){
  boolean errorOccured=false;
  if (args != null && args.length > 0) {
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(INPUT_OPTION_EQUATIONFILE)) {
        i++;
        if (i < args.length) {
          equationFileName=args[i];
          if (!isBaseDirectoryName)           equationBaseDirectoryName=getDirectoryName(new File(equationFileName)) + File.separator;
          equationFileName=equationFileName.replace(""String_Node_Str"",File.separator);
          equationFileName=equationFileName.replace(""String_Node_Str"",File.separator);
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_EQUATIONFILE);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_BASE_DIRECTORY)) {
        i++;
        if (i < args.length) {
          equationBaseDirectoryName=args[i];
          equationBaseDirectoryName=equationBaseDirectoryName.replace(""String_Node_Str"",File.separator);
          equationBaseDirectoryName=equationBaseDirectoryName.replace(""String_Node_Str"",File.separator);
          isBaseDirectoryName=true;
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_BASE_DIRECTORY);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_OUTPUT_DIRECTORY)) {
        i++;
        if (i < args.length) {
          outputDirectoryName=args[i];
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_OUTPUT_DIRECTORY);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_PREPROCESS_FILES)) {
        i++;
        if (i < args.length) {
          preprocessFiles=Boolean.parseBoolean(args[i]);
        }
 else {
          System.out.println(""String_Node_Str"" + INPUT_OPTION_PREPROCESS_FILES);
          errorOccured=true;
        }
      }
 else       if (args[i].equals(INPUT_OPTION_HELP)) {
        printHelp(false);
      }
 else {
        errorOccured=true;
      }
    }
  }
 else {
    errorOccured=true;
  }
  if (errorOccured) {
    printHelp(errorOccured);
  }
}"
18384,"public void run(String[] args){
  cmd.parseCmdLineArguments(args);
  try {
    try {
      fileLoader.loadFiles(cmd.equationFileName,cmd.equationBaseDirectoryName,false);
    }
 catch (    cide.gparser.ParseException e1) {
      fireParseErrorOccured(e1);
      e1.printStackTrace();
    }
    String outputDir=cmd.equationBaseDirectoryName;
    if (cmd.outputDirectoryName != null)     outputDir=cmd.outputDirectoryName;
    featureVisitor.setWorkingDir(outputDir);
    featureVisitor.setExpressionName(cmd.equationFileName);
    for (    ArtifactBuilderInterface builder : getArtifactBuilders()) {
      LinkedList<FSTNonTerminal> features=builder.getFeatures();
      for (      FSTNonTerminal feature : features)       System.out.println(feature.toString());
      FSTNode merged;
      if (features.size() != 0) {
        merged=merge(features);
        mergeVisitor.visit(merged);
        System.err.println(merged.toString());
        try {
          featureVisitor.visit((FSTNonTerminal)merged);
        }
 catch (        PrintVisitorException e) {
          e.printStackTrace();
        }
      }
    }
    setFstnodes(AbstractFSTParser.fstnodes);
  }
 catch (  MergeException me) {
    System.err.println(me.toString());
    me.printStackTrace();
  }
catch (  FileNotFoundException e1) {
    e1.printStackTrace();
  }
}","public void run(String[] args){
  cmd.parseCmdLineArguments(args);
  try {
    try {
      if (cmd.preprocessFiles)       fileLoader.setPreprocessFiles(true);
      fileLoader.loadFiles(cmd.equationFileName,cmd.equationBaseDirectoryName,false);
    }
 catch (    cide.gparser.ParseException e1) {
      fireParseErrorOccured(e1);
      e1.printStackTrace();
    }
    String outputDir=cmd.equationBaseDirectoryName;
    if (cmd.outputDirectoryName != null)     outputDir=cmd.outputDirectoryName;
    featureVisitor.setWorkingDir(outputDir);
    featureVisitor.setExpressionName(cmd.equationFileName);
    for (    ArtifactBuilderInterface builder : getArtifactBuilders()) {
      LinkedList<FSTNonTerminal> features=builder.getFeatures();
      for (      FSTNonTerminal feature : features)       System.out.println(feature.toString());
      FSTNode merged;
      if (features.size() != 0) {
        merged=merge(features);
        mergeVisitor.visit(merged);
        System.err.println(merged.toString());
        try {
          featureVisitor.visit((FSTNonTerminal)merged);
        }
 catch (        PrintVisitorException e) {
          e.printStackTrace();
        }
      }
    }
    setFstnodes(AbstractFSTParser.fstnodes);
  }
 catch (  MergeException me) {
    System.err.println(me.toString());
    me.printStackTrace();
  }
catch (  FileNotFoundException e1) {
    e1.printStackTrace();
  }
}"
18385,"public void merge(FSTTerminal node) throws ContentMergeException {
  String body=node.getBody() + ""String_Node_Str"";
  String[] tokens=body.split(FSTGenMerger.MERGE_SEPARATOR);
  try {
    tokens[0]=tokens[0].replace(FSTGenMerger.SEMANTIC_MERGE_MARKER,""String_Node_Str"").trim();
    tokens[1]=tokens[1].trim();
    tokens[2]=tokens[2].trim();
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    System.err.println(""String_Node_Str"" + body + ""String_Node_Str"");
    e.printStackTrace();
  }
  if (!(node.getType().contains(""String_Node_Str"") || node.getMergingMechanism().equals(""String_Node_Str""))) {
    if (tokens[0].length() == 0 && tokens[1].length() == 0 && tokens[2].length() == 0) {
      node.setBody(""String_Node_Str"");
    }
 else     if (tokens[0].equals(tokens[2])) {
      node.setBody(tokens[0]);
    }
 else     if (tokens[0].equals(tokens[1]) && tokens[2].length() > 0) {
      node.setBody(tokens[2]);
    }
 else     if (tokens[2].equals(tokens[1]) && tokens[0].length() > 0) {
      node.setBody(tokens[0]);
    }
 else     if (tokens[0].equals(tokens[1]) && tokens[2].length() == 0) {
      node.setBody(""String_Node_Str"");
    }
 else     if (tokens[2].equals(tokens[1]) && tokens[0].length() == 0) {
      node.setBody(""String_Node_Str"");
    }
    return;
  }
  try {
    File tmpDir=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
    tmpDir.mkdir();
    File fileVar1=File.createTempFile(""String_Node_Str"",""String_Node_Str"",tmpDir);
    File fileBase=File.createTempFile(""String_Node_Str"",""String_Node_Str"",tmpDir);
    File fileVar2=File.createTempFile(""String_Node_Str"",""String_Node_Str"",tmpDir);
    BufferedWriter writerVar1=new BufferedWriter(new FileWriter(fileVar1));
    if (node.getType().contains(""String_Node_Str"") || tokens[0].length() == 0)     writerVar1.write(tokens[0]);
 else     writerVar1.write(tokens[0] + ""String_Node_Str"");
    writerVar1.close();
    BufferedWriter writerBase=new BufferedWriter(new FileWriter(fileBase));
    if (node.getType().contains(""String_Node_Str"") || tokens[1].length() == 0)     writerBase.write(tokens[1]);
 else     writerBase.write(tokens[1] + ""String_Node_Str"");
    writerBase.close();
    BufferedWriter writerVar2=new BufferedWriter(new FileWriter(fileVar2));
    if (node.getType().contains(""String_Node_Str"") || tokens[2].length() == 0)     writerVar2.write(tokens[2]);
 else     writerVar2.write(tokens[2] + ""String_Node_Str"");
    writerVar2.close();
    String mergeCmd=""String_Node_Str"";
    if (System.getProperty(""String_Node_Str"").contains(""String_Node_Str""))     mergeCmd=""String_Node_Str"" + ""String_Node_Str"" + fileVar1.getPath() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fileBase.getPath()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fileVar2.getPath()+ ""String_Node_Str"";
 else     mergeCmd=""String_Node_Str"" + fileVar1.getPath() + ""String_Node_Str""+ fileBase.getPath()+ ""String_Node_Str""+ fileVar2.getPath();
    Runtime run=Runtime.getRuntime();
    Process pr=run.exec(mergeCmd);
    BufferedReader buf=new BufferedReader(new InputStreamReader(pr.getInputStream()));
    String line=""String_Node_Str"";
    String res=""String_Node_Str"";
    while ((line=buf.readLine()) != null) {
      res+=line + ""String_Node_Str"";
    }
    node.setBody(res);
    buf=new BufferedReader(new InputStreamReader(pr.getErrorStream()));
    while ((line=buf.readLine()) != null) {
      System.err.println(line);
    }
    fileVar1.delete();
    fileBase.delete();
    fileVar2.delete();
    tmpDir.delete();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void merge(FSTTerminal node) throws ContentMergeException {
  String body=node.getBody() + ""String_Node_Str"";
  String[] tokens=body.split(FSTGenMerger.MERGE_SEPARATOR);
  try {
    tokens[0]=tokens[0].replace(FSTGenMerger.SEMANTIC_MERGE_MARKER,""String_Node_Str"").trim();
    tokens[1]=tokens[1].trim();
    tokens[2]=tokens[2].trim();
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    System.err.println(""String_Node_Str"" + body + ""String_Node_Str"");
    e.printStackTrace();
  }
  if (!(node.getType().contains(""String_Node_Str"") || node.getMergingMechanism().equals(""String_Node_Str""))) {
    if (tokens[0].length() == 0 && tokens[1].length() == 0 && tokens[2].length() == 0) {
      node.setBody(""String_Node_Str"");
    }
 else     if (tokens[0].equals(tokens[2])) {
      node.setBody(tokens[0]);
    }
 else     if (tokens[0].equals(tokens[1]) && tokens[2].length() > 0) {
      node.setBody(tokens[2]);
    }
 else     if (tokens[2].equals(tokens[1]) && tokens[0].length() > 0) {
      node.setBody(tokens[0]);
    }
 else     if (tokens[0].equals(tokens[1]) && tokens[2].length() == 0) {
      node.setBody(""String_Node_Str"");
    }
 else     if (tokens[2].equals(tokens[1]) && tokens[0].length() == 0) {
      node.setBody(""String_Node_Str"");
    }
    return;
  }
  try {
    File tmpDir=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
    tmpDir.mkdir();
    File fileVar1=File.createTempFile(""String_Node_Str"",""String_Node_Str"",tmpDir);
    File fileBase=File.createTempFile(""String_Node_Str"",""String_Node_Str"",tmpDir);
    File fileVar2=File.createTempFile(""String_Node_Str"",""String_Node_Str"",tmpDir);
    BufferedWriter writerVar1=new BufferedWriter(new FileWriter(fileVar1));
    if (node.getType().contains(""String_Node_Str"") || tokens[0].length() == 0)     writerVar1.write(tokens[0]);
 else     writerVar1.write(tokens[0] + ""String_Node_Str"");
    writerVar1.close();
    BufferedWriter writerBase=new BufferedWriter(new FileWriter(fileBase));
    if (node.getType().contains(""String_Node_Str"") || tokens[1].length() == 0)     writerBase.write(tokens[1]);
 else     writerBase.write(tokens[1] + ""String_Node_Str"");
    writerBase.close();
    BufferedWriter writerVar2=new BufferedWriter(new FileWriter(fileVar2));
    if (node.getType().contains(""String_Node_Str"") || tokens[2].length() == 0)     writerVar2.write(tokens[2]);
 else     writerVar2.write(tokens[2] + ""String_Node_Str"");
    writerVar2.close();
    String mergeCmd=""String_Node_Str"";
    if (System.getProperty(""String_Node_Str"").contains(""String_Node_Str""))     mergeCmd=""String_Node_Str"" + ""String_Node_Str"" + fileVar1.getPath() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fileBase.getPath()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fileVar2.getPath()+ ""String_Node_Str"";
 else     mergeCmd=""String_Node_Str"" + fileVar1.getPath() + ""String_Node_Str""+ fileBase.getPath()+ ""String_Node_Str""+ fileVar2.getPath();
    Runtime run=Runtime.getRuntime();
    Process pr=run.exec(mergeCmd);
    BufferedReader buf=new BufferedReader(new InputStreamReader(pr.getInputStream()));
    String line=""String_Node_Str"";
    String res=""String_Node_Str"";
    while ((line=buf.readLine()) != null) {
      res+=line + ""String_Node_Str"";
    }
    pr.getInputStream().close();
    node.setBody(res);
    buf=new BufferedReader(new InputStreamReader(pr.getErrorStream()));
    while ((line=buf.readLine()) != null) {
      System.err.println(line);
    }
    pr.getErrorStream().close();
    pr.getOutputStream().close();
    fileVar1.delete();
    fileBase.delete();
    fileVar2.delete();
    tmpDir.delete();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
18386,"public boolean visit(FSTNonTerminal nonTerminal){
  if (nonTerminal.getType().equals(FILE_TYPE)) {
    FSTNonTerminal parent=findNonTerminal(nonTerminal,GUARD_PARENT);
    String identifier=fitString(nonTerminal.getName());
    parent.getChildren().add(0,new FSTTerminal(HEADER_GUARD_IFNDEF_LINE_TYPE,HEADER_GUARD_IFNDEF_LINE_NAME,HEADER_GUARD_IFNDEF_LINE_CONTENT + ""String_Node_Str"" + identifier,""String_Node_Str""));
    parent.getChildren().add(0,new FSTTerminal(HEADER_GUARD_DEFINE_LINE_TYPE,HEADER_GUARD_DEFINE_LINE_NAME,HEADER_GUARD_DEFINE_LINE_CONTENT + ""String_Node_Str"" + identifier,""String_Node_Str""));
    parent.getChildren().add(new FSTTerminal(HEADER_GUARD_ENDIF_LINE_TYPE,HEADER_GUARD_ENDIF_LINE_NAME,HEADER_GUARD_ENDIF_LINE_CONTENT,""String_Node_Str""));
  }
  return true;
}","public boolean visit(FSTNonTerminal nonTerminal){
  if (nonTerminal.getType().equals(FILE_TYPE)) {
    FSTNonTerminal parent=findNonTerminal(nonTerminal,GUARD_PARENT);
    String identifier=fitString(nonTerminal.getName());
    parent.getChildren().add(0,new FSTTerminal(HEADER_GUARD_DEFINE_LINE_TYPE,HEADER_GUARD_DEFINE_LINE_NAME,HEADER_GUARD_DEFINE_LINE_CONTENT + ""String_Node_Str"" + identifier,""String_Node_Str""));
    parent.getChildren().add(0,new FSTTerminal(HEADER_GUARD_IFNDEF_LINE_TYPE,HEADER_GUARD_IFNDEF_LINE_NAME,HEADER_GUARD_IFNDEF_LINE_CONTENT + ""String_Node_Str"" + identifier,""String_Node_Str""));
    parent.getChildren().add(new FSTTerminal(HEADER_GUARD_ENDIF_LINE_TYPE,HEADER_GUARD_ENDIF_LINE_NAME,HEADER_GUARD_ENDIF_LINE_CONTENT,""String_Node_Str""));
  }
  return true;
}"
18387,"public static void compose(FSTTerminal terminalA,FSTTerminal terminalB,FSTTerminal terminalComp,FSTNonTerminal nonterminalParent){
  if (terminalA.getBody().matches(""String_Node_Str"")) {
    FSTTerminal terminalComp2=(FSTTerminal)terminalB.getDeepClone();
    nonterminalParent.addChild(terminalComp2);
    String oldMethodName=terminalB.getName();
    StringTokenizer st=new StringTokenizer(oldMethodName,""String_Node_Str"");
    if (st.hasMoreTokens()) {
      oldMethodName=st.nextToken();
    }
    st=new StringTokenizer(oldMethodName,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      oldMethodName=st.nextToken();
    }
    String toReplace=""String_Node_Str"";
    String newMethodName=oldMethodName + ""String_Node_Str"" + getFeatureName(terminalB);
    String newBody=terminalComp.getBody().replaceAll(toReplace,newMethodName + ""String_Node_Str"");
    terminalComp.setBody(newBody);
    String auxBody=""String_Node_Str"";
    st=new StringTokenizer(terminalComp2.getBody(),""String_Node_Str"");
    if (st.hasMoreTokens()) {
      auxBody=st.nextToken();
    }
    st=new StringTokenizer(auxBody,""String_Node_Str"");
    String prefix=""String_Node_Str"";
    boolean found=false;
    while (st.hasMoreTokens() && !found) {
      String token=st.nextToken();
      if (oldMethodName.equals(token)) {
        found=true;
      }
 else {
        prefix+=token + ""String_Node_Str"";
      }
    }
    terminalComp2.setBody(prefix + terminalComp2.getBody().replaceFirst(prefix,""String_Node_Str"").replaceFirst(oldMethodName,newMethodName));
    terminalComp2.setName(newMethodName);
  }
}","public static void compose(FSTTerminal terminalA,FSTTerminal terminalB,FSTTerminal terminalComp,FSTNonTerminal nonterminalParent){
  if (terminalA.getBody().matches(""String_Node_Str"")) {
    FSTTerminal terminalComp2=(FSTTerminal)terminalB.getDeepClone();
    nonterminalParent.addChild(terminalComp2);
    String oldMethodName=terminalB.getName();
    StringTokenizer st=new StringTokenizer(oldMethodName,""String_Node_Str"");
    if (st.hasMoreTokens()) {
      oldMethodName=st.nextToken();
    }
    st=new StringTokenizer(oldMethodName,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      oldMethodName=st.nextToken();
    }
    String toReplace=""String_Node_Str"";
    String newMethodName=oldMethodName + ""String_Node_Str"" + getFeatureName(terminalB);
    String newBody=terminalComp.getBody().replaceAll(toReplace,newMethodName + ""String_Node_Str"");
    terminalComp.setBody(newBody);
    String auxBody=""String_Node_Str"";
    st=new StringTokenizer(terminalComp2.getBody(),""String_Node_Str"");
    if (st.hasMoreTokens()) {
      auxBody=st.nextToken();
    }
    st=new StringTokenizer(auxBody,""String_Node_Str"");
    String prefix=""String_Node_Str"";
    boolean found=false;
    while (st.hasMoreTokens() && !found) {
      String token=st.nextToken();
      if (oldMethodName.equals(token)) {
        found=true;
      }
 else {
        prefix+=token + ""String_Node_Str"";
      }
    }
    System.out.println(""String_Node_Str"" + prefix);
    String modPrefix=""String_Node_Str"";
    for (    char c : prefix.toCharArray()) {
      if (c == '[')       modPrefix+=""String_Node_Str"";
 else       if (c == ']')       modPrefix+=""String_Node_Str"";
 else       modPrefix+=String.valueOf(c);
    }
    prefix=modPrefix;
    System.out.println(""String_Node_Str"" + prefix);
    terminalComp2.setBody(prefix + terminalComp2.getBody().replaceFirst(prefix,""String_Node_Str"").replaceFirst(oldMethodName,newMethodName));
    terminalComp2.setName(newMethodName);
  }
}"
18388,"/** 
 * @param args
 * @throws Exception
 */
public static void main(String[] args) throws Exception {
  System.out.println(new JavaMethodBody(""String_Node_Str"").getFST());
}","/** 
 * @param args
 * @throws Exception
 */
public static void main(String[] args) throws Exception {
  JavaMethod jmOld=new JavaMethod(""String_Node_Str"");
  FSTNode jmOldFST=jmOld.getFST();
  List<FSTNode> l=new LinkedList<FSTNode>();
  l.add(jmOldFST);
  FSTNode featOld=new FSTNonTerminal(""String_Node_Str"",""String_Node_Str"",l);
  JavaMethod jmNew=new JavaMethod(""String_Node_Str"");
  FSTNode par=new FSTNonTerminal(""String_Node_Str"",""String_Node_Str"");
  System.out.println(FSTGenComposer.compose(jmNew.getFST(),jmOldFST,par));
}"
18389,"/** 
 * This method invoked after the user want to edit specified shelf.
 * @param shelf - shelf to edit
 */
public void startEditShelf(Shelf shelf){
  if (getLoggedUser() == null) {
    return;
  }
  if (!canViewShelf(shelf)) {
    showError(Constants.HAVENT_ACCESS);
    return;
  }
  model.resetModel(NavigationEnum.SHELF_EDIT,shelf.getOwner(),shelf,null,null,null);
}","/** 
 * This method invoked after the user want to edit specified shelf.
 * @param shelf - shelf to edit
 */
public void startEditShelf(Shelf shelf){
  if (getLoggedUser() == null) {
    return;
  }
  if (!canViewShelf(shelf)) {
    showError(""String_Node_Str"",Constants.HAVENT_ACCESS);
    return;
  }
  model.resetModel(NavigationEnum.SHELF_EDIT,shelf.getOwner(),shelf,null,null,null);
}"
18390,"/** 
 * This method invoked after the user want to see specified image independently is it her image or not.
 * @param album - album to show
 */
public void showImage(Image image){
  pushEvent(Events.CLEAR_EDITOR_EVENT);
  if (!canViewImage(image)) {
    showError(Constants.HAVENT_ACCESS);
    return;
  }
  if (!fileManager.isFilePresent(image.getFullPath())) {
    showError(""String_Node_Str"",Constants.IMAGE_RECENTLY_DELETED_ERROR);
    model.resetModel(NavigationEnum.ALBUM_PREVIEW,image.getAlbum().getOwner(),image.getAlbum().getShelf(),image.getAlbum(),null,image.getAlbum().getImages());
    return;
  }
  model.resetModel(NavigationEnum.ALBUM_IMAGE_PREVIEW,image.getAlbum().getOwner(),image.getAlbum().getShelf(),image.getAlbum(),image,image.getAlbum().getImages());
  image.setVisited(true);
}","/** 
 * This method invoked after the user want to see specified image independently is it her image or not.
 * @param album - album to show
 */
public void showImage(Image image){
  pushEvent(Events.CLEAR_EDITOR_EVENT);
  if (!canViewImage(image)) {
    showError(""String_Node_Str"",Constants.HAVENT_ACCESS);
    return;
  }
  if (!fileManager.isFilePresent(image.getFullPath())) {
    showError(""String_Node_Str"",Constants.IMAGE_RECENTLY_DELETED_ERROR);
    model.resetModel(NavigationEnum.ALBUM_PREVIEW,image.getAlbum().getOwner(),image.getAlbum().getShelf(),image.getAlbum(),null,image.getAlbum().getImages());
    return;
  }
  model.resetModel(NavigationEnum.ALBUM_IMAGE_PREVIEW,image.getAlbum().getOwner(),image.getAlbum().getShelf(),image.getAlbum(),image,image.getAlbum().getImages());
  image.setVisited(true);
}"
18391,"/** 
 * This method invoked after the user want to see specified album independently is it her album or not.
 * @param album - album to show
 */
public void showAlbum(Album album){
  if (!canViewAlbum(album)) {
    showError(Constants.HAVENT_ACCESS);
    return;
  }
  if (!fileManager.isDirectoryPresent(album.getPath())) {
    showError(""String_Node_Str"",Constants.ALBUM_RECENTLY_DELETED_ERROR);
    model.resetModel(NavigationEnum.SHELF_PREVIEW,album.getOwner(),album.getShelf(),null,null,null);
    return;
  }
  setPage(0);
  model.resetModel(NavigationEnum.ALBUM_PREVIEW,album.getOwner(),album.getShelf(),album,null,album.getImages());
}","/** 
 * This method invoked after the user want to see specified album independently is it her album or not.
 * @param album - album to show
 */
public void showAlbum(Album album){
  if (!canViewAlbum(album)) {
    showError(""String_Node_Str"",Constants.HAVENT_ACCESS);
    return;
  }
  if (!fileManager.isDirectoryPresent(album.getPath())) {
    showError(""String_Node_Str"",Constants.ALBUM_RECENTLY_DELETED_ERROR);
    model.resetModel(NavigationEnum.SHELF_PREVIEW,album.getOwner(),album.getShelf(),null,null,null);
    return;
  }
  setPage(0);
  model.resetModel(NavigationEnum.ALBUM_PREVIEW,album.getOwner(),album.getShelf(),album,null,album.getImages());
}"
18392,"/** 
 * This method invoked after the user want to edit specified album.
 * @param album - album to edit
 */
public void startEditAlbum(Album album){
  if (getLoggedUser() == null) {
    return;
  }
  if (!album.isOwner(getLoggedUser())) {
    showError(Constants.HAVENT_ACCESS);
    return;
  }
  model.resetModel(NavigationEnum.ALBUM_EDIT,album.getOwner(),album.getShelf(),album,null,album.getImages());
}","/** 
 * This method invoked after the user want to edit specified album.
 * @param album - album to edit
 */
public void startEditAlbum(Album album){
  if (getLoggedUser() == null) {
    return;
  }
  if (!album.isOwner(getLoggedUser())) {
    showError(""String_Node_Str"",Constants.HAVENT_ACCESS);
    return;
  }
  model.resetModel(NavigationEnum.ALBUM_EDIT,album.getOwner(),album.getShelf(),album,null,album.getImages());
}"
18393,"/** 
 * This method invoked after the user want to see specified shelf independently is it her shelf or not.
 * @param album - album to show
 */
public void showShelf(Shelf shelf){
  if (!fileManager.isDirectoryPresent(shelf.getPath())) {
    showError(Constants.SHELF_RECENTLY_DELETED_ERROR);
    model.resetModel(NavigationEnum.ANONYM,shelf.getOwner(),null,null,null,null);
    return;
  }
  model.resetModel(NavigationEnum.SHELF_PREVIEW,shelf.getOwner(),shelf,null,null,null);
}","/** 
 * This method invoked after the user want to see specified shelf independently is it her shelf or not.
 * @param album - album to show
 */
public void showShelf(Shelf shelf){
  if (!fileManager.isDirectoryPresent(shelf.getPath())) {
    showError(""String_Node_Str"",Constants.SHELF_RECENTLY_DELETED_ERROR);
    model.resetModel(NavigationEnum.ANONYM,shelf.getOwner(),null,null,null,null);
    return;
  }
  model.resetModel(NavigationEnum.SHELF_PREVIEW,shelf.getOwner(),shelf,null,null,null);
}"
18394,"private boolean canViewShelf(Shelf shelf){
  return shelf != null && shelf.isOwner(getLoggedUser() || shelf.isShared());
}","private boolean canViewShelf(Shelf shelf){
  return shelf != null && shelf.isOwner(getLoggedUser()) || shelf.isShared();
}"
18395,"public void showEvent(Event event){
  model.resetModel(NavigationEnum.EVENT_PREVIEW,loggedUser,null,null,null,null,event);
  pushEvent(Events.EVENT_DISPLAYED_EVENT);
}","public void showEvent(Event event){
  model.resetModel(NavigationEnum.EVENT_PREVIEW,getLoggedUser(),null,null,null,null,event);
  pushEvent(Events.EVENT_DISPLAYED_EVENT);
}"
18396,"public void showGPlusAlbum(){
  model.resetModel(NavigationEnum.GPLUS_ALBUM_PREVIEW,loggedUser,null,null,null,null);
}","public void showGPlusAlbum(){
  model.resetModel(NavigationEnum.GPLUS_ALBUM_PREVIEW,getLoggedUser(),null,null,null,null);
}"
18397,"public void showFbImage(String imageId){
  fac.setCurrentImageId(imageId);
  model.resetModel(NavigationEnum.FB_IMAGE_PREVIEW,loggedUser,null,null,null,null);
}","public void showFbImage(String imageId){
  fac.setCurrentImageId(imageId);
  model.resetModel(NavigationEnum.FB_IMAGE_PREVIEW,getLoggedUser(),null,null,null,null);
}"
18398,"public void onEventEdited(@Observes @EventType(Events.EVENT_EDITED_EVENT) ShelfEvent se){
  model.resetModel(NavigationEnum.EVENT_PREVIEW,loggedUser,null,null,null,null,se.getEvent());
  pushEvent(Events.EVENT_DISPLAYED_EVENT);
}","public void onEventEdited(@Observes @EventType(Events.EVENT_EDITED_EVENT) ShelfEvent se){
  model.resetModel(NavigationEnum.EVENT_PREVIEW,getLoggedUser(),null,null,null,null,se.getEvent());
  pushEvent(Events.EVENT_DISPLAYED_EVENT);
}"
18399,"public void showFBAlbum(String albumId){
  fac.setCurrentAlbumId(albumId);
  model.resetModel(NavigationEnum.FB_ALBUM_PREVIEW,loggedUser,null,null,null,null);
}","public void showFBAlbum(String albumId){
  fac.setCurrentAlbumId(albumId);
  model.resetModel(NavigationEnum.FB_ALBUM_PREVIEW,getLoggedUser(),null,null,null,null);
}"
18400,"public void showGPlusImage(String imageId){
  gpac.setCurrentImageId(imageId);
  model.resetModel(NavigationEnum.GPLUS_IMAGE_PREVIEW,loggedUser,null,null,null,null);
}","public void showGPlusImage(String imageId){
  gpac.setCurrentImageId(imageId);
  model.resetModel(NavigationEnum.GPLUS_IMAGE_PREVIEW,getLoggedUser(),null,null,null,null);
}"
18401,"public void showFbShelf(){
  model.resetModel(NavigationEnum.FB_SHELF,loggedUser,null,null,null,null);
}","public void showFbShelf(){
  model.resetModel(NavigationEnum.FB_SHELF,getLoggedUser(),null,null,null,null);
}"
18402,"public void showGPlusShelf(){
  model.resetModel(NavigationEnum.GPLUS_SHELF,loggedUser,null,null,null,null);
}","public void showGPlusShelf(){
  model.resetModel(NavigationEnum.GPLUS_SHELF,getLoggedUser(),null,null,null,null);
}"
18403,"public void onEventDeleted(@Observes @EventType(Events.EVENT_DELETED_EVENT) ShelfEvent se){
  model.resetModel(NavigationEnum.ANONYM,loggedUser,null,null,null,null,null);
}","public void onEventDeleted(@Observes @EventType(Events.EVENT_DELETED_EVENT) ShelfEvent se){
  model.resetModel(NavigationEnum.ANONYM,getLoggedUser(),null,null,null,null,null);
}"
18404,"public void onEventAdded(@Observes @EventType(Events.EVENT_ADDED_EVENT) ShelfEvent se){
  model.resetModel(NavigationEnum.EVENT_PREVIEW,loggedUser,null,null,null,null,se.getEvent());
  pushEvent(Events.EVENT_DISPLAYED_EVENT);
}","public void onEventAdded(@Observes @EventType(Events.EVENT_ADDED_EVENT) ShelfEvent se){
  model.resetModel(NavigationEnum.EVENT_PREVIEW,getLoggedUser(),null,null,null,null,se.getEvent());
  pushEvent(Events.EVENT_DISPLAYED_EVENT);
}"
18405,"public void processEvent(DropEvent event){
  String value=(String)event.getDragSource().getDragValue();
  dropValues.add(value);
  System.out.println(""String_Node_Str"");
}","public void processEvent(DropEvent event){
  String value=(String)event.getDragValue();
  dropValues.add(value);
  System.out.println(""String_Node_Str"");
}"
18406,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  final ToggleButton togglebutton=(ToggleButton)findViewById(R.id.ToggleButton01);
  runner=StrobeRunner.getInstance();
  if (runner.isRunning) {
  }
 else {
    cam=Camera.open();
    if (cam == null) {
      togglebutton.setEnabled(false);
      TextView t=(TextView)findViewById(R.id.TextView01);
      t.setText(R.string.nocamera);
      return;
    }
    cam.release();
  }
  togglebutton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      if (togglebutton.isChecked()) {
        bw=new Thread(runner);
        bw.start();
      }
 else {
        runner.requestStop=true;
      }
    }
  }
);
  final SeekBar skbar=(SeekBar)findViewById(R.id.SeekBar01);
  skbar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      runner.delay=progress;
    }
  }
);
  final SeekBar skbaroff=(SeekBar)findViewById(R.id.SeekBar02);
  skbaroff.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      runner.delayoff=progress;
    }
  }
);
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  final ToggleButton togglebutton=(ToggleButton)findViewById(R.id.ToggleButton01);
  runner=StrobeRunner.getInstance();
  runner.controller=this;
  if (runner.isRunning) {
  }
 else {
    try {
      cam=Camera.open();
      if (cam == null) {
        togglebutton.setEnabled(false);
        TextView t=(TextView)findViewById(R.id.TextView01);
        t.setText(R.string.nocamera);
        return;
      }
      cam.release();
    }
 catch (    RuntimeException ex) {
      togglebutton.setEnabled(false);
      TextView t=(TextView)findViewById(R.id.TextView01);
      t.setText(R.string.nocamera);
      Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_LONG).show();
      return;
    }
  }
  togglebutton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      if (togglebutton.isChecked()) {
        bw=new Thread(runner);
        bw.start();
      }
 else {
        runner.requestStop=true;
      }
    }
  }
);
  final SeekBar skbar=(SeekBar)findViewById(R.id.SeekBar01);
  skbar.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      runner.delay=progress;
    }
  }
);
  final SeekBar skbaroff=(SeekBar)findViewById(R.id.SeekBar02);
  skbaroff.setOnSeekBarChangeListener(new OnSeekBarChangeListener(){
    @Override public void onStopTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onStartTrackingTouch(    SeekBar seekBar){
    }
    @Override public void onProgressChanged(    SeekBar seekBar,    int progress,    boolean fromUser){
      runner.delayoff=progress;
    }
  }
);
}"
18407,"@Override public void run(){
  if (isRunning)   return;
  requestStop=false;
  isRunning=true;
  Camera cam=Camera.open();
  Camera.Parameters pon=cam.getParameters(), poff=cam.getParameters();
  pon.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
  poff.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
  while (!requestStop) {
    try {
      cam.setParameters(pon);
      Thread.sleep(delay);
      cam.setParameters(poff);
      Thread.sleep(delayoff);
    }
 catch (    InterruptedException ex) {
    }
  }
  cam.release();
  isRunning=false;
  requestStop=false;
}","@Override public void run(){
  if (isRunning)   return;
  requestStop=false;
  isRunning=true;
  Camera cam=Camera.open();
  Camera.Parameters pon=cam.getParameters(), poff=cam.getParameters();
  pon.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);
  poff.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
  while (!requestStop) {
    try {
      cam.setParameters(pon);
      Thread.sleep(delay);
      cam.setParameters(poff);
      Thread.sleep(delayoff);
    }
 catch (    InterruptedException ex) {
    }
catch (    RuntimeException ex) {
      requestStop=true;
      errorMessage=""String_Node_Str"";
    }
  }
  cam.release();
  isRunning=false;
  requestStop=false;
  controller.mHandler.post(controller.mShowToastRunnable);
}"
18408,"public void close() throws IOException {
  if (!open) {
    return;
  }
  open=false;
  flush();
  List<Entity> entities=new ArrayList<Entity>(buckets.size() + 1);
  Entity metaDataEntity=new Entity(GoogleAppEngineDirectory.META_KEY_KIND,fileName,dir.getIndexKey());
  metaDataEntity.setProperty(""String_Node_Str"",length);
  metaDataEntity.setProperty(""String_Node_Str"",System.currentTimeMillis());
  entities.add(metaDataEntity);
  for (int i=0; i < (buckets.size()); i++) {
    Entity contentEntity=new Entity(GoogleAppEngineDirectory.CONTENT_KEY_KIND,fileName + i,dir.getIndexKey());
    if (i == (buckets.size() - 1)) {
      byte[] buff=new byte[(int)(length - (bucketSize * i))];
      System.arraycopy(buckets.get(i),0,buff,0,buff.length);
      contentEntity.setProperty(""String_Node_Str"",new Blob(buff));
    }
 else {
      contentEntity.setProperty(""String_Node_Str"",new Blob(buckets.get(i)));
    }
    entities.add(contentEntity);
  }
  try {
    dir.getDatastoreService().put(entities);
  }
  finally {
    dir.getOnGoingIndexOutputs().remove(fileName);
  }
  currentBuffer=null;
}","public void close() throws IOException {
  if (!open) {
    return;
  }
  open=false;
  flush();
  List<Entity> entities=new ArrayList<Entity>(buckets.size() + 1);
  Entity metaDataEntity=new Entity(GoogleAppEngineDirectory.META_KEY_KIND,fileName,dir.getIndexKey());
  metaDataEntity.setProperty(""String_Node_Str"",length);
  metaDataEntity.setProperty(""String_Node_Str"",System.currentTimeMillis());
  entities.add(metaDataEntity);
  for (int i=0; i < (buckets.size()); i++) {
    Entity contentEntity=new Entity(GoogleAppEngineDirectory.CONTENT_KEY_KIND,fileName + i,metaDataEntity.getKey());
    if (i == (buckets.size() - 1)) {
      byte[] buff=new byte[(int)(length - (bucketSize * i))];
      System.arraycopy(buckets.get(i),0,buff,0,buff.length);
      contentEntity.setProperty(""String_Node_Str"",new Blob(buff));
    }
 else {
      contentEntity.setProperty(""String_Node_Str"",new Blob(buckets.get(i)));
    }
    entities.add(contentEntity);
  }
  try {
    dir.getDatastoreService().put(entities);
  }
  finally {
    dir.getOnGoingIndexOutputs().remove(fileName);
  }
  currentBuffer=null;
}"
18409,"public void closeDelegate() throws SearchEngineException {
}","public void closeDelegate() throws SearchEngineException {
  close(false);
}"
18410,"public void close() throws SearchEngineException {
}","private void close(boolean removeDelegate) throws SearchEngineException {
  if (internalSearch != null) {
    try {
      internalSearch.close();
    }
  finally {
      internalSearch=null;
      if (removeDelegate) {
        searchEngine.removeDelegatedClose(this);
      }
    }
  }
}"
18411,"public LuceneSearchEngineFactory(PropertyNamingStrategy propertyNamingStrategy,CompassSettings settings,CompassMapping mapping,ExecutorManager executorManager){
  this.propertyNamingStrategy=propertyNamingStrategy;
  this.mapping=mapping;
  this.executorManager=executorManager;
  this.settings=settings;
  this.luceneSettings=new LuceneSettings();
  luceneSettings.configure(settings);
  configure(settings,mapping);
}","public LuceneSearchEngineFactory(PropertyNamingStrategy propertyNamingStrategy,CompassSettings settings,CompassMapping mapping,ExecutorManager executorManager){
  this.propertyNamingStrategy=propertyNamingStrategy;
  this.mapping=mapping;
  this.executorManager=executorManager;
  this.settings=settings;
  this.luceneSettings=new LuceneSettings();
  luceneSettings.configure(settings);
  resourceFactory=new LuceneResourceFactory(this);
  analyzerManager=new LuceneAnalyzerManager();
  analyzerManager.configure(settings,mapping,luceneSettings);
  LuceneSearchEngineStore searchEngineStore=new DefaultLuceneSearchEngineStore();
  searchEngineStore.configure(this,settings,mapping);
  indexManager=new DefaultLuceneSearchEngineIndexManager(this,searchEngineStore);
  indexDeletionPolicyManager=new IndexDeletionPolicyFactory(indexManager);
  indexDeletionPolicyManager.configure(settings);
  try {
    ClassUtils.forName(""String_Node_Str"",settings.getClassLoader());
    highlighterManager=new LuceneHighlighterManager();
    highlighterManager.configure(settings);
  }
 catch (  ClassNotFoundException e1) {
    log.info(""String_Node_Str"");
  }
  searchEngineOptimizer=new LuceneSearchEngineOptimizerManager(this);
  ((CompassConfigurable)searchEngineOptimizer).configure(settings);
  if (settings.getSettingAsBoolean(LuceneEnvironment.SpellCheck.ENABLE,false)) {
    spellCheckManager=(InternalLuceneSearchEngineSpellCheckManager)settings.getSettingAsInstance(LuceneEnvironment.SpellCheck.CLASS,DefaultLuceneSpellCheckManager.class.getName());
    spellCheckManager.configure(this,settings,mapping);
  }
  queryParserManager=new LuceneQueryParserManager(this);
  queryParserManager.configure(settings);
  similarityManager=new LuceneSimilarityManager();
  similarityManager.configure(settings);
  transactionProcessorManager=new TransactionProcessorManager(this);
  debug=settings.getSettingAsBoolean(CompassEnvironment.DEBUG,false);
  if (debug) {
    debugOpenHoldersCount=new ConcurrentHashMap<String,AtomicInteger>();
  }
 else {
    debugOpenHoldersCount=null;
  }
}"
18412,"private LuceneIndexHolder internalRefreshCache(String subIndex) throws SearchEngineException {
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + subIndex + ""String_Node_Str"");
  }
  LuceneIndexHolder indexHolder=indexHolders.get(subIndex);
  if (indexHolder != null) {
    IndexReader reader;
    try {
      reader=indexHolder.getIndexReader().reopen();
    }
 catch (    IOException e) {
      throw new SearchEngineException(""String_Node_Str"" + subIndex + ""String_Node_Str"",e);
    }
    if (reader != indexHolder.getIndexReader()) {
      LuceneIndexHolder origHolder=indexHolder;
      indexHolder=new LuceneIndexHolder(subIndex,indexManager.openIndexSearcher(reader));
      LuceneIndexHolder oldHolder=indexHolders.put(subIndex,indexHolder);
      if (oldHolder != null) {
        oldHolder.markForClose();
      }
      origHolder.markForClose();
    }
 else {
      indexHolder.setInvalidated(false);
      indexHolder.markLastCacheInvalidation();
    }
  }
 else {
    try {
      IndexReader reader=IndexReader.open(indexManager.getDirectory(subIndex),true);
      indexHolder=new LuceneIndexHolder(subIndex,indexManager.openIndexSearcher(reader));
    }
 catch (    IOException e) {
      throw new SearchEngineException(""String_Node_Str"" + subIndex + ""String_Node_Str"",e);
    }
    LuceneIndexHolder oldHolder=indexHolders.put(subIndex,indexHolder);
    if (oldHolder != null) {
      oldHolder.markForClose();
    }
  }
  return indexHolder;
}","private LuceneIndexHolder internalRefreshCache(String subIndex) throws SearchEngineException {
  if (logger.isTraceEnabled()) {
    logger.trace(""String_Node_Str"" + subIndex + ""String_Node_Str"");
  }
  LuceneIndexHolder indexHolder=indexHolders.get(subIndex);
  if (indexHolder != null) {
    IndexReader reader;
    try {
      reader=indexHolder.getIndexReader().reopen();
    }
 catch (    IOException e) {
      throw new SearchEngineException(""String_Node_Str"" + subIndex + ""String_Node_Str"",e);
    }
    if (reader != indexHolder.getIndexReader()) {
      LuceneIndexHolder origHolder=indexHolder;
      indexHolder=new LuceneIndexHolder(indexManager.getSearchEngineFactory(),subIndex,indexManager.openIndexSearcher(reader));
      LuceneIndexHolder oldHolder=indexHolders.put(subIndex,indexHolder);
      if (oldHolder != null) {
        oldHolder.markForClose();
      }
      origHolder.markForClose();
    }
 else {
      indexHolder.setInvalidated(false);
      indexHolder.markLastCacheInvalidation();
    }
  }
 else {
    try {
      IndexReader reader=IndexReader.open(indexManager.getDirectory(subIndex),true);
      indexHolder=new LuceneIndexHolder(indexManager.getSearchEngineFactory(),subIndex,indexManager.openIndexSearcher(reader));
    }
 catch (    IOException e) {
      throw new SearchEngineException(""String_Node_Str"" + subIndex + ""String_Node_Str"",e);
    }
    LuceneIndexHolder oldHolder=indexHolders.put(subIndex,indexHolder);
    if (oldHolder != null) {
      oldHolder.markForClose();
    }
  }
  return indexHolder;
}"
18413,"public LuceneIndexHolder(String subIndex,IndexSearcher indexSearcher){
  this.subIndex=subIndex;
  this.indexSearcher=indexSearcher;
  this.indexReader=indexSearcher.getIndexReader();
}","public LuceneIndexHolder(LuceneSearchEngineFactory searchEngineFactory,String subIndex,IndexSearcher indexSearcher){
  this.searchEngineFactory=searchEngineFactory;
  this.subIndex=subIndex;
  this.indexSearcher=indexSearcher;
  this.indexReader=indexSearcher.getIndexReader();
  if (searchEngineFactory.isDebug()) {
    AtomicInteger count=searchEngineFactory.getDebugHoldersCount().get(subIndex);
    if (count == null) {
      AtomicInteger newCount=new AtomicInteger();
      count=searchEngineFactory.getDebugHoldersCount().putIfAbsent(subIndex,newCount);
      if (count == null) {
        count=newCount;
      }
    }
    count.incrementAndGet();
  }
}"
18414,"private void checkIfCanClose(){
  if (markForClose && count <= 0 && !closed) {
    closed=true;
    try {
      indexSearcher.close();
    }
 catch (    Exception e) {
    }
    try {
      indexReader.close();
    }
 catch (    Exception e) {
    }
  }
}","private void checkIfCanClose(){
  if (markForClose && count <= 0 && !closed) {
    if (searchEngineFactory.isDebug()) {
      searchEngineFactory.getDebugHoldersCount().get(subIndex).decrementAndGet();
    }
    closed=true;
    try {
      indexSearcher.close();
    }
 catch (    Exception e) {
    }
    try {
      indexReader.close();
    }
 catch (    Exception e) {
    }
  }
}"
18415,"protected IndexEntity[] doGetIndexEntities() throws CompassGpsException {
  ExtendedSqlMapClient extSqlMapClient=(ExtendedSqlMapClient)sqlMapClient;
  IndexEntity[] entities=new IndexEntity[selectStatementsIds.length];
  for (int i=0; i < selectStatementsIds.length; i++) {
    String statementId=selectStatementsIds[i];
    MappedStatement statement=extSqlMapClient.getDelegate().getMappedStatement(statementId);
    if (statement == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + statementId + ""String_Node_Str"");
    }
    Class resultClass=statement.getResultMap().getResultClass();
    ResourceMapping resourceMapping=((CompassGpsInterfaceDevice)getGps()).getMappingForEntityForIndex(resultClass);
    if (resourceMapping == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + resultClass.getClass() + ""String_Node_Str"");
    }
    Object parameterObject=null;
    if (statementsParameterObjects != null) {
      parameterObject=statementsParameterObjects[i];
    }
    entities[i]=new SqlMapIndexEntity(resultClass.getName(),resourceMapping.getSubIndexHash().getSubIndexes(),statementId,parameterObject);
  }
  return entities;
}","protected IndexEntity[] doGetIndexEntities() throws CompassGpsException {
  ExtendedSqlMapClient extSqlMapClient=(ExtendedSqlMapClient)sqlMapClient;
  IndexEntity[] entities=new IndexEntity[selectStatementsIds.length];
  for (int i=0; i < selectStatementsIds.length; i++) {
    String statementId=selectStatementsIds[i];
    MappedStatement statement=extSqlMapClient.getDelegate().getMappedStatement(statementId);
    if (statement == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + statementId + ""String_Node_Str"");
    }
    Class resultClass=statement.getResultMap().getResultClass();
    ResourceMapping resourceMapping=((CompassGpsInterfaceDevice)getGps()).getMappingForEntityForIndex(resultClass);
    if (resourceMapping == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + resultClass.getName() + ""String_Node_Str"");
    }
    Object parameterObject=null;
    if (statementsParameterObjects != null) {
      parameterObject=statementsParameterObjects[i];
    }
    entities[i]=new SqlMapIndexEntity(resultClass.getName(),resourceMapping.getSubIndexHash().getSubIndexes(),statementId,parameterObject);
  }
  return entities;
}"
18416,"public void testPolyQuery() throws Exception {
  CompassSession session=openSession();
  CompassTransaction tr=session.beginTransaction();
  Long id=new Long(1);
  ExtendsA extendsA=new ExtendsA();
  extendsA.setId(id);
  extendsA.setValue(""String_Node_Str"");
  extendsA.setExtendsValue(""String_Node_Str"");
  session.save(""String_Node_Str"",extendsA);
  extendsA=(ExtendsA)session.load(""String_Node_Str"",id);
  assertEquals(""String_Node_Str"",extendsA.getValue());
  id=new Long(1);
  extendsA=new ExtendsA();
  extendsA.setId(id);
  extendsA.setValue(""String_Node_Str"");
  extendsA.setExtendsValue(""String_Node_Str"");
  session.save(""String_Node_Str"",extendsA);
  extendsA=(ExtendsA)session.load(""String_Node_Str"",id);
  assertEquals(""String_Node_Str"",extendsA.getValue());
  CompassHits hits=session.queryBuilder().polyAlias(""String_Node_Str"").hits();
  assertEquals(2,hits.length());
  tr.commit();
  session.close();
}","public void testPolyQuery() throws Exception {
  CompassSession session=openSession();
  CompassTransaction tr=session.beginTransaction();
  Long id=new Long(1);
  ExtendsA extendsA=new ExtendsA();
  extendsA.setId(id);
  extendsA.setValue(""String_Node_Str"");
  extendsA.setExtendsValue(""String_Node_Str"");
  session.save(""String_Node_Str"",extendsA);
  extendsA=(ExtendsA)session.load(""String_Node_Str"",id);
  assertEquals(""String_Node_Str"",extendsA.getValue());
  id=new Long(1);
  extendsA=new ExtendsA();
  extendsA.setId(id);
  extendsA.setValue(""String_Node_Str"");
  extendsA.setExtendsValue(""String_Node_Str"");
  session.save(""String_Node_Str"",extendsA);
  extendsA=(ExtendsA)session.load(""String_Node_Str"",id);
  assertEquals(""String_Node_Str"",extendsA.getValue());
  CompassHits hits=session.queryBuilder().polyAlias(""String_Node_Str"").hits();
  assertEquals(2,hits.length());
  hits=session.find(""String_Node_Str"");
  assertEquals(2,hits.length());
  tr.commit();
  session.close();
}"
18417,"public void operate(final IndexOperationCallback callback) throws SearchEngineException {
  final String[] subIndexes=searchEngineStore.getSubIndexes();
  final Lock[] writerLocks=new Lock[subIndexes.length];
  final Lock[] commitLocks=new Lock[subIndexes.length];
  try {
    try {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"");
      }
      for (int i=0; i < subIndexes.length; i++) {
        Directory dir=getDirectory(subIndexes[i]);
        writerLocks[i]=dir.makeLock(IndexWriter.WRITE_LOCK_NAME);
        writerLocks[i].obtain(luceneSettings.getTransactionLockTimout());
      }
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new SearchEngineException(""String_Node_Str"",e);
    }
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    boolean continueToSecondStep=callback.firstStep();
    if (!continueToSecondStep) {
      return;
    }
    clearCache();
    notifyAllToClearCache();
    if (waitForCacheInvalidationBeforeSecondStep != 0 && luceneSettings.isWaitForCacheInvalidationOnIndexOperation()) {
      try {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + waitForCacheInvalidationBeforeSecondStep + ""String_Node_Str"");
        }
        Thread.sleep(waitForCacheInvalidationBeforeSecondStep);
      }
 catch (      InterruptedException e) {
        log.debug(""String_Node_Str"",e);
        throw new SearchEngineException(""String_Node_Str"",e);
      }
    }
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    callback.secondStep();
  }
  finally {
    LuceneUtils.clearLocks(commitLocks);
    LuceneUtils.clearLocks(writerLocks);
  }
}","public void operate(final IndexOperationCallback callback) throws SearchEngineException {
  final String[] subIndexes=searchEngineStore.getSubIndexes();
  final Lock[] writerLocks=new Lock[subIndexes.length];
  try {
    try {
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"");
      }
      for (int i=0; i < subIndexes.length; i++) {
        Directory dir=getDirectory(subIndexes[i]);
        writerLocks[i]=dir.makeLock(IndexWriter.WRITE_LOCK_NAME);
        writerLocks[i].obtain(luceneSettings.getTransactionLockTimout());
      }
      if (log.isDebugEnabled()) {
        log.debug(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      throw new SearchEngineException(""String_Node_Str"",e);
    }
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    boolean continueToSecondStep=callback.firstStep();
    if (!continueToSecondStep) {
      return;
    }
    clearCache();
    notifyAllToClearCache();
    if (waitForCacheInvalidationBeforeSecondStep != 0 && luceneSettings.isWaitForCacheInvalidationOnIndexOperation()) {
      try {
        if (log.isDebugEnabled()) {
          log.debug(""String_Node_Str"" + waitForCacheInvalidationBeforeSecondStep + ""String_Node_Str"");
        }
        Thread.sleep(waitForCacheInvalidationBeforeSecondStep);
      }
 catch (      InterruptedException e) {
        log.debug(""String_Node_Str"",e);
        throw new SearchEngineException(""String_Node_Str"",e);
      }
    }
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    callback.secondStep();
  }
  finally {
    LuceneUtils.clearLocks(writerLocks);
  }
}"
18418,"public void deleteFile(String name) throws IOException {
  if (shouldPerformOperationOnActualDirectory(name)) {
    dir.deleteFile(name);
    if (log.isTraceEnabled()) {
      log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
    }
  }
  if (localCacheDir.fileExists(name)) {
    if (log.isTraceEnabled()) {
      log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
    }
    localCacheDir.deleteFile(name);
  }
  if (searchEngineFactory.getLuceneSettings().isUseCompoundFile() && IndexFileNameFilter.getFilter().isCFSFile(name)) {
    return;
  }
  dir.deleteFile(name);
  if (log.isTraceEnabled()) {
    log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
  }
}","public void deleteFile(String name) throws IOException {
  if (shouldPerformOperationOnActualDirectory(name)) {
    dir.deleteFile(name);
    if (log.isTraceEnabled()) {
      log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
    }
    return;
  }
  if (localCacheDir.fileExists(name)) {
    if (log.isTraceEnabled()) {
      log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
    }
    localCacheDir.deleteFile(name);
  }
  if (searchEngineFactory.getLuceneSettings().isUseCompoundFile() && IndexFileNameFilter.getFilter().isCFSFile(name)) {
    return;
  }
  dir.deleteFile(name);
  if (log.isTraceEnabled()) {
    log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
  }
}"
18419,"public LocalDirectoryCache(String subIndex,Directory dir,Directory localCacheDir,int bufferSize,LuceneSearchEngineFactory searchEngineFactory){
  this.subIndex=subIndex;
  this.dir=dir;
  this.localCacheDir=localCacheDir;
  this.bufferSize=bufferSize;
  this.searchEngineFactory=searchEngineFactory;
}","public LocalDirectoryCache(String subIndex,Directory dir,Directory localCacheDir,int bufferSize,LuceneSearchEngineFactory searchEngineFactory){
  this.subIndex=subIndex;
  this.dir=dir;
  this.localCacheDir=localCacheDir;
  this.bufferSize=bufferSize;
  this.searchEngineFactory=searchEngineFactory;
  for (int i=0; i < monitors.length; i++) {
    monitors[i]=new Object();
  }
}"
18420,"public void touchFile(String name) throws IOException {
  if (shouldPerformOperationOnActualDirectory(name)) {
    dir.touchFile(name);
  }
  fetchFileIfNotExists(name);
  localCacheDir.touchFile(name);
  dir.touchFile(name);
}","public void touchFile(String name) throws IOException {
  if (shouldPerformOperationOnActualDirectory(name)) {
    dir.touchFile(name);
    return;
  }
  fetchFileIfNotExists(name);
  localCacheDir.touchFile(name);
  dir.touchFile(name);
}"
18421,"private void fetchFileIfNotExists(String name) throws IOException {
  if (localCacheDir.fileExists(name)) {
    return;
  }
  if (log.isTraceEnabled()) {
    log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
  }
  copy(dir,localCacheDir,name);
}","private void fetchFileIfNotExists(String name) throws IOException {
synchronized (monitors[Math.abs(name.hashCode()) % monitors.length]) {
    if (localCacheDir.fileExists(name)) {
      return;
    }
    if (log.isTraceEnabled()) {
      log.trace(logMessage(""String_Node_Str"" + name + ""String_Node_Str""));
    }
    copy(dir,localCacheDir,name);
  }
}"
18422,"public void renameFile(String from,String to) throws IOException {
  if (shouldPerformOperationOnActualDirectory(from)) {
    dir.renameFile(from,to);
  }
  fetchFileIfNotExists(from);
  localCacheDir.renameFile(from,to);
  dir.renameFile(from,to);
}","public void renameFile(String from,String to) throws IOException {
  if (shouldPerformOperationOnActualDirectory(from)) {
    dir.renameFile(from,to);
    return;
  }
  fetchFileIfNotExists(from);
  localCacheDir.renameFile(from,to);
  dir.renameFile(from,to);
}"
18423,"public long fileModified(String name) throws IOException {
  if (shouldPerformOperationOnActualDirectory(name)) {
    return dir.fileLength(name);
  }
  fetchFileIfNotExists(name);
  return localCacheDir.fileModified(name);
}","public long fileModified(String name) throws IOException {
  if (shouldPerformOperationOnActualDirectory(name)) {
    return dir.fileModified(name);
  }
  fetchFileIfNotExists(name);
  return localCacheDir.fileModified(name);
}"
18424,"public TransIndexManager(LuceneSearchEngineFactory searchEngineFactory){
  this.indexManager=searchEngineFactory.getLuceneIndexManager();
  this.luceneSettings=searchEngineFactory.getLuceneSettings();
}","public TransIndexManager(LuceneSearchEngineFactory searchEngineFactory){
  this.indexManager=searchEngineFactory.getLuceneIndexManager();
}"
18425,"private void bindReference(ConfigurationHelper referenceConf,AliasMapping aliasMapping,ReferenceMapping referenceMapping){
  String name=referenceConf.getAttribute(""String_Node_Str"");
  referenceMapping.setName(name);
  String refAlias=referenceConf.getAttribute(""String_Node_Str"",null);
  referenceMapping.setRefAliases(getAliases(refAlias));
  referenceMapping.setDefinedInAlias(aliasMapping.getAlias());
  String refCompAlias=referenceConf.getAttribute(""String_Node_Str"",null);
  if (refCompAlias != null) {
    referenceMapping.setRefCompAlias(valueLookup.lookupAliasName(refCompAlias));
  }
  bindConverter(referenceConf,referenceMapping);
  referenceMapping.setAccessor(referenceConf.getAttribute(""String_Node_Str"",null));
  if (aliasMapping instanceof ClassMapping) {
    referenceMapping.setObjClass(((ClassMapping)aliasMapping).getClazz());
  }
  referenceMapping.setPropertyName(name);
}","private void bindReference(ConfigurationHelper referenceConf,AliasMapping aliasMapping,ReferenceMapping referenceMapping){
  String name=referenceConf.getAttribute(""String_Node_Str"");
  referenceMapping.setName(name);
  String refAlias=referenceConf.getAttribute(""String_Node_Str"",null);
  referenceMapping.setRefAliases(getAliases(refAlias));
  referenceMapping.setDefinedInAlias(aliasMapping.getAlias());
  String refCompAlias=referenceConf.getAttribute(""String_Node_Str"",null);
  if (refCompAlias != null) {
    referenceMapping.setRefCompAlias(valueLookup.lookupAliasName(refCompAlias));
  }
  bindConverter(referenceConf,referenceMapping);
  referenceMapping.setAccessor(referenceConf.getAttribute(""String_Node_Str"",null));
  referenceMapping.setPropertyName(name);
}"
18426,"private void bindParent(ConfigurationHelper parentConf,AliasMapping aliasMapping,ParentMapping parentMapping){
  String name=parentConf.getAttribute(""String_Node_Str"");
  parentMapping.setName(name);
  bindConverter(parentConf,parentMapping);
  parentMapping.setAccessor(parentConf.getAttribute(""String_Node_Str"",null));
  if (aliasMapping instanceof ClassMapping) {
    parentMapping.setObjClass(((ClassMapping)aliasMapping).getClazz());
  }
  parentMapping.setPropertyName(name);
  parentMapping.setDefinedInAlias(aliasMapping.getAlias());
}","private void bindParent(ConfigurationHelper parentConf,AliasMapping aliasMapping,ParentMapping parentMapping){
  String name=parentConf.getAttribute(""String_Node_Str"");
  parentMapping.setName(name);
  bindConverter(parentConf,parentMapping);
  parentMapping.setAccessor(parentConf.getAttribute(""String_Node_Str"",null));
  parentMapping.setPropertyName(name);
  parentMapping.setDefinedInAlias(aliasMapping.getAlias());
}"
18427,"private void bindComponent(ConfigurationHelper componentConf,AliasMapping aliasMapping,ComponentMapping compMapping){
  String name=componentConf.getAttribute(""String_Node_Str"");
  compMapping.setName(name);
  String refAlias=componentConf.getAttribute(""String_Node_Str"",null);
  compMapping.setRefAliases(getAliases(refAlias));
  compMapping.setDefinedInAlias(aliasMapping.getAlias());
  int maxDepth=componentConf.getAttributeAsInteger(""String_Node_Str"",1);
  compMapping.setMaxDepth(maxDepth);
  bindConverter(componentConf,compMapping);
  compMapping.setAccessor(componentConf.getAttribute(""String_Node_Str"",null));
  if (aliasMapping instanceof ClassMapping) {
    compMapping.setObjClass(((ClassMapping)aliasMapping).getClazz());
  }
  compMapping.setPropertyName(name);
  boolean override=componentConf.getAttributeAsBoolean(""String_Node_Str"",true);
  compMapping.setOverrideByName(override);
}","private void bindComponent(ConfigurationHelper componentConf,AliasMapping aliasMapping,ComponentMapping compMapping){
  String name=componentConf.getAttribute(""String_Node_Str"");
  compMapping.setName(name);
  String refAlias=componentConf.getAttribute(""String_Node_Str"",null);
  compMapping.setRefAliases(getAliases(refAlias));
  compMapping.setDefinedInAlias(aliasMapping.getAlias());
  int maxDepth=componentConf.getAttributeAsInteger(""String_Node_Str"",1);
  compMapping.setMaxDepth(maxDepth);
  bindConverter(componentConf,compMapping);
  compMapping.setAccessor(componentConf.getAttribute(""String_Node_Str"",null));
  compMapping.setPropertyName(name);
  boolean override=componentConf.getAttributeAsBoolean(""String_Node_Str"",true);
  compMapping.setOverrideByName(override);
}"
18428,"private void bindClassProperty(ConfigurationHelper classPropertyConf,AliasMapping aliasMapping,ClassPropertyMapping classPropertyMapping){
  String name=classPropertyConf.getAttribute(""String_Node_Str"");
  classPropertyMapping.setName(name);
  String sClass=classPropertyConf.getAttribute(""String_Node_Str"",null);
  classPropertyMapping.setClassName(sClass);
  classPropertyMapping.setDefinedInAlias(aliasMapping.getAlias());
  classPropertyMapping.setBoost(getBoost(classPropertyConf));
  classPropertyMapping.setColClassName(classPropertyConf.getAttribute(""String_Node_Str"",null));
  classPropertyMapping.setAccessor(classPropertyConf.getAttribute(""String_Node_Str"",null));
  if (aliasMapping instanceof ClassMapping) {
    classPropertyMapping.setObjClass(((ClassMapping)aliasMapping).getClazz());
  }
  classPropertyMapping.setPropertyName(name);
  classPropertyMapping.setAnalyzer(classPropertyConf.getAttribute(""String_Node_Str"",null));
  boolean excludeFromAll=classPropertyConf.getAttributeAsBoolean(""String_Node_Str"",false);
  classPropertyMapping.setExcludeFromAll(excludeFromAll);
  String managedId=classPropertyConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  classPropertyMapping.setManagedId(ClassPropertyMapping.ManagedId.fromString(managedId));
  String managedIdIndex=classPropertyConf.getAttribute(""String_Node_Str"",null);
  if (managedIdIndex != null) {
    classPropertyMapping.setManagedIdIndex(Property.Index.fromString(managedIdIndex));
  }
  classPropertyMapping.setManagedIdConverterName(classPropertyConf.getAttribute(""String_Node_Str"",null));
  boolean override=classPropertyConf.getAttributeAsBoolean(""String_Node_Str"",true);
  classPropertyMapping.setOverrideByName(override);
  bindConverter(classPropertyConf,classPropertyMapping);
  ConfigurationHelper[] metadatas=classPropertyConf.getChildren(""String_Node_Str"");
  for (int i=0; i < metadatas.length; i++) {
    ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
    bindMetaData(metadatas[i],aliasMapping,classPropertyMapping,mdMapping);
    classPropertyMapping.addMapping(mdMapping);
  }
}","private void bindClassProperty(ConfigurationHelper classPropertyConf,AliasMapping aliasMapping,ClassPropertyMapping classPropertyMapping){
  String name=classPropertyConf.getAttribute(""String_Node_Str"");
  classPropertyMapping.setName(name);
  String sClass=classPropertyConf.getAttribute(""String_Node_Str"",null);
  classPropertyMapping.setClassName(sClass);
  classPropertyMapping.setDefinedInAlias(aliasMapping.getAlias());
  classPropertyMapping.setBoost(getBoost(classPropertyConf));
  classPropertyMapping.setColClassName(classPropertyConf.getAttribute(""String_Node_Str"",null));
  classPropertyMapping.setAccessor(classPropertyConf.getAttribute(""String_Node_Str"",null));
  classPropertyMapping.setPropertyName(name);
  classPropertyMapping.setAnalyzer(classPropertyConf.getAttribute(""String_Node_Str"",null));
  boolean excludeFromAll=classPropertyConf.getAttributeAsBoolean(""String_Node_Str"",false);
  classPropertyMapping.setExcludeFromAll(excludeFromAll);
  String managedId=classPropertyConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  classPropertyMapping.setManagedId(ClassPropertyMapping.ManagedId.fromString(managedId));
  String managedIdIndex=classPropertyConf.getAttribute(""String_Node_Str"",null);
  if (managedIdIndex != null) {
    classPropertyMapping.setManagedIdIndex(Property.Index.fromString(managedIdIndex));
  }
  classPropertyMapping.setManagedIdConverterName(classPropertyConf.getAttribute(""String_Node_Str"",null));
  boolean override=classPropertyConf.getAttributeAsBoolean(""String_Node_Str"",true);
  classPropertyMapping.setOverrideByName(override);
  bindConverter(classPropertyConf,classPropertyMapping);
  ConfigurationHelper[] metadatas=classPropertyConf.getChildren(""String_Node_Str"");
  for (int i=0; i < metadatas.length; i++) {
    ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
    bindMetaData(metadatas[i],aliasMapping,classPropertyMapping,mdMapping);
    classPropertyMapping.addMapping(mdMapping);
  }
}"
18429,"private void bindMetaData(ConfigurationHelper metadataConf,AliasMapping aliasMapping,ClassPropertyMapping classPropertyMapping,ClassPropertyMetaDataMapping mdMapping){
  if (!StringUtils.hasText(metadataConf.getValue())) {
    throw new MappingException(""String_Node_Str"" + aliasMapping.getAlias() + ""String_Node_Str""+ classPropertyMapping.getName()+ ""String_Node_Str"");
  }
  String name=valueLookup.lookupMetaDataName(metadataConf.getValue().trim());
  mdMapping.setBoost(getBoost(metadataConf,classPropertyMapping.getBoost()));
  mdMapping.setName(name);
  mdMapping.setPath(new StaticPropertyPath(name));
  mdMapping.setAccessor(classPropertyMapping.getAccessor());
  mdMapping.setObjClass(classPropertyMapping.getObjClass());
  mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
  bindConverter(metadataConf,mdMapping);
  String format=metadataConf.getAttribute(""String_Node_Str"",null);
  if (mdMapping.getConverter() == null) {
    if (format == null) {
      format=valueLookup.lookupMetaDataFormat(metadataConf.getValue().trim());
    }
    if (format != null) {
      mdMapping.setConverter(new MetaDataFormatDelegateConverter(format));
    }
  }
 else {
    if (format != null) {
      throw new ConfigurationException(""String_Node_Str"" + classPropertyMapping.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  String storeType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setStore(Property.Store.fromString(storeType));
  String indexType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setIndex(Property.Index.fromString(indexType));
  String termVectorType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setTermVector(Property.TermVector.fromString(termVectorType));
  String reverseType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setReverse(ResourcePropertyMapping.ReverseType.fromString(reverseType));
  mdMapping.setInternal(false);
  mdMapping.setAnalyzer(metadataConf.getAttribute(""String_Node_Str"",classPropertyMapping.getAnalyzer()));
  boolean excludeFromAll=metadataConf.getAttributeAsBoolean(""String_Node_Str"",classPropertyMapping.isExcludeFromAll());
  mdMapping.setExcludeFromAll(excludeFromAll);
}","private void bindMetaData(ConfigurationHelper metadataConf,AliasMapping aliasMapping,ClassPropertyMapping classPropertyMapping,ClassPropertyMetaDataMapping mdMapping){
  if (!StringUtils.hasText(metadataConf.getValue())) {
    throw new MappingException(""String_Node_Str"" + aliasMapping.getAlias() + ""String_Node_Str""+ classPropertyMapping.getName()+ ""String_Node_Str"");
  }
  String name=valueLookup.lookupMetaDataName(metadataConf.getValue().trim());
  mdMapping.setBoost(getBoost(metadataConf,classPropertyMapping.getBoost()));
  mdMapping.setName(name);
  mdMapping.setPath(new StaticPropertyPath(name));
  mdMapping.setAccessor(classPropertyMapping.getAccessor());
  mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
  bindConverter(metadataConf,mdMapping);
  String format=metadataConf.getAttribute(""String_Node_Str"",null);
  if (mdMapping.getConverter() == null) {
    if (format == null) {
      format=valueLookup.lookupMetaDataFormat(metadataConf.getValue().trim());
    }
    if (format != null) {
      mdMapping.setConverter(new MetaDataFormatDelegateConverter(format));
    }
  }
 else {
    if (format != null) {
      throw new ConfigurationException(""String_Node_Str"" + classPropertyMapping.getName() + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  String storeType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setStore(Property.Store.fromString(storeType));
  String indexType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setIndex(Property.Index.fromString(indexType));
  String termVectorType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setTermVector(Property.TermVector.fromString(termVectorType));
  String reverseType=metadataConf.getAttribute(""String_Node_Str"",""String_Node_Str"");
  mdMapping.setReverse(ResourcePropertyMapping.ReverseType.fromString(reverseType));
  mdMapping.setInternal(false);
  mdMapping.setAnalyzer(metadataConf.getAttribute(""String_Node_Str"",classPropertyMapping.getAnalyzer()));
  boolean excludeFromAll=metadataConf.getAttributeAsBoolean(""String_Node_Str"",classPropertyMapping.isExcludeFromAll());
  mdMapping.setExcludeFromAll(excludeFromAll);
}"
18430,"private void processMapping(Mapping mapping,Object fatherObject,PropertyAccessorFactory propertyAccessorFactory) throws MappingException {
  if (!(mapping instanceof ObjectMapping)) {
    return;
  }
  ObjectMapping objectMapping=(ObjectMapping)mapping;
  Class clazz=objectMapping.getObjClass();
  if (clazz == null) {
    if (fatherObject instanceof ObjectMapping) {
      clazz=((ObjectMapping)fatherObject).getObjClass();
    }
 else {
      clazz=(Class)fatherObject;
    }
    objectMapping.setObjClass(clazz);
  }
  PropertyAccessor pAccessor=propertyAccessorFactory.getPropertyAccessor(objectMapping.getAccessor());
  objectMapping.setGetter(pAccessor.getGetter(clazz,objectMapping.getPropertyName()));
  objectMapping.setSetter(pAccessor.getSetter(clazz,objectMapping.getPropertyName()));
  if (mapping instanceof MultipleMapping) {
    MultipleMapping multipleMapping=(MultipleMapping)mapping;
    for (Iterator it=multipleMapping.mappingsIt(); it.hasNext(); ) {
      processMapping((Mapping)it.next(),objectMapping,propertyAccessorFactory);
    }
  }
}","private void processMapping(Mapping mapping,Class clazz,PropertyAccessorFactory propertyAccessorFactory) throws MappingException {
  if (!(mapping instanceof ObjectMapping)) {
    return;
  }
  ObjectMapping objectMapping=(ObjectMapping)mapping;
  objectMapping.setObjClass(clazz);
  PropertyAccessor pAccessor=propertyAccessorFactory.getPropertyAccessor(objectMapping.getAccessor());
  objectMapping.setGetter(pAccessor.getGetter(clazz,objectMapping.getPropertyName()));
  objectMapping.setSetter(pAccessor.getSetter(clazz,objectMapping.getPropertyName()));
  if (mapping instanceof MultipleMapping) {
    MultipleMapping multipleMapping=(MultipleMapping)mapping;
    for (Iterator it=multipleMapping.mappingsIt(); it.hasNext(); ) {
      processMapping((Mapping)it.next(),clazz,propertyAccessorFactory);
    }
  }
}"
18431,"/** 
 * Since we did not process duplicate mappings, we need to replace them with the original mappings that were processed (for example, we added intenral ids to it where needed).
 */
protected void onDuplicateMapping(ClassMapping classMapping,ObjectMapping actualMapping,ObjectMapping duplicateMapping){
  Assert.isTrue(actualMapping.getName().equals(duplicateMapping.getName()),""String_Node_Str"" + duplicateMapping + ""String_Node_Str""+ actualMapping.getName()+ ""String_Node_Str"");
  classMapping.mappingsByNameMap.put(duplicateMapping.getName(),actualMapping);
  int index=classMapping.mappings.indexOf(duplicateMapping);
  if (index < 0) {
    for (int i=0; i < classMapping.mappings.size(); i++) {
      Object o=classMapping.mappings.get(i);
      if (o instanceof AbstractCollectionMapping) {
        AbstractCollectionMapping temp=(AbstractCollectionMapping)o;
        if (temp.getElementMapping() == duplicateMapping) {
          temp.setElementMapping(actualMapping);
          index=i;
          break;
        }
      }
    }
  }
  if (index < 0) {
    throw new IllegalStateException(""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str"");
  }
 else {
    classMapping.mappings.set(index,actualMapping);
  }
}","/** 
 * <p>Since we did not process duplicate mappings, we need to replace them with the original mappings that were processed (for example, we added intenral ids to it where needed).
 */
protected void onDuplicateMapping(ClassMapping classMapping,ObjectMapping actualMapping,ObjectMapping duplicateMapping){
  Assert.isTrue(actualMapping.getName().equals(duplicateMapping.getName()),""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str""+ actualMapping.getName()+ ""String_Node_Str"");
  int index=classMapping.mappings.indexOf(duplicateMapping);
  if (index < 0) {
    for (int i=0; i < classMapping.mappings.size(); i++) {
      Object o=classMapping.mappings.get(i);
      if (o instanceof AbstractCollectionMapping) {
        AbstractCollectionMapping temp=(AbstractCollectionMapping)o;
        if (temp.getElementMapping() == duplicateMapping) {
          temp.setElementMapping(actualMapping);
          index=i;
          break;
        }
      }
    }
  }
 else {
    classMapping.mappingsByNameMap.put(duplicateMapping.getName(),actualMapping);
    classMapping.mappings.set(index,actualMapping);
  }
  if (index < 0) {
    throw new IllegalStateException(""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str"");
  }
}"
18432,"public void testPersons() throws Exception {
  CompassSession session=openSession();
  CompassTransaction tr=session.beginTransaction();
  Person person=new SpecialPerson();
  person.id=1;
  person.description=""String_Node_Str"";
  person.names=new ArrayList();
  PersonName personName=new PersonName();
  personName.names=new ArrayList();
  personName.names.add(""String_Node_Str"");
  personName.names.add(""String_Node_Str"");
  person.names.add(personName);
  session.save(person);
  person=(Person)session.load(SpecialPerson.class,new Integer(1));
  assertEquals(""String_Node_Str"",person.description);
  assertEquals(1,person.names.size());
  tr.commit();
  session.close();
}","public void testPersons() throws Exception {
  CompassSession session=openSession();
  CompassTransaction tr=session.beginTransaction();
  Person person=new SpecialPerson();
  person.id=1;
  person.description=""String_Node_Str"";
  person.names=new ArrayList();
  PersonName personName=new PersonName();
  personName.names=new ArrayList();
  personName.names.add(""String_Node_Str"");
  personName.names.add(""String_Node_Str"");
  person.names.add(personName);
  session.save(person);
  User user=new User();
  user.id=1;
  user.description=""String_Node_Str"";
  user.identity=person;
  session.save(user);
  person=(Person)session.load(SpecialPerson.class,new Integer(1));
  assertEquals(""String_Node_Str"",person.description);
  assertEquals(1,person.names.size());
  personName=(PersonName)person.names.get(0);
  assertEquals(2,personName.names.size());
  user=(User)session.load(User.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",user.description);
  person=user.identity;
  assertEquals(""String_Node_Str"",person.description);
  assertEquals(1,person.names.size());
  personName=(PersonName)person.names.get(0);
  assertEquals(2,personName.names.size());
  tr.commit();
  session.close();
}"
18433,"/** 
 * <p>Since we did not process duplicate mappings, we need to replace them with the original mappings that were processed (for example, we added intenral ids to it where needed).
 */
protected void onDuplicateMapping(ClassMapping classMapping,ObjectMapping actualMapping,ObjectMapping duplicateMapping){
  Assert.isTrue(actualMapping.getName().equals(duplicateMapping.getName()),""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str""+ actualMapping.getName()+ ""String_Node_Str"");
  int index=classMapping.mappings.indexOf(duplicateMapping);
  if (index < 0) {
    for (int i=0; i < classMapping.mappings.size(); i++) {
      Object o=classMapping.mappings.get(i);
      if (o instanceof AbstractCollectionMapping) {
        AbstractCollectionMapping temp=(AbstractCollectionMapping)o;
        if (temp.getElementMapping() == duplicateMapping) {
          temp.setElementMapping(actualMapping);
          index=i;
          break;
        }
      }
    }
  }
 else {
    classMapping.mappingsByNameMap.put(duplicateMapping.getName(),actualMapping);
    classMapping.mappings.set(index,actualMapping);
  }
  if (index < 0) {
    throw new IllegalStateException(""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str"");
  }
}","/** 
 * <p>Since we did not process duplicate mappings, we need to replace them with the original mappings that were processed (for example, we added intenral ids to it where needed).
 */
protected void onDuplicateMapping(ClassMapping classMapping,ObjectMapping actualMapping,ObjectMapping duplicateMapping){
  Assert.isTrue(actualMapping.getPropertyName().equals(duplicateMapping.getPropertyName()),""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str""+ actualMapping.getName()+ ""String_Node_Str"");
  int index=classMapping.mappings.indexOf(duplicateMapping);
  if (index < 0) {
    for (int i=0; i < classMapping.mappings.size(); i++) {
      Object o=classMapping.mappings.get(i);
      if (o instanceof AbstractCollectionMapping) {
        AbstractCollectionMapping temp=(AbstractCollectionMapping)o;
        if (temp.getElementMapping() == duplicateMapping) {
          temp.setElementMapping(actualMapping);
          index=i;
          break;
        }
      }
    }
  }
 else {
    classMapping.mappingsByNameMap.put(duplicateMapping.getName(),actualMapping);
    classMapping.mappings.set(index,actualMapping);
  }
  if (index < 0) {
    throw new IllegalStateException(""String_Node_Str"" + duplicateMapping.getName() + ""String_Node_Str"");
  }
}"
18434,void setAccessor(String accessor);,"/** 
 * Sets the accessor type for this mapping. The accessor type can be field, property or a custom implementation of   {@link org.compass.core.accessor.PropertyAccessor}(this can be either the FQN of the class name or a regsitered type in the configuration, see  {@link org.compass.core.accessor.PropertyAccessorFactory}.
 */
void setAccessor(String accessor);"
18435,void setPropertyName(String propertyName);,"/** 
 * Sets the class property name of the object mapping.
 */
void setPropertyName(String propertyName);"
18436,Class getObjClass();,"/** 
 * Returns the class of the class mapping this object belongs to.
 */
Class getObjClass();"
18437,String getAccessor();,"/** 
 * Returns the accessor type for this mapping. The accessor type can be field, property or a custom implementation of   {@link org.compass.core.accessor.PropertyAccessor}(this can be either the FQN of the class name or a regsitered type in the configuration, see  {@link org.compass.core.accessor.PropertyAccessorFactory}.
 */
String getAccessor();"
18438,boolean canBeCollectionWrapped();,"/** 
 * Returns <code>true</code> if this object mapping can be wrapped with a Collection or an Array.
 */
boolean canBeCollectionWrapped();"
18439,void setDefinedInAlias(String alias);,"/** 
 * Sets which alias (or if not present, the FQN of the class name) this object property is defined at.
 */
void setDefinedInAlias(String alias);"
18440,String getPropertyName();,"/** 
 * Returns the class property name of the object mapping.
 */
String getPropertyName();"
18441,void setObjClass(Class objClass);,"/** 
 * Sets the class of the class mapping this object belongs to.
 */
void setObjClass(Class objClass);"
18442,"/** 
 * Returns which alias (or if not present, the FQN of the class name) this object property is defined.
 */
String getDefinedInAlias();","/** 
 * Returns which alias (or if not present, the FQN of the class name) this object property is defined at.
 */
String getDefinedInAlias();"
18443,"/** 
 * Need to be almost exactly as <code>bindClassPropertyMapping</code>.
 */
private void bindClassPropertyIdMapping(SearchableId searchableProp,ClassIdPropertyMapping classPropertyMapping,Class<?> clazz,Type type,AnnotatedElement annotatedElement) throws MappingException {
  bindConverter(classPropertyMapping,searchableProp.idConverter());
  classPropertyMapping.setBoost(searchableProp.boost());
  classPropertyMapping.setManagedId(AnnotationsBindingUtils.convert(searchableProp.managedId()));
  classPropertyMapping.setManagedIdIndex(AnnotationsBindingUtils.convert(searchableProp.managedIdIndex()));
  classPropertyMapping.setOverrideByName(searchableProp.override());
  SearchableMetaData metaData=annotatedElement.getAnnotation(SearchableMetaData.class);
  SearchableMetaDatas metaDatas=annotatedElement.getAnnotation(SearchableMetaDatas.class);
  if (StringUtils.hasLength(searchableProp.converter())) {
    classPropertyMapping.setManagedIdConverterName(searchableProp.converter());
  }
 else {
    classPropertyMapping.setManagedIdConverter(getConverter(clazz,type));
  }
  if (StringUtils.hasLength(searchableProp.name())) {
    ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
    String name=searchableProp.name();
    if (!StringUtils.hasLength(name)) {
      name=classPropertyMapping.getName();
    }
    mdMapping.setName(valueLookup.lookupMetaDataName(name));
    mdMapping.setPath(new StaticPropertyPath(mdMapping.getName()));
    mdMapping.setBoost(classPropertyMapping.getBoost());
    mdMapping.setAccessor(classPropertyMapping.getAccessor());
    mdMapping.setObjClass(classPropertyMapping.getObjClass());
    mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
    bindConverter(mdMapping,searchableProp.converter(),clazz,type);
    mdMapping.setStore(AnnotationsBindingUtils.convert(searchableProp.store()));
    mdMapping.setIndex(AnnotationsBindingUtils.convert(searchableProp.index()));
    mdMapping.setTermVector(AnnotationsBindingUtils.convert(searchableProp.termVector()));
    mdMapping.setReverse(AnnotationsBindingUtils.convert(searchableProp.reverse()));
    handleFormat(mdMapping,name,searchableProp.format());
    if (StringUtils.hasLength(searchableProp.analyzer())) {
      mdMapping.setAnalyzer(searchableProp.analyzer());
    }
    mdMapping.setExcludeFromAll(searchableProp.excludeFromAll());
    classPropertyMapping.addMapping(mdMapping);
  }
  if (metaData != null) {
    bindMetaData(metaData,classPropertyMapping,clazz,type);
  }
  if (metaDatas != null) {
    for (    SearchableMetaData searchableMetaData : metaDatas.value()) {
      bindMetaData(searchableMetaData,classPropertyMapping,clazz,type);
    }
  }
}","/** 
 * Need to be almost exactly as <code>bindClassPropertyMapping</code>.
 */
private void bindClassPropertyIdMapping(SearchableId searchableProp,ClassIdPropertyMapping classPropertyMapping,Class<?> clazz,Type type,AnnotatedElement annotatedElement) throws MappingException {
  bindConverter(classPropertyMapping,searchableProp.idConverter());
  classPropertyMapping.setBoost(searchableProp.boost());
  classPropertyMapping.setManagedId(AnnotationsBindingUtils.convert(searchableProp.managedId()));
  classPropertyMapping.setManagedIdIndex(AnnotationsBindingUtils.convert(searchableProp.managedIdIndex()));
  classPropertyMapping.setOverrideByName(searchableProp.override());
  SearchableMetaData metaData=annotatedElement.getAnnotation(SearchableMetaData.class);
  SearchableMetaDatas metaDatas=annotatedElement.getAnnotation(SearchableMetaDatas.class);
  if (StringUtils.hasLength(searchableProp.converter())) {
    classPropertyMapping.setManagedIdConverterName(searchableProp.converter());
  }
 else {
    classPropertyMapping.setManagedIdConverter(getConverter(clazz,type));
  }
  if (StringUtils.hasLength(searchableProp.name())) {
    ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
    String name=searchableProp.name();
    if (!StringUtils.hasLength(name)) {
      name=classPropertyMapping.getName();
    }
    mdMapping.setName(valueLookup.lookupMetaDataName(name));
    mdMapping.setPath(new StaticPropertyPath(mdMapping.getName()));
    mdMapping.setBoost(classPropertyMapping.getBoost());
    mdMapping.setAccessor(classPropertyMapping.getAccessor());
    mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
    bindConverter(mdMapping,searchableProp.converter(),clazz,type);
    mdMapping.setStore(AnnotationsBindingUtils.convert(searchableProp.store()));
    mdMapping.setIndex(AnnotationsBindingUtils.convert(searchableProp.index()));
    mdMapping.setTermVector(AnnotationsBindingUtils.convert(searchableProp.termVector()));
    mdMapping.setReverse(AnnotationsBindingUtils.convert(searchableProp.reverse()));
    handleFormat(mdMapping,name,searchableProp.format());
    if (StringUtils.hasLength(searchableProp.analyzer())) {
      mdMapping.setAnalyzer(searchableProp.analyzer());
    }
    mdMapping.setExcludeFromAll(searchableProp.excludeFromAll());
    classPropertyMapping.addMapping(mdMapping);
  }
  if (metaData != null) {
    bindMetaData(metaData,classPropertyMapping,clazz,type);
  }
  if (metaDatas != null) {
    for (    SearchableMetaData searchableMetaData : metaDatas.value()) {
      bindMetaData(searchableMetaData,classPropertyMapping,clazz,type);
    }
  }
}"
18444,"private void bindObjectMapping(ObjectMapping objectMapping,String actualAccessor,String name,String annotationAccessor,Class<?> searchableClass){
  if (!StringUtils.hasLength(annotationAccessor)) {
    objectMapping.setAccessor(actualAccessor);
  }
 else {
    objectMapping.setAccessor(annotationAccessor);
  }
  objectMapping.setName(name);
  objectMapping.setObjClass(classMapping.getClazz());
  objectMapping.setPropertyName(name);
  if (searchableClass.isAnnotationPresent(Searchable.class)) {
    Searchable searchable=searchableClass.getAnnotation(Searchable.class);
    if (StringUtils.hasLength(searchable.alias())) {
      objectMapping.setDefinedInAlias(searchable.alias());
    }
 else {
      objectMapping.setDefinedInAlias(searchableClass.getName());
    }
  }
 else {
    objectMapping.setDefinedInAlias(searchableClass.getName());
  }
}","private void bindObjectMapping(ObjectMapping objectMapping,String actualAccessor,String name,String annotationAccessor,Class<?> searchableClass){
  if (!StringUtils.hasLength(annotationAccessor)) {
    objectMapping.setAccessor(actualAccessor);
  }
 else {
    objectMapping.setAccessor(annotationAccessor);
  }
  objectMapping.setName(name);
  objectMapping.setPropertyName(name);
  if (searchableClass.isAnnotationPresent(Searchable.class)) {
    Searchable searchable=searchableClass.getAnnotation(Searchable.class);
    if (StringUtils.hasLength(searchable.alias())) {
      objectMapping.setDefinedInAlias(searchable.alias());
    }
 else {
      objectMapping.setDefinedInAlias(searchableClass.getName());
    }
  }
 else {
    objectMapping.setDefinedInAlias(searchableClass.getName());
  }
}"
18445,"private void bindMetaData(SearchableMetaData searchableMetaData,ClassPropertyMapping classPropertyMapping,Class<?> clazz,Type type){
  ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
  String name=searchableMetaData.name();
  mdMapping.setName(valueLookup.lookupMetaDataName(name));
  mdMapping.setPath(new StaticPropertyPath(mdMapping.getName()));
  if (searchableMetaData.boost() == 1.0f) {
    mdMapping.setBoost(classPropertyMapping.getBoost());
  }
 else {
    mdMapping.setBoost(searchableMetaData.boost());
  }
  bindConverter(mdMapping,searchableMetaData.converter(),clazz,type);
  mdMapping.setAccessor(classPropertyMapping.getAccessor());
  mdMapping.setObjClass(classPropertyMapping.getObjClass());
  mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
  mdMapping.setStore(AnnotationsBindingUtils.convert(searchableMetaData.store()));
  mdMapping.setIndex(AnnotationsBindingUtils.convert(searchableMetaData.index()));
  mdMapping.setTermVector(AnnotationsBindingUtils.convert(searchableMetaData.termVector()));
  mdMapping.setReverse(AnnotationsBindingUtils.convert(searchableMetaData.reverse()));
  handleFormat(mdMapping,name,searchableMetaData.format());
  mdMapping.setInternal(false);
  if (StringUtils.hasLength(searchableMetaData.analyzer())) {
    mdMapping.setAnalyzer(searchableMetaData.analyzer());
  }
  mdMapping.setExcludeFromAll(searchableMetaData.excludeFromAll());
  classPropertyMapping.addMapping(mdMapping);
}","private void bindMetaData(SearchableMetaData searchableMetaData,ClassPropertyMapping classPropertyMapping,Class<?> clazz,Type type){
  ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
  String name=searchableMetaData.name();
  mdMapping.setName(valueLookup.lookupMetaDataName(name));
  mdMapping.setPath(new StaticPropertyPath(mdMapping.getName()));
  if (searchableMetaData.boost() == 1.0f) {
    mdMapping.setBoost(classPropertyMapping.getBoost());
  }
 else {
    mdMapping.setBoost(searchableMetaData.boost());
  }
  bindConverter(mdMapping,searchableMetaData.converter(),clazz,type);
  mdMapping.setAccessor(classPropertyMapping.getAccessor());
  mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
  mdMapping.setStore(AnnotationsBindingUtils.convert(searchableMetaData.store()));
  mdMapping.setIndex(AnnotationsBindingUtils.convert(searchableMetaData.index()));
  mdMapping.setTermVector(AnnotationsBindingUtils.convert(searchableMetaData.termVector()));
  mdMapping.setReverse(AnnotationsBindingUtils.convert(searchableMetaData.reverse()));
  handleFormat(mdMapping,name,searchableMetaData.format());
  mdMapping.setInternal(false);
  if (StringUtils.hasLength(searchableMetaData.analyzer())) {
    mdMapping.setAnalyzer(searchableMetaData.analyzer());
  }
  mdMapping.setExcludeFromAll(searchableMetaData.excludeFromAll());
  classPropertyMapping.addMapping(mdMapping);
}"
18446,"/** 
 * Need to be almost exactly as <code>bindClassPropertyIdMapping</code>.
 */
private void bindClassPropertyMapping(SearchableProperty searchableProp,ClassPropertyMapping classPropertyMapping,AnnotatedElement annotatedElement,Class<?> clazz,Type type) throws MappingException {
  bindConverter(classPropertyMapping,searchableProp.propertyConverter());
  if (!searchableProp.type().equals(Object.class)) {
    classPropertyMapping.setClassName(searchableProp.type().getName());
  }
 else {
    classPropertyMapping.setClassName(AnnotationsBindingUtils.getCollectionParameterClassName(clazz,type));
  }
  if (StringUtils.hasLength(searchableProp.converter())) {
    classPropertyMapping.setManagedIdConverterName(searchableProp.converter());
  }
 else {
    classPropertyMapping.setManagedIdConverter(getConverter(clazz,type));
  }
  classPropertyMapping.setBoost(searchableProp.boost());
  classPropertyMapping.setManagedId(AnnotationsBindingUtils.convert(searchableProp.managedId()));
  classPropertyMapping.setManagedIdIndex(AnnotationsBindingUtils.convert(searchableProp.managedIdIndex()));
  classPropertyMapping.setOverrideByName(searchableProp.override());
  SearchableMetaData metaData=annotatedElement.getAnnotation(SearchableMetaData.class);
  SearchableMetaDatas metaDatas=annotatedElement.getAnnotation(SearchableMetaDatas.class);
  boolean hasMetaDataAnnotations=metaData != null || metaDatas != null;
  if (StringUtils.hasLength(searchableProp.name()) || !hasMetaDataAnnotations) {
    ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
    String name=searchableProp.name();
    if (!StringUtils.hasLength(name)) {
      name=classPropertyMapping.getName();
    }
    mdMapping.setName(valueLookup.lookupMetaDataName(name));
    mdMapping.setPath(new StaticPropertyPath(mdMapping.getName()));
    mdMapping.setBoost(classPropertyMapping.getBoost());
    bindConverter(mdMapping,searchableProp.converter(),clazz,type);
    mdMapping.setAccessor(classPropertyMapping.getAccessor());
    mdMapping.setObjClass(classPropertyMapping.getObjClass());
    mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
    mdMapping.setStore(AnnotationsBindingUtils.convert(searchableProp.store()));
    mdMapping.setIndex(AnnotationsBindingUtils.convert(searchableProp.index()));
    mdMapping.setTermVector(AnnotationsBindingUtils.convert(searchableProp.termVector()));
    mdMapping.setReverse(AnnotationsBindingUtils.convert(searchableProp.reverse()));
    handleFormat(mdMapping,name,searchableProp.format());
    mdMapping.setInternal(false);
    if (StringUtils.hasLength(searchableProp.analyzer())) {
      mdMapping.setAnalyzer(searchableProp.analyzer());
    }
    mdMapping.setExcludeFromAll(searchableProp.excludeFromAll());
    classPropertyMapping.addMapping(mdMapping);
  }
  if (metaData != null) {
    bindMetaData(metaData,classPropertyMapping,clazz,type);
  }
  if (metaDatas != null) {
    for (    SearchableMetaData searchableMetaData : metaDatas.value()) {
      bindMetaData(searchableMetaData,classPropertyMapping,clazz,type);
    }
  }
}","/** 
 * Need to be almost exactly as <code>bindClassPropertyIdMapping</code>.
 */
private void bindClassPropertyMapping(SearchableProperty searchableProp,ClassPropertyMapping classPropertyMapping,AnnotatedElement annotatedElement,Class<?> clazz,Type type) throws MappingException {
  bindConverter(classPropertyMapping,searchableProp.propertyConverter());
  if (!searchableProp.type().equals(Object.class)) {
    classPropertyMapping.setClassName(searchableProp.type().getName());
  }
 else {
    classPropertyMapping.setClassName(AnnotationsBindingUtils.getCollectionParameterClassName(clazz,type));
  }
  if (StringUtils.hasLength(searchableProp.converter())) {
    classPropertyMapping.setManagedIdConverterName(searchableProp.converter());
  }
 else {
    classPropertyMapping.setManagedIdConverter(getConverter(clazz,type));
  }
  classPropertyMapping.setBoost(searchableProp.boost());
  classPropertyMapping.setManagedId(AnnotationsBindingUtils.convert(searchableProp.managedId()));
  classPropertyMapping.setManagedIdIndex(AnnotationsBindingUtils.convert(searchableProp.managedIdIndex()));
  classPropertyMapping.setOverrideByName(searchableProp.override());
  SearchableMetaData metaData=annotatedElement.getAnnotation(SearchableMetaData.class);
  SearchableMetaDatas metaDatas=annotatedElement.getAnnotation(SearchableMetaDatas.class);
  boolean hasMetaDataAnnotations=metaData != null || metaDatas != null;
  if (StringUtils.hasLength(searchableProp.name()) || !hasMetaDataAnnotations) {
    ClassPropertyMetaDataMapping mdMapping=new ClassPropertyMetaDataMapping();
    String name=searchableProp.name();
    if (!StringUtils.hasLength(name)) {
      name=classPropertyMapping.getName();
    }
    mdMapping.setName(valueLookup.lookupMetaDataName(name));
    mdMapping.setPath(new StaticPropertyPath(mdMapping.getName()));
    mdMapping.setBoost(classPropertyMapping.getBoost());
    bindConverter(mdMapping,searchableProp.converter(),clazz,type);
    mdMapping.setAccessor(classPropertyMapping.getAccessor());
    mdMapping.setPropertyName(classPropertyMapping.getPropertyName());
    mdMapping.setStore(AnnotationsBindingUtils.convert(searchableProp.store()));
    mdMapping.setIndex(AnnotationsBindingUtils.convert(searchableProp.index()));
    mdMapping.setTermVector(AnnotationsBindingUtils.convert(searchableProp.termVector()));
    mdMapping.setReverse(AnnotationsBindingUtils.convert(searchableProp.reverse()));
    handleFormat(mdMapping,name,searchableProp.format());
    mdMapping.setInternal(false);
    if (StringUtils.hasLength(searchableProp.analyzer())) {
      mdMapping.setAnalyzer(searchableProp.analyzer());
    }
    mdMapping.setExcludeFromAll(searchableProp.excludeFromAll());
    classPropertyMapping.addMapping(mdMapping);
  }
  if (metaData != null) {
    bindMetaData(metaData,classPropertyMapping,clazz,type);
  }
  if (metaDatas != null) {
    for (    SearchableMetaData searchableMetaData : metaDatas.value()) {
      bindMetaData(searchableMetaData,classPropertyMapping,clazz,type);
    }
  }
}"
18447,"public CompassMapping process(CompassMapping compassMapping,PropertyNamingStrategy namingStrategy,ConverterLookup converterLookup,CompassSettings settings) throws MappingException {
  PropertyAccessorFactory propertyAccessorFactory=new PropertyAccessorFactory();
  propertyAccessorFactory.configure(settings);
  for (Iterator rIt=compassMapping.mappingsIt(); rIt.hasNext(); ) {
    Mapping mapping=(Mapping)rIt.next();
    if (mapping instanceof ClassMapping) {
      ClassMapping classMapping=(ClassMapping)mapping;
      classMapping.setConstructor(ClassUtils.getDefaultConstructor(classMapping.getClazz()));
      if (!Modifier.isAbstract(classMapping.getClazz().getModifiers()) && !Modifier.isInterface(classMapping.getClazz().getModifiers())) {
        if (classMapping.getConstructor() == null) {
          throw new MappingException(""String_Node_Str"" + classMapping.getName() + ""String_Node_Str"");
        }
      }
      if (classMapping.getPolyClass() != null) {
        classMapping.setPolyConstructor(ClassUtils.getDefaultConstructor(classMapping.getPolyClass()));
      }
      for (Iterator it=classMapping.mappingsIt(); it.hasNext(); ) {
        processMapping((Mapping)it.next(),classMapping.getClazz(),propertyAccessorFactory);
      }
    }
  }
  return compassMapping;
}","public CompassMapping process(CompassMapping compassMapping,PropertyNamingStrategy namingStrategy,ConverterLookup converterLookup,CompassSettings settings) throws MappingException {
  propertyAccessorFactory=new PropertyAccessorFactory();
  propertyAccessorFactory.configure(settings);
  for (Iterator rIt=compassMapping.mappingsIt(); rIt.hasNext(); ) {
    Mapping mapping=(Mapping)rIt.next();
    if (mapping instanceof ClassMapping) {
      ClassMapping classMapping=(ClassMapping)mapping;
      classMapping.setConstructor(ClassUtils.getDefaultConstructor(classMapping.getClazz()));
      if (!Modifier.isAbstract(classMapping.getClazz().getModifiers()) && !Modifier.isInterface(classMapping.getClazz().getModifiers())) {
        if (classMapping.getConstructor() == null) {
          throw new MappingException(""String_Node_Str"" + classMapping.getName() + ""String_Node_Str"");
        }
      }
      if (classMapping.getPolyClass() != null) {
        classMapping.setPolyConstructor(ClassUtils.getDefaultConstructor(classMapping.getPolyClass()));
      }
      Class clazz=classMapping.getClazz();
      if (classMapping.isPoly() && classMapping.getPolyClass() != null) {
        clazz=classMapping.getPolyClass();
      }
      for (Iterator it=classMapping.mappingsIt(); it.hasNext(); ) {
        processMapping((Mapping)it.next(),clazz);
      }
    }
  }
  return compassMapping;
}"
18448,"private void processMapping(Mapping mapping,Class clazz,PropertyAccessorFactory propertyAccessorFactory) throws MappingException {
  if (!(mapping instanceof ObjectMapping)) {
    return;
  }
  ObjectMapping objectMapping=(ObjectMapping)mapping;
  objectMapping.setObjClass(clazz);
  PropertyAccessor pAccessor=propertyAccessorFactory.getPropertyAccessor(objectMapping.getAccessor());
  objectMapping.setGetter(pAccessor.getGetter(clazz,objectMapping.getPropertyName()));
  objectMapping.setSetter(pAccessor.getSetter(clazz,objectMapping.getPropertyName()));
  if (mapping instanceof MultipleMapping) {
    MultipleMapping multipleMapping=(MultipleMapping)mapping;
    for (Iterator it=multipleMapping.mappingsIt(); it.hasNext(); ) {
      processMapping((Mapping)it.next(),clazz,propertyAccessorFactory);
    }
  }
}","private void processMapping(Mapping mapping,Class clazz) throws MappingException {
  if (!(mapping instanceof ObjectMapping)) {
    return;
  }
  ObjectMapping objectMapping=(ObjectMapping)mapping;
  PropertyAccessor pAccessor=propertyAccessorFactory.getPropertyAccessor(objectMapping.getAccessor());
  objectMapping.setGetter(pAccessor.getGetter(clazz,objectMapping.getPropertyName()));
  objectMapping.setSetter(pAccessor.getSetter(clazz,objectMapping.getPropertyName()));
  if (mapping instanceof MultipleMapping) {
    MultipleMapping multipleMapping=(MultipleMapping)mapping;
    for (Iterator it=multipleMapping.mappingsIt(); it.hasNext(); ) {
      processMapping((Mapping)it.next(),clazz);
    }
  }
}"
18449,"protected void copy(AbstractAccessorMapping copy){
  super.copy(copy);
  copy.setGetter(getGetter());
  copy.setSetter(getSetter());
  copy.setAccessor(getAccessor());
  copy.setObjClass(getObjClass());
  copy.setPropertyName(getPropertyName());
  copy.setDefinedInAlias(getDefinedInAlias());
}","protected void copy(AbstractAccessorMapping copy){
  super.copy(copy);
  copy.setGetter(getGetter());
  copy.setSetter(getSetter());
  copy.setAccessor(getAccessor());
  copy.setPropertyName(getPropertyName());
  copy.setDefinedInAlias(getDefinedInAlias());
}"
18450,"public Mapping copy(){
  ClassPropertyMetaDataMapping copy=new ClassPropertyMetaDataMapping();
  super.copy(copy);
  copy.setSetter(getSetter());
  copy.setGetter(getGetter());
  copy.setAccessor(getAccessor());
  copy.setObjClass(getObjClass());
  copy.setPropertyName(getPropertyName());
  return copy;
}","public Mapping copy(){
  ClassPropertyMetaDataMapping copy=new ClassPropertyMetaDataMapping();
  super.copy(copy);
  copy.setSetter(getSetter());
  copy.setGetter(getGetter());
  copy.setAccessor(getAccessor());
  copy.setPropertyName(getPropertyName());
  return copy;
}"
18451,"protected void doParse(Element element,BeanDefinitionBuilder beanDefinitionBuilder){
  if (element.getLocalName().equals(""String_Node_Str"")) {
    String id=element.getAttribute(""String_Node_Str"");
    element.setAttribute(ID_ATTRIBUTE,id);
    SchemaConfigurationBuilder schemaConfigurationBuilder=new SchemaConfigurationBuilder();
    CompassConfiguration config=CompassConfigurationFactory.newConfiguration();
    schemaConfigurationBuilder.processCompass(element,config);
    beanDefinitionBuilder.addPropertyValue(""String_Node_Str"",config);
    String txManagerRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (txManagerRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",txManagerRef);
    }
    String dataSourceRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (dataSourceRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",dataSourceRef);
    }
  }
 else   if (element.getLocalName().equals(""String_Node_Str"")) {
    element.setAttribute(ID_ATTRIBUTE,""String_Node_Str"" + System.currentTimeMillis());
  }
 else   if (element.getLocalName().equals(""String_Node_Str"")) {
    String compassRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (compassRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",compassRef);
    }
  }
}","protected void doParse(Element element,BeanDefinitionBuilder beanDefinitionBuilder){
  if (element.getLocalName().equals(""String_Node_Str"")) {
    String id=element.getAttribute(""String_Node_Str"");
    element.setAttribute(ID_ATTRIBUTE,id);
    SchemaConfigurationBuilder schemaConfigurationBuilder=new SchemaConfigurationBuilder();
    CompassConfiguration config=CompassConfigurationFactory.newConfiguration();
    schemaConfigurationBuilder.processCompass(element,config);
    beanDefinitionBuilder.addPropertyValue(""String_Node_Str"",config);
    String txManagerRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (txManagerRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",txManagerRef);
    }
    String dataSourceRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (dataSourceRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",dataSourceRef);
    }
    String postProcessRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (postProcessRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",postProcessRef);
    }
  }
 else   if (element.getLocalName().equals(""String_Node_Str"")) {
    element.setAttribute(ID_ATTRIBUTE,""String_Node_Str"" + System.currentTimeMillis());
  }
 else   if (element.getLocalName().equals(""String_Node_Str"")) {
    String compassRef=DomUtils.getElementAttribute(element,""String_Node_Str"");
    if (compassRef != null) {
      beanDefinitionBuilder.addPropertyReference(""String_Node_Str"",compassRef);
    }
  }
}"
18452,"private void processsAnnotatedElement(String name,String accessor,Class<?> clazz,Type type,Annotation annotation,AnnotatedElement annotatedElement){
  if (annotation instanceof SearchableId) {
    ClassIdPropertyMapping classPropertyMapping=new ClassIdPropertyMapping();
    SearchableId searchableId=(SearchableId)annotation;
    bindObjectMapping(classPropertyMapping,accessor,name,searchableId.accessor());
    bindClassPropertyIdMapping(searchableId,classPropertyMapping,clazz,type,annotatedElement);
    classMapping.addMapping(classPropertyMapping);
  }
 else   if (annotation instanceof SearchableProperty) {
    ClassPropertyMapping classPropertyMapping=new ClassPropertyMapping();
    SearchableProperty searchableProperty=(SearchableProperty)annotation;
    bindObjectMapping(classPropertyMapping,accessor,name,searchableProperty.accessor());
    bindClassPropertyMapping(searchableProperty,classPropertyMapping,annotatedElement,clazz,type);
    classMapping.addMapping(classPropertyMapping);
  }
 else   if (annotation instanceof SearchableComponent) {
    ComponentMapping componentMapping=new ComponentMapping();
    SearchableComponent searchableComponent=(SearchableComponent)annotation;
    bindObjectMapping(componentMapping,accessor,name,searchableComponent.accessor());
    bindComponent(searchableComponent,componentMapping,clazz,type);
    classMapping.addMapping(componentMapping);
  }
 else   if (annotation instanceof SearchableReference) {
    ReferenceMapping referenceMapping=new ReferenceMapping();
    SearchableReference searchableReference=(SearchableReference)annotation;
    bindObjectMapping(referenceMapping,accessor,name,searchableReference.accessor());
    bindReference(searchableReference,referenceMapping,clazz,type);
    classMapping.addMapping(referenceMapping);
  }
 else   if (annotation instanceof SearchableAnalyzerProperty) {
    ClassPropertyAnalyzerController analyzerMapping=new ClassPropertyAnalyzerController();
    SearchableAnalyzerProperty searchableAnalyzerProperty=(SearchableAnalyzerProperty)annotation;
    bindObjectMapping(analyzerMapping,accessor,name,searchableAnalyzerProperty.accessor());
    bindAnalyzer(searchableAnalyzerProperty,analyzerMapping,clazz,type);
    classMapping.addMapping(analyzerMapping);
  }
 else   if (annotation instanceof SearchableParent) {
    ParentMapping parentMapping=new ParentMapping();
    SearchableParent searchableParent=(SearchableParent)annotation;
    bindObjectMapping(parentMapping,accessor,name,searchableParent.accessor());
    bindParent(searchableParent,parentMapping,clazz,type);
    classMapping.addMapping(parentMapping);
  }
 else   if ((annotation instanceof SearchableMetaData) || (annotation instanceof SearchableMetaDatas)) {
    if (!annotatedElement.isAnnotationPresent(SearchableProperty.class)) {
      throw new MappingException(""String_Node_Str"");
    }
  }
}","private void processsAnnotatedElement(String name,String accessor,Class<?> clazz,Type type,Annotation annotation,AnnotatedElement annotatedElement){
  if (annotation instanceof SearchableId) {
    ClassIdPropertyMapping classPropertyMapping=new ClassIdPropertyMapping();
    SearchableId searchableId=(SearchableId)annotation;
    bindObjectMapping(classPropertyMapping,accessor,name,searchableId.accessor());
    bindClassPropertyIdMapping(searchableId,classPropertyMapping,clazz,type,annotatedElement);
    classMapping.addMapping(classPropertyMapping);
  }
 else   if (annotation instanceof SearchableProperty) {
    ClassPropertyMapping classPropertyMapping=new ClassPropertyMapping();
    SearchableProperty searchableProperty=(SearchableProperty)annotation;
    bindObjectMapping(classPropertyMapping,accessor,name,searchableProperty.accessor());
    bindClassPropertyMapping(searchableProperty,classPropertyMapping,annotatedElement,clazz,type);
    classMapping.addMapping(classPropertyMapping);
  }
 else   if (annotation instanceof SearchableComponent) {
    ComponentMapping componentMapping=new ComponentMapping();
    SearchableComponent searchableComponent=(SearchableComponent)annotation;
    bindObjectMapping(componentMapping,accessor,name,searchableComponent.accessor());
    bindComponent(searchableComponent,componentMapping,clazz,type);
    classMapping.addMapping(componentMapping);
  }
 else   if (annotation instanceof SearchableReference) {
    ReferenceMapping referenceMapping=new ReferenceMapping();
    SearchableReference searchableReference=(SearchableReference)annotation;
    bindObjectMapping(referenceMapping,accessor,name,searchableReference.accessor());
    bindReference(searchableReference,referenceMapping,clazz,type);
    classMapping.addMapping(referenceMapping);
  }
 else   if (annotation instanceof SearchableAnalyzerProperty) {
    ClassPropertyAnalyzerController analyzerMapping=new ClassPropertyAnalyzerController();
    SearchableAnalyzerProperty searchableAnalyzerProperty=(SearchableAnalyzerProperty)annotation;
    bindObjectMapping(analyzerMapping,accessor,name,searchableAnalyzerProperty.accessor());
    bindAnalyzer(searchableAnalyzerProperty,analyzerMapping,clazz,type);
    classMapping.addMapping(analyzerMapping);
  }
 else   if (annotation instanceof SearchableParent) {
    ParentMapping parentMapping=new ParentMapping();
    SearchableParent searchableParent=(SearchableParent)annotation;
    bindObjectMapping(parentMapping,accessor,name,searchableParent.accessor());
    bindParent(searchableParent,parentMapping,clazz,type);
    classMapping.addMapping(parentMapping);
  }
 else   if ((annotation instanceof SearchableMetaData) || (annotation instanceof SearchableMetaDatas)) {
    if (!annotatedElement.isAnnotationPresent(SearchableProperty.class) && !annotatedElement.isAnnotationPresent(SearchableId.class)) {
      throw new MappingException(""String_Node_Str"");
    }
  }
}"
18453,"private void validateDuplicateExcludeFromAll(ResourceMapping resourceMapping,String propertyName,ResourcePropertyMapping[] resourcePropertyMapping) throws MappingException {
  if (resourcePropertyMapping.length == 1) {
    return;
  }
  boolean excludeFromAll=resourcePropertyMapping[0].isExcludeFromAll();
  for (int i=1; i < resourcePropertyMapping.length; i++) {
    if (excludeFromAll != resourcePropertyMapping[i].isExcludeFromAll()) {
      throw new InvalidMappingException(""String_Node_Str"" + propertyName + ""String_Node_Str""+ resourceMapping.getAlias()+ ""String_Node_Str"");
    }
  }
}","private void validateDuplicateExcludeFromAll(ResourceMapping resourceMapping,String propertyName,ResourcePropertyMapping[] resourcePropertyMapping) throws MappingException {
  if (resourcePropertyMapping.length == 1) {
    return;
  }
  boolean excludeFromAll=resourcePropertyMapping[0].isExcludeFromAll();
  for (int i=1; i < resourcePropertyMapping.length; i++) {
    if (resourcePropertyMapping[i].isInternal()) {
      continue;
    }
    if (excludeFromAll != resourcePropertyMapping[i].isExcludeFromAll()) {
      throw new InvalidMappingException(""String_Node_Str"" + propertyName + ""String_Node_Str""+ resourceMapping.getAlias()+ ""String_Node_Str"");
    }
  }
}"
18454,"public CompassSettings copy(){
  return new CompassSettings((Properties)settings.clone());
}","public CompassSettings copy(){
  CompassSettings copySettings=new CompassSettings((Properties)settings.clone());
  copySettings.setRegistry(getRegistry());
  return copySettings;
}"
18455,"public void start(){
  indexManager.start();
  if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"" + settings.getIndexManagerScheduleInterval() + ""String_Node_Str"");
  }
  scheduledExecutorService=Executors.newSingleThreadScheduledExecutor(new SingleThreadThreadFactory(""String_Node_Str"",true));
  ScheduledIndexManagerRunnable scheduledIndexManagerRunnable=new ScheduledIndexManagerRunnable(indexManager);
  long period=settings.getIndexManagerScheduleInterval();
  scheduledExecutorService.scheduleWithFixedDelay(scheduledIndexManagerRunnable,period,period,TimeUnit.MILLISECONDS);
  setWaitForCacheInvalidationBeforeSecondStep((long)(settings.getIndexManagerScheduleInterval() * 1.1));
}","public void start(){
  indexManager.start();
  if (settings.getIndexManagerScheduleInterval() < 0) {
    log.info(""String_Node_Str"");
    return;
  }
  if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"" + settings.getIndexManagerScheduleInterval() + ""String_Node_Str"");
  }
  scheduledExecutorService=Executors.newSingleThreadScheduledExecutor(new SingleThreadThreadFactory(""String_Node_Str"",true));
  ScheduledIndexManagerRunnable scheduledIndexManagerRunnable=new ScheduledIndexManagerRunnable(indexManager);
  long period=settings.getIndexManagerScheduleInterval();
  scheduledExecutorService.scheduleWithFixedDelay(scheduledIndexManagerRunnable,period,period,TimeUnit.MILLISECONDS);
  setWaitForCacheInvalidationBeforeSecondStep((long)(settings.getIndexManagerScheduleInterval() * 1.1));
}"
18456,"protected Directory doGetDirectoryForPath(String path,boolean create) throws SearchEngineException {
  String totalPath=subContext + ""String_Node_Str"" + path;
  JdbcTable jdbcTable=(JdbcTable)cachedJdbcTables.get(totalPath);
  if (jdbcTable == null) {
    jdbcTable=new JdbcTable(jdbcSettings,dialect,totalPath);
    cachedJdbcTables.put(totalPath,jdbcTable);
  }
  JdbcDirectory dir=new JdbcDirectory(dataSource,jdbcTable);
  if (create) {
    try {
      createDirectory(dir);
    }
 catch (    IOException e) {
      throw new SearchEngineException(""String_Node_Str"" + path + ""String_Node_Str"",e);
    }
  }
  return dir;
}","protected Directory doGetDirectoryForPath(String path,boolean create) throws SearchEngineException {
  String totalPath=subContext + ""String_Node_Str"" + path;
  JdbcTable jdbcTable=(JdbcTable)cachedJdbcTables.get(totalPath);
  if (jdbcTable == null) {
    jdbcTable=new JdbcTable(jdbcSettings,dialect,totalPath);
    cachedJdbcTables.put(totalPath,jdbcTable);
  }
  JdbcDirectory dir=new JdbcDirectory(dataSource,jdbcTable);
  if (create) {
    try {
      createDirectory(dir);
    }
 catch (    IOException e) {
      throw new SearchEngineException(""String_Node_Str"" + totalPath + ""String_Node_Str"",e);
    }
  }
  return dir;
}"
18457,"public void closeDataSource(){
  dataSourceHolder.set(null);
}","public void closeDataSource(){
  dataSourceHolder.set(null);
  settings.getRegistry().put(dataSourceKey,null);
}"
18458,"protected DataSource doCreateDataSource(String url,CompassSettings settings) throws CompassException {
  DataSource dataSource=(DataSource)dataSourceHolder.get();
  return new UsernamePasswordDataSourceWrapper(dataSource,username,password,autoCommit);
}","protected DataSource doCreateDataSource(String url,CompassSettings settings) throws CompassException {
  this.settings=settings;
  DataSource dataSource=(DataSource)dataSourceHolder.get();
  if (dataSource == null) {
    dataSource=(DataSource)settings.getRegistry().get(dataSourceKey);
  }
  if (dataSource == null) {
    throw new CompassException(""String_Node_Str"");
  }
 else {
    settings.getRegistry().put(dataSourceKey,dataSource);
    dataSourceHolder.set(null);
  }
  return new UsernamePasswordDataSourceWrapper(dataSource,username,password,autoCommit);
}"
18459,"public LocalTransaction(InternalCompassSession session,TransactionIsolation transactionIsolation){
  state=UNKNOWN;
  this.session=session;
  this.transactionIsolation=transactionIsolation;
}","public LocalTransaction(InternalCompassSession session,TransactionIsolation transactionIsolation){
  state=UNKNOWN;
  this.session=session;
  this.compass=session.getCompass();
  this.transactionIsolation=transactionIsolation;
}"
18460,"protected void doRollback() throws CompassException {
  if (state == UNKNOWN) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + ""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
    }
  }
 else {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
    }
    CompassSessionHolder holder=TransactionSessionManager.getHolder(session.getCompass());
    holder.removeSession();
  }
  state=ROLLBACK;
  session.evictAll();
  session.getSearchEngine().rollback();
}","protected void doRollback() throws CompassException {
  if (state == UNKNOWN) {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + ""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ System.identityHashCode(compass)+ ""String_Node_Str""+ System.identityHashCode(session)+ ""String_Node_Str"");
    }
  }
 else {
    if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ System.identityHashCode(compass)+ ""String_Node_Str""+ System.identityHashCode(session)+ ""String_Node_Str"");
    }
    CompassSessionHolder holder=TransactionSessionManager.getHolder(session.getCompass());
    holder.removeSession();
  }
  state=ROLLBACK;
  session.evictAll();
  session.getSearchEngine().rollback();
}"
18461,"public void join() throws CompassException {
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
  }
}","public void join() throws CompassException {
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ System.identityHashCode(compass)+ ""String_Node_Str""+ System.identityHashCode(session)+ ""String_Node_Str"");
  }
}"
18462,"public void begin() throws CompassException {
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
  }
  session.getSearchEngine().begin(transactionIsolation);
  state=STARTED;
}","public void begin() throws CompassException {
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ System.identityHashCode(compass)+ ""String_Node_Str""+ System.identityHashCode(session)+ ""String_Node_Str"");
  }
  session.getSearchEngine().begin(transactionIsolation);
  state=STARTED;
}"
18463,"protected void doCommit() throws CompassException {
  if (session.getSearchEngine().wasRolledBack()) {
  }
  if (state == UNKNOWN) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
    return;
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str"");
  }
  CompassSessionHolder holder=TransactionSessionManager.getHolder(session.getCompass());
  holder.removeSession();
  session.evictAll();
  session.getSearchEngine().commit(true);
  state=COMMIT;
}","protected void doCommit() throws CompassException {
  if (session.getSearchEngine().wasRolledBack()) {
  }
  if (state == UNKNOWN) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ System.identityHashCode(compass)+ ""String_Node_Str""+ System.identityHashCode(session)+ ""String_Node_Str"");
    return;
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ System.identityHashCode(compass)+ ""String_Node_Str""+ System.identityHashCode(session)+ ""String_Node_Str"");
  }
  CompassSessionHolder holder=TransactionSessionManager.getHolder(session.getCompass());
  holder.removeSession();
  session.evictAll();
  session.getSearchEngine().commit(true);
  state=COMMIT;
}"
18464,"protected void doConfigure(CompassSettings settings){
  this.transactionManager=(PlatformTransactionManager)transactionManagerHolder.get();
  transactionManagerHolder.set(null);
}","protected void doConfigure(CompassSettings settings){
  this.transactionManager=(PlatformTransactionManager)transactionManagerHolder.get();
  if (transactionManager == null) {
    transactionManager=(PlatformTransactionManager)settings.getRegistry().get(transactionManagerKey);
  }
  if (transactionManager != null) {
    settings.getRegistry().put(transactionManagerKey,transactionManager);
  }
  transactionManagerHolder.set(null);
}"
18465,"/** 
 * Creates a new instance of the Jdbc directory settings with it's default values initialized.
 */
public JdbcDirectorySettings(){
  JdbcFileEntrySettings defaultSettings=new JdbcFileEntrySettings();
  registerFileEntrySettings(DEFAULT_FILE_ENTRY,defaultSettings);
  JdbcFileEntrySettings deletableSettings=new JdbcFileEntrySettings();
  deletableSettings.setClassSetting(JdbcFileEntrySettings.FILE_ENTRY_HANDLER_TYPE,NoOpFileEntryHandler.class);
  registerFileEntrySettings(""String_Node_Str"",deletableSettings);
  registerFileEntrySettings(""String_Node_Str"",deletableSettings);
  registerFileEntrySettings(""String_Node_Str"",deletableSettings);
  JdbcFileEntrySettings segmentsSettings=new JdbcFileEntrySettings();
  segmentsSettings.setClassSetting(JdbcFileEntrySettings.FILE_ENTRY_HANDLER_TYPE,ActualDeleteFileEntryHandler.class);
  segmentsSettings.setClassSetting(JdbcFileEntrySettings.INDEX_INPUT_TYPE_SETTING,FetchOnOpenJdbcIndexInput.class);
  segmentsSettings.setClassSetting(JdbcFileEntrySettings.INDEX_OUTPUT_TYPE_SETTING,RAMJdbcIndexOutput.class);
  registerFileEntrySettings(""String_Node_Str"",segmentsSettings);
  registerFileEntrySettings(""String_Node_Str"",segmentsSettings);
  JdbcFileEntrySettings fnmSettings=new JdbcFileEntrySettings();
  fnmSettings.setClassSetting(JdbcFileEntrySettings.INDEX_INPUT_TYPE_SETTING,FetchOnOpenJdbcIndexInput.class);
  fnmSettings.setClassSetting(JdbcFileEntrySettings.INDEX_OUTPUT_TYPE_SETTING,RAMJdbcIndexOutput.class);
  registerFileEntrySettings(""String_Node_Str"",fnmSettings);
}","/** 
 * Creates a new instance of the Jdbc directory settings with it's default values initialized.
 */
public JdbcDirectorySettings(){
  JdbcFileEntrySettings defaultSettings=new JdbcFileEntrySettings();
  registerFileEntrySettings(DEFAULT_FILE_ENTRY,defaultSettings);
  JdbcFileEntrySettings deletableSettings=new JdbcFileEntrySettings();
  deletableSettings.setClassSetting(JdbcFileEntrySettings.FILE_ENTRY_HANDLER_TYPE,NoOpFileEntryHandler.class);
  registerFileEntrySettings(""String_Node_Str"",deletableSettings);
  registerFileEntrySettings(""String_Node_Str"",deletableSettings);
  registerFileEntrySettings(""String_Node_Str"",deletableSettings);
  JdbcFileEntrySettings segmentsSettings=new JdbcFileEntrySettings();
  segmentsSettings.setClassSetting(JdbcFileEntrySettings.FILE_ENTRY_HANDLER_TYPE,ActualDeleteFileEntryHandler.class);
  segmentsSettings.setClassSetting(JdbcFileEntrySettings.INDEX_INPUT_TYPE_SETTING,FetchOnOpenJdbcIndexInput.class);
  segmentsSettings.setClassSetting(JdbcFileEntrySettings.INDEX_OUTPUT_TYPE_SETTING,RAMJdbcIndexOutput.class);
  registerFileEntrySettings(""String_Node_Str"",segmentsSettings);
  registerFileEntrySettings(""String_Node_Str"",segmentsSettings);
  JdbcFileEntrySettings dotDelSettings=new JdbcFileEntrySettings();
  dotDelSettings.setClassSetting(JdbcFileEntrySettings.FILE_ENTRY_HANDLER_TYPE,ActualDeleteFileEntryHandler.class);
  registerFileEntrySettings(""String_Node_Str"",dotDelSettings);
  JdbcFileEntrySettings tmpSettings=new JdbcFileEntrySettings();
  tmpSettings.setClassSetting(JdbcFileEntrySettings.FILE_ENTRY_HANDLER_TYPE,ActualDeleteFileEntryHandler.class);
  registerFileEntrySettings(""String_Node_Str"",dotDelSettings);
  JdbcFileEntrySettings fnmSettings=new JdbcFileEntrySettings();
  fnmSettings.setClassSetting(JdbcFileEntrySettings.INDEX_INPUT_TYPE_SETTING,FetchOnOpenJdbcIndexInput.class);
  fnmSettings.setClassSetting(JdbcFileEntrySettings.INDEX_OUTPUT_TYPE_SETTING,RAMJdbcIndexOutput.class);
  registerFileEntrySettings(""String_Node_Str"",fnmSettings);
}"
18466,"public void testScheduledOptimizer(){
  MockOptimizer optimizer=(MockOptimizer)((DefaultCompass.TransactionalSearchEngineOptimizer)((ScheduledLuceneSearchEngineOptimizer)getCompass().getSearchEngineOptimizer()).getWrappedOptimizer()).getWrappedOptimizer();
  assertTrue(getCompass().getSearchEngineOptimizer().isRunning());
  optimizer.clear();
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
  }
  assertTrue(optimizer.isNeedOptimizingCalled());
  assertFalse(optimizer.isOptimizeCalled());
  optimizer.clear();
  optimizer.setNeedOptimizing(true);
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
  }
  assertTrue(optimizer.isNeedOptimizingCalled());
  assertTrue(optimizer.isOptimizeCalled());
  getCompass().getSearchEngineOptimizer().stop();
  assertFalse(getCompass().getSearchEngineOptimizer().isRunning());
  optimizer.clear();
  optimizer.setNeedOptimizing(true);
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
  }
  assertFalse(optimizer.isNeedOptimizingCalled());
  assertFalse(optimizer.isOptimizeCalled());
}","public void testScheduledOptimizer(){
  MockOptimizer optimizer=(MockOptimizer)((DefaultCompass.TransactionalSearchEngineOptimizer)((ScheduledLuceneSearchEngineOptimizer)getCompass().getSearchEngineOptimizer()).getWrappedOptimizer()).getWrappedOptimizer();
  assertTrue(getCompass().getSearchEngineOptimizer().isRunning());
  optimizer.clear();
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
  }
  assertTrue(optimizer.isNeedOptimizingCalled());
  assertFalse(optimizer.isOptimizeCalled());
  optimizer.clear();
  optimizer.setNeedOptimizing(true);
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
  }
  assertTrue(optimizer.isNeedOptimizingCalled());
  assertTrue(optimizer.isOptimizeCalled());
  getCompass().getSearchEngineOptimizer().stop();
  assertFalse(getCompass().getSearchEngineOptimizer().isRunning());
  try {
    Thread.sleep(100);
    optimizer.clear();
    optimizer.setNeedOptimizing(true);
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
  }
  assertFalse(optimizer.isNeedOptimizingCalled());
  assertFalse(optimizer.isOptimizeCalled());
}"
18467,"public T dequeue(){
  if (head == null) {
    return null;
  }
  if (head.equals(tail)) {
    Node<T> result=tail;
    tail=head;
    size--;
    return result.getValue();
  }
  Node<T> currNode=head;
  while (currNode.getNext() != null) {
    if (currNode.getNext().equals(tail)) {
      Node<T> result=currNode.getNext();
      tail=currNode;
      size--;
      return result.getValue();
    }
  }
  return null;
}","public T dequeue(){
  if (head == null) {
    return null;
  }
  if (head.equals(tail)) {
    Node<T> result=tail;
    head=null;
    tail=null;
    size--;
    return result.getValue();
  }
  Node<T> currNode=head;
  while (currNode.getNext() != null) {
    if (currNode.getNext().equals(tail)) {
      Node<T> result=currNode.getNext();
      tail=currNode;
      size--;
      return result.getValue();
    }
    currNode=currNode.getNext();
  }
  return null;
}"
18468,"@Test public void testEnqueueAndDequeue(){
  Queue<Integer> queue=new Queue<Integer>();
  Assert.assertEquals(0,queue.getSize());
  queue.enqueue(12345);
  Assert.assertEquals(1,queue.getSize());
  int result=queue.dequeue();
  Assert.assertEquals(12345,result);
  Assert.assertEquals(0,queue.getSize());
}","@Test public void testEnqueueAndDequeue(){
  Queue<Integer> queue=new Queue<Integer>();
  Assert.assertEquals(0,queue.getSize());
  queue.enqueue(12345);
  Assert.assertEquals(1,queue.getSize());
  int result=queue.dequeue();
  Assert.assertEquals(12345,result);
  Assert.assertEquals(0,queue.getSize());
  queue.enqueue(1);
  queue.enqueue(2);
  queue.enqueue(3);
  queue.enqueue(4);
  queue.enqueue(5);
  Assert.assertEquals(5,queue.getSize());
  result=queue.dequeue();
  Assert.assertEquals(1,result);
  result=queue.dequeue();
  Assert.assertEquals(2,result);
  result=queue.dequeue();
  Assert.assertEquals(3,result);
  result=queue.dequeue();
  Assert.assertEquals(4,result);
  result=queue.dequeue();
  Assert.assertEquals(5,result);
}"
18469,"/** 
 * @see ActionListener#actionPerformed(ActionEvent)
 */
@Override public void actionPerformed(final ActionEvent e){
  final Sector sector=this.provider.getSector();
  final SelectSectorDialog dialog=sector.getGame().getSelectSectorDialog();
  dialog.setSelected(sector);
  if (dialog.open() == Result.OK)   this.provider.setSector(dialog.getSelected());
}","/** 
 * @see ActionListener#actionPerformed(ActionEvent)
 */
@Override public void actionPerformed(final ActionEvent e){
  final Sector sector=this.sectorProvider.getSector();
  final SelectSectorDialog dialog=this.gameProvider.getGame().getSelectSectorDialog();
  dialog.setSelected(sector);
  if (dialog.open() == Result.OK)   this.sectorProvider.setSector(dialog.getSelected());
}"
18470,"/** 
 * Constructor
 * @param provider The provider
 * @param context The context name (for having different action settings per context)
 */
public ChangeSectorAction(final SectorProvider provider,final String context){
  super(""String_Node_Str"",Icons.SECTOR,context);
  this.provider=provider;
  setEnabled(provider.canChangeSector());
  if (provider instanceof StateProvider)   ((StateProvider)provider).addStateListener(this);
}","/** 
 * Constructor
 * @param gameProvider The game provider.
 * @param sectorProvider The sector provider.
 * @param context The context name (for having different action settings per context)
 */
public ChangeSectorAction(final GameProvider gameProvider,final SectorProvider sectorProvider,final String context){
  super(""String_Node_Str"",Icons.SECTOR,context);
  if (gameProvider == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.gameProvider=gameProvider;
  this.sectorProvider=sectorProvider;
  setEnabled(sectorProvider.canChangeSector());
  if (sectorProvider instanceof StateProvider)   ((StateProvider)sectorProvider).addStateListener(this);
}"
18471,"/** 
 * @see de.ailis.xadrian.listeners.StateListener#stateChanged()
 */
@Override public void stateChanged(){
  setEnabled(this.provider.canChangeSector());
}","/** 
 * @see de.ailis.xadrian.listeners.StateListener#stateChanged()
 */
@Override public void stateChanged(){
  setEnabled(this.sectorProvider.canChangeSector());
}"
18472,"/** 
 * Constructor
 * @param complex The complex to edit
 */
public ComplexEditor(final Complex complex){
  super();
  setLayout(new BorderLayout());
  this.complex=complex;
  this.textPane=new JTextPane();
  this.textPane.setEditable(false);
  this.textPane.setBackground(Color.WHITE);
  this.textPane.setContentType(""String_Node_Str"");
  this.textPane.setDoubleBuffered(true);
  this.textPane.addHyperlinkListener(this);
  this.textPane.addCaretListener(this);
  final JPopupMenu popupMenu=new JPopupMenu();
  popupMenu.add(new CopyAction(this));
  popupMenu.add(new SelectAllAction(this));
  popupMenu.addSeparator();
  popupMenu.add(new AddFactoryAction(this));
  popupMenu.add(new ChangeSectorAction(this,""String_Node_Str""));
  popupMenu.add(new ChangeSunsAction(this));
  popupMenu.add(new ChangePricesAction(this));
  popupMenu.add(new JCheckBoxMenuItem(new ToggleBaseComplexAction(this)));
  SwingUtils.setPopupMenu(this.textPane,popupMenu);
  ((HTMLDocument)this.textPane.getDocument()).setBase(Main.class.getResource(""String_Node_Str""));
  final JScrollPane scrollPane=new JScrollPane(this.textPane);
  add(scrollPane);
  redraw();
  fireComplexState();
}","/** 
 * Constructor
 * @param complex The complex to edit
 */
public ComplexEditor(final Complex complex){
  super();
  setLayout(new BorderLayout());
  this.complex=complex;
  this.textPane=new JTextPane();
  this.textPane.setEditable(false);
  this.textPane.setBackground(Color.WHITE);
  this.textPane.setContentType(""String_Node_Str"");
  this.textPane.setDoubleBuffered(true);
  this.textPane.addHyperlinkListener(this);
  this.textPane.addCaretListener(this);
  final JPopupMenu popupMenu=new JPopupMenu();
  popupMenu.add(new CopyAction(this));
  popupMenu.add(new SelectAllAction(this));
  popupMenu.addSeparator();
  popupMenu.add(new AddFactoryAction(this));
  popupMenu.add(new ChangeSectorAction(this.complex,this,""String_Node_Str""));
  popupMenu.add(new ChangeSunsAction(this));
  popupMenu.add(new ChangePricesAction(this));
  popupMenu.add(new JCheckBoxMenuItem(new ToggleBaseComplexAction(this)));
  SwingUtils.setPopupMenu(this.textPane,popupMenu);
  ((HTMLDocument)this.textPane.getDocument()).setBase(Main.class.getResource(""String_Node_Str""));
  final JScrollPane scrollPane=new JScrollPane(this.textPane);
  add(scrollPane);
  redraw();
  fireComplexState();
}"
18473,"/** 
 * @see java.lang.Comparable#compareTo(java.lang.Object)
 */
@Override public int compareTo(final Asteroid o){
  int result=this.ware.compareTo(o.ware) * -1;
  if (result == 0)   result=Integer.valueOf(this.yield).compareTo(o.yield) * -1;
  if (result == 0)   result=this.id.compareTo(o.id);
  if (result == 0)   throw new RuntimeException();
  return result;
}","/** 
 * @see java.lang.Comparable#compareTo(java.lang.Object)
 */
@Override public int compareTo(final Asteroid o){
  if (this == o)   return 0;
  int result=this.ware.compareTo(o.ware) * -1;
  if (result == 0)   result=Integer.valueOf(this.yield).compareTo(o.yield) * -1;
  if (result == 0)   result=this.id.compareTo(o.id);
  return result;
}"
18474,"/** 
 * Returns the game this complex belongs to.
 * @return The game this complex belongs to
 */
public Game getGame(){
  return this.game;
}","/** 
 * @see de.ailis.xadrian.interfaces.GameProvider#getGame()
 */
@Override public Game getGame(){
  return this.game;
}"
18475,"/** 
 * Constructor
 * @param game The game this factory belongs to.
 * @param id The factory id
 * @param size The factory size
 * @param race The race
 * @param cycle The production cycle
 * @param product The produces product per cycle
 * @param price The factory price
 * @param volume The factory volume
 * @param resources The needed resources per cycle
 * @param storage The ware storage
 * @param manufacturers The manufacturer stations
 */
public Factory(final Game game,final String id,final FactorySize size,final Race race,final int cycle,final Product product,final int price,final int volume,final Product[] resources,final Capacity[] storage,final Station[] manufacturers){
  this.game=game;
  this.id=id;
  this.size=size;
  this.race=race;
  this.cycle=cycle;
  this.product=product;
  this.price=price;
  this.volume=volume;
  this.resources=resources;
  this.capacities=storage;
  this.manufacturers=manufacturers;
  this.messageId=""String_Node_Str"" + id.substring(0,id.lastIndexOf(""String_Node_Str""));
}","/** 
 * Constructor
 * @param game The game this factory belongs to. Must not be null.
 * @param id The factory id
 * @param size The factory size
 * @param race The race
 * @param cycle The production cycle
 * @param product The produces product per cycle
 * @param price The factory price
 * @param volume The factory volume
 * @param resources The needed resources per cycle
 * @param storage The ware storage
 * @param manufacturers The manufacturer stations
 */
public Factory(final Game game,final String id,final FactorySize size,final Race race,final int cycle,final Product product,final int price,final int volume,final Product[] resources,final Capacity[] storage,final Station[] manufacturers){
  if (game == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.game=game;
  this.id=id;
  this.size=size;
  this.race=race;
  this.cycle=cycle;
  this.product=product;
  this.price=price;
  this.volume=volume;
  this.resources=resources;
  this.capacities=storage;
  this.manufacturers=manufacturers;
  this.messageId=""String_Node_Str"" + id.substring(0,id.lastIndexOf(""String_Node_Str""));
}"
18476,"/** 
 * @see de.ailis.xadrian.support.ModalDialog#createDialogActions()
 */
@Override protected List<Action> createDialogActions(){
  final List<Action> dialogActions=new ArrayList<Action>();
  dialogActions.add(new ChangeSectorAction(this.asteroidsInfoPane,""String_Node_Str""));
  return dialogActions;
}","/** 
 * @see de.ailis.xadrian.support.ModalDialog#createDialogActions()
 */
@Override protected List<Action> createDialogActions(){
  final List<Action> dialogActions=new ArrayList<Action>();
  dialogActions.add(new ChangeSectorAction(this.gameProvider,this.asteroidsInfoPane,""String_Node_Str""));
  return dialogActions;
}"
18477,"/** 
 * Constructor
 * @param mineType The mine type
 */
public SetYieldsDialog(final Factory mineType){
  init(""String_Node_Str"",Result.OK,Result.CANCEL);
  setResizable(false);
  this.label.setText(I18N.getString(""String_Node_Str"",mineType.getRace().toString() + ""String_Node_Str"" + mineType.toString()));
}","/** 
 * Constructor
 * @param mineType The mine type
 */
public SetYieldsDialog(final Factory mineType){
  if (mineType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  this.gameProvider=mineType;
  init(""String_Node_Str"",Result.OK,Result.CANCEL);
  setResizable(false);
  this.label.setText(I18N.getString(""String_Node_Str"",mineType.getRace().toString() + ""String_Node_Str"" + mineType.toString()));
}"
18478,"/** 
 * Calculates and adds the factories needed to keep the factories of this complex running stable.
 */
private void calculateBaseComplex(){
  final FactoryFactory factoryFactory=FactoryFactory.getInstance();
  final RaceFactory raceFactory=RaceFactory.getInstance();
  final Ware crystals=WareFactory.getInstance().getWare(""String_Node_Str"");
  final Config config=Config.getInstance();
  long currentPrice;
  long price;
  final List<ComplexFactory> backup=new ArrayList<ComplexFactory>();
  this.autoFactories.clear();
  if (!this.addBaseComplex)   return;
  while (true)   if (!addBaseComplex(null))   break;
  currentPrice=getTotalPrice();
  for (  final Race race : raceFactory.getRaces()) {
    if (config.isRaceIgnored(race))     continue;
    if (!factoryFactory.hasFactories(race,crystals))     continue;
    backup.addAll(this.autoFactories);
    this.autoFactories.clear();
    while (true)     if (!addBaseComplex(race))     break;
    price=getTotalPrice();
    if (price < currentPrice) {
      currentPrice=price;
    }
 else {
      this.autoFactories.clear();
      this.autoFactories.addAll(backup);
    }
    backup.clear();
  }
  updateShoppingList();
}","/** 
 * Calculates and adds the factories needed to keep the factories of this complex running stable.
 */
private void calculateBaseComplex(){
  final FactoryFactory factoryFactory=FactoryFactory.getInstance();
  final RaceFactory raceFactory=RaceFactory.getInstance();
  final Ware crystals=WareFactory.getInstance().getWare(""String_Node_Str"");
  final Config config=Config.getInstance();
  long currentPrice;
  long price;
  final List<ComplexFactory> backup=new ArrayList<ComplexFactory>();
  this.autoFactories.clear();
  updateShoppingList();
  if (!this.addBaseComplex)   return;
  while (true)   if (!addBaseComplex(null))   break;
  currentPrice=getTotalPrice();
  for (  final Race race : raceFactory.getRaces()) {
    if (config.isRaceIgnored(race))     continue;
    if (!factoryFactory.hasFactories(race,crystals))     continue;
    backup.addAll(this.autoFactories);
    this.autoFactories.clear();
    while (true)     if (!addBaseComplex(race))     break;
    price=getTotalPrice();
    if (price < currentPrice) {
      currentPrice=price;
    }
 else {
      this.autoFactories.clear();
      this.autoFactories.addAll(backup);
    }
    backup.clear();
  }
  updateShoppingList();
}"
18479,"/** 
 * Increases the quantity of the factory with the given index.
 * @param index The factory index
 * @return True if quantity was changed, false if not.
 */
public boolean increaseQuantity(final int index){
  if (this.factories.get(index).increaseQuantity()) {
    updateShoppingList();
    return true;
  }
  return false;
}","/** 
 * Increases the quantity of the factory with the given index.
 * @param index The factory index
 * @return True if quantity was changed, false if not.
 */
public boolean increaseQuantity(final int index){
  if (this.factories.get(index).increaseQuantity()) {
    calculateBaseComplex();
    updateShoppingList();
    return true;
  }
  return false;
}"
18480,"/** 
 * Decreases the quantity of the factory with the given index.
 * @param index The factory index
 * @return True if quantity was changed, false if not.
 */
public boolean decreaseQuantity(final int index){
  if (this.factories.get(index).decreaseQuantity()) {
    updateShoppingList();
    return true;
  }
  return false;
}","/** 
 * Decreases the quantity of the factory with the given index.
 * @param index The factory index
 * @return True if quantity was changed, false if not.
 */
public boolean decreaseQuantity(final int index){
  if (this.factories.get(index).decreaseQuantity()) {
    calculateBaseComplex();
    updateShoppingList();
    return true;
  }
  return false;
}"
18481,"/** 
 * Creates the UI
 */
@Override protected void createUI(){
  setTitle(I18N.getTitle(""String_Node_Str""));
  setIconImages(Images.LOGOS);
  final JPanel selectorPanel=new JPanel();
  selectorPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
  final SectorSelector selector=new SectorSelector(512,512);
  this.selector=selector;
  selector.addMouseListener(new MouseAdapter(){
    /** 
 * @see MouseAdapter#mouseClicked(MouseEvent) 
 */
    @Override public void mouseClicked(    final MouseEvent e){
      if (e.getClickCount() == 2)       getRootPane().getDefaultButton().doClick(0);
    }
  }
);
  selectorPanel.add(selector);
  final JPanel controlsPanel=new JPanel();
  controlsPanel.setBorder(BorderFactory.createEmptyBorder(0,0,10,0));
  controlsPanel.setLayout(new BoxLayout(controlsPanel,BoxLayout.X_AXIS));
  final JTextField quickSearch=new JTextField();
  quickSearch.setColumns(15);
  quickSearch.addKeyListener(new KeyAdapter(){
    @Override public void keyReleased(    final KeyEvent e){
      selector.setFilter(quickSearch.getText());
    }
  }
);
  final JLabel quickSearchLabel=new JLabel(I18N.getString(""String_Node_Str""));
  quickSearchLabel.setDisplayedMnemonic(I18N.getMnemonic(""String_Node_Str""));
  quickSearchLabel.setLabelFor(quickSearch);
  final JComboBox modeComboBox=new JComboBox(SectorSelector.Mode.values());
  modeComboBox.setSelectedItem(selector.getMode());
  modeComboBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      selector.setMode((Mode)modeComboBox.getSelectedItem());
    }
  }
);
  final JLabel modeLabel=new JLabel(I18N.getString(""String_Node_Str""));
  modeLabel.setDisplayedMnemonic(I18N.getMnemonic(""String_Node_Str""));
  modeLabel.setLabelFor(modeComboBox);
  controlsPanel.add(quickSearchLabel);
  controlsPanel.add(Box.createRigidArea(new Dimension(10,0)));
  controlsPanel.add(quickSearch);
  controlsPanel.add(Box.createRigidArea(new Dimension(50,0)));
  controlsPanel.add(modeLabel);
  controlsPanel.add(Box.createRigidArea(new Dimension(10,0)));
  controlsPanel.add(modeComboBox);
  final JPanel contentPanel=new JPanel();
  contentPanel.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  contentPanel.setLayout(new BoxLayout(contentPanel,BoxLayout.Y_AXIS));
  contentPanel.add(controlsPanel);
  contentPanel.add(selectorPanel);
  add(contentPanel,BorderLayout.CENTER);
}","/** 
 * Creates the UI
 */
@Override protected void createUI(){
  setTitle(I18N.getTitle(""String_Node_Str""));
  setIconImages(Images.LOGOS);
  final JPanel selectorPanel=new JPanel();
  selectorPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
  final SectorSelector selector=new SectorSelector(512,512);
  this.selector=selector;
  selector.addMouseListener(new MouseAdapter(){
    /** 
 * @see MouseAdapter#mouseClicked(MouseEvent) 
 */
    @Override public void mouseClicked(    final MouseEvent e){
      if (e.getClickCount() == 2)       getRootPane().getDefaultButton().doClick(0);
    }
  }
);
  selectorPanel.add(selector);
  final JPanel controlsPanel=new JPanel();
  controlsPanel.setBorder(BorderFactory.createEmptyBorder(0,0,10,0));
  controlsPanel.setLayout(new BoxLayout(controlsPanel,BoxLayout.X_AXIS));
  final JTextField quickSearch=new JTextField();
  this.quickSearch=quickSearch;
  quickSearch.setColumns(15);
  quickSearch.addKeyListener(new KeyAdapter(){
    @Override public void keyReleased(    final KeyEvent e){
      selector.setFilter(quickSearch.getText());
    }
  }
);
  final JLabel quickSearchLabel=new JLabel(I18N.getString(""String_Node_Str""));
  quickSearchLabel.setDisplayedMnemonic(I18N.getMnemonic(""String_Node_Str""));
  quickSearchLabel.setLabelFor(quickSearch);
  final JComboBox modeComboBox=new JComboBox(SectorSelector.Mode.values());
  modeComboBox.setSelectedItem(selector.getMode());
  modeComboBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      selector.setMode((Mode)modeComboBox.getSelectedItem());
    }
  }
);
  final JLabel modeLabel=new JLabel(I18N.getString(""String_Node_Str""));
  modeLabel.setDisplayedMnemonic(I18N.getMnemonic(""String_Node_Str""));
  modeLabel.setLabelFor(modeComboBox);
  controlsPanel.add(quickSearchLabel);
  controlsPanel.add(Box.createRigidArea(new Dimension(10,0)));
  controlsPanel.add(quickSearch);
  controlsPanel.add(Box.createRigidArea(new Dimension(50,0)));
  controlsPanel.add(modeLabel);
  controlsPanel.add(Box.createRigidArea(new Dimension(10,0)));
  controlsPanel.add(modeComboBox);
  final JPanel contentPanel=new JPanel();
  contentPanel.setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  contentPanel.setLayout(new BoxLayout(contentPanel,BoxLayout.Y_AXIS));
  contentPanel.add(controlsPanel);
  contentPanel.add(selectorPanel);
  add(contentPanel,BorderLayout.CENTER);
}"
18482,"/** 
 * Constructor
 * @param complex The complex to edit
 */
public ComplexEditor(final Complex complex){
  super();
  setLayout(new BorderLayout());
  this.complex=complex;
  this.textPane=new JTextPane();
  this.textPane.setEditable(false);
  this.textPane.setBackground(Color.WHITE);
  this.textPane.setContentType(""String_Node_Str"");
  this.textPane.setDoubleBuffered(true);
  this.textPane.addHyperlinkListener(this);
  this.textPane.addCaretListener(this);
  final JPopupMenu popupMenu=new JPopupMenu();
  popupMenu.add(new CopyAction(this));
  popupMenu.add(new SelectAllAction(this));
  popupMenu.addSeparator();
  popupMenu.add(new AddFactoryAction(this));
  popupMenu.add(new ChangeSunsAction(this));
  popupMenu.add(new JCheckBoxMenuItem(new ToggleBaseComplexAction(this)));
  SwingUtils.setPopupMenu(this.textPane,popupMenu);
  ((HTMLDocument)this.textPane.getDocument()).setBase(Main.class.getResource(""String_Node_Str""));
  final JScrollPane scrollPane=new JScrollPane(this.textPane);
  add(scrollPane);
  redraw();
}","/** 
 * Constructor
 * @param complex The complex to edit
 */
public ComplexEditor(final Complex complex){
  super();
  setLayout(new BorderLayout());
  this.complex=complex;
  this.textPane=new JTextPane();
  this.textPane.setEditable(false);
  this.textPane.setBackground(Color.WHITE);
  this.textPane.setContentType(""String_Node_Str"");
  this.textPane.setDoubleBuffered(true);
  this.textPane.addHyperlinkListener(this);
  this.textPane.addCaretListener(this);
  final JPopupMenu popupMenu=new JPopupMenu();
  popupMenu.add(new CopyAction(this));
  popupMenu.add(new SelectAllAction(this));
  popupMenu.addSeparator();
  popupMenu.add(new AddFactoryAction(this));
  popupMenu.add(new ChangeSunsAction(this));
  popupMenu.add(new JCheckBoxMenuItem(new ToggleBaseComplexAction(this)));
  SwingUtils.setPopupMenu(this.textPane,popupMenu);
  ((HTMLDocument)this.textPane.getDocument()).setBase(Main.class.getResource(""String_Node_Str""));
  final JScrollPane scrollPane=new JScrollPane(this.textPane);
  add(scrollPane);
  redraw();
  this.fireComplexState();
}"
18483,"/** 
 * Adds the specified factory/factories to the complex.
 * @param complexFactory The factory/factories to add
 */
private void addFactory(final ComplexFactory complexFactory){
  if (complexFactory.getFactory().isMine()) {
    for (    final ComplexFactory current : this.factories) {
      if (current.getFactory().equals(complexFactory.getFactory()) && current.getYield() == complexFactory.getYield()) {
        current.addQuantity(complexFactory.getQuantity());
        return;
      }
    }
  }
  this.factories.add(complexFactory);
  Collections.sort(this.factories);
}","/** 
 * Adds the specified factory/factories to the complex.
 * @param complexFactory The factory/factories to add
 */
private void addFactory(final ComplexFactory complexFactory){
  if (!complexFactory.getFactory().isMine()) {
    for (    final ComplexFactory current : this.factories) {
      if (current.getFactory().equals(complexFactory.getFactory()) && current.getYield() == complexFactory.getYield()) {
        current.addQuantity(complexFactory.getQuantity());
        return;
      }
    }
  }
  this.factories.add(complexFactory);
  Collections.sort(this.factories);
}"
18484,"public Method getMethodFor(Class<?> clazz,String name,Object... args){
  Method[] methods=clazz.getMethods();
  Method compatibleMethod=null;
  for (  Method method : methods) {
    if (method.getName().equals(name)) {
      Class<?>[] params=method.getParameterTypes();
      Type[] types=method.getGenericParameterTypes();
      if (isMethodMatched(params,types,args)) {
        compatibleMethod=method;
        break;
      }
    }
  }
  if (compatibleMethod != null) {
    return compatibleMethod;
  }
  return null;
}","public Method getMethodFor(Class<?> clazz,String name,Object... args){
  Method[] methods=clazz.getMethods();
  for (  Method method : methods) {
    if (method.getName().equals(name)) {
      Class<?>[] params=method.getParameterTypes();
      Type[] types=method.getGenericParameterTypes();
      if (isMethodMatched(params,types,args)) {
        return method;
      }
    }
  }
  return null;
}"
18485,"public void setBeanProperties(Container container,BeanRef ref,Object bean,List<SetPropertyLater> setLater){
  if (!ref.isPropertiesSet()) {
    try {
      Logger.i(getClass().getSimpleName(),""String_Node_Str"" + ref.getName());
      List<Argument> properties=ref.getProperties();
      if (properties != null && properties.size() > 0) {
        for (        Argument property : properties) {
          if (property.getKey() != null) {
            setBeanProperty(container,ref,bean,property,setLater);
          }
 else {
            Logger.e(getClass().getSimpleName(),""String_Node_Str"" + ref.getName() + ""String_Node_Str"");
          }
        }
      }
      Logger.i(getClass().getSimpleName(),""String_Node_Str"" + ref.getName());
      ref.setPropertiesSet(true);
    }
 catch (    Exception e) {
      Logger.e(getClass().getSimpleName(),""String_Node_Str"" + ref.getName() + ""String_Node_Str"",e);
    }
  }
}","public void setBeanProperties(Container container,BeanRef ref,Object bean,List<SetPropertyLater> setLater){
  if (!ref.isSingleton() || !ref.isPropertiesSet()) {
    try {
      Logger.i(getClass().getSimpleName(),""String_Node_Str"" + ref.getName());
      List<Argument> properties=ref.getProperties();
      if (properties != null && properties.size() > 0) {
        for (        Argument property : properties) {
          if (property.getKey() != null) {
            setBeanProperty(container,ref,bean,property,setLater);
          }
 else {
            Logger.e(getClass().getSimpleName(),""String_Node_Str"" + ref.getName() + ""String_Node_Str"");
          }
        }
      }
      Logger.i(getClass().getSimpleName(),""String_Node_Str"" + ref.getName());
      if (ref.isSingleton()) {
        ref.setPropertiesSet(true);
      }
    }
 catch (    Exception e) {
      Logger.e(getClass().getSimpleName(),""String_Node_Str"" + ref.getName() + ""String_Node_Str"",e);
    }
  }
}"
18486,"public void setBean(Object bean){
  this.bean=bean;
}","public void setBean(Object bean){
  this.bean=bean;
  PROPERTY_SET_CALLS++;
}"
18487,"public Container build(Context context,BeanMapping mapping){
  Container container=new Container(mapping,this);
  buildBeans(context,container,builder,mapping,mapping.getBeanRefs(),0);
  Map<String,Object> beans=container.getBeans();
  Set<String> names=beans.keySet();
  for (  String name : names) {
    BeanRef ref=mapping.getBeanRef(name);
    Object bean=beans.get(name);
    setBeanProperties(container,ref,bean);
    initBean(container,ref,bean);
  }
  return container;
}","public Container build(Context context,BeanMapping mapping){
  Container container=new Container(mapping,this);
  buildBeans(context,container,builder,mapping,mapping.getBeanRefs(),0);
  Map<String,Object> beans=container.getBeans();
  Set<Entry<String,Object>> entrySet=beans.entrySet();
  for (  Entry<String,Object> entry : entrySet) {
    BeanRef ref=mapping.getBeanRef(entry.getKey());
    Object bean=entry.getValue();
    setBeanProperties(container,ref,bean);
    initBean(container,ref,bean);
  }
  return container;
}"
18488,"public Object coerce(Argument value){
  Object coerced=null;
  if (value.getValue() != null) {
switch (value.getType()) {
case BOOLEAN:
      coerced=Boolean.valueOf(value.getValue());
    break;
case BYTE:
  coerced=Byte.valueOf(value.getValue());
break;
case CHAR:
coerced=Character.valueOf(value.getValue().toString().toCharArray()[0]);
break;
case INTEGER:
coerced=Integer.valueOf(value.getValue());
break;
case LONG:
coerced=Long.valueOf(value.getValue());
break;
case SHORT:
coerced=Short.valueOf(value.getValue());
break;
case STRING:
coerced=value.getValue();
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + value.getType().name());
}
}
return coerced;
}","public Object coerce(Argument value){
  Object coerced=null;
  if (value.getValue() != null) {
switch (value.getType()) {
case BOOLEAN:
      coerced=Boolean.valueOf(value.getValue());
    break;
case BYTE:
  coerced=Byte.valueOf(value.getValue());
break;
case FLOAT:
coerced=Float.valueOf(value.getValue());
break;
case DOUBLE:
coerced=Double.valueOf(value.getValue());
break;
case CHAR:
coerced=Character.valueOf(value.getValue().toString().toCharArray()[0]);
break;
case INTEGER:
coerced=Integer.valueOf(value.getValue());
break;
case LONG:
coerced=Long.valueOf(value.getValue());
break;
case SHORT:
coerced=Short.valueOf(value.getValue());
break;
case STRING:
coerced=value.getValue();
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + value.getType().name());
}
}
return coerced;
}"
18489,"private boolean isMethodMatched(Class<?>[] params,Type[] genericParams,Object... args){
  if (params != null && args != null && params.length == args.length) {
    boolean match=true;
    for (int i=0; i < params.length; ++i) {
      Object arg=args[i];
      if (arg == null) {
        arg=Void.TYPE;
      }
      if (!params[i].isAssignableFrom(arg.getClass())) {
        if (params[i].isPrimitive()) {
          match&=isUnboxableToPrimitive(params[i],arg);
        }
 else {
          match=false;
        }
      }
 else       if (List.class.isAssignableFrom(params[i])) {
        match&=isListMatch(genericParams,i,arg);
      }
 else       if (Set.class.isAssignableFrom(params[i])) {
        match&=isSetMatch(genericParams,i,arg);
      }
 else       if (Map.class.isAssignableFrom(params[i])) {
        match&=isMapMatch(genericParams,i,arg);
      }
 else       if (params[i].isArray()) {
        match&=isArrayMatch(genericParams,i,arg);
      }
 else {
        match&=true;
      }
      if (!match)       break;
    }
    return match;
  }
 else   if ((params == null || params.length == 0) && (args == null || args.length == 0)) {
    return true;
  }
  return false;
}","private boolean isMethodMatched(Class<?>[] params,Type[] genericParams,Object... args){
  if (params != null && args != null && params.length == args.length) {
    boolean match=true;
    for (int i=0; i < params.length; ++i) {
      Object arg=args[i];
      if (arg == null) {
        arg=Void.TYPE;
      }
      if (!params[i].isAssignableFrom(arg.getClass())) {
        if (params[i].isPrimitive()) {
          match&=isUnboxableToPrimitive(params[i],arg);
        }
 else {
          match=false;
        }
      }
 else       if (List.class.isAssignableFrom(params[i])) {
        match&=isListMatch(genericParams,i,arg);
      }
 else       if (Set.class.isAssignableFrom(params[i])) {
        match&=isSetMatch(genericParams,i,arg);
      }
 else       if (Map.class.isAssignableFrom(params[i])) {
        match&=isMapMatch(genericParams,i,arg);
      }
 else {
        match&=true;
      }
      if (!match)       break;
    }
    return match;
  }
 else   if ((params == null || params.length == 0) && (args == null || args.length == 0)) {
    return true;
  }
  return false;
}"
18490,"private void setCollectionType(Argument arg,Attributes attributes){
  String type=attributes.getValue(""String_Node_Str"");
  if (type != null && type.trim().length() > 0) {
    try {
      CollectionType cType=CollectionType.valueOf(type.replaceAll(""String_Node_Str"",""String_Node_Str"").toUpperCase());
      if (!isCollectionTypeValid(arg,attributes,cType)) {
        Logger.w(getClass().getSimpleName(),""String_Node_Str"" + type + ""String_Node_Str""+ arg.getType()+ ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      Logger.w(getClass().getSimpleName(),""String_Node_Str"" + type + ""String_Node_Str"",e);
      setDefaultCollectionType(arg,attributes);
    }
  }
 else {
    setDefaultCollectionType(arg,attributes);
  }
}","private void setCollectionType(Argument arg,Attributes attributes){
  String type=attributes.getValue(""String_Node_Str"");
  if (type != null && type.trim().length() > 0) {
    try {
      CollectionType cType=CollectionType.valueOf(type.replaceAll(""String_Node_Str"",""String_Node_Str"").toUpperCase());
      if (isCollectionTypeValid(arg,attributes,cType)) {
        arg.setCollectionType(cType);
      }
 else {
        Logger.w(getClass().getSimpleName(),""String_Node_Str"" + type + ""String_Node_Str""+ arg.getType()+ ""String_Node_Str"");
        setDefaultCollectionType(arg,attributes);
      }
    }
 catch (    Exception e) {
      Logger.w(getClass().getSimpleName(),""String_Node_Str"" + type + ""String_Node_Str"",e);
      setDefaultCollectionType(arg,attributes);
    }
  }
 else {
    setDefaultCollectionType(arg,attributes);
  }
}"
18491,"/** 
 * Returns the full title for the program, including version number.
 * @return the title of the program
 */
public static String getTitle(){
  String version=""String_Node_Str"";
  try {
    InputStream s=Chess.class.getResourceAsStream(""String_Node_Str"");
    BufferedReader in=new BufferedReader(new InputStreamReader(s));
    version=in.readLine();
    in.close();
  }
 catch (  java.io.IOException e) {
    LOG.warning(""String_Node_Str"");
    version=""String_Node_Str"";
  }
  return TITLE_PREFIX + ""String_Node_Str"" + version;
}","/** 
 * Returns the full title for the program, including version number.
 * @return the title of the program
 */
public static String getTitle(){
  String version=""String_Node_Str"";
  try {
    InputStream s=Chess.class.getResourceAsStream(""String_Node_Str"");
    Reader isr=new InputStreamReader(s,""String_Node_Str"");
    BufferedReader in=new BufferedReader(isr);
    version=in.readLine();
    in.close();
  }
 catch (  java.io.IOException e) {
    LOG.warning(""String_Node_Str"");
    version=""String_Node_Str"";
  }
  return TITLE_PREFIX + ""String_Node_Str"" + version;
}"
18492,"/** 
 * Get the configuration.
 * @param name name of the configuration to load
 * @return the configuration
 */
public static Properties getConfig(final String name){
  Properties props;
  if (""String_Node_Str"".equals(name)) {
    props=new Properties();
  }
 else {
    props=new Properties(getConfig(""String_Node_Str""));
  }
  String filename=name + ""String_Node_Str"";
  try {
    props.load(Minimax.class.getResourceAsStream(filename));
  }
 catch (  java.io.IOException e) {
    LOG.warning(""String_Node_Str"" + name + ""String_Node_Str""+ e);
  }
  return props;
}","/** 
 * Get the configuration.
 * @param name name of the configuration to load
 * @return the configuration
 */
public static Properties getConfig(final String name){
  Properties props;
  if (""String_Node_Str"".equals(name)) {
    props=new Properties();
  }
 else {
    props=new Properties(getConfig(""String_Node_Str""));
  }
  String filename=name + ""String_Node_Str"";
  InputStream in=Minimax.class.getResourceAsStream(filename);
  try {
    props.load(in);
  }
 catch (  java.io.IOException e) {
    LOG.warning(""String_Node_Str"" + name + ""String_Node_Str""+ e);
  }
 finally {
    try {
      in.close();
    }
 catch (    Exception e) {
      LOG.info(""String_Node_Str"" + e.getMessage());
    }
  }
  return props;
}"
18493,"/** 
 * Recursive move searching.
 * @param b     board to search
 * @param depth current depth
 * @param s     side for current move
 * @param alpha lower bound to check
 * @param beta  upper bound to check
 * @return      best valuation found at lowest depth
 */
private double search(final Board b,final int depth,final Piece.Side s,final double alpha,final double beta){
  if (depth == 0) {
    return valuate(b);
  }
  Piece.Side opps=Piece.opposite(s);
  double best=alpha;
  MoveList list=b.allMoves(s,true);
  for (  Move move : list) {
    b.move(move);
    best=Math.max(best,-search(b,depth - 1,opps,-beta,-best));
    b.undo();
    if (beta <= best) {
      return best;
    }
  }
  return best;
}","/** 
 * Recursive move searching.
 * @param b     board to search
 * @param depth current depth
 * @param s     side for current move
 * @param alpha lower bound to check
 * @param beta  upper bound to check
 * @return      best valuation found at lowest depth
 */
private double search(final Board b,final int depth,final Piece.Side s,final double alpha,final double beta){
  if (depth == 0) {
    double v=valuate(b);
    return (s != side) ? -v : v;
  }
  Piece.Side opps=Piece.opposite(s);
  double best=alpha;
  MoveList list=b.allMoves(s,true);
  for (  Move move : list) {
    b.move(move);
    best=Math.max(best,-search(b,depth - 1,opps,-beta,-best));
    b.undo();
    if (beta <= best) {
      return best;
    }
  }
  return best;
}"
18494,"@Override public final void setActive(final Board curBoard,final Piece.Side currentSide){
  board=curBoard;
  side=currentSide;
  MoveList moves=board.allMoves(side,true);
  Collections.shuffle(moves);
  if (game != null) {
    game.setProgress(0);
    game.setStatus(""String_Node_Str"");
  }
  startTime=System.currentTimeMillis();
  CompletionService<Move> service=new ExecutorCompletionService<Move>(executor);
  int submitted=0;
  bestMove=null;
  for (  final Move move : moves) {
    final Board callboard=board.copy();
    service.submit(new Callable<Move>(){
      public Move call(){
        callboard.move(move);
        double beta=Double.POSITIVE_INFINITY;
        if (bestMove != null) {
          beta=-bestMove.getScore();
        }
        double v=search(callboard,maxDepth - 1,Piece.opposite(side),Double.NEGATIVE_INFINITY,beta);
        move.setScore(-v);
        return move;
      }
    }
);
    submitted++;
  }
  for (int i=0; i < submitted; i++) {
    try {
      Move m=service.take().get();
      if (bestMove == null || m.getScore() > bestMove.getScore()) {
        bestMove=m;
      }
    }
 catch (    Exception e) {
      LOG.warning(""String_Node_Str"");
    }
    if (game != null) {
      game.setProgress(i / (1.0f * (submitted - 1)));
    }
  }
  long time=(System.currentTimeMillis() - startTime);
  LOG.info(""String_Node_Str"" + (time / MILLI) + ""String_Node_Str""+ NTHREADS+ ""String_Node_Str"");
  game.move(bestMove);
}","@Override public final void setActive(final Board curBoard,final Piece.Side currentSide){
  board=curBoard;
  side=currentSide;
  MoveList moves=board.allMoves(side,true);
  Collections.shuffle(moves);
  if (game != null) {
    game.setProgress(0);
    game.setStatus(""String_Node_Str"");
  }
  startTime=System.currentTimeMillis();
  CompletionService<Move> service=new ExecutorCompletionService<Move>(executor);
  int submitted=0;
  bestMove=null;
  for (  final Move move : moves) {
    final Board callboard=board.copy();
    service.submit(new Callable<Move>(){
      public Move call(){
        callboard.move(move);
        double beta=Double.POSITIVE_INFINITY;
        if (bestMove != null) {
          beta=-bestMove.getScore();
        }
        double v=search(callboard,maxDepth - 1,Piece.opposite(side),Double.NEGATIVE_INFINITY,beta);
        move.setScore(-v);
        return move;
      }
    }
);
    submitted++;
  }
  for (int i=0; i < submitted; i++) {
    try {
      Move m=service.take().get();
      if (bestMove == null || m.getScore() > bestMove.getScore()) {
        bestMove=m;
      }
    }
 catch (    Exception e) {
      LOG.warning(""String_Node_Str"");
    }
    if (game != null) {
      game.setProgress(i / (1.0f * (submitted - 1)));
    }
  }
  long time=(System.currentTimeMillis() - startTime);
  LOG.info(""String_Node_Str"" + (time / MILLI) + ""String_Node_Str""+ NTHREADS+ ""String_Node_Str""+ maxDepth+ ""String_Node_Str"");
  game.move(bestMove);
}"
18495,"/** 
 * Perform a turn of the game.
 * @param move the move action to take
 */
public final void move(final Move move){
  if (done) {
    return;
  }
  board.move(move);
  Piece.Side opp=Piece.opposite(turn);
  if (board.checkmate(opp) || board.stalemate(opp)) {
    if (opp == Piece.Side.BLACK) {
      if (frame != null) {
        frame.setStatus(""String_Node_Str"");
      }
      winner=Piece.Side.WHITE;
    }
 else     if (opp == Piece.Side.WHITE) {
      if (frame != null) {
        frame.setStatus(""String_Node_Str"");
      }
      winner=Piece.Side.BLACK;
    }
 else {
      if (frame != null) {
        frame.setStatus(""String_Node_Str"");
      }
      winner=null;
    }
    frame.endGame();
    done=true;
    callListeners();
    return;
  }
  callListeners();
  if (!done) {
    (new Thread(this)).start();
  }
}","/** 
 * Perform a turn of the game.
 * @param move the move action to take
 */
public final void move(final Move move){
  if (done) {
    return;
  }
  board.move(move);
  Piece.Side opp=Piece.opposite(turn);
  if (board.checkmate(opp) || board.stalemate(opp)) {
    if (opp == Piece.Side.BLACK) {
      if (frame != null) {
        frame.setStatus(""String_Node_Str"");
      }
      winner=Piece.Side.WHITE;
    }
 else     if (opp == Piece.Side.WHITE) {
      if (frame != null) {
        frame.setStatus(""String_Node_Str"");
      }
      winner=Piece.Side.BLACK;
    }
 else {
      if (frame != null) {
        frame.setStatus(""String_Node_Str"");
      }
      winner=null;
    }
    if (frame != null) {
      frame.endGame();
    }
    done=true;
    callListeners();
    white.setBoard(board);
    black.setBoard(board);
    return;
  }
  callListeners();
  if (!done) {
    (new Thread(this)).start();
  }
}"
18496,"/** 
 * {@inheritDo} 
 */
public String toString(){
  String str=""String_Node_Str"";
  for (  String prop : PLIST) {
    str+=prop + ""String_Node_Str"" + get(prop)+ ""String_Node_Str"";
  }
  return str;
}","/** 
 * {@inheritDoc} 
 */
public final String toString(){
  String str=""String_Node_Str"";
  for (  String prop : PLIST) {
    str+=prop + ""String_Node_Str"" + get(prop)+ ""String_Node_Str"";
  }
  return str;
}"
18497,"/** 
 * Handle the event when the left button is clicked.
 * @param e the mouse event
 */
private void leftClick(final MouseEvent e){
  if (mode == Mode.WAIT) {
    return;
  }
  Position pos=getPixelPosition(e.getPoint());
  if (pos != null) {
    if (pos.equals(selected)) {
      selected=null;
      moves=null;
    }
 else     if (moves != null && moves.containsDest(pos)) {
      mode=Mode.WAIT;
      game.move(moves.getMoveByDest(pos));
      selected=null;
      moves=null;
    }
 else {
      Piece p=board.getPiece(pos);
      if (p != null && p.getSide() == side) {
        selected=pos;
        moves=p.getMoves(true);
      }
    }
  }
  repaint();
}","/** 
 * Handle the event when the left button is clicked.
 * @param e the mouse event
 */
private void leftClick(final MouseEvent e){
  if (mode == Mode.WAIT) {
    return;
  }
  Position pos=getPixelPosition(e.getPoint());
  if (!board.inRange(pos)) {
    return;
  }
  if (pos != null) {
    if (pos.equals(selected)) {
      selected=null;
      moves=null;
    }
 else     if (moves != null && moves.containsDest(pos)) {
      mode=Mode.WAIT;
      game.move(moves.getMoveByDest(pos));
      selected=null;
      moves=null;
    }
 else {
      Piece p=board.getPiece(pos);
      if (p != null && p.getSide() == side) {
        selected=pos;
        moves=p.getMoves(true);
      }
    }
  }
  repaint();
}"
18498,"/** 
 * Add move to list if piece can legally move there (no capture).
 * @param move move to be added
 * @return     true if position was added
 */
public final boolean addMove(final Move move){
  if (board.isFree(move.getDest()) && !causesCheck(move)) {
    super.add(move);
    return true;
  }
  return false;
}","/** 
 * Add move to list if piece can legally move there (no capture).
 * @param move move to be added
 * @return     true if position was added
 */
public final boolean addMove(final Move move){
  if (board.isFree(move.getDest())) {
    if (!causesCheck(move)) {
      super.add(move);
      return true;
    }
    return true;
  }
  return false;
}"
18499,"/** 
 * Add move to list if piece can move <i>or</i> capture at destination.
 * @param move position to be added
 * @return     true if position was added
 */
public final boolean addCapture(final Move move){
  Piece p=board.getPiece(move.getOrigin());
  if (board.isFree(move.getDest(),p.getSide()) && !causesCheck(move)) {
    super.add(move);
    return true;
  }
  return false;
}","/** 
 * Add move to list if piece can move <i>or</i> capture at destination.
 * @param move position to be added
 * @return     true if position was added
 */
public final boolean addCapture(final Move move){
  Piece p=board.getPiece(move.getOrigin());
  if (board.isFree(move.getDest(),p.getSide())) {
    if (!causesCheck(move)) {
      super.add(move);
      return true;
    }
    return true;
  }
  return false;
}"
18500,"/** 
 * {@inheritDoc} 
 */
public final MoveList getMoves(final boolean check){
  MoveList list=new MoveList(getBoard(),check);
  Position pos=getPosition();
  Board board=getBoard();
  int dir=direction();
  Position dest=new Position(pos,0,1 * dir);
  Move first=new Move(pos,dest);
  if (dest.getY() == upgradeRow()) {
    first.setNext(new Move(dest,null));
    Move upgrade=new Move(null,dest);
    upgrade.setCaptured(new Queen(getSide()));
    first.getNext().setNext(upgrade);
  }
  if (list.addMove(first)) {
    if (!moved()) {
      list.addMove(new Move(pos,new Position(pos,0,2 * dir)));
    }
  }
  list.addCaptureOnly(new Move(pos,new Position(pos,-1,1 * dir)));
  list.addCaptureOnly(new Move(pos,new Position(pos,1,1 * dir)));
  Move last=board.last();
  if (last != null) {
    Position left=new Position(pos,-1,0);
    Position right=new Position(pos,1,0);
    if (left.equals(last.getDest()) && (board.getPiece(left) instanceof Pawn)) {
      Move passant=new Move(pos,new Position(pos,-1,dir));
      passant.setNext(new Move(left,null));
      list.addMove(passant);
    }
 else     if (right.equals(last.getDest()) && (board.getPiece(right) instanceof Pawn)) {
      Move passant=new Move(pos,new Position(pos,1,dir));
      passant.setNext(new Move(right,null));
      list.addMove(passant);
    }
  }
  return list;
}","/** 
 * {@inheritDoc} 
 */
public final MoveList getMoves(final boolean check){
  MoveList list=new MoveList(getBoard(),check);
  Position pos=getPosition();
  Board board=getBoard();
  int dir=direction();
  Position dest=new Position(pos,0,1 * dir);
  Move first=new Move(pos,dest);
  if (dest.getY() == upgradeRow()) {
    first.setNext(new Move(dest,null));
    Move upgrade=new Move(null,dest);
    upgrade.setCaptured(new Queen(getSide()));
    first.getNext().setNext(upgrade);
  }
  if (list.addMove(first)) {
    if (!moved()) {
      list.addMove(new Move(pos,new Position(pos,0,2 * dir)));
    }
  }
  list.addCaptureOnly(new Move(pos,new Position(pos,-1,1 * dir)));
  list.addCaptureOnly(new Move(pos,new Position(pos,1,1 * dir)));
  Move last=board.last();
  if (last != null) {
    Position left=new Position(pos,-1,0);
    Position right=new Position(pos,1,0);
    if (left.equals(last.getDest()) && (last.getOrigin().getX() == last.getDest().getX()) && (board.getPiece(left) instanceof Pawn)) {
      Move passant=new Move(pos,new Position(pos,-1,dir));
      passant.setNext(new Move(left,null));
      list.addMove(passant);
    }
 else     if (right.equals(last.getDest()) && (last.getOrigin().getX() == last.getDest().getX()) && (board.getPiece(right) instanceof Pawn)) {
      Move passant=new Move(pos,new Position(pos,1,dir));
      passant.setNext(new Move(right,null));
      list.addMove(passant);
    }
  }
  return list;
}"
18501,"/** 
 * Determine bishop moves for given situation. This method is here for the purposes of reuse.
 * @param p     the piece being tested
 * @param list  list to be appended to
 * @return      the modified list
 */
public static final MoveList getMoves(final Piece p,final MoveList list){
  Position home=p.getPosition();
  int x=home.getX();
  int y=home.getY();
  while (x >= 0 && y >= 0) {
    x--;
    y--;
    Position pos=new Position(x,y);
    if (!list.addMove(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=home.getX();
  y=home.getY();
  while (x < p.getBoard().getWidth() && y < p.getBoard().getHeight()) {
    x++;
    y++;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=home.getX();
  y=home.getY();
  while (x >= 0 && y < p.getBoard().getHeight()) {
    x--;
    y++;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=home.getX();
  y=home.getY();
  while (x < p.getBoard().getWidth() && y >= 0) {
    x++;
    y--;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  return list;
}","/** 
 * Determine bishop moves for given situation. This method is here for the purposes of reuse.
 * @param p     the piece being tested
 * @param list  list to be appended to
 * @return      the modified list
 */
public static final MoveList getMoves(final Piece p,final MoveList list){
  Position home=p.getPosition();
  int x=home.getX();
  int y=home.getY();
  while (x >= 0 && y >= 0) {
    x--;
    y--;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=home.getX();
  y=home.getY();
  while (x < p.getBoard().getWidth() && y < p.getBoard().getHeight()) {
    x++;
    y++;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=home.getX();
  y=home.getY();
  while (x >= 0 && y < p.getBoard().getHeight()) {
    x--;
    y++;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=home.getX();
  y=home.getY();
  while (x < p.getBoard().getWidth() && y >= 0) {
    x++;
    y--;
    Position pos=new Position(x,y);
    if (!list.addCapture(new Move(home,pos))) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  return list;
}"
18502,"/** 
 * Determine rook moves for given situation. This method is here for the purposes of reuse.
 * @param p     the piece being tested
 * @param list  list to be appended to
 */
public static PositionList getMoves(Piece p,PositionList list){
  int x=p.getPosition().x;
  int y=p.getPosition().y;
  while (x >= 0) {
    x--;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=p.getPosition().x;
  y=p.getPosition().y;
  while (x < p.getBoard().getWidth()) {
    x++;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=p.getPosition().x;
  y=p.getPosition().y;
  while (y >= 0) {
    y--;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=p.getPosition().x;
  y=p.getPosition().y;
  while (y < p.getBoard().getWidth()) {
    y++;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  return list;
}","/** 
 * Determine rook moves for given situation. This method is here for the purposes of reuse.
 * @param p     the piece being tested
 * @param list  list to be appended to
 */
public static PositionList getMoves(Piece p,PositionList list){
  int x=p.getPosition().x;
  int y=p.getPosition().y;
  while (x >= 0) {
    x--;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=p.getPosition().x;
  y=p.getPosition().y;
  while (x < p.getBoard().getWidth()) {
    x++;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=p.getPosition().x;
  y=p.getPosition().y;
  while (y >= 0) {
    y--;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  x=p.getPosition().x;
  y=p.getPosition().y;
  while (y < p.getBoard().getHeight()) {
    y++;
    Position pos=new Position(x,y);
    if (!list.addMove(pos,p.getSide())) {
      break;
    }
    if (!p.getBoard().isFree(pos)) {
      break;
    }
  }
  return list;
}"
18503,"private Boolean moved(){
  Side side=getSide();
  Position pos=getPosition();
  return !((side == Side.WHITE && pos.x == 1) || (side == Side.BLACK && pos.y == 6));
}","private Boolean moved(){
  Side side=getSide();
  Position pos=getPosition();
  return !((side == Side.WHITE && pos.y == 1) || (side == Side.BLACK && pos.y == 6));
}"
18504,"public ArrayList<Position> getMoves(){
  ArrayList<Position> list=new ArrayList<Position>();
  Board b=getBoard();
  Position pos=getPosition();
  int dir=direction();
  Position first=new Position(pos.x,pos.y + 1 * dir);
  if (b.isEmpty(first) && b.inRange(first)) {
    list.add(first);
  }
  Position second=new Position(pos.x,pos.y + 2 * dir);
  if (!moved() && b.isEmpty(first) && b.inRange(first)) {
    list.add(first);
  }
  return list;
}","public ArrayList<Position> getMoves(){
  ArrayList<Position> list=new ArrayList<Position>();
  Board b=getBoard();
  Position pos=getPosition();
  int dir=direction();
  Position first=new Position(pos.x,pos.y + 1 * dir);
  if (b.isEmpty(first) && b.inRange(first)) {
    list.add(first);
  }
  Position second=new Position(pos.x,pos.y + 2 * dir);
  if (!moved() && b.isEmpty(first) && b.inRange(first)) {
    list.add(second);
  }
  return list;
}"
18505,"private void filterResources() throws MojoExecutionException {
  try {
    MavenResourcesExecution execution=new MavenResourcesExecution(getResources(),getFilteredAppDirectory(),project,encoding,null,null,session);
    execution.setEscapeWindowsPaths(escapeWindowsPaths);
    execution.setSupportMultiLineFiltering(supportMultiLineFiltering);
    if (nonFilteredFileExtensions != null) {
      execution.setNonFilteredFileExtensions(nonFilteredFileExtensions);
    }
    resourceFilter.filterResources(execution);
  }
 catch (  MavenFilteringException e) {
    throw new MojoExecutionException(""String_Node_Str"",e);
  }
}","private void filterResources() throws MojoExecutionException {
  try {
    MavenResourcesExecution execution=new MavenResourcesExecution(getResources(),getFilteredAppDirectory(),project,encoding,filters,Collections.EMPTY_LIST,session);
    execution.setEscapeWindowsPaths(escapeWindowsPaths);
    execution.setSupportMultiLineFiltering(supportMultiLineFiltering);
    if (nonFilteredFileExtensions != null) {
      execution.setNonFilteredFileExtensions(nonFilteredFileExtensions);
    }
    resourceFilter.filterResources(execution);
  }
 catch (  MavenFilteringException e) {
    throw new MojoExecutionException(""String_Node_Str"",e);
  }
}"
18506,"protected void createMuleApp(final File app) throws MojoExecutionException, ArchiverException {
  validateProject();
  MuleArchiver archiver=new MuleArchiver();
  addAppDirectory(archiver);
  addCompiledClasses(archiver);
  addDependencies(archiver);
  archiver.setDestFile(app);
  try {
    app.delete();
    archiver.createArchive();
  }
 catch (  IOException e) {
    getLog().error(""String_Node_Str"",e);
  }
}","protected void createMuleApp(final File app) throws MojoExecutionException, ArchiverException {
  validateProject();
  MuleArchiver archiver=new MuleArchiver(prependGroupId);
  addAppDirectory(archiver);
  addCompiledClasses(archiver);
  addDependencies(archiver);
  archiver.setDestFile(app);
  try {
    app.delete();
    archiver.createArchive();
  }
 catch (  IOException e) {
    getLog().error(""String_Node_Str"",e);
  }
}"
18507,"private void addDependencies(MuleArchiver archiver) throws ArchiverException {
  for (  Artifact artifact : getArtifactsToArchive()) {
    String message=String.format(""String_Node_Str"",artifact.getId());
    getLog().info(message);
    archiver.addLib(artifact.getFile());
  }
}","private void addDependencies(MuleArchiver archiver) throws ArchiverException {
  for (  Artifact artifact : getArtifactsToArchive()) {
    String message=String.format(""String_Node_Str"",artifact.getId());
    getLog().info(message);
    archiver.addLibraryArtifact(artifact);
  }
}"
18508,"protected void createMuleApp(final File app) throws MojoExecutionException, ArchiverException {
  validateProject();
  MuleArchiver archiver=new MuleArchiver(prependGroupId);
  addAppDirectory(archiver);
  addCompiledClasses(archiver);
  addDependencies(archiver);
  archiver.setDestFile(app);
  try {
    app.delete();
    archiver.createArchive();
  }
 catch (  IOException e) {
    getLog().error(""String_Node_Str"",e);
  }
}","protected void createMuleApp(final File app) throws MojoExecutionException, ArchiverException {
  validateProject();
  MuleArchiver archiver=new MuleArchiver(prependGroupId);
  addAppDirectory(archiver);
  addCompiledClasses(archiver);
  addDependencies(archiver);
  addMappingsFolder(archiver);
  archiver.setDestFile(app);
  try {
    app.delete();
    archiver.createArchive();
  }
 catch (  IOException e) {
    getLog().error(""String_Node_Str"",e);
  }
}"
18509,"public void doAggregation(Date startTime,CassandraConnectionInfo realtimeCluster,CassandraConnectionInfo offlineCluster){
  insertDataIntoOfflineCluster();
}","/** 
 * Do aggregation.
 * @param startTime the start time
 * @param realtimeCluster the realtime cluster
 * @param offlineCluster the offline cluster
 */
public void doAggregation(Date startTime,CassandraConnectionInfo realtimeCluster,CassandraConnectionInfo offlineCluster){
  insertDataIntoOfflineCluster();
}"
18510,"private void deleteExtractedDataFromRealTimeCluster(AggregationData data){
}","/** 
 * Delete extracted data from real time cluster.
 * @param data the data
 */
private void deleteExtractedDataFromRealTimeCluster(AggregationData data){
}"
18511,"public Aggregator(Date startTime,Date endTime,CassandraConnectionInfo realtimeCluster,CassandraConnectionInfo offlineCluster){
  super();
  this.startTime=startTime;
  this.endTime=endTime;
  this.realtimeCluster=realtimeCluster;
  this.offlineCluster=offlineCluster;
}","/** 
 * Instantiates a new aggregator.
 * @param startTime the start time
 * @param endTime the end time
 * @param realtimeCluster the realtime cluster
 * @param offlineCluster the offline cluster
 */
public Aggregator(Date startTime,Date endTime,CassandraConnectionInfo realtimeCluster,CassandraConnectionInfo offlineCluster){
  super();
  this.startTime=startTime;
  this.endTime=endTime;
  this.realtimeCluster=realtimeCluster;
  this.offlineCluster=offlineCluster;
}"
18512,"private void insertDataIntoOfflineCluster(){
}","/** 
 * Insert data into offline cluster.
 */
private void insertDataIntoOfflineCluster(){
}"
18513,"public CassandraConnectionInfo(String clusterName,String hostAdress,String port,String keySpaceName){
  cluster=HFactory.getOrCreateCluster(clusterName,hostAdress);
  keyspace=HFactory.createKeyspace(keySpaceName,cluster);
}","/** 
 * Instantiates a new cassandra connection info.
 * @param clusterName the cluster name
 * @param hostAdress the host adress
 * @param port the port
 * @param keySpaceName the key space name
 */
public CassandraConnectionInfo(String clusterName,String hostAdress,String port,String keySpaceName){
  cluster=HFactory.getOrCreateCluster(clusterName,hostAdress);
  keyspace=HFactory.createKeyspace(keySpaceName,cluster);
}"
18514,"public Cluster getCluster(){
  return cluster;
}","/** 
 * Gets the cluster.
 * @return the cluster
 */
public Cluster getCluster(){
  return cluster;
}"
18515,"public Keyspace getKeyspace(){
  return keyspace;
}","/** 
 * Gets the keyspace.
 * @return the keyspace
 */
public Keyspace getKeyspace(){
  return keyspace;
}"
18516,"public CassandraObject(Date startTime,Date endTime,CassandraConnectionInfo connectionInfo){
  super();
  this.startTime=startTime;
  this.endTime=endTime;
  this.connectionInfo=connectionInfo;
}","/** 
 * Instantiates a new cassandra object.
 * @param startTime the start time
 * @param endTime the end time
 * @param connectionInfo the connection info
 */
public CassandraObject(Date startTime,Date endTime,CassandraConnectionInfo connectionInfo){
  super();
  this.startTime=startTime;
  this.endTime=endTime;
  this.connectionInfo=connectionInfo;
}"
18517,"public ColumnFamilyReader(Date startTime,Date endTime,CassandraConnectionInfo connectionInfo){
  super(startTime,endTime,connectionInfo);
}","/** 
 * Instantiates a new column family reader.
 * @param startTime the start time
 * @param endTime the end time
 * @param connectionInfo the connection info
 */
public ColumnFamilyReader(Date startTime,Date endTime,CassandraConnectionInfo connectionInfo){
  super(startTime,endTime,connectionInfo);
}"
18518,"public abstract Map<KeyType,AggregationData<KeyType>> readData();","/** 
 * Read data.
 * @return the map
 */
public abstract Map<KeyType,AggregationData<KeyType>> readData();"
18519,public abstract List<KeyType> retrieveKeysInRange();,"/** 
 * Retrieve keys in range.
 * @return the list
 */
public abstract List<KeyType> retrieveKeysInRange();"
18520,"public KeyType getKey(){
  return key;
}","/** 
 * Gets the key.
 * @return the key
 */
public KeyType getKey(){
  return key;
}"
18521,"public void addColumn(Object columnKey,Object columnValue){
  this.columns.put(columnKey,columnValue);
}","/** 
 * Adds the column.
 * @param columnKey the column key
 * @param columnValue the column value
 */
public void addColumn(Object columnKey,Object columnValue){
  this.columns.put(columnKey,columnValue);
}"
18522,"public Object getValue(Object columnKey){
  return this.columns.get(columnKey);
}","/** 
 * Gets the value.
 * @param columnKey the column key
 * @return the value
 */
public Object getValue(Object columnKey){
  return this.columns.get(columnKey);
}"
18523,"public boolean contains(Object columnKey){
  return this.columns.containsKey(columnKey);
}","/** 
 * Contains.
 * @param columnKey the column key
 * @return true, if successful
 */
public boolean contains(Object columnKey){
  return this.columns.containsKey(columnKey);
}"
18524,"public int size(){
  return this.columns.size();
}","/** 
 * Size.
 * @return the int
 */
public int size(){
  return this.columns.size();
}"
18525,"public AggregationData(KeyType key){
  this(key,new HashMap<Object,Object>());
}","/** 
 * Instantiates a new aggregation data.
 * @param key the key
 */
public AggregationData(KeyType key){
  this(key,new HashMap<Object,Object>());
}"
18526,"public Map<Object,Object> getColumns(){
  return columns;
}","/** 
 * Gets the columns.
 * @return the columns
 */
public Map<Object,Object> getColumns(){
  return columns;
}"
18527,"@Override public Map<String,AggregationData<String>> readData(){
  Map<String,AggregationData<String>> result=new HashMap<String,AggregationData<String>>();
  try {
    List<String> keysToRead=retrieveKeysInRange();
    MultigetSliceQuery<String,Long,String> multigetSliceQuery=HFactory.createMultigetSliceQuery(connectionInfo.getKeyspace(),STR_SERIALIZER,LONG_SERIALIZER,STR_SERIALIZER);
    multigetSliceQuery.setColumnFamily(columnFamilyName);
    multigetSliceQuery.setKeys(keysToRead);
    multigetSliceQuery.setRange(startTime.getTime(),endTime.getTime(),false,ROWS_NUMBER_MAX_VALUE);
    QueryResult<Rows<String,Long,String>> queryResult=multigetSliceQuery.execute();
    if (queryResult != null) {
      for (      Row<String,Long,String> row : queryResult.get()) {
        AggregationData<String> rowData=new AggregationData<String>(row.getKey());
        for (        HColumn<Long,String> column : row.getColumnSlice().getColumns()) {
          rowData.addColumn(column.getName(),column.getValue());
        }
        result.put(row.getKey(),rowData);
      }
    }
 else {
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (e.getCause() != null) {
      e.getCause().printStackTrace();
    }
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public Map<String,AggregationData<String>> readData(){
  Map<String,AggregationData<String>> result=new HashMap<String,AggregationData<String>>();
  try {
    List<String> keysToRead=retrieveKeysInRange();
    MultigetSliceQuery<String,Long,String> multigetSliceQuery=HFactory.createMultigetSliceQuery(connectionInfo.getKeyspace(),STR_SERIALIZER,LONG_SERIALIZER,STR_SERIALIZER);
    multigetSliceQuery.setColumnFamily(columnFamilyName);
    multigetSliceQuery.setKeys(keysToRead);
    multigetSliceQuery.setRange(startTime.getTime(),endTime.getTime(),false,ROWS_NUMBER_MAX_VALUE);
    QueryResult<Rows<String,Long,String>> queryResult=multigetSliceQuery.execute();
    if (queryResult != null) {
      for (      Row<String,Long,String> row : queryResult.get()) {
        AggregationData<String> rowData=new AggregationData<String>(row.getKey());
        for (        HColumn<Long,String> column : row.getColumnSlice().getColumns()) {
          rowData.addColumn(column.getName(),column.getValue());
        }
        result.put(row.getKey(),rowData);
      }
    }
 else {
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (e.getCause() != null) {
      e.getCause().printStackTrace();
    }
  }
  return result;
}"
18528,"@Override public List<String> retrieveKeysInRange(){
  List<String> rowKeys=new ArrayList<String>();
  try {
    RangeSlicesQuery<String,Long,String> rangeSlicesQuery=HFactory.createRangeSlicesQuery(connectionInfo.getKeyspace(),STR_SERIALIZER,LONG_SERIALIZER,STR_SERIALIZER);
    rangeSlicesQuery.setColumnFamily(columnFamilyName);
    rangeSlicesQuery.setKeys(null,null);
    rangeSlicesQuery.setReturnKeysOnly();
    rangeSlicesQuery.setRange(startTime.getTime(),endTime.getTime(),false,ROWS_NUMBER_MAX_VALUE);
    rangeSlicesQuery.setRowCount(ROWS_NUMBER_MAX_VALUE);
    QueryResult<OrderedRows<String,Long,String>> result=rangeSlicesQuery.execute();
    OrderedRows<String,Long,String> orderedRows=result.get();
    for (    Row<String,Long,String> row : orderedRows) {
      if (!row.getColumnSlice().getColumns().isEmpty()) {
        rowKeys.add(row.getKey());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (e.getCause() != null) {
      e.getCause().printStackTrace();
    }
  }
  return rowKeys;
}","/** 
 * {@inheritDoc}
 */
@Override public List<String> retrieveKeysInRange(){
  List<String> rowKeys=new ArrayList<String>();
  try {
    RangeSlicesQuery<String,Long,String> rangeSlicesQuery=HFactory.createRangeSlicesQuery(connectionInfo.getKeyspace(),STR_SERIALIZER,LONG_SERIALIZER,STR_SERIALIZER);
    rangeSlicesQuery.setColumnFamily(columnFamilyName);
    rangeSlicesQuery.setKeys(null,null);
    rangeSlicesQuery.setReturnKeysOnly();
    rangeSlicesQuery.setRange(startTime.getTime(),endTime.getTime(),false,ROWS_NUMBER_MAX_VALUE);
    rangeSlicesQuery.setRowCount(ROWS_NUMBER_MAX_VALUE);
    QueryResult<OrderedRows<String,Long,String>> result=rangeSlicesQuery.execute();
    OrderedRows<String,Long,String> orderedRows=result.get();
    for (    Row<String,Long,String> row : orderedRows) {
      if (!row.getColumnSlice().getColumns().isEmpty()) {
        rowKeys.add(row.getKey());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    if (e.getCause() != null) {
      e.getCause().printStackTrace();
    }
  }
  return rowKeys;
}"
18529,"public AbstractErrorCountsReader(Date startTime,Date endTime,CassandraConnectionInfo connectionInfo){
  super(startTime,endTime,connectionInfo);
}","/** 
 * Instantiates a new abstract error counts reader.
 * @param startTime the start time
 * @param endTime the end time
 * @param connectionInfo the connection info
 */
public AbstractErrorCountsReader(Date startTime,Date endTime,CassandraConnectionInfo connectionInfo){
  super(startTime,endTime,connectionInfo);
}"
18530,"/** 
 * {@inheritDoc}
 */
@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  Map<Long,MetricGraphData> metricGraphDataByTime=new TreeMap<Long,MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  boolean totalizeResultsPerService=false;
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  }
  if (criteriaInfo.getOperationName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  }
  if (criteriaInfo.getConsumerName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  }
  Map<String,List<MetricValue<?>>> metricValuesMap;
  List<String> serviceNames=filters.get(""String_Node_Str"");
  List<String> operationNames=filters.get(""String_Node_Str"");
  List<String> consumerNames=filters.get(""String_Node_Str"");
  if (operationNames == null || operationNames.isEmpty()) {
    operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
    operationNames=removeServiceNamePrefix(operationNames);
    filters.put(""String_Node_Str"",operationNames);
    totalizeResultsPerService=true;
  }
  if (consumerNames != null && !consumerNames.isEmpty()) {
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      metricValuesMap=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
      for (      String consumerName : consumerNames) {
        List<MetricValue<?>> metricValues=metricValuesMap.get(consumerName);
        for (int i=0; i < duration / aggregationPeriod; ++i) {
          long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
          long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
          double value=0;
          for (          MetricValue<?> metricValue : metricValues) {
            long time=metricValue.getTimeMiliseconds();
            if (startTime <= time && time < stopTime) {
              value+=metricValue.getValueForMetric(encodedMetricName);
            }
          }
          MetricGraphData metricGraphData=new MetricGraphData();
          metricGraphData.setCount(value);
          metricGraphData.setTimeSlot(startTime);
          metricGraphData.setCriteria(null);
          if (totalizeResultsPerService) {
            MetricGraphData alreadyStoredMetricGraph=null;
            if (metricGraphDataByTime.containsKey(startTime)) {
              alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
              alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
            }
 else {
              result.add(metricGraphData);
              metricGraphDataByTime.put(startTime,metricGraphData);
            }
          }
 else {
            result.add(metricGraphData);
          }
        }
      }
    }
  }
 else {
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      metricValuesMap=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
      operationNames=filters.get(""String_Node_Str"");
      for (      String opName : operationNames) {
        List<MetricValue<?>> metricValues=metricValuesMap.get(opName);
        for (int i=0; i < duration / aggregationPeriod; ++i) {
          long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
          long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
          double value=0;
          for (          MetricValue<?> metricValue : metricValues) {
            long time=metricValue.getTimeMiliseconds();
            if (startTime <= time && time < stopTime) {
              value+=metricValue.getValueForMetric(encodedMetricName);
              break;
            }
          }
          MetricGraphData metricGraphData=new MetricGraphData();
          metricGraphData.setCount(value);
          metricGraphData.setTimeSlot(startTime);
          metricGraphData.setCriteria(null);
          if (totalizeResultsPerService) {
            MetricGraphData alreadyStoredMetricGraph=null;
            if (metricGraphDataByTime.containsKey(startTime)) {
              alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
              alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
            }
 else {
              result.add(metricGraphData);
              metricGraphDataByTime.put(startTime,metricGraphData);
            }
          }
 else {
            result.add(metricGraphData);
          }
        }
      }
    }
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  Map<Long,MetricGraphData> metricGraphDataByTime=new TreeMap<Long,MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  boolean totalizeResultsPerService=false;
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  }
  if (criteriaInfo.getOperationName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  }
  if (criteriaInfo.getConsumerName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  }
  Map<String,List<MetricValue<?>>> metricValuesMap;
  List<String> serviceNames=filters.get(""String_Node_Str"");
  List<String> operationNames=filters.get(""String_Node_Str"");
  List<String> consumerNames=filters.get(""String_Node_Str"");
  if (operationNames == null || operationNames.isEmpty()) {
    operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
    operationNames=removeServiceNamePrefix(operationNames);
    filters.put(""String_Node_Str"",operationNames);
    totalizeResultsPerService=true;
  }
  if (consumerNames != null && !consumerNames.isEmpty()) {
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(beginTime,serviceName);
      ipAddressList=ListUtils.sum(ipAddressList,ipPerDayAndServiceNameDAO.findByDateAndServiceName(endTime,serviceName));
      metricValuesMap=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
      for (      String consumerName : consumerNames) {
        List<MetricValue<?>> metricValues=metricValuesMap.get(consumerName);
        for (int i=0; i < duration / aggregationPeriod; ++i) {
          long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
          long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
          double value=0;
          if (metricValues != null) {
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=metricValue.getValueForMetric(encodedMetricName);
              }
            }
          }
          MetricGraphData metricGraphData=new MetricGraphData();
          metricGraphData.setCount(value);
          metricGraphData.setTimeSlot(startTime);
          metricGraphData.setCriteria(null);
          if (totalizeResultsPerService) {
            MetricGraphData alreadyStoredMetricGraph=null;
            if (metricGraphDataByTime.containsKey(startTime)) {
              alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
              alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
            }
 else {
              result.add(metricGraphData);
              metricGraphDataByTime.put(startTime,metricGraphData);
            }
          }
 else {
            result.add(metricGraphData);
          }
        }
      }
    }
  }
 else {
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(beginTime,serviceName);
      ipAddressList=ListUtils.sum(ipAddressList,ipPerDayAndServiceNameDAO.findByDateAndServiceName(endTime,serviceName));
      metricValuesMap=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
      operationNames=filters.get(""String_Node_Str"");
      for (      String opName : operationNames) {
        List<MetricValue<?>> metricValues=metricValuesMap.get(opName);
        for (int i=0; i < duration / aggregationPeriod; ++i) {
          long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
          long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
          double value=0;
          if (metricValues != null) {
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=metricValue.getValueForMetric(encodedMetricName);
                break;
              }
            }
          }
          MetricGraphData metricGraphData=new MetricGraphData();
          metricGraphData.setCount(value);
          metricGraphData.setTimeSlot(startTime);
          metricGraphData.setCriteria(null);
          if (totalizeResultsPerService) {
            MetricGraphData alreadyStoredMetricGraph=null;
            if (metricGraphDataByTime.containsKey(startTime)) {
              alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
              alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
            }
 else {
              result.add(metricGraphData);
              metricGraphDataByTime.put(startTime,metricGraphData);
            }
          }
 else {
            result.add(metricGraphData);
          }
        }
      }
    }
  }
  return result;
}"
18531,"/** 
 * Transform aggregated error values.
 * @param rows the rows
 * @return the map
 */
private Map<String,Map<String,Object>> transformAggregatedErrorValues(List<Map<String,Object>> rows){
  Map<String,Map<String,Object>> result=new HashMap<String,Map<String,Object>>();
  for (  Map<String,Object> row : rows) {
    long errorId=(Long)row.get(""String_Node_Str"");
    result.put(String.valueOf(errorId),row);
  }
  return result;
}","/** 
 * Transform aggregated error values.
 * @param rows the rows
 * @return the map
 */
private Map<String,Map<String,Object>> transformAggregatedErrorValues(List<Map<String,Object>> rows){
  Map<String,Map<String,Object>> result=new HashMap<String,Map<String,Object>>();
  for (  Map<String,Object> row : rows) {
    long errorId=(Long)row.get(""String_Node_Str"");
    if (result.containsKey(String.valueOf(errorId))) {
      Map<String,Object> oldRow=result.get(String.valueOf(errorId));
      Long oldErrorCount=(Long)oldRow.get(""String_Node_Str"");
      oldErrorCount+=(Long)row.get(""String_Node_Str"");
      oldRow.put(""String_Node_Str"",oldErrorCount);
    }
 else {
      result.put(String.valueOf(errorId),row);
    }
  }
  return result;
}"
18532,"/** 
 * {@inheritDoc}
 */
@Override public List<MetricGraphData> getErrorGraph(final String serviceName,final String operationName,final String consumerName,final String errorId,final String errorCategory,final String errorSeverity,final MetricCriteria metricCriteria){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  int aggregationPeriod=metricCriteria.getAggregationPeriod();
  long beginTime=metricCriteria.getFirstStartTime();
  long duration=metricCriteria.getDuration();
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(metricCriteria.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (serviceName != null && !""String_Node_Str"".equals(serviceName)) {
    filters.put(ResourceEntity.SERVICE.value(),Collections.singletonList(serviceName));
  }
  if (operationName != null && !""String_Node_Str"".equals(operationName)) {
    filters.put(ResourceEntity.OPERATION.value(),Collections.singletonList(operationName));
  }
  if (consumerName != null && !""String_Node_Str"".equals(consumerName)) {
    filters.put(ResourceEntity.CONSUMER.value(),Collections.singletonList(consumerName));
  }
  List<Map<String,Object>> queryResult=new ArrayList<Map<String,Object>>();
  if (errorCategory != null) {
    final String filter=(errorCategory == null ? null : ErrorCategory.fromValue(errorCategory).name());
    queryResult=metricsErrorsByCategoryDAO.findErrorValuesByFilter(beginTime,endTime,serverSide,aggregationPeriod,null,filter,filters);
  }
 else   if (errorSeverity != null) {
    final String filter=(errorSeverity == null ? null : ErrorSeverity.fromValue(errorSeverity).name());
    queryResult=metricsErrorsBySeverityDAO.findErrorValuesByFilter(beginTime,endTime,serverSide,aggregationPeriod,null,filter,filters);
  }
  for (int i=0; i < duration / aggregationPeriod; ++i) {
    long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
    long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
    double value=0;
    for (    Map<String,Object> row : queryResult) {
      long time=(Long)row.get(""String_Node_Str"");
      if (startTime <= time && time < stopTime) {
        value+=1;
      }
    }
    MetricGraphData metricGraphData=new MetricGraphData();
    metricGraphData.setCount(value);
    metricGraphData.setTimeSlot(startTime);
    metricGraphData.setCriteria(null);
    result.add(metricGraphData);
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<MetricGraphData> getErrorGraph(final String serviceName,final String operationName,final String consumerName,final String errorId,final String errorCategory,final String errorSeverity,final MetricCriteria metricCriteria){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  int aggregationPeriod=metricCriteria.getAggregationPeriod();
  long beginTime=metricCriteria.getFirstStartTime();
  long duration=metricCriteria.getDuration();
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(metricCriteria.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (serviceName != null && !""String_Node_Str"".equals(serviceName)) {
    filters.put(ResourceEntity.SERVICE.value(),Collections.singletonList(serviceName));
  }
  if (operationName != null && !""String_Node_Str"".equals(operationName)) {
    filters.put(ResourceEntity.OPERATION.value(),Collections.singletonList(operationName));
  }
  if (consumerName != null && !""String_Node_Str"".equals(consumerName)) {
    filters.put(ResourceEntity.CONSUMER.value(),Collections.singletonList(consumerName));
  }
  List<Map<String,Object>> queryResult=new ArrayList<Map<String,Object>>();
  if (errorCategory != null) {
    final String filter=(errorCategory == null ? null : ErrorCategory.fromValue(errorCategory).name());
    queryResult=metricsErrorsByCategoryDAO.findErrorValuesByFilter(beginTime,endTime,serverSide,aggregationPeriod,null,filter,filters);
  }
 else   if (errorSeverity != null) {
    final String filter=(errorSeverity == null ? null : ErrorSeverity.fromValue(errorSeverity).name());
    queryResult=metricsErrorsBySeverityDAO.findErrorValuesByFilter(beginTime,endTime,serverSide,aggregationPeriod,null,filter,filters);
  }
  for (int i=0; i < duration / aggregationPeriod; ++i) {
    long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
    long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
    double value=0;
    for (    Map<String,Object> row : queryResult) {
      long time=(Long)row.get(""String_Node_Str"");
      if (startTime <= time && time < stopTime) {
        value+=(Long)row.get(""String_Node_Str"");
      }
    }
    MetricGraphData metricGraphData=new MetricGraphData();
    metricGraphData.setCount(value);
    metricGraphData.setTimeSlot(startTime);
    metricGraphData.setCriteria(null);
    result.add(metricGraphData);
  }
  return result;
}"
18533,"/** 
 * {@inheritDoc}
 */
@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  String encodedMetricName=metricCriteria.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  for (  ResourceEntity resourceEntityType : ResourceEntity.values()) {
    List<String> resourceEntityNames=null;
    for (    ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
      if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
        resourceEntityNames=resourceEntityRequest.getResourceEntityName();
        break;
      }
    }
    if (resourceEntityNames == null) {
      resourceEntityNames=Collections.emptyList();
    }
    if (!resourceEntityNames.isEmpty()) {
      filters.put(resourceEntityType.value(),resourceEntityNames);
    }
  }
  String groupBy=metricResourceCriteria.getResourceEntityResponseType();
  long firstStartTime=metricCriteria.getFirstStartTime();
  long secondStartTime=metricCriteria.getSecondStartTime();
  long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
  int aggregationPeriod=metricCriteria.getAggregationPeriod();
  boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
  Map<String,List<MetricValue<?>>> data1=null;
  Map<String,List<MetricValue<?>>> data2=null;
  if (ResourceEntity.SERVICE.value().equals(groupBy)) {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      MetricGroupData metricGroupData=new MetricGroupData();
      metricGroupData.setCount1((Double)map1.get(serviceName));
      metricGroupData.setCount2((Double)map2.get(serviceName));
      CriteriaInfo criteriaInfo=new CriteriaInfo();
      criteriaInfo.setServiceName(serviceName);
      metricGroupData.setCriteriaInfo(criteriaInfo);
      result.add(metricGroupData);
    }
  }
 else   if (ResourceEntity.OPERATION.value().equals(groupBy)) {
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> consumerNames=filters.get(""String_Node_Str"");
    boolean iterateByServiceName=false;
    if (consumerNames != null && !consumerNames.isEmpty() && operationNames != null && !operationNames.isEmpty()) {
      iterateByServiceName=true;
    }
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      operationNames=filters.get(""String_Node_Str"");
      List<String> iterateBy=iterateByServiceName ? serviceNames : operationNames;
      for (      String key : iterateBy) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(key));
        metricGroupData.setCount2((Double)map2.get(key));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        if (iterateByServiceName) {
          criteriaInfo.setServiceName(key);
          criteriaInfo.setOperationName(operationNames.get(0));
        }
 else {
          criteriaInfo.setOperationName(key);
          criteriaInfo.setServiceName(serviceName);
        }
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
  }
 else   if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> serviceNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
    }
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (consumerNames == null || consumerNames.isEmpty()) {
      consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
      filters.put(""String_Node_Str"",consumerNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      data1=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
      data2=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      for (      String consumerName : consumerNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(consumerName));
        metricGroupData.setCount2((Double)map2.get(consumerName));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setConsumerName(consumerName);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
  }
 else   if (""String_Node_Str"".equals(groupBy)) {
    metricName=""String_Node_Str"";
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> serviceNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (consumerNames == null || consumerNames.isEmpty()) {
      consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
      filters.put(""String_Node_Str"",consumerNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      data1=metricValuesDAO.findMetricErrorValuesByOperation(ipAddressList,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricErrorValuesByOperation(ipAddressList,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      operationNames=filters.get(""String_Node_Str"");
      for (      String errorMetricName : metricValuesDAO.getErrorMetricNameList()) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(errorMetricName));
        metricGroupData.setCount2((Double)map2.get(errorMetricName));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setMetricName(errorMetricName);
        criteriaInfo.setServiceName(serviceName);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
  }
 else {
    throw new UnsupportedOperationException();
  }
  final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
  Collections.sort(result,new Comparator<MetricGroupData>(){
    @Override public int compare(    MetricGroupData mgd1,    MetricGroupData mgd2){
      double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
      double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
      if (v1 == v2) {
        v1=mgd1.getCount1() + mgd1.getCount2();
        v2=mgd2.getCount1() + mgd2.getCount2();
      }
      if (v1 == v2) {
        v1=mgd1.getCount2();
        v2=mgd2.getCount2();
      }
      int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
      return sortAsc ? result : -result;
    }
  }
);
  int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
  trimResultList(result,rows);
  removeZeroRowsFromList(result);
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  String encodedMetricName=metricCriteria.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  for (  ResourceEntity resourceEntityType : ResourceEntity.values()) {
    List<String> resourceEntityNames=null;
    for (    ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
      if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
        resourceEntityNames=resourceEntityRequest.getResourceEntityName();
        break;
      }
    }
    if (resourceEntityNames == null) {
      resourceEntityNames=Collections.emptyList();
    }
    if (!resourceEntityNames.isEmpty()) {
      filters.put(resourceEntityType.value(),resourceEntityNames);
    }
  }
  String groupBy=metricResourceCriteria.getResourceEntityResponseType();
  long firstStartTime=metricCriteria.getFirstStartTime();
  long secondStartTime=metricCriteria.getSecondStartTime();
  long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
  int aggregationPeriod=metricCriteria.getAggregationPeriod();
  boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
  Map<String,List<MetricValue<?>>> data1=null;
  Map<String,List<MetricValue<?>>> data2=null;
  if (ResourceEntity.SERVICE.value().equals(groupBy)) {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(firstStartTime,serviceName);
      ipAddressList=ListUtils.sum(ipAddressList,ipPerDayAndServiceNameDAO.findByDateAndServiceName(secondStartTime,serviceName));
      List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      MetricGroupData metricGroupData=new MetricGroupData();
      metricGroupData.setCount1((Double)map1.get(serviceName));
      metricGroupData.setCount2((Double)map2.get(serviceName));
      CriteriaInfo criteriaInfo=new CriteriaInfo();
      criteriaInfo.setServiceName(serviceName);
      metricGroupData.setCriteriaInfo(criteriaInfo);
      result.add(metricGroupData);
    }
  }
 else   if (ResourceEntity.OPERATION.value().equals(groupBy)) {
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> consumerNames=filters.get(""String_Node_Str"");
    boolean iterateByServiceName=false;
    if (consumerNames != null && !consumerNames.isEmpty() && operationNames != null && !operationNames.isEmpty()) {
      iterateByServiceName=true;
    }
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(firstStartTime,serviceName);
      ipAddressList=ListUtils.sum(ipAddressList,ipPerDayAndServiceNameDAO.findByDateAndServiceName(secondStartTime,serviceName));
      data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      operationNames=filters.get(""String_Node_Str"");
      List<String> iterateBy=iterateByServiceName ? serviceNames : operationNames;
      for (      String key : iterateBy) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(key));
        metricGroupData.setCount2((Double)map2.get(key));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        if (iterateByServiceName) {
          criteriaInfo.setServiceName(key);
          criteriaInfo.setOperationName(operationNames.get(0));
        }
 else {
          criteriaInfo.setOperationName(key);
          criteriaInfo.setServiceName(serviceName);
        }
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
  }
 else   if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> serviceNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
    }
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (consumerNames == null || consumerNames.isEmpty()) {
      consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
      filters.put(""String_Node_Str"",consumerNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(firstStartTime,serviceName);
      ipAddressList=ListUtils.sum(ipAddressList,ipPerDayAndServiceNameDAO.findByDateAndServiceName(secondStartTime,serviceName));
      data1=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
      data2=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      for (      String consumerName : consumerNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(consumerName));
        metricGroupData.setCount2((Double)map2.get(consumerName));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setConsumerName(consumerName);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
  }
 else   if (""String_Node_Str"".equals(groupBy)) {
    metricName=""String_Node_Str"";
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> serviceNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (consumerNames == null || consumerNames.isEmpty()) {
      consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
      filters.put(""String_Node_Str"",consumerNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(firstStartTime,serviceName);
      ipAddressList=ListUtils.sum(ipAddressList,ipPerDayAndServiceNameDAO.findByDateAndServiceName(secondStartTime,serviceName));
      data1=metricValuesDAO.findMetricErrorValuesByOperation(ipAddressList,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricErrorValuesByOperation(ipAddressList,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      operationNames=filters.get(""String_Node_Str"");
      for (      String errorMetricName : metricValuesDAO.getErrorMetricNameList()) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(errorMetricName));
        metricGroupData.setCount2((Double)map2.get(errorMetricName));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setMetricName(errorMetricName);
        criteriaInfo.setServiceName(serviceName);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
  }
 else {
    throw new UnsupportedOperationException();
  }
  final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
  Collections.sort(result,new Comparator<MetricGroupData>(){
    @Override public int compare(    MetricGroupData mgd1,    MetricGroupData mgd2){
      double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
      double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
      if (v1 == v2) {
        v1=mgd1.getCount1() + mgd1.getCount2();
        v2=mgd2.getCount1() + mgd2.getCount2();
      }
      if (v1 == v2) {
        v1=mgd1.getCount2();
        v2=mgd2.getCount2();
      }
      int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
      return sortAsc ? result : -result;
    }
  }
);
  int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
  trimResultList(result,rows);
  removeZeroRowsFromList(result);
  return result;
}"
18534,"/** 
 * {@inheritDoc}
 */
public List<Map<K,Object>> findErrorValuesByFilter(long beginTime,long endTime,boolean serverSide,int aggregationPeriod,Long errorId,String filter,Map<String,List<String>> filters){
  final List<String> errorKeys=KeyGeneratorUtil.generateErrorValuesKeys(serverSide,filters,filter);
  Map<K,Map<Long,String>> findItems=findItemsWithStringColumnValues((List<K>)errorKeys,beginTime,endTime);
  List<Map<K,Object>> result=new ArrayList<Map<K,Object>>();
  Set<Entry<K,Map<Long,String>>> entrySet=findItems.entrySet();
  for (  Entry<K,Map<Long,String>> findItemSet : entrySet) {
    Map<Long,String> value=findItemSet.getValue();
    Set<Entry<Long,String>> entrySet2=value.entrySet();
    for (    Entry<Long,String> findItemSet2 : entrySet2) {
      Map<K,Object> row=new HashMap<K,Object>();
      String errorValueKey=findItemSet2.getValue();
      ErrorValue errorValue=errorValuesDaoImpl.find(errorValueKey);
      row.put((K)""String_Node_Str"",errorByIdDaoImpl.findCountByTimeRange(errorValue.getErrorId(),beginTime,endTime));
      row.put((K)""String_Node_Str"",errorValue.getErrorId());
      row.put((K)""String_Node_Str"",errorValue.getName());
      if (filters.get(ResourceEntity.CONSUMER.value()) != null) {
        row.put((K)""String_Node_Str"",errorValue.getConsumerName());
      }
      row.put((K)""String_Node_Str"",errorValue.isServerSide());
      row.put((K)""String_Node_Str"",findItemSet2.getKey());
      result.add(row);
    }
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<Map<K,Object>> findErrorValuesByFilter(long beginTime,long endTime,boolean serverSide,int aggregationPeriod,Long errorId,String filter,Map<String,List<String>> filters){
  final List<String> errorKeys=KeyGeneratorUtil.generateErrorValuesKeys(serverSide,filters,filter);
  Map<K,Map<Long,String>> findItems=findItemsWithStringColumnValues((List<K>)errorKeys,beginTime,endTime);
  List<Map<K,Object>> result=new ArrayList<Map<K,Object>>();
  Set<Entry<K,Map<Long,String>>> entrySet=findItems.entrySet();
  for (  Entry<K,Map<Long,String>> findItemSet : entrySet) {
    Map<Long,String> value=findItemSet.getValue();
    Set<Entry<Long,String>> entrySet2=value.entrySet();
    for (    Entry<Long,String> findItemSet2 : entrySet2) {
      Map<K,Object> row=new HashMap<K,Object>();
      String errorValueKey=findItemSet2.getValue();
      ErrorValue errorValue=errorValuesDaoImpl.find(errorValueKey);
      row.put((K)""String_Node_Str"",1L);
      row.put((K)""String_Node_Str"",errorValue.getErrorId());
      row.put((K)""String_Node_Str"",errorValue.getName());
      if (filters.get(ResourceEntity.CONSUMER.value()) != null) {
        row.put((K)""String_Node_Str"",errorValue.getConsumerName());
      }
      row.put((K)""String_Node_Str"",errorValue.isServerSide());
      row.put((K)""String_Node_Str"",findItemSet2.getKey());
      result.add(row);
    }
  }
  return result;
}"
18535,"@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  if (criteriaInfo.getOperationName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  if (criteriaInfo.getConsumerName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  Map<String,List<MetricValue<?>>> metricValuesByOperationName;
  try {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> operationNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=this.ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      metricValuesByOperationName=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
      operationNames=filters.get(""String_Node_Str"");
      for (      String opName : operationNames) {
        List<MetricValue<?>> metricValues=metricValuesByOperationName.get(opName);
        for (int i=0; i < duration / aggregationPeriod; ++i) {
          long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
          long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
          double value=0;
          for (          MetricValue<?> metricValue : metricValues) {
            long time=metricValue.getTimeMiliseconds();
            if (startTime <= time && time < stopTime) {
              value+=(Double)metricValue.getValueForMetric(encodedMetricName);
              break;
            }
          }
          MetricGraphData metricGraphData=new MetricGraphData();
          metricGraphData.setCount(value);
          metricGraphData.setTimeSlot(startTime);
          metricGraphData.setCriteria(null);
          result.add(metricGraphData);
        }
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}","@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  boolean totalizeResultsPerService=false;
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  if (criteriaInfo.getOperationName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  if (criteriaInfo.getConsumerName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  Map<String,List<MetricValue<?>>> metricValuesMap;
  try {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      totalizeResultsPerService=true;
    }
    if (consumerNames != null && !consumerNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=this.ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        metricValuesMap=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        for (        String consumerName : consumerNames) {
          List<MetricValue<?>> metricValues=metricValuesMap.get(consumerName);
          for (int i=0; i < duration / aggregationPeriod; ++i) {
            long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
            long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
            double value=0;
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=(Double)metricValue.getValueForMetric(encodedMetricName);
                break;
              }
            }
            MetricGraphData metricGraphData=new MetricGraphData();
            metricGraphData.setCount(value);
            metricGraphData.setTimeSlot(startTime);
            metricGraphData.setCriteria(null);
            result.add(metricGraphData);
          }
        }
      }
    }
 else {
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=this.ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        metricValuesMap=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
        operationNames=filters.get(""String_Node_Str"");
        for (        String opName : operationNames) {
          List<MetricValue<?>> metricValues=metricValuesMap.get(opName);
          for (int i=0; i < duration / aggregationPeriod; ++i) {
            long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
            long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
            double value=0;
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=(Double)metricValue.getValueForMetric(encodedMetricName);
                break;
              }
            }
            MetricGraphData metricGraphData=new MetricGraphData();
            metricGraphData.setCount(value);
            metricGraphData.setTimeSlot(startTime);
            metricGraphData.setCriteria(null);
            result.add(metricGraphData);
          }
        }
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}"
18536,"/** 
 * Save metric snapshot.
 * @param timeSnapshot the time snapshot
 * @param snapshotCollection the snapshot collection
 * @throws ServiceException the service exception
 * @see org.ebayopensource.turmeric.runtime.common.monitoring.MetricsStorageProvider#saveMetricSnapshot(long,java.util.Collection)
 */
@Override public void saveMetricSnapshot(long timeSnapshot,Collection<MetricValueAggregator> snapshotCollection) throws ServiceException {
  try {
    System.out.println(""String_Node_Str"" + (snapshotCollection != null));
    if (snapshotCollection == null || snapshotCollection.isEmpty()) {
      System.out.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"" + snapshotCollection.size());
    for (    MetricValueAggregator metricValueAggregator : snapshotCollection) {
      System.out.println(""String_Node_Str"" + (metricValueAggregator != null));
      org.ebayopensource.turmeric.runtime.common.monitoring.MetricId metricId=metricValueAggregator.getMetricId();
      if (metricId.getOperationName() == null) {
        if (!storeServiceMetrics) {
          continue;
        }
      }
      metricValueAggregator=resolve(metricValueAggregator);
      MetricIdentifier<String> cmetricIdentifier=null;
      Collection<MetricClassifier> classifiers=metricValueAggregator.getClassifiers();
      System.out.println(""String_Node_Str"" + classifiers.size());
      for (      MetricClassifier metricClassifier : classifiers) {
        org.ebayopensource.turmeric.runtime.common.monitoring.value.MetricValue metricValue=metricValueAggregator.getValue(metricClassifier);
        org.ebayopensource.turmeric.runtime.common.monitoring.value.MetricComponentValue[] metricComponentValues=metricValue.getValues();
        if (valuesAreNonZero(metricComponentValues)) {
          if (cmetricIdentifier == null) {
            cmetricIdentifier=findMetricId(getKeyfromMetricId(metricId,serverSide));
            if (cmetricIdentifier == null) {
              createMetricId(metricId,metricValueAggregator);
              cmetricIdentifier=findMetricId(getKeyfromMetricId(metricId,serverSide));
            }
          }
          metricsDAO.saveServiceOperationByIpCF(getIPAddress(),cmetricIdentifier);
          metricsDAO.saveServiceConsumerByIpCF(getIPAddress(),cmetricIdentifier,metricClassifier.getUseCase());
        }
        metricsDAO.saveMetricValues(getIPAddress(),cmetricIdentifier,timeSnapshot,snapshotInterval,serverSide,metricValue,metricClassifier.getUseCase());
      }
      cmetricIdentifier=null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    previousSnapshot=snapshotCollection;
  }
}","/** 
 * Save metric snapshot.
 * @param timeSnapshot the time snapshot
 * @param snapshotCollection the snapshot collection
 * @throws ServiceException the service exception
 * @see org.ebayopensource.turmeric.runtime.common.monitoring.MetricsStorageProvider#saveMetricSnapshot(long,java.util.Collection)
 */
@Override public void saveMetricSnapshot(long timeSnapshot,Collection<MetricValueAggregator> snapshotCollection) throws ServiceException {
  try {
    System.out.println(""String_Node_Str"" + (snapshotCollection != null));
    if (snapshotCollection == null || snapshotCollection.isEmpty()) {
      System.out.println(""String_Node_Str"");
      return;
    }
    System.out.println(""String_Node_Str"" + snapshotCollection.size());
    for (    MetricValueAggregator metricValueAggregator : snapshotCollection) {
      System.out.println(""String_Node_Str"" + (metricValueAggregator != null));
      org.ebayopensource.turmeric.runtime.common.monitoring.MetricId metricId=metricValueAggregator.getMetricId();
      if (metricId.getOperationName() == null) {
        if (!storeServiceMetrics) {
          continue;
        }
      }
      metricValueAggregator=resolve(metricValueAggregator);
      MetricIdentifier<String> cmetricIdentifier=null;
      Collection<MetricClassifier> classifiers=metricValueAggregator.getClassifiers();
      System.out.println(""String_Node_Str"" + classifiers.size());
      for (      MetricClassifier metricClassifier : classifiers) {
        org.ebayopensource.turmeric.runtime.common.monitoring.value.MetricValue metricValue=metricValueAggregator.getValue(metricClassifier);
        org.ebayopensource.turmeric.runtime.common.monitoring.value.MetricComponentValue[] metricComponentValues=metricValue.getValues();
        if (valuesAreNonZero(metricComponentValues)) {
          if (cmetricIdentifier == null) {
            cmetricIdentifier=findMetricId(getKeyfromMetricId(metricId,serverSide));
            if (cmetricIdentifier == null) {
              createMetricId(metricId,metricValueAggregator);
              cmetricIdentifier=findMetricId(getKeyfromMetricId(metricId,serverSide));
            }
          }
          metricsDAO.saveServiceOperationByIpCF(getIPAddress(),cmetricIdentifier);
          metricsDAO.saveServiceConsumerByIpCF(getIPAddress(),cmetricIdentifier,metricClassifier.getUseCase());
          metricsDAO.saveMetricValues(getIPAddress(),cmetricIdentifier,timeSnapshot,snapshotInterval,serverSide,metricValue,metricClassifier.getUseCase());
        }
      }
      cmetricIdentifier=null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    previousSnapshot=snapshotCollection;
  }
}"
18537,"@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  if (criteriaInfo.getOperationName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  if (criteriaInfo.getConsumerName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  Map<String,List<MetricValue<?>>> metricValuesByOperationName;
  try {
    metricValuesByOperationName=metricValuesDAO.findMetricValuesByOperation(metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
    List<MetricValue<?>> metricValues=metricValuesByOperationName.get(criteriaInfo.getOperationName());
    for (int i=0; i < duration / aggregationPeriod; ++i) {
      long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
      long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
      double value=0;
      for (      MetricValue<?> metricValue : metricValues) {
        long time=metricValue.getTimeMiliseconds();
        if (startTime <= time && time < stopTime) {
          value+=(Double)metricValue.getValueForMetric(encodedMetricName);
          break;
        }
      }
      MetricGraphData metricGraphData=new MetricGraphData();
      metricGraphData.setCount(value);
      metricGraphData.setTimeSlot(startTime);
      metricGraphData.setCriteria(null);
      result.add(metricGraphData);
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}","@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  if (criteriaInfo.getOperationName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  if (criteriaInfo.getConsumerName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  Map<String,List<MetricValue<?>>> metricValuesByOperationName;
  try {
    List<String> operationNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    metricValuesByOperationName=metricValuesDAO.findMetricValuesByOperation(metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
    operationNames=filters.get(""String_Node_Str"");
    for (    String opName : operationNames) {
      List<MetricValue<?>> metricValues=metricValuesByOperationName.get(opName);
      for (int i=0; i < duration / aggregationPeriod; ++i) {
        long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
        long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
        double value=0;
        for (        MetricValue<?> metricValue : metricValues) {
          long time=metricValue.getTimeMiliseconds();
          if (startTime <= time && time < stopTime) {
            value+=(Double)metricValue.getValueForMetric(encodedMetricName);
            break;
          }
        }
        MetricGraphData metricGraphData=new MetricGraphData();
        metricGraphData.setCount(value);
        metricGraphData.setTimeSlot(startTime);
        metricGraphData.setCriteria(null);
        result.add(metricGraphData);
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}"
18538,"@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  try {
    String encodedMetricName=metricCriteria.getMetricName();
    String metricName=decodeMetricName(encodedMetricName);
    Map<String,List<String>> filters=new HashMap<String,List<String>>();
    for (    ResourceEntity resourceEntityType : ResourceEntity.values()) {
      List<String> resourceEntityNames=null;
      for (      ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
        if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
          resourceEntityNames=resourceEntityRequest.getResourceEntityName();
          break;
        }
      }
      if (resourceEntityNames == null)       resourceEntityNames=Collections.emptyList();
      if (!resourceEntityNames.isEmpty())       filters.put(resourceEntityType.value(),resourceEntityNames);
    }
    String groupBy=metricResourceCriteria.getResourceEntityResponseType();
    long firstStartTime=metricCriteria.getFirstStartTime();
    long secondStartTime=metricCriteria.getSecondStartTime();
    long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
    int aggregationPeriod=metricCriteria.getAggregationPeriod();
    boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
    Map<String,List<MetricValue<?>>> data1=null;
    Map<String,List<MetricValue<?>>> data2=null;
    if (ResourceEntity.SERVICE.value().equals(groupBy)) {
    }
 else     if (ResourceEntity.OPERATION.value().equals(groupBy)) {
      data1=metricValuesDAO.findMetricValuesByOperation(metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      List<String> operationNames=filters.get(""String_Node_Str"");
      for (      String operation : operationNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(operation));
        metricGroupData.setCount2((Double)map2.get(operation));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setOperationName(operation);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
    }
 else     if (""String_Node_Str"".equals(groupBy)) {
    }
 else {
      throw new UnsupportedOperationException();
    }
    final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
    Collections.sort(result,new Comparator<MetricGroupData>(){
      @Override public int compare(      MetricGroupData mgd1,      MetricGroupData mgd2){
        double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
        double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
        if (v1 == v2) {
          v1=mgd1.getCount1() + mgd1.getCount2();
          v2=mgd2.getCount1() + mgd2.getCount2();
        }
        if (v1 == v2) {
          v1=mgd1.getCount2();
          v2=mgd2.getCount2();
        }
        int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        return sortAsc ? result : -result;
      }
    }
);
    int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
    trimResultList(result,rows);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return result;
}","@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  try {
    String encodedMetricName=metricCriteria.getMetricName();
    String metricName=decodeMetricName(encodedMetricName);
    Map<String,List<String>> filters=new HashMap<String,List<String>>();
    for (    ResourceEntity resourceEntityType : ResourceEntity.values()) {
      List<String> resourceEntityNames=null;
      for (      ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
        if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
          resourceEntityNames=resourceEntityRequest.getResourceEntityName();
          break;
        }
      }
      if (resourceEntityNames == null)       resourceEntityNames=Collections.emptyList();
      if (!resourceEntityNames.isEmpty())       filters.put(resourceEntityType.value(),resourceEntityNames);
    }
    String groupBy=metricResourceCriteria.getResourceEntityResponseType();
    long firstStartTime=metricCriteria.getFirstStartTime();
    long secondStartTime=metricCriteria.getSecondStartTime();
    long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
    int aggregationPeriod=metricCriteria.getAggregationPeriod();
    boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
    Map<String,List<MetricValue<?>>> data1=null;
    Map<String,List<MetricValue<?>>> data2=null;
    if (ResourceEntity.SERVICE.value().equals(groupBy)) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      data1=metricValuesDAO.findMetricValuesByOperation(metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      for (      String operation : operationNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(operation));
        metricGroupData.setCount2((Double)map2.get(operation));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setOperationName(operation);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.OPERATION.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        List<String> serviceNames=filters.get(""String_Node_Str"");
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
      }
      data1=metricValuesDAO.findMetricValuesByOperation(metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      operationNames=filters.get(""String_Node_Str"");
      for (      String operation : operationNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(operation));
        metricGroupData.setCount2((Double)map2.get(operation));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setOperationName(operation);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
    }
 else     if (""String_Node_Str"".equals(groupBy)) {
    }
 else {
      throw new UnsupportedOperationException();
    }
    final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
    Collections.sort(result,new Comparator<MetricGroupData>(){
      @Override public int compare(      MetricGroupData mgd1,      MetricGroupData mgd2){
        double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
        double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
        if (v1 == v2) {
          v1=mgd1.getCount1() + mgd1.getCount2();
          v2=mgd2.getCount1() + mgd2.getCount2();
        }
        if (v1 == v2) {
          v1=mgd1.getCount2();
          v2=mgd2.getCount2();
        }
        int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        return sortAsc ? result : -result;
      }
    }
);
    int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
    trimResultList(result,rows);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return result;
}"
18539,"@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  if (criteriaInfo.getOperationName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  if (criteriaInfo.getConsumerName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  Map<String,List<MetricValue<?>>> metricValuesByOperationName;
  try {
    List<String> operationNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    metricValuesByOperationName=metricValuesDAO.findMetricValuesByOperation(metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
    operationNames=filters.get(""String_Node_Str"");
    for (    String opName : operationNames) {
      List<MetricValue<?>> metricValues=metricValuesByOperationName.get(opName);
      for (int i=0; i < duration / aggregationPeriod; ++i) {
        long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
        long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
        double value=0;
        for (        MetricValue<?> metricValue : metricValues) {
          long time=metricValue.getTimeMiliseconds();
          if (startTime <= time && time < stopTime) {
            value+=(Double)metricValue.getValueForMetric(encodedMetricName);
            break;
          }
        }
        MetricGraphData metricGraphData=new MetricGraphData();
        metricGraphData.setCount(value);
        metricGraphData.setTimeSlot(startTime);
        metricGraphData.setCriteria(null);
        result.add(metricGraphData);
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}","@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  if (criteriaInfo.getOperationName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  if (criteriaInfo.getConsumerName() != null)   filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  Map<String,List<MetricValue<?>>> metricValuesByOperationName;
  try {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> operationNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
    }
    for (    String serviceName : serviceNames) {
      List<String> ipAddressList=this.ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
      metricValuesByOperationName=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
      operationNames=filters.get(""String_Node_Str"");
      for (      String opName : operationNames) {
        List<MetricValue<?>> metricValues=metricValuesByOperationName.get(opName);
        for (int i=0; i < duration / aggregationPeriod; ++i) {
          long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
          long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
          double value=0;
          for (          MetricValue<?> metricValue : metricValues) {
            long time=metricValue.getTimeMiliseconds();
            if (startTime <= time && time < stopTime) {
              value+=(Double)metricValue.getValueForMetric(encodedMetricName);
              break;
            }
          }
          MetricGraphData metricGraphData=new MetricGraphData();
          metricGraphData.setCount(value);
          metricGraphData.setTimeSlot(startTime);
          metricGraphData.setCriteria(null);
          result.add(metricGraphData);
        }
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}"
18540,"/** 
 * Instantiates a new Metrics Query Service cassandra provider impl.
 */
public SOAMetricsQueryServiceCassandraProviderImpl(){
  getCassandraConfig();
  if (Boolean.valueOf(embeed)) {
    CassandraManager.initialize();
  }
  metricsErrorByIdDAO=new MetricsErrorByIdDAOImpl<Long>(clusterName,host,keyspace,errorByIdCF,Long.class);
  metricsErrorValuesDAO=new MetricsErrorValuesDAOImpl(clusterName,host,keyspace,errorValuesCF,String.class);
  metricsErrorsByCategoryDAO=new MetricsErrorsByCategoryDAOImpl<String>(clusterName,host,keyspace,errorsByCategoryCF,String.class,metricsErrorValuesDAO,metricsErrorByIdDAO);
  metricsErrorsBySeverityDAO=new MetricsErrorsBySeverityDAOImpl<String>(clusterName,host,keyspace,errorsBySeverityCF,String.class,metricsErrorValuesDAO,metricsErrorByIdDAO);
  metricIdentifierDAO=new MetricIdentifierDAOImpl<String>(clusterName,host,keyspace,metricsCF,String.class);
  metricTimeSeriesDAO=new MetricTimeSeriesDAOImpl<String>(clusterName,host,keyspace,metricByTimeSeriesCF,String.class);
  metricsServiceConsumerByIpDAO=new MetricsServiceConsumerByIpDAOImpl<String,String>(clusterName,host,keyspace,metricConsumerByIpCF,String.class,String.class);
  metricValuesDAO=new MetricValuesDAOImpl<String>(clusterName,host,keyspace,metricValuesCF,String.class);
  metricsServiceOperationByIpDAO=new MetricsServiceOperationByIpDAOImpl<String,String>(clusterName,host,keyspace,metricServiceOperationByIpCF,String.class,String.class);
  metricServiceCallsByTimeDAO=new MetricServiceCallsByTimeDAOImpl<String,Long>(clusterName,host,keyspace,metricServiceCallsByTimeCF,String.class,Long.class);
  metricValuesByIpAndDateDAO=new MetricValuesByIpAndDateDAOImpl<String,Long>(clusterName,host,keyspace,metricValuesByIpAndDateCF,String.class,Long.class);
}","/** 
 * Instantiates a new Metrics Query Service cassandra provider impl.
 */
public SOAMetricsQueryServiceCassandraProviderImpl(){
  getCassandraConfig();
  if (Boolean.valueOf(embeed)) {
    CassandraManager.initialize();
  }
  metricsErrorByIdDAO=new MetricsErrorByIdDAOImpl<Long>(clusterName,host,keyspace,errorByIdCF,Long.class);
  metricsErrorValuesDAO=new MetricsErrorValuesDAOImpl(clusterName,host,keyspace,errorValuesCF,String.class);
  metricsErrorsByCategoryDAO=new MetricsErrorsByCategoryDAOImpl<String>(clusterName,host,keyspace,errorsByCategoryCF,String.class,metricsErrorValuesDAO,metricsErrorByIdDAO);
  metricsErrorsBySeverityDAO=new MetricsErrorsBySeverityDAOImpl<String>(clusterName,host,keyspace,errorsBySeverityCF,String.class,metricsErrorValuesDAO,metricsErrorByIdDAO);
  metricIdentifierDAO=new MetricIdentifierDAOImpl<String>(clusterName,host,keyspace,metricsCF,String.class);
  metricTimeSeriesDAO=new MetricTimeSeriesDAOImpl<String>(clusterName,host,keyspace,metricByTimeSeriesCF,String.class);
  metricsServiceConsumerByIpDAO=new MetricsServiceConsumerByIpDAOImpl<String,String>(clusterName,host,keyspace,metricConsumerByIpCF,String.class,String.class);
  metricValuesDAO=new MetricValuesDAOImpl<String>(clusterName,host,keyspace,metricValuesCF,String.class);
  metricsServiceOperationByIpDAO=new MetricsServiceOperationByIpDAOImpl<String,String>(clusterName,host,keyspace,metricServiceOperationByIpCF,String.class,String.class);
  metricServiceCallsByTimeDAO=new MetricServiceCallsByTimeDAOImpl<String,Long>(clusterName,host,keyspace,metricServiceCallsByTimeCF,String.class,Long.class);
  metricValuesByIpAndDateDAO=new MetricValuesByIpAndDateDAOImpl<String,Long>(clusterName,host,keyspace,metricValuesByIpAndDateCF,String.class,Long.class);
  ipPerDayAndServiceNameDAO=new org.ebayopensource.turmeric.monitoring.provider.dao.impl.IpPerDayAndServiceNameDAOImpl<String,String>(clusterName,host,keyspace,""String_Node_Str"",String.class,String.class);
}"
18541,"@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  try {
    String encodedMetricName=metricCriteria.getMetricName();
    String metricName=decodeMetricName(encodedMetricName);
    Map<String,List<String>> filters=new HashMap<String,List<String>>();
    for (    ResourceEntity resourceEntityType : ResourceEntity.values()) {
      List<String> resourceEntityNames=null;
      for (      ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
        if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
          resourceEntityNames=resourceEntityRequest.getResourceEntityName();
          break;
        }
      }
      if (resourceEntityNames == null)       resourceEntityNames=Collections.emptyList();
      if (!resourceEntityNames.isEmpty())       filters.put(resourceEntityType.value(),resourceEntityNames);
    }
    String groupBy=metricResourceCriteria.getResourceEntityResponseType();
    long firstStartTime=metricCriteria.getFirstStartTime();
    long secondStartTime=metricCriteria.getSecondStartTime();
    long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
    int aggregationPeriod=metricCriteria.getAggregationPeriod();
    boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
    Map<String,List<MetricValue<?>>> data1=null;
    Map<String,List<MetricValue<?>>> data2=null;
    if (ResourceEntity.SERVICE.value().equals(groupBy)) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      data1=metricValuesDAO.findMetricValuesByOperation(metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      for (      String operation : operationNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(operation));
        metricGroupData.setCount2((Double)map2.get(operation));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setOperationName(operation);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.OPERATION.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        List<String> serviceNames=filters.get(""String_Node_Str"");
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
      }
      data1=metricValuesDAO.findMetricValuesByOperation(metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
      data2=metricValuesDAO.findMetricValuesByOperation(metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
      Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
      Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
      operationNames=filters.get(""String_Node_Str"");
      for (      String operation : operationNames) {
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(operation));
        metricGroupData.setCount2((Double)map2.get(operation));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setOperationName(operation);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
    }
 else     if (""String_Node_Str"".equals(groupBy)) {
    }
 else {
      throw new UnsupportedOperationException();
    }
    final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
    Collections.sort(result,new Comparator<MetricGroupData>(){
      @Override public int compare(      MetricGroupData mgd1,      MetricGroupData mgd2){
        double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
        double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
        if (v1 == v2) {
          v1=mgd1.getCount1() + mgd1.getCount2();
          v2=mgd2.getCount1() + mgd2.getCount2();
        }
        if (v1 == v2) {
          v1=mgd1.getCount2();
          v2=mgd2.getCount2();
        }
        int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        return sortAsc ? result : -result;
      }
    }
);
    int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
    trimResultList(result,rows);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return result;
}","@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  try {
    String encodedMetricName=metricCriteria.getMetricName();
    String metricName=decodeMetricName(encodedMetricName);
    Map<String,List<String>> filters=new HashMap<String,List<String>>();
    for (    ResourceEntity resourceEntityType : ResourceEntity.values()) {
      List<String> resourceEntityNames=null;
      for (      ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
        if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
          resourceEntityNames=resourceEntityRequest.getResourceEntityName();
          break;
        }
      }
      if (resourceEntityNames == null)       resourceEntityNames=Collections.emptyList();
      if (!resourceEntityNames.isEmpty())       filters.put(resourceEntityType.value(),resourceEntityNames);
    }
    String groupBy=metricResourceCriteria.getResourceEntityResponseType();
    long firstStartTime=metricCriteria.getFirstStartTime();
    long secondStartTime=metricCriteria.getSecondStartTime();
    long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
    int aggregationPeriod=metricCriteria.getAggregationPeriod();
    boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
    Map<String,List<MetricValue<?>>> data1=null;
    Map<String,List<MetricValue<?>>> data2=null;
    if (ResourceEntity.SERVICE.value().equals(groupBy)) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=this.ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
        data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        for (        String operation : operationNames) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(operation));
          metricGroupData.setCount2((Double)map2.get(operation));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setOperationName(operation);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else     if (ResourceEntity.OPERATION.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      List<String> serviceNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
      }
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=this.ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        operationNames=filters.get(""String_Node_Str"");
        for (        String operation : operationNames) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(operation));
          metricGroupData.setCount2((Double)map2.get(operation));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setOperationName(operation);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else     if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
    }
 else     if (""String_Node_Str"".equals(groupBy)) {
    }
 else {
      throw new UnsupportedOperationException();
    }
    final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
    Collections.sort(result,new Comparator<MetricGroupData>(){
      @Override public int compare(      MetricGroupData mgd1,      MetricGroupData mgd2){
        double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
        double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
        if (v1 == v2) {
          v1=mgd1.getCount1() + mgd1.getCount2();
          v2=mgd2.getCount1() + mgd2.getCount2();
        }
        if (v1 == v2) {
          v1=mgd1.getCount2();
          v2=mgd2.getCount2();
        }
        int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        return sortAsc ? result : -result;
      }
    }
);
    int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
    trimResultList(result,rows);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return result;
}"
18542,"public Map<String,List<MetricValue<?>>> findMetricValuesByOperation(String metricName,long firstStartTime,long l,boolean serverSide,int aggregationPeriod,Map<String,List<String>> filters) throws ServiceException ;","public Map<String,List<MetricValue<?>>> findMetricValuesByOperation(List<String> ipaddressList,String metricName,long firstStartTime,long l,boolean serverSide,int aggregationPeriod,Map<String,List<String>> filters) throws ServiceException ;"
18543,"/** 
 * {@inheritDoc}
 */
@Override public Map<String,List<MetricValue<?>>> findMetricValuesByOperation(String metricName,long begin,long end,boolean serverSide,int aggregationPeriod,Map<String,List<String>> filters) throws ServiceException {
  Map<String,List<MetricValue<?>>> result=new HashMap<String,List<MetricValue<?>>>();
  List<String> serviceAdminNames=filters.get(""String_Node_Str"");
  List<String> operationNames=filters.get(""String_Node_Str"");
  List<String> consumerNames=filters.get(""String_Node_Str"");
  String serviceName=serviceAdminNames.get(0);
  for (  String operation : operationNames) {
    Set<String> metricValuesToGet=new HashSet<String>();
    SliceQuery<String,Long,String> q=HFactory.createSliceQuery(keySpace,StringSerializer.get(),LongSerializer.get(),StringSerializer.get());
    q.setColumnFamily(""String_Node_Str"");
    String metricTimeSeriesKey=createMetricTimeSeriesKey(metricName,serviceName,operation,aggregationPeriod,serverSide);
    q.setKey(metricTimeSeriesKey);
    q.setRange(begin,end,false,100000000);
    QueryResult<ColumnSlice<Long,String>> r=q.execute();
    ColumnSlice<Long,String> columnSlice=r.get();
    for (    HColumn<Long,String> column : columnSlice.getColumns()) {
      if (column.getValue() != null && column.getValue().contains(metricName)) {
        metricValuesToGet.add(column.getValue());
      }
    }
    System.out.printf(""String_Node_Str"" + metricValuesToGet + ""String_Node_Str"",metricName,begin,end,serverSide,aggregationPeriod,metricTimeSeriesKey);
    List<MetricValue<?>> metricValues=this.findByKeys(metricValuesToGet);
    result.put(operation,metricValues);
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public Map<String,List<MetricValue<?>>> findMetricValuesByOperation(List<String> ipAddressList,String metricName,long begin,long end,boolean serverSide,int aggregationPeriod,Map<String,List<String>> filters) throws ServiceException {
  Map<String,List<MetricValue<?>>> result=new HashMap<String,List<MetricValue<?>>>();
  List<String> serviceAdminNames=filters.get(""String_Node_Str"");
  List<String> operationNames=filters.get(""String_Node_Str"");
  List<String> consumerNames=filters.get(""String_Node_Str"");
  String serviceName=serviceAdminNames.get(0);
  Map<Long,MetricValue<?>> metricValuesByTime=new TreeMap<Long,MetricValue<?>>();
  for (  String operation : operationNames) {
    for (    String ipAddress : ipAddressList) {
      Set<String> metricValuesToGet=new HashSet<String>();
      SliceQuery<String,Long,String> q=HFactory.createSliceQuery(keySpace,StringSerializer.get(),LongSerializer.get(),StringSerializer.get());
      q.setColumnFamily(""String_Node_Str"");
      String metricTimeSeriesKey=createMetricTimeSeriesKey(ipAddress,metricName,serviceName,operation,aggregationPeriod,serverSide);
      q.setKey(metricTimeSeriesKey);
      q.setRange(begin,end,false,100000000);
      QueryResult<ColumnSlice<Long,String>> r=q.execute();
      ColumnSlice<Long,String> columnSlice=r.get();
      for (      HColumn<Long,String> column : columnSlice.getColumns()) {
        if (column.getValue() != null && column.getValue().contains(metricName)) {
          metricValuesToGet.add(column.getValue());
        }
      }
      System.out.printf(""String_Node_Str"" + metricValuesToGet + ""String_Node_Str"",metricName,begin,end,serverSide,aggregationPeriod,metricTimeSeriesKey);
      List<MetricValue<?>> metricValues=this.findByKeys(metricValuesToGet);
      for (      MetricValue<?> metricValue : metricValues) {
        metricValuesByTime.put(metricValue.getTimeMiliseconds(),metricValue);
      }
    }
    List<MetricValue<?>> theList=new ArrayList<MetricValue<?>>();
    theList.addAll(metricValuesByTime.values());
    result.put(operation,theList);
  }
  return result;
}"
18544,"/** 
 * Creates the metric time series key.
 * @param metricName the metric name
 * @param serviceName the service name
 * @param operationName the operation name
 * @param snapshotInterval the snapshot interval
 * @param isServerSide the is server side
 * @return the string
 * @throws ServiceException the service exception
 */
private String createMetricTimeSeriesKey(String metricName,String serviceName,String operationName,int snapshotInterval,boolean isServerSide) throws ServiceException {
  String ipAddress=getIPAddress();
  return ipAddress + KEY_SEPARATOR + serviceName+ KEY_SEPARATOR+ operationName+ KEY_SEPARATOR+ metricName+ KEY_SEPARATOR+ snapshotInterval+ KEY_SEPARATOR+ isServerSide;
}","/** 
 * Creates the metric time series key.
 * @param metricName the metric name
 * @param serviceName the service name
 * @param operationName the operation name
 * @param snapshotInterval the snapshot interval
 * @param isServerSide the is server side
 * @return the string
 * @throws ServiceException the service exception
 */
private String createMetricTimeSeriesKey(String ipAddress,String metricName,String serviceName,String operationName,int snapshotInterval,boolean isServerSide) throws ServiceException {
  return ipAddress + KEY_SEPARATOR + serviceName+ KEY_SEPARATOR+ operationName+ KEY_SEPARATOR+ metricName+ KEY_SEPARATOR+ snapshotInterval+ KEY_SEPARATOR+ isServerSide;
}"
18545,"/** 
 * {@inheritDoc}
 */
@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  try {
    String encodedMetricName=metricCriteria.getMetricName();
    String metricName=decodeMetricName(encodedMetricName);
    Map<String,List<String>> filters=new HashMap<String,List<String>>();
    for (    ResourceEntity resourceEntityType : ResourceEntity.values()) {
      List<String> resourceEntityNames=null;
      for (      ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
        if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
          resourceEntityNames=resourceEntityRequest.getResourceEntityName();
          break;
        }
      }
      if (resourceEntityNames == null) {
        resourceEntityNames=Collections.emptyList();
      }
      if (!resourceEntityNames.isEmpty()) {
        filters.put(resourceEntityType.value(),resourceEntityNames);
      }
    }
    String groupBy=metricResourceCriteria.getResourceEntityResponseType();
    long firstStartTime=metricCriteria.getFirstStartTime();
    long secondStartTime=metricCriteria.getSecondStartTime();
    long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
    int aggregationPeriod=metricCriteria.getAggregationPeriod();
    boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
    Map<String,List<MetricValue<?>>> data1=null;
    Map<String,List<MetricValue<?>>> data2=null;
    if (ResourceEntity.SERVICE.value().equals(groupBy)) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
        data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(serviceName));
        metricGroupData.setCount2((Double)map2.get(serviceName));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setServiceName(serviceName);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.OPERATION.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      List<String> serviceNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
      }
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        operationNames=filters.get(""String_Node_Str"");
        for (        String operation : operationNames) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(operation));
          metricGroupData.setCount2((Double)map2.get(operation));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setOperationName(operation);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else     if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      List<String> serviceNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
      }
      List<String> consumerNames=filters.get(""String_Node_Str"");
      if (consumerNames == null || consumerNames.isEmpty()) {
        consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
        filters.put(""String_Node_Str"",consumerNames);
      }
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        data1=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        data2=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        for (        String consumerName : consumerNames) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(consumerName));
          metricGroupData.setCount2((Double)map2.get(consumerName));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setConsumerName(consumerName);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else     if (""String_Node_Str"".equals(groupBy)) {
    }
 else {
      throw new UnsupportedOperationException();
    }
    final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
    Collections.sort(result,new Comparator<MetricGroupData>(){
      @Override public int compare(      MetricGroupData mgd1,      MetricGroupData mgd2){
        double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
        double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
        if (v1 == v2) {
          v1=mgd1.getCount1() + mgd1.getCount2();
          v2=mgd2.getCount1() + mgd2.getCount2();
        }
        if (v1 == v2) {
          v1=mgd1.getCount2();
          v2=mgd2.getCount2();
        }
        int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        return sortAsc ? result : -result;
      }
    }
);
    int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
    trimResultList(result,rows);
    removeZeroRowsFromList(result);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<MetricGroupData> getMetricsData(MetricCriteria metricCriteria,MetricResourceCriteria metricResourceCriteria){
  List<MetricGroupData> result=new ArrayList<MetricGroupData>();
  try {
    String encodedMetricName=metricCriteria.getMetricName();
    String metricName=decodeMetricName(encodedMetricName);
    Map<String,List<String>> filters=new HashMap<String,List<String>>();
    for (    ResourceEntity resourceEntityType : ResourceEntity.values()) {
      List<String> resourceEntityNames=null;
      for (      ResourceEntityRequest resourceEntityRequest : metricResourceCriteria.getResourceRequestEntities()) {
        if (resourceEntityRequest.getResourceEntityType() == resourceEntityType) {
          resourceEntityNames=resourceEntityRequest.getResourceEntityName();
          break;
        }
      }
      if (resourceEntityNames == null) {
        resourceEntityNames=Collections.emptyList();
      }
      if (!resourceEntityNames.isEmpty()) {
        filters.put(resourceEntityType.value(),resourceEntityNames);
      }
    }
    String groupBy=metricResourceCriteria.getResourceEntityResponseType();
    long firstStartTime=metricCriteria.getFirstStartTime();
    long secondStartTime=metricCriteria.getSecondStartTime();
    long duration=TimeUnit.SECONDS.toMillis(metricCriteria.getDuration());
    int aggregationPeriod=metricCriteria.getAggregationPeriod();
    boolean serverSide=!MonitoringSystem.COLLECTION_LOCATION_CLIENT.equals(metricCriteria.getRoleType());
    Map<String,List<MetricValue<?>>> data1=null;
    Map<String,List<MetricValue<?>>> data2=null;
    if (ResourceEntity.SERVICE.value().equals(groupBy)) {
      List<String> serviceNames=filters.get(""String_Node_Str"");
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        List<String> operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
        data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        MetricGroupData metricGroupData=new MetricGroupData();
        metricGroupData.setCount1((Double)map1.get(serviceName));
        metricGroupData.setCount2((Double)map2.get(serviceName));
        CriteriaInfo criteriaInfo=new CriteriaInfo();
        criteriaInfo.setServiceName(serviceName);
        metricGroupData.setCriteriaInfo(criteriaInfo);
        result.add(metricGroupData);
      }
    }
 else     if (ResourceEntity.OPERATION.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      List<String> serviceNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
      }
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        data1=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        operationNames=filters.get(""String_Node_Str"");
        for (        String operation : operationNames) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(operation));
          metricGroupData.setCount2((Double)map2.get(operation));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setOperationName(operation);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else     if (ResourceEntity.CONSUMER.value().equals(groupBy)) {
      List<String> operationNames=filters.get(""String_Node_Str"");
      List<String> serviceNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
      }
      List<String> consumerNames=filters.get(""String_Node_Str"");
      if (consumerNames == null || consumerNames.isEmpty()) {
        consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
        filters.put(""String_Node_Str"",consumerNames);
      }
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        data1=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        data2=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        for (        String consumerName : consumerNames) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(consumerName));
          metricGroupData.setCount2((Double)map2.get(consumerName));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setConsumerName(consumerName);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else     if (""String_Node_Str"".equals(groupBy)) {
      metricName=""String_Node_Str"";
      List<String> operationNames=filters.get(""String_Node_Str"");
      List<String> serviceNames=filters.get(""String_Node_Str"");
      if (operationNames == null || operationNames.isEmpty()) {
        operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
        operationNames=removeServiceNamePrefix(operationNames);
        filters.put(""String_Node_Str"",operationNames);
      }
      List<String> consumerNames=filters.get(""String_Node_Str"");
      if (consumerNames == null || consumerNames.isEmpty()) {
        consumerNames=metricsServiceConsumerByIpDAO.findMetricConsumerNames(serviceNames);
        filters.put(""String_Node_Str"",consumerNames);
      }
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        data1=metricValuesDAO.findMetricErrorValuesByOperation(ipAddressList,firstStartTime,firstStartTime + duration,serverSide,aggregationPeriod,filters);
        data2=metricValuesDAO.findMetricErrorValuesByOperation(ipAddressList,secondStartTime,secondStartTime + duration,serverSide,aggregationPeriod,filters);
        Map<String,Object> map1=transformAggregatedMetricComponentValues(encodedMetricName,data1);
        Map<String,Object> map2=transformAggregatedMetricComponentValues(encodedMetricName,data2);
        operationNames=filters.get(""String_Node_Str"");
        for (        String errorMetricName : metricValuesDAO.getErrorMetricNameList()) {
          MetricGroupData metricGroupData=new MetricGroupData();
          metricGroupData.setCount1((Double)map1.get(errorMetricName));
          metricGroupData.setCount2((Double)map2.get(errorMetricName));
          CriteriaInfo criteriaInfo=new CriteriaInfo();
          criteriaInfo.setMetricName(errorMetricName);
          criteriaInfo.setServiceName(serviceName);
          metricGroupData.setCriteriaInfo(criteriaInfo);
          result.add(metricGroupData);
        }
      }
    }
 else {
      throw new UnsupportedOperationException();
    }
    final boolean sortAsc=metricCriteria.getSortOrder() == SortOrderType.ASCENDING;
    Collections.sort(result,new Comparator<MetricGroupData>(){
      @Override public int compare(      MetricGroupData mgd1,      MetricGroupData mgd2){
        double v1=Math.max(mgd1.getCount1(),mgd1.getCount2());
        double v2=Math.max(mgd2.getCount1(),mgd2.getCount2());
        if (v1 == v2) {
          v1=mgd1.getCount1() + mgd1.getCount2();
          v2=mgd2.getCount1() + mgd2.getCount2();
        }
        if (v1 == v2) {
          v1=mgd1.getCount2();
          v2=mgd2.getCount2();
        }
        int result=v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
        return sortAsc ? result : -result;
      }
    }
);
    int rows=metricCriteria.getNumRows() == null ? 0 : Integer.parseInt(metricCriteria.getNumRows());
    trimResultList(result,rows);
    removeZeroRowsFromList(result);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return result;
}"
18546,"/** 
 * Find metric values by consumer.
 * @param ipAddressList the ip address list
 * @param metricName the metric name
 * @param begin the begin
 * @param end the end
 * @param serverSide the server side
 * @param aggregationPeriod the aggregation period
 * @param serviceName the service name
 * @param operationNames the operation names
 * @param consumerNames the consumer names
 * @return the map
 * @throws ServiceException the service exception
 */
Map<String,List<MetricValue<?>>> findMetricValuesByConsumer(List<String> ipAddressList,String metricName,long begin,long end,boolean serverSide,int aggregationPeriod,String serviceName,List<String> operationNames,List<String> consumerNames) throws ServiceException ;","/** 
 * Find metric values by consumer.
 * @param ipAddressList the ip address list
 * @param metricName the metric name
 * @param begin the begin
 * @param end the end
 * @param serverSide the server side
 * @param aggregationPeriod the aggregation period
 * @param serviceName the service name
 * @param operationNames the operation names
 * @param consumerNames the consumer names
 * @return the mapString metricName,
 * @throws ServiceException the service exception
 */
Map<String,List<MetricValue<?>>> findMetricValuesByConsumer(List<String> ipAddressList,String metricName,long begin,long end,boolean serverSide,int aggregationPeriod,String serviceName,List<String> operationNames,List<String> consumerNames) throws ServiceException ;"
18547,"private double retrieveCallCounts(long startTime,long duration,double calls1){
  List<String> metricValuesList=new ArrayList<String>();
  List<?> valuesByIpAndDateList=metricValuesByIpAndDateDAO.findByRange(Long.valueOf(startTime),Long.valueOf(startTime + duration));
  for (  Object superModel : valuesByIpAndDateList) {
    Map<Long,Model> superColumns=((SuperModel<String,Long>)superModel).getColumns();
    for (    Entry<Long,Model> superColumn : superColumns.entrySet()) {
      Model<String> model=superColumn.getValue();
      Map<String,Object> columns=model.getColumns();
      for (      Entry<String,Object> column : columns.entrySet()) {
        if (column.getKey().contains(SystemMetricDefs.OP_TIME_TOTAL.getMetricName())) {
          metricValuesList.add(column.getKey());
        }
      }
    }
  }
  for (  String metricValueKey : metricValuesList) {
    org.ebayopensource.turmeric.monitoring.provider.model.MetricValue<?> metricValue=metricValuesDAO.find(metricValueKey);
    Map<String,Object> columns=metricValue.getColumns();
    if (columns != null && !columns.isEmpty()) {
      if (columns.containsKey(""String_Node_Str"")) {
        Object value=columns.get(""String_Node_Str"");
        if (value != null) {
          calls1=calls1 + Long.valueOf(value.toString());
        }
      }
    }
  }
  return calls1;
}","private double retrieveCallCounts(long startTime,long duration,double calls1){
  List<String> metricValuesList=new ArrayList<String>();
  List<?> valuesByIpAndDateList=metricValuesByIpAndDateDAO.findByRange(Long.valueOf(startTime),Long.valueOf(startTime + duration));
  for (  Object superModel : valuesByIpAndDateList) {
    Map<Long,Model> superColumns=((SuperModel<String,Long>)superModel).getColumns();
    for (    Entry<Long,Model> superColumn : superColumns.entrySet()) {
      Model<String> model=superColumn.getValue();
      Map<String,Object> columns=model.getColumns();
      for (      Entry<String,Object> column : columns.entrySet()) {
        if (column.getKey().contains(SystemMetricDefs.OP_TIME_TOTAL.getMetricName())) {
          metricValuesList.add(column.getKey());
        }
      }
    }
  }
  for (  String metricValueKey : metricValuesList) {
    org.ebayopensource.turmeric.monitoring.provider.model.MetricValue<?> metricValue=metricValuesDAO.find(metricValueKey);
    Map<String,Object> columns=metricValue.getColumns();
    if (columns != null && !columns.isEmpty()) {
      if (columns.containsKey(""String_Node_Str"")) {
        Object value=columns.get(""String_Node_Str"");
        if (value != null) {
          calls1=calls1 + (Long)value;
        }
      }
    }
  }
  return calls1;
}"
18548,"private Map<String,List<String>> populateFilters(final List<String> serviceNames,final List<String> operationNames,final List<String> consumerNames){
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (!serviceNames.isEmpty()) {
    filters.put(ResourceEntity.SERVICE.value(),serviceNames);
  }
  if (!operationNames.isEmpty()) {
    filters.put(ResourceEntity.OPERATION.value(),operationNames);
  }
  if (!consumerNames.isEmpty()) {
    filters.put(ResourceEntity.CONSUMER.value(),consumerNames);
  }
  return filters;
}","private Map<String,List<String>> populateFilters(final List<String> serviceNames,final List<String> operationNames,final List<String> consumerNames){
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (serviceNames != null && !serviceNames.isEmpty()) {
    filters.put(ResourceEntity.SERVICE.value(),serviceNames);
  }
  if (operationNames != null && !operationNames.isEmpty()) {
    filters.put(ResourceEntity.OPERATION.value(),operationNames);
  }
  if (consumerNames != null && !consumerNames.isEmpty()) {
    filters.put(ResourceEntity.CONSUMER.value(),consumerNames);
  }
  return filters;
}"
18549,"/** 
 * Instantiates a new Metrics Query Service cassandra provider impl.
 */
public SOAMetricsQueryServiceCassandraProviderImpl(){
  getCassandraConfig();
  if (Boolean.valueOf(embeed)) {
    CassandraManager.initialize();
  }
  metricsErrorByIdDAO=new MetricsErrorByIdDAOImpl<Long>(clusterName,host,keyspace,errorByIdCF,Long.class);
  metricsErrorValuesDAO=new MetricsErrorValuesDAOImpl(clusterName,host,keyspace,errorValuesCF,String.class);
  metricsErrorsByCategoryDAO=new MetricsErrorsByCategoryDAOImpl<String>(clusterName,host,keyspace,errorsByCategoryCF,String.class,metricsErrorValuesDAO);
  metricsErrorsBySeverityDAO=new MetricsErrorsBySeverityDAOImpl<String>(clusterName,host,keyspace,errorsBySeverityCF,String.class,metricsErrorValuesDAO);
  metricIdentifierDAO=new MetricIdentifierDAOImpl<String>(clusterName,host,keyspace,metricsCF,String.class);
  metricTimeSeriesDAO=new MetricTimeSeriesDAOImpl<String>(clusterName,host,keyspace,metricByTimeSeriesCF,String.class);
  metricsServiceConsumerByIpDAO=new MetricsServiceConsumerByIpDAOImpl<String,String>(clusterName,host,keyspace,metricConsumerByIpCF,String.class,String.class);
  metricValuesDAO=new MetricValuesDAOImpl<String>(clusterName,host,keyspace,metricValuesCF,String.class);
  metricsServiceOperationByIpDAO=new MetricsServiceOperationByIpDAOImpl<String,String>(clusterName,host,keyspace,metricServiceOperationByIpCF,String.class,String.class);
  metricServiceCallsByTimeDAO=new MetricServiceCallsByTimeDAOImpl<String,Long>(clusterName,host,keyspace,metricServiceCallsByTimeCF,String.class,Long.class);
  metricValuesByIpAndDateDAO=new MetricValuesByIpAndDateDAOImpl<String,Long>(clusterName,host,keyspace,metricValuesByIpAndDateCF,String.class,Long.class);
}","/** 
 * Instantiates a new Metrics Query Service cassandra provider impl.
 */
public SOAMetricsQueryServiceCassandraProviderImpl(){
  getCassandraConfig();
  if (Boolean.valueOf(embeed)) {
    CassandraManager.initialize();
  }
  metricsErrorByIdDAO=new MetricsErrorByIdDAOImpl<Long>(clusterName,host,keyspace,errorByIdCF,Long.class);
  metricsErrorValuesDAO=new MetricsErrorValuesDAOImpl(clusterName,host,keyspace,errorValuesCF,String.class);
  metricsErrorsByCategoryDAO=new MetricsErrorsByCategoryDAOImpl<String>(clusterName,host,keyspace,errorsByCategoryCF,String.class,metricsErrorValuesDAO,metricsErrorByIdDAO);
  metricsErrorsBySeverityDAO=new MetricsErrorsBySeverityDAOImpl<String>(clusterName,host,keyspace,errorsBySeverityCF,String.class,metricsErrorValuesDAO,metricsErrorByIdDAO);
  metricIdentifierDAO=new MetricIdentifierDAOImpl<String>(clusterName,host,keyspace,metricsCF,String.class);
  metricTimeSeriesDAO=new MetricTimeSeriesDAOImpl<String>(clusterName,host,keyspace,metricByTimeSeriesCF,String.class);
  metricsServiceConsumerByIpDAO=new MetricsServiceConsumerByIpDAOImpl<String,String>(clusterName,host,keyspace,metricConsumerByIpCF,String.class,String.class);
  metricValuesDAO=new MetricValuesDAOImpl<String>(clusterName,host,keyspace,metricValuesCF,String.class);
  metricsServiceOperationByIpDAO=new MetricsServiceOperationByIpDAOImpl<String,String>(clusterName,host,keyspace,metricServiceOperationByIpCF,String.class,String.class);
  metricServiceCallsByTimeDAO=new MetricServiceCallsByTimeDAOImpl<String,Long>(clusterName,host,keyspace,metricServiceCallsByTimeCF,String.class,Long.class);
  metricValuesByIpAndDateDAO=new MetricValuesByIpAndDateDAOImpl<String,Long>(clusterName,host,keyspace,metricValuesByIpAndDateCF,String.class,Long.class);
}"
18550,Error<?> find(K key);,public Error<?> find(K key);
18551,"public BaseMetricsErrorsByFiltersDAOImpl(final String clusterName,final String host,final String s_keyspace,final String columnFamilyName,final Class<K> kTypeClass,final MetricsErrorValuesDAO<String> errorValuesDaoImpl){
  super(clusterName,host,s_keyspace,kTypeClass,Model.class,columnFamilyName);
  this.errorValuesDaoImpl=errorValuesDaoImpl;
}","public BaseMetricsErrorsByFiltersDAOImpl(final String clusterName,final String host,final String s_keyspace,final String columnFamilyName,final Class<K> kTypeClass,final MetricsErrorValuesDAO<String> errorValuesDaoImpl,final MetricsErrorByIdDAO<Long> errorByIdDaoImpl){
  super(clusterName,host,s_keyspace,kTypeClass,Model.class,columnFamilyName);
  this.errorValuesDaoImpl=errorValuesDaoImpl;
  this.errorByIdDaoImpl=errorByIdDaoImpl;
}"
18552,"public List<Map<K,Object>> findErrorValuesByFilter(long beginTime,long endTime,boolean serverSide,int aggregationPeriod,Long errorId,String filter,Map<String,List<String>> filters){
  final List<String> errorKeys=KeyGeneratorUtil.generateErrorValuesKeys(serverSide,filters,filter);
  Map<K,Map<Long,String>> findItems=findItemsWithStringColumnValues((List<K>)errorKeys,beginTime,endTime);
  List<Map<K,Object>> result=new ArrayList<Map<K,Object>>();
  Set<Entry<K,Map<Long,String>>> entrySet=findItems.entrySet();
  for (  Entry<K,Map<Long,String>> findItemSet : entrySet) {
    Map<Long,String> value=findItemSet.getValue();
    Set<Entry<Long,String>> entrySet2=value.entrySet();
    for (    Entry<Long,String> findItemSet2 : entrySet2) {
      Map<K,Object> row=new HashMap<K,Object>();
      String errorValueKey=findItemSet2.getValue();
      ErrorValue errorValue=errorValuesDaoImpl.find(errorValueKey);
      row.put((K)""String_Node_Str"",200l);
      row.put((K)""String_Node_Str"",errorValue.getErrorId());
      row.put((K)""String_Node_Str"",errorValue.getName());
      if (filters.get(ResourceEntity.CONSUMER.value()) != null || !filters.get(ResourceEntity.CONSUMER.value()).isEmpty()) {
        row.put((K)""String_Node_Str"",errorValue.getConsumerName());
      }
      row.put((K)""String_Node_Str"",errorValue.isServerSide());
      row.put((K)""String_Node_Str"",findItemSet2.getKey());
      result.add(row);
    }
  }
  return result;
}","public List<Map<K,Object>> findErrorValuesByFilter(long beginTime,long endTime,boolean serverSide,int aggregationPeriod,Long errorId,String filter,Map<String,List<String>> filters){
  final List<String> errorKeys=KeyGeneratorUtil.generateErrorValuesKeys(serverSide,filters,filter);
  Map<K,Map<Long,String>> findItems=findItemsWithStringColumnValues((List<K>)errorKeys,beginTime,endTime);
  List<Map<K,Object>> result=new ArrayList<Map<K,Object>>();
  Set<Entry<K,Map<Long,String>>> entrySet=findItems.entrySet();
  for (  Entry<K,Map<Long,String>> findItemSet : entrySet) {
    Map<Long,String> value=findItemSet.getValue();
    Set<Entry<Long,String>> entrySet2=value.entrySet();
    for (    Entry<Long,String> findItemSet2 : entrySet2) {
      Map<K,Object> row=new HashMap<K,Object>();
      String errorValueKey=findItemSet2.getValue();
      ErrorValue errorValue=errorValuesDaoImpl.find(errorValueKey);
      row.put((K)""String_Node_Str"",errorByIdDaoImpl.findCountByTimeRange(errorValue.getErrorId(),beginTime,endTime));
      row.put((K)""String_Node_Str"",errorValue.getErrorId());
      row.put((K)""String_Node_Str"",errorValue.getName());
      if (filters.get(ResourceEntity.CONSUMER.value()) != null) {
        row.put((K)""String_Node_Str"",errorValue.getConsumerName());
      }
      row.put((K)""String_Node_Str"",errorValue.isServerSide());
      row.put((K)""String_Node_Str"",findItemSet2.getKey());
      result.add(row);
    }
  }
  return result;
}"
18553,"@Override public MetricValue find(K key){
  SliceQuery<String,String,Object> query=HFactory.createSliceQuery(keySpace,StringSerializer.get(),StringSerializer.get(),ObjectSerializer.get());
  QueryResult<ColumnSlice<String,Object>> result=query.setColumnFamily(columnFamilyName).setKey((String)key).setRange(""String_Node_Str"",""String_Node_Str"",false,10).execute();
  try {
    if (result.get().getColumns().isEmpty()) {
      return null;
    }
  }
 catch (  Exception e) {
    return null;
  }
  try {
    MetricValue metricValue=new MetricValue<K>(key);
    Map<String,Object> columns=metricValue.getColumns();
    ColumnSlice<String,Object> queryResult=result.get();
    for (    HColumn<String,Object> column : queryResult.getColumns()) {
      Object val=column.getValue();
      columns.put(column.getName(),val);
    }
    return metricValue;
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public MetricValue find(K key){
  SliceQuery<String,String,Object> query=HFactory.createSliceQuery(keySpace,StringSerializer.get(),StringSerializer.get(),ObjectSerializer.get());
  QueryResult<ColumnSlice<String,Object>> result=query.setColumnFamily(columnFamilyName).setKey((String)key).setRange(""String_Node_Str"",""String_Node_Str"",false,10).execute();
  try {
    if (result.get().getColumns().isEmpty()) {
      return null;
    }
  }
 catch (  Exception e) {
    return null;
  }
  try {
    MetricValue metricValue=new MetricValue<K>(key);
    Map<String,Object> columns=metricValue.getColumns();
    ColumnSlice<String,Object> queryResult=result.get();
    for (    HColumn<String,Object> column : queryResult.getColumns()) {
      Object val=column.getValue();
      columns.put(column.getName(),val);
    }
    return metricValue;
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + key,e);
  }
}"
18554,"/** 
 * Instantiates a new metrics error dao impl.
 * @param clusterName the cluster name
 * @param host the host
 * @param s_keyspace the s_keyspace
 * @param columnFamilyName the column family name
 */
public MetricsErrorsByCategoryDAOImpl(final String clusterName,final String host,final String s_keyspace,final String columnFamilyName,final Class<K> kTypeClass,final MetricsErrorValuesDAO<String> errorValuesDaoImpl){
  super(clusterName,host,s_keyspace,columnFamilyName,kTypeClass,errorValuesDaoImpl);
}","/** 
 * Instantiates a new metrics error dao impl.
 * @param clusterName the cluster name
 * @param host the host
 * @param s_keyspace the s_keyspace
 * @param columnFamilyName the column family name
 */
public MetricsErrorsByCategoryDAOImpl(final String clusterName,final String host,final String s_keyspace,final String columnFamilyName,final Class<K> kTypeClass,final MetricsErrorValuesDAO<String> errorValuesDaoImpl,final MetricsErrorByIdDAO<Long> errorByIdDaoImpl){
  super(clusterName,host,s_keyspace,columnFamilyName,kTypeClass,errorValuesDaoImpl,errorByIdDaoImpl);
}"
18555,"/** 
 * Instantiates a new metrics errors by severity dao impl.
 * @param clusterName the cluster name
 * @param host the host
 * @param s_keyspace the s_keyspace
 * @param columnFamilyName the column family name
 * @param errorValuesDaoImpl the error values dao impl
 */
public MetricsErrorsBySeverityDAOImpl(final String clusterName,final String host,final String s_keyspace,final String columnFamilyName,final Class<K> kTypeClass,final MetricsErrorValuesDAO errorValuesDaoImpl){
  super(clusterName,host,s_keyspace,columnFamilyName,kTypeClass,errorValuesDaoImpl);
}","/** 
 * Instantiates a new metrics errors by severity dao impl.
 * @param clusterName the cluster name
 * @param host the host
 * @param s_keyspace the s_keyspace
 * @param columnFamilyName the column family name
 * @param errorValuesDaoImpl the error values dao impl
 */
public MetricsErrorsBySeverityDAOImpl(final String clusterName,final String host,final String s_keyspace,final String columnFamilyName,final Class<K> kTypeClass,final MetricsErrorValuesDAO errorValuesDaoImpl,MetricsErrorByIdDAO<Long> errorByIdDaoImpl){
  super(clusterName,host,s_keyspace,columnFamilyName,kTypeClass,errorValuesDaoImpl,errorByIdDaoImpl);
}"
18556,"@Override public GetErrorMetricsDataResponse getErrorMetricsData(GetErrorMetricsDataRequest getErrorMetricsDataRequest){
  GetErrorMetricsDataResponse response=null;
  initialize();
  try {
    response=new GetErrorMetricsDataResponse();
    List<ExtendedErrorViewData> result=s_provider.getExtendedErrorMetricsData(getErrorMetricsDataRequest.getErrorType(),getErrorMetricsDataRequest.getServiceName(),getErrorMetricsDataRequest.getOperationName(),getErrorMetricsDataRequest.getConsumerName(),getErrorMetricsDataRequest.getErrorId(),getErrorMetricsDataRequest.getErrorCategory(),getErrorMetricsDataRequest.getErrorSeverity(),getErrorMetricsDataRequest.getErrorName(),getErrorMetricsDataRequest.getMetricCriteria());
    updateErrorDiffValues(result);
    response.getReturnData().addAll(result);
  }
 catch (  Exception e) {
    response.setErrorMessage(new ErrorMessage());
    response.getErrorMessage().getError().add(ErrorDataFactory.createErrorData(ErrorConstants.SVC_SOAMETRICSQUERYSERVICE_INTERNAL_ERROR,ErrorConstants.ERRORDOMAIN));
  }
  return response;
}","@Override public GetErrorMetricsDataResponse getErrorMetricsData(GetErrorMetricsDataRequest getErrorMetricsDataRequest){
  GetErrorMetricsDataResponse response=null;
  initialize();
  try {
    response=new GetErrorMetricsDataResponse();
    List<ExtendedErrorViewData> result=s_provider.getExtendedErrorMetricsData(getErrorMetricsDataRequest.getErrorType(),getErrorMetricsDataRequest.getServiceName(),getErrorMetricsDataRequest.getOperationName(),getErrorMetricsDataRequest.getConsumerName(),getErrorMetricsDataRequest.getErrorId(),getErrorMetricsDataRequest.getErrorCategory(),getErrorMetricsDataRequest.getErrorSeverity(),getErrorMetricsDataRequest.getErrorName(),getErrorMetricsDataRequest.getMetricCriteria());
    updateErrorDiffValues(result);
    response.getReturnData().addAll(result);
  }
 catch (  Error err) {
    err.printStackTrace();
  }
catch (  Exception e) {
    response.setErrorMessage(new ErrorMessage());
    response.getErrorMessage().getError().add(ErrorDataFactory.createErrorData(ErrorConstants.SVC_SOAMETRICSQUERYSERVICE_INTERNAL_ERROR,ErrorConstants.ERRORDOMAIN));
  }
  return response;
}"
18557,"public List<Map<K,Object>> findErrorValuesByFilter(long beginTime,long endTime,boolean serverSide,int aggregationPeriod,Long errorId,String filter,Map<String,List<String>> filters){
  final List<K> errorKeys=(List<K>)KeyGeneratorUtil.generateErrorValuesKeys(serverSide,filters,filter);
  Map<K,Map<Long,String>> findItems=findItems(errorKeys,beginTime,endTime);
  List<Map<K,Object>> result=new ArrayList<Map<K,Object>>();
  Set<Entry<K,Map<Long,String>>> entrySet=findItems.entrySet();
  for (  Entry<K,Map<Long,String>> findItemSet : entrySet) {
    Map<Long,String> value=findItemSet.getValue();
    Set<Entry<Long,String>> entrySet2=value.entrySet();
    for (    Entry<Long,String> findItemSet2 : entrySet2) {
      Map<K,Object> row=new HashMap<K,Object>();
      row.put((K)""String_Node_Str"",findItemSet2.getKey());
      result.add(row);
    }
  }
  return result;
}","public List<Map<K,Object>> findErrorValuesByFilter(long beginTime,long endTime,boolean serverSide,int aggregationPeriod,Long errorId,String filter,Map<String,List<String>> filters){
  final List<String> errorKeys=KeyGeneratorUtil.generateErrorValuesKeys(serverSide,filters,filter);
  Map<K,Map<Long,String>> findItems=findItems((List<K>)errorKeys,beginTime,endTime);
  List<Map<K,Object>> result=new ArrayList<Map<K,Object>>();
  Set<Entry<K,Map<Long,String>>> entrySet=findItems.entrySet();
  for (  Entry<K,Map<Long,String>> findItemSet : entrySet) {
    Map<Long,String> value=findItemSet.getValue();
    Set<Entry<Long,String>> entrySet2=value.entrySet();
    for (    Entry<Long,String> findItemSet2 : entrySet2) {
      Map<K,Object> row=new HashMap<K,Object>();
      row.put((K)""String_Node_Str"",findItemSet2.getKey());
      result.add(row);
    }
  }
  return result;
}"
18558,"/** 
 * {@inheritDoc}
 */
@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  Map<Long,MetricGraphData> metricGraphDataByTime=new TreeMap<Long,MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  boolean totalizeResultsPerService=false;
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  }
  if (criteriaInfo.getOperationName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  }
  if (criteriaInfo.getConsumerName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  }
  Map<String,List<MetricValue<?>>> metricValuesMap;
  try {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      totalizeResultsPerService=true;
    }
    if (consumerNames != null && !consumerNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        metricValuesMap=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        for (        String consumerName : consumerNames) {
          List<MetricValue<?>> metricValues=metricValuesMap.get(consumerName);
          for (int i=0; i < duration / aggregationPeriod; ++i) {
            long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
            long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
            double value=0;
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=metricValue.getValueForMetric(encodedMetricName);
                break;
              }
            }
            MetricGraphData metricGraphData=new MetricGraphData();
            metricGraphData.setCount(value);
            metricGraphData.setTimeSlot(startTime);
            metricGraphData.setCriteria(null);
            if (totalizeResultsPerService) {
              MetricGraphData alreadyStoredMetricGraph=null;
              if (metricGraphDataByTime.containsKey(startTime)) {
                alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
                alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
              }
 else {
                result.add(metricGraphData);
                metricGraphDataByTime.put(startTime,metricGraphData);
              }
            }
 else {
              result.add(metricGraphData);
            }
          }
        }
      }
    }
 else {
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        metricValuesMap=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
        operationNames=filters.get(""String_Node_Str"");
        for (        String opName : operationNames) {
          List<MetricValue<?>> metricValues=metricValuesMap.get(opName);
          for (int i=0; i < duration / aggregationPeriod; ++i) {
            long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
            long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
            double value=0;
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=metricValue.getValueForMetric(encodedMetricName);
                break;
              }
            }
            MetricGraphData metricGraphData=new MetricGraphData();
            metricGraphData.setCount(value);
            metricGraphData.setTimeSlot(startTime);
            metricGraphData.setCriteria(null);
            if (totalizeResultsPerService) {
              MetricGraphData alreadyStoredMetricGraph=null;
              if (metricGraphDataByTime.containsKey(startTime)) {
                alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
                alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
              }
 else {
                result.add(metricGraphData);
                metricGraphDataByTime.put(startTime,metricGraphData);
              }
            }
 else {
              result.add(metricGraphData);
            }
          }
        }
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}","/** 
 * {@inheritDoc}
 */
@Override public List<MetricGraphData> getMetricValue(CriteriaInfo criteriaInfo,long beginTime,long duration,int aggregationPeriod,String autoDelay){
  List<MetricGraphData> result=new ArrayList<MetricGraphData>();
  Map<Long,MetricGraphData> metricGraphDataByTime=new TreeMap<Long,MetricGraphData>();
  String encodedMetricName=criteriaInfo.getMetricName();
  String metricName=decodeMetricName(encodedMetricName);
  long endTime=beginTime + TimeUnit.SECONDS.toMillis(duration);
  boolean serverSide=MonitoringSystem.COLLECTION_LOCATION_SERVER.equals(criteriaInfo.getRoleType());
  boolean totalizeResultsPerService=false;
  Map<String,List<String>> filters=new HashMap<String,List<String>>();
  if (criteriaInfo.getServiceName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getServiceName().trim()));
  }
  if (criteriaInfo.getOperationName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getOperationName().trim()));
  }
  if (criteriaInfo.getConsumerName() != null) {
    filters.put(""String_Node_Str"",Arrays.asList(criteriaInfo.getConsumerName().trim()));
  }
  Map<String,List<MetricValue<?>>> metricValuesMap;
  try {
    List<String> serviceNames=filters.get(""String_Node_Str"");
    List<String> operationNames=filters.get(""String_Node_Str"");
    List<String> consumerNames=filters.get(""String_Node_Str"");
    if (operationNames == null || operationNames.isEmpty()) {
      operationNames=metricsServiceOperationByIpDAO.findMetricOperationNames(serviceNames);
      operationNames=removeServiceNamePrefix(operationNames);
      filters.put(""String_Node_Str"",operationNames);
      totalizeResultsPerService=true;
    }
    if (consumerNames != null && !consumerNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        metricValuesMap=metricValuesDAO.findMetricValuesByConsumer(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,serviceName,operationNames,consumerNames);
        for (        String consumerName : consumerNames) {
          List<MetricValue<?>> metricValues=metricValuesMap.get(consumerName);
          for (int i=0; i < duration / aggregationPeriod; ++i) {
            long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
            long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
            double value=0;
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=metricValue.getValueForMetric(encodedMetricName);
              }
            }
            MetricGraphData metricGraphData=new MetricGraphData();
            metricGraphData.setCount(value);
            metricGraphData.setTimeSlot(startTime);
            metricGraphData.setCriteria(null);
            if (totalizeResultsPerService) {
              MetricGraphData alreadyStoredMetricGraph=null;
              if (metricGraphDataByTime.containsKey(startTime)) {
                alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
                alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
              }
 else {
                result.add(metricGraphData);
                metricGraphDataByTime.put(startTime,metricGraphData);
              }
            }
 else {
              result.add(metricGraphData);
            }
          }
        }
      }
    }
 else {
      for (      String serviceName : serviceNames) {
        List<String> ipAddressList=ipPerDayAndServiceNameDAO.findByDateAndServiceName(System.currentTimeMillis(),serviceName);
        metricValuesMap=metricValuesDAO.findMetricValuesByOperation(ipAddressList,metricName,beginTime,endTime,serverSide,aggregationPeriod,filters);
        operationNames=filters.get(""String_Node_Str"");
        for (        String opName : operationNames) {
          List<MetricValue<?>> metricValues=metricValuesMap.get(opName);
          for (int i=0; i < duration / aggregationPeriod; ++i) {
            long startTime=beginTime + TimeUnit.SECONDS.toMillis(i * aggregationPeriod);
            long stopTime=startTime + TimeUnit.SECONDS.toMillis(aggregationPeriod);
            double value=0;
            for (            MetricValue<?> metricValue : metricValues) {
              long time=metricValue.getTimeMiliseconds();
              if (startTime <= time && time < stopTime) {
                value+=metricValue.getValueForMetric(encodedMetricName);
                break;
              }
            }
            MetricGraphData metricGraphData=new MetricGraphData();
            metricGraphData.setCount(value);
            metricGraphData.setTimeSlot(startTime);
            metricGraphData.setCriteria(null);
            if (totalizeResultsPerService) {
              MetricGraphData alreadyStoredMetricGraph=null;
              if (metricGraphDataByTime.containsKey(startTime)) {
                alreadyStoredMetricGraph=metricGraphDataByTime.get(startTime);
                alreadyStoredMetricGraph.setCount(metricGraphData.getCount() + alreadyStoredMetricGraph.getCount());
              }
 else {
                result.add(metricGraphData);
                metricGraphDataByTime.put(startTime,metricGraphData);
              }
            }
 else {
              result.add(metricGraphData);
            }
          }
        }
      }
    }
  }
 catch (  ServiceException e) {
    e.printStackTrace();
  }
  return result;
}"
18559,"public void createTestData() throws ServiceException {
  MetricId metricId1=new MetricId(SystemMetricDefs.OP_TIME_TOTAL.getMetricName(),srvcAdminName,opName);
  MetricValue metricValue1=new AverageMetricValue(metricId1);
  MetricValueAggregatorTestImpl aggregator1=new MetricValueAggregatorTestImpl(metricValue1,MetricCategory.Timing,MonitoringLevel.NORMAL);
  MetricClassifier metricClassifier1=new MetricClassifier(consumerName,""String_Node_Str"",""String_Node_Str"");
  MetricClassifier metricClassifier2=new MetricClassifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier2,1L);
  List<MetricValueAggregator> aggregators=deepCopyAggregators(aggregator1);
  metricsStorageProvider.saveMetricSnapshot(sixMinuteAgo,aggregators);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier2,1L);
  aggregators=deepCopyAggregators(aggregator1);
  metricsStorageProvider.saveMetricSnapshot(threeMinutesAgo,aggregators);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier2,1L);
  aggregators=deepCopyAggregators(aggregator1);
  metricsStorageProvider.saveMetricSnapshot(twoMinutesAgo,aggregators);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier2,1L);
  aggregators=deepCopyAggregators(aggregator1);
  metricsStorageProvider.saveMetricSnapshot(oneMinuteAgo,aggregators);
}","public void createTestData() throws ServiceException {
  MetricId metricId1=new MetricId(SystemMetricDefs.OP_TIME_TOTAL.getMetricName(),srvcAdminName,opName);
  MetricValue metricValue1=new AverageMetricValue(metricId1);
  MetricId metricId2=new MetricId(SystemMetricDefs.OP_TIME_TOTAL.getMetricName(),srvcAdminName,""String_Node_Str"");
  MetricValue metricValue2=new AverageMetricValue(metricId2);
  MetricValueAggregatorTestImpl aggregator1=new MetricValueAggregatorTestImpl(metricValue1,MetricCategory.Timing,MonitoringLevel.NORMAL);
  MetricValueAggregatorTestImpl aggregator2=new MetricValueAggregatorTestImpl(metricValue2,MetricCategory.Timing,MonitoringLevel.NORMAL);
  MetricClassifier metricClassifier1=new MetricClassifier(consumerName,""String_Node_Str"",""String_Node_Str"");
  MetricClassifier metricClassifier2=new MetricClassifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  aggregator1.update(metricClassifier1,1L);
  aggregator2.update(metricClassifier1,1l);
  aggregator2.update(metricClassifier1,1l);
  aggregator1.update(metricClassifier2,1L);
  List<MetricValueAggregator> aggregators=deepCopyAggregators(aggregator1,aggregator2);
  metricsStorageProvider.saveMetricSnapshot(sixMinutesAgo,aggregators);
  aggregator1.update(metricClassifier1,1L);
  aggregator2.update(metricClassifier1,1l);
  aggregator1.update(metricClassifier2,1L);
  aggregators=deepCopyAggregators(aggregator1,aggregator2);
  metricsStorageProvider.saveMetricSnapshot(threeMinutesAgo,aggregators);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier2,1L);
  aggregators=deepCopyAggregators(aggregator1);
  metricsStorageProvider.saveMetricSnapshot(twoMinutesAgo,aggregators);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier1,1L);
  aggregator1.update(metricClassifier2,1L);
  aggregators=deepCopyAggregators(aggregator1);
  metricsStorageProvider.saveMetricSnapshot(oneMinuteAgo,aggregators);
}"
18560,"@Test public void testCallCountOneServiceNoOperationAnotherConsumer() throws ServiceException {
  long duration=60 * 6;
  int aggregationPeriod=20;
  int expectedSum=4;
  CriteriaInfo criteriaInfo=new CriteriaInfo();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setServiceName(srvcAdminName);
  criteriaInfo.setRoleType(""String_Node_Str"");
  criteriaInfo.setConsumerName(""String_Node_Str"");
  List<MetricGraphData> response=queryprovider.getMetricValue(criteriaInfo,sixMinuteAgo,duration,aggregationPeriod,""String_Node_Str"");
  assertNotNull(response);
  assertEquals(""String_Node_Str"",duration / aggregationPeriod,response.size());
  int sum=0;
  for (  MetricGraphData metricGraphData : response) {
    sum+=metricGraphData.getCount();
  }
  assertEquals(""String_Node_Str"" + expectedSum,expectedSum,sum);
}","@Test public void testCallCountOneServiceNoOperationAnotherConsumer() throws ServiceException {
  long duration=60 * 6;
  int aggregationPeriod=20;
  int expectedSum=4;
  CriteriaInfo criteriaInfo=new CriteriaInfo();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setServiceName(srvcAdminName);
  criteriaInfo.setRoleType(""String_Node_Str"");
  criteriaInfo.setConsumerName(""String_Node_Str"");
  List<MetricGraphData> response=queryprovider.getMetricValue(criteriaInfo,sixMinutesAgo,duration,aggregationPeriod,""String_Node_Str"");
  assertNotNull(response);
  assertEquals(""String_Node_Str"",duration / aggregationPeriod,response.size());
  int sum=0;
  for (  MetricGraphData metricGraphData : response) {
    sum+=metricGraphData.getCount();
  }
  assertEquals(""String_Node_Str"" + expectedSum,expectedSum,sum);
}"
18561,"@Override @Before public void setUp() throws Exception {
  super.setUp();
  now=System.currentTimeMillis();
  consumerName=""String_Node_Str"";
  oneMinuteAgo=now - TimeUnit.SECONDS.toMillis(60);
  opName=""String_Node_Str"";
  sixMinuteAgo=now - TimeUnit.SECONDS.toMillis(60 * 6);
  srvcAdminName=""String_Node_Str"";
  threeMinutesAgo=now - TimeUnit.SECONDS.toMillis(60 * 3);
  twoMinutesAgo=now - TimeUnit.SECONDS.toMillis(60 * 2);
  errorStorageProvider=new CassandraErrorLoggingHandler();
  metricsStorageProvider=new CassandraMetricsStorageProvider();
  InitContext ctx=new MockInitContext(options);
  errorStorageProvider.init(ctx);
  metricsStorageProvider.init(options,null,MonitoringSystem.COLLECTION_LOCATION_SERVER,20);
  queryprovider=new SOAMetricsQueryServiceCassandraProviderImpl();
  createTestData();
}","@Override @Before public void setUp() throws Exception {
  super.setUp();
  now=System.currentTimeMillis();
  consumerName=""String_Node_Str"";
  oneMinuteAgo=now - TimeUnit.SECONDS.toMillis(60);
  opName=""String_Node_Str"";
  sixMinutesAgo=now - TimeUnit.SECONDS.toMillis(60 * 6);
  srvcAdminName=""String_Node_Str"";
  threeMinutesAgo=now - TimeUnit.SECONDS.toMillis(60 * 3);
  twoMinutesAgo=now - TimeUnit.SECONDS.toMillis(60 * 2);
  errorStorageProvider=new CassandraErrorLoggingHandler();
  metricsStorageProvider=new CassandraMetricsStorageProvider();
  InitContext ctx=new MockInitContext(options);
  errorStorageProvider.init(ctx);
  metricsStorageProvider.init(options,null,MonitoringSystem.COLLECTION_LOCATION_SERVER,20);
  queryprovider=new SOAMetricsQueryServiceCassandraProviderImpl();
  createTestData();
}"
18562,"@Test public void testCallCountOneServiceNoOperationOneConsumer() throws ServiceException {
  long duration=60 * 7;
  int aggregationPeriod=20;
  int expectedSum=9;
  CriteriaInfo criteriaInfo=new CriteriaInfo();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setServiceName(srvcAdminName);
  criteriaInfo.setRoleType(""String_Node_Str"");
  criteriaInfo.setConsumerName(consumerName);
  List<MetricGraphData> response=queryprovider.getMetricValue(criteriaInfo,sixMinuteAgo,duration,aggregationPeriod,""String_Node_Str"");
  assertNotNull(response);
  assertEquals(""String_Node_Str"",duration / aggregationPeriod,response.size());
  int sum=0;
  for (  MetricGraphData metricGraphData : response) {
    sum+=metricGraphData.getCount();
  }
  assertEquals(""String_Node_Str"" + expectedSum,expectedSum,sum);
}","@Test public void testCallCountOneServiceNoOperationOneConsumer() throws ServiceException {
  long duration=60 * 6;
  int aggregationPeriod=20;
  int expectedSum=12;
  CriteriaInfo criteriaInfo=new CriteriaInfo();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setServiceName(srvcAdminName);
  criteriaInfo.setRoleType(""String_Node_Str"");
  criteriaInfo.setConsumerName(consumerName);
  List<MetricGraphData> response=queryprovider.getMetricValue(criteriaInfo,sixMinutesAgo,duration,aggregationPeriod,""String_Node_Str"");
  assertNotNull(response);
  assertEquals(""String_Node_Str"",duration / aggregationPeriod,response.size());
  int sum=0;
  for (  MetricGraphData metricGraphData : response) {
    sum+=metricGraphData.getCount();
  }
  assertEquals(""String_Node_Str"" + expectedSum,expectedSum,sum);
}"
18563,"@Test public void testCallCountOneServiceNoOperationNoConsumer() throws ServiceException {
  long duration=60 * 6;
  int aggregationPeriod=20;
  int expectedSum=13;
  CriteriaInfo criteriaInfo=new CriteriaInfo();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setServiceName(srvcAdminName);
  criteriaInfo.setRoleType(""String_Node_Str"");
  List<MetricGraphData> response=queryprovider.getMetricValue(criteriaInfo,sixMinuteAgo,duration,aggregationPeriod,""String_Node_Str"");
  assertNotNull(response);
  assertEquals(""String_Node_Str"",duration / aggregationPeriod,response.size());
  int sum=0;
  for (  MetricGraphData metricGraphData : response) {
    sum+=metricGraphData.getCount();
  }
  assertEquals(""String_Node_Str"" + expectedSum,expectedSum,sum);
}","@Test public void testCallCountOneServiceNoOperationNoConsumer() throws ServiceException {
  long duration=60 * 6;
  int aggregationPeriod=20;
  int expectedSum=16;
  CriteriaInfo criteriaInfo=new CriteriaInfo();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setServiceName(srvcAdminName);
  criteriaInfo.setRoleType(""String_Node_Str"");
  List<MetricGraphData> response=queryprovider.getMetricValue(criteriaInfo,sixMinutesAgo,duration,aggregationPeriod,""String_Node_Str"");
  assertNotNull(response);
  assertEquals(""String_Node_Str"",duration / aggregationPeriod,response.size());
  int sum=0;
  for (  MetricGraphData metricGraphData : response) {
    sum+=metricGraphData.getCount();
  }
  assertEquals(""String_Node_Str"" + expectedSum,expectedSum,sum);
}"
18564,"@Before public void setUp() throws Exception {
  super.setUp();
  metricsErrorByIdDAOImpl=new MetricsErrorByIdDAOImpl<Long>(TURMERIC_TEST_CLUSTER,HOST,KEY_SPACE,""String_Node_Str"",Long.class);
  queryprovider=new SOAMetricsQueryServiceCassandraProviderImpl();
  errorStorageProvider=new CassandraErrorLoggingHandler();
  metricsStorageProvider=new CassandraMetricsStorageProvider();
  InitContext ctx=new MockInitContext(options);
  errorStorageProvider.init(ctx);
  metricsStorageProvider.init(options,null,MonitoringSystem.COLLECTION_LOCATION_SERVER,20);
  createData();
}","@Override @Before public void setUp() throws Exception {
  super.setUp();
  metricsErrorByIdDAOImpl=new MetricsErrorByIdDAOImpl<Long>(TURMERIC_TEST_CLUSTER,HOST,KEY_SPACE,""String_Node_Str"",Long.class);
  errorStorageProvider=new CassandraErrorLoggingHandler();
  metricsStorageProvider=new CassandraMetricsStorageProvider();
  InitContext ctx=new MockInitContext(options);
  errorStorageProvider.init(ctx);
  metricsStorageProvider.init(options,null,MonitoringSystem.COLLECTION_LOCATION_SERVER,20);
  queryprovider=new SOAMetricsQueryServiceCassandraProviderImpl();
  createData();
}"
18565,"@After public void tearDown(){
  super.tearDown();
}","@Override @After public void tearDown(){
  super.tearDown();
}"
18566,"@Test public void testDateSelectionInFilter(){
  assertNotNull(consumerPresenter);
  ConsumerView view=(ConsumerView)consumerPresenter.getView();
  assertNotNull(view);
  Tree serviceTree=(Tree)view.getSelector();
  assertNotNull(serviceTree);
  assertNotNull(serviceTree.getItem(0));
  assertNotNull(serviceTree.getItem(0).getChild(0));
  TreeItem serviceToSelect=serviceTree.getItem(0).asTreeItem().getChild(0);
  String html=serviceToSelect.asTreeItem().getHTML();
  assertNotNull(html);
  Map<String,Set<String>> consumerData=service.getConsumerData();
  String firstServiceName=consumerData.keySet().iterator().next();
  assertTrue(html.contains(firstServiceName));
  selectServiceForTab(ServicePresenter.SERVICE_ID,firstServiceName);
  view.getFilter().setDate1(new Date());
  Browser.click((Widget)view.getFilter().getApplyButton());
  FlexTable table=view.getTable(ConsumerMetric.CallVolume);
  assertNotNull(table);
  Widget cellContent=table.getWidget(1,0);
  assertNotNull(cellContent);
  Iterator<String> operationIterator=consumerData.get(firstServiceName).iterator();
  NodeList<Node> childNodes=cellContent.getElement().getChildNodes();
  int childNodesLength=childNodes.getLength();
  for (int i=0; i < childNodesLength; i++) {
    assertEquals(operationIterator.next(),childNodes.getItem(i).getNodeValue());
  }
}","@Test public void testDateSelectionInFilter(){
  assertNotNull(consumerPresenter);
  ConsumerView view=(ConsumerView)consumerPresenter.getView();
  assertNotNull(view);
  Tree serviceTree=(Tree)view.getSelector();
  assertNotNull(serviceTree);
  assertNotNull(serviceTree.getItem(0));
  assertNotNull(serviceTree.getItem(0).getChild(0));
  TreeItem serviceToSelect=serviceTree.getItem(0).asTreeItem().getChild(0);
  String html=serviceToSelect.asTreeItem().getHTML();
  assertNotNull(html);
  Map<String,Set<String>> consumerData=service.getConsumerData();
  String firstServiceName=consumerData.keySet().iterator().next();
  assertTrue(html.contains(firstServiceName));
  selectServiceForTab(ConsumerPresenter.CONSUMER_ID,firstServiceName);
  view.getFilter().setDate1(new Date());
  Browser.click((Widget)view.getFilter().getApplyButton());
  FlexTable table=view.getTable(ConsumerMetric.CallVolume);
  assertNotNull(table);
  Widget cellContent=table.getWidget(1,0);
  assertNotNull(cellContent);
  Iterator<String> operationIterator=consumerData.get(firstServiceName).iterator();
  NodeList<Node> childNodes=cellContent.getElement().getChildNodes();
  int childNodesLength=childNodes.getLength();
  for (int i=0; i < childNodesLength; i++) {
    assertEquals(operationIterator.next(),childNodes.getItem(i).getNodeValue());
  }
}"
18567,"/** 
 * Fetch metric.
 * @param m the m
 * @param ec the ec
 * @param mc the mc
 */
protected void fetchMetric(final ErrorMetric m,final ErrorCriteria ec,final MetricCriteria mc){
  queryService.getErrorData(ec,mc,new AsyncCallback<ErrorMetricData>(){
    public void onFailure(    Throwable err){
      view.error(err.getLocalizedMessage());
    }
    public void onSuccess(    ErrorMetricData data){
      view.setErrorMetricData(m,data);
switch (m) {
case TopApplicationErrors:
case TopRequestErrors:
case TopSystemErrors:
case TopCriticals:
case TopErrors:
case TopWarnings:
{
          List<HasClickHandlers> handlers=view.getTableColumn(m,0);
          for (          HasClickHandlers h : handlers) {
            h.addClickHandler(new ClickHandler(){
              public void onClick(              ClickEvent event){
                Object o=event.getSource();
                if (o instanceof HasText) {
                  String errorId=((HasText)o).getText();
                  SelectionContext ctx=new SelectionContext();
                  ctx.selectAll(selectionContext);
                  ctx.unselect(ObjectType.ErrorName);
                  ctx.select(ObjectType.ErrorId,errorId);
                  view.reset();
                  fetchErrorDetail(ctx);
                  fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
                  insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
                }
              }
            }
);
          }
          handlers=view.getTableColumn(m,1);
          for (          HasClickHandlers h : handlers) {
            h.addClickHandler(new ClickHandler(){
              public void onClick(              ClickEvent event){
                Object o=event.getSource();
                if (o instanceof HasText) {
                  String errorName=((HasText)o).getText();
                  SelectionContext ctx=new SelectionContext();
                  ctx.selectAll(selectionContext);
                  ctx.unselect(ObjectType.ErrorId);
                  ctx.select(ObjectType.ErrorName,errorName);
                  view.reset();
                  fetchErrorDetail(ctx);
                  fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
                  insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
                }
              }
            }
);
          }
          break;
        }
case ConsumerError:
{
        List<HasClickHandlers> handlers=view.getTableColumn(m,0);
        for (        HasClickHandlers h : handlers) {
          h.addClickHandler(new ClickHandler(){
            public void onClick(            ClickEvent event){
              Object o=event.getSource();
              if (o instanceof HasText) {
                String consumer=((HasText)o).getText();
                SelectionContext ctx=new SelectionContext();
                ctx.selectAll(selectionContext);
                ctx.select(ObjectType.ConsumerName,consumer);
                insertHistory(ConsumerPresenter.CONSUMER_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,true);
              }
            }
          }
);
        }
        break;
      }
  }
}
}
);
}","/** 
 * Fetch metric.
 * @param m the m
 * @param ec the ec
 * @param mc the mc
 */
protected void fetchMetric(final ErrorMetric m,final ErrorCriteria ec,final MetricCriteria mc){
  queryService.getErrorData(ec,mc,new AsyncCallback<ErrorMetricData>(){
    public void onFailure(    Throwable err){
      view.error(err.getLocalizedMessage());
    }
    public void onSuccess(    ErrorMetricData data){
      view.setErrorMetricData(m,data);
      String downloadUrl=queryService.getErrorDataDownloadUrl(ec,mc);
      view.setDownloadUrl(m,downloadUrl);
switch (m) {
case TopApplicationErrors:
case TopRequestErrors:
case TopSystemErrors:
case TopCriticals:
case TopErrors:
case TopWarnings:
{
          List<HasClickHandlers> handlers=view.getTableColumn(m,0);
          for (          HasClickHandlers h : handlers) {
            h.addClickHandler(new ClickHandler(){
              public void onClick(              ClickEvent event){
                Object o=event.getSource();
                if (o instanceof HasText) {
                  String errorId=((HasText)o).getText();
                  SelectionContext ctx=new SelectionContext();
                  ctx.selectAll(selectionContext);
                  ctx.unselect(ObjectType.ErrorName);
                  ctx.select(ObjectType.ErrorId,errorId);
                  view.reset();
                  fetchErrorDetail(ctx);
                  fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
                  insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
                }
              }
            }
);
          }
          handlers=view.getTableColumn(m,1);
          for (          HasClickHandlers h : handlers) {
            h.addClickHandler(new ClickHandler(){
              public void onClick(              ClickEvent event){
                Object o=event.getSource();
                if (o instanceof HasText) {
                  String errorName=((HasText)o).getText();
                  SelectionContext ctx=new SelectionContext();
                  ctx.selectAll(selectionContext);
                  ctx.unselect(ObjectType.ErrorId);
                  ctx.select(ObjectType.ErrorName,errorName);
                  view.reset();
                  fetchErrorDetail(ctx);
                  fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
                  insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
                }
              }
            }
);
          }
          break;
        }
case ConsumerError:
{
        List<HasClickHandlers> handlers=view.getTableColumn(m,0);
        for (        HasClickHandlers h : handlers) {
          h.addClickHandler(new ClickHandler(){
            public void onClick(            ClickEvent event){
              Object o=event.getSource();
              if (o instanceof HasText) {
                String consumer=((HasText)o).getText();
                SelectionContext ctx=new SelectionContext();
                ctx.selectAll(selectionContext);
                ctx.select(ObjectType.ConsumerName,consumer);
                insertHistory(ConsumerPresenter.CONSUMER_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,true);
              }
            }
          }
);
        }
        break;
      }
  }
}
}
);
}"
18568,"public void onSuccess(ErrorMetricData data){
  view.setErrorMetricData(m,data);
switch (m) {
case TopApplicationErrors:
case TopRequestErrors:
case TopSystemErrors:
case TopCriticals:
case TopErrors:
case TopWarnings:
{
      List<HasClickHandlers> handlers=view.getTableColumn(m,0);
      for (      HasClickHandlers h : handlers) {
        h.addClickHandler(new ClickHandler(){
          public void onClick(          ClickEvent event){
            Object o=event.getSource();
            if (o instanceof HasText) {
              String errorId=((HasText)o).getText();
              SelectionContext ctx=new SelectionContext();
              ctx.selectAll(selectionContext);
              ctx.unselect(ObjectType.ErrorName);
              ctx.select(ObjectType.ErrorId,errorId);
              view.reset();
              fetchErrorDetail(ctx);
              fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
              insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
            }
          }
        }
);
      }
      handlers=view.getTableColumn(m,1);
      for (      HasClickHandlers h : handlers) {
        h.addClickHandler(new ClickHandler(){
          public void onClick(          ClickEvent event){
            Object o=event.getSource();
            if (o instanceof HasText) {
              String errorName=((HasText)o).getText();
              SelectionContext ctx=new SelectionContext();
              ctx.selectAll(selectionContext);
              ctx.unselect(ObjectType.ErrorId);
              ctx.select(ObjectType.ErrorName,errorName);
              view.reset();
              fetchErrorDetail(ctx);
              fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
              insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
            }
          }
        }
);
      }
      break;
    }
case ConsumerError:
{
    List<HasClickHandlers> handlers=view.getTableColumn(m,0);
    for (    HasClickHandlers h : handlers) {
      h.addClickHandler(new ClickHandler(){
        public void onClick(        ClickEvent event){
          Object o=event.getSource();
          if (o instanceof HasText) {
            String consumer=((HasText)o).getText();
            SelectionContext ctx=new SelectionContext();
            ctx.selectAll(selectionContext);
            ctx.select(ObjectType.ConsumerName,consumer);
            insertHistory(ConsumerPresenter.CONSUMER_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,true);
          }
        }
      }
);
    }
    break;
  }
}
}","public void onSuccess(ErrorMetricData data){
  view.setErrorMetricData(m,data);
  String downloadUrl=queryService.getErrorDataDownloadUrl(ec,mc);
  view.setDownloadUrl(m,downloadUrl);
switch (m) {
case TopApplicationErrors:
case TopRequestErrors:
case TopSystemErrors:
case TopCriticals:
case TopErrors:
case TopWarnings:
{
      List<HasClickHandlers> handlers=view.getTableColumn(m,0);
      for (      HasClickHandlers h : handlers) {
        h.addClickHandler(new ClickHandler(){
          public void onClick(          ClickEvent event){
            Object o=event.getSource();
            if (o instanceof HasText) {
              String errorId=((HasText)o).getText();
              SelectionContext ctx=new SelectionContext();
              ctx.selectAll(selectionContext);
              ctx.unselect(ObjectType.ErrorName);
              ctx.select(ObjectType.ErrorId,errorId);
              view.reset();
              fetchErrorDetail(ctx);
              fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
              insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
            }
          }
        }
);
      }
      handlers=view.getTableColumn(m,1);
      for (      HasClickHandlers h : handlers) {
        h.addClickHandler(new ClickHandler(){
          public void onClick(          ClickEvent event){
            Object o=event.getSource();
            if (o instanceof HasText) {
              String errorName=((HasText)o).getText();
              SelectionContext ctx=new SelectionContext();
              ctx.selectAll(selectionContext);
              ctx.unselect(ObjectType.ErrorId);
              ctx.select(ObjectType.ErrorName,errorName);
              view.reset();
              fetchErrorDetail(ctx);
              fetchMetrics(Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError}),ctx,selectedDate1,selectedDate2,selectedDurationHrs);
              insertHistory(ERROR_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,false);
            }
          }
        }
);
      }
      break;
    }
case ConsumerError:
{
    List<HasClickHandlers> handlers=view.getTableColumn(m,0);
    for (    HasClickHandlers h : handlers) {
      h.addClickHandler(new ClickHandler(){
        public void onClick(        ClickEvent event){
          Object o=event.getSource();
          if (o instanceof HasText) {
            String consumer=((HasText)o).getText();
            SelectionContext ctx=new SelectionContext();
            ctx.selectAll(selectionContext);
            ctx.select(ObjectType.ConsumerName,consumer);
            insertHistory(ConsumerPresenter.CONSUMER_ID,ctx,selectedDate1,selectedDate2,selectedDurationHrs,true);
          }
        }
      }
);
    }
    break;
  }
}
}"
18569,"public void onValueChange(ValueChangeEvent<Date> event){
  Date date=event.getValue();
  int[] hrs=Util.getAvailableHours(date);
  ConsumerPresenter.this.view.getFilter().setHours2(hrs);
}","public void onValueChange(ValueChangeEvent<Date> event){
  Date date=event.getValue();
  int[] hrs=Util.getAvailableHours(date);
  ConsumerPresenter.this.view.getFilter().setHours1(hrs);
}"
18570,"protected void getConsumerServiceErrorTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  ConsumerTabCallbackQueue queue=new ConsumerErrorCountCallbackQueue();
  queue.setView(ConsumerPresenter.this.view);
  final Iterator<String> consuemrIterator=consumerNames.iterator();
  String consumerName=null;
  while (consuemrIterator.hasNext()) {
    consumerName=consuemrIterator.next();
    GWT.log(""String_Node_Str"" + consumerName);
    ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
    cllbck.setId(consumerName);
    queue.add(cllbck);
    CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
    criteriaInfo.setMetricName(""String_Node_Str"");
    criteriaInfo.setConsumerName(consumerName);
    criteriaInfo.setServiceName(serviceName);
    if (operationName != null) {
      criteriaInfo.setOperationName(operationName);
    }
    criteriaInfo.setRoleType(""String_Node_Str"");
    MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,3600l * durationHrs,3600,""String_Node_Str"");
    MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,3600l * durationHrs,3600,""String_Node_Str"");
    queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
  }
}","protected void getConsumerServiceErrorTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  ConsumerTabCallbackQueue queue=new ConsumerErrorCountCallbackQueue(serviceName,operationName,durationHrs,ConsumerPresenter.this.view);
  final Iterator<String> consuemrIterator=consumerNames.iterator();
  String consumerName=null;
  while (consuemrIterator.hasNext()) {
    consumerName=consuemrIterator.next();
    GWT.log(""String_Node_Str"" + consumerName);
    ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
    cllbck.setId(consumerName);
    queue.add(cllbck);
    CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
    criteriaInfo.setMetricName(""String_Node_Str"");
    criteriaInfo.setConsumerName(consumerName);
    criteriaInfo.setServiceName(serviceName);
    if (operationName != null) {
      criteriaInfo.setOperationName(operationName);
    }
    criteriaInfo.setRoleType(""String_Node_Str"");
    MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,3600l * durationHrs,3600,""String_Node_Str"");
    MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,3600l * durationHrs,3600,""String_Node_Str"");
    queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
  }
}"
18571,"protected void getConsumerServicePerformanceTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  ConsumerTabCallbackQueue queue=new ConsumerResponseTimeCallbackQueue();
  queue.setView(ConsumerPresenter.this.view);
  final Iterator<String> consuemrIterator=consumerNames.iterator();
  String consumerName=null;
  while (consuemrIterator.hasNext()) {
    consumerName=consuemrIterator.next();
    GWT.log(""String_Node_Str"" + consumerName);
    ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
    cllbck.setId(consumerName);
    queue.add(cllbck);
    CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
    criteriaInfo.setMetricName(""String_Node_Str"");
    criteriaInfo.setConsumerName(consumerName);
    criteriaInfo.setServiceName(serviceName);
    if (operationName != null) {
      criteriaInfo.setOperationName(operationName);
    }
    criteriaInfo.setRoleType(""String_Node_Str"");
    MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,3600l * durationHrs,3600,""String_Node_Str"");
    MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,3600l * durationHrs,3600,""String_Node_Str"");
    queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
  }
}","protected void getConsumerServicePerformanceTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  ConsumerTabCallbackQueue queue=new ConsumerResponseTimeCallbackQueue(serviceName,operationName,durationHrs,ConsumerPresenter.this.view);
  final Iterator<String> consuemrIterator=consumerNames.iterator();
  String consumerName=null;
  while (consuemrIterator.hasNext()) {
    consumerName=consuemrIterator.next();
    GWT.log(""String_Node_Str"" + consumerName);
    ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
    cllbck.setId(consumerName);
    queue.add(cllbck);
    CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
    criteriaInfo.setMetricName(""String_Node_Str"");
    criteriaInfo.setConsumerName(consumerName);
    criteriaInfo.setServiceName(serviceName);
    if (operationName != null) {
      criteriaInfo.setOperationName(operationName);
    }
    criteriaInfo.setRoleType(""String_Node_Str"");
    MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,3600l * durationHrs,3600,""String_Node_Str"");
    MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,3600l * durationHrs,3600,""String_Node_Str"");
    queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
  }
}"
18572,"public void onSelection(SelectionEvent<TreeItem> event){
  TreeItem selection=event.getSelectedItem();
  selectionContext.unselect(ObjectType.ServiceName);
  selectionContext.unselect(ObjectType.OperationName);
  if (selection.getParentItem() != null) {
    if (selection.getChildCount() == 0) {
      selectionContext.select(ObjectType.OperationName,selection.getText());
      selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
    }
 else {
      selectionContext.select(ObjectType.ServiceName,selection.getText());
    }
  }
  view.setSelection(selectionContext.getSelections());
  eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
  selectedDate1=ConsumerPresenter.this.view.getFilter().getDate1().getValue().getTime();
  selectedDate2=ConsumerPresenter.this.view.getFilter().getDate2().getValue().getTime();
  int hour1=ConsumerPresenter.this.view.getFilter().getHour1();
  int hour2=ConsumerPresenter.this.view.getFilter().getHour2();
  selectedDate1+=(Util.HRS_1_MS * hour1);
  selectedDate2+=(Util.HRS_1_MS * hour2);
  selectedDuration=ConsumerPresenter.this.view.getFilter().getDuration();
  selectedMetrics=Util.convertToEnumFromCamelCase(ConsumerPresenter.this.view.getFilter().getSelectedMetricNames(),ConsumerMetric.class);
  view.reset();
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
  insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDuration,selectedMetrics,false);
}","public void onSelection(SelectionEvent<TreeItem> event){
  TreeItem selection=event.getSelectedItem();
  selectionContext.unselect(ObjectType.ServiceName);
  selectionContext.unselect(ObjectType.OperationName);
  if (selection.getParentItem() != null) {
    if (selection.getChildCount() == 0) {
      selectionContext.select(ObjectType.OperationName,selection.getText());
      selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
    }
 else {
      selectionContext.select(ObjectType.ServiceName,selection.getText());
    }
  }
  view.setSelection(selectionContext.getSelections());
  eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
  selectedDate1=ConsumerPresenter.this.view.getFilter().getDate1().getValue().getTime();
  selectedDate2=ConsumerPresenter.this.view.getFilter().getDate2().getValue().getTime();
  int hour1=ConsumerPresenter.this.view.getFilter().getHour1();
  int hour2=ConsumerPresenter.this.view.getFilter().getHour1();
  selectedDate1+=(Util.HRS_1_MS * hour1);
  selectedDate2+=(Util.HRS_1_MS * hour2);
  selectedDuration=ConsumerPresenter.this.view.getFilter().getDuration();
  selectedMetrics=Util.convertToEnumFromCamelCase(ConsumerPresenter.this.view.getFilter().getSelectedMetricNames(),ConsumerMetric.class);
  view.reset();
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
  insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDuration,selectedMetrics,false);
}"
18573,"/** 
 * Bind.
 */
public void bind(){
  this.eventBus.addHandler(GetServicesEvent.TYPE,new GetServicesEventHandler(){
    public void onData(    GetServicesEvent event){
      if (ConsumerPresenter.this.servicesList == null) {
        ConsumerPresenter.this.servicesList=event.getData();
        ConsumerPresenter.this.view.setServicesMap(event.getData());
      }
    }
  }
);
  this.eventBus.addHandler(ObjectSelectionEvent.TYPE,new ObjectSelectionEventHandler(){
    public void onSelection(    ObjectSelectionEvent event){
      selectionContext=new SelectionContext();
      if (event.getSelection(ObjectType.ServiceName) != null)       selectionContext.select(ObjectType.ServiceName,event.getSelection(ObjectType.ServiceName));
      if (event.getSelection(ObjectType.OperationName) != null)       selectionContext.select(ObjectType.OperationName,event.getSelection(ObjectType.OperationName));
    }
  }
);
  this.eventBus.addHandler(DateFilterSelectionEvent.TYPE,new DateFilterSelectionHandler(){
    public void onSelection(    DateFilterSelectionEvent event){
      selectedDate1=event.getDate1();
      selectedDate2=event.getDate2();
      selectedDuration=event.getDuration();
      view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
      view.getFilter().setHour1(new Date(selectedDate1).getHours());
      view.getFilter().setDate1(new Date(selectedDate1));
      view.getFilter().setHours2(Util.getAvailableHours(selectedDate2));
      view.getFilter().setHour2(new Date(selectedDate2).getHours());
      view.getFilter().setDate2(new Date(selectedDate2));
      view.getFilter().setDuration(selectedDuration);
    }
  }
);
  this.view.getFilter().getDate1().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      ConsumerPresenter.this.view.getFilter().setHours1(hrs);
    }
  }
);
  this.view.getFilter().getDate2().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      ConsumerPresenter.this.view.getFilter().setHours2(hrs);
    }
  }
);
  this.view.getFilter().getApplyButton().addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      long oldDate1=selectedDate1;
      long oldDate2=selectedDate2;
      selectedDate1=ConsumerPresenter.this.view.getFilter().getDate1().getValue().getTime();
      selectedDate2=ConsumerPresenter.this.view.getFilter().getDate2().getValue().getTime();
      int hour1=ConsumerPresenter.this.view.getFilter().getHour1();
      int hour2=ConsumerPresenter.this.view.getFilter().getHour2();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      int oldDuration=selectedDuration;
      selectedDuration=ConsumerPresenter.this.view.getFilter().getDuration();
      view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDuration));
      if ((oldDate1 != selectedDate1) || (oldDate2 != selectedDate2) || (oldDuration != selectedDuration)) {
        eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDuration));
      }
      selectedMetrics=Util.convertToEnumFromCamelCase(ConsumerPresenter.this.view.getFilter().getSelectedMetricNames(),ConsumerMetric.class);
      ConsumerPresenter.this.view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDuration,selectedMetrics,false);
    }
  }
);
  this.view.getSelector().addSelectionHandler(new SelectionHandler<TreeItem>(){
    public void onSelection(    SelectionEvent<TreeItem> event){
      TreeItem selection=event.getSelectedItem();
      selectionContext.unselect(ObjectType.ServiceName);
      selectionContext.unselect(ObjectType.OperationName);
      if (selection.getParentItem() != null) {
        if (selection.getChildCount() == 0) {
          selectionContext.select(ObjectType.OperationName,selection.getText());
          selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
        }
 else {
          selectionContext.select(ObjectType.ServiceName,selection.getText());
        }
      }
      view.setSelection(selectionContext.getSelections());
      eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
      selectedDate1=ConsumerPresenter.this.view.getFilter().getDate1().getValue().getTime();
      selectedDate2=ConsumerPresenter.this.view.getFilter().getDate2().getValue().getTime();
      int hour1=ConsumerPresenter.this.view.getFilter().getHour1();
      int hour2=ConsumerPresenter.this.view.getFilter().getHour2();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      selectedDuration=ConsumerPresenter.this.view.getFilter().getDuration();
      selectedMetrics=Util.convertToEnumFromCamelCase(ConsumerPresenter.this.view.getFilter().getSelectedMetricNames(),ConsumerMetric.class);
      view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDuration,selectedMetrics,false);
    }
  }
);
}","/** 
 * Bind.
 */
public void bind(){
  this.eventBus.addHandler(GetServicesEvent.TYPE,new GetServicesEventHandler(){
    public void onData(    GetServicesEvent event){
      if (ConsumerPresenter.this.servicesList == null) {
        ConsumerPresenter.this.servicesList=event.getData();
        ConsumerPresenter.this.view.setServicesMap(event.getData());
      }
    }
  }
);
  this.eventBus.addHandler(ObjectSelectionEvent.TYPE,new ObjectSelectionEventHandler(){
    public void onSelection(    ObjectSelectionEvent event){
      selectionContext=new SelectionContext();
      if (event.getSelection(ObjectType.ServiceName) != null)       selectionContext.select(ObjectType.ServiceName,event.getSelection(ObjectType.ServiceName));
      if (event.getSelection(ObjectType.OperationName) != null)       selectionContext.select(ObjectType.OperationName,event.getSelection(ObjectType.OperationName));
    }
  }
);
  this.eventBus.addHandler(DateFilterSelectionEvent.TYPE,new DateFilterSelectionHandler(){
    public void onSelection(    DateFilterSelectionEvent event){
      selectedDate1=event.getDate1();
      selectedDate2=event.getDate2();
      selectedDuration=event.getDuration();
      view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
      view.getFilter().setHour1(new Date(selectedDate1).getHours());
      view.getFilter().setDate1(new Date(selectedDate1));
      view.getFilter().setDate2(new Date(selectedDate2));
      view.getFilter().setDuration(selectedDuration);
    }
  }
);
  this.view.getFilter().getDate1().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      ConsumerPresenter.this.view.getFilter().setHours1(hrs);
    }
  }
);
  this.view.getFilter().getApplyButton().addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      long oldDate1=selectedDate1;
      long oldDate2=selectedDate2;
      selectedDate1=ConsumerPresenter.this.view.getFilter().getDate1().getValue().getTime();
      selectedDate2=ConsumerPresenter.this.view.getFilter().getDate2().getValue().getTime();
      int hour1=ConsumerPresenter.this.view.getFilter().getHour1();
      int hour2=ConsumerPresenter.this.view.getFilter().getHour1();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      int oldDuration=selectedDuration;
      selectedDuration=ConsumerPresenter.this.view.getFilter().getDuration();
      view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDuration));
      if ((oldDate1 != selectedDate1) || (oldDate2 != selectedDate2) || (oldDuration != selectedDuration)) {
        eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDuration));
      }
      selectedMetrics=Util.convertToEnumFromCamelCase(ConsumerPresenter.this.view.getFilter().getSelectedMetricNames(),ConsumerMetric.class);
      ConsumerPresenter.this.view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDuration,selectedMetrics,false);
    }
  }
);
  this.view.getSelector().addSelectionHandler(new SelectionHandler<TreeItem>(){
    public void onSelection(    SelectionEvent<TreeItem> event){
      TreeItem selection=event.getSelectedItem();
      selectionContext.unselect(ObjectType.ServiceName);
      selectionContext.unselect(ObjectType.OperationName);
      if (selection.getParentItem() != null) {
        if (selection.getChildCount() == 0) {
          selectionContext.select(ObjectType.OperationName,selection.getText());
          selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
        }
 else {
          selectionContext.select(ObjectType.ServiceName,selection.getText());
        }
      }
      view.setSelection(selectionContext.getSelections());
      eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
      selectedDate1=ConsumerPresenter.this.view.getFilter().getDate1().getValue().getTime();
      selectedDate2=ConsumerPresenter.this.view.getFilter().getDate2().getValue().getTime();
      int hour1=ConsumerPresenter.this.view.getFilter().getHour1();
      int hour2=ConsumerPresenter.this.view.getFilter().getHour1();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      selectedDuration=ConsumerPresenter.this.view.getFilter().getDuration();
      selectedMetrics=Util.convertToEnumFromCamelCase(ConsumerPresenter.this.view.getFilter().getSelectedMetricNames(),ConsumerMetric.class);
      view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDuration,selectedMetrics,false);
    }
  }
);
}"
18574,"/** 
 * Gets the consumer service trends.
 * @param serviceName the service name
 * @param date1 the date1
 * @param date2 the date2
 * @param list
 * @param returnData the return data
 * @param initialIndex the initial index
 * @return the consumer service trends
 */
protected void getConsumerServiceTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  ConsumerTabCallbackQueue queue=new ConsumerCallCountTrendCallbackQueue(serviceName,operationName,durationHrs,ConsumerPresenter.this.view);
  final Iterator<String> consuemrIterator=consumerNames.iterator();
  String consumerName=null;
  while (consuemrIterator.hasNext()) {
    consumerName=consuemrIterator.next();
    GWT.log(""String_Node_Str"" + consumerName);
    CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
    criteriaInfo.setMetricName(""String_Node_Str"");
    criteriaInfo.setConsumerName(consumerName);
    criteriaInfo.setServiceName(serviceName);
    if (operationName != null) {
      criteriaInfo.setOperationName(operationName);
    }
    criteriaInfo.setRoleType(""String_Node_Str"");
    ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
    cllbck.setId(consumerName);
    queue.add(cllbck);
    MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,3600l * durationHrs,3600,""String_Node_Str"");
    MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,3600l * durationHrs,3600,""String_Node_Str"");
    queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
  }
}","/** 
 * Gets the consumer service trends.
 * @param serviceName the service name
 * @param date1 the date1
 * @param date2 the date2
 * @param list
 * @param returnData the return data
 * @param initialIndex the initial index
 * @return the consumer service trends
 */
protected void getConsumerServiceTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  if (consumerNames != null && consumerNames.size() > 0) {
    ConsumerTabCallbackQueue queue=new ConsumerCallCountTrendCallbackQueue(serviceName,operationName,durationHrs,ConsumerPresenter.this.view);
    final Iterator<String> consuemrIterator=consumerNames.iterator();
    String consumerName=null;
    while (consuemrIterator.hasNext()) {
      consumerName=consuemrIterator.next();
      GWT.log(""String_Node_Str"" + consumerName);
      CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
      criteriaInfo.setMetricName(""String_Node_Str"");
      criteriaInfo.setConsumerName(consumerName);
      criteriaInfo.setServiceName(serviceName);
      if (operationName != null) {
        criteriaInfo.setOperationName(operationName);
      }
      criteriaInfo.setRoleType(""String_Node_Str"");
      ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
      cllbck.setId(consumerName);
      queue.add(cllbck);
      MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,3600l * durationHrs,3600,""String_Node_Str"");
      MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,3600l * durationHrs,3600,""String_Node_Str"");
      queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
    }
  }
 else {
    ConsumerPresenter.this.view.claerConsumerServiceCallTrendGraph();
  }
}"
18575,"public void go(HasWidgets container,HistoryToken token){
  selectionContext=SelectionContext.fromHistoryToken(token);
  view.setSelection(selectionContext.getSelections());
  if (servicesList == null)   fetchServices();
  FilterContext filter=FilterContext.fromHistoryToken(token);
  Date now=new Date();
  long fullTimeLastHour=Util.getLastHour(now);
  long sameTimeYesterday=Util.get24HrsPrevious(fullTimeLastHour);
  selectedDate1=(filter.getDate1() == 0 ? new Date(sameTimeYesterday).getTime() : filter.getDate1());
  selectedDate2=(filter.getDate2() == 0 ? new Date(fullTimeLastHour).getTime() : filter.getDate2());
  view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
  view.getFilter().setHour1(new Date(selectedDate1).getHours());
  view.getFilter().setDate1(new Date(selectedDate1));
  view.getFilter().setHours2(Util.getAvailableHours(selectedDate2));
  view.getFilter().setHour2(new Date(selectedDate2).getHours());
  view.getFilter().setDate2(new Date(selectedDate2));
  String tmp=HistoryToken.getValue(token,HistoryToken.SELECTED_DURATION_TOKEN);
  selectedDuration=(filter.getDurationHrs() == 0 ? MetricsQueryService.DEFAULT_DURATION_HRS : filter.getDurationHrs());
  int[] intervals=new int[24];
  for (int i=0; i < 24; i++)   intervals[i]=i + 1;
  view.getFilter().setDurations(intervals);
  view.getFilter().setDuration(selectedDuration);
  view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDuration));
  if (selectionContext.getSelection(ObjectType.ConsumerName) == null) {
    view.getFilter().setMetricNames(Util.convertFromEnumToCamelCase(ANY_CONSUMER_METRICS));
    if (filter.getMetricNames() == null) {
      selectedMetrics=ANY_CONSUMER_METRICS;
    }
 else {
      selectedMetrics=Util.convertToEnumFromCamelCase(filter.getMetricNames(),ConsumerMetric.class);
      if (selectedMetrics == null || selectedMetrics.isEmpty())       selectedMetrics=ANY_CONSUMER_METRICS;
    }
  }
 else {
    view.getFilter().setMetricNames(Util.convertFromEnumToCamelCase(ONE_CONSUMER_METRICS));
    if (filter.getMetricNames() == null)     selectedMetrics=ONE_CONSUMER_METRICS;
 else     selectedMetrics=Util.convertToEnumFromCamelCase(filter.getMetricNames(),ConsumerMetric.class);
  }
  view.getFilter().setSelectedMetricNames(Util.convertFromEnumToCamelCase(selectedMetrics));
  view.reset();
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
  ((Dashboard)container).activate(this.view);
}","public void go(HasWidgets container,HistoryToken token){
  selectionContext=SelectionContext.fromHistoryToken(token);
  view.setSelection(selectionContext.getSelections());
  if (servicesList == null)   fetchServices();
  FilterContext filter=FilterContext.fromHistoryToken(token);
  Date now=new Date();
  long fullTimeLastHour=Util.getLastHour(now);
  long sameTimeYesterday=Util.get24HrsPrevious(fullTimeLastHour);
  selectedDate1=(filter.getDate1() == 0 ? new Date(sameTimeYesterday).getTime() : filter.getDate1());
  selectedDate2=(filter.getDate2() == 0 ? new Date(fullTimeLastHour).getTime() : filter.getDate2());
  view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
  view.getFilter().setHour1(new Date(selectedDate1).getHours());
  view.getFilter().setDate1(new Date(selectedDate1));
  view.getFilter().setDate2(new Date(selectedDate2));
  String tmp=HistoryToken.getValue(token,HistoryToken.SELECTED_DURATION_TOKEN);
  selectedDuration=(filter.getDurationHrs() == 0 ? MetricsQueryService.DEFAULT_DURATION_HRS : filter.getDurationHrs());
  int[] intervals=new int[24];
  for (int i=0; i < 24; i++)   intervals[i]=i + 1;
  view.getFilter().setDurations(intervals);
  view.getFilter().setDuration(selectedDuration);
  view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDuration));
  if (selectionContext.getSelection(ObjectType.ConsumerName) == null) {
    view.getFilter().setMetricNames(Util.convertFromEnumToCamelCase(ANY_CONSUMER_METRICS));
    if (filter.getMetricNames() == null) {
      selectedMetrics=ANY_CONSUMER_METRICS;
    }
 else {
      selectedMetrics=Util.convertToEnumFromCamelCase(filter.getMetricNames(),ConsumerMetric.class);
      if (selectedMetrics == null || selectedMetrics.isEmpty())       selectedMetrics=ANY_CONSUMER_METRICS;
    }
  }
 else {
    view.getFilter().setMetricNames(Util.convertFromEnumToCamelCase(ONE_CONSUMER_METRICS));
    if (filter.getMetricNames() == null)     selectedMetrics=ONE_CONSUMER_METRICS;
 else     selectedMetrics=Util.convertToEnumFromCamelCase(filter.getMetricNames(),ConsumerMetric.class);
  }
  view.getFilter().setSelectedMetricNames(Util.convertFromEnumToCamelCase(selectedMetrics));
  view.reset();
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDuration);
  ((Dashboard)container).activate(this.view);
}"
18576,"public void onValueChange(ValueChangeEvent<Date> event){
  Date date=event.getValue();
  int[] hrs=Util.getAvailableHours(date);
  view.getFilter().setHours2(hrs);
}","public void onValueChange(ValueChangeEvent<Date> event){
  Date date=event.getValue();
  int[] hrs=Util.getAvailableHours(date);
}"
18577,"public void onSelection(SelectionEvent<TreeItem> event){
  TreeItem selection=event.getSelectedItem();
  selectionContext.unselect(ObjectType.ServiceName);
  selectionContext.unselect(ObjectType.OperationName);
  selectionContext.unselect(ObjectType.ErrorId);
  selectionContext.unselect(ObjectType.ErrorName);
  if (selection.getParentItem() != null) {
    selectionContext=new SelectionContext();
    if (selection.getChildCount() == 0) {
      selectionContext.select(ObjectType.OperationName,selection.getText());
      selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
    }
 else {
      selectionContext.select(ObjectType.ServiceName,selection.getText());
    }
  }
  view.setSelection(selectionContext.getSelections());
  eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
  selectedDate1=view.getFilter().getDate1().getValue().getTime();
  selectedDate2=view.getFilter().getDate2().getValue().getTime();
  int hour1=view.getFilter().getHour1();
  int hour2=view.getFilter().getHour2();
  selectedDate1+=(Util.HRS_1_MS * hour1);
  selectedDate2+=(Util.HRS_1_MS * hour2);
  selectedDurationHrs=view.getFilter().getDuration();
  List<String> metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedCategoryViewNames();
  if (metrics.isEmpty())   metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedSeverityViewNames();
  selectedMetrics=Util.convertToEnumFromCamelCase(metrics,ErrorMetric.class);
  view.reset();
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
}","public void onSelection(SelectionEvent<TreeItem> event){
  TreeItem selection=event.getSelectedItem();
  selectionContext.unselect(ObjectType.ServiceName);
  selectionContext.unselect(ObjectType.OperationName);
  selectionContext.unselect(ObjectType.ErrorId);
  selectionContext.unselect(ObjectType.ErrorName);
  if (selection.getParentItem() != null) {
    selectionContext=new SelectionContext();
    if (selection.getChildCount() == 0) {
      selectionContext.select(ObjectType.OperationName,selection.getText());
      selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
    }
 else {
      selectionContext.select(ObjectType.ServiceName,selection.getText());
    }
  }
  view.setSelection(selectionContext.getSelections());
  eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
  selectedDate1=view.getFilter().getDate1().getValue().getTime();
  selectedDate2=view.getFilter().getDate2().getValue().getTime();
  int hour1=view.getFilter().getHour1();
  int hour2=view.getFilter().getHour1();
  selectedDate1+=(Util.HRS_1_MS * hour1);
  selectedDate2+=(Util.HRS_1_MS * hour2);
  selectedDurationHrs=view.getFilter().getDuration();
  List<String> metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedCategoryViewNames();
  if (metrics.isEmpty())   metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedSeverityViewNames();
  selectedMetrics=Util.convertToEnumFromCamelCase(metrics,ErrorMetric.class);
  view.reset();
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
}"
18578,"/** 
 * Bind.
 */
public void bind(){
  this.eventBus.addHandler(GetServicesEvent.TYPE,new GetServicesEventHandler(){
    public void onData(    GetServicesEvent event){
      if (servicesList == null) {
        servicesList=event.getData();
        view.setServicesMap(event.getData());
      }
    }
  }
);
  this.eventBus.addHandler(ObjectSelectionEvent.TYPE,new ObjectSelectionEventHandler(){
    public void onSelection(    ObjectSelectionEvent event){
      selectionContext=new SelectionContext();
      Map<ObjectType,String> selections=event.getSelections();
      if (selections != null) {
        for (        Map.Entry<ObjectType,String> entry : selections.entrySet()) {
          if (entry.getValue() != null)           selectionContext.select(entry.getKey(),entry.getValue());
        }
      }
    }
  }
);
  this.eventBus.addHandler(DateFilterSelectionEvent.TYPE,new DateFilterSelectionHandler(){
    public void onSelection(    DateFilterSelectionEvent event){
      selectedDate1=event.getDate1();
      selectedDate2=event.getDate2();
      selectedDurationHrs=event.getDuration();
      view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
      view.getFilter().setHour1(new Date(selectedDate1).getHours());
      view.getFilter().setDate1(new Date(selectedDate1));
      view.getFilter().setHours2(Util.getAvailableHours(selectedDate2));
      view.getFilter().setHour2(new Date(selectedDate2).getHours());
      view.getFilter().setDate2(new Date(selectedDate2));
      view.getFilter().setDuration(selectedDurationHrs);
    }
  }
);
  this.view.getFilter().getDate1().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      view.getFilter().setHours1(hrs);
    }
  }
);
  this.view.getFilter().getDate2().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      view.getFilter().setHours2(hrs);
    }
  }
);
  this.view.getFilter().getApplyButton().addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      long oldDate1=selectedDate1;
      long oldDate2=selectedDate2;
      selectedDate1=view.getFilter().getDate1().getValue().getTime();
      selectedDate2=view.getFilter().getDate2().getValue().getTime();
      int hour1=view.getFilter().getHour1();
      int hour2=view.getFilter().getHour2();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      int oldDuration=selectedDurationHrs;
      selectedDurationHrs=view.getFilter().getDuration();
      view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
      if ((oldDate1 != selectedDate1) || (oldDate2 != selectedDate2) || (oldDuration != selectedDurationHrs)) {
        eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
      }
      view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
      List<String> metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedCategoryViewNames();
      if (metrics.isEmpty())       metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedSeverityViewNames();
      selectedMetrics=Util.convertToEnumFromCamelCase(metrics,ErrorMetric.class);
      view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
    }
  }
);
  this.view.getSelector().addSelectionHandler(new SelectionHandler<TreeItem>(){
    public void onSelection(    SelectionEvent<TreeItem> event){
      TreeItem selection=event.getSelectedItem();
      selectionContext.unselect(ObjectType.ServiceName);
      selectionContext.unselect(ObjectType.OperationName);
      selectionContext.unselect(ObjectType.ErrorId);
      selectionContext.unselect(ObjectType.ErrorName);
      if (selection.getParentItem() != null) {
        selectionContext=new SelectionContext();
        if (selection.getChildCount() == 0) {
          selectionContext.select(ObjectType.OperationName,selection.getText());
          selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
        }
 else {
          selectionContext.select(ObjectType.ServiceName,selection.getText());
        }
      }
      view.setSelection(selectionContext.getSelections());
      eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
      selectedDate1=view.getFilter().getDate1().getValue().getTime();
      selectedDate2=view.getFilter().getDate2().getValue().getTime();
      int hour1=view.getFilter().getHour1();
      int hour2=view.getFilter().getHour2();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      selectedDurationHrs=view.getFilter().getDuration();
      List<String> metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedCategoryViewNames();
      if (metrics.isEmpty())       metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedSeverityViewNames();
      selectedMetrics=Util.convertToEnumFromCamelCase(metrics,ErrorMetric.class);
      view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
    }
  }
);
}","/** 
 * Bind.
 */
public void bind(){
  this.eventBus.addHandler(GetServicesEvent.TYPE,new GetServicesEventHandler(){
    public void onData(    GetServicesEvent event){
      if (servicesList == null) {
        servicesList=event.getData();
        view.setServicesMap(event.getData());
      }
    }
  }
);
  this.eventBus.addHandler(ObjectSelectionEvent.TYPE,new ObjectSelectionEventHandler(){
    public void onSelection(    ObjectSelectionEvent event){
      selectionContext=new SelectionContext();
      Map<ObjectType,String> selections=event.getSelections();
      if (selections != null) {
        for (        Map.Entry<ObjectType,String> entry : selections.entrySet()) {
          if (entry.getValue() != null)           selectionContext.select(entry.getKey(),entry.getValue());
        }
      }
    }
  }
);
  this.eventBus.addHandler(DateFilterSelectionEvent.TYPE,new DateFilterSelectionHandler(){
    public void onSelection(    DateFilterSelectionEvent event){
      selectedDate1=event.getDate1();
      selectedDate2=event.getDate2();
      selectedDurationHrs=event.getDuration();
      view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
      view.getFilter().setHour1(new Date(selectedDate1).getHours());
      view.getFilter().setDate1(new Date(selectedDate1));
      view.getFilter().setDate2(new Date(selectedDate2));
      view.getFilter().setDuration(selectedDurationHrs);
    }
  }
);
  this.view.getFilter().getDate1().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      view.getFilter().setHours1(hrs);
    }
  }
);
  this.view.getFilter().getDate2().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
    }
  }
);
  this.view.getFilter().getApplyButton().addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      long oldDate1=selectedDate1;
      long oldDate2=selectedDate2;
      selectedDate1=view.getFilter().getDate1().getValue().getTime();
      selectedDate2=view.getFilter().getDate2().getValue().getTime();
      int hour1=view.getFilter().getHour1();
      int hour2=view.getFilter().getHour1();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      int oldDuration=selectedDurationHrs;
      selectedDurationHrs=view.getFilter().getDuration();
      view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
      if ((oldDate1 != selectedDate1) || (oldDate2 != selectedDate2) || (oldDuration != selectedDurationHrs)) {
        eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
      }
      view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
      List<String> metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedCategoryViewNames();
      if (metrics.isEmpty())       metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedSeverityViewNames();
      selectedMetrics=Util.convertToEnumFromCamelCase(metrics,ErrorMetric.class);
      view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
    }
  }
);
  this.view.getSelector().addSelectionHandler(new SelectionHandler<TreeItem>(){
    public void onSelection(    SelectionEvent<TreeItem> event){
      TreeItem selection=event.getSelectedItem();
      selectionContext.unselect(ObjectType.ServiceName);
      selectionContext.unselect(ObjectType.OperationName);
      selectionContext.unselect(ObjectType.ErrorId);
      selectionContext.unselect(ObjectType.ErrorName);
      if (selection.getParentItem() != null) {
        selectionContext=new SelectionContext();
        if (selection.getChildCount() == 0) {
          selectionContext.select(ObjectType.OperationName,selection.getText());
          selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
        }
 else {
          selectionContext.select(ObjectType.ServiceName,selection.getText());
        }
      }
      view.setSelection(selectionContext.getSelections());
      eventBus.fireEvent(new ObjectSelectionEvent(selectionContext.getSelections()));
      selectedDate1=view.getFilter().getDate1().getValue().getTime();
      selectedDate2=view.getFilter().getDate2().getValue().getTime();
      int hour1=view.getFilter().getHour1();
      int hour2=view.getFilter().getHour1();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      selectedDurationHrs=view.getFilter().getDuration();
      List<String> metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedCategoryViewNames();
      if (metrics.isEmpty())       metrics=((Filterable.ErrorFilterable)view.getFilter()).getSelectedSeverityViewNames();
      selectedMetrics=Util.convertToEnumFromCamelCase(metrics,ErrorMetric.class);
      view.reset();
      fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
    }
  }
);
}"
18579,"public void go(HasWidgets container,HistoryToken token){
  selectionContext=SelectionContext.fromHistoryToken(token);
  view.setSelection(selectionContext.getSelections());
  if (servicesList == null)   fetchServices();
  FilterContext historyFilter=FilterContext.fromHistoryToken(token);
  Date now=new Date();
  long fullTimeLastHour=Util.getLastHour(now);
  long sameTimeYesterday=Util.get24HrsPrevious(fullTimeLastHour);
  selectedDate1=(historyFilter.getDate1() == 0 ? new Date(sameTimeYesterday).getTime() : historyFilter.getDate1());
  selectedDate2=(historyFilter.getDate2() == 0 ? new Date(fullTimeLastHour).getTime() : historyFilter.getDate2());
  view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
  view.getFilter().setHour1(new Date(selectedDate1).getHours());
  view.getFilter().setDate1(new Date(selectedDate1));
  view.getFilter().setHours2(Util.getAvailableHours(selectedDate2));
  view.getFilter().setHour2(new Date(selectedDate2).getHours());
  view.getFilter().setDate2(new Date(selectedDate2));
  selectedDurationHrs=(historyFilter.getDurationHrs() == 0 ? MetricsQueryService.DEFAULT_DURATION_HRS : historyFilter.getDurationHrs());
  int[] intervals=new int[24];
  for (int i=0; i < 24; i++)   intervals[i]=i + 1;
  view.getFilter().setDurations(intervals);
  view.getFilter().setDuration(selectedDurationHrs);
  view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
  Filterable.ErrorFilterable errFilter=(Filterable.ErrorFilterable)view.getFilter();
  errFilter.setCategoryViewNames(Util.convertFromEnumToCamelCase(CATEGORY_METRICS));
  errFilter.setSeverityViewNames(Util.convertFromEnumToCamelCase(SEVERITY_METRICS));
  List<String> metricNamesFromHistory=historyFilter.getMetricNames();
  List<ErrorMetric> errorMetricsFromHistory=Util.convertToEnumFromCamelCase(metricNamesFromHistory,ErrorMetric.class);
  if (errorMetricsFromHistory.isEmpty()) {
    selectedMetrics=CATEGORY_METRICS;
    errFilter.setSelectedCategoryViewNames(Util.convertFromEnumToCamelCase(selectedMetrics));
  }
 else {
    selectedMetrics=errorMetricsFromHistory;
    boolean isCategory=false;
    for (    ErrorMetric m : selectedMetrics) {
      if (CATEGORY_METRICS.contains(m)) {
        isCategory=true;
        break;
      }
    }
    if (isCategory) {
      errFilter.setSelectedCategoryViewNames(Util.convertFromEnumToCamelCase(selectedMetrics));
    }
 else {
      errFilter.setSelectedSeverityViewNames(Util.convertFromEnumToCamelCase(selectedMetrics));
    }
  }
  view.reset();
  if (selectionContext.getSelection(ObjectType.ErrorId) != null || selectionContext.getSelection(ObjectType.ErrorName) != null) {
    selectedMetrics=Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError});
    fetchErrorDetail(selectionContext);
  }
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  ((Dashboard)container).activate(this.view);
}","public void go(HasWidgets container,HistoryToken token){
  selectionContext=SelectionContext.fromHistoryToken(token);
  view.setSelection(selectionContext.getSelections());
  if (servicesList == null)   fetchServices();
  FilterContext historyFilter=FilterContext.fromHistoryToken(token);
  Date now=new Date();
  long fullTimeLastHour=Util.getLastHour(now);
  long sameTimeYesterday=Util.get24HrsPrevious(fullTimeLastHour);
  selectedDate1=(historyFilter.getDate1() == 0 ? new Date(sameTimeYesterday).getTime() : historyFilter.getDate1());
  selectedDate2=(historyFilter.getDate2() == 0 ? new Date(fullTimeLastHour).getTime() : historyFilter.getDate2());
  view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
  view.getFilter().setHour1(new Date(selectedDate1).getHours());
  view.getFilter().setDate1(new Date(selectedDate1));
  view.getFilter().setDate2(new Date(selectedDate2));
  selectedDurationHrs=(historyFilter.getDurationHrs() == 0 ? MetricsQueryService.DEFAULT_DURATION_HRS : historyFilter.getDurationHrs());
  int[] intervals=new int[24];
  for (int i=0; i < 24; i++)   intervals[i]=i + 1;
  view.getFilter().setDurations(intervals);
  view.getFilter().setDuration(selectedDurationHrs);
  view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
  Filterable.ErrorFilterable errFilter=(Filterable.ErrorFilterable)view.getFilter();
  errFilter.setCategoryViewNames(Util.convertFromEnumToCamelCase(CATEGORY_METRICS));
  errFilter.setSeverityViewNames(Util.convertFromEnumToCamelCase(SEVERITY_METRICS));
  List<String> metricNamesFromHistory=historyFilter.getMetricNames();
  List<ErrorMetric> errorMetricsFromHistory=Util.convertToEnumFromCamelCase(metricNamesFromHistory,ErrorMetric.class);
  if (errorMetricsFromHistory.isEmpty()) {
    selectedMetrics=CATEGORY_METRICS;
    errFilter.setSelectedCategoryViewNames(Util.convertFromEnumToCamelCase(selectedMetrics));
  }
 else {
    selectedMetrics=errorMetricsFromHistory;
    boolean isCategory=false;
    for (    ErrorMetric m : selectedMetrics) {
      if (CATEGORY_METRICS.contains(m)) {
        isCategory=true;
        break;
      }
    }
    if (isCategory) {
      errFilter.setSelectedCategoryViewNames(Util.convertFromEnumToCamelCase(selectedMetrics));
    }
 else {
      errFilter.setSelectedSeverityViewNames(Util.convertFromEnumToCamelCase(selectedMetrics));
    }
  }
  view.reset();
  if (selectionContext.getSelection(ObjectType.ErrorId) != null || selectionContext.getSelection(ObjectType.ErrorName) != null) {
    selectedMetrics=Arrays.asList(new ErrorMetric[]{ErrorMetric.ConsumerError});
    fetchErrorDetail(selectionContext);
  }
  fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  ((Dashboard)container).activate(this.view);
}"
18580,"public void onValueChange(ValueChangeEvent<Date> event){
  Date date=event.getValue();
  int[] hrs=Util.getAvailableHours(date);
  ServicePresenter.this.view.getFilter().setHours2(hrs);
}","public void onValueChange(ValueChangeEvent<Date> event){
  Date date=event.getValue();
  int[] hrs=Util.getAvailableHours(date);
  ServicePresenter.this.view.getFilter().setHours1(hrs);
}"
18581,"public void onSelection(SelectionEvent<TreeItem> event){
  TreeItem selection=event.getSelectedItem();
  selectionContext=new SelectionContext();
  if (selection.getParentItem() == null) {
    selectionContext.unselect(ObjectType.ServiceName);
    selectionContext.unselect(ObjectType.OperationName);
  }
 else {
    if (selection.getChildCount() == 0) {
      selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
      selectionContext.select(ObjectType.OperationName,selection.getText());
    }
 else {
      selectionContext.select(ObjectType.ServiceName,selection.getText());
    }
  }
  view.setSelection(selectionContext.getSelections());
  fireObjectSelectionEvent(selectionContext);
  selectedDate1=ServicePresenter.this.view.getFilter().getDate1().getValue().getTime();
  selectedDate2=ServicePresenter.this.view.getFilter().getDate2().getValue().getTime();
  int hour1=ServicePresenter.this.view.getFilter().getHour1();
  int hour2=ServicePresenter.this.view.getFilter().getHour2();
  selectedDate1+=(Util.HRS_1_MS * hour1);
  selectedDate2+=(Util.HRS_1_MS * hour2);
  selectedDurationHrs=ServicePresenter.this.view.getFilter().getDuration();
  eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
  selectedMetrics=Util.convertToEnumFromCamelCase(ServicePresenter.this.view.getFilter().getSelectedMetricNames(),ServiceMetric.class);
  view.reset();
  if (selectionContext.isSelected(ObjectType.ServiceName))   fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
}","public void onSelection(SelectionEvent<TreeItem> event){
  TreeItem selection=event.getSelectedItem();
  selectionContext=new SelectionContext();
  if (selection.getParentItem() == null) {
    selectionContext.unselect(ObjectType.ServiceName);
    selectionContext.unselect(ObjectType.OperationName);
  }
 else {
    if (selection.getChildCount() == 0) {
      selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
      selectionContext.select(ObjectType.OperationName,selection.getText());
    }
 else {
      selectionContext.select(ObjectType.ServiceName,selection.getText());
    }
  }
  view.setSelection(selectionContext.getSelections());
  fireObjectSelectionEvent(selectionContext);
  selectedDate1=ServicePresenter.this.view.getFilter().getDate1().getValue().getTime();
  selectedDate2=ServicePresenter.this.view.getFilter().getDate2().getValue().getTime();
  int hour1=ServicePresenter.this.view.getFilter().getHour1();
  int hour2=ServicePresenter.this.view.getFilter().getHour1();
  selectedDate1+=(Util.HRS_1_MS * hour1);
  selectedDate2+=(Util.HRS_1_MS * hour2);
  selectedDurationHrs=ServicePresenter.this.view.getFilter().getDuration();
  eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
  selectedMetrics=Util.convertToEnumFromCamelCase(ServicePresenter.this.view.getFilter().getSelectedMetricNames(),ServiceMetric.class);
  view.reset();
  if (selectionContext.isSelected(ObjectType.ServiceName))   fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
}"
18582,"/** 
 * Bind.
 */
public void bind(){
  this.eventBus.addHandler(ObjectSelectionEvent.TYPE,new ObjectSelectionEventHandler(){
    public void onSelection(    ObjectSelectionEvent event){
      selectionContext=new SelectionContext();
      if (event.getSelection(ObjectType.ServiceName) != null)       selectionContext.select(ObjectType.ServiceName,event.getSelection(ObjectType.ServiceName));
      if (event.getSelection(ObjectType.OperationName) != null)       selectionContext.select(ObjectType.OperationName,event.getSelection(ObjectType.OperationName));
    }
  }
);
  this.view.getFilter().getDate1().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      ServicePresenter.this.view.getFilter().setHours1(hrs);
    }
  }
);
  this.view.getFilter().getDate2().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      ServicePresenter.this.view.getFilter().setHours2(hrs);
    }
  }
);
  this.view.getFilter().getApplyButton().addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      if (selectionContext.getSelection(ObjectType.ServiceName) == null) {
        view.error(ConsoleUtil.messages.selectServer());
      }
 else {
        selectedDate1=ServicePresenter.this.view.getFilter().getDate1().getValue().getTime();
        selectedDate2=ServicePresenter.this.view.getFilter().getDate2().getValue().getTime();
        int hour1=ServicePresenter.this.view.getFilter().getHour1();
        int hour2=ServicePresenter.this.view.getFilter().getHour2();
        selectedDate1+=(Util.HRS_1_MS * hour1);
        selectedDate2+=(Util.HRS_1_MS * hour2);
        selectedDurationHrs=ServicePresenter.this.view.getFilter().getDuration();
        view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
        eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
        selectedMetrics=Util.convertToEnumFromCamelCase(ServicePresenter.this.view.getFilter().getSelectedMetricNames(),ServiceMetric.class);
        view.reset();
        fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
        insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
      }
    }
  }
);
  this.view.getSelector().addSelectionHandler(new SelectionHandler<TreeItem>(){
    public void onSelection(    SelectionEvent<TreeItem> event){
      TreeItem selection=event.getSelectedItem();
      selectionContext=new SelectionContext();
      if (selection.getParentItem() == null) {
        selectionContext.unselect(ObjectType.ServiceName);
        selectionContext.unselect(ObjectType.OperationName);
      }
 else {
        if (selection.getChildCount() == 0) {
          selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
          selectionContext.select(ObjectType.OperationName,selection.getText());
        }
 else {
          selectionContext.select(ObjectType.ServiceName,selection.getText());
        }
      }
      view.setSelection(selectionContext.getSelections());
      fireObjectSelectionEvent(selectionContext);
      selectedDate1=ServicePresenter.this.view.getFilter().getDate1().getValue().getTime();
      selectedDate2=ServicePresenter.this.view.getFilter().getDate2().getValue().getTime();
      int hour1=ServicePresenter.this.view.getFilter().getHour1();
      int hour2=ServicePresenter.this.view.getFilter().getHour2();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      selectedDurationHrs=ServicePresenter.this.view.getFilter().getDuration();
      eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
      selectedMetrics=Util.convertToEnumFromCamelCase(ServicePresenter.this.view.getFilter().getSelectedMetricNames(),ServiceMetric.class);
      view.reset();
      if (selectionContext.isSelected(ObjectType.ServiceName))       fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
    }
  }
);
}","/** 
 * Bind.
 */
public void bind(){
  this.eventBus.addHandler(ObjectSelectionEvent.TYPE,new ObjectSelectionEventHandler(){
    public void onSelection(    ObjectSelectionEvent event){
      selectionContext=new SelectionContext();
      if (event.getSelection(ObjectType.ServiceName) != null)       selectionContext.select(ObjectType.ServiceName,event.getSelection(ObjectType.ServiceName));
      if (event.getSelection(ObjectType.OperationName) != null)       selectionContext.select(ObjectType.OperationName,event.getSelection(ObjectType.OperationName));
    }
  }
);
  this.view.getFilter().getDate1().addValueChangeHandler(new ValueChangeHandler<Date>(){
    public void onValueChange(    ValueChangeEvent<Date> event){
      Date date=event.getValue();
      int[] hrs=Util.getAvailableHours(date);
      ServicePresenter.this.view.getFilter().setHours1(hrs);
    }
  }
);
  this.view.getFilter().getApplyButton().addClickHandler(new ClickHandler(){
    public void onClick(    ClickEvent event){
      if (selectionContext.getSelection(ObjectType.ServiceName) == null) {
        view.error(ConsoleUtil.messages.selectServer());
      }
 else {
        selectedDate1=ServicePresenter.this.view.getFilter().getDate1().getValue().getTime();
        selectedDate2=ServicePresenter.this.view.getFilter().getDate2().getValue().getTime();
        int hour1=ServicePresenter.this.view.getFilter().getHour1();
        int hour2=ServicePresenter.this.view.getFilter().getHour1();
        selectedDate1+=(Util.HRS_1_MS * hour1);
        selectedDate2+=(Util.HRS_1_MS * hour2);
        selectedDurationHrs=ServicePresenter.this.view.getFilter().getDuration();
        view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
        eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
        selectedMetrics=Util.convertToEnumFromCamelCase(ServicePresenter.this.view.getFilter().getSelectedMetricNames(),ServiceMetric.class);
        view.reset();
        fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
        insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
      }
    }
  }
);
  this.view.getSelector().addSelectionHandler(new SelectionHandler<TreeItem>(){
    public void onSelection(    SelectionEvent<TreeItem> event){
      TreeItem selection=event.getSelectedItem();
      selectionContext=new SelectionContext();
      if (selection.getParentItem() == null) {
        selectionContext.unselect(ObjectType.ServiceName);
        selectionContext.unselect(ObjectType.OperationName);
      }
 else {
        if (selection.getChildCount() == 0) {
          selectionContext.select(ObjectType.ServiceName,selection.getParentItem().getText());
          selectionContext.select(ObjectType.OperationName,selection.getText());
        }
 else {
          selectionContext.select(ObjectType.ServiceName,selection.getText());
        }
      }
      view.setSelection(selectionContext.getSelections());
      fireObjectSelectionEvent(selectionContext);
      selectedDate1=ServicePresenter.this.view.getFilter().getDate1().getValue().getTime();
      selectedDate2=ServicePresenter.this.view.getFilter().getDate2().getValue().getTime();
      int hour1=ServicePresenter.this.view.getFilter().getHour1();
      int hour2=ServicePresenter.this.view.getFilter().getHour1();
      selectedDate1+=(Util.HRS_1_MS * hour1);
      selectedDate2+=(Util.HRS_1_MS * hour2);
      selectedDurationHrs=ServicePresenter.this.view.getFilter().getDuration();
      eventBus.fireEvent(new DateFilterSelectionEvent(selectedDate1,selectedDate2,selectedDurationHrs));
      selectedMetrics=Util.convertToEnumFromCamelCase(ServicePresenter.this.view.getFilter().getSelectedMetricNames(),ServiceMetric.class);
      view.reset();
      if (selectionContext.isSelected(ObjectType.ServiceName))       fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
      insertHistory(selectionContext,selectedDate1,selectedDate2,selectedDurationHrs,selectedMetrics,false);
    }
  }
);
}"
18583,"/** 
 * Handle a navigational change, either via the history forward/back buttons or via a user selection (for simplicity also generated as a history change).
 * @param container the container
 * @param token the token
 * @see org.ebayopensource.turmeric.monitoring.client.presenter.Presenter#go(com.google.gwt.user.client.ui.HasWidgets,org.ebayopensource.turmeric.monitoring.client.model.HistoryToken)
 */
public void go(HasWidgets container,HistoryToken token){
  SelectionContext oldContext=selectionContext;
  selectionContext=SelectionContext.fromHistoryToken(token);
  view.setSelection(selectionContext.getSelections());
  conditionalFireServiceFilterSelectionEvent(oldContext,selectionContext);
  if (servicesList == null)   fetchServices();
  FilterContext filter=FilterContext.fromHistoryToken(token);
  Date now=new Date();
  long fullTimeLastHour=Util.getLastHour(now);
  long sameTimeYesterday=Util.get24HrsPrevious(fullTimeLastHour);
  long oldDate1=selectedDate1;
  long oldDate2=selectedDate2;
  selectedDate1=(filter.getDate1() == 0 ? new Date(sameTimeYesterday).getTime() : filter.getDate1());
  selectedDate2=(filter.getDate2() == 0 ? new Date(fullTimeLastHour).getTime() : filter.getDate2());
  Date asDate1=new Date(selectedDate1);
  Date asDate2=new Date(selectedDate2);
  ServicePresenter.this.view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
  ServicePresenter.this.view.getFilter().setHour1(asDate1.getHours());
  ServicePresenter.this.view.getFilter().setDate1(asDate1);
  ServicePresenter.this.view.getFilter().setHours2(Util.getAvailableHours(selectedDate2));
  ServicePresenter.this.view.getFilter().setHour2(asDate2.getHours());
  ServicePresenter.this.view.getFilter().setDate2(asDate2);
  int oldInterval=selectedDurationHrs;
  selectedDurationHrs=(filter.getDurationHrs() == 0 ? MetricsQueryService.DEFAULT_DURATION_HRS : filter.getDurationHrs());
  view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
  conditionalFireDateSelectionEvent(oldDate1,selectedDate1,oldDate2,selectedDate2,oldInterval,selectedDurationHrs);
  int[] intervals=new int[24];
  for (int i=0; i < 24; i++)   intervals[i]=i + 1;
  ServicePresenter.this.view.getFilter().setDurations(intervals);
  ServicePresenter.this.view.getFilter().setDuration(selectedDurationHrs);
  ServicePresenter.this.view.getFilter().setMetricNames(Util.convertFromEnumToCamelCase(Arrays.asList(ServiceMetric.values())));
  if (filter.getMetricNames() == null)   selectedMetrics=new ArrayList<ServiceMetric>(Arrays.asList(ServiceMetric.values()));
 else   selectedMetrics=Util.convertToEnumFromCamelCase(filter.getMetricNames(),ServiceMetric.class);
  view.getFilter().setSelectedMetricNames(Util.convertFromEnumToCamelCase(selectedMetrics));
  view.reset();
  if (selectionContext.getSelection(ObjectType.ServiceName) != null) {
    fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  }
  ((Dashboard)container).activate(this.view);
}","/** 
 * Handle a navigational change, either via the history forward/back buttons or via a user selection (for simplicity also generated as a history change).
 * @param container the container
 * @param token the token
 * @see org.ebayopensource.turmeric.monitoring.client.presenter.Presenter#go(com.google.gwt.user.client.ui.HasWidgets,org.ebayopensource.turmeric.monitoring.client.model.HistoryToken)
 */
public void go(HasWidgets container,HistoryToken token){
  SelectionContext oldContext=selectionContext;
  selectionContext=SelectionContext.fromHistoryToken(token);
  view.setSelection(selectionContext.getSelections());
  conditionalFireServiceFilterSelectionEvent(oldContext,selectionContext);
  if (servicesList == null)   fetchServices();
  FilterContext filter=FilterContext.fromHistoryToken(token);
  Date now=new Date();
  long fullTimeLastHour=Util.getLastHour(now);
  long sameTimeYesterday=Util.get24HrsPrevious(fullTimeLastHour);
  long oldDate1=selectedDate1;
  long oldDate2=selectedDate2;
  selectedDate1=(filter.getDate1() == 0 ? new Date(sameTimeYesterday).getTime() : filter.getDate1());
  selectedDate2=(filter.getDate2() == 0 ? new Date(fullTimeLastHour).getTime() : filter.getDate2());
  Date asDate1=new Date(selectedDate1);
  Date asDate2=new Date(selectedDate2);
  ServicePresenter.this.view.getFilter().setHours1(Util.getAvailableHours(selectedDate1));
  ServicePresenter.this.view.getFilter().setHour1(asDate1.getHours());
  ServicePresenter.this.view.getFilter().setDate1(asDate1);
  ServicePresenter.this.view.getFilter().setDate2(asDate2);
  int oldInterval=selectedDurationHrs;
  selectedDurationHrs=(filter.getDurationHrs() == 0 ? MetricsQueryService.DEFAULT_DURATION_HRS : filter.getDurationHrs());
  view.setFilterLabel(makeFilterLabel(selectedDate1,selectedDate2,selectedDurationHrs));
  conditionalFireDateSelectionEvent(oldDate1,selectedDate1,oldDate2,selectedDate2,oldInterval,selectedDurationHrs);
  int[] intervals=new int[24];
  for (int i=0; i < 24; i++)   intervals[i]=i + 1;
  ServicePresenter.this.view.getFilter().setDurations(intervals);
  ServicePresenter.this.view.getFilter().setDuration(selectedDurationHrs);
  ServicePresenter.this.view.getFilter().setMetricNames(Util.convertFromEnumToCamelCase(Arrays.asList(ServiceMetric.values())));
  if (filter.getMetricNames() == null)   selectedMetrics=new ArrayList<ServiceMetric>(Arrays.asList(ServiceMetric.values()));
 else   selectedMetrics=Util.convertToEnumFromCamelCase(filter.getMetricNames(),ServiceMetric.class);
  view.getFilter().setSelectedMetricNames(Util.convertFromEnumToCamelCase(selectedMetrics));
  view.reset();
  if (selectionContext.getSelection(ObjectType.ServiceName) != null) {
    fetchMetrics(selectedMetrics,selectionContext,selectedDate1,selectedDate2,selectedDurationHrs);
  }
  ((Dashboard)container).activate(this.view);
}"
18584,"/** 
 * Call the remote server to obtain metrics measurements.
 * @param criteria the criteria
 * @param resourceCriteria the resource criteria
 * @param callback the callback
 * @return the metric data
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getMetricData(org.ebayopensource.turmeric.monitoring.client.model.MetricCriteria,org.ebayopensource.turmeric.monitoring.client.model.MetricResourceCriteria,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getMetricData(final MetricCriteria criteria,final MetricResourceCriteria resourceCriteria,final AsyncCallback<MetricData> callback){
  final String url=URL.encode(MetricsDataRequest.getRestURL(criteria,resourceCriteria));
  GWT.log(""String_Node_Str"" + url);
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  final MetricData data=new MetricData();
  data.setRestUrl(url);
  data.setMetricCriteria(criteria);
  data.setMetricResourceCriteria(resourceCriteria);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          String responseText=response.getText();
          GWT.log(""String_Node_Str"" + responseText);
          MetricsDataResponse metricsResponse=MetricsDataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            GWT.log(""String_Node_Str"" + response.getText());
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            JsArray<MetricGroupDataJS> rows=metricsResponse.getReturnData();
            List<MetricGroupData> results=new ArrayList<MetricGroupData>();
            if (rows != null) {
              for (int i=0; i < rows.length(); i++) {
                MetricGroupDataJS js=rows.get(i);
                results.add(js);
              }
            }
            data.setReturnData(results);
            callback.onSuccess(data);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}","/** 
 * Call the remote server to obtain metrics measurements.
 * @param criteria the criteria
 * @param resourceCriteria the resource criteria
 * @param callback the callback
 * @return the metric data
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getMetricData(org.ebayopensource.turmeric.monitoring.client.model.MetricCriteria,org.ebayopensource.turmeric.monitoring.client.model.MetricResourceCriteria,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getMetricData(final MetricCriteria criteria,final MetricResourceCriteria resourceCriteria,final AsyncCallback<MetricData> callback){
  final String url=URL.encode(MetricsDataRequest.getRestURL(criteria,resourceCriteria));
  GWT.log(""String_Node_Str"" + url);
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  final MetricData data=new MetricData();
  data.setRestUrl(url);
  data.setMetricCriteria(criteria);
  data.setMetricResourceCriteria(resourceCriteria);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          String responseText=response.getText();
          GWT.log(""String_Node_Str"" + responseText);
          MetricsDataResponse metricsResponse=MetricsDataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            GWT.log(""String_Node_Str"" + response.getText());
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            JsArray<MetricGroupDataJS> rows=metricsResponse.getReturnData();
            List<MetricGroupData> results=new ArrayList<MetricGroupData>();
            if (rows != null) {
              for (int i=0; i < rows.length(); i++) {
                MetricGroupDataJS js=rows.get(i);
                results.add(js);
              }
            }
            data.setReturnData(results);
            callback.onSuccess(data);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}"
18585,"public void getServiceConsumers(final String serviceName,final AsyncCallback<Set<String>> callback){
  Set<String> serviceNames=new HashSet<String>();
  serviceNames.add(serviceName);
  final String url=MetricsMetaDataRequest.getRestURL(""String_Node_Str"",serviceNames,""String_Node_Str"");
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,URL.encode(url));
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      final Request request,      final Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
            Set<String> consumerNames=metaDataResponse.getOrderedResourceEntityResponseNames();
            callback.onSuccess(consumerNames);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}","public void getServiceConsumers(final String serviceName,final AsyncCallback<Set<String>> callback){
  Set<String> serviceNames=new HashSet<String>();
  serviceNames.add(serviceName);
  final String url=MetricsMetaDataRequest.getRestURL(""String_Node_Str"",serviceNames,""String_Node_Str"");
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,URL.encode(url));
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      final Request request,      final Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
            Set<String> consumerNames=metaDataResponse.getOrderedResourceEntityResponseNames();
            callback.onSuccess(consumerNames);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}"
18586,"public void onResponseReceived(final Request request,final Response response){
  if (response.getStatusCode() != Response.SC_OK) {
    GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
    callback.onFailure(getErrorAsThrowable(response));
  }
 else   if (response.getHeader(ERROR_HEADER) != null) {
    GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
    callback.onFailure(getErrorAsThrowable(response));
  }
 else {
    MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
    if (metaDataResponse == null)     callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
      Set<String> consumerNames=metaDataResponse.getOrderedResourceEntityResponseNames();
      callback.onSuccess(consumerNames);
    }
  }
}","public void onResponseReceived(final Request request,final Response response){
  if (response.getStatusCode() != Response.SC_OK) {
    GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
    callback.onFailure(getErrorAsThrowable(response));
  }
 else   if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
    GWT.log(""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
    callback.onFailure(getErrorAsThrowable(response));
  }
 else {
    MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
    if (metaDataResponse == null)     callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
      Set<String> consumerNames=metaDataResponse.getOrderedResourceEntityResponseNames();
      callback.onSuccess(consumerNames);
    }
  }
}"
18587,"private void getMetricValueForDate(MetricValue mv,final AsyncCallback<TimeSlotData> callback) throws RequestException {
  final TimeSlotData data=new TimeSlotData();
  data.setReturnData(new ArrayList<TimeSlotValue>(0));
  final String url=URL.encode(MetricValueRequest.getRestURL(mv));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  builder.setTimeoutMillis(60000);
  GWT.log(""String_Node_Str"" + url);
  builder.sendRequest(null,new RequestCallback(){
    public void onError(    Request request,    Throwable err){
      GWT.log(""String_Node_Str"",err);
      callback.onFailure(err);
    }
    public void onResponseReceived(    Request request,    Response response){
      if (response.getStatusCode() != Response.SC_OK) {
        GWT.log(""String_Node_Str"" + response.getStatusCode());
        callback.onFailure(new RequestException(""String_Node_Str"" + response.getStatusCode()));
      }
 else       if (response.getHeader(ERROR_HEADER) != null) {
        GWT.log(""String_Node_Str"" + response.getHeadersAsString());
        callback.onFailure(new RequestException(""String_Node_Str"" + response.getHeadersAsString()));
      }
 else {
        MetricValueResponse graphResponse=MetricValueResponse.fromJSON(response.getText());
        if (graphResponse == null) {
          GWT.log(""String_Node_Str"");
        }
 else {
          JsArray<MetricGraphDataJS> rows=graphResponse.getReturnData();
          List<TimeSlotValue> results=new ArrayList<TimeSlotValue>();
          if (rows != null) {
            for (int i=0; i < rows.length(); i++) {
              MetricGraphDataJS js=rows.get(i);
              results.add(js);
            }
          }
          data.getReturnData().addAll(results);
          callback.onSuccess(data);
        }
      }
    }
  }
);
}","private void getMetricValueForDate(MetricValue mv,final AsyncCallback<TimeSlotData> callback) throws RequestException {
  final TimeSlotData data=new TimeSlotData();
  data.setReturnData(new ArrayList<TimeSlotValue>(0));
  final String url=URL.encode(MetricValueRequest.getRestURL(mv));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  builder.setTimeoutMillis(60000);
  GWT.log(""String_Node_Str"" + url);
  builder.sendRequest(null,new RequestCallback(){
    public void onError(    Request request,    Throwable err){
      GWT.log(""String_Node_Str"",err);
      callback.onFailure(err);
    }
    public void onResponseReceived(    Request request,    Response response){
      if (response.getStatusCode() != Response.SC_OK) {
        GWT.log(""String_Node_Str"" + response.getStatusCode());
        callback.onFailure(new RequestException(""String_Node_Str"" + response.getStatusCode()));
      }
 else       if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
        GWT.log(""String_Node_Str"" + response.getHeadersAsString());
        callback.onFailure(new RequestException(""String_Node_Str"" + response.getHeadersAsString()));
      }
 else {
        MetricValueResponse graphResponse=MetricValueResponse.fromJSON(response.getText());
        if (graphResponse == null) {
          GWT.log(""String_Node_Str"");
        }
 else {
          JsArray<MetricGraphDataJS> rows=graphResponse.getReturnData();
          List<TimeSlotValue> results=new ArrayList<TimeSlotValue>();
          if (rows != null) {
            for (int i=0; i < rows.length(); i++) {
              MetricGraphDataJS js=rows.get(i);
              results.add(js);
            }
          }
          data.getReturnData().addAll(results);
          callback.onSuccess(data);
        }
      }
    }
  }
);
}"
18588,"/** 
 * Gets the service operations json.
 * @param serviceMap the service map
 * @param callback the callback
 * @return the service operations json
 */
public void getServiceOperationsJSON(final Map<String,Set<String>> serviceMap,final AsyncCallback<Map<String,Set<String>>> callback){
  final String url=MetricsMetaDataRequest.getJSONUrl();
  final String json=MetricsMetaDataRequest.getJSON(""String_Node_Str"",serviceMap.keySet(),""String_Node_Str"");
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,URL.encode(url));
  try {
    builder.sendRequest(json,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      final Request request,      final Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
            Set<String> operationNames=metaDataResponse.getOrderedResourceEntityResponseNames();
            String error=null;
            Iterator<String> itor=operationNames.iterator();
            while (itor.hasNext() && error == null) {
              String s=itor.next();
              int dot=s.indexOf(""String_Node_Str"");
              if (dot < 0) {
                error=s;
              }
 else {
                Set<String> operations=serviceMap.get(s.substring(0,dot));
                if (operations != null)                 operations.add(s.substring(dot + 1));
              }
            }
            if (error != null)             callback.onFailure(new Throwable(error));
 else             callback.onSuccess(serviceMap);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}","/** 
 * Gets the service operations json.
 * @param serviceMap the service map
 * @param callback the callback
 * @return the service operations json
 */
public void getServiceOperationsJSON(final Map<String,Set<String>> serviceMap,final AsyncCallback<Map<String,Set<String>>> callback){
  final String url=MetricsMetaDataRequest.getJSONUrl();
  final String json=MetricsMetaDataRequest.getJSON(""String_Node_Str"",serviceMap.keySet(),""String_Node_Str"");
  RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,URL.encode(url));
  try {
    builder.sendRequest(json,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      final Request request,      final Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
            Set<String> operationNames=metaDataResponse.getOrderedResourceEntityResponseNames();
            String error=null;
            Iterator<String> itor=operationNames.iterator();
            while (itor.hasNext() && error == null) {
              String s=itor.next();
              int dot=s.indexOf(""String_Node_Str"");
              if (dot < 0) {
                error=s;
              }
 else {
                Set<String> operations=serviceMap.get(s.substring(0,dot));
                if (operations != null)                 operations.add(s.substring(dot + 1));
              }
            }
            if (error != null)             callback.onFailure(new Throwable(error));
 else             callback.onSuccess(serviceMap);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}"
18589,"/** 
 * Gets the error detail.
 * @param errorId the error id
 * @param errorName the error name
 * @param service the service
 * @param callback the callback
 * @return the error detail
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorDetail(java.lang.String,java.lang.String,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getErrorDetail(final String errorId,final String errorName,final String service,final AsyncCallback<ErrorDetail> callback){
  final String url=URL.encode(ErrorMetricsMetadataRequest.getRestURL(errorId,errorName,service));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(new Throwable(""String_Node_Str"" + response.getStatusCode()));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
        }
 else {
          ErrorMetricsMetadataResponse metricsResponse=ErrorMetricsMetadataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            ErrorDetailJS js=metricsResponse.getReturnData();
            if (js == null)             callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else             callback.onSuccess(js);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}","/** 
 * Gets the error detail.
 * @param errorId the error id
 * @param errorName the error name
 * @param service the service
 * @param callback the callback
 * @return the error detail
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorDetail(java.lang.String,java.lang.String,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getErrorDetail(final String errorId,final String errorName,final String service,final AsyncCallback<ErrorDetail> callback){
  final String url=URL.encode(ErrorMetricsMetadataRequest.getRestURL(errorId,errorName,service));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(new Throwable(""String_Node_Str"" + response.getStatusCode()));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
        }
 else {
          ErrorMetricsMetadataResponse metricsResponse=ErrorMetricsMetadataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            ErrorDetailJS js=metricsResponse.getReturnData();
            if (js == null)             callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else             callback.onSuccess(js);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}"
18590,"/** 
 * Gets the error time slot data.
 * @param ec the ec
 * @param mc the mc
 * @param callback the callback
 * @return the error time slot data
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorTimeSlotData(org.ebayopensource.turmeric.monitoring.client.model.ErrorCriteria,org.ebayopensource.turmeric.monitoring.client.model.MetricCriteria,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getErrorTimeSlotData(final ErrorCriteria ec,final MetricCriteria mc,final AsyncCallback<ErrorTimeSlotData> callback){
  final String url=URL.encode(ErrorMetricsGraphRequest.getRestURL(ec,mc));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  final ErrorTimeSlotData data=new ErrorTimeSlotData();
  data.setRestUrl(url);
  data.setErrorCriteria(ec);
  data.setMetricCriteria(mc);
  GWT.log(""String_Node_Str"" + url);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          callback.onFailure(new Throwable(""String_Node_Str"" + response.getStatusCode()));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
        }
 else {
          String responseText=response.getText();
          ErrorMetricsGraphResponse graphResponse=ErrorMetricsGraphResponse.fromJSON(responseText);
          if (graphResponse == null) {
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            JsArray<MetricGraphDataJS> rows=graphResponse.getReturnData();
            List<TimeSlotValue> results=new ArrayList<TimeSlotValue>();
            if (rows != null) {
              for (int i=0; i < rows.length(); i++) {
                MetricGraphDataJS js=rows.get(i);
                results.add(js);
              }
            }
            data.setReturnData(results);
            callback.onSuccess(data);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}","/** 
 * Gets the error time slot data.
 * @param ec the ec
 * @param mc the mc
 * @param callback the callback
 * @return the error time slot data
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorTimeSlotData(org.ebayopensource.turmeric.monitoring.client.model.ErrorCriteria,org.ebayopensource.turmeric.monitoring.client.model.MetricCriteria,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getErrorTimeSlotData(final ErrorCriteria ec,final MetricCriteria mc,final AsyncCallback<ErrorTimeSlotData> callback){
  final String url=URL.encode(ErrorMetricsGraphRequest.getRestURL(ec,mc));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  final ErrorTimeSlotData data=new ErrorTimeSlotData();
  data.setRestUrl(url);
  data.setErrorCriteria(ec);
  data.setMetricCriteria(mc);
  GWT.log(""String_Node_Str"" + url);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          callback.onFailure(new Throwable(""String_Node_Str"" + response.getStatusCode()));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
        }
 else {
          String responseText=response.getText();
          ErrorMetricsGraphResponse graphResponse=ErrorMetricsGraphResponse.fromJSON(responseText);
          if (graphResponse == null) {
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            JsArray<MetricGraphDataJS> rows=graphResponse.getReturnData();
            List<TimeSlotValue> results=new ArrayList<TimeSlotValue>();
            if (rows != null) {
              for (int i=0; i < rows.length(); i++) {
                MetricGraphDataJS js=rows.get(i);
                results.add(js);
              }
            }
            data.setReturnData(results);
            callback.onSuccess(data);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}"
18591,"/** 
 * Gets the error data.
 * @param errorCriteria the error criteria
 * @param metricCriteria the metric criteria
 * @param callback the callback
 * @return the error data
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorData(org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService.ErrorType,java.util.List,java.util.List,java.util.List,java.lang.String,boolean,org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService.ErrorCategory,org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService.ErrorSeverity,org.ebayopensource.turmeric.monitoring.client.model.MetricCriteria)
 */
public void getErrorData(final ErrorCriteria errorCriteria,final MetricCriteria metricCriteria,final AsyncCallback<ErrorMetricData> callback){
  final String url=URL.encode(ErrorMetricsDataRequest.getRestURL(errorCriteria,metricCriteria));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  final ErrorMetricData data=new ErrorMetricData();
  data.setRestUrl(url);
  data.setErrorCriteria(errorCriteria);
  data.setMetricCriteria(metricCriteria);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          ErrorMetricsDataResponse metricsResponse=ErrorMetricsDataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getText());
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            JsArray<ErrorViewDataJS> rows=metricsResponse.getReturnData();
            List<ErrorViewData> results=new ArrayList<ErrorViewData>();
            if (rows != null) {
              for (int i=0; i < rows.length(); i++) {
                ErrorViewDataJS js=rows.get(i);
                results.add(js);
              }
            }
            data.setReturnData(results);
            callback.onSuccess(data);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
    GWT.log(""String_Node_Str"" + x.toString());
  }
}","/** 
 * Gets the error data.
 * @param errorCriteria the error criteria
 * @param metricCriteria the metric criteria
 * @param callback the callback
 * @return the error data
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorData(org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService.ErrorType,java.util.List,java.util.List,java.util.List,java.lang.String,boolean,org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService.ErrorCategory,org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService.ErrorSeverity,org.ebayopensource.turmeric.monitoring.client.model.MetricCriteria)
 */
public void getErrorData(final ErrorCriteria errorCriteria,final MetricCriteria metricCriteria,final AsyncCallback<ErrorMetricData> callback){
  final String url=URL.encode(ErrorMetricsDataRequest.getRestURL(errorCriteria,metricCriteria));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  final ErrorMetricData data=new ErrorMetricData();
  data.setRestUrl(url);
  data.setErrorCriteria(errorCriteria);
  data.setMetricCriteria(metricCriteria);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          ErrorMetricsDataResponse metricsResponse=ErrorMetricsDataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getText());
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            JsArray<ErrorViewDataJS> rows=metricsResponse.getReturnData();
            List<ErrorViewData> results=new ArrayList<ErrorViewData>();
            if (rows != null) {
              for (int i=0; i < rows.length(); i++) {
                ErrorViewDataJS js=rows.get(i);
                results.add(js);
              }
            }
            data.setReturnData(results);
            callback.onSuccess(data);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
    GWT.log(""String_Node_Str"" + x.toString());
  }
}"
18592,"/** 
 * Talk to the remote server to obtain a list of all operations for the given services.
 * @param serviceMap keys are the list of services for which to obtain the operations
 * @param callback the callback
 * @return the service operations
 */
public void getServiceOperations(final Map<String,Set<String>> serviceMap,final AsyncCallback<Map<String,Set<String>>> callback){
  final String url=MetricsMetaDataRequest.getRestURL(""String_Node_Str"",serviceMap.keySet(),""String_Node_Str"");
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,URL.encode(url));
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      final Request request,      final Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
            Set<String> operationNames=metaDataResponse.getOrderedResourceEntityResponseNames();
            String error=null;
            Iterator<String> itor=operationNames.iterator();
            while (itor.hasNext() && error == null) {
              String s=itor.next();
              int dot=s.indexOf(""String_Node_Str"");
              if (dot < 0) {
                error=s;
              }
 else {
                Set<String> operations=serviceMap.get(s.substring(0,dot));
                if (operations != null)                 operations.add(s.substring(dot + 1));
              }
            }
            if (error != null)             callback.onFailure(new Throwable(error));
 else             callback.onSuccess(serviceMap);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}","/** 
 * Talk to the remote server to obtain a list of all operations for the given services.
 * @param serviceMap keys are the list of services for which to obtain the operations
 * @param callback the callback
 * @return the service operations
 */
public void getServiceOperations(final Map<String,Set<String>> serviceMap,final AsyncCallback<Map<String,Set<String>>> callback){
  final String url=MetricsMetaDataRequest.getRestURL(""String_Node_Str"",serviceMap.keySet(),""String_Node_Str"");
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,URL.encode(url));
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      final Request request,      final Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else {
            Set<String> operationNames=metaDataResponse.getOrderedResourceEntityResponseNames();
            String error=null;
            Iterator<String> itor=operationNames.iterator();
            while (itor.hasNext() && error == null) {
              String s=itor.next();
              int dot=s.indexOf(""String_Node_Str"");
              if (dot < 0) {
                error=s;
              }
 else {
                Set<String> operations=serviceMap.get(s.substring(0,dot));
                if (operations != null)                 operations.add(s.substring(dot + 1));
              }
            }
            if (error != null)             callback.onFailure(new Throwable(error));
 else             callback.onSuccess(serviceMap);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}"
18593,"/** 
 * Call the remote server to obtain the list of services and their operations.
 * @param callback the callback
 * @return the services
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getServices(com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getServices(final AsyncCallback<Map<String,Set<String>>> callback){
  final String url=MetricsMetaDataRequest.getRestURL(""String_Node_Str"",null,""String_Node_Str"");
  final Map<String,Set<String>> serviceMap=new TreeMap<String,Set<String>>();
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,URL.encode(url));
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          GWT.log(response.getText());
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
 else {
            Set<String> services=metaDataResponse.getOrderedResourceEntityResponseNames();
            for (            String s : services) {
              GWT.log(""String_Node_Str"" + s);
              serviceMap.put(s,new TreeSet<String>());
            }
            getServiceOperationsJSON(serviceMap,callback);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}","/** 
 * Call the remote server to obtain the list of services and their operations.
 * @param callback the callback
 * @return the services
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getServices(com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getServices(final AsyncCallback<Map<String,Set<String>>> callback){
  final String url=MetricsMetaDataRequest.getRestURL(""String_Node_Str"",null,""String_Node_Str"");
  final Map<String,Set<String>> serviceMap=new TreeMap<String,Set<String>>();
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,URL.encode(url));
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else         if (response.getHeader(ERROR_HEADER) != null && response.getHeader(ERROR_HEADER).length() > 0) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(getErrorAsThrowable(response));
        }
 else {
          GWT.log(response.getText());
          MetricsMetaDataResponse metaDataResponse=MetricsMetaDataResponse.fromJSON(response.getText());
          if (metaDataResponse == null)           callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
 else {
            Set<String> services=metaDataResponse.getOrderedResourceEntityResponseNames();
            for (            String s : services) {
              GWT.log(""String_Node_Str"" + s);
              serviceMap.put(s,new TreeSet<String>());
            }
            getServiceOperationsJSON(serviceMap,callback);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}"
18594,"/** 
 * Gets the consumer service trends.
 * @param serviceName the service name
 * @param operationName the operation name
 * @param date1 the date1
 * @param date2 the date2
 * @param durationHrs the duration hrs
 * @param consumerNames the consumer names
 * @return the consumer service trends
 */
protected void getConsumerServiceTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  if (consumerNames != null && consumerNames.size() > 0) {
    ConsumerTabCallbackQueue queue=new ConsumerCallCountTrendCallbackQueue(serviceName,operationName,durationHrs,ConsumerPresenter.this.view);
    final Iterator<String> consuemrIterator=consumerNames.iterator();
    String consumerName=null;
    while (consuemrIterator.hasNext()) {
      consumerName=consuemrIterator.next();
      GWT.log(""String_Node_Str"" + consumerName);
      CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
      criteriaInfo.setMetricName(""String_Node_Str"");
      criteriaInfo.setConsumerName(consumerName);
      criteriaInfo.setServiceName(serviceName);
      if (operationName != null) {
        criteriaInfo.setOperationName(operationName);
      }
      criteriaInfo.setRoleType(""String_Node_Str"");
      ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
      cllbck.setId(consumerName);
      queue.add(cllbck);
      MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
      MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
      queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
    }
  }
 else {
    ConsumerPresenter.this.view.claerConsumerServiceCallTrendGraph();
  }
}","/** 
 * Gets the consumer service trends.
 * @param serviceName the service name
 * @param operationName the operation name
 * @param date1 the date1
 * @param date2 the date2
 * @param durationHrs the duration hrs
 * @param consumerNames the consumer names
 * @return the consumer service trends
 */
protected void getConsumerServiceTrends(final String serviceName,final String operationName,final long date1,final long date2,final int durationHrs,List<String> consumerNames){
  if (consumerNames != null && consumerNames.size() > 0) {
    ConsumerTabCallbackQueue queue=new ConsumerCallCountTrendCallbackQueue(serviceName,operationName,durationHrs,ConsumerPresenter.this.view);
    final Iterator<String> consuemrIterator=consumerNames.iterator();
    String consumerName=null;
    while (consuemrIterator.hasNext()) {
      consumerName=consuemrIterator.next();
      GWT.log(""String_Node_Str"" + consumerName);
      CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
      criteriaInfo.setMetricName(""String_Node_Str"");
      criteriaInfo.setConsumerName(consumerName);
      criteriaInfo.setServiceName(serviceName);
      if (operationName != null) {
        criteriaInfo.setOperationName(operationName);
      }
      criteriaInfo.setRoleType(""String_Node_Str"");
      ParallelCallback<List<TimeSlotData>> cllbck=new ParallelCallback<List<TimeSlotData>>();
      cllbck.setId(consumerName);
      queue.add(cllbck);
      MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
      MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
      queryService.getMetricValueTrend(firstDateValue,secondDateValue,cllbck);
    }
  }
 else {
    ConsumerPresenter.this.view.clearConsumerServiceCallTrendGraph();
  }
}"
18595,"/** 
 * Gets the consumer performance trend.
 * @param serviceName the service name
 * @param consumerName the consumer name
 * @param operationName the operation name
 * @param date1 the date1
 * @param date2 the date2
 * @param durationHrs the duration hrs
 * @return the consumer performance trend
 */
protected void getConsumerPerformanceTrend(final String serviceName,String consumerName,final String operationName,long date1,long date2,final int durationHrs){
  CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setConsumerName(consumerName);
  criteriaInfo.setServiceName(serviceName);
  if (operationName != null) {
    criteriaInfo.setOperationName(operationName);
  }
  criteriaInfo.setRoleType(""String_Node_Str"");
  Date firstDate=Util.resetTo12am(date1);
  Date secondDate=Util.resetTo12am(date2);
  MetricValue firstDateValue=new MetricValue(criteriaInfo,firstDate.getTime(),minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
  MetricValue secondDateValue=new MetricValue(criteriaInfo,secondDate.getTime(),minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
  queryService.getMetricValueTrend(firstDateValue,secondDateValue,new AsyncCallback<List<TimeSlotData>>(){
    @Override public void onSuccess(    List<TimeSlotData> dataRanges){
      String graphTitle=""String_Node_Str"";
      graphTitle=""String_Node_Str"" + serviceName;
      if (operationName != null) {
        graphTitle+=""String_Node_Str"" + operationName;
      }
      graphTitle+=""String_Node_Str"" + durationHrs + ""String_Node_Str"";
      ConsumerPresenter.this.view.activate();
      ConsumerPresenter.this.view.setConsumerPerformanceTrendData(dataRanges,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
);
}","/** 
 * Gets the consumer performance trend.
 * @param serviceName the service name
 * @param consumerName the consumer name
 * @param operationName the operation name
 * @param date1 the date1
 * @param date2 the date2
 * @param durationHrs the duration hrs
 * @return the consumer performance trend
 */
protected void getConsumerPerformanceTrend(final String serviceName,String consumerName,final String operationName,long date1,long date2,final int durationHrs){
  CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
  criteriaInfo.setMetricName(""String_Node_Str"");
  criteriaInfo.setConsumerName(consumerName);
  criteriaInfo.setServiceName(serviceName);
  if (operationName != null) {
    criteriaInfo.setOperationName(operationName);
  }
  criteriaInfo.setRoleType(""String_Node_Str"");
  MetricValue firstDateValue=new MetricValue(criteriaInfo,date1,minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
  MetricValue secondDateValue=new MetricValue(criteriaInfo,date2,minAggregationPeriod * durationHrs,(int)minAggregationPeriod,""String_Node_Str"");
  queryService.getMetricValueTrend(firstDateValue,secondDateValue,new AsyncCallback<List<TimeSlotData>>(){
    @Override public void onSuccess(    List<TimeSlotData> dataRanges){
      String graphTitle=""String_Node_Str"";
      graphTitle=""String_Node_Str"" + serviceName;
      if (operationName != null) {
        graphTitle+=""String_Node_Str"" + operationName;
      }
      graphTitle+=""String_Node_Str"" + durationHrs + ""String_Node_Str"";
      ConsumerPresenter.this.view.activate();
      ConsumerPresenter.this.view.setConsumerPerformanceTrendData(dataRanges,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
);
}"
18596,"public void setMetric(ConsumerMetric m,MetricData result){
  SummaryPanel panel=null;
  String date1Header=""String_Node_Str"";
  String date2Header=""String_Node_Str"";
  if (result != null) {
    String d1=ConsoleUtil.timeFormat.format(new Date(result.getMetricCriteria().date1));
    String d2=ConsoleUtil.timeFormat.format(new Date(result.getMetricCriteria().date2));
    date1Header=d1 + ""String_Node_Str"" + (result.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
    date2Header=d2 + ""String_Node_Str"" + (result.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
  }
switch (m) {
case CallVolume:
{
      String[] columns={ConsoleUtil.constants.consumers(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
      List<Widget[]> rows=new ArrayList<Widget[]>();
      if (result != null) {
        for (int i=0; i < result.getReturnData().size(); i++) {
          MetricGroupData rd=result.getReturnData().get(i);
          Widget[] rowData=new Widget[4];
          rowData[0]=new Label(rd.getCriteriaInfo().getConsumerName());
          rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
          rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
          rowData[3]=new Label(rd.getDiff());
          rows.add(rowData);
        }
      }
      setTabularData(callVolumeTable,columns,rows);
      for (int i=1; i < callVolumeTable.getRowCount(); i++) {
        Widget w=callVolumeTable.getWidget(i,0);
        w.addStyleName(""String_Node_Str"");
      }
      panel=callVolumePanel;
      break;
    }
case Performance:
{
    String[] columns={ConsoleUtil.constants.consumers(),(result == null ? ConsoleUtil.constants.average() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),(result == null ? ConsoleUtil.constants.average() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),""String_Node_Str"" + ConsoleUtil.constants.change()};
    List<Widget[]> rows=new ArrayList<Widget[]>();
    if (result != null) {
      for (int i=0; i < result.getReturnData().size(); i++) {
        MetricGroupData rd=result.getReturnData().get(i);
        Widget[] rowData=new Widget[4];
        rowData[0]=new Label(rd.getCriteriaInfo().getConsumerName());
        rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
        rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
        rowData[3]=new Label(rd.getDiff());
        rows.add(rowData);
      }
    }
    setTabularData(performanceTable,columns,rows);
    for (int i=1; i < performanceTable.getRowCount(); i++) {
      Widget w=performanceTable.getWidget(i,0);
      w.addStyleName(""String_Node_Str"");
    }
    panel=performancePanel;
    break;
  }
case Errors:
{
  String[] columns={ConsoleUtil.constants.consumers(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
  List<Widget[]> rows=new ArrayList<Widget[]>();
  if (result != null) {
    for (int i=0; i < result.getReturnData().size(); i++) {
      MetricGroupData rd=result.getReturnData().get(i);
      Widget[] rowData=new Widget[4];
      rowData[0]=new Label(rd.getCriteriaInfo().getConsumerName());
      rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
      rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
      rowData[3]=new Label(rd.getDiff());
      rows.add(rowData);
    }
  }
  setTabularData(errorsTable,columns,rows);
  for (int i=1; i < errorsTable.getRowCount(); i++) {
    Widget w=errorsTable.getWidget(i,0);
    w.addStyleName(""String_Node_Str"");
  }
  panel=errorsPanel;
  break;
}
case TopVolume:
{
String col0=ConsoleUtil.constants.services();
if (result != null && result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation)) col0=ConsoleUtil.constants.operations();
String[] columns={col0,(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
  for (int i=0; i < result.getReturnData().size(); i++) {
    MetricGroupData rd=result.getReturnData().get(i);
    Widget[] rowData=new Widget[4];
    if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Service))     rowData[0]=new Label(rd.getCriteriaInfo().getServiceName());
 else     if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation))     rowData[0]=new Label(rd.getCriteriaInfo().getOperationName());
    rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
    rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
    rowData[3]=new Label(rd.getDiff());
    rows.add(rowData);
  }
}
setTabularData(topVolumeTable,columns,rows);
for (int i=1; i < topVolumeTable.getRowCount(); i++) {
  Widget w=topVolumeTable.getWidget(i,0);
  w.addStyleName(""String_Node_Str"");
}
panel=topVolumePanel;
break;
}
case LeastPerformance:
{
String col0=ConsoleUtil.constants.services();
if (result != null && result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation)) col0=ConsoleUtil.constants.operations();
String[] columns={col0,(result == null ? ConsoleUtil.constants.average() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),(result == null ? ConsoleUtil.constants.average() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
for (int i=0; i < result.getReturnData().size(); i++) {
  MetricGroupData rd=result.getReturnData().get(i);
  Widget[] rowData=new Widget[4];
  if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Service))   rowData[0]=new Label(rd.getCriteriaInfo().getServiceName());
 else   if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation))   rowData[0]=new Label(rd.getCriteriaInfo().getOperationName());
  rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
  rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
  rowData[3]=new Label(rd.getDiff());
  rows.add(rowData);
}
}
setTabularData(leastPerformanceTable,columns,rows);
for (int i=1; i < leastPerformanceTable.getRowCount(); i++) {
Widget w=leastPerformanceTable.getWidget(i,0);
w.addStyleName(""String_Node_Str"");
}
panel=leastPerformancePanel;
break;
}
case TopServiceErrors:
{
boolean isOperation=false;
if (result != null && result.getMetricResourceCriteria() != null && result.getMetricResourceCriteria().resourceEntityRequests != null) {
for (ResourceEntityRequest r : result.getMetricResourceCriteria().resourceEntityRequests) {
if (r.resourceEntityType == Entity.Operation) isOperation=true;
}
}
String col0=ConsoleUtil.constants.services();
if (isOperation) col0=ConsoleUtil.constants.operations();
String[] columns={col0,ConsoleUtil.constants.errors(),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
for (int i=0; i < result.getReturnData().size(); i++) {
MetricGroupData rd=result.getReturnData().get(i);
Widget[] rowData=new Widget[5];
if (isOperation) rowData[0]=new Label(rd.getCriteriaInfo().getOperationName());
 else rowData[0]=new Label(rd.getCriteriaInfo().getServiceName());
rowData[1]=new Label(rd.getCriteriaInfo().getMetricName());
rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
rowData[3]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
rowData[4]=new Label(rd.getDiff());
rows.add(rowData);
}
}
setTabularData(topServiceErrorsTable,columns,rows);
for (int i=1; i < topServiceErrorsTable.getRowCount(); i++) {
Widget w=topServiceErrorsTable.getWidget(i,0);
w.addStyleName(""String_Node_Str"");
}
panel=topServiceErrorsPanel;
break;
}
case TopConsumerErrors:
{
String[] columns={ConsoleUtil.constants.errors(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
for (int i=0; i < result.getReturnData().size(); i++) {
MetricGroupData rd=result.getReturnData().get(i);
Widget[] rowData=new Widget[4];
rowData[0]=new Label(rd.getCriteriaInfo().getMetricName());
rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
rowData[3]=new Label(rd.getDiff());
rows.add(rowData);
}
}
setTabularData(topConsumerErrorsTable,columns,rows);
panel=topConsumerErrorsPanel;
break;
}
}
if (result != null && result.getReturnData() != null && panel != null) {
int rows=result.getReturnData().size() + 1;
double height=0;
if (rows > 10) height=10 * 2.5;
 else height=rows * 2.5;
panel.setContentContainerHeight(String.valueOf(height) + ""String_Node_Str"");
}
if (panel != null) {
if (result != null) panel.setInfo(result.getRestUrl());
show(panel);
}
}","public void setMetric(ConsumerMetric m,MetricData result){
  SummaryPanel panel=null;
  String date1Header=""String_Node_Str"";
  String date2Header=""String_Node_Str"";
  if (result != null) {
    String d1=ConsoleUtil.timeFormat.format(new Date(result.getMetricCriteria().date1));
    String d2=ConsoleUtil.timeFormat.format(new Date(result.getMetricCriteria().date2));
    date1Header=d1 + ""String_Node_Str"" + (result.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
    date2Header=d2 + ""String_Node_Str"" + (result.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
  }
switch (m) {
case CallVolume:
{
      String[] columns={ConsoleUtil.constants.consumers(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
      List<Widget[]> rows=new ArrayList<Widget[]>();
      if (result != null) {
        for (int i=0; i < result.getReturnData().size(); i++) {
          MetricGroupData rd=result.getReturnData().get(i);
          Widget[] rowData=new Widget[4];
          rowData[0]=new Label(rd.getCriteriaInfo().getConsumerName());
          rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
          rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
          rowData[3]=new Label(rd.getDiff());
          rows.add(rowData);
        }
      }
      setTabularData(callVolumeTable,columns,rows);
      for (int i=1; i < callVolumeTable.getRowCount(); i++) {
        Widget w=callVolumeTable.getWidget(i,0);
        w.addStyleName(""String_Node_Str"");
      }
      panel=callVolumePanel;
      break;
    }
case Performance:
{
    String[] columns={ConsoleUtil.constants.consumers(),(result == null ? ConsoleUtil.constants.average() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),(result == null ? ConsoleUtil.constants.average() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),""String_Node_Str"" + ConsoleUtil.constants.change()};
    List<Widget[]> rows=new ArrayList<Widget[]>();
    if (result != null) {
      for (int i=0; i < result.getReturnData().size(); i++) {
        MetricGroupData rd=result.getReturnData().get(i);
        Widget[] rowData=new Widget[4];
        rowData[0]=new Label(rd.getCriteriaInfo().getConsumerName());
        rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
        rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
        rowData[3]=new Label(rd.getDiff());
        rows.add(rowData);
      }
    }
    setTabularData(performanceTable,columns,rows);
    for (int i=1; i < performanceTable.getRowCount(); i++) {
      Widget w=performanceTable.getWidget(i,0);
      w.addStyleName(""String_Node_Str"");
    }
    panel=performancePanel;
    break;
  }
case Errors:
{
  String[] columns={ConsoleUtil.constants.consumers(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
  List<Widget[]> rows=new ArrayList<Widget[]>();
  if (result != null) {
    for (int i=0; i < result.getReturnData().size(); i++) {
      MetricGroupData rd=result.getReturnData().get(i);
      Widget[] rowData=new Widget[4];
      rowData[0]=new Label(rd.getCriteriaInfo().getConsumerName());
      rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
      rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
      rowData[3]=new Label(rd.getDiff());
      rows.add(rowData);
    }
  }
  setTabularData(errorsTable,columns,rows);
  for (int i=1; i < errorsTable.getRowCount(); i++) {
    Widget w=errorsTable.getWidget(i,0);
    w.addStyleName(""String_Node_Str"");
  }
  panel=errorsPanel;
  break;
}
case TopVolume:
{
String col0=ConsoleUtil.constants.services();
if (result != null && result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation)) col0=ConsoleUtil.constants.operations();
String[] columns={col0,(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
  for (int i=0; i < result.getReturnData().size(); i++) {
    MetricGroupData rd=result.getReturnData().get(i);
    Widget[] rowData=new Widget[4];
    if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Service))     rowData[0]=new Label(rd.getCriteriaInfo().getServiceName());
 else     if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation))     rowData[0]=new Label(rd.getCriteriaInfo().getOperationName());
    rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
    rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
    rowData[3]=new Label(rd.getDiff());
    rows.add(rowData);
  }
}
setTabularData(topVolumeTable,columns,rows);
for (int i=1; i < topVolumeTable.getRowCount(); i++) {
  Widget w=topVolumeTable.getWidget(i,0);
  w.addStyleName(""String_Node_Str"");
}
panel=topVolumePanel;
break;
}
case LeastPerformance:
{
String col0=ConsoleUtil.constants.services();
if (result != null && result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation)) col0=ConsoleUtil.constants.operations();
String[] columns={col0,(result == null ? ConsoleUtil.constants.average() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),(result == null ? ConsoleUtil.constants.average() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.average()+ ""String_Node_Str""),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
for (int i=0; i < result.getReturnData().size(); i++) {
  MetricGroupData rd=result.getReturnData().get(i);
  Widget[] rowData=new Widget[4];
  if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Service))   rowData[0]=new Label(rd.getCriteriaInfo().getServiceName());
 else   if (result.getMetricResourceCriteria().resourceEntityResponseType.equals(Entity.Operation))   rowData[0]=new Label(rd.getCriteriaInfo().getOperationName());
  rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
  rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
  rowData[3]=new Label(rd.getDiff());
  rows.add(rowData);
}
}
setTabularData(leastPerformanceTable,columns,rows);
for (int i=1; i < leastPerformanceTable.getRowCount(); i++) {
Widget w=leastPerformanceTable.getWidget(i,0);
w.addStyleName(""String_Node_Str"");
}
panel=leastPerformancePanel;
break;
}
case TopServiceErrors:
{
boolean isOperation=false;
if (result != null && result.getMetricResourceCriteria() != null && result.getMetricResourceCriteria().resourceEntityRequests != null) {
for (ResourceEntityRequest r : result.getMetricResourceCriteria().resourceEntityRequests) {
if (r.resourceEntityType == Entity.Operation) isOperation=true;
}
}
String col0=ConsoleUtil.constants.services();
if (isOperation) col0=ConsoleUtil.constants.operations();
String[] columns={col0,ConsoleUtil.constants.errors(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
for (int i=0; i < result.getReturnData().size(); i++) {
MetricGroupData rd=result.getReturnData().get(i);
Widget[] rowData=new Widget[5];
if (isOperation) rowData[0]=new Label(rd.getCriteriaInfo().getOperationName());
 else rowData[0]=new Label(rd.getCriteriaInfo().getServiceName());
rowData[1]=new Label(rd.getCriteriaInfo().getMetricName());
rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
rowData[3]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
rowData[4]=new Label(rd.getDiff());
rows.add(rowData);
}
}
setTabularData(topServiceErrorsTable,columns,rows);
for (int i=1; i < topServiceErrorsTable.getRowCount(); i++) {
Widget w=topServiceErrorsTable.getWidget(i,0);
w.addStyleName(""String_Node_Str"");
}
panel=topServiceErrorsPanel;
break;
}
case TopConsumerErrors:
{
String[] columns={ConsoleUtil.constants.errors(),(result == null ? ConsoleUtil.constants.count() : date2Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),(result == null ? ConsoleUtil.constants.count() : date1Header + ""String_Node_Str"" + ConsoleUtil.constants.count()),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<Widget[]> rows=new ArrayList<Widget[]>();
if (result != null) {
for (int i=0; i < result.getReturnData().size(); i++) {
MetricGroupData rd=result.getReturnData().get(i);
Widget[] rowData=new Widget[4];
rowData[0]=new Label(rd.getCriteriaInfo().getMetricName());
rowData[1]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount2())));
rowData[2]=new Label(NumberFormat.getDecimalFormat().format(Double.parseDouble(rd.getCount1())));
rowData[3]=new Label(rd.getDiff());
rows.add(rowData);
}
}
setTabularData(topConsumerErrorsTable,columns,rows);
panel=topConsumerErrorsPanel;
break;
}
}
if (result != null && result.getReturnData() != null && panel != null) {
int rows=result.getReturnData().size() + 1;
double height=0;
if (rows > 10) height=10 * 2.5;
 else height=rows * 2.5;
panel.setContentContainerHeight(String.valueOf(height) + ""String_Node_Str"");
}
if (panel != null) {
if (result != null) panel.setInfo(result.getRestUrl());
show(panel);
}
}"
18597,"public void setMetric(ServiceMetric metric,MetricData data){
  SummaryPanel panel=null;
  String date1Header=""String_Node_Str"";
  String date2Header=""String_Node_Str"";
  if (data != null) {
    String d1=ConsoleUtil.shotTimeFormat.format(new Date(data.getMetricCriteria().date1));
    String d2=ConsoleUtil.shotTimeFormat.format(new Date(data.getMetricCriteria().date2));
    date1Header=d1 + ""String_Node_Str"" + (data.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
    date2Header=d2 + ""String_Node_Str"" + (data.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
  }
switch (metric) {
case TopVolume:
{
      String count=ConsoleUtil.constants.count();
      String[] columns={ConsoleUtil.constants.operations(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
      List<String[]> rows=new ArrayList<String[]>();
      if (data != null) {
        for (int i=0; i < data.getReturnData().size(); i++) {
          MetricGroupData rd=data.getReturnData().get(i);
          String[] rowData=new String[4];
          rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
          rowData[1]=rd.getCount1();
          rowData[2]=rd.getCount2();
          rowData[3]=rd.getDiff();
          rows.add(rowData);
        }
      }
      setTabularData(topVolumeTable,columns,rows,null);
      panel=topVolumePanel;
      break;
    }
case LeastPerformance:
{
    String avg=ConsoleUtil.constants.average();
    String[] columns={ConsoleUtil.constants.operations(),(data == null ? avg : date1Header + ""String_Node_Str"" + avg+ ""String_Node_Str""),(data == null ? avg : date2Header + ""String_Node_Str"" + avg+ ""String_Node_Str""),""String_Node_Str"" + ConsoleUtil.constants.change()};
    List<String[]> rows=new ArrayList<String[]>();
    if (data != null) {
      for (int i=0; i < data.getReturnData().size(); i++) {
        MetricGroupData rd=data.getReturnData().get(i);
        String[] rowData=new String[4];
        rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
        double d1=Double.parseDouble(rd.getCount1()) / 1000.0;
        double d2=Double.parseDouble(rd.getCount1()) / 1000.0;
        rowData[1]=String.valueOf(d1);
        rowData[2]=String.valueOf(d2);
        rowData[3]=rd.getDiff();
        rows.add(rowData);
      }
    }
    setTabularData(leastPerformanceTable,columns,rows,null);
    panel=leastPerformancePanel;
    break;
  }
case TopErrors:
{
  String count=ConsoleUtil.constants.count();
  String[] columns={ConsoleUtil.constants.errors(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
  List<String[]> rows=new ArrayList<String[]>();
  if (data != null) {
    for (int i=0; i < data.getReturnData().size(); i++) {
      MetricGroupData rd=data.getReturnData().get(i);
      String[] rowData=new String[4];
      rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
      rowData[1]=rd.getCount1();
      rowData[2]=rd.getCount2();
      rowData[3]=rd.getDiff();
      rows.add(rowData);
    }
  }
  setTabularData(topErrorsTable,columns,rows,null);
  panel=topErrorsPanel;
  break;
}
case ConsumerTraffic:
{
String count=ConsoleUtil.constants.count();
String[] columns={ConsoleUtil.constants.consumers(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<String[]> rows=new ArrayList<String[]>();
if (data != null) {
  for (int i=0; i < data.getReturnData().size(); i++) {
    MetricGroupData rd=data.getReturnData().get(i);
    String[] rowData=new String[4];
    rowData[0]=ConsoleUtil.convertConsumerFromMissing(rd.getCriteriaInfo().getConsumerName());
    rowData[1]=rd.getCount1();
    rowData[2]=rd.getCount2();
    rowData[3]=rd.getDiff();
    rows.add(rowData);
  }
}
setTabularData(consumerTrafficTable,columns,rows,new String[]{""String_Node_Str"",null,null});
panel=consumerTrafficPanel;
break;
}
case ConsumerErrors:
{
String count=ConsoleUtil.constants.count();
String[] columns={ConsoleUtil.constants.consumers(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<String[]> rows=new ArrayList<String[]>();
if (data != null) {
for (int i=0; i < data.getReturnData().size(); i++) {
  MetricGroupData rd=data.getReturnData().get(i);
  String[] rowData=new String[4];
  rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
  rowData[1]=rd.getCount1();
  rowData[2]=rd.getCount2();
  rowData[3]=rd.getDiff();
  rows.add(rowData);
}
}
setTabularData(consumerErrorsTable,columns,rows,new String[]{""String_Node_Str"",null,null});
panel=consumerErrorsPanel;
break;
}
}
if (data != null && data.getReturnData() != null && panel != null) {
int rows=data.getReturnData().size() + 1;
double height=0;
if (rows > 10) height=10 * 2.5;
 else height=rows * 2.5;
panel.setContentContainerHeight(String.valueOf(height) + ""String_Node_Str"");
}
if (panel != null) {
if (data != null) panel.setInfo(data.getRestUrl());
show(panel);
}
}","public void setMetric(ServiceMetric metric,MetricData data){
  SummaryPanel panel=null;
  String date1Header=""String_Node_Str"";
  String date2Header=""String_Node_Str"";
  if (data != null) {
    String d1=ConsoleUtil.shotTimeFormat.format(new Date(data.getMetricCriteria().date1));
    String d2=ConsoleUtil.shotTimeFormat.format(new Date(data.getMetricCriteria().date2));
    date1Header=d1 + ""String_Node_Str"" + (data.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
    date2Header=d2 + ""String_Node_Str"" + (data.getMetricCriteria().durationSec / (60 * 60))+ ConsoleUtil.constants.hr();
  }
switch (metric) {
case TopVolume:
{
      String count=ConsoleUtil.constants.count();
      String[] columns={ConsoleUtil.constants.operations(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
      List<String[]> rows=new ArrayList<String[]>();
      if (data != null) {
        for (int i=0; i < data.getReturnData().size(); i++) {
          MetricGroupData rd=data.getReturnData().get(i);
          String[] rowData=new String[4];
          rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
          rowData[1]=rd.getCount1();
          rowData[2]=rd.getCount2();
          rowData[3]=rd.getDiff();
          rows.add(rowData);
        }
      }
      setTabularData(topVolumeTable,columns,rows,null);
      panel=topVolumePanel;
      break;
    }
case LeastPerformance:
{
    String avg=ConsoleUtil.constants.average();
    String[] columns={ConsoleUtil.constants.operations(),(data == null ? avg : date1Header + ""String_Node_Str"" + avg+ ""String_Node_Str""),(data == null ? avg : date2Header + ""String_Node_Str"" + avg+ ""String_Node_Str""),""String_Node_Str"" + ConsoleUtil.constants.change()};
    List<String[]> rows=new ArrayList<String[]>();
    if (data != null) {
      for (int i=0; i < data.getReturnData().size(); i++) {
        MetricGroupData rd=data.getReturnData().get(i);
        String[] rowData=new String[4];
        rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
        double d1=Double.parseDouble(rd.getCount1()) / 1000.0;
        double d2=Double.parseDouble(rd.getCount2()) / 1000.0;
        rowData[1]=String.valueOf(d1);
        rowData[2]=String.valueOf(d2);
        rowData[3]=rd.getDiff();
        rows.add(rowData);
      }
    }
    setTabularData(leastPerformanceTable,columns,rows,null);
    panel=leastPerformancePanel;
    break;
  }
case TopErrors:
{
  String count=ConsoleUtil.constants.count();
  String[] columns={ConsoleUtil.constants.errors(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
  List<String[]> rows=new ArrayList<String[]>();
  if (data != null) {
    for (int i=0; i < data.getReturnData().size(); i++) {
      MetricGroupData rd=data.getReturnData().get(i);
      String[] rowData=new String[4];
      rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
      rowData[1]=rd.getCount1();
      rowData[2]=rd.getCount2();
      rowData[3]=rd.getDiff();
      rows.add(rowData);
    }
  }
  setTabularData(topErrorsTable,columns,rows,null);
  panel=topErrorsPanel;
  break;
}
case ConsumerTraffic:
{
String count=ConsoleUtil.constants.count();
String[] columns={ConsoleUtil.constants.consumers(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<String[]> rows=new ArrayList<String[]>();
if (data != null) {
  for (int i=0; i < data.getReturnData().size(); i++) {
    MetricGroupData rd=data.getReturnData().get(i);
    String[] rowData=new String[4];
    rowData[0]=ConsoleUtil.convertConsumerFromMissing(rd.getCriteriaInfo().getConsumerName());
    rowData[1]=rd.getCount1();
    rowData[2]=rd.getCount2();
    rowData[3]=rd.getDiff();
    rows.add(rowData);
  }
}
setTabularData(consumerTrafficTable,columns,rows,new String[]{""String_Node_Str"",null,null});
panel=consumerTrafficPanel;
break;
}
case ConsumerErrors:
{
String count=ConsoleUtil.constants.count();
String[] columns={ConsoleUtil.constants.consumers(),(data == null ? count : date1Header + ""String_Node_Str"" + count),(data == null ? count : date2Header + ""String_Node_Str"" + count),""String_Node_Str"" + ConsoleUtil.constants.change()};
List<String[]> rows=new ArrayList<String[]>();
if (data != null) {
for (int i=0; i < data.getReturnData().size(); i++) {
  MetricGroupData rd=data.getReturnData().get(i);
  String[] rowData=new String[4];
  rowData[0]=getEntityName(metric,data.getMetricResourceCriteria().resourceEntityResponseType,rd);
  rowData[1]=rd.getCount1();
  rowData[2]=rd.getCount2();
  rowData[3]=rd.getDiff();
  rows.add(rowData);
}
}
setTabularData(consumerErrorsTable,columns,rows,new String[]{""String_Node_Str"",null,null});
panel=consumerErrorsPanel;
break;
}
}
if (data != null && data.getReturnData() != null && panel != null) {
int rows=data.getReturnData().size() + 1;
double height=0;
if (rows > 10) height=10 * 2.5;
 else height=rows * 2.5;
panel.setContentContainerHeight(String.valueOf(height) + ""String_Node_Str"");
}
if (panel != null) {
if (data != null) panel.setInfo(data.getRestUrl());
show(panel);
}
}"
18598,"public void getErrorTrend(final ErrorCriteria ec,final MetricCriteria firstDate,final MetricCriteria secondDate,final AsyncCallback<List<ErrorTimeSlotData>> callback);","/** 
 * Gets the error trend.
 * @param ec the ec
 * @param firstDate the first date
 * @param secondDate the second date
 * @param callback the callback
 * @return the error trend
 */
public void getErrorTrend(final ErrorCriteria ec,final MetricCriteria firstDate,final MetricCriteria secondDate,final AsyncCallback<List<ErrorTimeSlotData>> callback);"
18599,"/** 
 * Gets the error detail.
 * @param errorId the error id
 * @param errorName the error name
 * @param service the service
 * @param callback the callback
 * @return the error detail
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorDetail(java.lang.String,java.lang.String,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getErrorDetail(final String errorId,final String errorName,final String service,final AsyncCallback<ErrorDetail> callback){
  final String url=URL.encode(ErrorMetricsMetadataRequest.getRestURL(errorId,errorName,service));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          callback.onFailure(new Throwable(""String_Node_Str"" + response.getStatusCode()));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
        }
 else {
          ErrorMetricsMetadataResponse metricsResponse=ErrorMetricsMetadataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            ErrorDetailJS js=metricsResponse.getReturnData();
            if (js == null)             callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else             callback.onSuccess(js);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}","/** 
 * Gets the error detail.
 * @param errorId the error id
 * @param errorName the error name
 * @param service the service
 * @param callback the callback
 * @return the error detail
 * @see org.ebayopensource.turmeric.monitoring.client.model.MetricsQueryService#getErrorDetail(java.lang.String,java.lang.String,com.google.gwt.user.client.rpc.AsyncCallback)
 */
public void getErrorDetail(final String errorId,final String errorName,final String service,final AsyncCallback<ErrorDetail> callback){
  final String url=URL.encode(ErrorMetricsMetadataRequest.getRestURL(errorId,errorName,service));
  RequestBuilder builder=new RequestBuilder(RequestBuilder.GET,url);
  try {
    builder.sendRequest(null,new RequestCallback(){
      public void onError(      Request request,      Throwable err){
        errorLogger.log(Level.SEVERE,""String_Node_Str"",err);
        callback.onFailure(err);
      }
      public void onResponseReceived(      Request request,      Response response){
        if (response.getStatusCode() != Response.SC_OK) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(new Throwable(""String_Node_Str"" + response.getStatusCode()));
        }
 else         if (response.getHeader(ERROR_HEADER) != null) {
          errorLogger.log(Level.SEVERE,""String_Node_Str"" + url + ""String_Node_Str""+ response.getStatusCode()+ ""String_Node_Str""+ response.getText());
          callback.onFailure(new Throwable(ConsoleUtil.messages.badRequestData()));
        }
 else {
          ErrorMetricsMetadataResponse metricsResponse=ErrorMetricsMetadataResponse.fromJSON(response.getText());
          if (metricsResponse == null) {
            callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
          }
 else {
            ErrorDetailJS js=metricsResponse.getReturnData();
            if (js == null)             callback.onFailure(new Throwable(ConsoleUtil.messages.badOrMissingResponseData()));
 else             callback.onSuccess(js);
          }
        }
      }
    }
);
  }
 catch (  RequestException x) {
    errorLogger.log(Level.SEVERE,""String_Node_Str"",x);
    callback.onFailure(x);
  }
}"
18600,"/** 
 * Sets the consumer performance trend data.
 * @param dataRanges the new consumer performance trend data
 */
public void setConsumerPerformanceTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTile);","/** 
 * Sets the consumer performance trend data.
 * @param dataRanges the new consumer performance trend data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTile the graph tile
 */
public void setConsumerPerformanceTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTile);"
18601,"/** 
 * Sets the consumer call trend data.
 * @param graphData the new consumer call trend data
 */
void setConsumerCallTrendData(List<TimeSlotData> graphData,long aggregationPeriod,int hourSpan,String graphTile);","/** 
 * Sets the consumer call trend data.
 * @param graphData the new consumer call trend data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTile the graph tile
 */
void setConsumerCallTrendData(List<TimeSlotData> graphData,long aggregationPeriod,int hourSpan,String graphTile);"
18602,"/** 
 * Sets the consumer error count trend data.
 * @param graphData the graph data
 * @param graphTitle the graph title
 */
public void setConsumerErrorCountTrendData(Map<String,List<TimeSlotData>> graphData,long aggregationPeriod,int hourSpan,String graphTitle);","/** 
 * Sets the consumer error count trend data.
 * @param graphData the graph data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setConsumerErrorCountTrendData(Map<String,List<TimeSlotData>> graphData,long aggregationPeriod,int hourSpan,String graphTitle);"
18603,"/** 
 * Sets the consumer error trend data.
 * @param dataRanges the new consumer error trend data
 */
public void setConsumerErrorTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTile);","/** 
 * Sets the consumer error trend data.
 * @param dataRanges the new consumer error trend data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTile the graph tile
 */
public void setConsumerErrorTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTile);"
18604,"/** 
 * Sets the consumer service call trend data.
 * @param graphData the graph data
 * @param graphTitle the graph title
 */
public void setConsumerServiceCallTrendData(Map<String,List<TimeSlotData>> graphData,long aggregationPeriod,int hourSpan,String graphTitle);","/** 
 * Sets the consumer service call trend data.
 * @param graphData the graph data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setConsumerServiceCallTrendData(Map<String,List<TimeSlotData>> graphData,long aggregationPeriod,int hourSpan,String graphTitle);"
18605,"/** 
 * Sets the consumer service performance trend data.
 * @param graphData the graph data
 * @param graphTitle the graph title
 */
public void setConsumerServicePerformanceTrendData(Map<String,List<TimeSlotData>> graphData,long aggregationPeriod,int hourSpan,String graphTitle);","/** 
 * Sets the consumer service performance trend data.
 * @param graphData the graph data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setConsumerServicePerformanceTrendData(Map<String,List<TimeSlotData>> graphData,long aggregationPeriod,int hourSpan,String graphTitle);"
18606,"public void setServiceRequestErrorTrendData(List<ErrorTimeSlotData> dataRanges,String graphTitle);","/** 
 * Sets the service request error trend data.
 * @param dataRanges the data ranges
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setServiceRequestErrorTrendData(List<ErrorTimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);"
18607,"public void setServiceSystemErrorTrendData(List<ErrorTimeSlotData> dataRanges,String graphTitle);","/** 
 * Sets the service system error trend data.
 * @param dataRanges the data ranges
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setServiceSystemErrorTrendData(List<ErrorTimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);"
18608,"public void setServiceApplicationErrorTrendData(List<ErrorTimeSlotData> dataRanges,String graphTitle);","/** 
 * Sets the service application error trend data.
 * @param dataRanges the data ranges
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setServiceApplicationErrorTrendData(List<ErrorTimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);"
18609,"private void getServiceRequestErrorTrend(SelectionContext selectionContext2,long date1,long date2,final int durationHrs){
  AsyncCallback<List<ErrorTimeSlotData>> callback=new AsyncCallback<List<ErrorTimeSlotData>>(){
    @Override public void onSuccess(    List<ErrorTimeSlotData> dataRanges){
      String serviceOpName=selectionContext.getSelection(ObjectType.ServiceName);
      if (selectionContext.getSelection(ObjectType.OperationName) != null) {
        serviceOpName+=""String_Node_Str"" + selectionContext.getSelection(ObjectType.OperationName);
      }
      String graphTitle=ConsoleUtil.messages.graphTitle(""String_Node_Str"",serviceOpName,durationHrs);
      ErrorPresenter.this.view.activate();
      ErrorPresenter.this.view.setServiceRequestErrorTrendData(dataRanges,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
;
  this.getSimpleErrorGraphData(ErrorType.Category,ErrorCategory.Request,null,""String_Node_Str"",minAggregationPeriod,selectionContext,date1,date2,durationHrs,callback);
}","private void getServiceRequestErrorTrend(SelectionContext selectionContext2,long date1,long date2,final int durationHrs){
  AsyncCallback<List<ErrorTimeSlotData>> callback=new AsyncCallback<List<ErrorTimeSlotData>>(){
    @Override public void onSuccess(    List<ErrorTimeSlotData> dataRanges){
      String serviceOpName=selectionContext.getSelection(ObjectType.ServiceName);
      if (selectionContext.getSelection(ObjectType.OperationName) != null) {
        serviceOpName+=""String_Node_Str"" + selectionContext.getSelection(ObjectType.OperationName);
      }
      String graphTitle=ConsoleUtil.messages.graphTitle(""String_Node_Str"",serviceOpName,durationHrs);
      ErrorPresenter.this.view.activate();
      ErrorPresenter.this.view.setServiceRequestErrorTrendData(dataRanges,minAggregationPeriod,durationHrs,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
;
  this.getSimpleErrorGraphData(ErrorType.Category,ErrorCategory.Request,null,""String_Node_Str"",minAggregationPeriod,selectionContext,date1,date2,durationHrs,callback);
}"
18610,"private void getServiceSystemErrorTrend(final SelectionContext selectionContext2,final long date1,final long date2,final int durationHrs){
  AsyncCallback<List<ErrorTimeSlotData>> callback=new AsyncCallback<List<ErrorTimeSlotData>>(){
    @Override public void onSuccess(    List<ErrorTimeSlotData> dataRanges){
      String serviceOpName=selectionContext.getSelection(ObjectType.ServiceName);
      if (selectionContext.getSelection(ObjectType.OperationName) != null) {
        serviceOpName+=""String_Node_Str"" + selectionContext.getSelection(ObjectType.OperationName);
      }
      String graphTitle=ConsoleUtil.messages.graphTitle(""String_Node_Str"",serviceOpName,durationHrs);
      ErrorPresenter.this.view.activate();
      ErrorPresenter.this.view.setServiceSystemErrorTrendData(dataRanges,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
;
  this.getSimpleErrorGraphData(ErrorType.Category,ErrorCategory.System,null,""String_Node_Str"",minAggregationPeriod,selectionContext,date1,date2,durationHrs,callback);
}","private void getServiceSystemErrorTrend(final SelectionContext selectionContext2,final long date1,final long date2,final int durationHrs){
  AsyncCallback<List<ErrorTimeSlotData>> callback=new AsyncCallback<List<ErrorTimeSlotData>>(){
    @Override public void onSuccess(    List<ErrorTimeSlotData> dataRanges){
      String serviceOpName=selectionContext.getSelection(ObjectType.ServiceName);
      if (selectionContext.getSelection(ObjectType.OperationName) != null) {
        serviceOpName+=""String_Node_Str"" + selectionContext.getSelection(ObjectType.OperationName);
      }
      String graphTitle=ConsoleUtil.messages.graphTitle(""String_Node_Str"",serviceOpName,durationHrs);
      ErrorPresenter.this.view.activate();
      ErrorPresenter.this.view.setServiceSystemErrorTrendData(dataRanges,minAggregationPeriod,durationHrs,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
;
  this.getSimpleErrorGraphData(ErrorType.Category,ErrorCategory.System,null,""String_Node_Str"",minAggregationPeriod,selectionContext,date1,date2,durationHrs,callback);
}"
18611,"private void getServiceApplicationErrorTrend(SelectionContext selectionContext2,long date1,long date2,final int durationHrs){
  AsyncCallback<List<ErrorTimeSlotData>> callback=new AsyncCallback<List<ErrorTimeSlotData>>(){
    @Override public void onSuccess(    List<ErrorTimeSlotData> dataRanges){
      String serviceOpName=selectionContext.getSelection(ObjectType.ServiceName);
      if (selectionContext.getSelection(ObjectType.OperationName) != null) {
        serviceOpName+=""String_Node_Str"" + selectionContext.getSelection(ObjectType.OperationName);
      }
      String graphTitle=ConsoleUtil.messages.graphTitle(""String_Node_Str"",serviceOpName,durationHrs);
      ErrorPresenter.this.view.activate();
      ErrorPresenter.this.view.setServiceApplicationErrorTrendData(dataRanges,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
;
  this.getSimpleErrorGraphData(ErrorType.Category,ErrorCategory.Application,null,""String_Node_Str"",minAggregationPeriod,selectionContext,date1,date2,durationHrs,callback);
}","private void getServiceApplicationErrorTrend(SelectionContext selectionContext2,long date1,long date2,final int durationHrs){
  AsyncCallback<List<ErrorTimeSlotData>> callback=new AsyncCallback<List<ErrorTimeSlotData>>(){
    @Override public void onSuccess(    List<ErrorTimeSlotData> dataRanges){
      String serviceOpName=selectionContext.getSelection(ObjectType.ServiceName);
      if (selectionContext.getSelection(ObjectType.OperationName) != null) {
        serviceOpName+=""String_Node_Str"" + selectionContext.getSelection(ObjectType.OperationName);
      }
      String graphTitle=ConsoleUtil.messages.graphTitle(""String_Node_Str"",serviceOpName,durationHrs);
      ErrorPresenter.this.view.activate();
      ErrorPresenter.this.view.setServiceApplicationErrorTrendData(dataRanges,minAggregationPeriod,durationHrs,graphTitle);
    }
    @Override public void onFailure(    Throwable exception){
      GWT.log(exception.getMessage());
    }
  }
;
  this.getSimpleErrorGraphData(ErrorType.Category,ErrorCategory.Application,null,""String_Node_Str"",minAggregationPeriod,selectionContext,date1,date2,durationHrs,callback);
}"
18612,"/** 
 * Sets the service error trend data.
 * @param dataRanges the new service error trend data
 */
public void setServiceErrorTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);","/** 
 * Sets the service error trend data.
 * @param dataRanges the new service error trend data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setServiceErrorTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);"
18613,"/** 
 * Sets the service call trend data.
 * @param dataRanges the new service call trend data
 */
public void setServiceCallTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);","/** 
 * Sets the service call trend data.
 * @param dataRanges the new service call trend data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setServiceCallTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);"
18614,public HasWidgets getErrorWidget();,"/** 
 * Gets the error widget.
 * @return the error widget
 */
public HasWidgets getErrorWidget();"
18615,"/** 
 * Sets the service performance trend data.
 * @param dataRanges the new service performance trend data
 */
public void setServicePerformanceTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);","/** 
 * Sets the service performance trend data.
 * @param dataRanges the new service performance trend data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public void setServicePerformanceTrendData(List<TimeSlotData> dataRanges,long aggregationPeriod,int hourSpan,String graphTitle);"
18616,"public static void getSimpleErrorGraphData(MetricsQueryService queryService,ErrorType errorType,ErrorCategory errorCategory,ErrorSeverity severity,String roleType,long aggregationPeriod,final SelectionContext selectionContext,long date1,long date2,final int hourSpan,AsyncCallback<List<ErrorTimeSlotData>> callback){
  String serviceName=selectionContext.getSelection(ObjectType.ServiceName);
  String operationName=selectionContext.getSelection(ObjectType.OperationName);
  String consumerName=selectionContext.getSelection(ObjectType.ConsumerName);
  List<String> serviceNames=null;
  List<String> consumerNames=null;
  List<String> operationNames=null;
  if (serviceName != null) {
    serviceNames=Arrays.asList(serviceName);
  }
  if (consumerName != null) {
    consumerNames=Arrays.asList(consumerName);
  }
  if (operationName != null) {
    operationNames=Arrays.asList(operationName);
  }
  ErrorCriteria ec=ErrorCriteria.newErrorCriteria(errorType,serviceNames,operationNames,consumerNames,null,false,errorCategory,severity);
  MetricCriteria firstDate=new MetricCriteria(""String_Node_Str"",date1,hourSpan,(int)aggregationPeriod);
  MetricCriteria secondDate=new MetricCriteria(""String_Node_Str"",date2,hourSpan,(int)aggregationPeriod);
  queryService.getErrorTrend(ec,firstDate,secondDate,callback);
}","/** 
 * Gets the simple error graph data.
 * @param queryService the query service
 * @param errorType the error type
 * @param errorCategory the error category
 * @param severity the severity
 * @param roleType the role type
 * @param aggregationPeriod the aggregation period
 * @param selectionContext the selection context
 * @param date1 the date1
 * @param date2 the date2
 * @param hourSpan the hour span
 * @param callback the callback
 * @return the simple error graph data
 */
public static void getSimpleErrorGraphData(MetricsQueryService queryService,ErrorType errorType,ErrorCategory errorCategory,ErrorSeverity severity,String roleType,long aggregationPeriod,final SelectionContext selectionContext,long date1,long date2,final int hourSpan,AsyncCallback<List<ErrorTimeSlotData>> callback){
  String serviceName=selectionContext.getSelection(ObjectType.ServiceName);
  String operationName=selectionContext.getSelection(ObjectType.OperationName);
  String consumerName=selectionContext.getSelection(ObjectType.ConsumerName);
  List<String> serviceNames=null;
  List<String> consumerNames=null;
  List<String> operationNames=null;
  if (serviceName != null) {
    serviceNames=Arrays.asList(serviceName);
  }
  if (consumerName != null) {
    consumerNames=Arrays.asList(consumerName);
  }
  if (operationName != null) {
    operationNames=Arrays.asList(operationName);
  }
  ErrorCriteria ec=ErrorCriteria.newErrorCriteria(errorType,serviceNames,operationNames,consumerNames,null,false,errorCategory,severity);
  MetricCriteria firstDate=new MetricCriteria(""String_Node_Str"",date1,hourSpan,(int)aggregationPeriod);
  MetricCriteria secondDate=new MetricCriteria(""String_Node_Str"",date2,hourSpan,(int)aggregationPeriod);
  queryService.getErrorTrend(ec,firstDate,secondDate,callback);
}"
18617,"public static void createLineChart(final SummaryPanel panel,final List<TimeSlotData> timeData,final long aggregationPeriod,final int hourSpan,final String graphTitle){
  Runnable onLoadCallback=new Runnable(){
    public void run(){
      final LineChart lineChart=new LineChart(createChartDataTable(timeData,aggregationPeriod,hourSpan),createOptions(graphTitle));
      panel.addChart(lineChart);
    }
  }
;
  VisualizationUtils.loadVisualizationApi(onLoadCallback,""String_Node_Str"");
}","/** 
 * Creates the line chart.
 * @param panel the panel
 * @param timeData the time data
 * @param aggregationPeriod the aggregation period
 * @param hourSpan the hour span
 * @param graphTitle the graph title
 */
public static void createLineChart(final SummaryPanel panel,final List<? extends TimeSlotData> timeData,final long aggregationPeriod,final int hourSpan,final String graphTitle){
  Runnable onLoadCallback=new Runnable(){
    public void run(){
      final LineChart lineChart=new LineChart(createChartDataTable(timeData,aggregationPeriod,hourSpan),createOptions(graphTitle));
      panel.addChart(lineChart);
    }
  }
;
  VisualizationUtils.loadVisualizationApi(onLoadCallback,""String_Node_Str"");
}"
18618,"private static AbstractDataTable createChartDataTable(List<TimeSlotData> timeDataRange,long aggregationPeriod,int hourSpan){
  int plotPointsPerHour=1;
  if (aggregationPeriod < 3600) {
    plotPointsPerHour=(int)(3600 / aggregationPeriod);
  }
  DataTable data=DataTable.create();
  TimeSlotData firstDateRange=timeDataRange.get(0);
  TimeSlotData secondDateRange=timeDataRange.get(1);
  if (firstDateRange.getReturnData() != null && secondDateRange.getReturnData() != null) {
    int rowSize=hourSpan;
    double[] firstDateRangeArray=calculatePlotPointsPerTimeUnit(firstDateRange.getReturnData(),plotPointsPerHour,hourSpan);
    double[] secondDateRangeArray=calculatePlotPointsPerTimeUnit(secondDateRange.getReturnData(),plotPointsPerHour,hourSpan);
    String[] labelArray=calculateDateTimeLabelPerTimeUnit(firstDateRange.getReturnData(),plotPointsPerHour,hourSpan);
    if (rowSize > 0) {
      data.addColumn(ColumnType.STRING,""String_Node_Str"");
      data.addColumn(ColumnType.NUMBER,ConsoleUtil.shotTimeFormat.format(new Date(firstDateRange.getReturnData().get(0).getTimeSlot())));
      data.addColumn(ColumnType.NUMBER,ConsoleUtil.shotTimeFormat.format(new Date(secondDateRange.getReturnData().get(0).getTimeSlot())));
      data.addRows(rowSize);
      for (int i=0; i < rowSize; i++) {
        data.setValue(i,0,labelArray[i]);
        data.setValue(i,1,firstDateRangeArray[i]);
        data.setValue(i,2,secondDateRangeArray[i]);
      }
    }
 else {
      data.addColumn(ColumnType.STRING,""String_Node_Str"");
      data.addColumn(ColumnType.NUMBER,""String_Node_Str"");
      data.addColumn(ColumnType.NUMBER,""String_Node_Str"");
      data.addRows(rowSize);
    }
  }
  return data;
}","private static AbstractDataTable createChartDataTable(List<? extends TimeSlotData> timeDataRange,long aggregationPeriod,int hourSpan){
  int plotPointsPerHour=1;
  if (aggregationPeriod < 3600) {
    plotPointsPerHour=(int)(3600 / aggregationPeriod);
  }
  DataTable data=DataTable.create();
  TimeSlotData firstDateRange=timeDataRange.get(0);
  TimeSlotData secondDateRange=timeDataRange.get(1);
  if (firstDateRange.getReturnData() != null && secondDateRange.getReturnData() != null) {
    int rowSize=hourSpan;
    double[] firstDateRangeArray=calculatePlotPointsPerTimeUnit(firstDateRange.getReturnData(),plotPointsPerHour,hourSpan);
    double[] secondDateRangeArray=calculatePlotPointsPerTimeUnit(secondDateRange.getReturnData(),plotPointsPerHour,hourSpan);
    String[] labelArray=calculateDateTimeLabelPerTimeUnit(firstDateRange.getReturnData(),plotPointsPerHour,hourSpan);
    if (rowSize > 0) {
      data.addColumn(ColumnType.STRING,""String_Node_Str"");
      data.addColumn(ColumnType.NUMBER,ConsoleUtil.shotTimeFormat.format(new Date(firstDateRange.getReturnData().get(0).getTimeSlot())));
      data.addColumn(ColumnType.NUMBER,ConsoleUtil.shotTimeFormat.format(new Date(secondDateRange.getReturnData().get(0).getTimeSlot())));
      data.addRows(rowSize);
      for (int i=0; i < rowSize; i++) {
        data.setValue(i,0,labelArray[i]);
        data.setValue(i,1,firstDateRangeArray[i]);
        data.setValue(i,2,secondDateRangeArray[i]);
      }
    }
 else {
      data.addColumn(ColumnType.STRING,""String_Node_Str"");
      data.addColumn(ColumnType.NUMBER,""String_Node_Str"");
      data.addColumn(ColumnType.NUMBER,""String_Node_Str"");
      data.addRows(rowSize);
    }
  }
  return data;
}"
18619,"public static void getSimpleGraphData(MetricsQueryService queryService,String metricName,String roleType,long aggregationPeriod,final SelectionContext selectionContext,long date1,long date2,final int hourSpan,AsyncCallback<List<TimeSlotData>> callback){
  long hourToSecondsMultiplier=3600;
  CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
  criteriaInfo.setMetricName(metricName);
  criteriaInfo.setServiceName(selectionContext.getSelection(ObjectType.ServiceName));
  if (selectionContext.getSelection(ObjectType.OperationName) != null) {
    criteriaInfo.setOperationName(selectionContext.getSelection(ObjectType.OperationName));
  }
  criteriaInfo.setRoleType(roleType);
  if (aggregationPeriod >= 3600) {
    hourToSecondsMultiplier=aggregationPeriod;
  }
  queryService.getMetricValueTrend(new MetricValue(criteriaInfo,date1,hourToSecondsMultiplier * hourSpan,(int)aggregationPeriod,""String_Node_Str""),new MetricValue(criteriaInfo,date2,hourToSecondsMultiplier * hourSpan,(int)aggregationPeriod,""String_Node_Str""),callback);
}","/** 
 * Gets the simple graph data.
 * @param queryService the query service
 * @param metricName the metric name
 * @param roleType the role type
 * @param aggregationPeriod the aggregation period
 * @param selectionContext the selection context
 * @param date1 the date1
 * @param date2 the date2
 * @param hourSpan the hour span
 * @param callback the callback
 * @return the simple graph data
 */
public static void getSimpleGraphData(MetricsQueryService queryService,String metricName,String roleType,long aggregationPeriod,final SelectionContext selectionContext,long date1,long date2,final int hourSpan,AsyncCallback<List<TimeSlotData>> callback){
  long hourToSecondsMultiplier=3600;
  CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
  criteriaInfo.setMetricName(metricName);
  criteriaInfo.setServiceName(selectionContext.getSelection(ObjectType.ServiceName));
  if (selectionContext.getSelection(ObjectType.OperationName) != null) {
    criteriaInfo.setOperationName(selectionContext.getSelection(ObjectType.OperationName));
  }
  criteriaInfo.setRoleType(roleType);
  if (aggregationPeriod >= 3600) {
    hourToSecondsMultiplier=aggregationPeriod;
  }
  queryService.getMetricValueTrend(new MetricValue(criteriaInfo,date1,hourToSecondsMultiplier * hourSpan,(int)aggregationPeriod,""String_Node_Str""),new MetricValue(criteriaInfo,date2,hourToSecondsMultiplier * hourSpan,(int)aggregationPeriod,""String_Node_Str""),callback);
}"
18620,"public void onError(Request request,Throwable err){
  GWT.log(""String_Node_Str"",err);
}","public void onError(Request request,Throwable err){
  GWT.log(""String_Node_Str"",err);
  callback.onFailure(err);
}"
18621,"public void onResponseReceived(Request request,Response response){
  if (response.getStatusCode() != Response.SC_OK) {
    GWT.log(""String_Node_Str"" + response.getStatusCode());
  }
 else   if (response.getHeader(ERROR_HEADER) != null) {
    GWT.log(""String_Node_Str"" + response.getHeadersAsString());
  }
 else {
    GWT.log(response.getText());
    MetricValueResponse graphResponse=MetricValueResponse.fromJSON(response.getText());
    if (graphResponse == null) {
      GWT.log(""String_Node_Str"");
    }
 else {
      JsArray<MetricGraphDataJS> rows=graphResponse.getReturnData();
      List<TimeSlotValue> results=new ArrayList<TimeSlotValue>();
      if (rows != null) {
        for (int i=0; i < rows.length(); i++) {
          MetricGraphDataJS js=rows.get(i);
          results.add(js);
        }
      }
      data.setReturnData(results);
    }
  }
}","public void onResponseReceived(Request request,Response response){
  if (response.getStatusCode() != Response.SC_OK) {
    GWT.log(""String_Node_Str"" + response.getStatusCode());
    callback.onFailure(new RequestException(""String_Node_Str"" + response.getStatusCode()));
  }
 else   if (response.getHeader(ERROR_HEADER) != null) {
    GWT.log(""String_Node_Str"" + response.getHeadersAsString());
    callback.onFailure(new RequestException(""String_Node_Str"" + response.getHeadersAsString()));
  }
 else {
    MetricValueResponse graphResponse=MetricValueResponse.fromJSON(response.getText());
    if (graphResponse == null) {
      GWT.log(""String_Node_Str"");
    }
 else {
      JsArray<MetricGraphDataJS> rows=graphResponse.getReturnData();
      List<TimeSlotValue> results=new ArrayList<TimeSlotValue>();
      if (rows != null) {
        for (int i=0; i < rows.length(); i++) {
          MetricGraphDataJS js=rows.get(i);
          results.add(js);
        }
      }
      data.getReturnData().addAll(results);
      GWT.log(""String_Node_Str"" + data.getReturnData().size());
      callback.onSuccess(data);
    }
  }
}"
18622,"@Override public void getServiceCallTrend(MetricValue firstDate,MetricValue secondDate,final AsyncCallback<List<TimeSlotData>> callback){
  try {
    TimeSlotData firstDateRange=this.getServiceCallTrend(firstDate);
    TimeSlotData secondDateRange=this.getServiceCallTrend(secondDate);
    List<TimeSlotData> results=new ArrayList<TimeSlotData>();
    results.add(firstDateRange);
    results.add(secondDateRange);
    if (firstDateRange != null && secondDate != null) {
      callback.onSuccess(results);
    }
 else {
      callback.onFailure(new Exception(""String_Node_Str""));
    }
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}","@Override public void getServiceCallTrend(MetricValue firstDate,final MetricValue secondDate,final AsyncCallback<List<TimeSlotData>> callback){
  try {
    final TimeSlotData firstDateRange=new TimeSlotData();
    final TimeSlotData secondDateRange=new TimeSlotData();
    this.getServiceCallTrendForDate(firstDate,new AsyncCallback<TimeSlotData>(){
      @Override public void onFailure(      Throwable arg0){
        Window.alert(""String_Node_Str"" + arg0.getMessage());
      }
      @Override public void onSuccess(      TimeSlotData arg0){
        firstDateRange.setReturnData(arg0.getReturnData());
        try {
          getServiceCallTrendForDate(secondDate,new AsyncCallback<TimeSlotData>(){
            @Override public void onFailure(            Throwable arg0){
              Window.alert(""String_Node_Str"" + arg0.getMessage());
            }
            @Override public void onSuccess(            TimeSlotData arg0){
              secondDateRange.setReturnData(arg0.getReturnData());
              List<TimeSlotData> results=new ArrayList<TimeSlotData>();
              results.add(firstDateRange);
              results.add(secondDateRange);
              if (firstDateRange != null && secondDateRange != null) {
                callback.onSuccess(results);
              }
 else {
                callback.onFailure(new Exception(""String_Node_Str""));
              }
            }
          }
);
        }
 catch (        RequestException e) {
          e.printStackTrace();
        }
      }
    }
);
  }
 catch (  RequestException x) {
    callback.onFailure(x);
  }
}"
18623,"/** 
 * Get a number of metrics from the server.
 * @param metrics
 * @param service
 * @param operation
 * @param date1
 * @param date2
 * @param intervalHrs
 */
protected void fetchMetrics(List<ServiceMetric> metrics,SelectionContext selectionContext,long date1,long date2,int intervalHrs){
  Entity returnType=null;
  for (  ServiceMetric m : metrics) {
switch (m) {
case TopVolume:
{
        returnType=Entity.Operation;
        break;
      }
case ConsumerTraffic:
{
      returnType=Entity.Consumer;
      break;
    }
case LeastPerformance:
{
    returnType=Entity.Operation;
    break;
  }
case TopErrors:
{
  returnType=Entity.Error;
  break;
}
case ConsumerErrors:
{
returnType=Entity.Consumer;
break;
}
}
fetchMetric(m,selectionContext,returnType,date1,date2,intervalHrs);
}
}","/** 
 * Get a number of metrics from the server.
 * @param metrics
 * @param service
 * @param operation
 * @param date1
 * @param date2
 * @param intervalHrs
 */
protected void fetchMetrics(List<ServiceMetric> metrics,SelectionContext selectionContext,long date1,long date2,int intervalHrs){
  Entity returnType=null;
  for (  ServiceMetric m : metrics) {
switch (m) {
case TopVolume:
{
        returnType=Entity.Operation;
        break;
      }
case ConsumerTraffic:
{
      returnType=Entity.Consumer;
      break;
    }
case LeastPerformance:
{
    returnType=Entity.Operation;
    break;
  }
case TopErrors:
{
  returnType=Entity.Error;
  break;
}
case ConsumerErrors:
{
returnType=Entity.Consumer;
break;
}
}
fetchMetric(m,selectionContext,returnType,date1,date2,intervalHrs);
}
GWT.log(""String_Node_Str"");
CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
criteriaInfo.setMetricName(""String_Node_Str"");
criteriaInfo.setServiceName(""String_Node_Str"");
criteriaInfo.setRoleType(""String_Node_Str"");
Date firstDate=resetTo12am(date1);
Date secondDate=resetTo12am(date2);
queryService.getServiceCallTrend(new MetricValue(criteriaInfo,firstDate.getTime(),3600l * 24,3600,""String_Node_Str""),new MetricValue(criteriaInfo,secondDate.getTime(),3600l * 24,3600,""String_Node_Str""),new AsyncCallback<List<TimeSlotData>>(){
@Override public void onSuccess(List<TimeSlotData> dataRanges){
ServicePresenter.this.view.activate();
ServicePresenter.this.view.setServiceCallTrendData(dataRanges);
}
@Override public void onFailure(Throwable exception){
GWT.log(exception.getMessage());
}
}
);
}"
18624,"/** 
 * Get some metrics numbers from the server.
 * @param m the metric to fetch
 * @param service
 * @param operation
 * @param returnType
 * @param date1
 * @param date2
 * @param intervalHrs
 */
protected void fetchMetric(final ServiceMetric m,final SelectionContext selectionContext,Entity returnType,final long date1,final long date2,final int intervalHrs){
  List<EntityName> subject=new ArrayList<EntityName>();
  if (selectionContext.getSelection(ObjectType.ServiceName) != null) {
    EntityName serviceName=new EntityName();
    serviceName.type=Entity.Service;
    serviceName.add(selectionContext.getSelection(ObjectType.ServiceName));
    subject.add(serviceName);
  }
  if (selectionContext.getSelection(ObjectType.OperationName) != null) {
    EntityName opName=new EntityName();
    opName.type=Entity.Operation;
    opName.add(selectionContext.getSelection(ObjectType.OperationName));
    subject.add(opName);
  }
  MetricCriteria mc=MetricCriteria.newMetricCriteria(m.toMetricName(),date1,date2,intervalHrs,Ordering.Descending,10,Perspective.Server,false);
  MetricResourceCriteria rmc=MetricResourceCriteria.newMetricResourceCriteria(subject,returnType);
  String url=queryService.getMetricDataDownloadUrl(mc,rmc);
  ServicePresenter.this.view.setDownloadUrl(m,url);
  queryService.getMetricData(mc,rmc,new AsyncCallback<MetricData>(){
    public void onFailure(    Throwable error){
      if (!ConsoleUtil.messages.badOrMissingResponseData().equals(error.getMessage()))       ServicePresenter.this.view.error(ConsoleUtil.messages.serverError(error.getLocalizedMessage()));
 else       ServicePresenter.this.view.setMetric(m,null);
    }
    public void onSuccess(    MetricData metric){
      ServicePresenter.this.view.activate();
      ServicePresenter.this.view.setMetric(m,metric);
switch (m) {
case ConsumerErrors:
case ConsumerTraffic:
{
          List<HasClickHandlers> clickHandlers=view.getTableColumn(m,1,0);
          if (clickHandlers != null) {
            for (            HasClickHandlers h : clickHandlers) {
              h.addClickHandler(new ClickHandler(){
                public void onClick(                ClickEvent event){
                  Object o=event.getSource();
                  if (o instanceof HasText) {
                    String consumer=((HasText)o).getText();
                    SelectionContext tmpSelection=new SelectionContext();
                    tmpSelection.selectAll(selectionContext);
                    tmpSelection.select(ObjectType.ConsumerName,consumer);
                    insertHistory(ConsumerPresenter.CONSUMER_ID,tmpSelection,date1,date2,intervalHrs,true);
                  }
                }
              }
);
            }
          }
          break;
        }
    }
  }
}
);
CriteriaInfoImpl criteriaInfo=new CriteriaInfoImpl();
criteriaInfo.setMetricName(""String_Node_Str"");
criteriaInfo.setServiceName(""String_Node_Str"");
criteriaInfo.setRoleType(""String_Node_Str"");
queryService.getServiceCallTrend(new MetricValue(criteriaInfo,date1,2400l,5,""String_Node_Str""),new MetricValue(criteriaInfo,date2,2400l,5,""String_Node_Str""),new AsyncCallback<List<TimeSlotData>>(){
  @Override public void onSuccess(  List<TimeSlotData> dataRanges){
    ServicePresenter.this.view.setServiceCallTrendData(dataRanges);
  }
  @Override public void onFailure(  Throwable exception){
    GWT.log(exception.getMessage());
  }
}
);
}","/** 
 * Get some metrics numbers from the server.
 * @param m the metric to fetch
 * @param service
 * @param operation
 * @param returnType
 * @param date1
 * @param date2
 * @param intervalHrs
 */
protected void fetchMetric(final ServiceMetric m,final SelectionContext selectionContext,Entity returnType,final long date1,final long date2,final int intervalHrs){
  List<EntityName> subject=new ArrayList<EntityName>();
  if (selectionContext.getSelection(ObjectType.ServiceName) != null) {
    EntityName serviceName=new EntityName();
    serviceName.type=Entity.Service;
    serviceName.add(selectionContext.getSelection(ObjectType.ServiceName));
    subject.add(serviceName);
  }
  if (selectionContext.getSelection(ObjectType.OperationName) != null) {
    EntityName opName=new EntityName();
    opName.type=Entity.Operation;
    opName.add(selectionContext.getSelection(ObjectType.OperationName));
    subject.add(opName);
  }
  MetricCriteria mc=MetricCriteria.newMetricCriteria(m.toMetricName(),date1,date2,intervalHrs,Ordering.Descending,10,Perspective.Server,false);
  MetricResourceCriteria rmc=MetricResourceCriteria.newMetricResourceCriteria(subject,returnType);
  String url=queryService.getMetricDataDownloadUrl(mc,rmc);
  ServicePresenter.this.view.setDownloadUrl(m,url);
  queryService.getMetricData(mc,rmc,new AsyncCallback<MetricData>(){
    public void onFailure(    Throwable error){
      if (!ConsoleUtil.messages.badOrMissingResponseData().equals(error.getMessage()))       ServicePresenter.this.view.error(ConsoleUtil.messages.serverError(error.getLocalizedMessage()));
 else       ServicePresenter.this.view.setMetric(m,null);
    }
    public void onSuccess(    MetricData metric){
      ServicePresenter.this.view.activate();
      ServicePresenter.this.view.setMetric(m,metric);
switch (m) {
case ConsumerErrors:
case ConsumerTraffic:
{
          List<HasClickHandlers> clickHandlers=view.getTableColumn(m,1,0);
          if (clickHandlers != null) {
            for (            HasClickHandlers h : clickHandlers) {
              h.addClickHandler(new ClickHandler(){
                public void onClick(                ClickEvent event){
                  Object o=event.getSource();
                  if (o instanceof HasText) {
                    String consumer=((HasText)o).getText();
                    SelectionContext tmpSelection=new SelectionContext();
                    tmpSelection.selectAll(selectionContext);
                    tmpSelection.select(ObjectType.ConsumerName,consumer);
                    insertHistory(ConsumerPresenter.CONSUMER_ID,tmpSelection,date1,date2,intervalHrs,true);
                  }
                }
              }
);
            }
          }
          break;
        }
    }
  }
}
);
}"
18625,"/** 
 * Two union types are equal if they have the same number of alternates and all alternates are equal.
 */
boolean checkUnionEquivalenceHelper(UnionType that,EquivalenceMethod eqMethod){
  if (eqMethod == EquivalenceMethod.IDENTITY && alternates.size() != that.alternates.size()) {
    return false;
  }
  for (  JSType alternate : that.alternates) {
    if (!hasAlternate(alternate,eqMethod)) {
      return false;
    }
  }
  return true;
}","/** 
 * Two union types are equal if, after flattening nested union types, they have the same number of alternates and all alternates are equal.
 */
boolean checkUnionEquivalenceHelper(UnionType that,EquivalenceMethod eqMethod){
  Collection<JSType> thatAlternates=that.getAlternates();
  if (eqMethod == EquivalenceMethod.IDENTITY && getAlternates().size() != thatAlternates.size()) {
    return false;
  }
  for (  JSType alternate : thatAlternates) {
    if (!hasAlternate(alternate,eqMethod)) {
      return false;
    }
  }
  return true;
}"
18626,"private boolean hasAlternate(JSType type,EquivalenceMethod eqMethod){
  for (  JSType alternate : alternates) {
    if (alternate.checkEquivalenceHelper(type,eqMethod)) {
      return true;
    }
  }
  return false;
}","private boolean hasAlternate(JSType type,EquivalenceMethod eqMethod){
  for (  JSType alternate : getAlternates()) {
    if (alternate.checkEquivalenceHelper(type,eqMethod)) {
      return true;
    }
  }
  return false;
}"
18627,"/** 
 * Gets the alternate types of this union type.
 * @return The alternate types of this union type. The returned set isimmutable.
 */
public Iterable<JSType> getAlternates(){
  return alternates;
}","/** 
 * Gets the alternate types of this union type.
 * @return The alternate types of this union type. The returned set isimmutable.
 */
public Collection<JSType> getAlternates(){
  for (  JSType t : alternates) {
    if (t.isUnionType()) {
      rebuildAlternates();
      break;
    }
  }
  return alternates;
}"
18628,"Iterable<JSType> getAlternates(){
  JSType specialCaseType=reduceAlternatesWithoutUnion();
  if (specialCaseType != null) {
    return ImmutableList.of(specialCaseType);
  }
  return Collections.unmodifiableList(alternates);
}","Collection<JSType> getAlternates(){
  JSType specialCaseType=reduceAlternatesWithoutUnion();
  if (specialCaseType != null) {
    return ImmutableList.of(specialCaseType);
  }
  return Collections.unmodifiableList(alternates);
}"
18629,"/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,String[] expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),root != null);
  if (astValidationEnabled) {
    (new AstValidator()).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse(""String_Node_Str"",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator()).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str"",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue(""String_Node_Str"",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue(""String_Node_Str"",-1 != actual.lineNumber);
          assertTrue(""String_Node_Str"",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"",hasCodeChanged);
    }
    if (expected != null) {
      if (compareAsTree) {
        String explanation=expectedRoot.checkTreeEquals(mainRoot);
        assertNull(""String_Node_Str"" + compiler.toSource(expectedRoot) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
      }
 else       if (expected != null) {
        assertEquals(Joiner.on(""String_Node_Str"").join(expected),compiler.toSource(mainRoot));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=root.getFirstChild();
    Node normalizeCheckMainRootClone=root.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    String errors=""String_Node_Str"";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + ""String_Node_Str"";
    }
    assertEquals(""String_Node_Str"" + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualError : compiler.getWarnings()) {
        warnings+=actualError.description + ""String_Node_Str"";
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}","/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,String[] expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  assertTrue(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),root != null);
  if (astValidationEnabled) {
    (new AstValidator()).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=Lists.newArrayList();
  boolean hasCodeChanged=false;
  assertFalse(""String_Node_Str"",recentChange.hasCodeChanged());
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager(compiler);
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,typeCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator()).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      aggregateWarnings.addAll(Lists.newArrayList(compiler.getWarnings()));
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager(compiler);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertEquals(expectedSymbolTableError,stErrors[0].getType());
    }
 else {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str"",numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertEquals(warning,actual.getType());
        if (!allowSourcelessWarnings) {
          assertTrue(""String_Node_Str"",actual.sourceName != null && !actual.sourceName.isEmpty());
          assertTrue(""String_Node_Str"",-1 != actual.lineNumber);
          assertTrue(""String_Node_Str"",-1 != actual.getCharno());
        }
        if (description != null) {
          assertEquals(description,actual.description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"",hasCodeChanged);
    }
    if (expected != null) {
      if (compareAsTree) {
        String explanation=expectedRoot.checkTreeEquals(mainRoot);
        assertNull(""String_Node_Str"" + compiler.toSource(expectedRoot) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
      }
 else       if (expected != null) {
        assertEquals(Joiner.on(""String_Node_Str"").join(expected),compiler.toSource(mainRoot));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    String errors=""String_Node_Str"";
    for (    JSError actualError : compiler.getErrors()) {
      errors+=actualError.description + ""String_Node_Str"";
    }
    assertEquals(""String_Node_Str"" + errors,1,compiler.getErrorCount());
    assertEquals(errors,error,compiler.getErrors()[0].getType());
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualError : compiler.getWarnings()) {
        warnings+=actualError.description + ""String_Node_Str"";
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}"
18630,"@Override protected void setUp() throws Exception {
  super.setUp();
  previouslyUsedMap=new VariableMap(ImmutableMap.<String,String>of());
  prefix=DEFAULT_PREFIX;
  withClosurePass=false;
  localRenamingOnly=false;
  preserveFunctionExpressionNames=false;
  generatePseudoNames=false;
  shouldShadow=false;
}","@Override protected void setUp() throws Exception {
  super.setUp();
  previouslyUsedMap=new VariableMap(ImmutableMap.<String,String>of());
  prefix=DEFAULT_PREFIX;
  withClosurePass=false;
  withNormalize=false;
  localRenamingOnly=false;
  preserveFunctionExpressionNames=false;
  generatePseudoNames=false;
  shouldShadow=false;
}"
18631,"public void testDollarSignSuperExport2(){
  boolean normalizedExpectedJs=false;
  super.enableNormalize(false);
  useGoogleCodingConvention=false;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  localRenamingOnly=false;
  test(""String_Node_Str"",""String_Node_Str"");
  useGoogleCodingConvention=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  super.disableNormalize();
}","public void testDollarSignSuperExport2(){
  withNormalize=true;
  useGoogleCodingConvention=false;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  localRenamingOnly=false;
  test(""String_Node_Str"",""String_Node_Str"");
  useGoogleCodingConvention=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}"
18632,"@Override public void process(Node externs,Node root){
  ProcessClosurePrimitives closurePass=new ProcessClosurePrimitives(compiler,null,CheckLevel.WARNING);
  closurePass.process(externs,root);
  renameVars=new RenameVars(compiler,prefix,false,false,false,false,previouslyUsedMap,null,closurePass.getExportedVariableNames());
  renameVars.process(externs,root);
}","@Override public void process(Node externs,Node root){
  Normalize normalize=new Normalize(compiler,false);
  normalize.process(externs,root);
  wrappedPass.process(externs,root);
}"
18633,"@Override protected CompilerPass getProcessor(Compiler compiler){
  if (withClosurePass) {
    return new ClosurePassAndRenameVars(compiler);
  }
 else {
    return renameVars=new RenameVars(compiler,prefix,localRenamingOnly,preserveFunctionExpressionNames,generatePseudoNames,shouldShadow,previouslyUsedMap,null,null);
  }
}","@Override protected CompilerPass getProcessor(Compiler compiler){
  CompilerPass pass;
  if (withClosurePass) {
    pass=new ClosurePassAndRenameVars(compiler);
  }
 else {
    pass=renameVars=new RenameVars(compiler,prefix,localRenamingOnly,preserveFunctionExpressionNames,generatePseudoNames,shouldShadow,previouslyUsedMap,null,null);
  }
  if (withNormalize) {
    pass=new NormalizePassWrapper(compiler,pass);
  }
  return pass;
}"
18634,"/** 
 * Visits an object literal field definition <code>key : value</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.
 * @param t the traversal
 * @param key the assign node
 */
private void visitObjLitKey(NodeTraversal t,Node key,Node objlit){
  if (objlit.isFromExterns()) {
    ensureTyped(t,key);
    return;
  }
  Node rvalue=key.getFirstChild();
  JSType rightType=NodeUtil.getObjectLitKeyTypeFromValueType(key,getJSType(rvalue));
  if (rightType == null) {
    rightType=getNativeType(UNKNOWN_TYPE);
  }
  Node owner=objlit;
  JSType keyType=getJSType(key);
  JSType allowedValueType=keyType;
  if (allowedValueType.isEnumElementType()) {
    allowedValueType=allowedValueType.toMaybeEnumElementType().getPrimitiveType();
  }
  boolean valid=validator.expectCanAssignToPropertyOf(t,key,rightType,allowedValueType,owner,NodeUtil.getObjectLitKeyName(key));
  if (valid) {
    ensureTyped(t,key,rightType);
  }
 else {
    ensureTyped(t,key);
  }
  JSType objlitType=getJSType(objlit);
  ObjectType type=ObjectType.cast(objlitType.restrictByNotNullOrUndefined());
  if (type != null) {
    String property=NodeUtil.getObjectLitKeyName(key);
    if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type,property)) {
      validator.expectCanAssignToPropertyOf(t,key,keyType,type.getPropertyType(property),owner,property);
    }
    return;
  }
}","/** 
 * Visits an object literal field definition <code>key : value</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.
 * @param t the traversal
 * @param key the assign node
 */
private void visitObjLitKey(NodeTraversal t,Node key,Node objlit,JSType litType){
  if (objlit.isFromExterns()) {
    ensureTyped(t,key);
    return;
  }
  if (litType.isStruct() && key.isQuotedString()) {
    report(t,key,ILLEGAL_OBJLIT_KEY,""String_Node_Str"");
  }
 else   if (litType.isDict() && !key.isQuotedString()) {
    report(t,key,ILLEGAL_OBJLIT_KEY,""String_Node_Str"");
  }
  Node rvalue=key.getFirstChild();
  JSType rightType=NodeUtil.getObjectLitKeyTypeFromValueType(key,getJSType(rvalue));
  if (rightType == null) {
    rightType=getNativeType(UNKNOWN_TYPE);
  }
  Node owner=objlit;
  JSType keyType=getJSType(key);
  JSType allowedValueType=keyType;
  if (allowedValueType.isEnumElementType()) {
    allowedValueType=allowedValueType.toMaybeEnumElementType().getPrimitiveType();
  }
  boolean valid=validator.expectCanAssignToPropertyOf(t,key,rightType,allowedValueType,owner,NodeUtil.getObjectLitKeyName(key));
  if (valid) {
    ensureTyped(t,key,rightType);
  }
 else {
    ensureTyped(t,key);
  }
  JSType objlitType=getJSType(objlit);
  ObjectType type=ObjectType.cast(objlitType.restrictByNotNullOrUndefined());
  if (type != null) {
    String property=NodeUtil.getObjectLitKeyName(key);
    if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type,property)) {
      validator.expectCanAssignToPropertyOf(t,key,keyType,type.getPropertyType(property),owner,property);
    }
    return;
  }
}"
18635,"/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.CAST:
    Node expr=n.getFirstChild();
  ensureTyped(t,n,getJSType(expr));
JSType castType=getJSType(n);
JSType exprType=getJSType(expr);
if (castType.isSubtype(exprType)) {
expr.setJSType(castType);
}
break;
case Token.NAME:
typeable=visitName(t,n,parent);
break;
case Token.PARAM_LIST:
typeable=false;
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.STRING_KEY:
typeable=false;
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
break;
case Token.CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj=n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
}
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
for (Node key : n.children()) {
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}","/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.CAST:
    Node expr=n.getFirstChild();
  ensureTyped(t,n,getJSType(expr));
JSType castType=getJSType(n);
JSType exprType=getJSType(expr);
if (castType.isSubtype(exprType)) {
expr.setJSType(castType);
}
break;
case Token.NAME:
typeable=visitName(t,n,parent);
break;
case Token.PARAM_LIST:
typeable=false;
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.STRING_KEY:
typeable=false;
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
break;
case Token.CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj=n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
}
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
JSType typ=getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t,key,n,typ);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}"
18636,"/** 
 * TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?'
 */
private Node parseTypeExpression(JsDocToken token){
  if (token == JsDocToken.QMARK) {
    token=next();
    if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) {
      restoreLookAhead(token);
      return newNode(Token.QMARK);
    }
    return wrapNode(Token.QMARK,parseBasicTypeExpression(token));
  }
 else   if (token == JsDocToken.BANG) {
    return wrapNode(Token.BANG,parseBasicTypeExpression(next()));
  }
 else {
    Node basicTypeExpr=parseBasicTypeExpression(token);
    if (basicTypeExpr != null) {
      if (match(JsDocToken.QMARK)) {
        next();
        return wrapNode(Token.QMARK,basicTypeExpr);
      }
 else       if (match(JsDocToken.BANG)) {
        next();
        return wrapNode(Token.BANG,basicTypeExpr);
      }
    }
    return basicTypeExpr;
  }
}","/** 
 * TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?'
 */
private Node parseTypeExpression(JsDocToken token){
  if (token == JsDocToken.QMARK) {
    token=next();
    if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE || token == JsDocToken.GT) {
      restoreLookAhead(token);
      return newNode(Token.QMARK);
    }
    return wrapNode(Token.QMARK,parseBasicTypeExpression(token));
  }
 else   if (token == JsDocToken.BANG) {
    return wrapNode(Token.BANG,parseBasicTypeExpression(next()));
  }
 else {
    Node basicTypeExpr=parseBasicTypeExpression(token);
    if (basicTypeExpr != null) {
      if (match(JsDocToken.QMARK)) {
        next();
        return wrapNode(Token.QMARK,basicTypeExpr);
      }
 else       if (match(JsDocToken.BANG)) {
        next();
        return wrapNode(Token.BANG,basicTypeExpr);
      }
    }
    return basicTypeExpr;
  }
}"
18637,"/** 
 * TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' TypeExpressionList := TypeExpression // a white lie
 */
private Node parseTypeName(JsDocToken token){
  if (token != JsDocToken.STRING) {
    return reportGenericTypeSyntaxWarning();
  }
  String typeName=stream.getString();
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') {
    skipEOLs();
    if (match(JsDocToken.STRING)) {
      next();
      typeName+=stream.getString();
    }
  }
  Node typeNameNode=newStringNode(typeName,lineno,charno);
  if (match(JsDocToken.LT)) {
    next();
    skipEOLs();
    Node memberType=parseTypeExpressionList(next());
    if (memberType != null) {
      typeNameNode.addChildToFront(memberType);
      skipEOLs();
      if (!match(JsDocToken.GT)) {
        return reportTypeSyntaxWarning(""String_Node_Str"");
      }
      next();
    }
  }
  return typeNameNode;
}","/** 
 * TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>'
 */
private Node parseTypeName(JsDocToken token){
  if (token != JsDocToken.STRING) {
    return reportGenericTypeSyntaxWarning();
  }
  String typeName=stream.getString();
  int lineno=stream.getLineno();
  int charno=stream.getCharno();
  while (match(JsDocToken.EOL) && typeName.charAt(typeName.length() - 1) == '.') {
    skipEOLs();
    if (match(JsDocToken.STRING)) {
      next();
      typeName+=stream.getString();
    }
  }
  Node typeNameNode=newStringNode(typeName,lineno,charno);
  if (match(JsDocToken.LT)) {
    next();
    skipEOLs();
    Node memberType=parseTypeExpressionList(next());
    if (memberType != null) {
      typeNameNode.addChildToFront(memberType);
      skipEOLs();
      if (!match(JsDocToken.GT)) {
        return reportTypeSyntaxWarning(""String_Node_Str"");
      }
      next();
    }
  }
  return typeNameNode;
}"
18638,"/** 
 * Check whether there's any property conflict for for a particular super interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that havebeen visited
 * @param currentProperties The property names in the super interfacethat have been visited
 * @param interfaceType The super interface that is being visited
 */
private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
  Set<String> currentPropertyNames=interfaceType.getImplicitPrototype().getOwnPropertyNames();
  for (  String name : currentPropertyNames) {
    ObjectType oType=properties.get(name);
    if (oType != null) {
      if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
        compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
      }
    }
    currentProperties.put(name,interfaceType);
  }
  for (  ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
    checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
  }
}","/** 
 * Check whether there's any property conflict for for a particular super interface
 * @param t The node traversal object that supplies context
 * @param n The node being visited
 * @param functionName The function name being checked
 * @param properties The property names in the super interfaces that havebeen visited
 * @param currentProperties The property names in the super interfacethat have been visited
 * @param interfaceType The super interface that is being visited
 */
private void checkInterfaceConflictProperties(NodeTraversal t,Node n,String functionName,HashMap<String,ObjectType> properties,HashMap<String,ObjectType> currentProperties,ObjectType interfaceType){
  ObjectType implicitProto=interfaceType.getImplicitPrototype();
  Set<String> currentPropertyNames;
  if (implicitProto == null) {
    currentPropertyNames=ImmutableSet.of();
  }
 else {
    currentPropertyNames=implicitProto.getOwnPropertyNames();
  }
  for (  String name : currentPropertyNames) {
    ObjectType oType=properties.get(name);
    if (oType != null) {
      if (!interfaceType.getPropertyType(name).isEquivalentTo(oType.getPropertyType(name))) {
        compiler.report(t.makeError(n,INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,functionName,name,oType.toString(),interfaceType.toString()));
      }
    }
    currentProperties.put(name,interfaceType);
  }
  for (  ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {
    checkInterfaceConflictProperties(t,n,functionName,properties,currentProperties,iType);
  }
}"
18639,"boolean isParameterizeSubtypeOf(JSType thatType){
  if (thatType.isParameterizedType()) {
    JSType thisParameter=this.parameterType;
    JSType thatParameter=thatType.toMaybeParameterizedType().parameterType;
    return this.wrapsSameRawType(thatType) && (thisParameter.isSubtype(thatParameter) || thatParameter.isSubtype(thisParameter));
  }
 else {
    return this.getReferencedTypeInternal().isSubtype(thatType);
  }
}","boolean isParameterizeSubtypeOf(JSType thatType){
  if (thatType.isParameterizedType()) {
    JSType thisParameter=this.parameterType;
    JSType thatParameter=thatType.toMaybeParameterizedType().parameterType;
    if (this.wrapsSameRawType(thatType)) {
      return (thisParameter.isSubtype(thatParameter) || thatParameter.isSubtype(thisParameter));
    }
  }
  return this.getReferencedTypeInternal().isSubtype(thatType);
}"
18640,"/** 
 * When computing infima, we may get a situation like inf(Type1, Type2) where both types are unresolved, so they're technically subtypes of one another. If this happens, filter them down to NoResolvedType.
 */
static JSType filterNoResolvedType(JSType type){
  if (type.isNoResolvedType()) {
    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);
  }
 else   if (type.isUnionType()) {
    UnionType unionType=type.toMaybeUnionType();
    boolean needsFiltering=false;
    for (    JSType alt : unionType.getAlternates()) {
      if (alt.isNoResolvedType()) {
        needsFiltering=true;
        break;
      }
    }
    if (needsFiltering) {
      UnionTypeBuilder builder=new UnionTypeBuilder(type.registry);
      for (      JSType alt : unionType.getAlternates()) {
        if (!alt.isNoResolvedType()) {
          builder.addAlternate(alt);
        }
      }
      return builder.build();
    }
  }
  return type;
}","/** 
 * When computing infima, we may get a situation like inf(Type1, Type2) where both types are unresolved, so they're technically subtypes of one another. If this happens, filter them down to NoResolvedType.
 */
static JSType filterNoResolvedType(JSType type){
  if (type.isNoResolvedType()) {
    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);
  }
 else   if (type.isUnionType()) {
    UnionType unionType=type.toMaybeUnionType();
    boolean needsFiltering=false;
    for (    JSType alt : unionType.getAlternates()) {
      if (alt.isNoResolvedType()) {
        needsFiltering=true;
        break;
      }
    }
    if (needsFiltering) {
      UnionTypeBuilder builder=new UnionTypeBuilder(type.registry);
      builder.addAlternate(type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE));
      for (      JSType alt : unionType.getAlternates()) {
        if (!alt.isNoResolvedType()) {
          builder.addAlternate(alt);
        }
      }
      return builder.build();
    }
  }
  return type;
}"
18641,"/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isSubtype(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtype(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}","/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isSubtype(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtype(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}"
18642,"JSType meet(JSType that){
  UnionTypeBuilder builder=new UnionTypeBuilder(registry);
  for (  JSType alternate : alternates) {
    if (alternate.isSubtype(that)) {
      builder.addAlternate(alternate);
    }
  }
  if (that.isUnionType()) {
    for (    JSType otherAlternate : that.toMaybeUnionType().alternates) {
      if (otherAlternate.isSubtype(this)) {
        builder.addAlternate(otherAlternate);
      }
    }
  }
 else   if (that.isSubtype(this)) {
    builder.addAlternate(that);
  }
  JSType result=builder.build();
  if (!result.isNoType()) {
    return result;
  }
 else   if (this.isObject() && that.isObject()) {
    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}","JSType meet(JSType that){
  UnionTypeBuilder builder=new UnionTypeBuilder(registry);
  for (  JSType alternate : alternates) {
    if (alternate.isSubtype(that)) {
      builder.addAlternate(alternate);
    }
  }
  if (that.isUnionType()) {
    for (    JSType otherAlternate : that.toMaybeUnionType().alternates) {
      if (otherAlternate.isSubtype(this)) {
        builder.addAlternate(otherAlternate);
      }
    }
  }
 else   if (that.isSubtype(this)) {
    builder.addAlternate(that);
  }
  JSType result=builder.build();
  if (!result.isNoType()) {
    return result;
  }
 else   if (this.isObject() && (that.isObject() && !that.isNoType())) {
    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}"
18643,"/** 
 * Returns a more restricted union type than   {@code this} one, in which allsubtypes of  {@code type} have been removed.<p>Examples: <ul> <li> {@code (number,string)} restricted by {@code number} is{@code string}</li> <li>  {@code (null, EvalError, URIError)} restricted by{@code Error} is {@code null}</li> </ul>
 * @param type the supertype of the types to remove from this union type
 */
public JSType getRestrictedUnion(JSType type){
  UnionTypeBuilder restricted=new UnionTypeBuilder(registry);
  for (  JSType t : alternates) {
    if (t.isUnknownType() || !t.isSubtype(type)) {
      restricted.addAlternate(t);
    }
  }
  return restricted.build();
}","/** 
 * Returns a more restricted union type than   {@code this} one, in which allsubtypes of  {@code type} have been removed.<p>Examples: <ul> <li> {@code (number,string)} restricted by {@code number} is{@code string}</li> <li>  {@code (null, EvalError, URIError)} restricted by{@code Error} is {@code null}</li> </ul>
 * @param type the supertype of the types to remove from this union type
 */
public JSType getRestrictedUnion(JSType type){
  UnionTypeBuilder restricted=new UnionTypeBuilder(registry);
  for (  JSType t : alternates) {
    if (t.isUnknownType() || t.isNoResolvedType() || !t.isSubtype(type)) {
      restricted.addAlternate(t);
    }
  }
  return restricted.build();
}"
18644,"public void testNamedSubtypeChain() throws Exception {
  List<JSType> typeChain=Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE),registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),registry.getNativeType(JSTypeNative.OBJECT_TYPE),googBar.getPrototype(),googBar.getInstanceType(),googSubBar.getPrototype(),googSubBar.getInstanceType(),googSubSubBar.getPrototype(),googSubSubBar.getInstanceType(),registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),registry.getNativeType(JSTypeNative.NO_RESOLVED_TYPE),registry.getNativeType(JSTypeNative.NO_TYPE));
  verifySubtypeChain(typeChain);
}","public void testNamedSubtypeChain() throws Exception {
  List<JSType> typeChain=Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE),registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),registry.getNativeType(JSTypeNative.OBJECT_TYPE),googBar.getPrototype(),googBar.getInstanceType(),googSubBar.getPrototype(),googSubBar.getInstanceType(),googSubSubBar.getPrototype(),googSubSubBar.getInstanceType(),registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),registry.getNativeType(JSTypeNative.NO_TYPE));
  verifySubtypeChain(typeChain);
}"
18645,"/** 
 * Tests the behavior of the unresolved Bottom type.
 */
public void testNoResolvedType() throws Exception {
  assertFalse(NO_RESOLVED_TYPE.isNoObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNoType());
  assertTrue(NO_RESOLVED_TYPE.isNoResolvedType());
  assertFalse(NO_RESOLVED_TYPE.isArrayType());
  assertFalse(NO_RESOLVED_TYPE.isBooleanValueType());
  assertFalse(NO_RESOLVED_TYPE.isDateType());
  assertFalse(NO_RESOLVED_TYPE.isEnumElementType());
  assertFalse(NO_RESOLVED_TYPE.isNullType());
  assertFalse(NO_RESOLVED_TYPE.isNamedType());
  assertTrue(NO_RESOLVED_TYPE.isNumber());
  assertFalse(NO_RESOLVED_TYPE.isNumberObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNumberValueType());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType());
  assertFalse(NO_RESOLVED_TYPE.isRegexpType());
  assertTrue(NO_RESOLVED_TYPE.isString());
  assertFalse(NO_RESOLVED_TYPE.isStringObjectType());
  assertFalse(NO_RESOLVED_TYPE.isStringValueType());
  assertFalse(NO_RESOLVED_TYPE.isEnumType());
  assertFalse(NO_RESOLVED_TYPE.isUnionType());
  assertFalse(NO_RESOLVED_TYPE.isStruct());
  assertFalse(NO_RESOLVED_TYPE.isDict());
  assertFalse(NO_RESOLVED_TYPE.isAllType());
  assertFalse(NO_RESOLVED_TYPE.isVoidType());
  assertTrue(NO_RESOLVED_TYPE.isConstructor());
  assertFalse(NO_RESOLVED_TYPE.isInstanceType());
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(functionType));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(VOID_TYPE));
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ARRAY_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,DATE_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,EVAL_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,functionType);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NULL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,URI_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,RANGE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REFERENCE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REGEXP_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,SYNTAX_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,TYPE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ALL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,VOID_TYPE);
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isNullable());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertTrue(NO_RESOLVED_TYPE.matchesInt32Context());
  assertTrue(NO_RESOLVED_TYPE.matchesNumberContext());
  assertTrue(NO_RESOLVED_TYPE.matchesObjectContext());
  assertTrue(NO_RESOLVED_TYPE.matchesStringContext());
  assertTrue(NO_RESOLVED_TYPE.matchesUint32Context());
  assertEquals(""String_Node_Str"",NO_RESOLVED_TYPE.toString());
  assertEquals(null,NO_RESOLVED_TYPE.getDisplayName());
  assertFalse(NO_RESOLVED_TYPE.hasDisplayName());
  assertTypeEquals(CHECKED_UNKNOWN_TYPE,NO_RESOLVED_TYPE.getPropertyType(""String_Node_Str""));
  Asserts.assertResolvesToSame(NO_RESOLVED_TYPE);
  assertTrue(forwardDeclaredNamedType.isEmptyType());
  assertTrue(forwardDeclaredNamedType.isNoResolvedType());
}","/** 
 * Tests the behavior of the unresolved Bottom type.
 */
public void testNoResolvedType() throws Exception {
  assertFalse(NO_RESOLVED_TYPE.isNoObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNoType());
  assertTrue(NO_RESOLVED_TYPE.isNoResolvedType());
  assertFalse(NO_RESOLVED_TYPE.isArrayType());
  assertFalse(NO_RESOLVED_TYPE.isBooleanValueType());
  assertFalse(NO_RESOLVED_TYPE.isDateType());
  assertFalse(NO_RESOLVED_TYPE.isEnumElementType());
  assertFalse(NO_RESOLVED_TYPE.isNullType());
  assertFalse(NO_RESOLVED_TYPE.isNamedType());
  assertTrue(NO_RESOLVED_TYPE.isNumber());
  assertFalse(NO_RESOLVED_TYPE.isNumberObjectType());
  assertFalse(NO_RESOLVED_TYPE.isNumberValueType());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertFalse(NO_RESOLVED_TYPE.isFunctionPrototypeType());
  assertFalse(NO_RESOLVED_TYPE.isRegexpType());
  assertTrue(NO_RESOLVED_TYPE.isString());
  assertFalse(NO_RESOLVED_TYPE.isStringObjectType());
  assertFalse(NO_RESOLVED_TYPE.isStringValueType());
  assertFalse(NO_RESOLVED_TYPE.isEnumType());
  assertFalse(NO_RESOLVED_TYPE.isUnionType());
  assertFalse(NO_RESOLVED_TYPE.isStruct());
  assertFalse(NO_RESOLVED_TYPE.isDict());
  assertFalse(NO_RESOLVED_TYPE.isAllType());
  assertFalse(NO_RESOLVED_TYPE.isVoidType());
  assertTrue(NO_RESOLVED_TYPE.isConstructor());
  assertFalse(NO_RESOLVED_TYPE.isInstanceType());
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(functionType));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isSubtype(VOID_TYPE));
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ARRAY_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,DATE_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,EVAL_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,functionType);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NULL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,NUMBER_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,URI_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,RANGE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REFERENCE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,REGEXP_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,STRING_OBJECT_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,SYNTAX_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,TYPE_ERROR_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,ALL_TYPE);
  assertCanTestForEqualityWith(NO_RESOLVED_TYPE,VOID_TYPE);
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_RESOLVED_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertTrue(NO_RESOLVED_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NO_RESOLVED_TYPE.isNullable());
  assertTrue(NO_RESOLVED_TYPE.isObject());
  assertTrue(NO_RESOLVED_TYPE.matchesInt32Context());
  assertTrue(NO_RESOLVED_TYPE.matchesNumberContext());
  assertTrue(NO_RESOLVED_TYPE.matchesObjectContext());
  assertTrue(NO_RESOLVED_TYPE.matchesStringContext());
  assertTrue(NO_RESOLVED_TYPE.matchesUint32Context());
  assertEquals(""String_Node_Str"",NO_RESOLVED_TYPE.toString());
  assertEquals(null,NO_RESOLVED_TYPE.getDisplayName());
  assertFalse(NO_RESOLVED_TYPE.hasDisplayName());
  assertTypeEquals(CHECKED_UNKNOWN_TYPE,NO_RESOLVED_TYPE.getPropertyType(""String_Node_Str""));
  Asserts.assertResolvesToSame(NO_RESOLVED_TYPE);
  assertTrue(forwardDeclaredNamedType.isEmptyType());
  assertTrue(forwardDeclaredNamedType.isNoResolvedType());
  UnionType nullable=(UnionType)registry.createNullableType(NO_RESOLVED_TYPE);
  assertTypeEquals(nullable,nullable.getGreatestSubtype(NULL_TYPE));
  assertTypeEquals(NO_RESOLVED_TYPE,nullable.getRestrictedUnion(NULL_TYPE));
}"
18646,"/** 
 * Tests the behavior of the null type.
 */
public void testNullType() throws Exception {
  assertFalse(NULL_TYPE.isArrayType());
  assertFalse(NULL_TYPE.isBooleanValueType());
  assertFalse(NULL_TYPE.isDateType());
  assertFalse(NULL_TYPE.isEnumElementType());
  assertFalse(NULL_TYPE.isNamedType());
  assertTrue(NULL_TYPE.isNullType());
  assertFalse(NULL_TYPE.isNumber());
  assertFalse(NULL_TYPE.isNumberObjectType());
  assertFalse(NULL_TYPE.isNumberValueType());
  assertFalse(NULL_TYPE.isFunctionPrototypeType());
  assertFalse(NULL_TYPE.isRegexpType());
  assertFalse(NULL_TYPE.isString());
  assertFalse(NULL_TYPE.isStringObjectType());
  assertFalse(NULL_TYPE.isStringValueType());
  assertFalse(NULL_TYPE.isEnumType());
  assertFalse(NULL_TYPE.isUnionType());
  assertFalse(NULL_TYPE.isStruct());
  assertFalse(NULL_TYPE.isDict());
  assertFalse(NULL_TYPE.isAllType());
  assertFalse(NULL_TYPE.isVoidType());
  assertFalse(NULL_TYPE.isConstructor());
  assertFalse(NULL_TYPE.isInstanceType());
  assertNull(NULL_TYPE.autoboxesTo());
  assertFalse(NULL_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NO_TYPE));
  assertTrue(NULL_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NULL_TYPE.isSubtype(ALL_TYPE));
  assertFalse(NULL_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NUMBER_TYPE));
  assertFalse(NULL_TYPE.isSubtype(functionType));
  assertFalse(NULL_TYPE.isSubtype(OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(DATE_TYPE));
  assertFalse(NULL_TYPE.isSubtype(REGEXP_TYPE));
  assertFalse(NULL_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NULL_TYPE.isSubtype(UNKNOWN_TYPE));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NULL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ALL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(STRING_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NUMBER_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(functionType)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(DATE_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(REGEXP_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ARRAY_TYPE)));
  assertFalse(NULL_TYPE.canBeCalled());
  assertCanTestForEqualityWith(NULL_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,ALL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ARRAY_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,DATE_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,EVAL_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,functionType);
  assertCannotTestForEqualityWith(NULL_TYPE,NULL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,URI_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,RANGE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REFERENCE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REGEXP_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,SYNTAX_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,TYPE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,VOID_TYPE);
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(createNullableType(STRING_OBJECT_TYPE)));
  assertTypeEquals(NULL_TYPE,NULL_TYPE.getLeastSupertype(NULL_TYPE));
  assertTypeEquals(ALL_TYPE,NULL_TYPE.getLeastSupertype(ALL_TYPE));
  assertTypeEquals(createNullableType(STRING_OBJECT_TYPE),NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));
  assertTypeEquals(createNullableType(NUMBER_TYPE),NULL_TYPE.getLeastSupertype(NUMBER_TYPE));
  assertTypeEquals(createNullableType(functionType),NULL_TYPE.getLeastSupertype(functionType));
  assertTypeEquals(createNullableType(OBJECT_TYPE),NULL_TYPE.getLeastSupertype(OBJECT_TYPE));
  assertTypeEquals(createNullableType(DATE_TYPE),NULL_TYPE.getLeastSupertype(DATE_TYPE));
  assertTypeEquals(createNullableType(REGEXP_TYPE),NULL_TYPE.getLeastSupertype(REGEXP_TYPE));
  assertTrue(NULL_TYPE.matchesInt32Context());
  assertTrue(NULL_TYPE.matchesNumberContext());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertTrue(NULL_TYPE.matchesStringContext());
  assertTrue(NULL_TYPE.matchesUint32Context());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertEquals(""String_Node_Str"",NULL_TYPE.toString());
  assertTrue(NULL_TYPE.hasDisplayName());
  assertEquals(""String_Node_Str"",NULL_TYPE.getDisplayName());
  Asserts.assertResolvesToSame(NULL_TYPE);
  assertTrue(NULL_TYPE.isSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertTypeEquals(NULL_TYPE,NULL_TYPE.getGreatestSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertFalse(NULL_TYPE.isNominalConstructor());
  assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE));
}","/** 
 * Tests the behavior of the null type.
 */
public void testNullType() throws Exception {
  assertFalse(NULL_TYPE.isArrayType());
  assertFalse(NULL_TYPE.isBooleanValueType());
  assertFalse(NULL_TYPE.isDateType());
  assertFalse(NULL_TYPE.isEnumElementType());
  assertFalse(NULL_TYPE.isNamedType());
  assertTrue(NULL_TYPE.isNullType());
  assertFalse(NULL_TYPE.isNumber());
  assertFalse(NULL_TYPE.isNumberObjectType());
  assertFalse(NULL_TYPE.isNumberValueType());
  assertFalse(NULL_TYPE.isFunctionPrototypeType());
  assertFalse(NULL_TYPE.isRegexpType());
  assertFalse(NULL_TYPE.isString());
  assertFalse(NULL_TYPE.isStringObjectType());
  assertFalse(NULL_TYPE.isStringValueType());
  assertFalse(NULL_TYPE.isEnumType());
  assertFalse(NULL_TYPE.isUnionType());
  assertFalse(NULL_TYPE.isStruct());
  assertFalse(NULL_TYPE.isDict());
  assertFalse(NULL_TYPE.isAllType());
  assertFalse(NULL_TYPE.isVoidType());
  assertFalse(NULL_TYPE.isConstructor());
  assertFalse(NULL_TYPE.isInstanceType());
  assertNull(NULL_TYPE.autoboxesTo());
  assertFalse(NULL_TYPE.isSubtype(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NO_TYPE));
  assertTrue(NULL_TYPE.isSubtype(NULL_TYPE));
  assertTrue(NULL_TYPE.isSubtype(ALL_TYPE));
  assertFalse(NULL_TYPE.isSubtype(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(NUMBER_TYPE));
  assertFalse(NULL_TYPE.isSubtype(functionType));
  assertFalse(NULL_TYPE.isSubtype(OBJECT_TYPE));
  assertFalse(NULL_TYPE.isSubtype(DATE_TYPE));
  assertFalse(NULL_TYPE.isSubtype(REGEXP_TYPE));
  assertFalse(NULL_TYPE.isSubtype(ARRAY_TYPE));
  assertTrue(NULL_TYPE.isSubtype(UNKNOWN_TYPE));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NO_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NULL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ALL_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(STRING_OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(NUMBER_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(functionType)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(OBJECT_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(DATE_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(REGEXP_TYPE)));
  assertTrue(NULL_TYPE.isSubtype(createNullableType(ARRAY_TYPE)));
  assertFalse(NULL_TYPE.canBeCalled());
  assertCanTestForEqualityWith(NULL_TYPE,NO_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,NO_OBJECT_TYPE);
  assertCanTestForEqualityWith(NULL_TYPE,ALL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ARRAY_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,BOOLEAN_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,DATE_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,EVAL_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,functionType);
  assertCannotTestForEqualityWith(NULL_TYPE,NULL_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,NUMBER_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,URI_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,RANGE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REFERENCE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,REGEXP_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,STRING_OBJECT_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,SYNTAX_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,TYPE_ERROR_TYPE);
  assertCannotTestForEqualityWith(NULL_TYPE,VOID_TYPE);
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NO_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NO_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ARRAY_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(BOOLEAN_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(DATE_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(EVAL_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(functionType));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(NULL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(NUMBER_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(URI_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(RANGE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REFERENCE_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(REGEXP_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(STRING_OBJECT_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(SYNTAX_ERROR_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(TYPE_ERROR_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(ALL_TYPE));
  assertFalse(NULL_TYPE.canTestForShallowEqualityWith(VOID_TYPE));
  assertTrue(NULL_TYPE.canTestForShallowEqualityWith(createNullableType(STRING_OBJECT_TYPE)));
  assertTypeEquals(NULL_TYPE,NULL_TYPE.getLeastSupertype(NULL_TYPE));
  assertTypeEquals(ALL_TYPE,NULL_TYPE.getLeastSupertype(ALL_TYPE));
  assertTypeEquals(createNullableType(STRING_OBJECT_TYPE),NULL_TYPE.getLeastSupertype(STRING_OBJECT_TYPE));
  assertTypeEquals(createNullableType(NUMBER_TYPE),NULL_TYPE.getLeastSupertype(NUMBER_TYPE));
  assertTypeEquals(createNullableType(functionType),NULL_TYPE.getLeastSupertype(functionType));
  assertTypeEquals(createNullableType(OBJECT_TYPE),NULL_TYPE.getLeastSupertype(OBJECT_TYPE));
  assertTypeEquals(createNullableType(DATE_TYPE),NULL_TYPE.getLeastSupertype(DATE_TYPE));
  assertTypeEquals(createNullableType(REGEXP_TYPE),NULL_TYPE.getLeastSupertype(REGEXP_TYPE));
  assertTrue(NULL_TYPE.matchesInt32Context());
  assertTrue(NULL_TYPE.matchesNumberContext());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertTrue(NULL_TYPE.matchesStringContext());
  assertTrue(NULL_TYPE.matchesUint32Context());
  assertFalse(NULL_TYPE.matchesObjectContext());
  assertEquals(""String_Node_Str"",NULL_TYPE.toString());
  assertTrue(NULL_TYPE.hasDisplayName());
  assertEquals(""String_Node_Str"",NULL_TYPE.getDisplayName());
  Asserts.assertResolvesToSame(NULL_TYPE);
  assertTrue(NULL_TYPE.isSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertTypeEquals(createUnionType(forwardDeclaredNamedType,NULL_TYPE),NULL_TYPE.getGreatestSubtype(createUnionType(forwardDeclaredNamedType,NULL_TYPE)));
  assertFalse(NULL_TYPE.isNominalConstructor());
  assertTrue(NULL_TYPE.differsFrom(UNKNOWN_TYPE));
}"
18647,"/** 
 * Resolve the referenced type within the enclosing scope.
 */
@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> enclosing){
  boolean resolved=resolveViaRegistry(t,enclosing);
  if (detectImplicitPrototypeCycle()) {
    handleTypeCycle(t);
  }
  if (resolved) {
    super.resolveInternal(t,enclosing);
    finishPropertyContinuations();
    return registry.isLastGeneration() ? getReferencedType() : this;
  }
  resolveViaProperties(t,enclosing);
  if (detectImplicitPrototypeCycle()) {
    handleTypeCycle(t);
  }
  super.resolveInternal(t,enclosing);
  if (isResolved()) {
    finishPropertyContinuations();
  }
  return registry.isLastGeneration() ? getReferencedType() : this;
}","/** 
 * Resolve the referenced type within the enclosing scope.
 */
@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> enclosing){
  boolean resolved=resolveViaRegistry(t,enclosing);
  if (detectInheritanceCycle()) {
    handleTypeCycle(t);
  }
  if (resolved) {
    super.resolveInternal(t,enclosing);
    finishPropertyContinuations();
    return registry.isLastGeneration() ? getReferencedType() : this;
  }
  resolveViaProperties(t,enclosing);
  if (detectInheritanceCycle()) {
    handleTypeCycle(t);
  }
  super.resolveInternal(t,enclosing);
  if (isResolved()) {
    finishPropertyContinuations();
  }
  return registry.isLastGeneration() ? getReferencedType() : this;
}"
18648,"/** 
 * Detects a cycle in the implicit prototype chain. This method accesses the   {@link #getImplicitPrototype()} method and must therefore beinvoked only after the object is sufficiently initialized to respond to calls to this method.<p> The method is not thread safe.<p>
 * @return True iff an implicit prototype cycle was detected.
 */
final boolean detectImplicitPrototypeCycle(){
  this.visited=true;
  ObjectType p=getImplicitPrototype();
  while (p != null) {
    if (p.visited) {
      return true;
    }
 else {
      p.visited=true;
    }
    p=p.getImplicitPrototype();
  }
  p=this;
  do {
    p.visited=false;
    p=p.getImplicitPrototype();
  }
 while (p != null);
  return false;
}","/** 
 * Detects a cycle in the implicit prototype chain. This method accesses the   {@link #getImplicitPrototype()} method and must therefore beinvoked only after the object is sufficiently initialized to respond to calls to this method.<p>
 * @return True iff an implicit prototype cycle was detected.
 */
final boolean detectImplicitPrototypeCycle(){
  this.visited=true;
  ObjectType p=getImplicitPrototype();
  while (p != null) {
    if (p.visited) {
      return true;
    }
 else {
      p.visited=true;
    }
    p=p.getImplicitPrototype();
  }
  p=this;
  do {
    p.visited=false;
    p=p.getImplicitPrototype();
  }
 while (p != null);
  return false;
}"
18649,"/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node next=null;
    Node prev=null;
    for (Node c=n.getFirstChild().getNext(); c != null; c=next) {
      next=c.getNext();
      if (!mayHaveSideEffects(c.getFirstChild()) && isUselessCase(c,prev)) {
        removeCase(n,c);
      }
 else {
        prev=c;
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node parent=n.getParent();
    Node replacement=IR.exprResult(condition).srcref(n);
    parent.replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}","/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          n.removeChild(cur);
          reportCodeChange();
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          n.removeChild(cur);
          reportCodeChange();
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}"
18650,"public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
}","public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}"
18651,"/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          n.removeChild(cur);
          reportCodeChange();
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          n.removeChild(cur);
          reportCodeChange();
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}","/** 
 * Remove useless switches and cases.
 */
private Node tryOptimizeSwitch(Node n){
  Preconditions.checkState(n.isSwitch());
  Node defaultCase=tryOptimizeDefaultCase(n);
  if (defaultCase == null) {
    Node cond=n.getFirstChild(), prev=null, next=null, cur;
    for (cur=cond.getNext(); cur != null; cur=next) {
      next=cur.getNext();
      if (!mayHaveSideEffects(cur.getFirstChild()) && isUselessCase(cur,prev)) {
        removeCase(n,cur);
      }
 else {
        prev=cur;
      }
    }
    if (NodeUtil.isLiteralValue(cond,false)) {
      Node caseLabel;
      TernaryValue caseMatches=TernaryValue.TRUE;
      for (cur=cond.getNext(); cur != null; cur=next) {
        next=cur.getNext();
        caseLabel=cur.getFirstChild();
        caseMatches=PeepholeFoldConstants.evaluateComparison(Token.SHEQ,cond,caseLabel);
        if (caseMatches == TernaryValue.TRUE) {
          break;
        }
 else         if (caseMatches == TernaryValue.UNKNOWN) {
          break;
        }
 else {
          n.removeChild(cur);
          reportCodeChange();
        }
      }
      if (caseMatches != TernaryValue.UNKNOWN) {
        Node block, lastStm;
        while (cur != null) {
          block=cur.getLastChild();
          lastStm=block.getLastChild();
          cur=cur.getNext();
          if (lastStm != null && lastStm.isBreak()) {
            block.removeChild(lastStm);
            reportCodeChange();
            break;
          }
        }
        for (; cur != null; cur=next) {
          next=cur.getNext();
          n.removeChild(cur);
          reportCodeChange();
        }
        cur=cond.getNext();
        if (cur != null && cur.getNext() == null) {
          block=cur.getLastChild();
          if (!(NodeUtil.containsType(block,Token.BREAK,NodeUtil.MATCH_NOT_FUNCTION))) {
            cur.removeChild(block);
            n.getParent().replaceChild(n,block);
            reportCodeChange();
            return block;
          }
        }
      }
    }
  }
  if (n.hasOneChild()) {
    Node condition=n.removeFirstChild();
    Node replacement=IR.exprResult(condition).srcref(n);
    n.getParent().replaceChild(n,replacement);
    reportCodeChange();
    return replacement;
  }
  return null;
}"
18652,"public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
}","public void testOptimizeSwitch(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
  foldSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
18653,"/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignTo(NodeTraversal t,Node n,JSType rightType,JSType leftType,String msg){
  if (!rightType.canAssignTo(leftType)) {
    if (bothIntrinsics(rightType,leftType)) {
      registerMismatch(rightType,leftType,null);
    }
 else {
      mismatch(t,n,msg,rightType,leftType);
    }
    return false;
  }
  return true;
}","/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param msg An extra message for the mismatch warning, if necessary.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignTo(NodeTraversal t,Node n,JSType rightType,JSType leftType,String msg){
  if (!rightType.canAssignTo(leftType)) {
    mismatch(t,n,msg,rightType,leftType);
    return false;
  }
  return true;
}"
18654,"/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignToPropertyOf(NodeTraversal t,Node n,JSType rightType,JSType leftType,Node owner,String propName){
  if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
    if (bothIntrinsics(rightType,leftType)) {
      registerMismatch(rightType,leftType,null);
    }
 else {
      JSType ownerType=getJSType(owner);
      if (ownerType.isFunctionPrototypeType()) {
        FunctionType ownerFn=ownerType.toObjectType().getOwnerFunction();
        if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
          return true;
        }
      }
      mismatch(t,n,""String_Node_Str"" + propName + ""String_Node_Str""+ getReadableJSTypeName(owner,true),rightType,leftType);
    }
    return false;
  }
  return true;
}","/** 
 * Expect that the first type can be assigned to a symbol of the second type.
 * @param t The node traversal.
 * @param n The node to issue warnings on.
 * @param rightType The type on the RHS of the assign.
 * @param leftType The type of the symbol on the LHS of the assign.
 * @param owner The owner of the property being assigned to.
 * @param propName The name of the property being assigned to.
 * @return True if the types matched, false otherwise.
 */
boolean expectCanAssignToPropertyOf(NodeTraversal t,Node n,JSType rightType,JSType leftType,Node owner,String propName){
  if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
    JSType ownerType=getJSType(owner);
    if (ownerType.isFunctionPrototypeType()) {
      FunctionType ownerFn=ownerType.toObjectType().getOwnerFunction();
      if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {
        return true;
      }
    }
    mismatch(t,n,""String_Node_Str"" + propName + ""String_Node_Str""+ getReadableJSTypeName(owner,true),rightType,leftType);
    return false;
  }
  return true;
}"
18655,"/** 
 * A function is a subtype of another if their call methods are related via subtyping and   {@code this} is a subtype of {@code that} with regard tothe prototype chain.
 */
@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isFunctionType()) {
    FunctionType other=that.toMaybeFunctionType();
    if (other.isInterface()) {
      return true;
    }
    if (isInterface()) {
      return false;
    }
    boolean treatThisTypesAsCovariant=isConstructor() || other.isConstructor() || (other.typeOfThis.toObjectType() != null && other.typeOfThis.toObjectType().getConstructor() != null && other.typeOfThis.toObjectType().getConstructor().isInterface())|| other.typeOfThis.isSubtype(this.typeOfThis)|| this.typeOfThis.isSubtype(other.typeOfThis);
    return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
  }
  return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}","/** 
 * A function is a subtype of another if their call methods are related via subtyping and   {@code this} is a subtype of {@code that} with regard tothe prototype chain.
 */
@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isFunctionType()) {
    FunctionType other=that.toMaybeFunctionType();
    if (other.isInterface()) {
      return true;
    }
    if (isInterface()) {
      return false;
    }
    boolean treatThisTypesAsCovariant=(other.typeOfThis.toObjectType() != null && other.typeOfThis.toObjectType().getConstructor() != null && other.typeOfThis.toObjectType().getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis) || this.typeOfThis.isSubtype(other.typeOfThis);
    return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
  }
  return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
}"
18656,"public void testTypeRedefinition() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}","public void testTypeRedefinition() throws Exception {
  testClosureTypesMultipleWarnings(""String_Node_Str"" + ""String_Node_Str"",Lists.newArrayList(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
18657,"private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(descriptions.size(),compiler.getWarningCount());
    for (int i=0; i < descriptions.size(); i++) {
      assertEquals(descriptions.get(i),compiler.getWarnings()[i].description);
    }
  }
}","private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(descriptions.size(),compiler.getWarningCount());
    Set<String> actualWarningDescriptions=Sets.newHashSet();
    for (int i=0; i < descriptions.size(); i++) {
      actualWarningDescriptions.add(compiler.getWarnings()[i].description);
    }
    assertEquals(Sets.newHashSet(descriptions),actualWarningDescriptions);
  }
}"
18658,"public void testTypeRedefinition() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}","public void testTypeRedefinition() throws Exception {
  testClosureTypesMultipleWarnings(""String_Node_Str"" + ""String_Node_Str"",Lists.newArrayList(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
18659,"private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),descriptions.size(),compiler.getWarningCount());
    for (int i=0; i < descriptions.size(); i++) {
      assertEquals(descriptions.get(i),compiler.getWarnings()[i].description);
    }
  }
}","private void testClosureTypesMultipleWarnings(String js,List<String> descriptions) throws Exception {
  Node n=compiler.parseTestCode(js);
  Node externs=new Node(Token.BLOCK);
  Node externAndJsRoot=new Node(Token.BLOCK,externs,n);
  externAndJsRoot.setIsSyntheticBlock(true);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR).process(null,n);
  CodingConvention convention=compiler.getCodingConvention();
  new TypeCheck(compiler,new ClosureReverseAbstractInterpreter(convention,registry).append(new SemanticReverseAbstractInterpreter(convention,registry)).getFirst(),registry).processForTesting(null,n);
  assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getErrors()),0,compiler.getErrorCount());
  if (descriptions == null) {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),0,compiler.getWarningCount());
  }
 else {
    assertEquals(""String_Node_Str"" + Joiner.on(""String_Node_Str"").join(compiler.getWarnings()),descriptions.size(),compiler.getWarningCount());
    Set<String> actualWarningDescriptions=Sets.newHashSet();
    for (int i=0; i < descriptions.size(); i++) {
      actualWarningDescriptions.add(compiler.getWarnings()[i].description);
    }
    assertEquals(Sets.newHashSet(descriptions),actualWarningDescriptions);
  }
}"
18660,"/** 
 * @return True if our parameter spec is equal to {@code that}'s parameter spec.
 */
boolean hasEqualParameters(ArrowType that,EquivalenceMethod eqMethod){
  Node thisParam=parameters.getFirstChild();
  Node otherParam=that.parameters.getFirstChild();
  while (thisParam != null && otherParam != null) {
    JSType thisParamType=thisParam.getJSType();
    JSType otherParamType=otherParam.getJSType();
    if (thisParamType != null) {
      if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType,eqMethod)) {
        return false;
      }
    }
 else {
      if (otherParamType != null) {
        return false;
      }
    }
    thisParam=thisParam.getNext();
    otherParam=otherParam.getNext();
  }
  return thisParam == otherParam;
}","/** 
 * @return True if our parameter spec is equal to {@code that}'s parameter spec.
 */
boolean hasEqualParameters(ArrowType that,EquivalenceMethod eqMethod){
  Node thisParam=parameters.getFirstChild();
  Node otherParam=that.parameters.getFirstChild();
  while (thisParam != null && otherParam != null) {
    JSType thisParamType=thisParam.getJSType();
    JSType otherParamType=otherParam.getJSType();
    if (thisParamType != null) {
      if (otherParamType != null && !thisParamType.checkEquivalenceHelper(otherParamType,eqMethod)) {
        return false;
      }
    }
 else {
      if (otherParamType != null) {
        return false;
      }
    }
    if (thisParam.isOptionalArg() != otherParam.isOptionalArg()) {
      return false;
    }
    if (thisParam.isVarArgs() != otherParam.isVarArgs()) {
      return false;
    }
    thisParam=thisParam.getNext();
    otherParam=otherParam.getNext();
  }
  return thisParam == otherParam;
}"
18661,"private void initializeBuiltInTypes(){
  BooleanType BOOLEAN_TYPE=new BooleanType(this);
  registerNativeType(JSTypeNative.BOOLEAN_TYPE,BOOLEAN_TYPE);
  NullType NULL_TYPE=new NullType(this);
  registerNativeType(JSTypeNative.NULL_TYPE,NULL_TYPE);
  NumberType NUMBER_TYPE=new NumberType(this);
  registerNativeType(JSTypeNative.NUMBER_TYPE,NUMBER_TYPE);
  StringType STRING_TYPE=new StringType(this);
  registerNativeType(JSTypeNative.STRING_TYPE,STRING_TYPE);
  UnknownType UNKNOWN_TYPE=new UnknownType(this,false);
  registerNativeType(JSTypeNative.UNKNOWN_TYPE,UNKNOWN_TYPE);
  UnknownType checkedUnknownType=new UnknownType(this,true);
  registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE,checkedUnknownType);
  VoidType VOID_TYPE=new VoidType(this);
  registerNativeType(JSTypeNative.VOID_TYPE,VOID_TYPE);
  AllType ALL_TYPE=new AllType(this);
  registerNativeType(JSTypeNative.ALL_TYPE,ALL_TYPE);
  PrototypeObjectType TOP_LEVEL_PROTOTYPE=new PrototypeObjectType(this,null,null,true,null,null);
  registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE,TOP_LEVEL_PROTOTYPE);
  FunctionType OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE,null);
  registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE,OBJECT_FUNCTION_TYPE);
  ObjectType OBJECT_TYPE=OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.OBJECT_TYPE,OBJECT_TYPE);
  ObjectType OBJECT_PROTOTYPE=OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.OBJECT_PROTOTYPE,OBJECT_PROTOTYPE);
  FunctionType FUNCTION_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE,FUNCTION_FUNCTION_TYPE);
  ObjectType FUNCTION_PROTOTYPE=FUNCTION_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE,FUNCTION_PROTOTYPE);
  NoType NO_TYPE=new NoType(this);
  registerNativeType(JSTypeNative.NO_TYPE,NO_TYPE);
  NoObjectType NO_OBJECT_TYPE=new NoObjectType(this);
  registerNativeType(JSTypeNative.NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  NoObjectType NO_RESOLVED_TYPE=new NoResolvedType(this);
  registerNativeType(JSTypeNative.NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  FunctionType ARRAY_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),null),null,null,true,true);
  ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType=ARRAY_FUNCTION_TYPE.getInstanceType();
  ObjectType arrayPrototype=ARRAY_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE,ARRAY_FUNCTION_TYPE);
  ObjectType ARRAY_TYPE=ARRAY_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ARRAY_TYPE,ARRAY_TYPE);
  FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),BOOLEAN_TYPE),null,null,true,true);
  ObjectType booleanPrototype=BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,BOOLEAN_OBJECT_FUNCTION_TYPE);
  ObjectType BOOLEAN_OBJECT_TYPE=BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE,BOOLEAN_OBJECT_TYPE);
  FunctionType DATE_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType datePrototype=DATE_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE,DATE_FUNCTION_TYPE);
  ObjectType DATE_TYPE=DATE_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.DATE_TYPE,DATE_TYPE);
  FunctionType ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE,ERROR_FUNCTION_TYPE);
  ObjectType ERROR_TYPE=ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ERROR_TYPE,ERROR_TYPE);
  FunctionType EVAL_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE,EVAL_ERROR_FUNCTION_TYPE);
  ObjectType EVAL_ERROR_TYPE=EVAL_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.EVAL_ERROR_TYPE,EVAL_ERROR_TYPE);
  FunctionType RANGE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE,RANGE_ERROR_FUNCTION_TYPE);
  ObjectType RANGE_ERROR_TYPE=RANGE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.RANGE_ERROR_TYPE,RANGE_ERROR_TYPE);
  FunctionType REFERENCE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,REFERENCE_ERROR_FUNCTION_TYPE);
  ObjectType REFERENCE_ERROR_TYPE=REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE,REFERENCE_ERROR_TYPE);
  FunctionType SYNTAX_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE,SYNTAX_ERROR_FUNCTION_TYPE);
  ObjectType SYNTAX_ERROR_TYPE=SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE,SYNTAX_ERROR_TYPE);
  FunctionType TYPE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE,TYPE_ERROR_FUNCTION_TYPE);
  ObjectType TYPE_ERROR_TYPE=TYPE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.TYPE_ERROR_TYPE,TYPE_ERROR_TYPE);
  FunctionType URI_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE,URI_ERROR_FUNCTION_TYPE);
  ObjectType URI_ERROR_TYPE=URI_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.URI_ERROR_TYPE,URI_ERROR_TYPE);
  FunctionType NUMBER_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType numberPrototype=NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE,NUMBER_OBJECT_FUNCTION_TYPE);
  ObjectType NUMBER_OBJECT_TYPE=NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE,NUMBER_OBJECT_TYPE);
  FunctionType REGEXP_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE,ALL_TYPE)),null,null,true,true);
  REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType=REGEXP_FUNCTION_TYPE.getInstanceType();
  ObjectType regexpPrototype=REGEXP_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE,REGEXP_FUNCTION_TYPE);
  ObjectType REGEXP_TYPE=REGEXP_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REGEXP_TYPE,REGEXP_TYPE);
  FunctionType STRING_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType stringPrototype=STRING_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE,STRING_OBJECT_FUNCTION_TYPE);
  ObjectType STRING_OBJECT_TYPE=STRING_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.STRING_OBJECT_TYPE,STRING_OBJECT_TYPE);
  JSType NULL_VOID=createUnionType(NULL_TYPE,VOID_TYPE);
  registerNativeType(JSTypeNative.NULL_VOID,NULL_VOID);
  JSType OBJECT_NUMBER_STRING=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING,OBJECT_NUMBER_STRING);
  JSType OBJECT_NUMBER_STRING_BOOLEAN=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,OBJECT_NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING_BOOLEAN=createUnionType(NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING=createUnionType(NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING,NUMBER_STRING);
  JSType STRING_VALUE_OR_OBJECT_TYPE=createUnionType(STRING_OBJECT_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE,STRING_VALUE_OR_OBJECT_TYPE);
  JSType NUMBER_VALUE_OR_OBJECT_TYPE=createUnionType(NUMBER_OBJECT_TYPE,NUMBER_TYPE);
  registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE,NUMBER_VALUE_OR_OBJECT_TYPE);
  FunctionType U2U_FUNCTION_TYPE=createFunctionType(UNKNOWN_TYPE,true,UNKNOWN_TYPE);
  registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE,U2U_FUNCTION_TYPE);
  FunctionType U2U_CONSTRUCTOR_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE),UNKNOWN_TYPE),UNKNOWN_TYPE,null,true,true){
    private static final long serialVersionUID=1L;
    @Override public FunctionType getConstructor(){
      return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
    }
  }
;
  registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE,U2U_CONSTRUCTOR_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE,U2U_CONSTRUCTOR_TYPE);
  FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);
  U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);
  FunctionType LEAST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(NO_TYPE,ALL_TYPE);
  registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE,LEAST_FUNCTION_TYPE);
  FunctionType GLOBAL_THIS_CTOR=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType GLOBAL_THIS=GLOBAL_THIS_CTOR.getInstanceType();
  registerNativeType(JSTypeNative.GLOBAL_THIS,GLOBAL_THIS);
  FunctionType GREATEST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(ALL_TYPE,NO_TYPE);
  registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,GREATEST_FUNCTION_TYPE);
  registerPropertyOnType(""String_Node_Str"",OBJECT_FUNCTION_TYPE);
}","private void initializeBuiltInTypes(){
  BooleanType BOOLEAN_TYPE=new BooleanType(this);
  registerNativeType(JSTypeNative.BOOLEAN_TYPE,BOOLEAN_TYPE);
  NullType NULL_TYPE=new NullType(this);
  registerNativeType(JSTypeNative.NULL_TYPE,NULL_TYPE);
  NumberType NUMBER_TYPE=new NumberType(this);
  registerNativeType(JSTypeNative.NUMBER_TYPE,NUMBER_TYPE);
  StringType STRING_TYPE=new StringType(this);
  registerNativeType(JSTypeNative.STRING_TYPE,STRING_TYPE);
  UnknownType UNKNOWN_TYPE=new UnknownType(this,false);
  registerNativeType(JSTypeNative.UNKNOWN_TYPE,UNKNOWN_TYPE);
  UnknownType checkedUnknownType=new UnknownType(this,true);
  registerNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE,checkedUnknownType);
  VoidType VOID_TYPE=new VoidType(this);
  registerNativeType(JSTypeNative.VOID_TYPE,VOID_TYPE);
  AllType ALL_TYPE=new AllType(this);
  registerNativeType(JSTypeNative.ALL_TYPE,ALL_TYPE);
  PrototypeObjectType TOP_LEVEL_PROTOTYPE=new PrototypeObjectType(this,null,null,true,null,null);
  registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE,TOP_LEVEL_PROTOTYPE);
  FunctionType OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE,null);
  registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE,OBJECT_FUNCTION_TYPE);
  ObjectType OBJECT_TYPE=OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.OBJECT_TYPE,OBJECT_TYPE);
  ObjectType OBJECT_PROTOTYPE=OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.OBJECT_PROTOTYPE,OBJECT_PROTOTYPE);
  FunctionType FUNCTION_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),UNKNOWN_TYPE),null,null,true,true);
  FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_FUNCTION_TYPE,FUNCTION_FUNCTION_TYPE);
  ObjectType FUNCTION_PROTOTYPE=FUNCTION_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE,FUNCTION_PROTOTYPE);
  NoType NO_TYPE=new NoType(this);
  registerNativeType(JSTypeNative.NO_TYPE,NO_TYPE);
  NoObjectType NO_OBJECT_TYPE=new NoObjectType(this);
  registerNativeType(JSTypeNative.NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  NoObjectType NO_RESOLVED_TYPE=new NoResolvedType(this);
  registerNativeType(JSTypeNative.NO_RESOLVED_TYPE,NO_RESOLVED_TYPE);
  FunctionType ARRAY_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(ALL_TYPE),null),null,null,true,true);
  ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType=ARRAY_FUNCTION_TYPE.getInstanceType();
  ObjectType arrayPrototype=ARRAY_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE,ARRAY_FUNCTION_TYPE);
  ObjectType ARRAY_TYPE=ARRAY_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ARRAY_TYPE,ARRAY_TYPE);
  FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),BOOLEAN_TYPE),null,null,true,true);
  ObjectType booleanPrototype=BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,BOOLEAN_OBJECT_FUNCTION_TYPE);
  ObjectType BOOLEAN_OBJECT_TYPE=BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE,BOOLEAN_OBJECT_TYPE);
  FunctionType DATE_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE,UNKNOWN_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType datePrototype=DATE_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE,DATE_FUNCTION_TYPE);
  ObjectType DATE_TYPE=DATE_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.DATE_TYPE,DATE_TYPE);
  FunctionType ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE,ERROR_FUNCTION_TYPE);
  ObjectType ERROR_TYPE=ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.ERROR_TYPE,ERROR_TYPE);
  FunctionType EVAL_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE,EVAL_ERROR_FUNCTION_TYPE);
  ObjectType EVAL_ERROR_TYPE=EVAL_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.EVAL_ERROR_TYPE,EVAL_ERROR_TYPE);
  FunctionType RANGE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE,RANGE_ERROR_FUNCTION_TYPE);
  ObjectType RANGE_ERROR_TYPE=RANGE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.RANGE_ERROR_TYPE,RANGE_ERROR_TYPE);
  FunctionType REFERENCE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,REFERENCE_ERROR_FUNCTION_TYPE);
  ObjectType REFERENCE_ERROR_TYPE=REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE,REFERENCE_ERROR_TYPE);
  FunctionType SYNTAX_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE,SYNTAX_ERROR_FUNCTION_TYPE);
  ObjectType SYNTAX_ERROR_TYPE=SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE,SYNTAX_ERROR_TYPE);
  FunctionType TYPE_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE,TYPE_ERROR_FUNCTION_TYPE);
  ObjectType TYPE_ERROR_TYPE=TYPE_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.TYPE_ERROR_TYPE,TYPE_ERROR_TYPE);
  FunctionType URI_ERROR_FUNCTION_TYPE=new ErrorFunctionType(this,""String_Node_Str"");
  URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);
  registerNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE,URI_ERROR_FUNCTION_TYPE);
  ObjectType URI_ERROR_TYPE=URI_ERROR_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.URI_ERROR_TYPE,URI_ERROR_TYPE);
  FunctionType NUMBER_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType numberPrototype=NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE,NUMBER_OBJECT_FUNCTION_TYPE);
  ObjectType NUMBER_OBJECT_TYPE=NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE,NUMBER_OBJECT_TYPE);
  FunctionType REGEXP_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE,ALL_TYPE)),null,null,true,true);
  REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType=REGEXP_FUNCTION_TYPE.getInstanceType();
  ObjectType regexpPrototype=REGEXP_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE,REGEXP_FUNCTION_TYPE);
  ObjectType REGEXP_TYPE=REGEXP_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.REGEXP_TYPE,REGEXP_TYPE);
  FunctionType STRING_OBJECT_FUNCTION_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createOptionalParameters(ALL_TYPE),STRING_TYPE),null,null,true,true);
  ObjectType stringPrototype=STRING_OBJECT_FUNCTION_TYPE.getPrototype();
  registerNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE,STRING_OBJECT_FUNCTION_TYPE);
  ObjectType STRING_OBJECT_TYPE=STRING_OBJECT_FUNCTION_TYPE.getInstanceType();
  registerNativeType(JSTypeNative.STRING_OBJECT_TYPE,STRING_OBJECT_TYPE);
  JSType NULL_VOID=createUnionType(NULL_TYPE,VOID_TYPE);
  registerNativeType(JSTypeNative.NULL_VOID,NULL_VOID);
  JSType OBJECT_NUMBER_STRING=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING,OBJECT_NUMBER_STRING);
  JSType OBJECT_NUMBER_STRING_BOOLEAN=createUnionType(OBJECT_TYPE,NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,OBJECT_NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING_BOOLEAN=createUnionType(NUMBER_TYPE,STRING_TYPE,BOOLEAN_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,NUMBER_STRING_BOOLEAN);
  JSType NUMBER_STRING=createUnionType(NUMBER_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.NUMBER_STRING,NUMBER_STRING);
  JSType STRING_VALUE_OR_OBJECT_TYPE=createUnionType(STRING_OBJECT_TYPE,STRING_TYPE);
  registerNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE,STRING_VALUE_OR_OBJECT_TYPE);
  JSType NUMBER_VALUE_OR_OBJECT_TYPE=createUnionType(NUMBER_OBJECT_TYPE,NUMBER_TYPE);
  registerNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE,NUMBER_VALUE_OR_OBJECT_TYPE);
  FunctionType U2U_FUNCTION_TYPE=createFunctionType(UNKNOWN_TYPE,true,UNKNOWN_TYPE);
  registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE,U2U_FUNCTION_TYPE);
  FunctionType U2U_CONSTRUCTOR_TYPE=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParametersWithVarArgs(UNKNOWN_TYPE),UNKNOWN_TYPE),UNKNOWN_TYPE,null,true,true){
    private static final long serialVersionUID=1L;
    @Override public FunctionType getConstructor(){
      return registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
    }
  }
;
  registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE,U2U_CONSTRUCTOR_TYPE);
  registerNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE,U2U_CONSTRUCTOR_TYPE);
  FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);
  U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);
  FunctionType LEAST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(NO_TYPE,ALL_TYPE);
  registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE,LEAST_FUNCTION_TYPE);
  FunctionType GLOBAL_THIS_CTOR=new FunctionType(this,""String_Node_Str"",null,createArrowType(createParameters(false,ALL_TYPE),NUMBER_TYPE),null,null,true,true);
  ObjectType GLOBAL_THIS=GLOBAL_THIS_CTOR.getInstanceType();
  registerNativeType(JSTypeNative.GLOBAL_THIS,GLOBAL_THIS);
  FunctionType GREATEST_FUNCTION_TYPE=createNativeFunctionTypeWithVarArgs(ALL_TYPE,NO_TYPE);
  registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,GREATEST_FUNCTION_TYPE);
  registerPropertyOnType(""String_Node_Str"",OBJECT_FUNCTION_TYPE);
}"
18662,"public void testGetElem(){
  testSame(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
}","public void testGetElem(){
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertType(""String_Node_Str"",getType(""String_Node_Str""));
}"
18663,"public void testParseOptionalModifier() throws Exception {
  JSDocInfo info=parse(""String_Node_Str"");
  assertTypeEquals(registry.createFunctionType(UNKNOWN_TYPE,createUnionType(VOID_TYPE,NUMBER_TYPE)),info.getType());
}","public void testParseOptionalModifier() throws Exception {
  JSDocInfo info=parse(""String_Node_Str"");
  assertTypeEquals(registry.createFunctionType(UNKNOWN_TYPE,registry.createOptionalParameters(NUMBER_TYPE)),info.getType());
}"
18664,"/** 
 * Computes the subset of   {@code this} and {@code that} types if equalityis observed. If a value  {@code v1} of type {@code null} is equal to a value{@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code null} and the type of {@code v2} is{@code undefined}.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderEquality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderEquality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (this.testForEquality(that)) {
case FALSE:
    return new TypePair(null,null);
case TRUE:
case UNKNOWN:
  return new TypePair(this,that);
}
throw new IllegalStateException();
}","/** 
 * Computes the subset of   {@code this} and {@code that} types if equalityis observed. If a value  {@code v1} of type {@code null} is equal to a value{@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code null} and the type of {@code v2} is{@code undefined}.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderEquality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderEquality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (testForEquality(that)) {
case FALSE:
    return new TypePair(null,null);
case TRUE:
case UNKNOWN:
  return new TypePair(this,that);
}
throw new IllegalStateException();
}"
18665,"/** 
 * A hash code function for diagnosing complicated issues around type-identity.
 */
public String toDebugHashCodeString(){
  return ""String_Node_Str"" + this.hashCode() + ""String_Node_Str"";
}","/** 
 * A hash code function for diagnosing complicated issues around type-identity.
 */
public String toDebugHashCodeString(){
  return ""String_Node_Str"" + hashCode() + ""String_Node_Str"";
}"
18666,"/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable. By meaningfully, we mean compatible types that do not lead to step 22 of the definition of the Abstract Equality Comparison Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */
public final boolean canTestForEqualityWith(JSType that){
  return this.testForEquality(that).equals(UNKNOWN);
}","/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable. By meaningfully, we mean compatible types that do not lead to step 22 of the definition of the Abstract Equality Comparison Algorithm (11.9.3, page 55&ndash;56) of the ECMA-262 specification.<p>
 */
public final boolean canTestForEqualityWith(JSType that){
  return testForEquality(that).equals(UNKNOWN);
}"
18667,"/** 
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */
public final boolean isNumber(){
  return this.isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}","/** 
 * Tests whether the type is a number (value or Object).
 * @return {@code this &lt;: (Number, number)}
 */
public final boolean isNumber(){
  return isSubtype(getNativeType(JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE));
}"
18668,"/** 
 * Returns true iff   {@code this} can be a {@code struct}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isStruct(){
  if (isObject()) {
    ObjectType objType=toObjectType();
    FunctionType ctor=objType.getConstructor();
    if (ctor == null) {
      JSDocInfo info=objType.getJSDocInfo();
      return info != null && info.makesStructs();
    }
 else {
      return ctor.makesStructs();
    }
  }
  return false;
}","/** 
 * Returns true iff   {@code this} can be a {@code struct}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isStruct(){
  if (isObject()) {
    ObjectType objType=toObjectType();
    ObjectType iproto=objType.getImplicitPrototype();
    if (iproto != null && iproto.isStruct()) {
      return true;
    }
    FunctionType ctor=objType.getConstructor();
    if (ctor == null) {
      JSDocInfo info=objType.getJSDocInfo();
      return info != null && info.makesStructs();
    }
 else {
      return ctor.makesStructs();
    }
  }
  return false;
}"
18669,"/** 
 * Computes the subset of   {@code this} and {@code that} types if inequalityis observed. If a value  {@code v1} of type {@code number} is not equal to avalue  {@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code number} and the type of {@code v2} is{@code number} as well.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (this.testForEquality(that)) {
case TRUE:
    JSType noType=getNativeType(JSTypeNative.NO_TYPE);
  return new TypePair(noType,noType);
case FALSE:
case UNKNOWN:
return new TypePair(this,that);
}
throw new IllegalStateException();
}","/** 
 * Computes the subset of   {@code this} and {@code that} types if inequalityis observed. If a value  {@code v1} of type {@code number} is not equal to avalue  {@code v2} of type {@code (undefined,number)}, we can infer that the type of   {@code v1} is {@code number} and the type of {@code v2} is{@code number} as well.
 * @return a pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
switch (testForEquality(that)) {
case TRUE:
    JSType noType=getNativeType(JSTypeNative.NO_TYPE);
  return new TypePair(noType,noType);
case FALSE:
case UNKNOWN:
return new TypePair(this,that);
}
throw new IllegalStateException();
}"
18670,"/** 
 * Returns true iff   {@code this} can be a {@code dict}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isDict(){
  if (isObject()) {
    FunctionType ctor=toObjectType().getConstructor();
    return ctor != null && ctor.makesDicts();
  }
  return false;
}","/** 
 * Returns true iff   {@code this} can be a {@code dict}. UnionType overrides the method, assume   {@code this} is not a union here.
 */
public boolean isDict(){
  if (isObject()) {
    ObjectType objType=toObjectType();
    ObjectType iproto=objType.getImplicitPrototype();
    if (iproto != null && iproto.isDict()) {
      return true;
    }
    FunctionType ctor=objType.getConstructor();
    return ctor != null && ctor.makesDicts();
  }
  return false;
}"
18671,"/** 
 * Tests whether this type is nullable.
 */
public boolean isNullable(){
  return this.isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}","/** 
 * Tests whether this type is nullable.
 */
public boolean isNullable(){
  return isSubtype(getNativeType(JSTypeNative.NULL_TYPE));
}"
18672,"/** 
 * Tests whether values of   {@code this} type can be safely assignedto values of  {@code that} type.<p>The default implementation verifies that  {@code this} is a subtypeof  {@code that}.<p>
 */
public boolean canAssignTo(JSType that){
  if (this.isSubtype(that)) {
    return true;
  }
  return false;
}","/** 
 * Tests whether values of   {@code this} type can be safely assignedto values of  {@code that} type.<p>The default implementation verifies that  {@code this} is a subtypeof  {@code that}.<p>
 */
public boolean canAssignTo(JSType that){
  return isSubtype(that);
}"
18673,"/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}","/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if (isNullType() && that.isNullType() || isVoidType() && that.isVoidType()) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}"
18674,"/** 
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that,EquivalenceMethod eqMethod){
  if (this == that) {
    return true;
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return this.toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod);
  }
  if (isRecordType() && that.isRecordType()) {
    return this.toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(),eqMethod);
  }
  ParameterizedType thisParamType=toMaybeParameterizedType();
  ParameterizedType thatParamType=that.toMaybeParameterizedType();
  if (thisParamType != null || thatParamType != null) {
    boolean paramsMatch=false;
    if (thisParamType != null && thatParamType != null) {
      paramsMatch=thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(),eqMethod);
    }
 else     if (eqMethod == EquivalenceMethod.IDENTITY) {
      paramsMatch=false;
    }
 else {
      paramsMatch=true;
    }
    JSType thisRootType=thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
    JSType thatRootType=thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
    return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType,eqMethod);
  }
  if (isNominalType() && that.isNominalType()) {
    return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod);
  }
  return this == that;
}","/** 
 * An equivalence visitor.
 */
boolean checkEquivalenceHelper(JSType that,EquivalenceMethod eqMethod){
  if (this == that) {
    return true;
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod);
  }
  if (isRecordType() && that.isRecordType()) {
    return toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(),eqMethod);
  }
  ParameterizedType thisParamType=toMaybeParameterizedType();
  ParameterizedType thatParamType=that.toMaybeParameterizedType();
  if (thisParamType != null || thatParamType != null) {
    boolean paramsMatch=false;
    if (thisParamType != null && thatParamType != null) {
      paramsMatch=thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(),eqMethod);
    }
 else     if (eqMethod == EquivalenceMethod.IDENTITY) {
      paramsMatch=false;
    }
 else {
      paramsMatch=true;
    }
    JSType thisRootType=thisParamType == null ? this : thisParamType.getReferencedTypeInternal();
    JSType thatRootType=thatParamType == null ? that : thatParamType.getReferencedTypeInternal();
    return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType,eqMethod);
  }
  if (isNominalType() && that.isNominalType()) {
    return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName());
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod);
  }
  return this == that;
}"
18675,"/** 
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */
public final boolean isString(){
  return this.isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}","/** 
 * Tests whether the type is a string (value or Object).
 * @return {@code this &lt;: (String, string)}
 */
public final boolean isString(){
  return isSubtype(getNativeType(JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE));
}"
18676,"/** 
 * Given the name of a native object property, checks whether the property is present on the object and different from the native one.
 */
private boolean hasOverridenNativeProperty(String propertyName){
  if (isNativeObjectType()) {
    return false;
  }
  JSType propertyType=getPropertyType(propertyName);
  ObjectType nativeType=this.isFunctionType() ? registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) : registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);
  JSType nativePropertyType=nativeType.getPropertyType(propertyName);
  return propertyType != nativePropertyType;
}","/** 
 * Given the name of a native object property, checks whether the property is present on the object and different from the native one.
 */
private boolean hasOverridenNativeProperty(String propertyName){
  if (isNativeObjectType()) {
    return false;
  }
  JSType propertyType=getPropertyType(propertyName);
  ObjectType nativeType=isFunctionType() ? registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE) : registry.getNativeObjectType(JSTypeNative.OBJECT_PROTOTYPE);
  JSType nativePropertyType=nativeType.getPropertyType(propertyName);
  return propertyType != nativePropertyType;
}"
18677,"@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isUnionType()) {
    return false;
  }
  if (that.isRecordType()) {
    return RecordType.isSubtype(this,that.toMaybeRecordType());
  }
  ObjectType thatObj=that.toObjectType();
  FunctionType thatCtor=thatObj == null ? null : thatObj.getConstructor();
  if (getConstructor() != null && getConstructor().isInterface()) {
    for (    ObjectType thisInterface : getCtorExtendedInterfaces()) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
 else   if (thatCtor != null && thatCtor.isInterface()) {
    Iterable<ObjectType> thisInterfaces=getCtorImplementedInterfaces();
    for (    ObjectType thisInterface : thisInterfaces) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
    return true;
  }
  return thatObj != null && this.isImplicitPrototype(thatObj);
}","@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isUnionType()) {
    return false;
  }
  if (that.isRecordType()) {
    return RecordType.isSubtype(this,that.toMaybeRecordType());
  }
  ObjectType thatObj=that.toObjectType();
  FunctionType thatCtor=thatObj == null ? null : thatObj.getConstructor();
  if (getConstructor() != null && getConstructor().isInterface()) {
    for (    ObjectType thisInterface : getCtorExtendedInterfaces()) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
 else   if (thatCtor != null && thatCtor.isInterface()) {
    Iterable<ObjectType> thisInterfaces=getCtorImplementedInterfaces();
    for (    ObjectType thisInterface : thisInterfaces) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
    return true;
  }
  return thatObj != null && isImplicitPrototype(thatObj);
}"
18678,"/** 
 * Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo.
 */
FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info){
  if (info != null) {
    isConstructor=info.isConstructor();
    makesStructs=info.makesStructs();
    makesDicts=info.makesDicts();
    isInterface=info.isInterface();
    if (makesStructs && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
 else     if (makesDicts && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
    if (info.hasBaseType()) {
      if (isConstructor) {
        JSType maybeBaseType=info.getBaseType().evaluate(scope,typeRegistry);
        if (maybeBaseType != null && maybeBaseType.setValidator(new ExtendedTypeValidator())) {
          baseType=(ObjectType)maybeBaseType;
        }
      }
 else {
        reportWarning(EXTENDS_WITHOUT_TYPEDEF,fnName);
      }
    }
    if (isConstructor || isInterface) {
      implementedInterfaces=Lists.newArrayList();
      for (      JSTypeExpression t : info.getImplementedInterfaces()) {
        JSType maybeInterType=t.evaluate(scope,typeRegistry);
        if (maybeInterType != null && maybeInterType.setValidator(new ImplementedTypeValidator())) {
          implementedInterfaces.add((ObjectType)maybeInterType);
        }
      }
    }
 else     if (info.getImplementedInterfaceCount() > 0) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
    if (isInterface) {
      extendedInterfaces=Lists.newArrayList();
      for (      JSTypeExpression t : info.getExtendedInterfaces()) {
        JSType maybeInterfaceType=t.evaluate(scope,typeRegistry);
        if (maybeInterfaceType != null && maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {
          extendedInterfaces.add((ObjectType)maybeInterfaceType);
        }
      }
    }
  }
  return this;
}","/** 
 * Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo.
 */
FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info){
  if (info != null) {
    isConstructor=info.isConstructor();
    makesStructs=info.makesStructs();
    makesDicts=info.makesDicts();
    isInterface=info.isInterface();
    if (makesStructs && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
 else     if (makesDicts && !isConstructor) {
      reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
    }
    if (info.hasBaseType()) {
      if (isConstructor) {
        JSType maybeBaseType=info.getBaseType().evaluate(scope,typeRegistry);
        if (maybeBaseType != null && maybeBaseType.setValidator(new ExtendedTypeValidator())) {
          baseType=(ObjectType)maybeBaseType;
        }
      }
 else {
        reportWarning(EXTENDS_WITHOUT_TYPEDEF,fnName);
      }
    }
    if (info.getImplementedInterfaceCount() > 0) {
      if (isConstructor) {
        implementedInterfaces=Lists.newArrayList();
        for (        JSTypeExpression t : info.getImplementedInterfaces()) {
          JSType maybeInterType=t.evaluate(scope,typeRegistry);
          if (maybeInterType != null && maybeInterType.setValidator(new ImplementedTypeValidator())) {
            implementedInterfaces.add((ObjectType)maybeInterType);
          }
        }
      }
 else       if (isInterface) {
        reportWarning(TypeCheck.CONFLICTING_IMPLEMENTED_TYPE,fnName);
      }
 else {
        reportWarning(CONSTRUCTOR_REQUIRED,""String_Node_Str"",fnName);
      }
    }
    if (isInterface) {
      extendedInterfaces=Lists.newArrayList();
      for (      JSTypeExpression t : info.getExtendedInterfaces()) {
        JSType maybeInterfaceType=t.evaluate(scope,typeRegistry);
        if (maybeInterfaceType != null && maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {
          extendedInterfaces.add((ObjectType)maybeInterfaceType);
        }
      }
    }
  }
  return this;
}"
18679,"/** 
 * Visits a   {@link Token#FUNCTION} node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitFunction(NodeTraversal t,Node n){
  FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getSuperClassConstructor();
    if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null && baseConstructor.isInterface() && functionType.isConstructor()) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
    }
 else {
      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null) {
        if (functionType.makesStructs() && !baseConstructor.makesStructs()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
 else         if (functionType.makesDicts() && !baseConstructor.makesDicts()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
      }
      for (      JSType baseInterface : functionType.getImplementedInterfaces()) {
        boolean badImplementedType=false;
        ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
        if (baseInterfaceObj != null) {
          FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
          if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
            badImplementedType=true;
          }
        }
 else {
          badImplementedType=true;
        }
        if (badImplementedType) {
          report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
        }
      }
      validator.expectAllInterfaceProperties(t,n,functionType);
    }
  }
 else   if (functionType.isInterface()) {
    for (    ObjectType extInterface : functionType.getExtendedInterfaces()) {
      if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) {
        compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
      }
    }
    if (functionType.hasImplementedInterfaces()) {
      compiler.report(t.makeError(n,CONFLICTING_IMPLEMENTED_TYPE,functionPrivateName));
    }
    if (functionType.getExtendedInterfacesCount() > 1) {
      HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
      HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
      for (      ObjectType interfaceType : functionType.getExtendedInterfaces()) {
        currentProperties.clear();
        checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
        properties.putAll(currentProperties);
      }
    }
  }
}","/** 
 * Visits a   {@link Token#FUNCTION} node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitFunction(NodeTraversal t,Node n){
  FunctionType functionType=JSType.toMaybeFunctionType(n.getJSType());
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getSuperClassConstructor();
    if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null && baseConstructor.isInterface() && functionType.isConstructor()) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
    }
 else {
      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && baseConstructor != null) {
        if (functionType.makesStructs() && !baseConstructor.makesStructs()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
 else         if (functionType.makesDicts() && !baseConstructor.makesDicts()) {
          compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
        }
      }
      for (      JSType baseInterface : functionType.getImplementedInterfaces()) {
        boolean badImplementedType=false;
        ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
        if (baseInterfaceObj != null) {
          FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
          if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
            badImplementedType=true;
          }
        }
 else {
          badImplementedType=true;
        }
        if (badImplementedType) {
          report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
        }
      }
      validator.expectAllInterfaceProperties(t,n,functionType);
    }
  }
 else   if (functionType.isInterface()) {
    for (    ObjectType extInterface : functionType.getExtendedInterfaces()) {
      if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) {
        compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,""String_Node_Str"",functionPrivateName));
      }
    }
    if (functionType.getExtendedInterfacesCount() > 1) {
      HashMap<String,ObjectType> properties=new HashMap<String,ObjectType>();
      HashMap<String,ObjectType> currentProperties=new HashMap<String,ObjectType>();
      for (      ObjectType interfaceType : functionType.getExtendedInterfaces()) {
        currentProperties.clear();
        checkInterfaceConflictProperties(t,n,functionPrivateName,properties,currentProperties,interfaceType);
        properties.putAll(currentProperties);
      }
    }
  }
}"
18680,"public void setImplementedInterfaces(List<ObjectType> implementedInterfaces){
  for (  ObjectType type : implementedInterfaces) {
    registry.registerTypeImplementingInterface(this,type);
  }
  this.implementedInterfaces=ImmutableList.copyOf(implementedInterfaces);
}","public void setImplementedInterfaces(List<ObjectType> implementedInterfaces){
  if (isConstructor()) {
    for (    ObjectType type : implementedInterfaces) {
      registry.registerTypeImplementingInterface(this,type);
    }
    this.implementedInterfaces=ImmutableList.copyOf(implementedInterfaces);
  }
 else {
    throw new UnsupportedOperationException();
  }
}"
18681,"private void addExpr(Node n,int minPrecedence,Context context){
  if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && (n.isIn()))) {
    add(""String_Node_Str"");
    add(n,clearContextForNoInOperator(context));
    add(""String_Node_Str"");
  }
 else {
    add(n,context);
  }
}","private void addExpr(Node n,int minPrecedence,Context context){
  if ((NodeUtil.precedence(n.getType()) < minPrecedence) || ((context == Context.IN_FOR_INIT_CLAUSE) && n.isIn())) {
    add(""String_Node_Str"");
    add(n,Context.OTHER);
    add(""String_Node_Str"");
  }
 else {
    add(n,context);
  }
}"
18682,"public void testObjectLit(){
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}","public void testObjectLit(){
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}"
18683,"/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.NAME:
    typeable=visitName(t,n,parent);
  break;
case Token.PARAM_LIST:
if (!parent.isFunction()) {
  ensureTyped(t,n,getJSType(n.getFirstChild()));
}
 else {
  typeable=false;
}
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.STRING_KEY:
typeable=false;
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
typeable=true;
break;
case Token.CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,""String_Node_Str"");
validator.expectString(t,left,leftType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
for (Node key : n.children()) {
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}","/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.NAME:
    typeable=visitName(t,n,parent);
  break;
case Token.PARAM_LIST:
if (!parent.isFunction()) {
  ensureTyped(t,n,getJSType(n.getFirstChild()));
}
 else {
  typeable=false;
}
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.STRING_KEY:
typeable=false;
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
typeable=true;
break;
case Token.CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,""String_Node_Str"");
validator.expectString(t,left,leftType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
for (Node key : n.children()) {
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}"
18684,"private void traverse(Node node){
  if (!shouldVisit(node)) {
    return;
  }
  int visits=0;
  do {
    for (Node c=node.getFirstChild(); c != null; c=c.getNext()) {
      traverse(c);
    }
    visit(node);
    visits++;
    Preconditions.checkState(visits < 10000,""String_Node_Str"");
  }
 while (shouldRetraverse(node));
  exitNode(node);
}","private void traverse(Node node){
  if (!shouldVisit(node)) {
    return;
  }
  int visits=0;
  do {
    Node c=node.getFirstChild();
    while (c != null) {
      Node next=c.getNext();
      traverse(c);
      c=next;
    }
    visit(node);
    visits++;
    Preconditions.checkState(visits < 10000,""String_Node_Str"");
  }
 while (shouldRetraverse(node));
  exitNode(node);
}"
18685,"public void testSuppressEs5StrictWarning(){
  CompilerOptions options=createCompilerOptions();
  options.setWarningLevel(DiagnosticGroups.ES5_STRICT,CheckLevel.WARNING);
  testSame(options,""String_Node_Str"" + ""String_Node_Str"");
}","public void testSuppressEs5StrictWarning(){
  CompilerOptions options=createCompilerOptions();
  options.setWarningLevel(DiagnosticGroups.ES5_STRICT,CheckLevel.WARNING);
  test(options,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}"
18686,"public void testVarDeclarationsIntoFor(){
  CompilerOptions options=createCompilerOptions();
  options.collapseVariableDeclarations=false;
  String code=""String_Node_Str"";
  testSame(options,code);
  options.collapseVariableDeclarations=false;
  test(options,code,""String_Node_Str"");
}","public void testVarDeclarationsIntoFor(){
  CompilerOptions options=createCompilerOptions();
  options.collapseVariableDeclarations=false;
  String code=""String_Node_Str"";
  testSame(options,code);
  options.collapseVariableDeclarations=true;
  test(options,code,""String_Node_Str"");
}"
18687,"protected Node parse(String[] original,CompilerOptions options){
  Compiler compiler=new Compiler();
  List<SourceFile> inputs=Lists.newArrayList();
  for (int i=0; i < original.length; i++) {
    inputs.add(SourceFile.fromCode(""String_Node_Str"" + i,original[i]));
  }
  compiler.init(externs,inputs,options);
  checkUnexpectedErrorsOrWarnings(compiler,0);
  Node all=compiler.parseInputs();
  checkUnexpectedErrorsOrWarnings(compiler,0);
  Node n=all.getLastChild();
  Node externs=all.getFirstChild();
  (new CreateSyntheticBlocks(compiler,""String_Node_Str"",""String_Node_Str"")).process(externs,n);
  (new Normalize(compiler,false)).process(externs,n);
  (MakeDeclaredNamesUnique.getContextualRenameInverter(compiler)).process(externs,n);
  (new Denormalize(compiler)).process(externs,n);
  return n;
}","protected Node parse(String[] original,CompilerOptions options){
  Compiler compiler=new Compiler();
  List<SourceFile> inputs=Lists.newArrayList();
  for (int i=0; i < original.length; i++) {
    inputs.add(SourceFile.fromCode(""String_Node_Str"" + i,original[i]));
  }
  compiler.init(externs,inputs,options);
  checkUnexpectedErrorsOrWarnings(compiler,0);
  Node all=compiler.parseInputs();
  checkUnexpectedErrorsOrWarnings(compiler,0);
  Node n=all.getLastChild();
  Node externs=all.getFirstChild();
  (new CreateSyntheticBlocks(compiler,""String_Node_Str"",""String_Node_Str"")).process(externs,n);
  return n;
}"
18688,"Candidate(String varName,Node defCfgNode,Node use,Node useCfgNode){
  Preconditions.checkArgument(use.isName());
  this.varName=varName;
  this.defCfgNode=defCfgNode;
  this.use=use;
  this.useCfgNode=useCfgNode;
}","Candidate(String varName,Definition defMetadata,Node use,Node useCfgNode){
  Preconditions.checkArgument(use.isName());
  this.varName=varName;
  this.defMetadata=defMetadata;
  this.use=use;
  this.useCfgNode=useCfgNode;
}"
18689,"private boolean canInline(){
  if (defCfgNode.isFunction()) {
    return false;
  }
  getDefinition(defCfgNode,null);
  getNumUseInUseCfgNode(useCfgNode,null);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkRightOf(def,defCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkLeftOf(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {
    return false;
  }
  if (numUseWithinUseCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,defCfgNode);
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getType()) {
case Token.GETELEM:
case Token.GETPROP:
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
case Token.NEW:
        return true;
    }
    return false;
  }
}
,new Predicate<Node>(){
  @Override public boolean apply(  Node input){
    return !input.isFunction();
  }
}
)) {
  return false;
}
if (NodeUtil.isStatementBlock(defCfgNode.getParent()) && defCfgNode.getNext() != useCfgNode) {
  CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch>(cfg,cfg.getDirectedGraphNode(defCfgNode),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
  if (pathCheck.somePathsSatisfyPredicate()) {
    return false;
  }
}
return true;
}","private boolean canInline(){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  for (  Var dependency : defMetadata.depends) {
    if (inlinedNewDependencies.contains(dependency)) {
      return false;
    }
  }
  getDefinition(getDefCfgNode(),null);
  getNumUseInUseCfgNode(useCfgNode,null);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkRightOf(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkLeftOf(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {
    return false;
  }
  if (numUseWithinUseCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getType()) {
case Token.GETELEM:
case Token.GETPROP:
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
case Token.NEW:
        return true;
    }
    return false;
  }
}
,new Predicate<Node>(){
  @Override public boolean apply(  Node input){
    return !input.isFunction();
  }
}
)) {
  return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
  CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
  if (pathCheck.somePathsSatisfyPredicate()) {
    return false;
  }
}
return true;
}"
18690,"@Override public void enterScope(NodeTraversal t){
  if (t.inGlobalScope()) {
    return;
  }
  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {
    return;
  }
  ControlFlowAnalysis cfa=new ControlFlowAnalysis(compiler,false,true);
  Preconditions.checkState(t.getScopeRoot().isFunction());
  cfa.process(null,t.getScopeRoot().getLastChild());
  cfg=cfa.getCfg();
  reachingDef=new MustBeReachingVariableDef(cfg,t.getScope(),compiler);
  reachingDef.analyze();
  candidates=Lists.newLinkedList();
  new NodeTraversal(compiler,new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());
  reachingUses=new MaybeReachingVariableUse(cfg,t.getScope(),compiler);
  reachingUses.analyze();
  for (  Candidate c : candidates) {
    if (c.canInline()) {
      c.inlineVariable();
    }
  }
}","@Override public void enterScope(NodeTraversal t){
  if (t.inGlobalScope()) {
    return;
  }
  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {
    return;
  }
  ControlFlowAnalysis cfa=new ControlFlowAnalysis(compiler,false,true);
  Preconditions.checkState(t.getScopeRoot().isFunction());
  cfa.process(null,t.getScopeRoot().getLastChild());
  cfg=cfa.getCfg();
  reachingDef=new MustBeReachingVariableDef(cfg,t.getScope(),compiler);
  reachingDef.analyze();
  candidates=Lists.newLinkedList();
  new NodeTraversal(compiler,new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());
  reachingUses=new MaybeReachingVariableUse(cfg,t.getScope(),compiler);
  reachingUses.analyze();
  for (  Candidate c : candidates) {
    if (c.canInline()) {
      c.inlineVariable();
      if (!c.defMetadata.depends.isEmpty()) {
        inlinedNewDependencies.add(t.getScope().getVar(c.varName));
      }
    }
  }
}"
18691,"/** 
 * Gets the must reaching definition of a given node. The node must be one of the control flow graph nodes.
 * @param name name of the variable. It can only be names of local variablethat are not function parameters, escaped variables or variables declared in catch.
 * @param useNode the location of the use where the definition reaches.
 */
Node getDef(String name,Node useNode){
  Preconditions.checkArgument(getCfg().hasNode(useNode));
  GraphNode<Node,Branch> n=getCfg().getNode(useNode);
  FlowState<MustDef> state=n.getAnnotation();
  Definition def=state.getIn().reachingDef.get(jsScope.getVar(name));
  if (def == null) {
    return null;
  }
 else {
    return def.node;
  }
}","/** 
 * Gets the must reaching definition of a given node.
 * @param name name of the variable. It can only be names of local variablethat are not function parameters, escaped variables or variables declared in catch.
 * @param useNode the location of the use where the definition reaches.
 */
Definition getDef(String name,Node useNode){
  Preconditions.checkArgument(getCfg().hasNode(useNode));
  GraphNode<Node,Branch> n=getCfg().getNode(useNode);
  FlowState<MustDef> state=n.getAnnotation();
  return state.getIn().reachingDef.get(jsScope.getVar(name));
}"
18692,"boolean dependsOnOuterScopeVars(String name,Node useNode){
  Preconditions.checkArgument(getCfg().hasNode(useNode));
  GraphNode<Node,Branch> n=getCfg().getNode(useNode);
  FlowState<MustDef> state=n.getAnnotation();
  Definition def=state.getIn().reachingDef.get(jsScope.getVar(name));
  if (def.unknownDependencies) {
    return true;
  }
  for (  Var s : def.depends) {
    if (s.scope != jsScope) {
      return true;
    }
  }
  return false;
}","boolean dependsOnOuterScopeVars(Definition def){
  if (def.unknownDependencies) {
    return true;
  }
  for (  Var s : def.depends) {
    if (s.scope != jsScope) {
      return true;
    }
  }
  return false;
}"
18693,"public void testFunctionParams1(){
  computeDefUse(""String_Node_Str"");
  assertSame(def,defUse.getDef(""String_Node_Str"",use));
}","public void testFunctionParams1(){
  computeDefUse(""String_Node_Str"");
  assertSame(def,defUse.getDefNode(""String_Node_Str"",use));
}"
18694,"public void testFunctionParams2(){
  computeDefUse(""String_Node_Str"");
  assertNotSame(def,defUse.getDef(""String_Node_Str"",use));
}","public void testFunctionParams2(){
  computeDefUse(""String_Node_Str"");
  assertNotSame(def,defUse.getDefNode(""String_Node_Str"",use));
}"
18695,"/** 
 * The use of x at U: is the definition of x at D:.
 */
private void assertMatch(String src){
  computeDefUse(src);
  assertSame(def,defUse.getDef(""String_Node_Str"",use));
}","/** 
 * The use of x at U: is the definition of x at D:.
 */
private void assertMatch(String src){
  computeDefUse(src);
  assertSame(def,defUse.getDefNode(""String_Node_Str"",use));
}"
18696,"public void testArgumentsObjectEscaped(){
  computeDefUse(""String_Node_Str"");
  assertNotSame(def,defUse.getDef(""String_Node_Str"",use));
}","public void testArgumentsObjectEscaped(){
  computeDefUse(""String_Node_Str"");
  assertNotSame(def,defUse.getDefNode(""String_Node_Str"",use));
}"
18697,"/** 
 * The use of x at U: is not the definition of x at D:.
 */
private void assertNotMatch(String src){
  computeDefUse(src);
  assertNotSame(def,defUse.getDef(""String_Node_Str"",use));
}","/** 
 * The use of x at U: is not the definition of x at D:.
 */
private void assertNotMatch(String src){
  computeDefUse(src);
  assertNotSame(def,defUse.getDefNode(""String_Node_Str"",use));
}"
18698,"public void testArgumentsObjectModifications(){
  computeDefUse(""String_Node_Str"");
  assertNotSame(def,defUse.getDef(""String_Node_Str"",use));
}","public void testArgumentsObjectModifications(){
  computeDefUse(""String_Node_Str"");
  assertNotSame(def,defUse.getDefNode(""String_Node_Str"",use));
}"
18699,"@Override public void addDeclaredName(String name){
  Preconditions.checkState(!name.equals(ARGUMENTS));
  if (!declarations.containsKey(name)) {
    declarations.put(name,getUniqueName(name));
  }
}","@Override public void addDeclaredName(String name){
  if (whitelist.contains(name)) {
    delegate.addDeclaredName(name);
  }
}"
18700,"@Override public String getReplacementName(String oldName){
  return declarations.get(oldName);
}","@Override public String getReplacementName(String oldName){
  return whitelist.contains(oldName) ? delegate.getReplacementName(oldName) : null;
}"
18701,"@Override public boolean stripConstIfReplaced(){
  return removeConstness;
}","@Override public boolean stripConstIfReplaced(){
  return delegate.stripConstIfReplaced();
}"
18702,"@Override public Renamer forChildScope(){
  return new InlineRenamer(uniqueIdSupplier,idPrefix,false);
}","@Override public Renamer forChildScope(){
  return new WhitelistedRenamer(delegate.forChildScope(),whitelist);
}"
18703,"private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    int type=n.getType();
    Node parent=n.getParent();
    if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) {
      String name=n.getString();
      Var aliasVar=scope.getVar(name);
      aliases.put(name,aliasVar);
      String qualifiedName=aliasVar.getInitialValue().getQualifiedName();
      transformation.addAlias(name,qualifiedName);
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}","private void findAliases(NodeTraversal t){
  Scope scope=t.getScope();
  for (  Var v : scope.getVarIterable()) {
    Node n=v.getNode();
    int type=n.getType();
    Node parent=n.getParent();
    if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) {
      String name=n.getString();
      Var aliasVar=scope.getVar(name);
      aliases.put(name,aliasVar);
      String qualifiedName=aliasVar.getInitialValue().getQualifiedName();
      transformation.addAlias(name,qualifiedName);
      int rootIndex=qualifiedName.indexOf(""String_Node_Str"");
      if (rootIndex != -1) {
        String qNameRoot=qualifiedName.substring(0,rootIndex);
        if (!aliases.containsKey(qNameRoot)) {
          forbiddenLocals.add(qNameRoot);
        }
      }
    }
 else     if (v.isBleedingFunction()) {
    }
 else     if (parent.getType() == Token.LP) {
    }
 else {
      report(t,n,GOOG_SCOPE_NON_ALIAS_LOCAL,n.getString());
    }
  }
}"
18704,"@Override public void exitScope(NodeTraversal t){
  if (t.getScopeDepth() == 2) {
    aliases.clear();
    transformation=null;
  }
}","@Override public void exitScope(NodeTraversal t){
  if (t.getScopeDepth() > 2) {
    findNamespaceShadows(t);
  }
  if (t.getScopeDepth() == 2) {
    renameNamespaceShadows(t);
    aliases.clear();
    forbiddenLocals.clear();
    transformation=null;
    hasNamespaceShadows=false;
  }
}"
18705,"/** 
 * @param iterator The to use while inspecting the nodebeginning with the deepest ancestor.
 */
private LocalVarMotion(Node nameNode,FunctionlessLocalScope iterator){
  Preconditions.checkArgument(nameNode.isName());
  Node valueNode=NodeUtil.getAssignedValue(nameNode);
  this.varName=nameNode.getString();
  this.valueHasSideEffects=valueNode != null && NodeUtil.mayHaveSideEffects(valueNode);
  this.iterator=iterator;
  advanceLookAhead(true);
}","/** 
 * @param iterator The iterator to use while inspecting the nodebeginning with the deepest ancestor.
 */
private LocalVarMotion(Node nameNode,FunctionlessLocalScope iterator){
  Preconditions.checkArgument(nameNode.isName());
  Node valueNode=NodeUtil.getAssignedValue(nameNode);
  this.varName=nameNode.getString();
  this.valueHasSideEffects=valueNode != null && NodeUtil.mayHaveSideEffects(valueNode);
  this.iterator=iterator;
  advanceLookAhead(true);
}"
18706,"private void advanceLookAhead(boolean atStart){
  if (!atStart) {
    if (lookAhead == null) {
      return;
    }
    Node curNode=iterator.current();
    if (curNode.isName() && varName.equals(curNode.getString())) {
      lookAhead=null;
      return;
    }
  }
  if (!iterator.hasNext()) {
    lookAhead=null;
    return;
  }
  Node nextNode=iterator.next();
  Node nextParent=iterator.currentParent();
  int type=nextNode.getType();
  if (valueHasSideEffects) {
    if (type == Token.NAME && !varName.equals(nextNode.getString())) {
      boolean blocked=false;
      if (nextParent == null) {
        blocked=true;
      }
 else {
        boolean assignsName=(nextParent.isAssign() && nextNode == nextParent.getFirstChild());
        boolean isVarDeclaration=(nextParent.isVar());
        if (!assignsName && !isVarDeclaration) {
          blocked=true;
        }
      }
      if (blocked) {
        lookAhead=null;
        return;
      }
    }
  }
  if (NodeUtil.nodeTypeMayHaveSideEffects(nextNode) && type != Token.NAME || type == Token.NAME && nextParent.isCatch()) {
    lookAhead=null;
    return;
  }
  lookAhead=nextNode;
}","private void advanceLookAhead(boolean atStart){
  if (!atStart) {
    if (lookAhead == null) {
      return;
    }
    Node curNode=iterator.current();
    if (curNode.isName() && varName.equals(curNode.getString())) {
      lookAhead=null;
      return;
    }
  }
  if (!iterator.hasNext()) {
    lookAhead=null;
    return;
  }
  Node nextNode=iterator.next();
  Node nextParent=iterator.currentParent();
  int type=nextNode.getType();
  if (valueHasSideEffects) {
    boolean readsState=false;
    if ((nextNode.isName() && !varName.equals(nextNode.getString())) || (nextNode.isGetProp() || nextNode.isGetElem())) {
      if (nextParent == null || !NodeUtil.isVarOrSimpleAssignLhs(nextNode,nextParent)) {
        readsState=true;
      }
    }
 else     if (nextNode.isCall() || nextNode.isNew()) {
      readsState=true;
    }
    if (readsState) {
      lookAhead=null;
      return;
    }
  }
  if (NodeUtil.nodeTypeMayHaveSideEffects(nextNode) && type != Token.NAME || type == Token.NAME && nextParent.isCatch()) {
    lookAhead=null;
    return;
  }
  lookAhead=nextNode;
}"
18707,"/** 
 * Returns a   {@code CompilerEnvirons} suitable for using Rhinoin an IDE environment.  Most features are enabled by default. The  {@link ErrorReporter} is set to an {@link ErrorCollector}.
 */
public static CompilerEnvirons ideEnvirons(){
  CompilerEnvirons env=new CompilerEnvirons();
  env.setRecoverFromErrors(true);
  env.setRecordingComments(true);
  env.setStrictMode(true);
  env.setWarnTrailingComma(true);
  env.setLanguageVersion(170);
  env.setReservedKeywordAsIdentifier(true);
  env.setAllowKeywordAsObjectPropertyName(true);
  env.setIdeMode(true);
  env.setErrorReporter(new ErrorCollector());
  return env;
}","/** 
 * Returns a   {@code CompilerEnvirons} suitable for using Rhinoin an IDE environment.  Most features are enabled by default. The  {@link ErrorReporter} is set to an {@link ErrorCollector}.
 */
public static CompilerEnvirons ideEnvirons(){
  CompilerEnvirons env=new CompilerEnvirons();
  env.setRecoverFromErrors(true);
  env.setRecordingComments(true);
  env.setStrictMode(true);
  env.setWarnTrailingComma(true);
  env.setLanguageVersion(170);
  env.setReservedKeywordAsIdentifier(true);
  env.setIdeMode(true);
  env.setErrorReporter(new ErrorCollector());
  return env;
}"
18708,"public CompilerEnvirons(){
  errorReporter=DefaultErrorReporter.instance;
  languageVersion=Context.VERSION_DEFAULT;
  generateDebugInfo=true;
  reservedKeywordAsIdentifier=true;
  allowKeywordAsObjectPropertyName=false;
  allowMemberExprAsFunctionName=false;
  xmlAvailable=true;
  optimizationLevel=0;
  generatingSource=true;
  strictMode=false;
  warningAsError=false;
  generateObserverCount=false;
  allowSharpComments=false;
}","public CompilerEnvirons(){
  errorReporter=DefaultErrorReporter.instance;
  languageVersion=Context.VERSION_DEFAULT;
  generateDebugInfo=true;
  reservedKeywordAsIdentifier=true;
  allowMemberExprAsFunctionName=false;
  xmlAvailable=true;
  optimizationLevel=0;
  generatingSource=true;
  strictMode=false;
  warningAsError=false;
  generateObserverCount=false;
  allowSharpComments=false;
}"
18709,"public void initFromContext(Context cx){
  setErrorReporter(cx.getErrorReporter());
  languageVersion=cx.getLanguageVersion();
  generateDebugInfo=(!cx.isGeneratingDebugChanged() || cx.isGeneratingDebug());
  reservedKeywordAsIdentifier=cx.hasFeature(Context.FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER);
  allowKeywordAsObjectPropertyName=(languageVersion >= Context.VERSION_1_8);
  allowMemberExprAsFunctionName=cx.hasFeature(Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME);
  strictMode=cx.hasFeature(Context.FEATURE_STRICT_MODE);
  warningAsError=cx.hasFeature(Context.FEATURE_WARNING_AS_ERROR);
  xmlAvailable=cx.hasFeature(Context.FEATURE_E4X);
  optimizationLevel=cx.getOptimizationLevel();
  generatingSource=cx.isGeneratingSource();
  activationNames=cx.activationNames;
  generateObserverCount=cx.generateObserverCount;
}","public void initFromContext(Context cx){
  setErrorReporter(cx.getErrorReporter());
  languageVersion=cx.getLanguageVersion();
  generateDebugInfo=(!cx.isGeneratingDebugChanged() || cx.isGeneratingDebug());
  reservedKeywordAsIdentifier=cx.hasFeature(Context.FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER);
  allowMemberExprAsFunctionName=cx.hasFeature(Context.FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME);
  strictMode=cx.hasFeature(Context.FEATURE_STRICT_MODE);
  warningAsError=cx.hasFeature(Context.FEATURE_WARNING_AS_ERROR);
  xmlAvailable=cx.hasFeature(Context.FEATURE_E4X);
  optimizationLevel=cx.getOptimizationLevel();
  generatingSource=cx.isGeneratingSource();
  activationNames=cx.activationNames;
  generateObserverCount=cx.generateObserverCount;
}"
18710,"private ObjectLiteral objectLiteral() throws IOException {
  int pos=ts.tokenBeg, lineno=ts.lineno;
  int afterComma=-1;
  List<ObjectProperty> elems=new ArrayList<ObjectProperty>();
  Set<String> getterNames=null;
  Set<String> setterNames=null;
  if (this.inUseStrictDirective) {
    getterNames=new HashSet<String>();
    setterNames=new HashSet<String>();
  }
  Comment objJsdocNode=getAndResetJsDoc();
  commaLoop:   for (; ; ) {
    String propertyName=null;
    int entryKind=PROP_ENTRY;
    int tt=peekToken();
    Comment jsdocNode=getAndResetJsDoc();
switch (tt) {
case Token.NAME:
      afterComma=-1;
    Name name=createNameNode();
  propertyName=ts.getString();
int ppos=ts.tokenBeg;
consumeToken();
if ((peekToken() != Token.COLON && (""String_Node_Str"".equals(propertyName) || ""String_Node_Str"".equals(propertyName)))) {
boolean isGet=""String_Node_Str"".equals(propertyName);
entryKind=isGet ? GET_ENTRY : SET_ENTRY;
AstNode pname=objliteralProperty();
if (pname == null) {
propertyName=null;
}
 else {
propertyName=ts.getString();
ObjectProperty objectProp=getterSetterProperty(ppos,pname,isGet);
pname.setJsDocNode(jsdocNode);
elems.add(objectProp);
}
}
 else {
AstNode pname=name;
pname.setJsDocNode(jsdocNode);
elems.add(plainProperty(pname,tt));
}
break;
case Token.RC:
if (afterComma != -1) warnTrailingComma(pos,elems,afterComma);
break commaLoop;
default :
AstNode pname=objliteralProperty();
if (pname == null) {
propertyName=null;
}
 else {
afterComma=-1;
propertyName=ts.getString();
pname.setJsDocNode(jsdocNode);
elems.add(plainProperty(pname,tt));
}
break;
}
if (this.inUseStrictDirective && propertyName != null) {
switch (entryKind) {
case PROP_ENTRY:
if (getterNames.contains(propertyName) || setterNames.contains(propertyName)) {
addError(""String_Node_Str"",propertyName);
}
getterNames.add(propertyName);
setterNames.add(propertyName);
break;
case GET_ENTRY:
if (getterNames.contains(propertyName)) {
addError(""String_Node_Str"",propertyName);
}
getterNames.add(propertyName);
break;
case SET_ENTRY:
if (setterNames.contains(propertyName)) {
addError(""String_Node_Str"",propertyName);
}
setterNames.add(propertyName);
break;
}
}
getAndResetJsDoc();
jsdocNode=null;
if (matchToken(Token.COMMA)) {
afterComma=ts.tokenEnd;
}
 else {
break commaLoop;
}
}
mustMatchToken(Token.RC,""String_Node_Str"");
ObjectLiteral pn=new ObjectLiteral(pos,ts.tokenEnd - pos);
if (objJsdocNode != null) {
pn.setJsDocNode(objJsdocNode);
}
pn.setElements(elems);
pn.setLineno(lineno);
return pn;
}","private ObjectLiteral objectLiteral() throws IOException {
  int pos=ts.tokenBeg, lineno=ts.lineno;
  int afterComma=-1;
  List<ObjectProperty> elems=new ArrayList<ObjectProperty>();
  Set<String> getterNames=null;
  Set<String> setterNames=null;
  if (this.inUseStrictDirective) {
    getterNames=new HashSet<String>();
    setterNames=new HashSet<String>();
  }
  Comment objJsdocNode=getAndResetJsDoc();
  commaLoop:   for (; ; ) {
    String propertyName=null;
    int entryKind=PROP_ENTRY;
    int tt=peekToken();
    Comment jsdocNode=getAndResetJsDoc();
switch (tt) {
case Token.NAME:
      afterComma=-1;
    Name name=createNameNode();
  propertyName=ts.getString();
int ppos=ts.tokenBeg;
consumeToken();
int peeked=peekToken();
boolean maybeGetterOrSetter=""String_Node_Str"".equals(propertyName) || ""String_Node_Str"".equals(propertyName);
if (maybeGetterOrSetter && peeked != Token.COMMA && peeked != Token.COLON && peeked != Token.RC) {
boolean isGet=""String_Node_Str"".equals(propertyName);
entryKind=isGet ? GET_ENTRY : SET_ENTRY;
AstNode pname=objliteralProperty();
if (pname == null) {
propertyName=null;
}
 else {
propertyName=ts.getString();
ObjectProperty objectProp=getterSetterProperty(ppos,pname,isGet);
pname.setJsDocNode(jsdocNode);
elems.add(objectProp);
}
}
 else {
AstNode pname=name;
pname.setJsDocNode(jsdocNode);
elems.add(plainProperty(pname,tt));
}
break;
case Token.RC:
if (afterComma != -1) warnTrailingComma(pos,elems,afterComma);
break commaLoop;
default :
AstNode pname=objliteralProperty();
if (pname == null) {
propertyName=null;
}
 else {
afterComma=-1;
propertyName=ts.getString();
pname.setJsDocNode(jsdocNode);
elems.add(plainProperty(pname,tt));
}
break;
}
if (this.inUseStrictDirective && propertyName != null) {
switch (entryKind) {
case PROP_ENTRY:
if (getterNames.contains(propertyName) || setterNames.contains(propertyName)) {
addError(""String_Node_Str"",propertyName);
}
getterNames.add(propertyName);
setterNames.add(propertyName);
break;
case GET_ENTRY:
if (getterNames.contains(propertyName)) {
addError(""String_Node_Str"",propertyName);
}
getterNames.add(propertyName);
break;
case SET_ENTRY:
if (setterNames.contains(propertyName)) {
addError(""String_Node_Str"",propertyName);
}
setterNames.add(propertyName);
break;
}
}
getAndResetJsDoc();
jsdocNode=null;
if (matchToken(Token.COMMA)) {
afterComma=ts.tokenEnd;
}
 else {
break commaLoop;
}
}
mustMatchToken(Token.RC,""String_Node_Str"");
ObjectLiteral pn=new ObjectLiteral(pos,ts.tokenEnd - pos);
if (objJsdocNode != null) {
pn.setJsDocNode(objJsdocNode);
}
pn.setElements(elems);
pn.setLineno(lineno);
return pn;
}"
18711,"/** 
 * Handles any construct following a ""."" or "".."" operator.
 * @param pn the left-hand side (target) of the operator.  Never null.
 * @return a PropertyGet, XmlMemberGet, or ErrorNode
 */
private AstNode propertyAccess(int tt,AstNode pn) throws IOException {
  if (pn == null)   codeBug();
  int memberTypeFlags=0, lineno=ts.lineno, dotPos=ts.tokenBeg;
  consumeToken();
  if (tt == Token.DOTDOT) {
    mustHaveXML();
    memberTypeFlags=Node.DESCENDANTS_FLAG;
  }
  if (!compilerEnv.isXmlAvailable()) {
    int maybeName=nextToken();
    if (maybeName != Token.NAME && !(compilerEnv.isAllowKeywordAsObjectPropertyName() && TokenStream.isKeyword(ts.getString()))) {
      reportError(""String_Node_Str"");
    }
    Name name=createNameNode(true,Token.GETPROP);
    PropertyGet pg=new PropertyGet(pn,name,dotPos);
    pg.setLineno(lineno);
    return pg;
  }
  AstNode ref=null;
  int token=nextToken();
switch (token) {
case Token.THROW:
    saveNameTokenData(ts.tokenBeg,""String_Node_Str"",ts.lineno);
  ref=propertyName(-1,""String_Node_Str"",memberTypeFlags);
break;
case Token.NAME:
ref=propertyName(-1,ts.getString(),memberTypeFlags);
break;
case Token.MUL:
saveNameTokenData(ts.tokenBeg,""String_Node_Str"",ts.lineno);
ref=propertyName(-1,""String_Node_Str"",memberTypeFlags);
break;
case Token.XMLATTR:
ref=attributeAccess();
break;
default :
if (compilerEnv.isReservedKeywordAsIdentifier()) {
String name=Token.keywordToName(token);
if (name != null) {
saveNameTokenData(ts.tokenBeg,name,ts.lineno);
ref=propertyName(-1,name,memberTypeFlags);
break;
}
}
reportError(""String_Node_Str"");
return makeErrorNode();
}
boolean xml=ref instanceof XmlRef;
InfixExpression result=xml ? new XmlMemberGet() : new PropertyGet();
if (xml && tt == Token.DOT) result.setType(Token.DOT);
int pos=pn.getPosition();
result.setPosition(pos);
result.setLength(getNodeEnd(ref) - pos);
result.setOperatorPosition(dotPos - pos);
result.setLineno(pn.getLineno());
result.setLeft(pn);
result.setRight(ref);
return result;
}","/** 
 * Handles any construct following a ""."" or "".."" operator.
 * @param pn the left-hand side (target) of the operator.  Never null.
 * @return a PropertyGet, XmlMemberGet, or ErrorNode
 */
private AstNode propertyAccess(int tt,AstNode pn) throws IOException {
  if (pn == null)   codeBug();
  int memberTypeFlags=0, lineno=ts.lineno, dotPos=ts.tokenBeg;
  consumeToken();
  if (tt == Token.DOTDOT) {
    mustHaveXML();
    memberTypeFlags=Node.DESCENDANTS_FLAG;
  }
  if (!compilerEnv.isXmlAvailable()) {
    int maybeName=nextToken();
    if (maybeName != Token.NAME && !(compilerEnv.isReservedKeywordAsIdentifier() && TokenStream.isKeyword(ts.getString()))) {
      reportError(""String_Node_Str"");
    }
    Name name=createNameNode(true,Token.GETPROP);
    PropertyGet pg=new PropertyGet(pn,name,dotPos);
    pg.setLineno(lineno);
    return pg;
  }
  AstNode ref=null;
  int token=nextToken();
switch (token) {
case Token.THROW:
    saveNameTokenData(ts.tokenBeg,""String_Node_Str"",ts.lineno);
  ref=propertyName(-1,""String_Node_Str"",memberTypeFlags);
break;
case Token.NAME:
ref=propertyName(-1,ts.getString(),memberTypeFlags);
break;
case Token.MUL:
saveNameTokenData(ts.tokenBeg,""String_Node_Str"",ts.lineno);
ref=propertyName(-1,""String_Node_Str"",memberTypeFlags);
break;
case Token.XMLATTR:
ref=attributeAccess();
break;
default :
if (compilerEnv.isReservedKeywordAsIdentifier()) {
String name=Token.keywordToName(token);
if (name != null) {
saveNameTokenData(ts.tokenBeg,name,ts.lineno);
ref=propertyName(-1,name,memberTypeFlags);
break;
}
}
reportError(""String_Node_Str"");
return makeErrorNode();
}
boolean xml=ref instanceof XmlRef;
InfixExpression result=xml ? new XmlMemberGet() : new PropertyGet();
if (xml && tt == Token.DOT) result.setType(Token.DOT);
int pos=pn.getPosition();
result.setPosition(pos);
result.setLength(getNodeEnd(ref) - pos);
result.setOperatorPosition(dotPos - pos);
result.setLineno(pn.getLineno());
result.setLeft(pn);
result.setRight(ref);
return result;
}"
18712,"@Override protected void setUp() throws Exception {
  super.setUp();
  allowKeywordsAsObjectLiteralsKeys=false;
}","@Override protected void setUp() throws Exception {
  super.setUp();
  environment=new CompilerEnvirons();
}"
18713,"public void testParseObjectLiteral2(){
  expectParseErrors(""String_Node_Str"",new String[]{""String_Node_Str""});
  allowKeywordsAsObjectLiteralsKeys=true;
  parse(""String_Node_Str"");
}","public void testParseObjectLiteral2(){
  environment.setReservedKeywordAsIdentifier(false);
  expectParseErrors(""String_Node_Str"",new String[]{""String_Node_Str""});
  environment.setReservedKeywordAsIdentifier(true);
  parse(""String_Node_Str"");
}"
18714,"public void testParseObjectLiteral1(){
  allowKeywordsAsObjectLiteralsKeys=true;
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
}","public void testParseObjectLiteral1(){
  environment.setReservedKeywordAsIdentifier(true);
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
}"
18715,"private AstRoot parseAsReader(String string) throws IOException {
  CompilerEnvirons environment=new CompilerEnvirons();
  TestErrorReporter testErrorReporter=new TestErrorReporter(null,null);
  environment.setErrorReporter(testErrorReporter);
  environment.setRecordingComments(true);
  environment.setRecordingLocalJsDocComments(true);
  Parser p=new Parser(environment,testErrorReporter);
  AstRoot script=p.parse(new StringReader(string),null,0);
  assertTrue(testErrorReporter.hasEncounteredAllErrors());
  assertTrue(testErrorReporter.hasEncounteredAllWarnings());
  return script;
}","private AstRoot parseAsReader(String string) throws IOException {
  TestErrorReporter testErrorReporter=new TestErrorReporter(null,null);
  environment.setErrorReporter(testErrorReporter);
  environment.setRecordingComments(true);
  environment.setRecordingLocalJsDocComments(true);
  Parser p=new Parser(environment,testErrorReporter);
  AstRoot script=p.parse(new StringReader(string),null,0);
  assertTrue(testErrorReporter.hasEncounteredAllErrors());
  assertTrue(testErrorReporter.hasEncounteredAllWarnings());
  return script;
}"
18716,"public void testParseKeywordPropertyAccess(){
  allowKeywordsAsObjectLiteralsKeys=true;
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
}","public void testParseKeywordPropertyAccess(){
  environment.setReservedKeywordAsIdentifier(true);
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
}"
18717,"private AstRoot parse(String string,final String[] errors,final String[] warnings,boolean jsdoc){
  CompilerEnvirons environment=new CompilerEnvirons();
  environment.setReservedKeywordAsIdentifier(allowKeywordsAsObjectLiteralsKeys);
  TestErrorReporter testErrorReporter=new TestErrorReporter(errors,warnings){
    @Override public EvaluatorException runtimeError(    String message,    String sourceName,    int line,    String lineSource,    int lineOffset){
      if (errors == null) {
        throw new UnsupportedOperationException();
      }
      return new EvaluatorException(message,sourceName,line,lineSource,lineOffset);
    }
  }
;
  environment.setErrorReporter(testErrorReporter);
  environment.setRecordingComments(true);
  environment.setRecordingLocalJsDocComments(jsdoc);
  Parser p=new Parser(environment,testErrorReporter);
  AstRoot script=null;
  try {
    script=p.parse(string,null,0);
  }
 catch (  EvaluatorException e) {
    if (errors == null) {
      throw e;
    }
  }
  assertTrue(testErrorReporter.hasEncounteredAllErrors());
  assertTrue(testErrorReporter.hasEncounteredAllWarnings());
  return script;
}","private AstRoot parse(String string,final String[] errors,final String[] warnings,boolean jsdoc){
  TestErrorReporter testErrorReporter=new TestErrorReporter(errors,warnings){
    @Override public EvaluatorException runtimeError(    String message,    String sourceName,    int line,    String lineSource,    int lineOffset){
      if (errors == null) {
        throw new UnsupportedOperationException();
      }
      return new EvaluatorException(message,sourceName,line,lineSource,lineOffset);
    }
  }
;
  environment.setErrorReporter(testErrorReporter);
  environment.setRecordingComments(true);
  environment.setRecordingLocalJsDocComments(jsdoc);
  Parser p=new Parser(environment,testErrorReporter);
  AstRoot script=null;
  try {
    script=p.parse(string,null,0);
  }
 catch (  EvaluatorException e) {
    if (errors == null) {
      throw e;
    }
  }
  assertTrue(testErrorReporter.hasEncounteredAllErrors());
  assertTrue(testErrorReporter.hasEncounteredAllWarnings());
  return script;
}"
18718,"/** 
 * Parses the JavaScript text given by a reader.
 * @param sourceString Source code from the file.
 * @param errorReporter An error.
 * @param logger A logger.
 * @return The AST of the given text.
 * @throws IOException
 */
public static Node parse(StaticSourceFile sourceFile,String sourceString,Config config,ErrorReporter errorReporter,Logger logger) throws IOException {
  Context cx=Context.enter();
  cx.setErrorReporter(errorReporter);
  cx.setLanguageVersion(Context.VERSION_1_5);
  CompilerEnvirons compilerEnv=new CompilerEnvirons();
  compilerEnv.initFromContext(cx);
  compilerEnv.setRecordingComments(true);
  compilerEnv.setRecordingLocalJsDocComments(true);
  compilerEnv.setWarnTrailingComma(config.languageMode == LanguageMode.ECMASCRIPT3);
  boolean acceptEs5=config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;
  compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);
  compilerEnv.setAllowKeywordAsObjectPropertyName(acceptEs5);
  compilerEnv.setAllowMemberExprAsFunctionName(false);
  compilerEnv.setIdeMode(config.isIdeMode);
  compilerEnv.setRecoverFromErrors(config.isIdeMode);
  Parser p=new Parser(compilerEnv,errorReporter);
  AstRoot astRoot=null;
  try {
    astRoot=p.parse(sourceString,sourceFile.getName(),1);
  }
 catch (  EvaluatorException e) {
    logger.info(""String_Node_Str"" + sourceFile.getName() + ""String_Node_Str""+ e.getMessage());
  }
 finally {
    Context.exit();
  }
  Node root=null;
  if (astRoot != null) {
    root=IRFactory.transformTree(astRoot,sourceFile,sourceString,config,errorReporter);
    root.setIsSyntheticBlock(true);
  }
  return root;
}","/** 
 * Parses the JavaScript text given by a reader.
 * @param sourceString Source code from the file.
 * @param errorReporter An error.
 * @param logger A logger.
 * @return The AST of the given text.
 * @throws IOException
 */
public static Node parse(StaticSourceFile sourceFile,String sourceString,Config config,ErrorReporter errorReporter,Logger logger) throws IOException {
  Context cx=Context.enter();
  cx.setErrorReporter(errorReporter);
  cx.setLanguageVersion(Context.VERSION_1_5);
  CompilerEnvirons compilerEnv=new CompilerEnvirons();
  compilerEnv.initFromContext(cx);
  compilerEnv.setRecordingComments(true);
  compilerEnv.setRecordingLocalJsDocComments(true);
  compilerEnv.setWarnTrailingComma(config.languageMode == LanguageMode.ECMASCRIPT3);
  boolean acceptEs5=config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;
  compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);
  compilerEnv.setAllowMemberExprAsFunctionName(false);
  compilerEnv.setIdeMode(config.isIdeMode);
  compilerEnv.setRecoverFromErrors(config.isIdeMode);
  Parser p=new Parser(compilerEnv,errorReporter);
  AstRoot astRoot=null;
  try {
    astRoot=p.parse(sourceString,sourceFile.getName(),1);
  }
 catch (  EvaluatorException e) {
    logger.info(""String_Node_Str"" + sourceFile.getName() + ""String_Node_Str""+ e.getMessage());
  }
 finally {
    Context.exit();
  }
  Node root=null;
  if (astRoot != null) {
    root=IRFactory.transformTree(astRoot,sourceFile,sourceString,config,errorReporter);
    root.setIsSyntheticBlock(true);
  }
  return root;
}"
18719,"private FlowScope traverseNew(Node n,FlowScope scope){
  Node constructor=n.getFirstChild();
  scope=traverse(constructor,scope);
  JSType constructorType=constructor.getJSType();
  JSType type=null;
  if (constructorType != null) {
    constructorType=constructorType.restrictByNotNullOrUndefined();
    if (constructorType.isUnknownType()) {
      type=getNativeType(UNKNOWN_TYPE);
    }
 else {
      FunctionType ct=constructorType.toMaybeFunctionType();
      if (ct == null && constructorType instanceof FunctionType) {
        ct=(FunctionType)constructorType;
      }
      if (ct != null && ct.isConstructor()) {
        type=ct.getInstanceType();
      }
    }
  }
  n.setJSType(type);
  for (Node arg=constructor.getNext(); arg != null; arg=arg.getNext()) {
    scope=traverse(arg,scope);
  }
  return scope;
}","private FlowScope traverseNew(Node n,FlowScope scope){
  scope=traverseChildren(n,scope);
  Node constructor=n.getFirstChild();
  JSType constructorType=constructor.getJSType();
  JSType type=null;
  if (constructorType != null) {
    constructorType=constructorType.restrictByNotNullOrUndefined();
    if (constructorType.isUnknownType()) {
      type=getNativeType(UNKNOWN_TYPE);
    }
 else {
      FunctionType ct=constructorType.toMaybeFunctionType();
      if (ct == null && constructorType instanceof FunctionType) {
        ct=(FunctionType)constructorType;
      }
      if (ct != null && ct.isConstructor()) {
        type=ct.getInstanceType();
        backwardsInferenceFromCallSite(n,ct);
      }
    }
  }
  n.setJSType(type);
  return scope;
}"
18720,"/** 
 * Gets the type of   {@code this} in this function.
 */
@Override public ObjectType getTypeOfThis(){
  return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis;
}","/** 
 * Gets the type of   {@code this} in this function.
 */
@Override public ObjectType getTypeOfThis(){
  return typeOfThis.isNoObjectType() ? registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis;
}"
18721,"@Override public void process(Node externs,Node root){
  (new NodeTraversal(compiler,this)).traverse(root);
}","@Override public void process(Node externs,Node root){
  (new NodeTraversal(compiler,this)).traverseRoots(externs,root);
}"
18722,"boolean dependsOnOuterScopeVars(String name,Node useNode){
  Preconditions.checkArgument(getCfg().hasNode(useNode));
  GraphNode<Node,Branch> n=getCfg().getNode(useNode);
  FlowState<MustDef> state=n.getAnnotation();
  Definition def=state.getIn().reachingDef.get(jsScope.getVar(name));
  for (  Var s : def.depends) {
    if (s.scope != jsScope) {
      return true;
    }
  }
  return false;
}","boolean dependsOnOuterScopeVars(String name,Node useNode){
  Preconditions.checkArgument(getCfg().hasNode(useNode));
  GraphNode<Node,Branch> n=getCfg().getNode(useNode);
  FlowState<MustDef> state=n.getAnnotation();
  Definition def=state.getIn().reachingDef.get(jsScope.getVar(name));
  if (def.unknownDependencies) {
    return true;
  }
  for (  Var s : def.depends) {
    if (s.scope != jsScope) {
      return true;
    }
  }
  return false;
}"
18723,"/** 
 * Computes all the local variables that rValue reads from and store that in the def's depends set.
 */
private void computeDependence(final Definition def,Node rValue){
  NodeTraversal.traverse(compiler,rValue,new AbstractCfgNodeTraversalCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && jsScope.isDeclared(n.getString(),true)) {
        def.depends.add(jsScope.getVar(n.getString()));
      }
    }
  }
);
}","/** 
 * Computes all the local variables that rValue reads from and store that in the def's depends set.
 */
private void computeDependence(final Definition def,Node rValue){
  NodeTraversal.traverse(compiler,rValue,new AbstractCfgNodeTraversalCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName()) {
        Var dep=jsScope.getVar(n.getString());
        if (dep == null) {
          def.unknownDependencies=true;
        }
 else {
          def.depends.add(dep);
        }
      }
    }
  }
);
}"
18724,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && jsScope.isDeclared(n.getString(),true)) {
    def.depends.add(jsScope.getVar(n.getString()));
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName()) {
    Var dep=jsScope.getVar(n.getString());
    if (dep == null) {
      def.unknownDependencies=true;
    }
 else {
      def.depends.add(dep);
    }
  }
}"
18725,"public void testInlineAcrossSideEffect1(){
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testInlineAcrossSideEffect1(){
  noInline(""String_Node_Str"");
}"
18726,"public void testInlineExpression9(){
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testInlineExpression9(){
  inline(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}"
18727,"public void testInlineExpression8(){
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testInlineExpression8(){
  inline(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}"
18728,"public void testCanInlineAcrossNoSideEffect(){
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testCanInlineAcrossNoSideEffect(){
  noInline(""String_Node_Str"");
}"
18729,"@Override public void matchConstraint(ObjectType constraintObj){
  if (constraintObj.isRecordType()) {
    for (    String prop : constraintObj.getOwnPropertyNames()) {
      JSType propType=constraintObj.getPropertyType(prop);
      if (!isPropertyTypeDeclared(prop)) {
        JSType typeToInfer=propType;
        if (!hasProperty(prop)) {
          typeToInfer=getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);
        }
        defineInferredProperty(prop,typeToInfer,null);
      }
    }
  }
}","@Override public void matchConstraint(ObjectType constraintObj){
  if (hasReferenceName()) {
    return;
  }
  if (constraintObj.isRecordType()) {
    for (    String prop : constraintObj.getOwnPropertyNames()) {
      JSType propType=constraintObj.getPropertyType(prop);
      if (!isPropertyTypeDeclared(prop)) {
        JSType typeToInfer=propType;
        if (!hasProperty(prop)) {
          typeToInfer=getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);
        }
        defineInferredProperty(prop,typeToInfer,null);
      }
    }
  }
}"
18730,"/** 
 * Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.
 * @param t the traversal
 * @param assign the assign node(<code>assign.isAssign()</code> is an implicit invariant)
 */
private void visitAssign(NodeTraversal t,Node assign){
  JSDocInfo info=assign.getJSDocInfo();
  Node lvalue=assign.getFirstChild();
  Node rvalue=assign.getLastChild();
  if (lvalue.isGetProp()) {
    Node object=lvalue.getFirstChild();
    JSType objectJsType=getJSType(object);
    String property=lvalue.getLastChild().getString();
    if (object.isGetProp()) {
      JSType jsType=getJSType(object.getFirstChild());
      if (jsType.isInterface() && object.getLastChild().getString().equals(""String_Node_Str"")) {
        visitInterfaceGetprop(t,assign,object,property,lvalue,rvalue);
      }
    }
    checkEnumAlias(t,info,rvalue);
    if (property.equals(""String_Node_Str"")) {
      if (objectJsType != null && objectJsType.isFunctionType()) {
        FunctionType functionType=objectJsType.toMaybeFunctionType();
        if (functionType.isConstructor()) {
          JSType rvalueType=rvalue.getJSType();
          validator.expectObject(t,rvalue,rvalueType,OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);
          return;
        }
      }
    }
    if (object.isGetProp()) {
      Node object2=object.getFirstChild();
      String property2=NodeUtil.getStringValue(object.getLastChild());
      if (""String_Node_Str"".equals(property2)) {
        JSType jsType=getJSType(object2);
        if (jsType.isFunctionType()) {
          FunctionType functionType=jsType.toMaybeFunctionType();
          if (functionType.isConstructor() || functionType.isInterface()) {
            checkDeclaredPropertyInheritance(t,assign,functionType,property,info,getJSType(rvalue));
          }
        }
      }
    }
    ObjectType type=ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());
    if (type != null) {
      if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type,property)) {
        validator.expectCanAssignToPropertyOf(t,assign,getJSType(rvalue),type.getPropertyType(property),object,property);
        return;
      }
    }
  }
  JSType leftType=getJSType(lvalue);
  if (lvalue.isQualifiedName()) {
    JSType rvalueType=getJSType(assign.getLastChild());
    Var var=t.getScope().getVar(lvalue.getQualifiedName());
    if (var != null) {
      if (var.isTypeInferred()) {
        return;
      }
      if (var.getType() != null) {
        leftType=var.getType();
      }
    }
  }
  Node rightChild=assign.getLastChild();
  JSType rightType=getJSType(rightChild);
  if (validator.expectCanAssignTo(t,assign,rightType,leftType,""String_Node_Str"")) {
    ensureTyped(t,assign,rightType);
  }
 else {
    ensureTyped(t,assign);
  }
}","/** 
 * Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.
 * @param t the traversal
 * @param assign the assign node(<code>assign.isAssign()</code> is an implicit invariant)
 */
private void visitAssign(NodeTraversal t,Node assign){
  JSDocInfo info=assign.getJSDocInfo();
  Node lvalue=assign.getFirstChild();
  Node rvalue=assign.getLastChild();
  if (lvalue.isGetProp()) {
    Node object=lvalue.getFirstChild();
    JSType objectJsType=getJSType(object);
    String property=lvalue.getLastChild().getString();
    if (object.isGetProp()) {
      JSType jsType=getJSType(object.getFirstChild());
      if (jsType.isInterface() && object.getLastChild().getString().equals(""String_Node_Str"")) {
        visitInterfaceGetprop(t,assign,object,property,lvalue,rvalue);
      }
    }
    checkEnumAlias(t,info,rvalue);
    if (property.equals(""String_Node_Str"")) {
      if (objectJsType != null && objectJsType.isFunctionType()) {
        FunctionType functionType=objectJsType.toMaybeFunctionType();
        if (functionType.isConstructor()) {
          JSType rvalueType=rvalue.getJSType();
          validator.expectObject(t,rvalue,rvalueType,OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);
          return;
        }
      }
    }
    if (object.isGetProp()) {
      Node object2=object.getFirstChild();
      String property2=NodeUtil.getStringValue(object.getLastChild());
      if (""String_Node_Str"".equals(property2)) {
        JSType jsType=getJSType(object2);
        if (jsType.isFunctionType()) {
          FunctionType functionType=jsType.toMaybeFunctionType();
          if (functionType.isConstructor() || functionType.isInterface()) {
            checkDeclaredPropertyInheritance(t,assign,functionType,property,info,getJSType(rvalue));
          }
        }
      }
    }
    ObjectType type=ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());
    if (type != null) {
      if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type,property)) {
        JSType expectedType=type.getPropertyType(property);
        if (!expectedType.isUnknownType()) {
          validator.expectCanAssignToPropertyOf(t,assign,getJSType(rvalue),expectedType,object,property);
          return;
        }
      }
    }
  }
  JSType leftType=getJSType(lvalue);
  if (lvalue.isQualifiedName()) {
    JSType rvalueType=getJSType(assign.getLastChild());
    Var var=t.getScope().getVar(lvalue.getQualifiedName());
    if (var != null) {
      if (var.isTypeInferred()) {
        return;
      }
      if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() && t.getScope() != var.getScope()) {
        return;
      }
      if (var.getType() != null) {
        leftType=var.getType();
      }
    }
  }
  Node rightChild=assign.getLastChild();
  JSType rightType=getJSType(rightChild);
  if (validator.expectCanAssignTo(t,assign,rightType,leftType,""String_Node_Str"")) {
    ensureTyped(t,assign,rightType);
  }
 else {
    ensureTyped(t,assign);
  }
}"
18731,"void setPrototypeBasedOn(ObjectType baseType,Node propertyNode){
  if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()|| !(baseType instanceof PrototypeObjectType)) {
    baseType=new PrototypeObjectType(registry,this.getReferenceName() + ""String_Node_Str"",baseType);
  }
  setPrototype((PrototypeObjectType)baseType,propertyNode);
}","void setPrototypeBasedOn(ObjectType baseType,Node propertyNode){
  if (baseType.hasReferenceName() || isNativeObjectType() || baseType.isFunctionPrototypeType()) {
    baseType=new PrototypeObjectType(registry,this.getReferenceName() + ""String_Node_Str"",baseType);
  }
  setPrototype(baseType,propertyNode);
}"
18732,"@Override public void clearCachedValues(){
  super.clearCachedValues();
  if (subTypes != null) {
    for (    FunctionType subType : subTypes) {
      subType.clearCachedValues();
    }
  }
  if (!isNativeObjectType()) {
    if (hasInstanceType()) {
      getInstanceType().clearCachedValues();
    }
    if (prototypeSlot != null) {
      ((PrototypeObjectType)prototypeSlot.getType()).clearCachedValues();
    }
  }
}","@Override public void clearCachedValues(){
  super.clearCachedValues();
  if (subTypes != null) {
    for (    FunctionType subType : subTypes) {
      subType.clearCachedValues();
    }
  }
  if (!isNativeObjectType()) {
    if (hasInstanceType()) {
      getInstanceType().clearCachedValues();
    }
    if (prototypeSlot != null) {
      ((ObjectType)prototypeSlot.getType()).clearCachedValues();
    }
  }
}"
18733,"/** 
 * Gets the   {@code prototype} property of this function type. This isequivalent to  {@code (ObjectType) getPropertyType(""prototype"")}.
 */
public ObjectType getPrototype(){
  if (prototypeSlot == null) {
    setPrototype(new PrototypeObjectType(registry,this.getReferenceName() + ""String_Node_Str"",registry.getNativeObjectType(OBJECT_TYPE),isNativeObjectType()),null);
  }
  return (ObjectType)prototypeSlot.getType();
}","/** 
 * Gets the   {@code prototype} property of this function type. This isequivalent to  {@code (ObjectType) getPropertyType(""prototype"")}.
 */
public ObjectType getPrototype(){
  if (prototypeSlot == null) {
    String refName=getReferenceName();
    if (refName == null) {
      setPrototype(registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),null);
    }
 else {
      setPrototype(new PrototypeObjectType(registry,this.getReferenceName() + ""String_Node_Str"",registry.getNativeObjectType(OBJECT_TYPE),isNativeObjectType()),null);
    }
  }
  return (ObjectType)prototypeSlot.getType();
}"
18734,"/** 
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it willsilently be discarded.
 */
boolean setPrototype(PrototypeObjectType prototype,Node propertyNode){
  if (prototype == null) {
    return false;
  }
  if (isConstructor() && prototype == getInstanceType()) {
    return false;
  }
  PrototypeObjectType oldPrototype=prototypeSlot == null ? null : (PrototypeObjectType)prototypeSlot.getType();
  boolean replacedPrototype=oldPrototype != null;
  this.prototypeSlot=new Property(""String_Node_Str"",prototype,true,propertyNode == null ? source : propertyNode);
  prototype.setOwnerFunction(this);
  if (oldPrototype != null) {
    oldPrototype.setOwnerFunction(null);
  }
  if (isConstructor() || isInterface()) {
    FunctionType superClass=getSuperClassConstructor();
    if (superClass != null) {
      superClass.addSubType(this);
    }
    if (isInterface()) {
      for (      ObjectType interfaceType : getExtendedInterfaces()) {
        if (interfaceType.getConstructor() != null) {
          interfaceType.getConstructor().addSubType(this);
        }
      }
    }
  }
  if (replacedPrototype) {
    clearCachedValues();
  }
  return true;
}","/** 
 * Sets the prototype.
 * @param prototype the prototype. If this value is {@code null} it willsilently be discarded.
 */
boolean setPrototype(ObjectType prototype,Node propertyNode){
  if (prototype == null) {
    return false;
  }
  if (isConstructor() && prototype == getInstanceType()) {
    return false;
  }
  ObjectType oldPrototype=prototypeSlot == null ? null : (ObjectType)prototypeSlot.getType();
  boolean replacedPrototype=oldPrototype != null;
  this.prototypeSlot=new Property(""String_Node_Str"",prototype,true,propertyNode == null ? source : propertyNode);
  prototype.setOwnerFunction(this);
  if (oldPrototype != null) {
    oldPrototype.setOwnerFunction(null);
  }
  if (isConstructor() || isInterface()) {
    FunctionType superClass=getSuperClassConstructor();
    if (superClass != null) {
      superClass.addSubType(this);
    }
    if (isInterface()) {
      for (      ObjectType interfaceType : getExtendedInterfaces()) {
        if (interfaceType.getConstructor() != null) {
          interfaceType.getConstructor().addSubType(this);
        }
      }
    }
  }
  if (replacedPrototype) {
    clearCachedValues();
  }
  return true;
}"
18735,"/** 
 * Tests that defining a property of a function's   {@code prototype} adds theproperty to it instance type.
 */
public void testFunctionPrototypeAndImplicitPrototype1(){
  FunctionType constructor=registry.createConstructorType(null,null,null,null);
  ObjectType instance=constructor.getInstanceType();
  ObjectType prototype=(ObjectType)constructor.getPropertyType(""String_Node_Str"");
  prototype.defineDeclaredProperty(""String_Node_Str"",DATE_TYPE,null);
  assertEquals(NATIVE_PROPERTIES_COUNT + 1,instance.getPropertiesCount());
}","/** 
 * Tests that defining a property of a function's   {@code prototype} adds theproperty to it instance type.
 */
public void testFunctionPrototypeAndImplicitPrototype1(){
  FunctionType constructor=registry.createConstructorType(""String_Node_Str"",null,null,null);
  ObjectType instance=constructor.getInstanceType();
  ObjectType prototype=(ObjectType)constructor.getPropertyType(""String_Node_Str"");
  prototype.defineDeclaredProperty(""String_Node_Str"",DATE_TYPE,null);
  assertEquals(NATIVE_PROPERTIES_COUNT + 1,instance.getPropertiesCount());
}"
18736,"@Override void endFile(){
  super.endFile();
  if (!preferLineBreakAtEndOfFile) {
    return;
  }
  if (lineLength > lineLengthThreshold / 2) {
    append(""String_Node_Str"");
    startNewLine();
  }
 else   if (prevCutPosition > 0) {
    for (int i=prevCutPosition; i < code.length() - 1; i++) {
      code.setCharAt(i,code.charAt(i + 1));
    }
    code.setLength(code.length() - 1);
    lineStartPosition=prevLineStartPosition;
    lineLength=code.length() - lineStartPosition;
    reportLineCut(lineIndex,prevCutPosition,false);
    lineIndex--;
    prevCutPosition=0;
    prevLineStartPosition=0;
    append(""String_Node_Str"");
    startNewLine();
  }
 else {
  }
}","@Override void endFile(){
  super.endFile();
  if (!preferLineBreakAtEndOfFile) {
    return;
  }
  if (lineLength > lineLengthThreshold / 2) {
    append(""String_Node_Str"");
    startNewLine();
  }
 else   if (prevCutPosition > 0) {
    code.setCharAt(prevCutPosition,' ');
    lineStartPosition=prevLineStartPosition;
    lineLength=code.length() - lineStartPosition;
    reportLineCut(lineIndex,prevCutPosition + 1,false);
    lineIndex--;
    prevCutPosition=0;
    prevLineStartPosition=0;
    append(""String_Node_Str"");
    startNewLine();
  }
 else {
  }
}"
18737,"public void testPreferLineBreakAtEndOfFile(){
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","public void testPreferLineBreakAtEndOfFile(){
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertLineBreakAtEndOfFile(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
18738,"private void tryConvertToNumber(Node n){
switch (n.getType()) {
case Token.NUMBER:
    return;
case Token.AND:
case Token.OR:
case Token.COMMA:
  tryConvertToNumber(n.getLastChild());
return;
case Token.HOOK:
tryConvertToNumber(n.getChildAtIndex(1));
tryConvertToNumber(n.getLastChild());
return;
case Token.NAME:
if (!NodeUtil.isUndefined(n)) {
return;
}
break;
}
Double result=NodeUtil.getNumberValue(n);
if (result == null) {
return;
}
double value=result;
Node replacement=NodeUtil.numberNode(value,n);
n.getParent().replaceChild(n,replacement);
reportCodeChange();
}","private void tryConvertToNumber(Node n){
switch (n.getType()) {
case Token.NUMBER:
    return;
case Token.AND:
case Token.OR:
case Token.COMMA:
  tryConvertToNumber(n.getLastChild());
return;
case Token.HOOK:
tryConvertToNumber(n.getChildAtIndex(1));
tryConvertToNumber(n.getLastChild());
return;
case Token.NAME:
if (!NodeUtil.isUndefined(n)) {
return;
}
break;
}
Double result=NodeUtil.getNumberValue(n);
if (result == null) {
return;
}
double value=result;
Node replacement=NodeUtil.numberNode(value,n);
if (replacement.isEquivalentTo(n)) {
return;
}
n.getParent().replaceChild(n,replacement);
reportCodeChange();
}"
18739,"public void testInvertibleOperators(){
  Map<String,String> inverses=ImmutableMap.<String,String>builder().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").build();
  Set<String> comparators=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Set<String> equalitors=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  Set<String> uncomparables=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  List<String> operators=ImmutableList.copyOf(inverses.values());
  for (int iOperandA=0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {
    for (int iOperandB=0; iOperandB < LITERAL_OPERANDS.size(); iOperandB++) {
      for (int iOp=0; iOp < operators.size(); iOp++) {
        String a=LITERAL_OPERANDS.get(iOperandA);
        String b=LITERAL_OPERANDS.get(iOperandB);
        String op=operators.get(iOp);
        String inverse=inverses.get(op);
        if (comparators.contains(op) && (uncomparables.contains(a) || uncomparables.contains(b))) {
          assertSameResults(join(a,op,b),""String_Node_Str"");
          assertSameResults(join(a,inverse,b),""String_Node_Str"");
        }
 else         if (a.equals(b) && equalitors.contains(op)) {
          if (a.equals(""String_Node_Str"") || a.equals(""String_Node_Str"")) {
            foldSame(join(a,op,b));
            foldSame(join(a,inverse,b));
          }
 else {
            assertSameResults(join(a,op,b),""String_Node_Str"");
            assertSameResults(join(a,inverse,b),""String_Node_Str"");
          }
        }
 else {
          assertNotSameResults(join(a,op,b),join(a,inverse,b));
        }
      }
    }
  }
}","public void testInvertibleOperators(){
  Map<String,String> inverses=ImmutableMap.<String,String>builder().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"").build();
  Set<String> comparators=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Set<String> equalitors=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  Set<String> uncomparables=ImmutableSet.of(""String_Node_Str"",""String_Node_Str"");
  List<String> operators=ImmutableList.copyOf(inverses.values());
  for (int iOperandA=0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {
    for (int iOperandB=0; iOperandB < LITERAL_OPERANDS.size(); iOperandB++) {
      for (int iOp=0; iOp < operators.size(); iOp++) {
        String a=LITERAL_OPERANDS.get(iOperandA);
        String b=LITERAL_OPERANDS.get(iOperandB);
        String op=operators.get(iOp);
        String inverse=inverses.get(op);
        if (comparators.contains(op) && (uncomparables.contains(a) || uncomparables.contains(b))) {
          assertSameResults(join(a,op,b),""String_Node_Str"");
          assertSameResults(join(a,inverse,b),""String_Node_Str"");
        }
 else         if (a.equals(b) && equalitors.contains(op)) {
          if (a.equals(""String_Node_Str"") || a.equals(""String_Node_Str"") || a.equals(""String_Node_Str"")) {
            foldSame(join(a,op,b));
            foldSame(join(a,inverse,b));
          }
 else {
            assertSameResults(join(a,op,b),""String_Node_Str"");
            assertSameResults(join(a,inverse,b),""String_Node_Str"");
          }
        }
 else {
          assertNotSameResults(join(a,op,b),join(a,inverse,b));
        }
      }
    }
  }
}"
18740,"/** 
 * TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?'
 */
private Node parseTypeExpression(JsDocToken token){
  if (token == JsDocToken.QMARK) {
    token=next();
    if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) {
      restoreLookAhead(token);
      return newNode(Token.QMARK);
    }
    return wrapNode(Token.QMARK,parseBasicTypeExpression(token));
  }
 else   if (token == JsDocToken.BANG) {
    return wrapNode(Token.BANG,parseBasicTypeExpression(next()));
  }
 else {
    Node basicTypeExpr=parseBasicTypeExpression(token);
    if (basicTypeExpr != null) {
      if (match(JsDocToken.QMARK)) {
        next();
        return wrapNode(Token.QMARK,basicTypeExpr);
      }
 else       if (match(JsDocToken.BANG)) {
        next();
        return wrapNode(Token.BANG,basicTypeExpr);
      }
    }
    return basicTypeExpr;
  }
}","/** 
 * TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?'
 */
private Node parseTypeExpression(JsDocToken token){
  if (token == JsDocToken.QMARK) {
    token=next();
    if (token == JsDocToken.COMMA || token == JsDocToken.EQUALS || token == JsDocToken.RB || token == JsDocToken.RC || token == JsDocToken.RP || token == JsDocToken.PIPE) {
      restoreLookAhead(token);
      return newNode(Token.QMARK);
    }
    return wrapNode(Token.QMARK,parseBasicTypeExpression(token));
  }
 else   if (token == JsDocToken.BANG) {
    return wrapNode(Token.BANG,parseBasicTypeExpression(next()));
  }
 else {
    Node basicTypeExpr=parseBasicTypeExpression(token);
    if (basicTypeExpr != null) {
      if (match(JsDocToken.QMARK)) {
        next();
        return wrapNode(Token.QMARK,basicTypeExpr);
      }
 else       if (match(JsDocToken.BANG)) {
        next();
        return wrapNode(Token.BANG,basicTypeExpr);
      }
    }
    return basicTypeExpr;
  }
}"
18741,"/** 
 * Activates Common JS module processing.
 */
public void setProcessCommonJSModules(boolean processCommonJSModules){
  this.processCommonJSModules=processCommonJSModules;
}","/** 
 * Rewrites CommonJS modulee so that modules can be concatenated together, by renaming all globals to avoid conflicting with other modules.
 */
public void setProcessCommonJSModules(boolean processCommonJSModules){
  this.processCommonJSModules=processCommonJSModules;
}"
18742,"/** 
 * Get the return value of calling ""bind"" on this function with the specified number of arguments. If -1 is passed, then we will return a result that accepts any parameters.
 */
public FunctionType getBindReturnType(int argsToBind){
  FunctionBuilder builder=new FunctionBuilder(registry).withReturnType(getReturnType());
  if (argsToBind >= 0) {
    Node origParams=getParametersNode();
    if (origParams != null) {
      Node params=origParams.cloneTree();
      for (int i=1; i < argsToBind && params.getFirstChild() != null; i++) {
        params.removeFirstChild();
      }
      builder.withParamsNode(params);
    }
  }
  return builder.build();
}","/** 
 * Get the return value of calling ""bind"" on this function with the specified number of arguments. If -1 is passed, then we will return a result that accepts any parameters.
 */
public FunctionType getBindReturnType(int argsToBind){
  FunctionBuilder builder=new FunctionBuilder(registry).withReturnType(getReturnType());
  if (argsToBind >= 0) {
    Node origParams=getParametersNode();
    if (origParams != null) {
      Node params=origParams.cloneTree();
      for (int i=1; i < argsToBind && params.getFirstChild() != null; i++) {
        if (params.getFirstChild().isVarArgs()) {
          break;
        }
        params.removeFirstChild();
      }
      builder.withParamsNode(params);
    }
  }
  return builder.build();
}"
18743,"void add(String newcode){
  maybeEndStatement();
  if (newcode.length() == 0) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
  append(newcode);
}","void add(String newcode){
  maybeEndStatement();
  if (newcode.length() == 0) {
    return;
  }
  char c=newcode.charAt(0);
  if ((isWordChar(c) || c == '\\') && isWordChar(getLastChar())) {
    append(""String_Node_Str"");
  }
 else   if (c == '/' && getLastChar() == '/') {
    append(""String_Node_Str"");
  }
  append(newcode);
}"
18744,"JSType getGreatestSubtypeHelper(JSType that){
  if (that.isRecordType()) {
    RecordType thatRecord=(RecordType)that;
    RecordTypeBuilder builder=new RecordTypeBuilder(registry);
    for (    String property : properties.keySet()) {
      if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
        return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
      }
      builder.addProperty(property,getPropertyType(property),getPropertyNode(property));
    }
    for (    String property : thatRecord.properties.keySet()) {
      if (!hasProperty(property)) {
        builder.addProperty(property,thatRecord.getPropertyType(property),thatRecord.getPropertyNode(property));
      }
    }
    return builder.build();
  }
  JSType greatestSubtype=registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  JSType thatRestrictedToObj=registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
  if (!thatRestrictedToObj.isEmptyType()) {
    for (    Map.Entry<String,JSType> entry : properties.entrySet()) {
      String propName=entry.getKey();
      JSType propType=entry.getValue();
      UnionTypeBuilder builder=new UnionTypeBuilder(registry);
      for (      ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
        JSType altPropType=alt.getPropertyType(propName);
        if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
          builder.addAlternate(alt);
        }
      }
      greatestSubtype=greatestSubtype.getLeastSupertype(builder.build());
    }
  }
  return greatestSubtype;
}","JSType getGreatestSubtypeHelper(JSType that){
  if (that.isRecordType()) {
    RecordType thatRecord=that.toMaybeRecordType();
    RecordTypeBuilder builder=new RecordTypeBuilder(registry);
    for (    String property : properties.keySet()) {
      if (thatRecord.hasProperty(property) && !thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
        return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
      }
      builder.addProperty(property,getPropertyType(property),getPropertyNode(property));
    }
    for (    String property : thatRecord.properties.keySet()) {
      if (!hasProperty(property)) {
        builder.addProperty(property,thatRecord.getPropertyType(property),thatRecord.getPropertyNode(property));
      }
    }
    return builder.build();
  }
  JSType greatestSubtype=registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  JSType thatRestrictedToObj=registry.getNativeType(JSTypeNative.OBJECT_TYPE).getGreatestSubtype(that);
  if (!thatRestrictedToObj.isEmptyType()) {
    for (    Map.Entry<String,JSType> entry : properties.entrySet()) {
      String propName=entry.getKey();
      JSType propType=entry.getValue();
      UnionTypeBuilder builder=new UnionTypeBuilder(registry);
      for (      ObjectType alt : registry.getEachReferenceTypeWithProperty(propName)) {
        JSType altPropType=alt.getPropertyType(propName);
        if (altPropType != null && !alt.isEquivalentTo(this) && alt.isSubtype(that) && (propType.isUnknownType() || altPropType.isUnknownType() || altPropType.isEquivalentTo(propType))) {
          builder.addAlternate(alt);
        }
      }
      greatestSubtype=greatestSubtype.getLeastSupertype(builder.build());
    }
  }
  return greatestSubtype;
}"
18745,"public void testRecordSubtypeChain() throws Exception {
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType aType=builder.build();
  builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType abType=builder.build();
  builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",NUMBER_TYPE,null);
  JSType abcType=builder.build();
  List<JSType> typeChain=Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE),registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),registry.getNativeType(JSTypeNative.OBJECT_TYPE),aType,abType,abcType,registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),registry.getNativeType(JSTypeNative.NO_TYPE));
  verifySubtypeChain(typeChain);
}","public void testRecordSubtypeChain() throws Exception {
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType aType=builder.build();
  builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType abType=builder.build();
  builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType acType=builder.build();
  JSType abOrAcType=registry.createUnionType(abType,acType);
  builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",NUMBER_TYPE,null);
  JSType abcType=builder.build();
  List<JSType> typeChain=Lists.newArrayList(registry.getNativeType(JSTypeNative.ALL_TYPE),registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),registry.getNativeType(JSTypeNative.OBJECT_TYPE),aType,abOrAcType,abType,abcType,registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),registry.getNativeType(JSTypeNative.NO_TYPE));
  verifySubtypeChain(typeChain);
}"
18746,"public void testRecordTypeLeastSuperType3(){
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",NUMBER_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType subRecordType=builder.build();
  JSType leastSupertype=recordType.getLeastSupertype(subRecordType);
  assertTypeEquals(leastSupertype,OBJECT_TYPE);
}","public void testRecordTypeLeastSuperType3(){
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",NUMBER_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType otherRecordType=builder.build();
  assertTypeEquals(registry.createUnionType(recordType,otherRecordType),recordType.getLeastSupertype(otherRecordType));
}"
18747,"public void testRecordTypeLeastSuperType2(){
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",NUMBER_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType subRecordType=builder.build();
  JSType leastSupertype=recordType.getLeastSupertype(subRecordType);
  builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  assertTypeEquals(leastSupertype,builder.build());
}","public void testRecordTypeLeastSuperType2(){
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  builder.addProperty(""String_Node_Str"",NUMBER_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  builder.addProperty(""String_Node_Str"",STRING_TYPE,null);
  JSType otherRecordType=builder.build();
  assertTypeEquals(registry.createUnionType(recordType,otherRecordType),recordType.getLeastSupertype(otherRecordType));
}"
18748,"/** 
 * Check if the given node is a property of a name in the global scope.
 */
private boolean isQnameRootedInGlobalScope(Node n){
  Node root=NodeUtil.getRootOfQualifiedName(n);
  if (root.isName()) {
    Var var=scope.getVar(root.getString());
    if (var != null) {
      return var.isGlobal();
    }
  }
  return false;
}","/** 
 * Check if the given node is a property of a name in the global scope.
 */
private boolean isQnameRootedInGlobalScope(Node n){
  Scope scope=getQnameRootScope(n);
  return scope != null && scope.isGlobal();
}"
18749,"/** 
 * For functions with function(this: T, ...) and T as parameters, type inference will set the type of this on a function literal argument to the the actual type of T.
 */
private void updateTypeOfThisOnClosure(Node n,FunctionType fnType){
  if (fnType.getTemplateTypeName() == null) {
    return;
  }
  int i=0;
  int childCount=n.getChildCount();
  for (  Node iParameter : fnType.getParameters()) {
    JSType iParameterType=getJSType(iParameter).restrictByNotNullOrUndefined();
    if (iParameterType.isTemplateType()) {
      JSType iArgumentType=null;
      if (i + 1 < childCount) {
        Node iArgument=n.getChildAtIndex(i + 1);
        iArgumentType=getJSType(iArgument).restrictByNotNullOrUndefined();
        if (!(iArgumentType instanceof ObjectType)) {
          compiler.report(JSError.make(NodeUtil.getSourceName(iArgument),iArgument,TEMPLATE_TYPE_NOT_OBJECT_TYPE));
          return;
        }
      }
      boolean foundTemplateTypeOfThisParameter=false;
      int j=0;
      for (      Node jParameter : fnType.getParameters()) {
        JSType jParameterType=getJSType(jParameter).restrictByNotNullOrUndefined();
        if (jParameterType.isFunctionType()) {
          FunctionType jParameterFnType=jParameterType.toMaybeFunctionType();
          if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {
            foundTemplateTypeOfThisParameter=true;
            if (j + 1 >= childCount) {
              return;
            }
            Node jArgument=n.getChildAtIndex(j + 1);
            JSType jArgumentType=getJSType(jArgument);
            if (jArgument.getType() == Token.FUNCTION && jArgumentType.isFunctionType()) {
              if (iArgumentType != null && !iArgumentType.isNoType()) {
                FunctionType jArgumentFnType=jArgumentType.toMaybeFunctionType();
                if (jArgumentFnType.getTypeOfThis().isUnknownType()) {
                  jArgument.setJSType(registry.createFunctionTypeWithNewThisType(jArgumentFnType,(ObjectType)iArgumentType));
                }
              }
 else {
                if (NodeUtil.referencesThis(NodeUtil.getFunctionBody(jArgument))) {
                  compiler.report(JSError.make(NodeUtil.getSourceName(n),n,FUNCTION_LITERAL_UNDEFINED_THIS));
                }
              }
            }
          }
        }
        j++;
      }
      if (!foundTemplateTypeOfThisParameter) {
        compiler.report(JSError.make(NodeUtil.getSourceName(n),n,TEMPLATE_TYPE_OF_THIS_EXPECTED));
        return;
      }
    }
    i++;
  }
}","/** 
 * For functions with function(this: T, ...) and T as parameters, type inference will set the type of this on a function literal argument to the the actual type of T.
 */
private void updateTypeOfThisOnClosure(Node n,FunctionType fnType){
  if (fnType.getTemplateTypeName() == null) {
    return;
  }
  int i=0;
  int childCount=n.getChildCount();
  for (  Node iParameter : fnType.getParameters()) {
    JSType iParameterType=getJSType(iParameter).restrictByNotNullOrUndefined();
    if (iParameterType.isTemplateType()) {
      ObjectType iArgumentType=null;
      if (i + 1 < childCount) {
        Node iArgument=n.getChildAtIndex(i + 1);
        iArgumentType=getJSType(iArgument).restrictByNotNullOrUndefined().collapseUnion().toObjectType();
        if (iArgumentType == null) {
          compiler.report(JSError.make(NodeUtil.getSourceName(iArgument),iArgument,TEMPLATE_TYPE_NOT_OBJECT_TYPE,getJSType(iArgument).toString()));
          return;
        }
      }
      boolean foundTemplateTypeOfThisParameter=false;
      int j=0;
      for (      Node jParameter : fnType.getParameters()) {
        JSType jParameterType=getJSType(jParameter).restrictByNotNullOrUndefined();
        if (jParameterType.isFunctionType()) {
          FunctionType jParameterFnType=jParameterType.toMaybeFunctionType();
          if (jParameterFnType.getTypeOfThis().equals(iParameterType)) {
            foundTemplateTypeOfThisParameter=true;
            if (j + 1 >= childCount) {
              return;
            }
            Node jArgument=n.getChildAtIndex(j + 1);
            JSType jArgumentType=getJSType(jArgument);
            if (jArgument.getType() == Token.FUNCTION && jArgumentType.isFunctionType()) {
              if (iArgumentType != null && !iArgumentType.isNoType()) {
                FunctionType jArgumentFnType=jArgumentType.toMaybeFunctionType();
                if (jArgumentFnType.getTypeOfThis().isUnknownType()) {
                  jArgument.setJSType(registry.createFunctionTypeWithNewThisType(jArgumentFnType,iArgumentType));
                }
              }
 else {
                if (NodeUtil.referencesThis(NodeUtil.getFunctionBody(jArgument))) {
                  compiler.report(JSError.make(NodeUtil.getSourceName(n),n,FUNCTION_LITERAL_UNDEFINED_THIS));
                }
              }
            }
          }
        }
        j++;
      }
      if (!foundTemplateTypeOfThisParameter) {
        compiler.report(JSError.make(NodeUtil.getSourceName(n),n,TEMPLATE_TYPE_OF_THIS_EXPECTED));
        return;
      }
    }
    i++;
  }
}"
18750,"public void testBadTemplateType2() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(),true);
}","public void testBadTemplateType2() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(""String_Node_Str""));
}"
18751,"public void testBadTemplateType1() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(),true);
}","public void testBadTemplateType1() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());
}"
18752,"public void testBadTemplateType5() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(),true);
}","public void testBadTemplateType5() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
}"
18753,"public void testBadTemplateType4() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(),true);
}","public void testBadTemplateType4() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
}"
18754,"public void testBadTemplateType3() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(),true);
}","public void testBadTemplateType3() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());
}"
18755,"public void testBadTemplateType2() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(),true);
}","public void testBadTemplateType2() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_NOT_OBJECT_TYPE.format(""String_Node_Str""));
}"
18756,"public void testBadTemplateType1() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format(),true);
}","public void testBadTemplateType1() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_DUPLICATED.format());
}"
18757,"public void testBadTemplateType5() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(),true);
}","public void testBadTemplateType5() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
}"
18758,"public void testBadTemplateType4() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format(),true);
}","public void testBadTemplateType4() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",FunctionTypeBuilder.TEMPLATE_TYPE_EXPECTED.format());
}"
18759,"public void testBadTemplateType3() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format(),true);
}","public void testBadTemplateType3() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",TypeInference.TEMPLATE_TYPE_OF_THIS_EXPECTED.format());
}"
18760,"@Override public void inferQualifiedSlot(Node node,String symbol,JSType bottomType,JSType inferredType){
  Scope functionScope=getFunctionScope();
  if (functionScope.isLocal()) {
    if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {
      int firstDot=symbol.indexOf(""String_Node_Str"");
      Preconditions.checkState(firstDot != -1);
      Var owner=functionScope.getVar(symbol.substring(0,firstDot));
      Scope ownerScope=owner == null ? functionScope : owner.getScope();
      ownerScope.declare(symbol,node,bottomType,null);
    }
    inferSlotType(symbol,inferredType);
  }
}","@Override public void inferQualifiedSlot(Node node,String symbol,JSType bottomType,JSType inferredType){
  Scope functionScope=getFunctionScope();
  if (functionScope.isLocal()) {
    if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {
      functionScope.declare(symbol,node,bottomType,null);
    }
    inferSlotType(symbol,inferredType);
  }
}"
18761,"/** 
 * Visits a GETPROP node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of <code>n</code>
 */
private void visitGetProp(NodeTraversal t,Node n,Node parent){
  if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {
    return;
  }
  Node property=n.getLastChild();
  Node objNode=n.getFirstChild();
  JSType childType=getJSType(objNode);
  if (!validator.expectNotNullOrUndefined(t,n,childType,childType + ""String_Node_Str"",getNativeType(OBJECT_TYPE))) {
    ensureTyped(t,n);
    return;
  }
  checkPropertyAccess(childType,property.getString(),t,n);
  ensureTyped(t,n);
}","/** 
 * Visits a GETPROP node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of <code>n</code>
 */
private void visitGetProp(NodeTraversal t,Node n,Node parent){
  if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {
    return;
  }
  Node property=n.getLastChild();
  Node objNode=n.getFirstChild();
  JSType childType=getJSType(objNode);
  if (!validator.expectNotNullOrUndefined(t,n,childType,""String_Node_Str"",getNativeType(OBJECT_TYPE))) {
    ensureTyped(t,n);
    return;
  }
  checkPropertyAccess(childType,property.getString(),t,n);
  ensureTyped(t,n);
}"
18762,"/** 
 * Creates an instance for a function that is an interface. 
 */
private FunctionType(JSTypeRegistry registry,String name,Node source){
  super(registry,name,registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));
  Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType());
  Preconditions.checkArgument(name != null);
  this.source=source;
  this.call=new ArrowType(registry,new Node(Token.LP),null);
  this.kind=Kind.INTERFACE;
  this.typeOfThis=new InstanceObjectType(registry,this);
}","/** 
 * Creates an instance for a function that is an interface. 
 */
private FunctionType(JSTypeRegistry registry,String name,Node source){
  super(registry,name,registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));
  setPrettyPrint(true);
  Preconditions.checkArgument(source == null || Token.FUNCTION == source.getType());
  Preconditions.checkArgument(name != null);
  this.source=source;
  this.call=new ArrowType(registry,new Node(Token.LP),null);
  this.kind=Kind.INTERFACE;
  this.typeOfThis=new InstanceObjectType(registry,this);
}"
18763,"/** 
 * Informally, a function is represented by  {@code function (params): returnType} where the {@code params} is a commaseparated list of types, the first one being a special {@code this:T} if the function expects a known type for {@code this}.
 */
@Override public String toString(){
  if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
    return ""String_Node_Str"";
  }
  StringBuilder b=new StringBuilder(32);
  b.append(""String_Node_Str"");
  int paramNum=call.parameters.getChildCount();
  boolean hasKnownTypeOfThis=!typeOfThis.isUnknownType();
  if (hasKnownTypeOfThis) {
    if (isConstructor()) {
      b.append(""String_Node_Str"");
    }
 else {
      b.append(""String_Node_Str"");
    }
    b.append(typeOfThis.toString());
  }
  if (paramNum > 0) {
    if (hasKnownTypeOfThis) {
      b.append(""String_Node_Str"");
    }
    Node p=call.parameters.getFirstChild();
    if (p.isVarArgs()) {
      appendVarArgsString(b,p.getJSType());
    }
 else {
      b.append(p.getJSType().toString());
    }
    p=p.getNext();
    while (p != null) {
      b.append(""String_Node_Str"");
      if (p.isVarArgs()) {
        appendVarArgsString(b,p.getJSType());
      }
 else {
        b.append(p.getJSType().toString());
      }
      p=p.getNext();
    }
  }
  b.append(""String_Node_Str"");
  b.append(call.returnType);
  return b.toString();
}","/** 
 * Informally, a function is represented by  {@code function (params): returnType} where the {@code params} is a commaseparated list of types, the first one being a special {@code this:T} if the function expects a known type for {@code this}.
 */
@Override public String toString(){
  if (!isPrettyPrint() || this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
    return ""String_Node_Str"";
  }
  setPrettyPrint(false);
  StringBuilder b=new StringBuilder(32);
  b.append(""String_Node_Str"");
  int paramNum=call.parameters.getChildCount();
  boolean hasKnownTypeOfThis=!typeOfThis.isUnknownType();
  if (hasKnownTypeOfThis) {
    if (isConstructor()) {
      b.append(""String_Node_Str"");
    }
 else {
      b.append(""String_Node_Str"");
    }
    b.append(typeOfThis.toString());
  }
  if (paramNum > 0) {
    if (hasKnownTypeOfThis) {
      b.append(""String_Node_Str"");
    }
    Node p=call.parameters.getFirstChild();
    if (p.isVarArgs()) {
      appendVarArgsString(b,p.getJSType());
    }
 else {
      b.append(p.getJSType().toString());
    }
    p=p.getNext();
    while (p != null) {
      b.append(""String_Node_Str"");
      if (p.isVarArgs()) {
        appendVarArgsString(b,p.getJSType());
      }
 else {
        b.append(p.getJSType().toString());
      }
      p=p.getNext();
    }
  }
  b.append(""String_Node_Str"");
  b.append(call.returnType);
  setPrettyPrint(true);
  return b.toString();
}"
18764,"/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isSubtype(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtype(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}","/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isSubtype(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtype(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}"
18765,"public boolean isRecordType(){
  return false;
}","public boolean isRecordType(){
  return toMaybeRecordType() != null;
}"
18766,"@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isUnionType()) {
    return false;
  }
  if (that instanceof RecordType) {
    return RecordType.isSubtype(this,(RecordType)that);
  }
  ObjectType thatObj=that.toObjectType();
  ObjectType thatCtor=thatObj == null ? null : thatObj.getConstructor();
  if (thatCtor != null && thatCtor.isInterface()) {
    Iterable<ObjectType> thisInterfaces=getCtorImplementedInterfaces();
    for (    ObjectType thisInterface : thisInterfaces) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (getConstructor() != null && getConstructor().isInterface()) {
    for (    ObjectType thisInterface : getCtorExtendedInterfaces()) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
    return true;
  }
  return this.isImplicitPrototype(thatObj);
}","@Override public boolean isSubtype(JSType that){
  if (JSType.isSubtypeHelper(this,that)) {
    return true;
  }
  if (that.isUnionType()) {
    return false;
  }
  if (that.isRecordType()) {
    return RecordType.isSubtype(this,that.toMaybeRecordType());
  }
  ObjectType thatObj=that.toObjectType();
  ObjectType thatCtor=thatObj == null ? null : thatObj.getConstructor();
  if (thatCtor != null && thatCtor.isInterface()) {
    Iterable<ObjectType> thisInterfaces=getCtorImplementedInterfaces();
    for (    ObjectType thisInterface : thisInterfaces) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (getConstructor() != null && getConstructor().isInterface()) {
    for (    ObjectType thisInterface : getCtorExtendedInterfaces()) {
      if (thisInterface.isSubtype(that)) {
        return true;
      }
    }
  }
  if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
    return true;
  }
  return this.isImplicitPrototype(thatObj);
}"
18767,"@Override public boolean isEquivalentTo(JSType other){
  if (!(other instanceof RecordType)) {
    return false;
  }
  RecordType otherRecord=(RecordType)other;
  Set<String> keySet=properties.keySet();
  Map<String,JSType> otherProps=otherRecord.properties;
  if (!otherProps.keySet().equals(keySet)) {
    return false;
  }
  for (  String key : keySet) {
    if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {
      return false;
    }
  }
  return true;
}","@Override public boolean isEquivalentTo(JSType other){
  if (!other.isRecordType()) {
    return false;
  }
  RecordType otherRecord=other.toMaybeRecordType();
  if (otherRecord == this) {
    return true;
  }
  Set<String> keySet=properties.keySet();
  Map<String,JSType> otherProps=otherRecord.properties;
  if (!otherProps.keySet().equals(keySet)) {
    return false;
  }
  for (  String key : keySet) {
    if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {
      return false;
    }
  }
  return true;
}"
18768,"/** 
 * Creates a record type.
 * @param registry The type registry under which this type lives.
 * @param properties A map of all the properties of this record type.
 * @throws IllegalStateException if the {@code RecordProperty} associatedwith a property is null.
 */
RecordType(JSTypeRegistry registry,Map<String,RecordProperty> properties){
  super(registry,null,null);
  for (  String property : properties.keySet()) {
    RecordProperty prop=properties.get(property);
    if (prop == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    defineDeclaredProperty(property,prop.getType(),prop.getPropertyNode());
  }
  isFrozen=true;
}","/** 
 * Creates a record type.
 * @param registry The type registry under which this type lives.
 * @param properties A map of all the properties of this record type.
 * @throws IllegalStateException if the {@code RecordProperty} associatedwith a property is null.
 */
RecordType(JSTypeRegistry registry,Map<String,RecordProperty> properties){
  super(registry,null,null);
  setPrettyPrint(true);
  for (  String property : properties.keySet()) {
    RecordProperty prop=properties.get(property);
    if (prop == null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    defineDeclaredProperty(property,prop.getType(),prop.getPropertyNode());
  }
  isFrozen=true;
}"
18769,"@Override public JSType getLeastSupertype(JSType that){
  if (!that.isRecordType()) {
    return super.getLeastSupertype(that);
  }
  RecordType thatRecord=(RecordType)that;
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  for (  String property : properties.keySet()) {
    if (thatRecord.hasProperty(property) && thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
      builder.addProperty(property,getPropertyType(property),getPropertyNode(property));
    }
  }
  return builder.build();
}","@Override public JSType getLeastSupertype(JSType that){
  if (!that.isRecordType()) {
    return super.getLeastSupertype(that);
  }
  RecordType thatRecord=that.toMaybeRecordType();
  RecordTypeBuilder builder=new RecordTypeBuilder(registry);
  for (  String property : properties.keySet()) {
    if (thatRecord.hasProperty(property) && thatRecord.getPropertyType(property).isEquivalentTo(getPropertyType(property))) {
      builder.addProperty(property,getPropertyType(property),getPropertyNode(property));
    }
  }
  return builder.build();
}"
18770,"/** 
 * Looks for a type expression at the current token and if found, returns it. Note that this method consumes input. Parameter type expressions are special for two reasons: <ol> <li>They must begin with '{', to distinguish type names from param names. <li>They may end in '=', to denote optionality. </ol>
 * @param token The current token.
 * @return The type expression found or null if none.
 */
private Node parseAndRecordParamTypeNode(JsDocToken token){
  Preconditions.checkArgument(token == JsDocToken.LC);
  int lineno=stream.getLineno();
  int startCharno=stream.getCharno();
  Node typeNode=parseParamTypeExpressionAnnotation(token);
  int endCharno=stream.getCharno();
  jsdocBuilder.markTypeNode(typeNode,lineno,startCharno,endCharno,true);
  return typeNode;
}","/** 
 * Looks for a type expression at the current token and if found, returns it. Note that this method consumes input. Parameter type expressions are special for two reasons: <ol> <li>They must begin with '{', to distinguish type names from param names. <li>They may end in '=', to denote optionality. </ol>
 * @param token The current token.
 * @return The type expression found or null if none.
 */
private Node parseAndRecordParamTypeNode(JsDocToken token){
  Preconditions.checkArgument(token == JsDocToken.LC);
  int lineno=stream.getLineno();
  int startCharno=stream.getCharno();
  Node typeNode=parseParamTypeExpressionAnnotation(token);
  if (typeNode != null) {
    int endLineno=stream.getLineno();
    int endCharno=stream.getCharno();
    jsdocBuilder.markTypeNode(typeNode,lineno,startCharno,endLineno,endCharno,true);
  }
  return typeNode;
}"
18771,"/** 
 * Looks for a parameter type expression at the current token and if found, returns it. Note that this method consumes input.
 * @param token The current token.
 * @param lineno The line of the type expression.
 * @param startCharno The starting character position of the type expression.
 * @param matchingLC Whether the type expression starts with a ""{"".
 * @param onlyParseSimpleNames If true, only simple type names are parsed(via a call to parseTypeNameAnnotation instead of parseTypeExpressionAnnotation).
 * @return The type expression found or null if none.
 */
private Node parseAndRecordTypeNode(JsDocToken token,int lineno,int startCharno,boolean matchingLC,boolean onlyParseSimpleNames){
  Node typeNode=null;
  if (onlyParseSimpleNames) {
    typeNode=parseTypeNameAnnotation(token);
  }
 else {
    typeNode=parseTypeExpressionAnnotation(token);
  }
  if (typeNode != null && !matchingLC) {
    typeNode.putBooleanProp(Node.BRACELESS_TYPE,true);
  }
  int endCharno=stream.getCharno();
  jsdocBuilder.markTypeNode(typeNode,lineno,startCharno,endCharno,matchingLC);
  return typeNode;
}","/** 
 * Looks for a parameter type expression at the current token and if found, returns it. Note that this method consumes input.
 * @param token The current token.
 * @param lineno The line of the type expression.
 * @param startCharno The starting character position of the type expression.
 * @param matchingLC Whether the type expression starts with a ""{"".
 * @param onlyParseSimpleNames If true, only simple type names are parsed(via a call to parseTypeNameAnnotation instead of parseTypeExpressionAnnotation).
 * @return The type expression found or null if none.
 */
private Node parseAndRecordTypeNode(JsDocToken token,int lineno,int startCharno,boolean matchingLC,boolean onlyParseSimpleNames){
  Node typeNode=null;
  if (onlyParseSimpleNames) {
    typeNode=parseTypeNameAnnotation(token);
  }
 else {
    typeNode=parseTypeExpressionAnnotation(token);
  }
  if (typeNode != null && !matchingLC) {
    typeNode.putBooleanProp(Node.BRACELESS_TYPE,true);
  }
  if (typeNode != null) {
    int endLineno=stream.getLineno();
    int endCharno=stream.getCharno();
    jsdocBuilder.markTypeNode(typeNode,lineno,startCharno,endLineno,endCharno,matchingLC);
  }
  return typeNode;
}"
18772,"/** 
 * Gets the list of all markers for the documentation in this JSDoc. 
 */
public Collection<Marker> getMarkers(){
  return documentation == null ? null : documentation.markers;
}","/** 
 * Gets the list of all markers for the documentation in this JSDoc. 
 */
public Collection<Marker> getMarkers(){
  return documentation == null ? ImmutableList.<Marker>of() : documentation.markers;
}"
18773,"/** 
 * Adds a textual block to the current marker.
 */
public void markText(String text,int startLineno,int startCharno,int endLineno,int endCharno){
  if (currentMarker != null) {
    currentMarker.description=new JSDocInfo.StringPosition();
    currentMarker.description.setItem(text);
    currentMarker.description.setPositionInformation(startLineno,startCharno,endLineno,endCharno);
  }
}","/** 
 * Adds a textual block to the current marker.
 */
public void markText(String text,int startLineno,int startCharno,int endLineno,int endCharno){
  if (currentMarker != null) {
    JSDocInfo.StringPosition position=new JSDocInfo.StringPosition();
    position.setItem(text);
    position.setPositionInformation(startLineno,startCharno,endLineno,endCharno);
    currentMarker.setDescription(position);
  }
}"
18774,"/** 
 * Adds a marker to the current JSDocInfo and populates the marker with the annotation information.
 */
public void markAnnotation(String annotation,int lineno,int charno){
  JSDocInfo.Marker marker=currentInfo.addMarker();
  if (marker != null) {
    marker.annotation=new JSDocInfo.StringPosition();
    marker.annotation.setItem(annotation);
    marker.annotation.setPositionInformation(lineno,charno,lineno,charno + annotation.length());
  }
  currentMarker=marker;
}","/** 
 * Adds a marker to the current JSDocInfo and populates the marker with the annotation information.
 */
public void markAnnotation(String annotation,int lineno,int charno){
  JSDocInfo.Marker marker=currentInfo.addMarker();
  if (marker != null) {
    JSDocInfo.TrimmedStringPosition position=new JSDocInfo.TrimmedStringPosition();
    position.setItem(annotation);
    position.setPositionInformation(lineno,charno,lineno,charno + annotation.length());
    marker.setAnnotation(position);
    populated=true;
  }
  currentMarker=marker;
}"
18775,"/** 
 * Adds a name declaration to the current marker.
 */
public void markName(String name,int lineno,int charno){
  if (currentMarker != null) {
    currentMarker.name=new JSDocInfo.StringPosition();
    currentMarker.name.setItem(name);
    currentMarker.name.setPositionInformation(lineno,charno,lineno,charno + name.length());
  }
}","/** 
 * Adds a name declaration to the current marker.
 */
public void markName(String name,int lineno,int charno){
  if (currentMarker != null) {
    JSDocInfo.TrimmedStringPosition position=new JSDocInfo.TrimmedStringPosition();
    position.setItem(name);
    position.setPositionInformation(lineno,charno,lineno,charno + name.length());
    currentMarker.setName(position);
  }
}"
18776,"/** 
 * Adds a type declaration to the current marker.
 */
public void markTypeNode(Node typeNode,int lineno,int startCharno,int endCharno,boolean hasLC){
  if (currentMarker != null) {
    currentMarker.type=new JSDocInfo.TypePosition();
    currentMarker.type.setItem(typeNode);
    currentMarker.type.hasBrackets=hasLC;
    currentMarker.type.setPositionInformation(lineno,startCharno,lineno,endCharno);
  }
}","/** 
 * Adds a type declaration to the current marker.
 */
public void markTypeNode(Node typeNode,int lineno,int startCharno,int endLineno,int endCharno,boolean hasLC){
  if (currentMarker != null) {
    JSDocInfo.TypePosition position=new JSDocInfo.TypePosition();
    position.setItem(typeNode);
    position.setHasBrackets(hasLC);
    position.setPositionInformation(lineno,startCharno,endLineno,endCharno);
    currentMarker.setType(position);
  }
}"
18777,"/** 
 * Sets the position information contained in this source position.
 */
public void setPositionInformation(int startLineno,int startCharno,int endLineno,int endCharno){
  this.startLineno=startLineno;
  this.startCharno=startCharno;
  this.endLineno=endLineno;
  this.endCharno=endCharno;
}","/** 
 * Sets the position information contained in this source position.
 */
public void setPositionInformation(int startLineno,int startCharno,int endLineno,int endCharno){
  if (startLineno == endLineno) {
    if (startCharno >= endCharno) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + startCharno + ""String_Node_Str""+ ""String_Node_Str""+ endCharno);
    }
  }
 else {
    if (startLineno > endLineno) {
      throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + startLineno + ""String_Node_Str""+ ""String_Node_Str""+ endLineno);
    }
  }
  this.startLineno=startLineno;
  this.startCharno=startCharno;
  this.endLineno=endLineno;
  this.endCharno=endCharno;
}"
18778,"private void assertMarkerPosition(Node n,int lineno,int charno){
  int count=0;
  for (  JSDocInfo.Marker marker : n.getJSDocInfo().getMarkers()) {
    assertEquals(lineno,marker.annotation.getStartLine());
    assertEquals(charno,marker.annotation.getPositionOnStartLine());
    count++;
  }
  assertEquals(1,count);
}","private void assertMarkerPosition(Node n,int lineno,int charno){
  int count=0;
  for (  JSDocInfo.Marker marker : n.getJSDocInfo().getMarkers()) {
    assertEquals(lineno,marker.getAnnotation().getStartLine());
    assertEquals(charno,marker.getAnnotation().getPositionOnStartLine());
    count++;
  }
  assertEquals(1,count);
}"
18779,"/** 
 * Set the implicit prototype if it's possible to do so.
 * @return True if we were able to set the implicit prototype successfully,false if it was not possible to do so for some reason. There are a few different reasons why this could fail: for example, numbers can't be implicit prototypes, and we don't want to change the implicit prototype if other classes have already subclassed this one.
 */
public boolean resetImplicitPrototype(JSType type,ObjectType newImplicitProto){
  if (type instanceof PrototypeObjectType) {
    PrototypeObjectType poType=(PrototypeObjectType)type;
    if (!poType.hasCachedValues()) {
      poType.setImplicitPrototype(newImplicitProto);
      return true;
    }
  }
  return false;
}","/** 
 * Set the implicit prototype if it's possible to do so.
 * @return True if we were able to set the implicit prototype successfully,false if it was not possible to do so for some reason. There are a few different reasons why this could fail: for example, numbers can't be implicit prototypes, and we don't want to change the implicit prototype if other classes have already subclassed this one.
 */
public boolean resetImplicitPrototype(JSType type,ObjectType newImplicitProto){
  if (type instanceof PrototypeObjectType) {
    PrototypeObjectType poType=(PrototypeObjectType)type;
    poType.clearCachedValues();
    poType.setImplicitPrototype(newImplicitProto);
    return true;
  }
  return false;
}"
18780,"/** 
 * Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values.
 */
public boolean hasCachedValues(){
  return !unknown;
}","/** 
 * Returns true if any cached values have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values.
 */
public boolean hasCachedValues(){
  return !unknown;
}"
18781,"/** 
 * Sets the source node.
 */
public void setSource(Node source){
  if (null == source) {
    prototypeSlot=null;
  }
  this.source=source;
}","/** 
 * Sets the source node.
 */
public void setSource(Node source){
  if (prototypeSlot != null) {
    if (source == null || prototypeSlot.getNode() == null) {
      prototypeSlot=new Property(prototypeSlot.getName(),prototypeSlot.getType(),prototypeSlot.isTypeInferred(),source);
    }
  }
  this.source=source;
}"
18782,"private FlowScope narrowScope(FlowScope scope,Node node,JSType narrowed){
  scope=scope.createChildFlowScope();
  if (node.getType() == Token.GETPROP) {
    scope.inferQualifiedSlot(node.getQualifiedName(),getNativeType(UNKNOWN_TYPE),narrowed);
  }
 else {
    redeclareSimpleVar(scope,node,narrowed);
  }
  return scope;
}","private FlowScope narrowScope(FlowScope scope,Node node,JSType narrowed){
  scope=scope.createChildFlowScope();
  if (node.getType() == Token.GETPROP) {
    scope.inferQualifiedSlot(node.getQualifiedName(),getJSType(node),narrowed);
  }
 else {
    redeclareSimpleVar(scope,node,narrowed);
  }
  return scope;
}"
18783,"public void testClosure7() throws Exception {
  testClosureTypes(CLOSURE_DEFS + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testClosure7() throws Exception {
  testClosureTypes(CLOSURE_DEFS + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}"
18784,"private void reportRefToUndefinedName(Name name,Ref ref){
  while (name.parent != null && name.parent.globalSets + name.parent.localSets == 0) {
    name=name.parent;
  }
  compiler.report(JSError.make(ref.getSourceName(),ref.node,level,UNDEFINED_NAME_WARNING,name.fullName()));
}","private void reportRefToUndefinedName(Name name,Ref ref){
  while (name.parent != null && name.parent.globalSets + name.parent.localSets == 0) {
    name=name.parent;
  }
  compiler.report(JSError.make(ref.getSourceName(),ref.node,level,UNDEFINED_NAME_WARNING,name.getFullName()));
}"
18785,"private void reportBadModuleReference(Name name,Ref ref){
  compiler.report(JSError.make(ref.source.getName(),ref.node,STRICT_MODULE_DEP_QNAME,ref.getModule().getName(),name.getDeclaration().getModule().getName(),name.fullName()));
}","private void reportBadModuleReference(Name name,Ref ref){
  compiler.report(JSError.make(ref.source.getName(),ref.node,STRICT_MODULE_DEP_QNAME,ref.getModule().getName(),name.getDeclaration().getModule().getName(),name.getFullName()));
}"
18786,"private void validateName(Name name,boolean isDefined){
  Ref declaration=name.getDeclaration();
  Name parent=name.parent;
  boolean singleGlobalParentDecl=parent != null && parent.getDeclaration() != null && parent.localSets == 0;
  JSModuleGraph moduleGraph=compiler.getModuleGraph();
  for (  Ref ref : name.getRefs()) {
    if (!isDefined && !isTypedef(ref)) {
      reportRefToUndefinedName(name,ref);
    }
 else     if (declaration != null && ref.getModule() != declaration.getModule() && !moduleGraph.dependsOn(ref.getModule(),declaration.getModule())) {
      reportBadModuleReference(name,ref);
    }
 else     if (ref.scope.isGlobal() && singleGlobalParentDecl && parent.getDeclaration().preOrderIndex > ref.preOrderIndex) {
      compiler.report(JSError.make(ref.source.getName(),ref.node,NAME_DEFINED_LATE_WARNING,name.fullName(),parent.fullName(),parent.getDeclaration().source.getName(),String.valueOf(parent.getDeclaration().node.getLineno())));
    }
  }
}","private void validateName(Name name,boolean isDefined){
  Ref declaration=name.getDeclaration();
  Name parent=name.parent;
  boolean singleGlobalParentDecl=parent != null && parent.getDeclaration() != null && parent.localSets == 0;
  JSModuleGraph moduleGraph=compiler.getModuleGraph();
  for (  Ref ref : name.getRefs()) {
    if (!isDefined && !isTypedef(ref)) {
      reportRefToUndefinedName(name,ref);
    }
 else     if (declaration != null && ref.getModule() != declaration.getModule() && !moduleGraph.dependsOn(ref.getModule(),declaration.getModule())) {
      reportBadModuleReference(name,ref);
    }
 else     if (ref.scope.isGlobal() && singleGlobalParentDecl && parent.getDeclaration().preOrderIndex > ref.preOrderIndex) {
      compiler.report(JSError.make(ref.source.getName(),ref.node,NAME_DEFINED_LATE_WARNING,name.getFullName(),parent.getFullName(),parent.getDeclaration().source.getName(),String.valueOf(parent.getDeclaration().node.getLineno())));
    }
  }
}"
18787,"/** 
 * Reports a warning because a namespace was redefined.
 * @param nameObj A namespace that is being redefined
 * @param ref The reference that set the namespace
 */
private void warnAboutNamespaceRedefinition(Name nameObj,Ref ref){
  compiler.report(JSError.make(ref.getSourceName(),ref.node,NAMESPACE_REDEFINED_WARNING,nameObj.fullName()));
}","/** 
 * Reports a warning because a namespace was redefined.
 * @param nameObj A namespace that is being redefined
 * @param ref The reference that set the namespace
 */
private void warnAboutNamespaceRedefinition(Name nameObj,Ref ref){
  compiler.report(JSError.make(ref.getSourceName(),ref.node,NAMESPACE_REDEFINED_WARNING,nameObj.getFullName()));
}"
18788,"/** 
 * Warns about any references to ""this"" in the given FUNCTION. The function is getting collapsed, so the references will change.
 */
private void checkForHosedThisReferences(Node function,JSDocInfo docInfo,final Name name){
  if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) {
    NodeTraversal.traverse(compiler,function.getLastChild(),new NodeTraversal.AbstractShallowCallback(){
      @Override public void visit(      NodeTraversal t,      Node n,      Node parent){
        if (n.getType() == Token.THIS) {
          compiler.report(JSError.make(name.getDeclaration().getSourceName(),n,UNSAFE_THIS,name.fullName()));
        }
      }
    }
);
  }
}","/** 
 * Warns about any references to ""this"" in the given FUNCTION. The function is getting collapsed, so the references will change.
 */
private void checkForHosedThisReferences(Node function,JSDocInfo docInfo,final Name name){
  if (docInfo == null || (!docInfo.isConstructor() && !docInfo.hasThisType())) {
    NodeTraversal.traverse(compiler,function.getLastChild(),new NodeTraversal.AbstractShallowCallback(){
      @Override public void visit(      NodeTraversal t,      Node n,      Node parent){
        if (n.getType() == Token.THIS) {
          compiler.report(JSError.make(name.getDeclaration().getSourceName(),n,UNSAFE_THIS,name.getFullName()));
        }
      }
    }
);
  }
}"
18789,"@Override public void process(Node externs,Node root){
  GlobalNamespace namespace;
  if (collapsePropertiesOnExternTypes) {
    namespace=new GlobalNamespace(compiler,externs,root);
  }
 else {
    namespace=new GlobalNamespace(compiler,root);
  }
  if (inlineAliases) {
    inlineAliases(namespace);
  }
  nameMap=namespace.getNameIndex();
  globalNames=namespace.getNameForest();
  checkNamespaces();
  for (  Name n : globalNames) {
    flattenReferencesToCollapsibleDescendantNames(n,n.getName());
  }
  for (  Name n : globalNames) {
    collapseDeclarationOfNameAndDescendants(n,n.getName());
  }
}","@Override public void process(Node externs,Node root){
  GlobalNamespace namespace;
  if (collapsePropertiesOnExternTypes) {
    namespace=new GlobalNamespace(compiler,externs,root);
  }
 else {
    namespace=new GlobalNamespace(compiler,root);
  }
  if (inlineAliases) {
    inlineAliases(namespace);
  }
  nameMap=namespace.getNameIndex();
  globalNames=namespace.getNameForest();
  checkNamespaces();
  for (  Name n : globalNames) {
    flattenReferencesToCollapsibleDescendantNames(n,n.getBaseName());
  }
  for (  Name n : globalNames) {
    collapseDeclarationOfNameAndDescendants(n,n.getBaseName());
  }
}"
18790,"/** 
 * Flattens all references to collapsible properties of a global name except their initial definitions. Recurses on subnames.
 * @param n An object representing a global name
 * @param alias The flattened name for {@code n}
 */
private void flattenReferencesToCollapsibleDescendantNames(Name n,String alias){
  if (n.props == null)   return;
  for (  Name p : n.props) {
    String propAlias=appendPropForAlias(alias,p.getName());
    if (p.canCollapse()) {
      flattenReferencesTo(p,propAlias);
    }
 else     if (p.isSimpleStubDeclaration()) {
      flattenSimpleStubDeclaration(p,propAlias);
    }
    flattenReferencesToCollapsibleDescendantNames(p,propAlias);
  }
}","/** 
 * Flattens all references to collapsible properties of a global name except their initial definitions. Recurses on subnames.
 * @param n An object representing a global name
 * @param alias The flattened name for {@code n}
 */
private void flattenReferencesToCollapsibleDescendantNames(Name n,String alias){
  if (n.props == null)   return;
  for (  Name p : n.props) {
    String propAlias=appendPropForAlias(alias,p.getBaseName());
    if (p.canCollapse()) {
      flattenReferencesTo(p,propAlias);
    }
 else     if (p.isSimpleStubDeclaration()) {
      flattenSimpleStubDeclaration(p,propAlias);
    }
    flattenReferencesToCollapsibleDescendantNames(p,propAlias);
  }
}"
18791,"/** 
 * Updates the initial assignment to a collapsible property at global scope by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1). The property's value may either be a primitive or an object literal or function whose properties aren't collapsible.
 * @param alias The flattened property name (e.g. ""a$b"")
 * @param refName The name for the reference being updated.
 * @param ref An object containing information about the assignment gettingupdated
 */
private void updateSimpleDeclaration(String alias,Name refName,Ref ref){
  Node rvalue=ref.node.getNext();
  Node parent=ref.node.getParent();
  Node gramps=parent.getParent();
  Node greatGramps=gramps.getParent();
  Node greatGreatGramps=greatGramps.getParent();
  if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
    checkForHosedThisReferences(rvalue,refName.docInfo,refName);
  }
  Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,gramps.getFirstChild(),refName.fullName());
  NodeUtil.copyNameAnnotations(ref.node.getLastChild(),nameNode);
  if (gramps.getType() == Token.EXPR_RESULT) {
    parent.removeChild(rvalue);
    nameNode.addChildToFront(rvalue);
    Node varNode=new Node(Token.VAR,nameNode);
    greatGramps.replaceChild(gramps,varNode);
  }
 else {
    Preconditions.checkNotNull(ref.getTwin());
    Node current=gramps;
    Node currentParent=gramps.getParent();
    for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current=currentParent, currentParent=currentParent.getParent()) {
    }
    Node stubVar=new Node(Token.VAR,nameNode.cloneTree()).copyInformationFrom(nameNode);
    currentParent.addChildBefore(stubVar,current);
    parent.replaceChild(ref.node,nameNode);
  }
  compiler.reportCodeChange();
}","/** 
 * Updates the initial assignment to a collapsible property at global scope by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1). The property's value may either be a primitive or an object literal or function whose properties aren't collapsible.
 * @param alias The flattened property name (e.g. ""a$b"")
 * @param refName The name for the reference being updated.
 * @param ref An object containing information about the assignment gettingupdated
 */
private void updateSimpleDeclaration(String alias,Name refName,Ref ref){
  Node rvalue=ref.node.getNext();
  Node parent=ref.node.getParent();
  Node gramps=parent.getParent();
  Node greatGramps=gramps.getParent();
  Node greatGreatGramps=greatGramps.getParent();
  if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
    checkForHosedThisReferences(rvalue,refName.docInfo,refName);
  }
  Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,gramps.getFirstChild(),refName.getFullName());
  NodeUtil.copyNameAnnotations(ref.node.getLastChild(),nameNode);
  if (gramps.getType() == Token.EXPR_RESULT) {
    parent.removeChild(rvalue);
    nameNode.addChildToFront(rvalue);
    Node varNode=new Node(Token.VAR,nameNode);
    greatGramps.replaceChild(gramps,varNode);
  }
 else {
    Preconditions.checkNotNull(ref.getTwin());
    Node current=gramps;
    Node currentParent=gramps.getParent();
    for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current=currentParent, currentParent=currentParent.getParent()) {
    }
    Node stubVar=new Node(Token.VAR,nameNode.cloneTree()).copyInformationFrom(nameNode);
    currentParent.addChildBefore(stubVar,current);
    parent.replaceChild(ref.node,nameNode);
  }
  compiler.reportCodeChange();
}"
18792,"/** 
 * Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.
 * @param alias The object literal's flattened name (e.g. ""a$b$c"")
 * @param objlit The OBJLIT node
 * @param varNode The VAR node to which new global variables should be addedas children
 * @param nameToAddAfter The child of {@code varNode} after which newvariables should be added (may be null)
 * @param varParent {@code varNode}'s parent
 * @return The number of variables added
 */
private int declareVarsForObjLitValues(Name objlitName,String alias,Node objlit,Node varNode,Node nameToAddAfter,Node varParent){
  int numVars=0;
  int arbitraryNameCounter=0;
  boolean discardKeys=!objlitName.shouldKeepKeys();
  for (Node key=objlit.getFirstChild(), nextKey; key != null; key=nextKey) {
    Node value=key.getFirstChild();
    nextKey=key.getNext();
    if (key.getType() == Token.GET || key.getType() == Token.SET) {
      continue;
    }
    boolean isJsIdentifier=key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString());
    String propName=isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);
    String qName=objlitName.fullName() + '.' + propName;
    Name p=nameMap.get(qName);
    if (p != null && !p.canCollapse()) {
      continue;
    }
    String propAlias=appendPropForAlias(alias,propName);
    Node refNode=null;
    if (discardKeys) {
      objlit.removeChild(key);
      value.detachFromParent();
    }
 else {
      refNode=Node.newString(Token.NAME,propAlias);
      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
        refNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
      }
      key.replaceChild(value,refNode);
    }
    Node nameNode=Node.newString(Token.NAME,propAlias);
    nameNode.addChildToFront(value);
    if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    Node newVar=new Node(Token.VAR,nameNode).copyInformationFromForTree(key);
    if (nameToAddAfter != null) {
      varParent.addChildAfter(newVar,nameToAddAfter);
    }
 else {
      varParent.addChildBefore(newVar,varNode);
    }
    compiler.reportCodeChange();
    nameToAddAfter=newVar;
    if (isJsIdentifier && p != null) {
      if (!discardKeys) {
        Ref newAlias=p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);
        newAlias.node=refNode;
        p.addRef(newAlias);
      }
      p.getDeclaration().node=nameNode;
      if (value.getType() == Token.FUNCTION) {
        checkForHosedThisReferences(value,value.getJSDocInfo(),p);
      }
    }
    numVars++;
  }
  return numVars;
}","/** 
 * Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.
 * @param alias The object literal's flattened name (e.g. ""a$b$c"")
 * @param objlit The OBJLIT node
 * @param varNode The VAR node to which new global variables should be addedas children
 * @param nameToAddAfter The child of {@code varNode} after which newvariables should be added (may be null)
 * @param varParent {@code varNode}'s parent
 * @return The number of variables added
 */
private int declareVarsForObjLitValues(Name objlitName,String alias,Node objlit,Node varNode,Node nameToAddAfter,Node varParent){
  int numVars=0;
  int arbitraryNameCounter=0;
  boolean discardKeys=!objlitName.shouldKeepKeys();
  for (Node key=objlit.getFirstChild(), nextKey; key != null; key=nextKey) {
    Node value=key.getFirstChild();
    nextKey=key.getNext();
    if (key.getType() == Token.GET || key.getType() == Token.SET) {
      continue;
    }
    boolean isJsIdentifier=key.getType() != Token.NUMBER && TokenStream.isJSIdentifier(key.getString());
    String propName=isJsIdentifier ? key.getString() : String.valueOf(++arbitraryNameCounter);
    String qName=objlitName.getFullName() + '.' + propName;
    Name p=nameMap.get(qName);
    if (p != null && !p.canCollapse()) {
      continue;
    }
    String propAlias=appendPropForAlias(alias,propName);
    Node refNode=null;
    if (discardKeys) {
      objlit.removeChild(key);
      value.detachFromParent();
    }
 else {
      refNode=Node.newString(Token.NAME,propAlias);
      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
        refNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
      }
      key.replaceChild(value,refNode);
    }
    Node nameNode=Node.newString(Token.NAME,propAlias);
    nameNode.addChildToFront(value);
    if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    Node newVar=new Node(Token.VAR,nameNode).copyInformationFromForTree(key);
    if (nameToAddAfter != null) {
      varParent.addChildAfter(newVar,nameToAddAfter);
    }
 else {
      varParent.addChildBefore(newVar,varNode);
    }
    compiler.reportCodeChange();
    nameToAddAfter=newVar;
    if (isJsIdentifier && p != null) {
      if (!discardKeys) {
        Ref newAlias=p.getDeclaration().cloneAndReclassify(Ref.Type.ALIASING_GET);
        newAlias.node=refNode;
        p.addRef(newAlias);
      }
      p.getDeclaration().node=nameNode;
      if (value.getType() == Token.FUNCTION) {
        checkForHosedThisReferences(value,value.getJSDocInfo(),p);
      }
    }
    numVars++;
  }
  return numVars;
}"
18793,"/** 
 * Adds global variable ""stubs"" for any properties of a global name that are only set in a local scope or read but never set.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name of the object whose properties we areadding stubs for (e.g. ""a$b$c"")
 * @param parent The node to which new global variables should be addedas children
 * @param addAfter The child of after which newvariables should be added (may be null)
 * @return The number of variables added
 */
private int addStubsForUndeclaredProperties(Name n,String alias,Node parent,Node addAfter){
  Preconditions.checkState(n.canCollapseUnannotatedChildNames());
  Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));
  Preconditions.checkNotNull(addAfter);
  int numStubs=0;
  if (n.props != null) {
    for (    Name p : n.props) {
      if (p.needsToBeStubbed()) {
        String propAlias=appendPropForAlias(alias,p.getName());
        Node nameNode=Node.newString(Token.NAME,propAlias);
        Node newVar=new Node(Token.VAR,nameNode).copyInformationFromForTree(addAfter);
        parent.addChildAfter(newVar,addAfter);
        addAfter=newVar;
        numStubs++;
        compiler.reportCodeChange();
        if (p.getRefs().get(0).node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
          nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
        }
      }
    }
  }
  return numStubs;
}","/** 
 * Adds global variable ""stubs"" for any properties of a global name that are only set in a local scope or read but never set.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name of the object whose properties we areadding stubs for (e.g. ""a$b$c"")
 * @param parent The node to which new global variables should be addedas children
 * @param addAfter The child of after which newvariables should be added (may be null)
 * @return The number of variables added
 */
private int addStubsForUndeclaredProperties(Name n,String alias,Node parent,Node addAfter){
  Preconditions.checkState(n.canCollapseUnannotatedChildNames());
  Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));
  Preconditions.checkNotNull(addAfter);
  int numStubs=0;
  if (n.props != null) {
    for (    Name p : n.props) {
      if (p.needsToBeStubbed()) {
        String propAlias=appendPropForAlias(alias,p.getBaseName());
        Node nameNode=Node.newString(Token.NAME,propAlias);
        Node newVar=new Node(Token.VAR,nameNode).copyInformationFromForTree(addAfter);
        parent.addChildAfter(newVar,addAfter);
        addAfter=newVar;
        numStubs++;
        compiler.reportCodeChange();
        if (p.getRefs().get(0).node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
          nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
        }
      }
    }
  }
  return numStubs;
}"
18794,"/** 
 * Flattens all references to a collapsible property of a global name except its initial definition.
 * @param n A global property name (e.g. ""a.b"" or ""a.b.c.d"")
 * @param alias The flattened name (e.g. ""a$b"" or ""a$b$c$d"")
 */
private void flattenReferencesTo(Name n,String alias){
  String originalName=n.fullName();
  for (  Ref r : n.getRefs()) {
    if (r == n.getDeclaration()) {
      continue;
    }
    Node rParent=r.node.getParent();
    if (!NodeUtil.isObjectLitKey(r.node,rParent) && (r.getTwin() == null || r.isSet())) {
      flattenNameRef(alias,r.node,rParent,originalName);
    }
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      flattenPrefixes(alias,p,1);
    }
  }
}","/** 
 * Flattens all references to a collapsible property of a global name except its initial definition.
 * @param n A global property name (e.g. ""a.b"" or ""a.b.c.d"")
 * @param alias The flattened name (e.g. ""a$b"" or ""a$b$c$d"")
 */
private void flattenReferencesTo(Name n,String alias){
  String originalName=n.getFullName();
  for (  Ref r : n.getRefs()) {
    if (r == n.getDeclaration()) {
      continue;
    }
    Node rParent=r.node.getParent();
    if (!NodeUtil.isObjectLitKey(r.node,rParent) && (r.getTwin() == null || r.isSet())) {
      flattenNameRef(alias,r.node,rParent,originalName);
    }
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      flattenPrefixes(alias,p,1);
    }
  }
}"
18795,"/** 
 * Flattens all occurrences of a name as a prefix of subnames beginning with a particular subname.
 * @param n A global property name (e.g. ""a.b.c.d"")
 * @param alias A flattened prefix name (e.g. ""a$b"")
 * @param depth The difference in depth between the property name andthe prefix name (e.g. 2)
 */
private void flattenPrefixes(String alias,Name n,int depth){
  String originalName=n.fullName();
  Ref decl=n.getDeclaration();
  if (decl != null && decl.node != null && decl.node.getType() == Token.GETPROP) {
    flattenNameRefAtDepth(alias,decl.node,depth,originalName);
  }
  for (  Ref r : n.getRefs()) {
    if (r == decl) {
      continue;
    }
    if (r.getTwin() == null || r.isSet()) {
      flattenNameRefAtDepth(alias,r.node,depth,originalName);
    }
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      flattenPrefixes(alias,p,depth + 1);
    }
  }
}","/** 
 * Flattens all occurrences of a name as a prefix of subnames beginning with a particular subname.
 * @param n A global property name (e.g. ""a.b.c.d"")
 * @param alias A flattened prefix name (e.g. ""a$b"")
 * @param depth The difference in depth between the property name andthe prefix name (e.g. 2)
 */
private void flattenPrefixes(String alias,Name n,int depth){
  String originalName=n.getFullName();
  Ref decl=n.getDeclaration();
  if (decl != null && decl.node != null && decl.node.getType() == Token.GETPROP) {
    flattenNameRefAtDepth(alias,decl.node,depth,originalName);
  }
  for (  Ref r : n.getRefs()) {
    if (r == decl) {
      continue;
    }
    if (r.getTwin() == null || r.isSet()) {
      flattenNameRefAtDepth(alias,r.node,depth,originalName);
    }
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      flattenPrefixes(alias,p,depth + 1);
    }
  }
}"
18796,"/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at an ASSIGN node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 */
private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n,String alias,boolean canCollapseChildNames){
  Ref ref=n.getDeclaration();
  Node rvalue=ref.node.getNext();
  Node varNode=new Node(Token.VAR);
  Node varParent=ref.node.getAncestor(3);
  Node gramps=ref.node.getAncestor(2);
  boolean isObjLit=rvalue.getType() == Token.OBJECTLIT;
  boolean insertedVarNode=false;
  if (isObjLit && n.canEliminate()) {
    varParent.replaceChild(gramps,varNode);
    ref.node=null;
    insertedVarNode=true;
  }
 else   if (!n.isSimpleName()) {
    if (rvalue.getType() == Token.FUNCTION) {
      checkForHosedThisReferences(rvalue,n.docInfo,n);
    }
    ref.node.getParent().removeChild(rvalue);
    Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,ref.node.getAncestor(2),n.fullName());
    JSDocInfo info=ref.node.getParent().getJSDocInfo();
    if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) || (info != null && info.isConstant())) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    varNode.addChildToBack(nameNode);
    nameNode.addChildToFront(rvalue);
    varParent.replaceChild(gramps,varNode);
    ref.node=nameNode;
    insertedVarNode=true;
  }
  if (canCollapseChildNames) {
    if (isObjLit) {
      declareVarsForObjLitValues(n,alias,rvalue,varNode,varParent.getChildBefore(varNode),varParent);
    }
    addStubsForUndeclaredProperties(n,alias,varParent,varNode);
  }
  if (insertedVarNode) {
    if (!varNode.hasChildren()) {
      varParent.removeChild(varNode);
    }
    compiler.reportCodeChange();
  }
}","/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at an ASSIGN node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 */
private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n,String alias,boolean canCollapseChildNames){
  Ref ref=n.getDeclaration();
  Node rvalue=ref.node.getNext();
  Node varNode=new Node(Token.VAR);
  Node varParent=ref.node.getAncestor(3);
  Node gramps=ref.node.getAncestor(2);
  boolean isObjLit=rvalue.getType() == Token.OBJECTLIT;
  boolean insertedVarNode=false;
  if (isObjLit && n.canEliminate()) {
    varParent.replaceChild(gramps,varNode);
    ref.node=null;
    insertedVarNode=true;
  }
 else   if (!n.isSimpleName()) {
    if (rvalue.getType() == Token.FUNCTION) {
      checkForHosedThisReferences(rvalue,n.docInfo,n);
    }
    ref.node.getParent().removeChild(rvalue);
    Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,ref.node.getAncestor(2),n.getFullName());
    JSDocInfo info=ref.node.getParent().getJSDocInfo();
    if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) || (info != null && info.isConstant())) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    varNode.addChildToBack(nameNode);
    nameNode.addChildToFront(rvalue);
    varParent.replaceChild(gramps,varNode);
    ref.node=nameNode;
    insertedVarNode=true;
  }
  if (canCollapseChildNames) {
    if (isObjLit) {
      declareVarsForObjLitValues(n,alias,rvalue,varNode,varParent.getChildBefore(varNode),varParent);
    }
    addStubsForUndeclaredProperties(n,alias,varParent,varNode);
  }
  if (insertedVarNode) {
    if (!varNode.hasChildren()) {
      varParent.removeChild(varNode);
    }
    compiler.reportCodeChange();
  }
}"
18797,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.getType() == Token.THIS) {
    compiler.report(JSError.make(name.getDeclaration().getSourceName(),n,UNSAFE_THIS,name.fullName()));
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.getType() == Token.THIS) {
    compiler.report(JSError.make(name.getDeclaration().getSourceName(),n,UNSAFE_THIS,name.getFullName()));
  }
}"
18798,"/** 
 * Reports a warning because a namespace was aliased.
 * @param nameObj A namespace that is being aliased
 * @param ref The reference that forced the alias
 */
private void warnAboutNamespaceAliasing(Name nameObj,Ref ref){
  compiler.report(JSError.make(ref.getSourceName(),ref.node,UNSAFE_NAMESPACE_WARNING,nameObj.fullName()));
}","/** 
 * Reports a warning because a namespace was aliased.
 * @param nameObj A namespace that is being aliased
 * @param ref The reference that forced the alias
 */
private void warnAboutNamespaceAliasing(Name nameObj,Ref ref){
  compiler.report(JSError.make(ref.getSourceName(),ref.node,UNSAFE_NAMESPACE_WARNING,nameObj.getFullName()));
}"
18799,"/** 
 * Flattens a stub declaration. This is mostly a hack to support legacy users.
 */
private void flattenSimpleStubDeclaration(Name name,String alias){
  Ref ref=Iterables.getOnlyElement(name.getRefs());
  Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,ref.node,name.fullName());
  Node varNode=new Node(Token.VAR,nameNode).copyInformationFrom(nameNode);
  Preconditions.checkState(ref.node.getParent().getType() == Token.EXPR_RESULT);
  Node parent=ref.node.getParent();
  Node gramps=parent.getParent();
  gramps.replaceChild(parent,varNode);
  compiler.reportCodeChange();
}","/** 
 * Flattens a stub declaration. This is mostly a hack to support legacy users.
 */
private void flattenSimpleStubDeclaration(Name name,String alias){
  Ref ref=Iterables.getOnlyElement(name.getRefs());
  Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,ref.node,name.getFullName());
  Node varNode=new Node(Token.VAR,nameNode).copyInformationFrom(nameNode);
  Preconditions.checkState(ref.node.getParent().getType() == Token.EXPR_RESULT);
  Node parent=ref.node.getParent();
  Node gramps=parent.getParent();
  gramps.replaceChild(parent,varNode);
  compiler.reportCodeChange();
}"
18800,"/** 
 * Collapses definitions of the collapsible properties of a global name. Recurses on subnames that also represent JavaScript objects with collapsible properties.
 * @param n A node representing a global name
 * @param alias The flattened name for {@code n}
 */
private void collapseDeclarationOfNameAndDescendants(Name n,String alias){
  boolean canCollapseChildNames=n.canCollapseUnannotatedChildNames();
  if (n.canCollapse()) {
    updateObjLitOrFunctionDeclaration(n,alias,canCollapseChildNames);
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      collapseDeclarationOfNameAndDescendants(p,appendPropForAlias(alias,p.getName()));
      if (!p.inExterns && canCollapseChildNames && p.getDeclaration() != null && p.canCollapse() && p.getDeclaration().node != null && p.getDeclaration().node.getParent() != null && p.getDeclaration().node.getParent().getType() == Token.ASSIGN) {
        updateSimpleDeclaration(appendPropForAlias(alias,p.getName()),p,p.getDeclaration());
      }
    }
  }
}","/** 
 * Collapses definitions of the collapsible properties of a global name. Recurses on subnames that also represent JavaScript objects with collapsible properties.
 * @param n A node representing a global name
 * @param alias The flattened name for {@code n}
 */
private void collapseDeclarationOfNameAndDescendants(Name n,String alias){
  boolean canCollapseChildNames=n.canCollapseUnannotatedChildNames();
  if (n.canCollapse()) {
    updateObjLitOrFunctionDeclaration(n,alias,canCollapseChildNames);
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      collapseDeclarationOfNameAndDescendants(p,appendPropForAlias(alias,p.getBaseName()));
      if (!p.inExterns && canCollapseChildNames && p.getDeclaration() != null && p.canCollapse() && p.getDeclaration().node != null && p.getDeclaration().node.getParent() != null && p.getDeclaration().node.getParent().getType() == Token.ASSIGN) {
        updateSimpleDeclaration(appendPropForAlias(alias,p.getBaseName()),p,p.getDeclaration());
      }
    }
  }
}"
18801,"@Override public String getName(){
  return name;
}","@Override public String getName(){
  return getFullName();
}"
18802,"Name(String name,Name parent,boolean inExterns){
  this.name=name;
  this.parent=parent;
  this.type=Type.OTHER;
  this.inExterns=inExterns;
}","Name(String name,Name parent,boolean inExterns){
  this.baseName=name;
  this.parent=parent;
  this.type=Type.OTHER;
  this.inExterns=inExterns;
}"
18803,"@Override public String toString(){
  return fullName() + ""String_Node_Str"" + type+ ""String_Node_Str""+ globalSets+ ""String_Node_Str""+ localSets+ ""String_Node_Str""+ totalGets+ ""String_Node_Str""+ aliasingGets+ ""String_Node_Str""+ callGets;
}","@Override public String toString(){
  return getFullName() + ""String_Node_Str"" + type+ ""String_Node_Str""+ globalSets+ ""String_Node_Str""+ localSets+ ""String_Node_Str""+ totalGets+ ""String_Node_Str""+ aliasingGets+ ""String_Node_Str""+ callGets;
}"
18804,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  RefInfo refInfo=allRefInfo.get(n);
  if (refInfo != null) {
    Ref ref=refInfo.ref;
    Name name=refInfo.name;
    String fullName=name.fullName();
switch (ref.type) {
case SET_FROM_GLOBAL:
case SET_FROM_LOCAL:
      Node valParent=getValueParent(ref);
    Node val=valParent.getLastChild();
  if (valParent.getType() == Token.ASSIGN && name.isSimpleName() && name.getDeclaration() == ref) {
    compiler.report(t.makeError(val,INVALID_DEFINE_INIT_ERROR,fullName));
  }
 else   if (processDefineAssignment(t,fullName,val,valParent)) {
    refInfo.name.removeRef(ref);
    lvalueToRemoveLater=valParent;
  }
break;
default :
if (t.inGlobalScope()) {
DefineInfo info=assignableDefines.get(fullName);
if (info != null) {
  setDefineInfoNotAssignable(info,t);
  assignableDefines.remove(fullName);
}
}
break;
}
}
if (!t.inGlobalScope() && n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) {
compiler.report(t.makeError(n,NON_GLOBAL_DEFINE_INIT_ERROR,""String_Node_Str""));
}
if (lvalueToRemoveLater == n) {
lvalueToRemoveLater=null;
if (n.getType() == Token.ASSIGN) {
Node last=n.getLastChild();
n.removeChild(last);
parent.replaceChild(n,last);
}
 else {
Preconditions.checkState(n.getType() == Token.NAME);
n.removeChild(n.getFirstChild());
}
compiler.reportCodeChange();
}
if (n.getType() == Token.CALL) {
if (t.inGlobalScope()) {
for (DefineInfo info : assignableDefines.values()) {
setDefineInfoNotAssignable(info,t);
}
assignableDefines.clear();
}
}
updateAssignAllowedStack(n,false);
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  RefInfo refInfo=allRefInfo.get(n);
  if (refInfo != null) {
    Ref ref=refInfo.ref;
    Name name=refInfo.name;
    String fullName=name.getFullName();
switch (ref.type) {
case SET_FROM_GLOBAL:
case SET_FROM_LOCAL:
      Node valParent=getValueParent(ref);
    Node val=valParent.getLastChild();
  if (valParent.getType() == Token.ASSIGN && name.isSimpleName() && name.getDeclaration() == ref) {
    compiler.report(t.makeError(val,INVALID_DEFINE_INIT_ERROR,fullName));
  }
 else   if (processDefineAssignment(t,fullName,val,valParent)) {
    refInfo.name.removeRef(ref);
    lvalueToRemoveLater=valParent;
  }
break;
default :
if (t.inGlobalScope()) {
DefineInfo info=assignableDefines.get(fullName);
if (info != null) {
  setDefineInfoNotAssignable(info,t);
  assignableDefines.remove(fullName);
}
}
break;
}
}
if (!t.inGlobalScope() && n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) {
compiler.report(t.makeError(n,NON_GLOBAL_DEFINE_INIT_ERROR,""String_Node_Str""));
}
if (lvalueToRemoveLater == n) {
lvalueToRemoveLater=null;
if (n.getType() == Token.ASSIGN) {
Node last=n.getLastChild();
n.removeChild(last);
parent.replaceChild(n,last);
}
 else {
Preconditions.checkState(n.getType() == Token.NAME);
n.removeChild(n.getFirstChild());
}
compiler.reportCodeChange();
}
if (n.getType() == Token.CALL) {
if (t.inGlobalScope()) {
for (DefineInfo info : assignableDefines.values()) {
setDefineInfoNotAssignable(info,t);
}
assignableDefines.clear();
}
}
updateAssignAllowedStack(n,false);
}"
18805,"/** 
 * A   {@link UnionType} contains a given type (alternate) iff the membervector contains it.
 * @param alternate The alternate which might be in this union.
 * @return {@code true} if the alternate is in the union
 */
public boolean contains(JSType type){
  for (  JSType alt : alternates) {
    if (alt.isEquivalentTo(type)) {
      return true;
    }
  }
  return false;
}","/** 
 * A   {@link UnionType} contains a given type (alternate) iff the membervector contains it.
 * @param type The alternate which might be in this union.
 * @return {@code true} if the alternate is in the union
 */
public boolean contains(JSType type){
  for (  JSType alt : alternates) {
    if (alt.isEquivalentTo(type)) {
      return true;
    }
  }
  return false;
}"
18806,"/** 
 * @param item The item to inspect
 * @param propType The property to look for
 * @return The replacement list if the property was removed, or'item' otherwise.
 */
private PropListItem removeProp(PropListItem item,int propType){
  if (item == null) {
    return null;
  }
 else   if (item.getType() == propType) {
    return item.getNext();
  }
 else {
    PropListItem result=removeProp(item.getNext(),propType);
    if (result != item.getNext()) {
      item.setNext(result);
      return item;
    }
 else {
      return item;
    }
  }
}","/** 
 * @param item The item to inspect
 * @param propType The property to look for
 * @return The replacement list if the property was removed, or'item' otherwise.
 */
private PropListItem removeProp(PropListItem item,int propType){
  if (item == null) {
    return null;
  }
 else   if (item.getType() == propType) {
    return item.getNext();
  }
 else {
    PropListItem result=removeProp(item.getNext(),propType);
    if (result != item.getNext()) {
      return item.chain(result);
    }
 else {
      return item;
    }
  }
}"
18807,"/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.NAME:
    typeable=visitName(t,n,parent);
  break;
case Token.LP:
if (parent.getType() != Token.FUNCTION) {
  ensureTyped(t,n,getJSType(n.getFirstChild()));
}
 else {
  typeable=false;
}
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL:
ensureTyped(t,n);
break;
case Token.GET_REF:
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
if (!NodeUtil.isObjectLitKey(n,n.getParent())) {
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET:
case Token.SET:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
typeable=true;
break;
case Token.CALL:
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ:
case Token.SHNE:
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,""String_Node_Str"");
validator.expectString(t,left,leftType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.getType() == Token.OBJECTLIT) {
for (Node key : n.children()) {
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}","/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType, rightType;
  Node left, right;
  boolean typeable=true;
switch (n.getType()) {
case Token.NAME:
    typeable=visitName(t,n,parent);
  break;
case Token.LP:
if (parent.getType() != Token.FUNCTION) {
  ensureTyped(t,n,getJSType(n.getFirstChild()));
}
 else {
  typeable=false;
}
break;
case Token.COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE:
case Token.FALSE:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS:
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL:
ensureTyped(t,n);
break;
case Token.GET_REF:
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING:
if (!NodeUtil.isObjectLitKey(n,n.getParent())) {
ensureTyped(t,n,STRING_TYPE);
}
 else {
typeable=false;
}
break;
case Token.GET:
case Token.SET:
break;
case Token.ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP:
visitGetProp(t,n,parent);
typeable=!(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n);
break;
case Token.GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR:
visitVar(t,n);
typeable=false;
break;
case Token.NEW:
visitNew(t,n);
typeable=true;
break;
case Token.CALL:
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN:
visitReturn(t,n);
typeable=false;
break;
case Token.DEC:
case Token.INC:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS:
case Token.NEG:
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ:
case Token.NE:
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ:
case Token.SHNE:
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,""String_Node_Str"");
validator.expectString(t,left,leftType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case Token.FUNCTION:
visitFunction(t,n);
break;
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable=false;
break;
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable=false;
break;
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.getType() == Token.OBJECTLIT) {
for (Node key : n.children()) {
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkNoTypeCheckSection(n,false);
}"
18808,"/** 
 * Determines whether the given property with @const tag got reassigned
 * @param t The current traversal.
 * @param getprop The getprop node.
 */
private void checkConstantProperty(NodeTraversal t,Node getprop){
  Node parent=getprop.getParent();
  if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop) && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {
    return;
  }
  ObjectType objectType=ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
  String propertyName=getprop.getLastChild().getString();
  if (objectType != null) {
    ObjectType oType=objectType;
    while (oType != null) {
      if (oType.hasReferenceName()) {
        if (initializedConstantProperties.containsEntry(oType.getReferenceName(),propertyName)) {
          compiler.report(t.makeError(getprop,CONST_PROPERTY_REASSIGNED_VALUE,propertyName));
          break;
        }
      }
      oType=oType.getImplicitPrototype();
    }
    JSDocInfo info=objectType.getOwnPropertyJSDocInfo(propertyName);
    if (info != null && info.isConstant() && objectType.hasReferenceName()) {
      initializedConstantProperties.put(objectType.getReferenceName(),propertyName);
    }
    if (objectType.isInstanceType()) {
      ObjectType prototype=objectType.getImplicitPrototype();
      if (prototype != null) {
        JSDocInfo prototypeInfo=prototype.getOwnPropertyJSDocInfo(propertyName);
        if (prototypeInfo != null && prototypeInfo.isConstant() && prototype.hasReferenceName()) {
          initializedConstantProperties.put(prototype.getReferenceName(),propertyName);
        }
      }
    }
  }
}","/** 
 * Determines whether the given property with @const tag got reassigned
 * @param t The current traversal.
 * @param getprop The getprop node.
 */
private void checkConstantProperty(NodeTraversal t,Node getprop){
  Node parent=getprop.getParent();
  if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop) && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {
    return;
  }
  ObjectType objectType=ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
  String propertyName=getprop.getLastChild().getString();
  boolean isConstant=isPropertyDeclaredConstant(objectType,propertyName);
  if (isConstant) {
    ObjectType oType=objectType;
    while (oType != null) {
      if (oType.hasReferenceName()) {
        if (initializedConstantProperties.containsEntry(oType.getReferenceName(),propertyName)) {
          compiler.report(t.makeError(getprop,CONST_PROPERTY_REASSIGNED_VALUE,propertyName));
          break;
        }
      }
      oType=oType.getImplicitPrototype();
    }
    Preconditions.checkState(objectType.hasReferenceName());
    initializedConstantProperties.put(objectType.getReferenceName(),propertyName);
    if (objectType.isInstanceType()) {
      ObjectType prototype=objectType.getImplicitPrototype();
      if (prototype != null) {
        if (prototype.hasProperty(propertyName) && prototype.hasReferenceName()) {
          initializedConstantProperties.put(prototype.getReferenceName(),propertyName);
        }
      }
    }
  }
}"
18809,"/** 
 * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType
 */
private Node parseBasicTypeExpression(JsDocToken token){
  if (token == JsDocToken.STAR) {
    return newNode(Token.STAR);
  }
 else   if (token == JsDocToken.LB) {
    skipEOLs();
    return parseArrayType(next());
  }
 else   if (token == JsDocToken.LC) {
    skipEOLs();
    return parseRecordType(next());
  }
 else   if (token == JsDocToken.LP) {
    skipEOLs();
    return parseUnionType(next());
  }
 else   if (token == JsDocToken.STRING) {
    String string=stream.getString();
    if (""String_Node_Str"".equals(string)) {
      skipEOLs();
      return parseFunctionType(next());
    }
 else     if (""String_Node_Str"".equals(string) || ""String_Node_Str"".equals(string)) {
      return newStringNode(string);
    }
 else {
      return parseTypeName(token);
    }
  }
  return reportGenericTypeSyntaxWarning();
}","/** 
 * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType
 */
private Node parseBasicTypeExpression(JsDocToken token){
  if (token == JsDocToken.STAR) {
    return newNode(Token.STAR);
  }
 else   if (token == JsDocToken.LB) {
    skipEOLs();
    return parseArrayType(next());
  }
 else   if (token == JsDocToken.LC) {
    skipEOLs();
    return parseRecordType(next());
  }
 else   if (token == JsDocToken.LP) {
    skipEOLs();
    return parseUnionType(next());
  }
 else   if (token == JsDocToken.STRING) {
    String string=stream.getString();
    if (""String_Node_Str"".equals(string)) {
      skipEOLs();
      return parseFunctionType(next());
    }
 else     if (""String_Node_Str"".equals(string) || ""String_Node_Str"".equals(string)) {
      return newStringNode(string);
    }
 else {
      return parseTypeName(token);
    }
  }
  restoreLookAhead(token);
  return reportGenericTypeSyntaxWarning();
}"
18810,"/** 
 * FunctionType := 'function' FunctionSignatureType FunctionSignatureType := TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token){
  if (token != JsDocToken.LP) {
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  Node functionType=newNode(Token.FUNCTION);
  Node parameters=null;
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    token=next();
    boolean hasParams=true;
    if (token == JsDocToken.STRING) {
      String tokenStr=stream.getString();
      boolean isThis=""String_Node_Str"".equals(tokenStr);
      boolean isNew=""String_Node_Str"".equals(tokenStr);
      if (isThis || isNew) {
        if (match(JsDocToken.COLON)) {
          next();
          skipEOLs();
          Node contextType=wrapNode(isThis ? Token.THIS : Token.NEW,parseTypeName(next()));
          if (contextType == null) {
            return null;
          }
          functionType.addChildToFront(contextType);
        }
 else {
          return reportTypeSyntaxWarning(""String_Node_Str"");
        }
        if (match(JsDocToken.COMMA)) {
          next();
          skipEOLs();
          token=next();
        }
 else {
          hasParams=false;
        }
      }
    }
    if (hasParams) {
      parameters=parseParametersType(token);
      if (parameters == null) {
        return null;
      }
    }
  }
  if (parameters != null) {
    functionType.addChildToBack(parameters);
  }
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  skipEOLs();
  Node resultType=parseResultType(next());
  if (resultType == null) {
    return null;
  }
 else {
    functionType.addChildToBack(resultType);
  }
  return functionType;
}","/** 
 * FunctionType := 'function' FunctionSignatureType FunctionSignatureType := TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType
 */
private Node parseFunctionType(JsDocToken token){
  if (token != JsDocToken.LP) {
    restoreLookAhead(token);
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  Node functionType=newNode(Token.FUNCTION);
  Node parameters=null;
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    token=next();
    boolean hasParams=true;
    if (token == JsDocToken.STRING) {
      String tokenStr=stream.getString();
      boolean isThis=""String_Node_Str"".equals(tokenStr);
      boolean isNew=""String_Node_Str"".equals(tokenStr);
      if (isThis || isNew) {
        if (match(JsDocToken.COLON)) {
          next();
          skipEOLs();
          Node contextType=wrapNode(isThis ? Token.THIS : Token.NEW,parseTypeName(next()));
          if (contextType == null) {
            return null;
          }
          functionType.addChildToFront(contextType);
        }
 else {
          return reportTypeSyntaxWarning(""String_Node_Str"");
        }
        if (match(JsDocToken.COMMA)) {
          next();
          skipEOLs();
          token=next();
        }
 else {
          hasParams=false;
        }
      }
    }
    if (hasParams) {
      parameters=parseParametersType(token);
      if (parameters == null) {
        return null;
      }
    }
  }
  if (parameters != null) {
    functionType.addChildToBack(parameters);
  }
  skipEOLs();
  if (!match(JsDocToken.RP)) {
    return reportTypeSyntaxWarning(""String_Node_Str"");
  }
  skipEOLs();
  Node resultType=parseResultType(next());
  if (resultType == null) {
    return null;
  }
 else {
    functionType.addChildToBack(resultType);
  }
  return functionType;
}"
18811,"/** 
 * Parses a   {@link JSDocInfo} object. This parsing method reads all tokensreturned by the  {@link JsDocTokenStream#getJsDocToken()} method until the{@link JsDocToken#EOC} is returned.
 * @return {@code true} if JSDoc information was correctly parsed,{@code false} otherwise
 */
boolean parse(){
  int lineno;
  int charno;
  JSTypeExpression type;
  state=State.SEARCHING_ANNOTATION;
  skipEOLs();
  JsDocToken token=next();
  List<ExtendedTypeInfo> extendedTypes=Lists.newArrayList();
  if (jsdocBuilder.shouldParseDocumentation()) {
    ExtractionInfo blockInfo=extractBlockComment(token);
    token=blockInfo.token;
    if (!blockInfo.string.isEmpty()) {
      jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
  }
 else {
    if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
      jsdocBuilder.recordBlockDescription(""String_Node_Str"");
    }
  }
  retry:   for (; ; ) {
switch (token) {
case ANNOTATION:
      if (state == State.SEARCHING_ANNOTATION) {
        state=State.SEARCHING_NEWLINE;
        lineno=stream.getLineno();
        charno=stream.getCharno();
        String annotationName=stream.getString();
        Annotation annotation=annotationNames.get(annotationName);
        if (annotation == null) {
          parser.addParserWarning(""String_Node_Str"",annotationName,stream.getLineno(),stream.getCharno());
        }
 else {
          jsdocBuilder.markAnnotation(annotationName,lineno,charno);
switch (annotation) {
case AUTHOR:
            if (jsdocBuilder.shouldParseDocumentation()) {
              ExtractionInfo authorInfo=extractSingleLineBlock();
              String author=authorInfo.string;
              if (author.length() == 0) {
                parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
              }
 else {
                jsdocBuilder.addAuthor(author);
              }
              token=authorInfo.token;
            }
 else {
              token=eatTokensUntilEOL(token);
            }
          continue retry;
case CONSTANT:
        if (!jsdocBuilder.recordConstancy()) {
          parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
        }
      token=eatTokensUntilEOL();
    continue retry;
case CONSTRUCTOR:
  if (!jsdocBuilder.recordConstructor()) {
    if (jsdocBuilder.isInterfaceRecorded()) {
      parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
    }
 else {
      parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
    }
  }
token=eatTokensUntilEOL();
continue retry;
case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
ExtractionInfo reasonInfo=extractMultilineTextualBlock(token);
String reason=reasonInfo.string;
if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}
token=reasonInfo.token;
continue retry;
case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
token=eatTokensUntilEOL();
continue retry;
case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
token=eatTokensUntilEOL();
continue retry;
}
 else {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
jsdocBuilder.recordDescription(description);
token=descriptionInfo.token;
continue retry;
}
case FILE_OVERVIEW:
String fileOverview=""String_Node_Str"";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo=extractMultilineTextualBlock(token,WhitespaceOption.TRIM);
fileOverview=fileOverviewInfo.string;
token=fileOverviewInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
continue retry;
case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo=extractMultilineTextualBlock(token,WhitespaceOption.PRESERVE);
String preserve=preserveInfo.string;
if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}
token=preserveInfo.token;
continue retry;
case ENUM:
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
}
if (type == null) {
type=createJSTypeExpression(newStringNode(""String_Node_Str""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatTokensUntilEOL(token);
continue retry;
case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
boolean matchingRc=false;
if (token == JsDocToken.LC) {
token=next();
matchingRc=true;
}
if (token == JsDocToken.STRING) {
Node typeNode=parseAndRecordTypeNameNode(token,lineno,charno,matchingRc);
lineno=stream.getLineno();
charno=stream.getCharno();
typeNode=wrapNode(Token.BANG,typeNode);
if (typeNode != null && !matchingRc) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE,true);
}
type=createJSTypeExpression(typeNode);
if (annotation == Annotation.EXTENDS) {
extendedTypes.add(new ExtendedTypeInfo(type,stream.getLineno(),stream.getCharno()));
}
 else {
Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
}
token=next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatTokensUntilEOL(token);
continue retry;
case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case LENDS:
skipEOLs();
matchingRc=false;
if (match(JsDocToken.LC)) {
token=next();
matchingRc=true;
}
if (match(JsDocToken.STRING)) {
token=next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case MEANING:
ExtractionInfo meaningInfo=extractMultilineTextualBlock(token);
String meaning=meaningInfo.string;
token=meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
continue retry;
case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NOT_IMPLEMENTED:
token=eatTokensUntilEOL();
continue retry;
case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case THROWS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
if (type == null) {
token=eatTokensUntilEOL();
continue retry;
}
}
token=current();
jsdocBuilder.recordThrowType(type);
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type,description);
}
token=descriptionInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case PARAM:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordParamTypeNode(token));
if (type == null) {
token=eatTokensUntilEOL();
continue retry;
}
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
}
String name=null;
boolean isBracketedParam=JsDocToken.LB == token;
if (isBracketedParam) {
token=next();
}
if (JsDocToken.STRING != token) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
 else {
name=stream.getString();
if (isBracketedParam) {
token=next();
if (JsDocToken.EQUALS == token) {
token=next();
if (JsDocToken.STRING == token) {
token=next();
}
}
if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""String_Node_Str"");
}
 else if (type != null) {
type=JSTypeExpression.makeOptionalArg(type);
}
}
if (name.indexOf('.') > -1) {
name=null;
}
 else if (!jsdocBuilder.recordParameter(name,type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
 else {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
}
}
if (name == null) {
token=eatTokensUntilEOL(token);
continue retry;
}
jsdocBuilder.markName(name,lineno,charno);
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo paramDescriptionInfo=extractMultilineTextualBlock(token);
String paramDescription=paramDescriptionInfo.string;
if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,paramDescription);
}
token=paramDescriptionInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case MODIFIES:
token=parseModifiesTag(next());
continue retry;
case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo=extractSingleLineBlock();
String reference=referenceInfo.string;
if (reference.length() == 0) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addReference(reference);
}
token=referenceInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case SUPPRESS:
token=parseSuppressTag(next());
continue retry;
case TEMPLATE:
ExtractionInfo templateInfo=extractSingleLineBlock();
String templateTypeName=templateInfo.string;
if (templateTypeName.length() == 0) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=templateInfo.token;
continue retry;
case VERSION:
ExtractionInfo versionInfo=extractSingleLineBlock();
String version=versionInfo.string;
if (version.length() == 0) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
token=versionInfo.token;
continue retry;
case DEFINE:
case RETURN:
case THIS:
case TYPE:
case TYPEDEF:
lineno=stream.getLineno();
charno=stream.getCharno();
Node typeNode=null;
if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
typeNode=newNode(Token.QMARK);
}
 else {
skipEOLs();
token=next();
typeNode=parseAndRecordTypeNode(token,lineno,charno);
}
if (annotation == Annotation.THIS) {
typeNode=wrapNode(Token.BANG,typeNode);
if (typeNode != null && token != JsDocToken.LC) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE,true);
}
}
type=createJSTypeExpression(typeNode);
if (type == null) {
}
 else {
switch (annotation) {
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
break;
case RETURN:
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
break;
}
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo returnDescriptionInfo=extractMultilineTextualBlock(token);
String returnDescription=returnDescriptionInfo.string;
if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(returnDescription);
}
token=returnDescriptionInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
case TYPE:
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
}
token=eatTokensUntilEOL();
}
continue retry;
}
}
}
break;
case EOC:
if (hasParsedFileOverviewDocInfo()) {
fileOverviewJSDocInfo=retrieveAndResetParsedJSDocInfo();
}
checkExtendedTypes(extendedTypes);
return true;
case EOF:
jsdocBuilder.build(null);
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
checkExtendedTypes(extendedTypes);
return false;
case EOL:
if (state == State.SEARCHING_NEWLINE) {
state=State.SEARCHING_ANNOTATION;
}
token=next();
continue retry;
default :
if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
token=next();
continue retry;
}
 else {
state=State.SEARCHING_NEWLINE;
token=eatTokensUntilEOL();
continue retry;
}
}
token=next();
}
}","/** 
 * Parses a   {@link JSDocInfo} object. This parsing method reads all tokensreturned by the  {@link JsDocTokenStream#getJsDocToken()} method until the{@link JsDocToken#EOC} is returned.
 * @return {@code true} if JSDoc information was correctly parsed,{@code false} otherwise
 */
boolean parse(){
  int lineno;
  int charno;
  JSTypeExpression type;
  state=State.SEARCHING_ANNOTATION;
  skipEOLs();
  JsDocToken token=next();
  List<ExtendedTypeInfo> extendedTypes=Lists.newArrayList();
  if (jsdocBuilder.shouldParseDocumentation()) {
    ExtractionInfo blockInfo=extractBlockComment(token);
    token=blockInfo.token;
    if (!blockInfo.string.isEmpty()) {
      jsdocBuilder.recordBlockDescription(blockInfo.string);
    }
  }
 else {
    if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
      jsdocBuilder.recordBlockDescription(""String_Node_Str"");
    }
  }
  retry:   for (; ; ) {
switch (token) {
case ANNOTATION:
      if (state == State.SEARCHING_ANNOTATION) {
        state=State.SEARCHING_NEWLINE;
        lineno=stream.getLineno();
        charno=stream.getCharno();
        String annotationName=stream.getString();
        Annotation annotation=annotationNames.get(annotationName);
        if (annotation == null) {
          parser.addParserWarning(""String_Node_Str"",annotationName,stream.getLineno(),stream.getCharno());
        }
 else {
          jsdocBuilder.markAnnotation(annotationName,lineno,charno);
switch (annotation) {
case AUTHOR:
            if (jsdocBuilder.shouldParseDocumentation()) {
              ExtractionInfo authorInfo=extractSingleLineBlock();
              String author=authorInfo.string;
              if (author.length() == 0) {
                parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
              }
 else {
                jsdocBuilder.addAuthor(author);
              }
              token=authorInfo.token;
            }
 else {
              token=eatTokensUntilEOL(token);
            }
          continue retry;
case CONSTANT:
        if (!jsdocBuilder.recordConstancy()) {
          parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
        }
      token=eatTokensUntilEOL();
    continue retry;
case CONSTRUCTOR:
  if (!jsdocBuilder.recordConstructor()) {
    if (jsdocBuilder.isInterfaceRecorded()) {
      parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
    }
 else {
      parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
    }
  }
token=eatTokensUntilEOL();
continue retry;
case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
ExtractionInfo reasonInfo=extractMultilineTextualBlock(token);
String reason=reasonInfo.string;
if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}
token=reasonInfo.token;
continue retry;
case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
token=eatTokensUntilEOL();
continue retry;
case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
token=eatTokensUntilEOL();
continue retry;
}
 else {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
jsdocBuilder.recordDescription(description);
token=descriptionInfo.token;
continue retry;
}
case FILE_OVERVIEW:
String fileOverview=""String_Node_Str"";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo=extractMultilineTextualBlock(token,WhitespaceOption.TRIM);
fileOverview=fileOverviewInfo.string;
token=fileOverviewInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
continue retry;
case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo=extractMultilineTextualBlock(token,WhitespaceOption.PRESERVE);
String preserve=preserveInfo.string;
if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}
token=preserveInfo.token;
continue retry;
case ENUM:
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
}
if (type == null) {
type=createJSTypeExpression(newStringNode(""String_Node_Str""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatTokensUntilEOL(token);
continue retry;
case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
boolean matchingRc=false;
if (token == JsDocToken.LC) {
token=next();
matchingRc=true;
}
if (token == JsDocToken.STRING) {
Node typeNode=parseAndRecordTypeNameNode(token,lineno,charno,matchingRc);
lineno=stream.getLineno();
charno=stream.getCharno();
typeNode=wrapNode(Token.BANG,typeNode);
if (typeNode != null && !matchingRc) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE,true);
}
type=createJSTypeExpression(typeNode);
if (annotation == Annotation.EXTENDS) {
extendedTypes.add(new ExtendedTypeInfo(type,stream.getLineno(),stream.getCharno()));
}
 else {
Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
}
token=next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
token=eatTokensUntilEOL(token);
continue retry;
case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case LENDS:
skipEOLs();
matchingRc=false;
if (match(JsDocToken.LC)) {
token=next();
matchingRc=true;
}
if (match(JsDocToken.STRING)) {
token=next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
 else {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case MEANING:
ExtractionInfo meaningInfo=extractMultilineTextualBlock(token);
String meaning=meaningInfo.string;
token=meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
continue retry;
case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NOT_IMPLEMENTED:
token=eatTokensUntilEOL();
continue retry;
case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case THROWS:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordTypeNode(token));
if (type == null) {
token=eatTokensUntilEOL();
continue retry;
}
}
token=current();
jsdocBuilder.recordThrowType(type);
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo descriptionInfo=extractMultilineTextualBlock(token);
String description=descriptionInfo.string;
if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type,description);
}
token=descriptionInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case PARAM:
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
type=null;
if (token == JsDocToken.LC) {
type=createJSTypeExpression(parseAndRecordParamTypeNode(token));
if (type == null) {
token=eatTokensUntilEOL();
continue retry;
}
skipEOLs();
token=next();
lineno=stream.getLineno();
charno=stream.getCharno();
}
String name=null;
boolean isBracketedParam=JsDocToken.LB == token;
if (isBracketedParam) {
token=next();
}
if (JsDocToken.STRING != token) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
 else {
name=stream.getString();
if (isBracketedParam) {
token=next();
if (JsDocToken.EQUALS == token) {
token=next();
if (JsDocToken.STRING == token) {
token=next();
}
}
if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""String_Node_Str"");
}
 else if (type != null) {
type=JSTypeExpression.makeOptionalArg(type);
}
}
if (name.indexOf('.') > -1) {
name=null;
}
 else if (!jsdocBuilder.recordParameter(name,type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
 else {
parser.addTypeWarning(""String_Node_Str"",name,lineno,charno);
}
}
}
if (name == null) {
token=eatTokensUntilEOL(token);
continue retry;
}
jsdocBuilder.markName(name,lineno,charno);
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo paramDescriptionInfo=extractMultilineTextualBlock(token);
String paramDescription=paramDescriptionInfo.string;
if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,paramDescription);
}
token=paramDescriptionInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case MODIFIES:
token=parseModifiesTag(next());
continue retry;
case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=eatTokensUntilEOL();
continue retry;
case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo=extractSingleLineBlock();
String reference=referenceInfo.string;
if (reference.length() == 0) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
jsdocBuilder.addReference(reference);
}
token=referenceInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case SUPPRESS:
token=parseSuppressTag(next());
continue retry;
case TEMPLATE:
ExtractionInfo templateInfo=extractSingleLineBlock();
String templateTypeName=templateInfo.string;
if (templateTypeName.length() == 0) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) {
parser.addTypeWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
token=templateInfo.token;
continue retry;
case VERSION:
ExtractionInfo versionInfo=extractSingleLineBlock();
String version=versionInfo.string;
if (version.length() == 0) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
 else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
}
}
token=versionInfo.token;
continue retry;
case DEFINE:
case RETURN:
case THIS:
case TYPE:
case TYPEDEF:
lineno=stream.getLineno();
charno=stream.getCharno();
Node typeNode=null;
if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) {
typeNode=newNode(Token.QMARK);
}
 else {
skipEOLs();
token=next();
typeNode=parseAndRecordTypeNode(token,lineno,charno);
}
if (annotation == Annotation.THIS) {
typeNode=wrapNode(Token.BANG,typeNode);
if (typeNode != null && token != JsDocToken.LC) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE,true);
}
}
type=createJSTypeExpression(typeNode);
if (type == null) {
}
 else {
switch (annotation) {
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""String_Node_Str"",lineno,charno);
}
break;
case RETURN:
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
break;
}
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo returnDescriptionInfo=extractMultilineTextualBlock(token);
String returnDescription=returnDescriptionInfo.string;
if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(returnDescription);
}
token=returnDescriptionInfo.token;
}
 else {
token=eatTokensUntilEOL(token);
}
continue retry;
case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
case TYPE:
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(""String_Node_Str"",lineno,charno);
}
break;
}
}
token=eatTokensUntilEOL();
continue retry;
}
}
}
break;
case EOC:
if (hasParsedFileOverviewDocInfo()) {
fileOverviewJSDocInfo=retrieveAndResetParsedJSDocInfo();
}
checkExtendedTypes(extendedTypes);
return true;
case EOF:
jsdocBuilder.build(null);
parser.addParserWarning(""String_Node_Str"",stream.getLineno(),stream.getCharno());
checkExtendedTypes(extendedTypes);
return false;
case EOL:
if (state == State.SEARCHING_NEWLINE) {
state=State.SEARCHING_ANNOTATION;
}
token=next();
continue retry;
default :
if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
token=next();
continue retry;
}
 else {
state=State.SEARCHING_NEWLINE;
token=eatTokensUntilEOL();
continue retry;
}
}
token=next();
}
}"
18812,"@Override public void hotSwapScript(Node scriptRoot,Scope globalScope){
  NodeTraversal.traverse(compiler,scriptRoot,this);
}","@Override public void hotSwapScript(Node scriptRoot){
  NodeTraversal.traverse(compiler,scriptRoot,this);
}"
18813,"/** 
 * Returns the root node of the AST, which includes both externs and source.
 */
public Node getRoot(){
  return externAndJsRoot;
}","@Override public Node getRoot(){
  return externAndJsRoot;
}"
18814,"@Override public void hotSwapScript(Node scriptRoot,Scope globalScope){
  makeTypeCheck(compiler).check(scriptRoot,false);
}","@Override public void hotSwapScript(Node scriptRoot){
  regenerateGlobalTypedScope(compiler,compiler.getRoot());
}"
18815,"/** 
 * Process the JS with root node root. This is supposed to be significantly faster compared to corresponding full-compiler passes.
 * @param scriptRoot Root node corresponding to the file that is modified,should be of type  {@code Token.SCRIPT}.
 * @param globalScope The global scope which is not necessarily types.
 */
void hotSwapScript(Node scriptRoot,Scope globalScope);","/** 
 * Process the JS with root node root. This is supposed to be significantly faster compared to corresponding full-compiler passes.
 * @param scriptRoot Root node corresponding to the file that is modified,should be of type  {@code Token.SCRIPT}.
 */
void hotSwapScript(Node scriptRoot);"
18816,"@Override public void hotSwapScript(Node scriptRoot,Scope globalScope){
  this.compiler.process(this);
}","@Override public void hotSwapScript(Node scriptRoot){
  this.compiler.process(this);
}"
18817,"@Override public void hotSwapScript(Node scriptRoot,Scope globalScope){
  Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);
  NodeTraversal t=new NodeTraversal(compiler,this);
  t.traverseWithScope(scriptRoot,globalScope);
}","@Override public void hotSwapScript(Node scriptRoot){
  Preconditions.checkState(scriptRoot.getType() == Token.SCRIPT);
  NodeTraversal t=new NodeTraversal(compiler,this);
  Scope scope=new SyntacticScopeCreator(compiler).createScope(compiler.getRoot(),null);
  t.traverseWithScope(scriptRoot,scope);
}"
18818,"@Override public boolean acceptEcmaScript5(){
  return options.getLanguageIn() == LanguageMode.ECMASCRIPT5;
}","@Override public boolean acceptEcmaScript5(){
switch (options.getLanguageIn()) {
case ECMASCRIPT5:
case ECMASCRIPT5_STRICT:
    return true;
}
return false;
}"
18819,"/** 
 * Creates a RecordType from the nodes representing said record type.
 * @param n The node with type info.
 * @param sourceName The source file name.
 * @param scope A scope for doing type name lookups.
 */
private JSType createRecordTypeFromNodes(Node n,String sourceName,StaticScope<JSType> scope){
  RecordTypeBuilder builder=new RecordTypeBuilder(this);
  for (Node fieldTypeNode=n.getFirstChild(); fieldTypeNode != null; fieldTypeNode=fieldTypeNode.getNext()) {
    Node fieldNameNode=fieldTypeNode;
    boolean hasType=false;
    if (fieldTypeNode.getType() == Token.COLON) {
      fieldNameNode=fieldTypeNode.getFirstChild();
      hasType=true;
    }
    String fieldName=fieldNameNode.getString();
    if (fieldName.startsWith(""String_Node_Str"") || fieldName.startsWith(""String_Node_Str"")) {
      fieldName=fieldName.substring(1,fieldName.length() - 1);
    }
    JSType fieldType=null;
    if (hasType) {
      fieldType=createFromTypeNodesInternal(fieldTypeNode.getLastChild(),sourceName,scope);
    }
 else {
      fieldType=getNativeType(JSTypeNative.UNKNOWN_TYPE);
    }
    builder.addProperty(fieldName,fieldType,fieldNameNode);
  }
  return builder.build();
}","/** 
 * Creates a RecordType from the nodes representing said record type.
 * @param n The node with type info.
 * @param sourceName The source file name.
 * @param scope A scope for doing type name lookups.
 */
private JSType createRecordTypeFromNodes(Node n,String sourceName,StaticScope<JSType> scope){
  RecordTypeBuilder builder=new RecordTypeBuilder(this);
  for (Node fieldTypeNode=n.getFirstChild(); fieldTypeNode != null; fieldTypeNode=fieldTypeNode.getNext()) {
    Node fieldNameNode=fieldTypeNode;
    boolean hasType=false;
    if (fieldTypeNode.getType() == Token.COLON) {
      fieldNameNode=fieldTypeNode.getFirstChild();
      hasType=true;
    }
    String fieldName=fieldNameNode.getString();
    if (fieldName.startsWith(""String_Node_Str"") || fieldName.startsWith(""String_Node_Str"")) {
      fieldName=fieldName.substring(1,fieldName.length() - 1);
    }
    JSType fieldType=null;
    if (hasType) {
      fieldType=createFromTypeNodesInternal(fieldTypeNode.getLastChild(),sourceName,scope);
    }
 else {
      fieldType=getNativeType(JSTypeNative.UNKNOWN_TYPE);
    }
    if (builder.addProperty(fieldName,fieldType,fieldNameNode) == null) {
      reporter.warning(""String_Node_Str"" + fieldName,sourceName,n.getLineno(),""String_Node_Str"",n.getCharno());
    }
  }
  return builder.build();
}"
18820,"/** 
 * Creates a record.
 * @return The record type.
 */
public JSType build(){
  if (isEmpty) {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
  return registry.createRecordType(properties.build());
}","/** 
 * Creates a record.
 * @return The record type.
 */
public JSType build(){
  if (isEmpty) {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
  return registry.createRecordType(Collections.unmodifiableMap(properties));
}"
18821,"/** 
 * Adds a property with the given name and type to the record type.
 * @param name the name of the new property
 * @param type the JSType of the new property
 * @param propertyNode the node that holds this property definition
 * @return The builder itself for chaining purposes.
 */
public RecordTypeBuilder addProperty(String name,JSType type,Node propertyNode){
  isEmpty=false;
  properties.put(name,new RecordProperty(type,propertyNode));
  return this;
}","/** 
 * Adds a property with the given name and type to the record type.
 * @param name the name of the new property
 * @param type the JSType of the new property
 * @param propertyNode the node that holds this property definition
 * @return The builder itself for chaining purposes, or null if there'sa duplicate.
 */
public RecordTypeBuilder addProperty(String name,JSType type,Node propertyNode){
  isEmpty=false;
  if (properties.containsKey(name)) {
    return null;
  }
  properties.put(name,new RecordProperty(type,propertyNode));
  return this;
}"
18822,"/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name. This involves flattening the global name (if it's not just a global variable name already), collapsing object literal keys into global variables, declaring stub global variables for properties added later in a local scope, and eliminating the global name entirely (if possible).
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 */
private void updateObjLitOrFunctionDeclaration(Name n,String alias){
switch (n.declaration.node.getParent().getType()) {
case Token.ASSIGN:
    updateObjLitOrFunctionDeclarationAtAssignNode(n,alias);
  break;
case Token.VAR:
updateObjLitOrFunctionDeclarationAtVarNode(n);
break;
case Token.FUNCTION:
updateFunctionDeclarationAtFunctionNode(n);
break;
}
}","/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name. This involves flattening the global name (if it's not just a global variable name already), collapsing object literal keys into global variables, declaring stub global variables for properties added later in a local scope. It may seem odd that this function also takes care of declaring stubs for direct children. The ultimate goal of this function is to eliminate the global name entirely (when possible), so that ""middlemen"" namespaces disappear, and to do that we need to make sure that all the direct children will be collapsed as well.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 * @param canCollapseChildNames Whether it's possible to collapse children ofthis name. (This is mostly passed for convenience; it's equivalent to n.canCollapseChildNames()).
 */
private void updateObjLitOrFunctionDeclaration(Name n,String alias,boolean canCollapseChildNames){
  if (n.declaration == null) {
    return;
  }
  if (n.declaration.getTwin() != null) {
    return;
  }
switch (n.declaration.node.getParent().getType()) {
case Token.ASSIGN:
    updateObjLitOrFunctionDeclarationAtAssignNode(n,alias,canCollapseChildNames);
  break;
case Token.VAR:
updateObjLitOrFunctionDeclarationAtVarNode(n,canCollapseChildNames);
break;
case Token.FUNCTION:
updateFunctionDeclarationAtFunctionNode(n,canCollapseChildNames);
break;
}
}"
18823,"/** 
 * Adds global variable ""stubs"" for any properties of a global name that are only set in a local scope or read but never set.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name of the object whose properties we areadding stubs for (e.g. ""a$b$c"")
 * @param parent The node to which new global variables should be addedas children
 * @param addAfter The child of after which newvariables should be added (may be null)
 * @return The number of variables added
 */
private int addStubsForUndeclaredProperties(Name n,String alias,Node parent,Node addAfter){
  Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));
  Preconditions.checkNotNull(addAfter);
  int numStubs=0;
  if (n.props != null) {
    for (    Name p : n.props) {
      if (p.needsToBeStubbed()) {
        String propAlias=appendPropForAlias(alias,p.name);
        Node nameNode=Node.newString(Token.NAME,propAlias);
        Node newVar=new Node(Token.VAR,nameNode).copyInformationFromForTree(addAfter);
        parent.addChildAfter(newVar,addAfter);
        addAfter=newVar;
        numStubs++;
        compiler.reportCodeChange();
        if (p.refs.get(0).node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
          nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
        }
      }
    }
  }
  return numStubs;
}","/** 
 * Adds global variable ""stubs"" for any properties of a global name that are only set in a local scope or read but never set.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name of the object whose properties we areadding stubs for (e.g. ""a$b$c"")
 * @param parent The node to which new global variables should be addedas children
 * @param addAfter The child of after which newvariables should be added (may be null)
 * @return The number of variables added
 */
private int addStubsForUndeclaredProperties(Name n,String alias,Node parent,Node addAfter){
  Preconditions.checkState(n.canCollapseUnannotatedChildNames());
  Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));
  Preconditions.checkNotNull(addAfter);
  int numStubs=0;
  if (n.props != null) {
    for (    Name p : n.props) {
      if (p.needsToBeStubbed()) {
        String propAlias=appendPropForAlias(alias,p.name);
        Node nameNode=Node.newString(Token.NAME,propAlias);
        Node newVar=new Node(Token.VAR,nameNode).copyInformationFromForTree(addAfter);
        parent.addChildAfter(newVar,addAfter);
        addAfter=newVar;
        numStubs++;
        compiler.reportCodeChange();
        if (p.refs.get(0).node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
          nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
        }
      }
    }
  }
  return numStubs;
}"
18824,"/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at a VAR node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"")
 */
private void updateObjLitOrFunctionDeclarationAtVarNode(Name n){
  Ref ref=n.declaration;
  String name=ref.node.getString();
  Node rvalue=ref.node.getFirstChild();
  Node varNode=ref.node.getParent();
  Node gramps=varNode.getParent();
  boolean isObjLit=rvalue.getType() == Token.OBJECTLIT;
  int numChanges=0;
  if (isObjLit) {
    numChanges+=declareVarsForObjLitValues(n,name,rvalue,varNode,gramps.getChildBefore(varNode),gramps);
  }
  numChanges+=addStubsForUndeclaredProperties(n,name,gramps,varNode);
  if (isObjLit && n.canEliminate()) {
    varNode.removeChild(ref.node);
    if (!varNode.hasChildren()) {
      gramps.removeChild(varNode);
    }
    numChanges++;
    ref.node=null;
  }
  if (numChanges > 0) {
    compiler.reportCodeChange();
  }
}","/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at a VAR node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"")
 */
private void updateObjLitOrFunctionDeclarationAtVarNode(Name n,boolean canCollapseChildNames){
  if (!canCollapseChildNames) {
    return;
  }
  Ref ref=n.declaration;
  String name=ref.node.getString();
  Node rvalue=ref.node.getFirstChild();
  Node varNode=ref.node.getParent();
  Node gramps=varNode.getParent();
  boolean isObjLit=rvalue.getType() == Token.OBJECTLIT;
  int numChanges=0;
  if (isObjLit) {
    numChanges+=declareVarsForObjLitValues(n,name,rvalue,varNode,gramps.getChildBefore(varNode),gramps);
  }
  numChanges+=addStubsForUndeclaredProperties(n,name,gramps,varNode);
  if (isObjLit && n.canEliminate()) {
    varNode.removeChild(ref.node);
    if (!varNode.hasChildren()) {
      gramps.removeChild(varNode);
    }
    numChanges++;
    ref.node=null;
  }
  if (numChanges > 0) {
    compiler.reportCodeChange();
  }
}"
18825,"/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at a FUNCTION node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"")
 */
private void updateFunctionDeclarationAtFunctionNode(Name n){
  Ref ref=n.declaration;
  String fnName=ref.node.getString();
  addStubsForUndeclaredProperties(n,fnName,ref.node.getAncestor(2),ref.node.getParent());
}","/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at a FUNCTION node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"")
 */
private void updateFunctionDeclarationAtFunctionNode(Name n,boolean canCollapseChildNames){
  if (!canCollapseChildNames) {
    return;
  }
  Ref ref=n.declaration;
  String fnName=ref.node.getString();
  addStubsForUndeclaredProperties(n,fnName,ref.node.getAncestor(2),ref.node.getParent());
}"
18826,"/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at an ASSIGN node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 */
private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n,String alias){
  Ref ref=n.declaration;
  Node rvalue=ref.node.getNext();
  Node varNode=new Node(Token.VAR);
  Node varParent=ref.node.getAncestor(3);
  Node gramps=ref.node.getAncestor(2);
  boolean isObjLit=rvalue.getType() == Token.OBJECTLIT;
  if (isObjLit && n.canEliminate()) {
    varParent.replaceChild(gramps,varNode);
    ref.node=null;
  }
 else {
    if (rvalue.getType() == Token.FUNCTION) {
      checkForHosedThisReferences(rvalue,n.docInfo,n);
    }
    ref.node.getParent().removeChild(rvalue);
    Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,ref.node.getAncestor(2),n.fullName());
    if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    varNode.addChildToBack(nameNode);
    nameNode.addChildToFront(rvalue);
    varParent.replaceChild(gramps,varNode);
    ref.node=nameNode;
  }
  if (isObjLit) {
    declareVarsForObjLitValues(n,alias,rvalue,varNode,varParent.getChildBefore(varNode),varParent);
  }
  addStubsForUndeclaredProperties(n,alias,varParent,varNode);
  if (!varNode.hasChildren()) {
    varParent.removeChild(varNode);
  }
  compiler.reportCodeChange();
}","/** 
 * Updates the first initialization (a.k.a ""declaration"") of a global name that occurs at an ASSIGN node. See comment for  {@link #updateObjLitOrFunctionDeclaration}.
 * @param n An object representing a global name (e.g. ""a"", ""a.b.c"")
 * @param alias The flattened name for {@code n} (e.g. ""a"", ""a$b$c"")
 */
private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n,String alias,boolean canCollapseChildNames){
  Ref ref=n.declaration;
  Node rvalue=ref.node.getNext();
  Node varNode=new Node(Token.VAR);
  Node varParent=ref.node.getAncestor(3);
  Node gramps=ref.node.getAncestor(2);
  boolean isObjLit=rvalue.getType() == Token.OBJECTLIT;
  boolean insertedVarNode=false;
  if (isObjLit && n.canEliminate()) {
    varParent.replaceChild(gramps,varNode);
    ref.node=null;
    insertedVarNode=true;
  }
 else   if (!n.isSimpleName()) {
    if (rvalue.getType() == Token.FUNCTION) {
      checkForHosedThisReferences(rvalue,n.docInfo,n);
    }
    ref.node.getParent().removeChild(rvalue);
    Node nameNode=NodeUtil.newName(compiler.getCodingConvention(),alias,ref.node.getAncestor(2),n.fullName());
    if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME,true);
    }
    varNode.addChildToBack(nameNode);
    nameNode.addChildToFront(rvalue);
    varParent.replaceChild(gramps,varNode);
    ref.node=nameNode;
    insertedVarNode=true;
  }
  if (canCollapseChildNames) {
    if (isObjLit) {
      declareVarsForObjLitValues(n,alias,rvalue,varNode,varParent.getChildBefore(varNode),varParent);
    }
    addStubsForUndeclaredProperties(n,alias,varParent,varNode);
  }
  if (insertedVarNode) {
    if (!varNode.hasChildren()) {
      varParent.removeChild(varNode);
    }
    compiler.reportCodeChange();
  }
}"
18827,"/** 
 * Collapses definitions of the collapsible properties of a global name. Recurses on subnames that also represent JavaScript objects with collapsible properties.
 * @param n A node representing a global name
 * @param alias The flattened name for {@code n}
 */
private void collapseDeclarationOfNameAndDescendants(Name n,String alias){
  boolean canCollapseChildNames=n.canCollapseUnannotatedChildNames();
  if (n.canCollapse() && canCollapseChildNames) {
    updateObjLitOrFunctionDeclaration(n,alias);
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      collapseDeclarationOfNameAndDescendants(p,appendPropForAlias(alias,p.name));
      if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) {
        updateSimpleDeclaration(appendPropForAlias(alias,p.name),p,p.declaration);
      }
    }
  }
}","/** 
 * Collapses definitions of the collapsible properties of a global name. Recurses on subnames that also represent JavaScript objects with collapsible properties.
 * @param n A node representing a global name
 * @param alias The flattened name for {@code n}
 */
private void collapseDeclarationOfNameAndDescendants(Name n,String alias){
  boolean canCollapseChildNames=n.canCollapseUnannotatedChildNames();
  if (n.canCollapse()) {
    updateObjLitOrFunctionDeclaration(n,alias,canCollapseChildNames);
  }
  if (n.props != null) {
    for (    Name p : n.props) {
      collapseDeclarationOfNameAndDescendants(p,appendPropForAlias(alias,p.name));
      if (!p.inExterns && canCollapseChildNames && p.declaration != null && p.declaration.node != null && p.declaration.node.getParent() != null && p.declaration.node.getParent().getType() == Token.ASSIGN) {
        updateSimpleDeclaration(appendPropForAlias(alias,p.name),p,p.declaration);
      }
    }
  }
}"
18828,"/** 
 * Creates a RecordType from the nodes representing said record type.
 * @param n The node with type info.
 * @param sourceName The source file name.
 * @param scope A scope for doing type name lookups.
 */
private JSType createRecordTypeFromNodes(Node n,String sourceName,StaticScope<JSType> scope){
  RecordTypeBuilder builder=new RecordTypeBuilder(this);
  for (Node fieldTypeNode=n.getFirstChild(); fieldTypeNode != null; fieldTypeNode=fieldTypeNode.getNext()) {
    Node fieldNameNode=fieldTypeNode;
    boolean hasType=false;
    if (fieldTypeNode.getType() == Token.COLON) {
      fieldNameNode=fieldTypeNode.getFirstChild();
      hasType=true;
    }
    String fieldName=fieldNameNode.getString();
    if (fieldName.startsWith(""String_Node_Str"") || fieldName.startsWith(""String_Node_Str"")) {
      fieldName=fieldName.substring(1,fieldName.length() - 1);
    }
    JSType fieldType=null;
    if (hasType) {
      fieldType=createFromTypeNodesInternal(fieldTypeNode.getLastChild(),sourceName,scope);
    }
 else {
      fieldType=getNativeType(JSTypeNative.UNKNOWN_TYPE);
    }
    if (builder.addProperty(fieldName,fieldType,fieldNameNode) == null) {
      reporter.warning(""String_Node_Str"" + fieldName,sourceName,n.getLineno(),""String_Node_Str"",n.getCharno());
    }
  }
  return builder.build();
}","/** 
 * Creates a RecordType from the nodes representing said record type.
 * @param n The node with type info.
 * @param sourceName The source file name.
 * @param scope A scope for doing type name lookups.
 */
private JSType createRecordTypeFromNodes(Node n,String sourceName,StaticScope<JSType> scope){
  RecordTypeBuilder builder=new RecordTypeBuilder(this);
  for (Node fieldTypeNode=n.getFirstChild(); fieldTypeNode != null; fieldTypeNode=fieldTypeNode.getNext()) {
    Node fieldNameNode=fieldTypeNode;
    boolean hasType=false;
    if (fieldTypeNode.getType() == Token.COLON) {
      fieldNameNode=fieldTypeNode.getFirstChild();
      hasType=true;
    }
    String fieldName=fieldNameNode.getString();
    if (fieldName.startsWith(""String_Node_Str"") || fieldName.startsWith(""String_Node_Str"")) {
      fieldName=fieldName.substring(1,fieldName.length() - 1);
    }
    JSType fieldType=null;
    if (hasType) {
      fieldType=createFromTypeNodesInternal(fieldTypeNode.getLastChild(),sourceName,scope);
    }
 else {
      fieldType=getNativeType(JSTypeNative.UNKNOWN_TYPE);
    }
    if (builder.addProperty(fieldName,fieldType,fieldNameNode) == null) {
      reporter.warning(""String_Node_Str"" + fieldName,sourceName,n.getLineno(),""String_Node_Str"",fieldNameNode.getCharno());
    }
  }
  return builder.build();
}"
18829,"void addGuard(WarningsGuard guard){
  if (guard instanceof ComposeWarningsGuard) {
    addGuards(Lists.reverse(((ComposeWarningsGuard)guard).guards));
  }
 else {
    int index=Collections.binarySearch(this.guards,guard,guardComparator);
    if (index < 0) {
      index=-index - 1;
    }
    this.guards.add(index,guard);
  }
}","void addGuard(WarningsGuard guard){
  if (guard instanceof ComposeWarningsGuard) {
    addGuards(((ComposeWarningsGuard)guard).guards.descendingSet());
  }
 else {
    numberOfAdds++;
    orderOfAddition.put(guard,numberOfAdds);
    guards.remove(guard);
    guards.add(guard);
  }
}"
18830,"@Override public int compare(WarningsGuard a,WarningsGuard b){
  return a.getPriority() - b.getPriority();
}","@Override public int compare(WarningsGuard a,WarningsGuard b){
  int priorityDiff=a.getPriority() - b.getPriority();
  if (priorityDiff != 0) {
    return priorityDiff;
  }
  return orderOfAddition.get(b).intValue() - orderOfAddition.get(a).intValue();
}"
18831,"List<WarningsGuard> getGuards(){
  return Collections.unmodifiableList(guards);
}","List<WarningsGuard> getGuards(){
  return Collections.unmodifiableList(Lists.newArrayList(guards));
}"
18832,"private CompilerOptions createCompilerOptions(){
  CompilerOptions options=new CompilerOptions();
  this.compilationLevel.setOptionsForCompilationLevel(options);
  if (this.debugOptions) {
    this.compilationLevel.setDebugOptionsForCompilationLevel(options);
  }
  options.prettyPrint=this.prettyPrint;
  options.printInputDelimiter=this.printInputDelimiter;
  this.warningLevel.setOptionsForWarningLevel(options);
  options.setManageClosureDependencies(manageDependencies);
  return options;
}","private CompilerOptions createCompilerOptions(){
  CompilerOptions options=new CompilerOptions();
  this.compilationLevel.setOptionsForCompilationLevel(options);
  if (this.debugOptions) {
    this.compilationLevel.setDebugOptionsForCompilationLevel(options);
  }
  options.prettyPrint=this.prettyPrint;
  options.printInputDelimiter=this.printInputDelimiter;
  options.generateExports=this.generateExports;
  this.warningLevel.setOptionsForWarningLevel(options);
  options.setManageClosureDependencies(manageDependencies);
  return options;
}"
18833,"public CompileTask(){
  this.warningLevel=WarningLevel.DEFAULT;
  this.debugOptions=false;
  this.compilationLevel=CompilationLevel.SIMPLE_OPTIMIZATIONS;
  this.customExternsOnly=false;
  this.manageDependencies=false;
  this.prettyPrint=false;
  this.printInputDelimiter=false;
  this.externFileLists=Lists.newLinkedList();
  this.sourceFileLists=Lists.newLinkedList();
}","public CompileTask(){
  this.warningLevel=WarningLevel.DEFAULT;
  this.debugOptions=false;
  this.compilationLevel=CompilationLevel.SIMPLE_OPTIMIZATIONS;
  this.customExternsOnly=false;
  this.manageDependencies=false;
  this.prettyPrint=false;
  this.printInputDelimiter=false;
  this.generateExports=false;
  this.externFileLists=Lists.newLinkedList();
  this.sourceFileLists=Lists.newLinkedList();
}"
18834,"/** 
 * Visits a   {@link Token#FUNCTION} node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitFunction(NodeTraversal t,Node n){
  JSDocInfo info=n.getJSDocInfo();
  FunctionType functionType=(FunctionType)n.getJSType();
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isInterface() || functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getPrototype().getImplicitPrototype().getConstructor();
    if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isConstructor() && functionType.isInterface() || baseConstructor.isInterface() && functionType.isConstructor())) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,functionPrivateName));
    }
    for (    JSType baseInterface : functionType.getImplementedInterfaces()) {
      boolean badImplementedType=false;
      ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
      if (baseInterfaceObj != null) {
        FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
        if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
          badImplementedType=true;
        }
      }
 else {
        badImplementedType=true;
      }
      if (badImplementedType) {
        report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
      }
    }
    if (functionType.isConstructor()) {
      validator.expectAllInterfacePropertiesImplemented(functionType);
    }
  }
}","/** 
 * Visits a   {@link Token#FUNCTION} node.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 */
private void visitFunction(NodeTraversal t,Node n){
  JSDocInfo info=n.getJSDocInfo();
  FunctionType functionType=(FunctionType)n.getJSType();
  String functionPrivateName=n.getFirstChild().getString();
  if (functionType.isInterface() || functionType.isConstructor()) {
    FunctionType baseConstructor=functionType.getPrototype().getImplicitPrototype().getConstructor();
    if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isConstructor() && functionType.isInterface() || baseConstructor.isInterface() && functionType.isConstructor())) {
      compiler.report(t.makeError(n,CONFLICTING_EXTENDED_TYPE,functionPrivateName));
    }
    for (    JSType baseInterface : functionType.getImplementedInterfaces()) {
      boolean badImplementedType=false;
      ObjectType baseInterfaceObj=ObjectType.cast(baseInterface);
      if (baseInterfaceObj != null) {
        FunctionType interfaceConstructor=baseInterfaceObj.getConstructor();
        if (interfaceConstructor != null && !interfaceConstructor.isInterface()) {
          badImplementedType=true;
        }
      }
 else {
        badImplementedType=true;
      }
      if (badImplementedType) {
        report(t,n,BAD_IMPLEMENTED_TYPE,functionPrivateName);
      }
    }
    if (functionType.isConstructor()) {
      validator.expectAllInterfaceProperties(t,n,functionType);
    }
  }
}"
18835,"/** 
 * Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t,Node n,FunctionType ctorType,String propertyName,JSDocInfo info,JSType propertyType){
  if (hasUnknownOrEmptySupertype(ctorType)) {
    return;
  }
  FunctionType superClass=ctorType.getSuperClassConstructor();
  boolean superClassHasProperty=superClass != null && superClass.getPrototype().hasProperty(propertyName);
  boolean declaredOverride=info != null && info.isOverride();
  boolean foundInterfaceProperty=false;
  if (ctorType.isConstructor()) {
    for (    JSType implementedInterface : ctorType.getImplementedInterfaces()) {
      if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
        continue;
      }
      FunctionType interfaceType=implementedInterface.toObjectType().getConstructor();
      Preconditions.checkNotNull(interfaceType);
      boolean interfaceHasProperty=interfaceType.getPrototype().hasProperty(propertyName);
      foundInterfaceProperty=foundInterfaceProperty || interfaceHasProperty;
      if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
        compiler.report(t.makeError(n,reportMissingOverride,HIDDEN_INTERFACE_PROPERTY,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString()));
      }
      if (interfaceHasProperty) {
        JSType interfacePropType=interfaceType.getPrototype().getPropertyType(propertyName);
        if (!propertyType.canAssignTo(interfacePropType)) {
          compiler.report(t.makeError(n,HIDDEN_INTERFACE_PROPERTY_MISMATCH,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString(),interfacePropType.toString(),propertyType.toString()));
        }
      }
    }
  }
  if (!declaredOverride && !superClassHasProperty) {
    return;
  }
  JSType topInstanceType=superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;
  if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride&& superClassHasProperty) {
    compiler.report(t.makeError(n,reportMissingOverride,HIDDEN_SUPERCLASS_PROPERTY,propertyName,topInstanceType.toString()));
  }
  if (!declaredOverride) {
    return;
  }
  if (superClassHasProperty) {
    JSType superClassPropType=superClass.getPrototype().getPropertyType(propertyName);
    if (!propertyType.canAssignTo(superClassPropType)) {
      compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superClassPropType.toString(),propertyType.toString()));
    }
  }
 else   if (!foundInterfaceProperty) {
    compiler.report(t.makeError(n,UNKNOWN_OVERRIDE,propertyName,ctorType.getInstanceType().toString()));
  }
}","/** 
 * Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t,Node n,FunctionType ctorType,String propertyName,JSDocInfo info,JSType propertyType){
  if (hasUnknownOrEmptySupertype(ctorType)) {
    return;
  }
  FunctionType superClass=ctorType.getSuperClassConstructor();
  boolean superClassHasProperty=superClass != null && superClass.getPrototype().hasProperty(propertyName);
  boolean declaredOverride=info != null && info.isOverride();
  boolean foundInterfaceProperty=false;
  if (ctorType.isConstructor()) {
    for (    JSType implementedInterface : ctorType.getImplementedInterfaces()) {
      if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
        continue;
      }
      FunctionType interfaceType=implementedInterface.toObjectType().getConstructor();
      Preconditions.checkNotNull(interfaceType);
      boolean interfaceHasProperty=interfaceType.getPrototype().hasProperty(propertyName);
      foundInterfaceProperty=foundInterfaceProperty || interfaceHasProperty;
      if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {
        compiler.report(t.makeError(n,reportMissingOverride,HIDDEN_INTERFACE_PROPERTY,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString()));
      }
    }
  }
  if (!declaredOverride && !superClassHasProperty) {
    return;
  }
  JSType topInstanceType=superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;
  if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride&& superClassHasProperty) {
    compiler.report(t.makeError(n,reportMissingOverride,HIDDEN_SUPERCLASS_PROPERTY,propertyName,topInstanceType.toString()));
  }
  if (!declaredOverride) {
    return;
  }
  if (superClassHasProperty) {
    JSType superClassPropType=superClass.getPrototype().getPropertyType(propertyName);
    if (!propertyType.canAssignTo(superClassPropType)) {
      compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superClassPropType.toString(),propertyType.toString()));
    }
  }
 else   if (!foundInterfaceProperty) {
    compiler.report(t.makeError(n,UNKNOWN_OVERRIDE,propertyName,ctorType.getInstanceType().toString()));
  }
}"
18836,"CheckAccessControls(AbstractCompiler compiler){
  this.compiler=compiler;
  this.validator=compiler.getTypeValidator();
}","CheckAccessControls(AbstractCompiler compiler){
  this.compiler=compiler;
  this.validator=compiler.getTypeValidator();
  this.initializedConstantProperties=HashMultimap.create();
}"
18837,"public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.NAME:
    checkNameDeprecation(t,n,parent);
  checkNameVisibility(t,n,parent);
break;
case Token.GETPROP:
checkPropertyDeprecation(t,n,parent);
checkPropertyVisibility(t,n,parent);
break;
case Token.NEW:
checkConstructorDeprecation(t,n,parent);
break;
}
}","public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.NAME:
    checkNameDeprecation(t,n,parent);
  checkNameVisibility(t,n,parent);
break;
case Token.GETPROP:
checkPropertyDeprecation(t,n,parent);
checkPropertyVisibility(t,n,parent);
checkConstantProperty(t,n);
break;
case Token.NEW:
checkConstructorDeprecation(t,n,parent);
break;
}
}"
18838,"@Override protected CompilerOptions getOptions(){
  CompilerOptions options=super.getOptions();
  options.setWarningLevel(DiagnosticGroups.ACCESS_CONTROLS,CheckLevel.ERROR);
  return options;
}","@Override protected CompilerOptions getOptions(){
  CompilerOptions options=super.getOptions();
  options.setWarningLevel(DiagnosticGroups.ACCESS_CONTROLS,CheckLevel.ERROR);
  options.setWarningLevel(DiagnosticGroups.CONSTANT_PROPERTY,CheckLevel.ERROR);
  return options;
}"
18839,"public void testWarningForSuperClassWithDeprecatedSubclassMethod(){
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testWarningForSuperClassWithDeprecatedSubclassMethod(){
  testSame(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
18840,"/** 
 * Try to minimize conditions expressions, as there are additional assumptions that can be made when it is known that the final result is a boolean. The following transformations are done recursively: !(x||y) --> !x&&!y !(x&&y) --> !x||!y !!x     --> x Thus: !(x&&!y) --> !x||!!y --> !x||y Returns the replacement for n, or the original if no change was made
 */
private Node tryMinimizeCondition(Node n){
  Node parent=n.getParent();
switch (n.getType()) {
case Token.NOT:
    Node first=n.getFirstChild();
switch (first.getType()) {
case Token.NOT:
{
      Node newRoot=first.removeFirstChild();
      parent.replaceChild(n,newRoot);
      reportCodeChange();
      return newRoot;
    }
case Token.AND:
case Token.OR:
{
    Node leftParent=first.getFirstChild();
    Node rightParent=first.getLastChild();
    if (leftParent.getType() == Token.NOT && rightParent.getType() == Token.NOT) {
      Node left=leftParent.removeFirstChild();
      Node right=rightParent.removeFirstChild();
      int newOp=(first.getType() == Token.AND) ? Token.OR : Token.AND;
      Node newRoot=new Node(newOp,left,right);
      parent.replaceChild(n,newRoot);
      reportCodeChange();
      return newRoot;
    }
  }
break;
default :
TernaryValue nVal=NodeUtil.getBooleanValue(first);
if (nVal != TernaryValue.UNKNOWN) {
boolean result=nVal.not().toBoolean(true);
int equivalentResult=result ? 1 : 0;
return maybeReplaceChildWithNumber(n,parent,equivalentResult);
}
}
return n;
case Token.OR:
case Token.AND:
{
Node left=n.getFirstChild();
Node right=n.getLastChild();
left=tryMinimizeCondition(left);
right=tryMinimizeCondition(right);
TernaryValue rightVal=NodeUtil.getBooleanValue(right);
if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) {
int type=n.getType();
Node replacement=null;
boolean rval=rightVal.toBoolean(true);
if (type == Token.OR && !rval || type == Token.AND && rval) {
replacement=left;
}
 else if (!mayHaveSideEffects(left)) {
replacement=right;
}
if (replacement != null) {
n.detachChildren();
parent.replaceChild(n,replacement);
reportCodeChange();
return replacement;
}
}
return n;
}
case Token.HOOK:
{
Node condition=n.getFirstChild();
Node trueNode=n.getFirstChild().getNext();
Node falseNode=n.getLastChild();
trueNode=tryMinimizeCondition(trueNode);
falseNode=tryMinimizeCondition(falseNode);
Node replacement=null;
if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE && NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {
condition.detachFromParent();
replacement=condition;
}
 else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.FALSE && NodeUtil.getBooleanValue(falseNode) == TernaryValue.TRUE) {
condition.detachFromParent();
replacement=new Node(Token.NOT,condition);
}
 else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE) {
n.detachChildren();
replacement=new Node(Token.OR,condition,falseNode);
}
 else if (NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {
n.detachChildren();
replacement=new Node(Token.AND,condition,trueNode);
}
if (replacement != null) {
parent.replaceChild(n,replacement);
n=replacement;
reportCodeChange();
}
return n;
}
default :
TernaryValue nVal=NodeUtil.getBooleanValue(n);
if (nVal != TernaryValue.UNKNOWN) {
boolean result=nVal.toBoolean(true);
int equivalentResult=result ? 1 : 0;
return maybeReplaceChildWithNumber(n,parent,equivalentResult);
}
return n;
}
}","/** 
 * Try to minimize conditions expressions, as there are additional assumptions that can be made when it is known that the final result is a boolean. The following transformations are done recursively: !(x||y) --> !x&&!y !(x&&y) --> !x||!y !!x     --> x Thus: !(x&&!y) --> !x||!!y --> !x||y Returns the replacement for n, or the original if no change was made
 */
private Node tryMinimizeCondition(Node n){
  Node parent=n.getParent();
switch (n.getType()) {
case Token.NOT:
    Node first=n.getFirstChild();
switch (first.getType()) {
case Token.NOT:
{
      Node newRoot=first.removeFirstChild();
      parent.replaceChild(n,newRoot);
      reportCodeChange();
      return newRoot;
    }
case Token.AND:
case Token.OR:
{
    Node leftParent=first.getFirstChild();
    Node rightParent=first.getLastChild();
    Node left, right;
    if (leftParent.getType() != Token.NOT && rightParent.getType() != Token.NOT) {
      int op_precedence=NodeUtil.precedence(first.getType());
      if ((isLowerPrecedence(leftParent,NOT_PRECEDENCE) && isHigherPrecedence(leftParent,op_precedence)) || (isLowerPrecedence(rightParent,NOT_PRECEDENCE) && isHigherPrecedence(rightParent,op_precedence))) {
        return n;
      }
    }
    if (leftParent.getType() == Token.NOT) {
      left=leftParent.removeFirstChild();
    }
 else {
      leftParent.detachFromParent();
      left=new Node(Token.NOT,leftParent).copyInformationFrom(leftParent);
    }
    if (rightParent.getType() == Token.NOT) {
      right=rightParent.removeFirstChild();
    }
 else {
      rightParent.detachFromParent();
      right=new Node(Token.NOT,rightParent).copyInformationFrom(rightParent);
    }
    int newOp=(first.getType() == Token.AND) ? Token.OR : Token.AND;
    Node newRoot=new Node(newOp,left,right);
    parent.replaceChild(n,newRoot);
    reportCodeChange();
    return newRoot;
  }
default :
TernaryValue nVal=NodeUtil.getBooleanValue(first);
if (nVal != TernaryValue.UNKNOWN) {
boolean result=nVal.not().toBoolean(true);
int equivalentResult=result ? 1 : 0;
return maybeReplaceChildWithNumber(n,parent,equivalentResult);
}
}
return n;
case Token.OR:
case Token.AND:
{
Node left=n.getFirstChild();
Node right=n.getLastChild();
left=tryMinimizeCondition(left);
right=tryMinimizeCondition(right);
TernaryValue rightVal=NodeUtil.getBooleanValue(right);
if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) {
int type=n.getType();
Node replacement=null;
boolean rval=rightVal.toBoolean(true);
if (type == Token.OR && !rval || type == Token.AND && rval) {
replacement=left;
}
 else if (!mayHaveSideEffects(left)) {
replacement=right;
}
if (replacement != null) {
n.detachChildren();
parent.replaceChild(n,replacement);
reportCodeChange();
return replacement;
}
}
return n;
}
case Token.HOOK:
{
Node condition=n.getFirstChild();
Node trueNode=n.getFirstChild().getNext();
Node falseNode=n.getLastChild();
trueNode=tryMinimizeCondition(trueNode);
falseNode=tryMinimizeCondition(falseNode);
Node replacement=null;
if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE && NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {
condition.detachFromParent();
replacement=condition;
}
 else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.FALSE && NodeUtil.getBooleanValue(falseNode) == TernaryValue.TRUE) {
condition.detachFromParent();
replacement=new Node(Token.NOT,condition);
}
 else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE) {
n.detachChildren();
replacement=new Node(Token.OR,condition,falseNode);
}
 else if (NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {
n.detachChildren();
replacement=new Node(Token.AND,condition,trueNode);
}
if (replacement != null) {
parent.replaceChild(n,replacement);
n=replacement;
reportCodeChange();
}
return n;
}
default :
TernaryValue nVal=NodeUtil.getBooleanValue(n);
if (nVal != TernaryValue.UNKNOWN) {
boolean result=nVal.toBoolean(true);
int equivalentResult=result ? 1 : 0;
return maybeReplaceChildWithNumber(n,parent,equivalentResult);
}
return n;
}
}"
18841,"public void testMinimizeWhileCondition(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
}","public void testMinimizeWhileCondition(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
}"
18842,"private void maybeCollectMember(NodeTraversal t,Node member,Node nodeWithJsDocInfo,@Nullable Node value){
  JSDocInfo info=nodeWithJsDocInfo.getJSDocInfo();
  if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) {
    return;
  }
  member.getFirstChild().setJSType(thisType);
  JSType jsType=getDeclaredPropType(t,info,member,value);
  Node name=member.getLastChild();
  if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) {
    thisType.defineDeclaredProperty(name.getString(),jsType,false,member);
  }
}","private void maybeCollectMember(NodeTraversal t,Node member,Node nodeWithJsDocInfo,@Nullable Node value){
  JSDocInfo info=nodeWithJsDocInfo.getJSDocInfo();
  if (info == null || member.getType() != Token.GETPROP || member.getFirstChild().getType() != Token.THIS) {
    return;
  }
  member.getFirstChild().setJSType(thisType);
  JSType jsType=getDeclaredType(t.getSourceName(),info,member,value);
  Node name=member.getLastChild();
  if (jsType != null && (name.getType() == Token.NAME || name.getType() == Token.STRING)) {
    thisType.defineDeclaredProperty(name.getString(),jsType,false,member);
  }
}"
18843,"private JSType getDeclaredTypeInAnnotation(String sourceName,Node node,JSDocInfo info){
  JSType jsType=null;
  Node objNode=node.getType() == Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node,node.getParent()) ? node.getParent() : null;
  if (info != null) {
    if (info.hasType()) {
      jsType=info.getType().evaluate(scope,typeRegistry);
    }
 else     if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
      String fnName=node.getQualifiedName();
      jsType=createFunctionTypeFromNodes(null,fnName,info,node);
    }
  }
  return jsType;
}","/** 
 * Returns the type specified in a JSDoc annotation near a GETPROP or NAME. Extracts type information from either the   {@code @type} tag or fromthe  {@code @return} and {@code @param} tags.
 */
private JSType getDeclaredTypeInAnnotation(String sourceName,Node node,JSDocInfo info){
  JSType jsType=null;
  Node objNode=node.getType() == Token.GETPROP ? node.getFirstChild() : NodeUtil.isObjectLitKey(node,node.getParent()) ? node.getParent() : null;
  if (info != null) {
    if (info.hasType()) {
      jsType=info.getType().evaluate(scope,typeRegistry);
    }
 else     if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
      String fnName=node.getQualifiedName();
      jsType=createFunctionTypeFromNodes(null,fnName,info,node);
    }
  }
  return jsType;
}"
18844,"/** 
 * Defines a variable based on the   {@link Token#NAME} node passed.
 * @param name The {@link Token#NAME} node.
 * @param var The parent of the {@code name} node, which must be a{@link Token#VAR} node.
 * @param parent {@code var}'s parent.
 * @param info the {@link JSDocInfo} information relating to this{@code name} node.
 */
private void defineName(Node name,Node var,Node parent,JSDocInfo info){
  Node value=name.getFirstChild();
  JSType type=null;
  if (value != null && value.getType() == Token.FUNCTION && shouldUseFunctionLiteralType((FunctionType)value.getJSType(),info,name)) {
    type=value.getJSType();
  }
  if (type == null) {
    if (info == null) {
      CompilerInput input=compiler.getInput(sourceName);
      Preconditions.checkNotNull(input,sourceName);
      type=input.isExtern() ? getNativeType(UNKNOWN_TYPE) : null;
    }
 else     if (info.hasEnumParameterType()) {
      if (value != null && value.getType() == Token.OBJECTLIT) {
        type=value.getJSType();
      }
 else {
        type=createEnumTypeFromNodes(value,name.getString(),info,name);
      }
    }
 else     if (info.isConstructor()) {
      type=createFunctionTypeFromNodes(value,name.getString(),info,name);
    }
 else {
      type=getDeclaredTypeInAnnotation(sourceName,name,info);
    }
  }
  defineSlot(name,var,type);
}","/** 
 * Defines a variable based on the   {@link Token#NAME} node passed.
 * @param name The {@link Token#NAME} node.
 * @param var The parent of the {@code name} node, which must be a{@link Token#VAR} node.
 * @param parent {@code var}'s parent.
 * @param info the {@link JSDocInfo} information relating to this{@code name} node.
 */
private void defineName(Node name,Node var,Node parent,JSDocInfo info){
  Node value=name.getFirstChild();
  JSType type=getDeclaredType(sourceName,info,name,value);
  if (type == null) {
    CompilerInput input=compiler.getInput(sourceName);
    Preconditions.checkNotNull(input,sourceName);
    type=input.isExtern() ? getNativeType(UNKNOWN_TYPE) : null;
  }
  defineSlot(name,var,type);
}"
18845,"/** 
 * Process an object literal and all the types on it.
 * @param objLit The OBJECTLIT node.
 * @param objLitType The type of the OBJECTLIT node. This might be a namedtype, because of the lends annotation.
 */
void processObjectLitProperties(NodeTraversal t,Node objLit,ObjectType objLitType){
  for (Node keyNode=objLit.getFirstChild(); keyNode != null; keyNode=keyNode.getNext()) {
    Node value=keyNode.getFirstChild();
    String memberName=NodeUtil.getObjectLitKeyName(keyNode);
    JSDocInfo info=keyNode.getJSDocInfo();
    JSType valueType=getDeclaredPropType(t,info,keyNode,value);
    JSType keyType=NodeUtil.getObjectLitKeyTypeFromValueType(keyNode,valueType);
    if (keyType != null) {
      String qualifiedName=getBestLValueName(keyNode);
      if (qualifiedName != null) {
        defineSlot(keyNode,objLit,qualifiedName,keyType,false);
      }
 else {
        setDeferredType(keyNode,keyType);
      }
      if (objLitType != null) {
        boolean isExtern=t.getInput() != null && t.getInput().isExtern();
        objLitType.defineDeclaredProperty(memberName,keyType,isExtern,keyNode);
      }
    }
  }
}","/** 
 * Process an object literal and all the types on it.
 * @param objLit The OBJECTLIT node.
 * @param objLitType The type of the OBJECTLIT node. This might be a namedtype, because of the lends annotation.
 */
void processObjectLitProperties(NodeTraversal t,Node objLit,ObjectType objLitType){
  for (Node keyNode=objLit.getFirstChild(); keyNode != null; keyNode=keyNode.getNext()) {
    Node value=keyNode.getFirstChild();
    String memberName=NodeUtil.getObjectLitKeyName(keyNode);
    JSDocInfo info=keyNode.getJSDocInfo();
    JSType valueType=getDeclaredType(t.getSourceName(),info,keyNode,value);
    JSType keyType=NodeUtil.getObjectLitKeyTypeFromValueType(keyNode,valueType);
    if (keyType != null) {
      String qualifiedName=getBestLValueName(keyNode);
      if (qualifiedName != null) {
        defineSlot(keyNode,objLit,qualifiedName,keyType,false);
      }
 else {
        setDeferredType(keyNode,keyType);
      }
      if (objLitType != null) {
        boolean isExtern=t.getInput() != null && t.getInput().isExtern();
        objLitType.defineDeclaredProperty(memberName,keyType,isExtern,keyNode);
      }
    }
  }
}"
18846,"public void testConstructorAlias10() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testConstructorAlias10() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}"
18847,"public void testConstructorAlias9() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testConstructorAlias9() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}"
18848,"public void testConstructorAlias8() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testConstructorAlias8() throws Exception {
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}"
18849,"public void testStubFunctionDeclaration8() throws Exception {
  testFunctionType(""String_Node_Str"",""String_Node_Str"",createNullableType(U2U_CONSTRUCTOR_TYPE).restrictByNotNullOrUndefined().toString());
}","public void testStubFunctionDeclaration8() throws Exception {
  testFunctionType(""String_Node_Str"",""String_Node_Str"",createOptionalType(createNullableType(U2U_CONSTRUCTOR_TYPE)).toString());
}"
18850,"public void testStubFunctionDeclaration8() throws Exception {
  testFunctionType(""String_Node_Str"",""String_Node_Str"",createNullableType(U2U_CONSTRUCTOR_TYPE).restrictByNotNullOrUndefined().toString());
}","public void testStubFunctionDeclaration8() throws Exception {
  testFunctionType(""String_Node_Str"",""String_Node_Str"",createNullableType(U2U_CONSTRUCTOR_TYPE).toString());
}"
18851,"/** 
 * Gets the value of a node as a Number, or null if it cannot be converted. When it returns a non-null Double, this method effectively emulates the <code>Number()</code> JavaScript cast function.
 */
static Double getNumberValue(Node n){
switch (n.getType()) {
case Token.TRUE:
    return 1.0;
case Token.FALSE:
case Token.NULL:
  return 0.0;
case Token.NUMBER:
return n.getDouble();
case Token.VOID:
if (mayHaveSideEffects(n.getFirstChild())) {
return null;
}
 else {
return Double.NaN;
}
case Token.NAME:
String name=n.getString();
if (name.equals(""String_Node_Str"")) {
return Double.NaN;
}
if (name.equals(""String_Node_Str"")) {
return Double.NaN;
}
if (name.equals(""String_Node_Str"")) {
return Double.POSITIVE_INFINITY;
}
return null;
case Token.NEG:
if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME && n.getFirstChild().getString().equals(""String_Node_Str"")) {
return Double.NEGATIVE_INFINITY;
}
return null;
case Token.NOT:
TernaryValue child=getBooleanValue(n.getFirstChild());
if (child != TernaryValue.UNKNOWN) {
return child.toBoolean(true) ? 0.0 : 1.0;
}
break;
case Token.STRING:
String s=trimJsWhiteSpace(n.getString());
if (s.length() == 0) {
return 0.0;
}
if (s.length() > 2 && s.charAt(0) == '0' && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
try {
return Double.valueOf(Integer.parseInt(s.substring(2),16));
}
 catch (NumberFormatException e) {
return Double.NaN;
}
}
if (s.length() > 3 && (s.charAt(0) == '-' || s.charAt(0) == '+') && s.charAt(1) == '0' && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
return null;
}
if (s.equals(""String_Node_Str"") || s.equals(""String_Node_Str"") || s.equals(""String_Node_Str"")) {
return null;
}
try {
return Double.parseDouble(s);
}
 catch (NumberFormatException e) {
return Double.NaN;
}
}
return null;
}","/** 
 * Gets the value of a node as a Number, or null if it cannot be converted. When it returns a non-null Double, this method effectively emulates the <code>Number()</code> JavaScript cast function.
 */
static Double getNumberValue(Node n){
switch (n.getType()) {
case Token.TRUE:
    return 1.0;
case Token.FALSE:
case Token.NULL:
  return 0.0;
case Token.NUMBER:
return n.getDouble();
case Token.VOID:
if (mayHaveSideEffects(n.getFirstChild())) {
return null;
}
 else {
return Double.NaN;
}
case Token.NAME:
String name=n.getString();
if (name.equals(""String_Node_Str"")) {
return Double.NaN;
}
if (name.equals(""String_Node_Str"")) {
return Double.NaN;
}
if (name.equals(""String_Node_Str"")) {
return Double.POSITIVE_INFINITY;
}
return null;
case Token.NEG:
if (n.getChildCount() == 1 && n.getFirstChild().getType() == Token.NAME && n.getFirstChild().getString().equals(""String_Node_Str"")) {
return Double.NEGATIVE_INFINITY;
}
return null;
case Token.NOT:
TernaryValue child=getBooleanValue(n.getFirstChild());
if (child != TernaryValue.UNKNOWN) {
return child.toBoolean(true) ? 0.0 : 1.0;
}
break;
case Token.STRING:
return getStringNumberValue(n.getString());
case Token.ARRAYLIT:
case Token.OBJECTLIT:
String value=getStringValue(n);
return value != null ? getStringNumberValue(value) : null;
}
return null;
}"
18852,"/** 
 * Gets the value of a node as a String, or null if it cannot be converted. When it returns a non-null String, this method effectively emulates the <code>String()</code> JavaScript cast function.
 */
static String getStringValue(Node n){
switch (n.getType()) {
case Token.STRING:
    return n.getString();
case Token.NAME:
  String name=n.getString();
if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)) {
  return name;
}
break;
case Token.NUMBER:
double value=n.getDouble();
long longValue=(long)value;
if (longValue == value) {
return Long.toString(longValue);
}
 else {
return Double.toString(n.getDouble());
}
case Token.FALSE:
case Token.TRUE:
case Token.NULL:
return Node.tokenToName(n.getType());
case Token.VOID:
return ""String_Node_Str"";
case Token.NOT:
TernaryValue child=getBooleanValue(n.getFirstChild());
if (child != TernaryValue.UNKNOWN) {
return child.toBoolean(true) ? ""String_Node_Str"" : ""String_Node_Str"";
}
break;
}
return null;
}","/** 
 * Gets the value of a node as a String, or null if it cannot be converted. When it returns a non-null String, this method effectively emulates the <code>String()</code> JavaScript cast function.
 */
static String getStringValue(Node n){
switch (n.getType()) {
case Token.STRING:
    return n.getString();
case Token.NAME:
  String name=n.getString();
if (""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name) || ""String_Node_Str"".equals(name)) {
  return name;
}
break;
case Token.NUMBER:
double value=n.getDouble();
long longValue=(long)value;
if (longValue == value) {
return Long.toString(longValue);
}
 else {
return Double.toString(n.getDouble());
}
case Token.FALSE:
case Token.TRUE:
case Token.NULL:
return Node.tokenToName(n.getType());
case Token.VOID:
return ""String_Node_Str"";
case Token.NOT:
TernaryValue child=getBooleanValue(n.getFirstChild());
if (child != TernaryValue.UNKNOWN) {
return child.toBoolean(true) ? ""String_Node_Str"" : ""String_Node_Str"";
}
break;
case Token.ARRAYLIT:
return arrayToString(n);
case Token.OBJECTLIT:
return ""String_Node_Str"";
}
return null;
}"
18853,"/** 
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
private Node tryFoldArrayJoin(Node n){
  Node callTarget=n.getFirstChild();
  if (callTarget == null) {
    return n;
  }
  Node right=callTarget.getNext();
  if (right == null) {
    return n;
  }
  if (!NodeUtil.isGetProp(callTarget) || !NodeUtil.isImmutableValue(right)) {
    return n;
  }
  Node arrayNode=callTarget.getFirstChild();
  Node functionName=arrayNode.getNext();
  if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""String_Node_Str"")) {
    return n;
  }
  String joinString=NodeUtil.getStringValue(right);
  List<Node> arrayFoldedChildren=Lists.newLinkedList();
  StringBuilder sb=null;
  int foldedSize=0;
  Node prev=null;
  Node elem=arrayNode.getFirstChild();
  while (elem != null) {
    if (NodeUtil.isImmutableValue(elem)) {
      if (sb == null) {
        sb=new StringBuilder();
      }
 else {
        sb.append(joinString);
      }
      sb.append(NodeUtil.getStringValue(elem));
    }
 else {
      if (sb != null) {
        Preconditions.checkNotNull(prev);
        foldedSize+=sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
        sb=null;
      }
      foldedSize+=InlineCostEstimator.getCost(elem);
      arrayFoldedChildren.add(elem);
    }
    prev=elem;
    elem=elem.getNext();
  }
  if (sb != null) {
    Preconditions.checkNotNull(prev);
    foldedSize+=sb.length() + 2;
    arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
  }
  foldedSize+=arrayFoldedChildren.size() - 1;
  int originalSize=InlineCostEstimator.getCost(n);
switch (arrayFoldedChildren.size()) {
case 0:
    Node emptyStringNode=Node.newString(""String_Node_Str"");
  n.getParent().replaceChild(n,emptyStringNode);
reportCodeChange();
return emptyStringNode;
case 1:
Node foldedStringNode=arrayFoldedChildren.remove(0);
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
if (foldedStringNode.getType() != Token.STRING) {
Node replacement=new Node(Token.ADD,Node.newString(""String_Node_Str"").copyInformationFrom(right),foldedStringNode);
foldedStringNode=replacement;
}
n.getParent().replaceChild(n,foldedStringNode);
reportCodeChange();
return foldedStringNode;
default :
if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
return n;
}
int kJoinOverhead=""String_Node_Str"".length();
foldedSize+=kJoinOverhead;
foldedSize+=InlineCostEstimator.getCost(right);
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
for (Node node : arrayFoldedChildren) {
arrayNode.addChildToBack(node);
}
reportCodeChange();
break;
}
return n;
}","/** 
 * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';
 */
private Node tryFoldArrayJoin(Node n){
  Node callTarget=n.getFirstChild();
  if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
    return n;
  }
  Node right=callTarget.getNext();
  if (right != null && !NodeUtil.isImmutableValue(right)) {
    return n;
  }
  Node arrayNode=callTarget.getFirstChild();
  Node functionName=arrayNode.getNext();
  if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(""String_Node_Str"")) {
    return n;
  }
  String joinString=(right == null) ? ""String_Node_Str"" : NodeUtil.getStringValue(right);
  List<Node> arrayFoldedChildren=Lists.newLinkedList();
  StringBuilder sb=null;
  int foldedSize=0;
  Node prev=null;
  Node elem=arrayNode.getFirstChild();
  while (elem != null) {
    if (NodeUtil.isImmutableValue(elem)) {
      if (sb == null) {
        sb=new StringBuilder();
      }
 else {
        sb.append(joinString);
      }
      sb.append(NodeUtil.getArrayElementStringValue(elem));
    }
 else {
      if (sb != null) {
        Preconditions.checkNotNull(prev);
        foldedSize+=sb.length() + 2;
        arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
        sb=null;
      }
      foldedSize+=InlineCostEstimator.getCost(elem);
      arrayFoldedChildren.add(elem);
    }
    prev=elem;
    elem=elem.getNext();
  }
  if (sb != null) {
    Preconditions.checkNotNull(prev);
    foldedSize+=sb.length() + 2;
    arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(prev));
  }
  foldedSize+=arrayFoldedChildren.size() - 1;
  int originalSize=InlineCostEstimator.getCost(n);
switch (arrayFoldedChildren.size()) {
case 0:
    Node emptyStringNode=Node.newString(""String_Node_Str"");
  n.getParent().replaceChild(n,emptyStringNode);
reportCodeChange();
return emptyStringNode;
case 1:
Node foldedStringNode=arrayFoldedChildren.remove(0);
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
if (foldedStringNode.getType() != Token.STRING) {
Node replacement=new Node(Token.ADD,Node.newString(""String_Node_Str"").copyInformationFrom(right),foldedStringNode);
foldedStringNode=replacement;
}
n.getParent().replaceChild(n,foldedStringNode);
reportCodeChange();
return foldedStringNode;
default :
if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
return n;
}
int kJoinOverhead=""String_Node_Str"".length();
foldedSize+=kJoinOverhead;
foldedSize+=InlineCostEstimator.getCost(right);
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
for (Node node : arrayFoldedChildren) {
arrayNode.addChildToBack(node);
}
reportCodeChange();
break;
}
return n;
}"
18854,"public void testGetStringValue(){
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(null,NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(null,NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(null,NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(null,NodeUtil.getStringValue(getNode(""String_Node_Str"")));
}","public void testGetStringValue(){
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(null,NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(""String_Node_Str"",NodeUtil.getStringValue(getNode(""String_Node_Str"")));
  assertEquals(null,NodeUtil.getStringValue(getNode(""String_Node_Str"")));
}"
18855,"public void testStringJoinAdd(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
}","public void testStringJoinAdd(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
}"
18856,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.getType() != Token.NAME) {
    return;
  }
  String name=n.getString();
  if (name.length() == 0) {
    return;
  }
  Scope.Var var=t.getScope().getVar(name);
  boolean local=(var != null) && var.isLocal();
  if (!local && localRenamingOnly) {
    reservedNames.add(name);
    return;
  }
  if (preserveFunctionExpressionNames && var != null && NodeUtil.isFunctionExpression(var.getParentNode())) {
    reservedNames.add(name);
    return;
  }
  if (!okToRenameVar(name,local)) {
    if (local) {
      String newName=MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
      if (!newName.equals(name)) {
        n.setString(newName);
      }
    }
    return;
  }
  if (isExternsPass_) {
    if (!local) {
      externNames.add(name);
    }
    return;
  }
  if (pseudoNameMap != null) {
    recordPseudoName(n);
  }
  if (local) {
    String tempName=LOCAL_VAR_PREFIX + var.getLocalVarIndex();
    incCount(tempName,null);
    localNameNodes.add(n);
    n.setString(tempName);
  }
 else   if (var != null) {
    incCount(name,var.input);
    globalNameNodes.add(n);
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.getType() != Token.NAME) {
    return;
  }
  String name=n.getString();
  if (name.length() == 0) {
    return;
  }
  Scope.Var var=t.getScope().getVar(name);
  boolean local=(var != null) && var.isLocal() && (!var.scope.getParent().isGlobal() || !var.isBleedingFunction());
  if (!local && localRenamingOnly) {
    reservedNames.add(name);
    return;
  }
  if (preserveFunctionExpressionNames && var != null && NodeUtil.isFunctionExpression(var.getParentNode())) {
    reservedNames.add(name);
    return;
  }
  if (!okToRenameVar(name,local)) {
    if (local) {
      String newName=MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);
      if (!newName.equals(name)) {
        n.setString(newName);
      }
    }
    return;
  }
  if (isExternsPass_) {
    if (!local) {
      externNames.add(name);
    }
    return;
  }
  if (pseudoNameMap != null) {
    recordPseudoName(n);
  }
  if (local) {
    String tempName=LOCAL_VAR_PREFIX + var.getLocalVarIndex();
    incCount(tempName,null);
    localNameNodes.add(n);
    n.setString(tempName);
  }
 else   if (var != null) {
    incCount(name,var.input);
    globalNameNodes.add(n);
  }
}"
18857,"private void initConfigFromFlags(String[] args,PrintStream err){
  Pattern argPattern=Pattern.compile(""String_Node_Str"");
  Pattern quotesPattern=Pattern.compile(""String_Node_Str"");
  List<String> processedArgs=Lists.newArrayList();
  for (  String arg : args) {
    Matcher matcher=argPattern.matcher(arg);
    if (matcher.matches()) {
      processedArgs.add(matcher.group(1));
      String value=matcher.group(2);
      Matcher quotesMatcher=quotesPattern.matcher(value);
      if (quotesMatcher.matches()) {
        processedArgs.add(quotesMatcher.group(1));
      }
 else {
        processedArgs.add(value);
      }
    }
 else {
      processedArgs.add(arg);
    }
  }
  CmdLineParser parser=new CmdLineParser(flags);
  isConfigValid=true;
  try {
    parser.parseArgument(processedArgs.toArray(new String[]{}));
  }
 catch (  CmdLineException e) {
    err.println(e.getMessage());
    isConfigValid=false;
  }
  if (flags.version) {
    ResourceBundle config=ResourceBundle.getBundle(configResource);
    err.println(""String_Node_Str"" + ""String_Node_Str"" + config.getString(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ config.getString(""String_Node_Str""));
    err.flush();
  }
  if (!isConfigValid || flags.display_help) {
    isConfigValid=false;
    parser.printUsage(err);
  }
 else {
    getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setClosureEntryPoints(flags.closure_entry_point).setOutputManifest(flags.output_manifest);
  }
}","private void initConfigFromFlags(String[] args,PrintStream err){
  List<String> processedArgs=processArgs(args);
  CmdLineParser parser=new CmdLineParser(flags);
  isConfigValid=true;
  try {
    parser.parseArgument(processedArgs.toArray(new String[]{}));
    if (!flags.flag_file.equals(""String_Node_Str"")) {
      processFlagFile(err);
    }
  }
 catch (  CmdLineException e) {
    err.println(e.getMessage());
    isConfigValid=false;
  }
catch (  IOException ioErr) {
    err.println(""String_Node_Str"" + flags.flag_file + ""String_Node_Str"");
    isConfigValid=false;
  }
  if (flags.version) {
    ResourceBundle config=ResourceBundle.getBundle(configResource);
    err.println(""String_Node_Str"" + ""String_Node_Str"" + config.getString(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ config.getString(""String_Node_Str""));
    err.flush();
  }
  if (!isConfigValid || flags.display_help) {
    isConfigValid=false;
    parser.printUsage(err);
  }
 else {
    getCommandLineConfig().setPrintTree(flags.print_tree).setComputePhaseOrdering(flags.compute_phase_ordering).setPrintAst(flags.print_ast).setPrintPassGraph(flags.print_pass_graph).setJscompDevMode(flags.jscomp_dev_mode).setLoggingLevel(flags.logging_level).setExterns(flags.externs).setJs(flags.js).setJsOutputFile(flags.js_output_file).setModule(flags.module).setVariableMapInputFile(flags.variable_map_input_file).setPropertyMapInputFile(flags.property_map_input_file).setVariableMapOutputFile(flags.variable_map_output_file).setCreateNameMapFiles(flags.create_name_map_files).setPropertyMapOutputFile(flags.property_map_output_file).setCodingConvention(flags.third_party ? new DefaultCodingConvention() : new ClosureCodingConvention()).setSummaryDetailLevel(flags.summary_detail_level).setOutputWrapper(flags.output_wrapper).setOutputWrapperMarker(flags.output_wrapper_marker).setModuleWrapper(flags.module_wrapper).setModuleOutputPathPrefix(flags.module_output_path_prefix).setCreateSourceMap(flags.create_source_map).setJscompError(flags.jscomp_error).setJscompWarning(flags.jscomp_warning).setJscompOff(flags.jscomp_off).setDefine(flags.define).setCharset(flags.charset).setManageClosureDependencies(flags.manage_closure_dependencies).setClosureEntryPoints(flags.closure_entry_point).setOutputManifest(flags.output_manifest);
  }
}"
18858,"TernaryValue testForEqualityHelper(JSType aType,JSType bType){
  if (bType.isAllType() || bType.isEmptyType() || bType.isUnknownType()) {
    return UNKNOWN;
  }
  if (aType.isFunctionType() || bType.isFunctionType()) {
    JSType otherType=aType.isFunctionType() ? bType : aType;
    if (otherType.isSubtype(getNativeType(JSTypeNative.OBJECT_TYPE))) {
      return TernaryValue.UNKNOWN;
    }
 else {
      return TernaryValue.FALSE;
    }
  }
  if (bType.isEnumElementType() || bType.isUnionType()) {
    return bType.testForEquality(aType);
  }
  return null;
}","TernaryValue testForEqualityHelper(JSType aType,JSType bType){
  if (bType.isAllType() || bType.isEmptyType() || bType.isUnknownType()|| aType.isAllType()|| aType.isEmptyType()|| aType.isUnknownType()) {
    return UNKNOWN;
  }
  if (aType.isFunctionType() || bType.isFunctionType()) {
    JSType otherType=aType.isFunctionType() ? bType : aType;
    if (!otherType.getGreatestSubtype(getNativeType(JSTypeNative.OBJECT_TYPE)).isEmptyType()) {
      return TernaryValue.UNKNOWN;
    }
 else {
      return TernaryValue.FALSE;
    }
  }
  if (bType.isEnumElementType() || bType.isUnionType()) {
    return bType.testForEquality(aType);
  }
  return null;
}"
18859,"/** 
 * Tests the   {@link JSType#testForEquality(JSType)} method.
 */
public void testTestForEquality(){
  compare(TRUE,NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  compare(UNKNOWN,ALL_TYPE,ALL_TYPE);
  compare(TRUE,NO_TYPE,NO_TYPE);
  compare(UNKNOWN,NO_OBJECT_TYPE,NUMBER_TYPE);
  compare(UNKNOWN,ALL_TYPE,NUMBER_TYPE);
  compare(UNKNOWN,NO_TYPE,NUMBER_TYPE);
  compare(FALSE,NULL_TYPE,BOOLEAN_TYPE);
  compare(TRUE,NULL_TYPE,NULL_TYPE);
  compare(FALSE,NULL_TYPE,NUMBER_TYPE);
  compare(FALSE,NULL_TYPE,OBJECT_TYPE);
  compare(FALSE,NULL_TYPE,STRING_TYPE);
  compare(TRUE,NULL_TYPE,VOID_TYPE);
  compare(UNKNOWN,NULL_TYPE,createUnionType(UNKNOWN_TYPE,VOID_TYPE));
  compare(UNKNOWN,NULL_TYPE,createUnionType(OBJECT_TYPE,VOID_TYPE));
  compare(UNKNOWN,NULL_TYPE,unresolvedNamedType);
  compare(UNKNOWN,NULL_TYPE,createUnionType(unresolvedNamedType,DATE_TYPE));
  compare(FALSE,VOID_TYPE,REGEXP_TYPE);
  compare(TRUE,VOID_TYPE,VOID_TYPE);
  compare(UNKNOWN,VOID_TYPE,createUnionType(REGEXP_TYPE,VOID_TYPE));
  compare(UNKNOWN,NUMBER_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,NUMBER_TYPE,NUMBER_TYPE);
  compare(UNKNOWN,NUMBER_TYPE,OBJECT_TYPE);
  compare(UNKNOWN,ARRAY_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,OBJECT_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,OBJECT_TYPE,STRING_TYPE);
  compare(UNKNOWN,STRING_TYPE,STRING_TYPE);
  compare(UNKNOWN,STRING_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,STRING_TYPE,NUMBER_TYPE);
  compare(FALSE,STRING_TYPE,VOID_TYPE);
  compare(FALSE,STRING_TYPE,NULL_TYPE);
  compare(FALSE,STRING_TYPE,createUnionType(NULL_TYPE,VOID_TYPE));
  compare(UNKNOWN,UNKNOWN_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,UNKNOWN_TYPE,NULL_TYPE);
  compare(UNKNOWN,UNKNOWN_TYPE,VOID_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,BOOLEAN_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,NUMBER_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,STRING_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,VOID_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,NULL_TYPE);
  compare(UNKNOWN,U2U_CONSTRUCTOR_TYPE,OBJECT_TYPE);
  compare(UNKNOWN,U2U_CONSTRUCTOR_TYPE,ALL_TYPE);
}","/** 
 * Tests the   {@link JSType#testForEquality(JSType)} method.
 */
public void testTestForEquality(){
  compare(TRUE,NO_OBJECT_TYPE,NO_OBJECT_TYPE);
  compare(UNKNOWN,ALL_TYPE,ALL_TYPE);
  compare(TRUE,NO_TYPE,NO_TYPE);
  compare(UNKNOWN,NO_OBJECT_TYPE,NUMBER_TYPE);
  compare(UNKNOWN,ALL_TYPE,NUMBER_TYPE);
  compare(UNKNOWN,NO_TYPE,NUMBER_TYPE);
  compare(FALSE,NULL_TYPE,BOOLEAN_TYPE);
  compare(TRUE,NULL_TYPE,NULL_TYPE);
  compare(FALSE,NULL_TYPE,NUMBER_TYPE);
  compare(FALSE,NULL_TYPE,OBJECT_TYPE);
  compare(FALSE,NULL_TYPE,STRING_TYPE);
  compare(TRUE,NULL_TYPE,VOID_TYPE);
  compare(UNKNOWN,NULL_TYPE,createUnionType(UNKNOWN_TYPE,VOID_TYPE));
  compare(UNKNOWN,NULL_TYPE,createUnionType(OBJECT_TYPE,VOID_TYPE));
  compare(UNKNOWN,NULL_TYPE,unresolvedNamedType);
  compare(UNKNOWN,NULL_TYPE,createUnionType(unresolvedNamedType,DATE_TYPE));
  compare(FALSE,VOID_TYPE,REGEXP_TYPE);
  compare(TRUE,VOID_TYPE,VOID_TYPE);
  compare(UNKNOWN,VOID_TYPE,createUnionType(REGEXP_TYPE,VOID_TYPE));
  compare(UNKNOWN,NUMBER_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,NUMBER_TYPE,NUMBER_TYPE);
  compare(UNKNOWN,NUMBER_TYPE,OBJECT_TYPE);
  compare(UNKNOWN,ARRAY_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,OBJECT_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,OBJECT_TYPE,STRING_TYPE);
  compare(UNKNOWN,STRING_TYPE,STRING_TYPE);
  compare(UNKNOWN,STRING_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,STRING_TYPE,NUMBER_TYPE);
  compare(FALSE,STRING_TYPE,VOID_TYPE);
  compare(FALSE,STRING_TYPE,NULL_TYPE);
  compare(FALSE,STRING_TYPE,createUnionType(NULL_TYPE,VOID_TYPE));
  compare(UNKNOWN,UNKNOWN_TYPE,BOOLEAN_TYPE);
  compare(UNKNOWN,UNKNOWN_TYPE,NULL_TYPE);
  compare(UNKNOWN,UNKNOWN_TYPE,VOID_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,BOOLEAN_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,NUMBER_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,STRING_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,VOID_TYPE);
  compare(FALSE,U2U_CONSTRUCTOR_TYPE,NULL_TYPE);
  compare(UNKNOWN,U2U_CONSTRUCTOR_TYPE,OBJECT_TYPE);
  compare(UNKNOWN,U2U_CONSTRUCTOR_TYPE,ALL_TYPE);
  compare(UNKNOWN,NULL_TYPE,subclassOfUnresolvedNamedType);
  JSType functionAndNull=createUnionType(NULL_TYPE,dateMethod);
  compare(UNKNOWN,functionAndNull,dateMethod);
}"
18860,"@Override public int parseArguments(Parameters params) throws CmdLineException {
  String param=params.getParameter(0);
  if (param == null) {
    setter.addValue(true);
    return 0;
  }
 else {
    String lowerParam=param.toLowerCase();
    if (TRUES.contains(lowerParam)) {
      setter.addValue(true);
    }
 else     if (FALSES.contains(lowerParam)) {
      setter.addValue(false);
    }
 else {
      setter.addValue(true);
      return 0;
    }
    return 1;
  }
}","@Override public int parseArguments(Parameters params) throws CmdLineException {
  String param=null;
  try {
    param=params.getParameter(0);
  }
 catch (  CmdLineException e) {
  }
  if (param == null) {
    setter.addValue(true);
    return 0;
  }
 else {
    String lowerParam=param.toLowerCase();
    if (TRUES.contains(lowerParam)) {
      setter.addValue(true);
    }
 else     if (FALSES.contains(lowerParam)) {
      setter.addValue(false);
    }
 else {
      setter.addValue(true);
      return 0;
    }
    return 1;
  }
}"
18861,"@Override public void setUp() throws Exception {
  super.setUp();
  externs=DEFAULT_EXTERNS;
  lastCompiler=null;
  outReader=new ByteArrayOutputStream();
  errReader=new ByteArrayOutputStream();
  useStringComparison=false;
  useModules=ModulePattern.NONE;
  args.clear();
  exitCodes=Lists.newArrayList();
}","@Override public void setUp() throws Exception {
  super.setUp();
  externs=DEFAULT_EXTERNS;
  lastCompiler=null;
  lastArg=null;
  outReader=new ByteArrayOutputStream();
  errReader=new ByteArrayOutputStream();
  useStringComparison=false;
  useModules=ModulePattern.NONE;
  args.clear();
  exitCodes=Lists.newArrayList();
}"
18862,"private CommandLineRunner createCommandLineRunner(String[] original){
  for (int i=0; i < original.length; i++) {
    args.add(""String_Node_Str"");
    args.add(""String_Node_Str"" + i + ""String_Node_Str"");
    if (useModules == ModulePattern.CHAIN) {
      args.add(""String_Node_Str"");
      args.add(""String_Node_Str"" + i + ""String_Node_Str""+ (i > 0 ? (""String_Node_Str"" + (i - 1)) : ""String_Node_Str""));
    }
 else     if (useModules == ModulePattern.STAR) {
      args.add(""String_Node_Str"");
      args.add(""String_Node_Str"" + i + ""String_Node_Str""+ (i > 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
  String[] argStrings=args.toArray(new String[]{});
  return new CommandLineRunner(argStrings,new PrintStream(outReader),new PrintStream(errReader));
}","private CommandLineRunner createCommandLineRunner(String[] original){
  for (int i=0; i < original.length; i++) {
    args.add(""String_Node_Str"");
    args.add(""String_Node_Str"" + i + ""String_Node_Str"");
    if (useModules == ModulePattern.CHAIN) {
      args.add(""String_Node_Str"");
      args.add(""String_Node_Str"" + i + ""String_Node_Str""+ (i > 0 ? (""String_Node_Str"" + (i - 1)) : ""String_Node_Str""));
    }
 else     if (useModules == ModulePattern.STAR) {
      args.add(""String_Node_Str"");
      args.add(""String_Node_Str"" + i + ""String_Node_Str""+ (i > 0 ? ""String_Node_Str"" : ""String_Node_Str""));
    }
  }
  if (lastArg != null) {
    args.add(lastArg);
  }
  String[] argStrings=args.toArray(new String[]{});
  return new CommandLineRunner(argStrings,new PrintStream(outReader),new PrintStream(errReader));
}"
18863,"/** 
 * Determines whether two slots are meaningfully different for the purposes of data flow analysis.
 */
private boolean diffSlots(StaticSlot<JSType> slotA,StaticSlot<JSType> slotB){
  boolean aIsNull=slotA == null || slotA.getType() == null;
  boolean bIsNull=slotB == null || slotB.getType() == null;
  if (aIsNull && bIsNull) {
    return false;
  }
 else   if (aIsNull ^ bIsNull) {
    return true;
  }
  JSType aType=slotA.getType();
  JSType bType=slotB.getType();
  if (aType.isNoType() || bType.isNoType()) {
    return false;
  }
  return aType.differsFrom(bType);
}","/** 
 * Determines whether two slots are meaningfully different for the purposes of data flow analysis.
 */
private boolean diffSlots(StaticSlot<JSType> slotA,StaticSlot<JSType> slotB){
  boolean aIsNull=slotA == null || slotA.getType() == null;
  boolean bIsNull=slotB == null || slotB.getType() == null;
  if (aIsNull && bIsNull) {
    return false;
  }
 else   if (aIsNull ^ bIsNull) {
    return true;
  }
  return slotA.getType().differsFrom(slotB.getType());
}"
18864,"/** 
 * @return The expression node.
 */
private Node getBlockExpression(Node n){
  Preconditions.checkState(isExpressBlock(n));
  return n.getFirstChild();
}","/** 
 * @return The expression node.
 */
private Node getBlockExpression(Node n){
  Preconditions.checkState(isFoldableExpressBlock(n));
  return n.getFirstChild();
}"
18865,"/** 
 * Try turning IF nodes into smaller HOOKs Returns the replacement for n or the original if no replacement was necessary.
 */
private Node tryMinimizeIf(Node n){
  Node parent=n.getParent();
  Node cond=n.getFirstChild();
  if (NodeUtil.isLiteralValue(cond,true)) {
    return n;
  }
  Node thenBranch=cond.getNext();
  Node elseBranch=thenBranch.getNext();
  if (elseBranch == null) {
    if (isExpressBlock(thenBranch)) {
      Node expr=getBlockExpression(thenBranch);
      if (isPropertyAssignmentInExpression(expr)) {
        return n;
      }
      if (cond.getType() == Token.NOT) {
        if (isLowerPrecedenceInExpression(cond,OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(),OR_PRECEDENCE)) {
          return n;
        }
        Node or=new Node(Token.OR,cond.removeFirstChild(),expr.removeFirstChild()).copyInformationFrom(n);
        Node newExpr=NodeUtil.newExpr(or);
        parent.replaceChild(n,newExpr);
        reportCodeChange();
        return newExpr;
      }
      if (isLowerPrecedenceInExpression(cond,AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(),AND_PRECEDENCE)) {
        return n;
      }
      n.removeChild(cond);
      Node and=new Node(Token.AND,cond,expr.removeFirstChild()).copyInformationFrom(n);
      Node newExpr=NodeUtil.newExpr(and);
      parent.replaceChild(n,newExpr);
      reportCodeChange();
      return newExpr;
    }
    return n;
  }
  tryRemoveRepeatedStatements(n);
  if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
    n.replaceChild(cond,cond.removeFirstChild());
    n.removeChild(thenBranch);
    n.addChildToBack(thenBranch);
    reportCodeChange();
    return n;
  }
  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
    Node thenExpr=getBlockReturnExpression(thenBranch);
    Node elseExpr=getBlockReturnExpression(elseBranch);
    n.removeChild(cond);
    thenExpr.detachFromParent();
    elseExpr.detachFromParent();
    Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
    Node returnNode=new Node(Token.RETURN,hookNode);
    parent.replaceChild(n,returnNode);
    reportCodeChange();
    return returnNode;
  }
  boolean thenBranchIsExpressionBlock=isExpressBlock(thenBranch);
  boolean elseBranchIsExpressionBlock=isExpressBlock(elseBranch);
  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
    Node thenOp=getBlockExpression(thenBranch).getFirstChild();
    Node elseOp=getBlockExpression(elseBranch).getFirstChild();
    if (thenOp.getType() == elseOp.getType()) {
      if (NodeUtil.isAssignmentOp(thenOp)) {
        Node lhs=thenOp.getFirstChild();
        if (areNodesEqualForInlining(lhs,elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {
          n.removeChild(cond);
          Node assignName=thenOp.removeFirstChild();
          Node thenExpr=thenOp.removeFirstChild();
          Node elseExpr=elseOp.getLastChild();
          elseOp.removeChild(elseExpr);
          Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
          Node assign=new Node(thenOp.getType(),assignName,hookNode).copyInformationFrom(thenOp);
          Node expr=NodeUtil.newExpr(assign);
          parent.replaceChild(n,expr);
          reportCodeChange();
          return expr;
        }
      }
 else       if (NodeUtil.isCall(thenOp)) {
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node hookNode=new Node(Token.HOOK,cond,thenOp,elseOp).copyInformationFrom(n);
        Node expr=NodeUtil.newExpr(hookNode);
        parent.replaceChild(n,expr);
        reportCodeChange();
        return expr;
      }
    }
    return n;
  }
  boolean thenBranchIsVar=isVarBlock(thenBranch);
  boolean elseBranchIsVar=isVarBlock(elseBranch);
  if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
    Node var=getBlockVar(thenBranch);
    Node elseAssign=getBlockExpression(elseBranch).getFirstChild();
    Node name1=var.getFirstChild();
    Node maybeName2=elseAssign.getFirstChild();
    if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
      Node thenExpr=name1.removeChildren();
      Node elseExpr=elseAssign.getLastChild().detachFromParent();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name1.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
 else   if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
    Node var=getBlockVar(elseBranch);
    Node thenAssign=getBlockExpression(thenBranch).getFirstChild();
    Node maybeName1=thenAssign.getFirstChild();
    Node name2=var.getFirstChild();
    if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
      Node thenExpr=thenAssign.getLastChild().detachFromParent();
      Node elseExpr=name2.removeChildren();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name2.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
  return n;
}","/** 
 * Try turning IF nodes into smaller HOOKs Returns the replacement for n or the original if no replacement was necessary.
 */
private Node tryMinimizeIf(Node n){
  Node parent=n.getParent();
  Node cond=n.getFirstChild();
  if (NodeUtil.isLiteralValue(cond,true)) {
    return n;
  }
  Node thenBranch=cond.getNext();
  Node elseBranch=thenBranch.getNext();
  if (elseBranch == null) {
    if (isFoldableExpressBlock(thenBranch)) {
      Node expr=getBlockExpression(thenBranch);
      if (isPropertyAssignmentInExpression(expr)) {
        return n;
      }
      if (cond.getType() == Token.NOT) {
        if (isLowerPrecedenceInExpression(cond,OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(),OR_PRECEDENCE)) {
          return n;
        }
        Node or=new Node(Token.OR,cond.removeFirstChild(),expr.removeFirstChild()).copyInformationFrom(n);
        Node newExpr=NodeUtil.newExpr(or);
        parent.replaceChild(n,newExpr);
        reportCodeChange();
        return newExpr;
      }
      if (isLowerPrecedenceInExpression(cond,AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(),AND_PRECEDENCE)) {
        return n;
      }
      n.removeChild(cond);
      Node and=new Node(Token.AND,cond,expr.removeFirstChild()).copyInformationFrom(n);
      Node newExpr=NodeUtil.newExpr(and);
      parent.replaceChild(n,newExpr);
      reportCodeChange();
      return newExpr;
    }
    return n;
  }
  tryRemoveRepeatedStatements(n);
  if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
    n.replaceChild(cond,cond.removeFirstChild());
    n.removeChild(thenBranch);
    n.addChildToBack(thenBranch);
    reportCodeChange();
    return n;
  }
  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
    Node thenExpr=getBlockReturnExpression(thenBranch);
    Node elseExpr=getBlockReturnExpression(elseBranch);
    n.removeChild(cond);
    thenExpr.detachFromParent();
    elseExpr.detachFromParent();
    Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
    Node returnNode=new Node(Token.RETURN,hookNode);
    parent.replaceChild(n,returnNode);
    reportCodeChange();
    return returnNode;
  }
  boolean thenBranchIsExpressionBlock=isFoldableExpressBlock(thenBranch);
  boolean elseBranchIsExpressionBlock=isFoldableExpressBlock(elseBranch);
  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
    Node thenOp=getBlockExpression(thenBranch).getFirstChild();
    Node elseOp=getBlockExpression(elseBranch).getFirstChild();
    if (thenOp.getType() == elseOp.getType()) {
      if (NodeUtil.isAssignmentOp(thenOp)) {
        Node lhs=thenOp.getFirstChild();
        if (areNodesEqualForInlining(lhs,elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {
          n.removeChild(cond);
          Node assignName=thenOp.removeFirstChild();
          Node thenExpr=thenOp.removeFirstChild();
          Node elseExpr=elseOp.getLastChild();
          elseOp.removeChild(elseExpr);
          Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
          Node assign=new Node(thenOp.getType(),assignName,hookNode).copyInformationFrom(thenOp);
          Node expr=NodeUtil.newExpr(assign);
          parent.replaceChild(n,expr);
          reportCodeChange();
          return expr;
        }
      }
 else       if (NodeUtil.isCall(thenOp)) {
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node hookNode=new Node(Token.HOOK,cond,thenOp,elseOp).copyInformationFrom(n);
        Node expr=NodeUtil.newExpr(hookNode);
        parent.replaceChild(n,expr);
        reportCodeChange();
        return expr;
      }
    }
    return n;
  }
  boolean thenBranchIsVar=isVarBlock(thenBranch);
  boolean elseBranchIsVar=isVarBlock(elseBranch);
  if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
    Node var=getBlockVar(thenBranch);
    Node elseAssign=getBlockExpression(elseBranch).getFirstChild();
    Node name1=var.getFirstChild();
    Node maybeName2=elseAssign.getFirstChild();
    if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
      Node thenExpr=name1.removeChildren();
      Node elseExpr=elseAssign.getLastChild().detachFromParent();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name1.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
 else   if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
    Node var=getBlockVar(elseBranch);
    Node thenAssign=getBlockExpression(thenBranch).getFirstChild();
    Node maybeName1=thenAssign.getFirstChild();
    Node name2=var.getFirstChild();
    if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
      Node thenExpr=thenAssign.getLastChild().detachFromParent();
      Node elseExpr=name2.removeChildren();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name2.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
  return n;
}"
18866,"@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> scope){
  setResolvedTypeInternal(this);
  if (implicitPrototype != null && !implicitPrototype.isNativeObjectType()) {
    implicitPrototype=(ObjectType)implicitPrototype.resolve(t,scope);
  }
  for (  Property prop : properties.values()) {
    prop.type=safeResolve(prop.type,t,scope);
  }
  return this;
}","@Override JSType resolveInternal(ErrorReporter t,StaticScope<JSType> scope){
  setResolvedTypeInternal(this);
  ObjectType implicitPrototype=getImplicitPrototype();
  if (implicitPrototype != null) {
    implicitPrototypeFallback=(ObjectType)implicitPrototype.resolve(t,scope);
  }
  for (  Property prop : properties.values()) {
    prop.type=safeResolve(prop.type,t,scope);
  }
  return this;
}"
18867,"/** 
 * This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed.
 */
void setImplicitPrototype(ObjectType implicitPrototype){
  checkState(!hasCachedValues());
  this.implicitPrototype=implicitPrototype;
}","/** 
 * This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed.
 */
final void setImplicitPrototype(ObjectType implicitPrototype){
  checkState(!hasCachedValues());
  this.implicitPrototypeFallback=implicitPrototype;
}"
18868,"@Override public ObjectType getImplicitPrototype(){
  return implicitPrototype;
}","@Override public ObjectType getImplicitPrototype(){
  return implicitPrototypeFallback;
}"
18869,"/** 
 * Creates an object type, allowing specification of the implicit prototype when creating native objects.
 */
PrototypeObjectType(JSTypeRegistry registry,String className,ObjectType implicitPrototype,boolean nativeType){
  super(registry);
  this.properties=Maps.newTreeMap();
  this.className=className;
  this.nativeType=nativeType;
  if (nativeType) {
    this.implicitPrototype=implicitPrototype;
  }
 else   if (implicitPrototype == null) {
    this.implicitPrototype=registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
 else {
    this.implicitPrototype=implicitPrototype;
  }
}","/** 
 * Creates an object type, allowing specification of the implicit prototype when creating native objects.
 */
PrototypeObjectType(JSTypeRegistry registry,String className,ObjectType implicitPrototype,boolean nativeType){
  super(registry);
  this.properties=Maps.newTreeMap();
  this.className=className;
  this.nativeType=nativeType;
  if (nativeType || implicitPrototype != null) {
    setImplicitPrototype(implicitPrototype);
  }
 else {
    setImplicitPrototype(registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));
  }
}"
18870,"private JSType supAndInfHelper(JSType that,boolean leastSuper){
  if (isFunctionType() && that.isFunctionType()) {
    if (isEquivalentTo(that)) {
      return this;
    }
    FunctionType other=null;
    if (that instanceof FunctionType) {
      other=(FunctionType)that;
    }
    if (other != null && isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !other.call.hasUnknownParamsOrReturn()) {
      if (this.isSubtype(that)) {
        return leastSuper ? that : this;
      }
 else       if (that.isSubtype(this)) {
        return leastSuper ? this : that;
      }
      FunctionType merged=tryMergeFunctionPiecewise(other,leastSuper);
      if (merged != null) {
        return merged;
      }
    }
    JSType functionInstance=registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
      return leastSuper ? that : this;
    }
 else     if (functionInstance.isEquivalentTo(this)) {
      return leastSuper ? this : that;
    }
    FunctionType greatestFn=registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn=registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
  }
  return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that);
}","/** 
 * Computes the supremum or infimum of functions with other types. Because sup() and inf() share a lot of logic for functions, we use a single helper.
 * @param leastSuper If true, compute the supremum of {@code this} with{@code that}. Otherwise compute the infimum.
 * @return The least supertype or greatest subtype.
 */
private JSType supAndInfHelper(JSType that,boolean leastSuper){
  if (isFunctionType() && that.isFunctionType()) {
    if (isEquivalentTo(that)) {
      return this;
    }
    FunctionType other=null;
    if (that instanceof FunctionType) {
      other=(FunctionType)that;
    }
    if (other != null && isOrdinaryFunction() && that.isOrdinaryFunction() && !this.call.hasUnknownParamsOrReturn() && !other.call.hasUnknownParamsOrReturn()) {
      boolean isSubtypeOfThat=this.isSubtype(that);
      boolean isSubtypeOfThis=that.isSubtype(this);
      if (isSubtypeOfThat && !isSubtypeOfThis) {
        return leastSuper ? that : this;
      }
 else       if (isSubtypeOfThis && !isSubtypeOfThat) {
        return leastSuper ? this : that;
      }
      FunctionType merged=tryMergeFunctionPiecewise(other,leastSuper);
      if (merged != null) {
        return merged;
      }
    }
    JSType functionInstance=registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
      return leastSuper ? that : this;
    }
 else     if (functionInstance.isEquivalentTo(this)) {
      return leastSuper ? this : that;
    }
    FunctionType greatestFn=registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn=registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
  }
  return leastSuper ? super.getLeastSupertype(that) : super.getGreatestSubtype(that);
}"
18871,"/** 
 * Creates a dotted namespace assignment expression (e.g. <code>foo.bar = {};</code>).
 * @param namespace A dotted namespace
 * @param node A node from which to copy source info.
 */
private Node makeAssignmentExprNode(String namespace,Node node){
  Node decl=new Node(Token.EXPR_RESULT,new Node(Token.ASSIGN,NodeUtil.newQualifiedNameNode(namespace,node,namespace),new Node(Token.OBJECTLIT)));
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  Preconditions.checkState(isNamespacePlaceholder(decl));
  decl.copyInformationFromForTree(node);
  return decl;
}","/** 
 * Creates a dotted namespace assignment expression (e.g. <code>foo.bar = {};</code>).
 * @param namespace A dotted namespace
 * @param node A node from which to copy source info.
 */
private Node makeAssignmentExprNode(String namespace,Node node){
  Node decl=new Node(Token.EXPR_RESULT,new Node(Token.ASSIGN,NodeUtil.newQualifiedNameNode(namespace,node,namespace),createNamespaceLiteral()));
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  Preconditions.checkState(isNamespacePlaceholder(decl));
  decl.copyInformationFromForTree(node);
  return decl;
}"
18872,"/** 
 * Creates a simple namespace variable declaration (e.g. <code>var foo = {};</code>).
 * @param namespace A simple namespace (must be a valid js identifier)
 * @param sourceNode The node to get source information from.
 */
private Node makeVarDeclNode(String namespace,Node sourceNode){
  Node name=Node.newString(Token.NAME,namespace);
  name.addChildToFront(new Node(Token.OBJECTLIT));
  Node decl=new Node(Token.VAR,name);
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  if (compiler.getCodingConvention().isConstant(namespace)) {
    name.putBooleanProp(Node.IS_CONSTANT_NAME,true);
  }
  Preconditions.checkState(isNamespacePlaceholder(decl));
  decl.copyInformationFromForTree(sourceNode);
  return decl;
}","/** 
 * Creates a simple namespace variable declaration (e.g. <code>var foo = {};</code>).
 * @param namespace A simple namespace (must be a valid js identifier)
 * @param sourceNode The node to get source information from.
 */
private Node makeVarDeclNode(String namespace,Node sourceNode){
  Node name=Node.newString(Token.NAME,namespace);
  name.addChildToFront(createNamespaceLiteral());
  Node decl=new Node(Token.VAR,name);
  decl.putBooleanProp(Node.IS_NAMESPACE,true);
  if (compiler.getCodingConvention().isConstant(namespace)) {
    name.putBooleanProp(Node.IS_CONSTANT_NAME,true);
  }
  Preconditions.checkState(isNamespacePlaceholder(decl));
  decl.copyInformationFromForTree(sourceNode);
  return decl;
}"
18873,"private FlowScope traverseObjectLiteral(Node n,FlowScope scope){
  ObjectType objectType=(ObjectType)n.getJSType();
  if (objectType == null) {
    return scope;
  }
  if (objectType.hasReferenceName()) {
    return scope;
  }
  for (Node name=n.getFirstChild(); name != null; name=name.getNext().getNext()) {
    Node value=name.getNext();
    scope=traverse(name,scope);
    scope=traverse(value,scope);
    String memberName=NodeUtil.getStringValue(name);
    if (memberName != null) {
      objectType.defineInferredProperty(memberName,getJSType(value),false);
    }
 else {
      n.setJSType(getNativeType(UNKNOWN_TYPE));
      return scope;
    }
  }
  return scope;
}","private FlowScope traverseObjectLiteral(Node n,FlowScope scope){
  ObjectType objectType=(ObjectType)n.getJSType();
  Preconditions.checkNotNull(objectType);
  if (objectType.hasReferenceName()) {
    return scope;
  }
  for (Node name=n.getFirstChild(); name != null; name=name.getNext().getNext()) {
    Node value=name.getNext();
    scope=traverse(name,scope);
    scope=traverse(value,scope);
    String memberName=NodeUtil.getStringValue(name);
    if (memberName != null) {
      objectType.defineInferredProperty(memberName,getJSType(value),false);
    }
 else {
      n.setJSType(getNativeType(UNKNOWN_TYPE));
      return scope;
    }
  }
  return scope;
}"
18874,"private void attachLiteralTypes(Node n){
switch (n.getType()) {
case Token.NULL:
    n.setJSType(getNativeType(NULL_TYPE));
  break;
case Token.VOID:
n.setJSType(getNativeType(VOID_TYPE));
break;
case Token.STRING:
n.setJSType(getNativeType(STRING_TYPE));
break;
case Token.NUMBER:
n.setJSType(getNativeType(NUMBER_TYPE));
break;
case Token.TRUE:
case Token.FALSE:
n.setJSType(getNativeType(BOOLEAN_TYPE));
break;
case Token.REGEXP:
n.setJSType(getNativeType(REGEXP_TYPE));
break;
case Token.REF_SPECIAL:
n.setJSType(getNativeType(UNKNOWN_TYPE));
break;
case Token.OBJECTLIT:
n.setJSType(typeRegistry.createAnonymousObjectType());
break;
}
}","private void attachLiteralTypes(Node n){
switch (n.getType()) {
case Token.NULL:
    n.setJSType(getNativeType(NULL_TYPE));
  break;
case Token.VOID:
n.setJSType(getNativeType(VOID_TYPE));
break;
case Token.STRING:
n.setJSType(getNativeType(STRING_TYPE));
break;
case Token.NUMBER:
n.setJSType(getNativeType(NUMBER_TYPE));
break;
case Token.TRUE:
case Token.FALSE:
n.setJSType(getNativeType(BOOLEAN_TYPE));
break;
case Token.REGEXP:
n.setJSType(getNativeType(REGEXP_TYPE));
break;
case Token.REF_SPECIAL:
n.setJSType(getNativeType(UNKNOWN_TYPE));
break;
case Token.OBJECTLIT:
if (n.getJSType() == null) {
n.setJSType(typeRegistry.createAnonymousObjectType());
}
break;
}
}"
18875,"@Override public boolean apply(Node node){
  return NodeUtil.isCall(node) || NodeUtil.isNew(node) || NodeUtil.isFunction(node)|| NodeUtil.isName(node)|| (NodeUtil.isString(node) && NodeUtil.isGet(node.getParent()));
}","@Override public boolean apply(Node node){
  return NodeUtil.isCall(node) || NodeUtil.isNew(node) || NodeUtil.isFunction(node)|| NodeUtil.isName(node)|| NodeUtil.isGet(node)|| (NodeUtil.isString(node) && NodeUtil.isGet(node.getParent()));
}"
18876,"void addGuard(WarningsGuard guard){
  if (guard instanceof ComposeWarningsGuard) {
    addGuards(((ComposeWarningsGuard)guard).guards);
  }
 else {
    int index=Collections.binarySearch(this.guards,guard,guardComparator);
    if (index < 0) {
      index=-index - 1;
    }
    this.guards.add(index,guard);
  }
}","void addGuard(WarningsGuard guard){
  if (guard instanceof ComposeWarningsGuard) {
    addGuards(Iterables.reverse(((ComposeWarningsGuard)guard).guards));
  }
 else {
    int index=Collections.binarySearch(this.guards,guard,guardComparator);
    if (index < 0) {
      index=-index - 1;
    }
    this.guards.add(index,guard);
  }
}"
18877,"/** 
 * Determines whether this guard will ""elevate"" the status of any disabled diagnostic type in the group to a warning or an error.
 */
@Override public boolean enables(DiagnosticGroup group){
  for (  WarningsGuard guard : guards) {
    if (guard.enables(group)) {
      return true;
    }
  }
  return false;
}","/** 
 * Determines whether this guard will ""elevate"" the status of any disabled diagnostic type in the group to a warning or an error.
 */
@Override public boolean enables(DiagnosticGroup group){
  for (  WarningsGuard guard : guards) {
    if (guard.enables(group)) {
      return true;
    }
 else     if (guard.disables(group)) {
      return false;
    }
  }
  return false;
}"
18878,"/** 
 * Determines whether the given value is eligible to be moved across modules.
 */
private boolean canMoveValue(Node n){
  if (n == null || NodeUtil.isLiteralValue(n) || n.getType() == Token.FUNCTION) {
    return true;
  }
 else   if (n.getType() == Token.CALL) {
    Node functionName=n.getFirstChild();
    return functionName.getType() == Token.NAME && (functionName.getString().equals(CrossModuleMethodMotion.STUB_METHOD_NAME) || functionName.getString().equals(CrossModuleMethodMotion.UNSTUB_METHOD_NAME));
  }
 else   if (n.getType() == Token.ARRAYLIT || n.getType() == Token.OBJECTLIT) {
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      if (!canMoveValue(child)) {
        return false;
      }
    }
    return true;
  }
  return false;
}","/** 
 * Determines whether the given value is eligible to be moved across modules.
 */
private boolean canMoveValue(Node n){
  if (n == null || NodeUtil.isLiteralValue(n,true) || n.getType() == Token.FUNCTION) {
    return true;
  }
 else   if (n.getType() == Token.CALL) {
    Node functionName=n.getFirstChild();
    return functionName.getType() == Token.NAME && (functionName.getString().equals(CrossModuleMethodMotion.STUB_METHOD_NAME) || functionName.getString().equals(CrossModuleMethodMotion.UNSTUB_METHOD_NAME));
  }
 else   if (n.getType() == Token.ARRAYLIT || n.getType() == Token.OBJECTLIT) {
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      if (!canMoveValue(child)) {
        return false;
      }
    }
    return true;
  }
  return false;
}"
18879,"@Override void visit(NodeTraversal t,Node callNode,Node parent,String callName){
  if (externMethods.contains(callName) || nonMethodProperties.contains(callName)) {
    return;
  }
  Collection<Node> definitions=methodDefinitions.get(callName);
  if (definitions == null || definitions.size() == 0) {
    return;
  }
  Node firstDefinition=definitions.iterator().next();
  if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) {
    if (!argsMayHaveSideEffects(callNode)) {
      Node returned=returnedExpression(firstDefinition);
      if (returned != null) {
        if (isPropertyTree(returned)) {
          logger.fine(""String_Node_Str"" + callName);
          inlinePropertyReturn(parent,callNode,returned);
        }
 else         if (NodeUtil.isLiteralValue(returned) && !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {
          logger.fine(""String_Node_Str"" + callName);
          inlineConstReturn(parent,callNode,returned);
        }
      }
 else       if (isEmptyMethod(firstDefinition) && !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {
        logger.fine(""String_Node_Str"" + callName);
        inlineEmptyMethod(t,parent,callNode);
      }
    }
  }
 else {
    logger.fine(""String_Node_Str"" + callName + ""String_Node_Str"");
  }
}","@Override void visit(NodeTraversal t,Node callNode,Node parent,String callName){
  if (externMethods.contains(callName) || nonMethodProperties.contains(callName)) {
    return;
  }
  Collection<Node> definitions=methodDefinitions.get(callName);
  if (definitions == null || definitions.size() == 0) {
    return;
  }
  Node firstDefinition=definitions.iterator().next();
  if (definitions.size() == 1 || allDefinitionsEquivalent(definitions)) {
    if (!argsMayHaveSideEffects(callNode)) {
      Node returned=returnedExpression(firstDefinition);
      if (returned != null) {
        if (isPropertyTree(returned)) {
          logger.fine(""String_Node_Str"" + callName);
          inlinePropertyReturn(parent,callNode,returned);
        }
 else         if (NodeUtil.isLiteralValue(returned,false) && !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {
          logger.fine(""String_Node_Str"" + callName);
          inlineConstReturn(parent,callNode,returned);
        }
      }
 else       if (isEmptyMethod(firstDefinition) && !NodeUtil.mayHaveSideEffects(callNode.getFirstChild())) {
        logger.fine(""String_Node_Str"" + callName);
        inlineEmptyMethod(t,parent,callNode);
      }
    }
  }
 else {
    logger.fine(""String_Node_Str"" + callName + ""String_Node_Str"");
  }
}"
18880,"/** 
 * If the value is a literal, we can cross more boundaries to inline it.
 */
private boolean canMoveAggressively(Node value){
  return NodeUtil.isLiteralValue(value) || value.getType() == Token.FUNCTION;
}","/** 
 * If the value is a literal, we can cross more boundaries to inline it.
 */
private boolean canMoveAggressively(Node value){
  return NodeUtil.isLiteralValue(value,true) || value.getType() == Token.FUNCTION;
}"
18881,"/** 
 * If the value of a variable is not constant, then it may read or modify state. Therefore it cannot be moved past anything else that may modify the value being read or read values that are modified.
 */
private boolean canMoveModerately(Reference initialization,Reference reference){
  Iterator<Node> it;
  if (initialization.getParent().getType() == Token.VAR) {
    it=NodeIterators.LocalVarMotion.forVar(initialization.getNameNode(),initialization.getParent(),initialization.getGrandparent());
  }
 else   if (initialization.getParent().getType() == Token.ASSIGN) {
    Preconditions.checkState(initialization.getGrandparent().getType() == Token.EXPR_RESULT);
    it=NodeIterators.LocalVarMotion.forAssign(initialization.getNameNode(),initialization.getParent(),initialization.getGrandparent(),initialization.getGrandparent().getParent());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Node targetName=reference.getNameNode();
  while (it.hasNext()) {
    Node curNode=it.next();
    if (curNode == targetName) {
      return true;
    }
  }
  return false;
}","/** 
 * If the value of a variable is not constant, then it may read or modify state. Therefore it cannot be moved past anything else that may modify the value being read or read values that are modified.
 */
private boolean canMoveModerately(Reference initialization,Reference reference){
  Iterator<Node> it;
  if (initialization.getParent().getType() == Token.VAR) {
    it=NodeIterators.LocalVarMotion.forVar(initialization.getNameNode(),initialization.getParent(),initialization.getGrandparent());
  }
 else   if (initialization.getParent().getType() == Token.ASSIGN) {
    Preconditions.checkState(initialization.getGrandparent().getType() == Token.EXPR_RESULT);
    it=NodeIterators.LocalVarMotion.forAssign(initialization.getNameNode(),initialization.getParent(),initialization.getGrandparent(),initialization.getGrandparent().getParent());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + initialization.getParent().toStringTree());
  }
  Node targetName=reference.getNameNode();
  while (it.hasNext()) {
    Node curNode=it.next();
    if (curNode == targetName) {
      return true;
    }
  }
  return false;
}"
18882,"/** 
 * Returns true if this is a literal value. We define a literal value as any node that evaluates to the same thing regardless of when or where it is evaluated. So /xyz/ and [3, 5] are literals, but function() { return a; } is not.
 */
static boolean isLiteralValue(Node n){
switch (n.getType()) {
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      if (!isLiteralValue(child)) {
        return false;
      }
    }
  return true;
default :
return isImmutableValue(n);
}
}","/** 
 * Returns true if this is a literal value. We define a literal value as any node that evaluates to the same thing regardless of when or where it is evaluated. So /xyz/ and [3, 5] are literals, but the name a is not. Function literals do not meet this definition, because they lexically capture variables. For example, if you have <code> function() { return a; } </code> If it is evaluated in a different scope, then it captures a different variable. Even if the function did not read any captured vairables directly, it would still fail this definition, because it affects the lifecycle of variables in the enclosing scope. However, a function literal with respect to a particular scope is a literal.
 * @param includeFunctions If true, all function expressions will betreated as literals.
 */
static boolean isLiteralValue(Node n,boolean includeFunctions){
switch (n.getType()) {
case Token.ARRAYLIT:
case Token.OBJECTLIT:
case Token.REGEXP:
    for (Node child=n.getFirstChild(); child != null; child=child.getNext()) {
      if (!isLiteralValue(child,includeFunctions)) {
        return false;
      }
    }
  return true;
case Token.FUNCTION:
return includeFunctions && !NodeUtil.isFunctionDeclaration(n);
default :
return isImmutableValue(n);
}
}"
18883,"/** 
 * Returns true if some node in n's subtree changes application state. If   {@code checkForNewObjects} is true, we assume that newly createdmutable objects (like object literals) change state. Otherwise, we assume that they have no side effects.
 */
private static boolean checkForStateChangeHelper(Node n,boolean checkForNewObjects,AbstractCompiler compiler){
switch (n.getType()) {
case Token.AND:
case Token.BLOCK:
case Token.EXPR_RESULT:
case Token.HOOK:
case Token.IF:
case Token.IN:
case Token.LP:
case Token.NUMBER:
case Token.OR:
case Token.THIS:
case Token.TRUE:
case Token.FALSE:
case Token.NULL:
case Token.STRING:
case Token.SWITCH:
case Token.TRY:
case Token.EMPTY:
    break;
case Token.THROW:
  return true;
case Token.OBJECTLIT:
case Token.ARRAYLIT:
case Token.REGEXP:
if (checkForNewObjects) {
  return true;
}
break;
case Token.VAR:
case Token.NAME:
if (n.getFirstChild() != null) {
return true;
}
break;
case Token.FUNCTION:
return !isFunctionExpression(n);
case Token.NEW:
if (checkForNewObjects) {
return true;
}
if (!constructorCallHasSideEffects(n)) {
break;
}
return true;
case Token.CALL:
if (!functionCallHasSideEffects(n,compiler)) {
break;
}
return true;
default :
if (isSimpleOperatorType(n.getType())) {
break;
}
if (isAssignmentOp(n)) {
if (checkForStateChangeHelper(n.getFirstChild(),checkForNewObjects,compiler) || checkForStateChangeHelper(n.getLastChild(),checkForNewObjects,compiler)) {
return true;
}
Node current=n.getFirstChild();
for (; current.getType() == Token.GETPROP || current.getType() == Token.GETELEM; current=current.getFirstChild()) {
}
return !(isLiteralValue(current) || current.getType() == Token.FUNCTION);
}
return true;
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (checkForStateChangeHelper(c,checkForNewObjects,compiler)) {
return true;
}
}
return false;
}","/** 
 * Returns true if some node in n's subtree changes application state. If   {@code checkForNewObjects} is true, we assume that newly createdmutable objects (like object literals) change state. Otherwise, we assume that they have no side effects.
 */
private static boolean checkForStateChangeHelper(Node n,boolean checkForNewObjects,AbstractCompiler compiler){
switch (n.getType()) {
case Token.AND:
case Token.BLOCK:
case Token.EXPR_RESULT:
case Token.HOOK:
case Token.IF:
case Token.IN:
case Token.LP:
case Token.NUMBER:
case Token.OR:
case Token.THIS:
case Token.TRUE:
case Token.FALSE:
case Token.NULL:
case Token.STRING:
case Token.SWITCH:
case Token.TRY:
case Token.EMPTY:
    break;
case Token.THROW:
  return true;
case Token.OBJECTLIT:
case Token.ARRAYLIT:
case Token.REGEXP:
if (checkForNewObjects) {
  return true;
}
break;
case Token.VAR:
case Token.NAME:
if (n.getFirstChild() != null) {
return true;
}
break;
case Token.FUNCTION:
return checkForNewObjects || !isFunctionExpression(n);
case Token.NEW:
if (checkForNewObjects) {
return true;
}
if (!constructorCallHasSideEffects(n)) {
break;
}
return true;
case Token.CALL:
if (!functionCallHasSideEffects(n,compiler)) {
break;
}
return true;
default :
if (isSimpleOperatorType(n.getType())) {
break;
}
if (isAssignmentOp(n)) {
if (checkForStateChangeHelper(n.getFirstChild(),checkForNewObjects,compiler) || checkForStateChangeHelper(n.getLastChild(),checkForNewObjects,compiler)) {
return true;
}
Node current=n.getFirstChild();
for (; current.getType() == Token.GETPROP || current.getType() == Token.GETELEM; current=current.getFirstChild()) {
}
return !isLiteralValue(current,true);
}
return true;
}
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (checkForStateChangeHelper(c,checkForNewObjects,compiler)) {
return true;
}
}
return false;
}"
18884,"private void buildParameterList(List<Parameter> parameters,Node cur){
  while ((cur=cur.getNext()) != null) {
    parameters.add(new Parameter(cur,NodeUtil.isLiteralValue(cur)));
  }
}","private void buildParameterList(List<Parameter> parameters,Node cur){
  while ((cur=cur.getNext()) != null) {
    parameters.add(new Parameter(cur,NodeUtil.isLiteralValue(cur,false)));
  }
}"
18885,"private Node tryFoldAdd(Node node,Node left,Node right){
  Preconditions.checkArgument(node.getType() == Token.ADD);
  if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) {
    return tryFoldAddConstant(node,left,right);
  }
 else {
    return tryFoldLeftChildAdd(node,left,right);
  }
}","private Node tryFoldAdd(Node node,Node left,Node right){
  Preconditions.checkArgument(node.getType() == Token.ADD);
  if (NodeUtil.isLiteralValue(left,false) && NodeUtil.isLiteralValue(right,false)) {
    return tryFoldAddConstant(node,left,right);
  }
 else {
    return tryFoldLeftChildAdd(node,left,right);
  }
}"
18886,"/** 
 * Expressions such as [foo() + 'a' + 'b'] generate parse trees where no node has two const children ((foo() + 'a') + 'b'), so tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings). Specifically it folds Add exprssions where: - The left child is also and add expression - The right child is a constant value - The left child's right child is a STRING constant. WARNING: If javascript ever adds operator overloading, this will probably stop being correct.
 */
private Node tryFoldLeftChildAdd(Node n,Node left,Node right){
  if (NodeUtil.isLiteralValue(right) && left.getType() == Token.ADD && left.getChildCount() == 2) {
    Node ll=left.getFirstChild();
    Node lr=ll.getNext();
    if (lr.getType() != Token.STRING) {
      return n;
    }
    String leftString=NodeUtil.getStringValue(lr);
    String rightString=NodeUtil.getStringValue(right);
    if (leftString != null && rightString != null) {
      left.removeChild(ll);
      String result=leftString + rightString;
      n.replaceChild(left,ll);
      n.replaceChild(right,Node.newString(result));
      reportCodeChange();
    }
  }
  return n;
}","/** 
 * Expressions such as [foo() + 'a' + 'b'] generate parse trees where no node has two const children ((foo() + 'a') + 'b'), so tryFoldAdd() won't fold it -- tryFoldLeftChildAdd() will (for Strings). Specifically it folds Add exprssions where: - The left child is also and add expression - The right child is a constant value - The left child's right child is a STRING constant. WARNING: If javascript ever adds operator overloading, this will probably stop being correct.
 */
private Node tryFoldLeftChildAdd(Node n,Node left,Node right){
  if (NodeUtil.isLiteralValue(right,false) && left.getType() == Token.ADD && left.getChildCount() == 2) {
    Node ll=left.getFirstChild();
    Node lr=ll.getNext();
    if (lr.getType() != Token.STRING) {
      return n;
    }
    String leftString=NodeUtil.getStringValue(lr);
    String rightString=NodeUtil.getStringValue(right);
    if (leftString != null && rightString != null) {
      left.removeChild(ll);
      String result=leftString + rightString;
      n.replaceChild(left,ll);
      n.replaceChild(right,Node.newString(result));
      reportCodeChange();
    }
  }
  return n;
}"
18887,"/** 
 * Folds 'typeof(foo)' if foo is a literal, e.g. typeof(""bar"") --> ""string"" typeof(6) --> ""number""
 */
private Node tryFoldTypeof(Node originalTypeofNode){
  Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);
  Node argumentNode=originalTypeofNode.getFirstChild();
  if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
    return originalTypeofNode;
  }
  String typeNameString=null;
switch (argumentNode.getType()) {
case Token.STRING:
    typeNameString=""String_Node_Str"";
  break;
case Token.NUMBER:
typeNameString=""String_Node_Str"";
break;
case Token.TRUE:
case Token.FALSE:
typeNameString=""String_Node_Str"";
break;
case Token.NULL:
case Token.OBJECTLIT:
case Token.ARRAYLIT:
typeNameString=""String_Node_Str"";
break;
case Token.VOID:
typeNameString=""String_Node_Str"";
break;
case Token.NAME:
if (""String_Node_Str"".equals(argumentNode.getString())) {
typeNameString=""String_Node_Str"";
}
break;
}
if (typeNameString != null) {
Node newNode=Node.newString(typeNameString);
originalTypeofNode.getParent().replaceChild(originalTypeofNode,newNode);
reportCodeChange();
return newNode;
}
return originalTypeofNode;
}","/** 
 * Folds 'typeof(foo)' if foo is a literal, e.g. typeof(""bar"") --> ""string"" typeof(6) --> ""number""
 */
private Node tryFoldTypeof(Node originalTypeofNode){
  Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);
  Node argumentNode=originalTypeofNode.getFirstChild();
  if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode,true)) {
    return originalTypeofNode;
  }
  String typeNameString=null;
switch (argumentNode.getType()) {
case Token.FUNCTION:
    typeNameString=""String_Node_Str"";
  break;
case Token.STRING:
typeNameString=""String_Node_Str"";
break;
case Token.NUMBER:
typeNameString=""String_Node_Str"";
break;
case Token.TRUE:
case Token.FALSE:
typeNameString=""String_Node_Str"";
break;
case Token.NULL:
case Token.OBJECTLIT:
case Token.ARRAYLIT:
typeNameString=""String_Node_Str"";
break;
case Token.VOID:
typeNameString=""String_Node_Str"";
break;
case Token.NAME:
if (""String_Node_Str"".equals(argumentNode.getString())) {
typeNameString=""String_Node_Str"";
}
break;
}
if (typeNameString != null) {
Node newNode=Node.newString(typeNameString);
originalTypeofNode.getParent().replaceChild(originalTypeofNode,newNode);
reportCodeChange();
return newNode;
}
return originalTypeofNode;
}"
18888,"/** 
 * Try to fold   {@code left instanceof right} into {@code true}or   {@code false}.
 */
private Node tryFoldInstanceof(Node n,Node left,Node right){
  Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);
  if (NodeUtil.isLiteralValue(left) && !NodeUtil.mayHaveSideEffects(right)) {
    Node replacementNode=null;
    if (NodeUtil.isImmutableValue(left)) {
      replacementNode=new Node(Token.FALSE);
    }
 else     if (right.getType() == Token.NAME && ""String_Node_Str"".equals(right.getString())) {
      replacementNode=new Node(Token.TRUE);
    }
    if (replacementNode != null) {
      n.getParent().replaceChild(n,replacementNode);
      reportCodeChange();
      return replacementNode;
    }
  }
  return n;
}","/** 
 * Try to fold   {@code left instanceof right} into {@code true}or   {@code false}.
 */
private Node tryFoldInstanceof(Node n,Node left,Node right){
  Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);
  if (NodeUtil.isLiteralValue(left,true) && !NodeUtil.mayHaveSideEffects(right)) {
    Node replacementNode=null;
    if (NodeUtil.isImmutableValue(left)) {
      replacementNode=new Node(Token.FALSE);
    }
 else     if (right.getType() == Token.NAME && ""String_Node_Str"".equals(right.getString())) {
      replacementNode=new Node(Token.TRUE);
    }
    if (replacementNode != null) {
      n.getParent().replaceChild(n,replacementNode);
      reportCodeChange();
      return replacementNode;
    }
  }
  return n;
}"
18889,"/** 
 * Try to fold comparison nodes, e.g ==
 */
@SuppressWarnings(""String_Node_Str"") private Node tryFoldComparison(Node n,Node left,Node right){
  if (!NodeUtil.isLiteralValue(left) || !NodeUtil.isLiteralValue(right)) {
    if (n.getType() != Token.GT && n.getType() != Token.LT) {
      return n;
    }
  }
  int op=n.getType();
  boolean result;
  boolean rightLiteral=NodeUtil.isLiteralValue(right);
  boolean undefinedRight=((Token.NAME == right.getType() && right.getString().equals(""String_Node_Str"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild())));
switch (left.getType()) {
case Token.VOID:
    if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
      return n;
    }
 else     if (!rightLiteral) {
      return n;
    }
 else {
      boolean nullRight=(Token.NULL == right.getType());
      boolean equivalent=undefinedRight || nullRight;
switch (op) {
case Token.EQ:
        result=equivalent;
      break;
case Token.NE:
    result=!equivalent;
  break;
case Token.SHEQ:
result=undefinedRight;
break;
case Token.SHNE:
result=!undefinedRight;
break;
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
result=false;
break;
default :
return n;
}
}
break;
case Token.NULL:
if (undefinedRight) {
result=(op == Token.EQ);
break;
}
case Token.TRUE:
case Token.FALSE:
if (undefinedRight) {
result=false;
break;
}
case Token.THIS:
int tt=right.getType();
if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL) {
return n;
}
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=left.getType() == right.getType();
break;
case Token.SHNE:
case Token.NE:
result=left.getType() != right.getType();
break;
default :
return n;
}
break;
case Token.STRING:
if (undefinedRight) {
result=false;
break;
}
if (Token.STRING != right.getType()) {
return n;
}
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=left.getString().equals(right.getString());
break;
case Token.SHNE:
case Token.NE:
result=!left.getString().equals(right.getString());
break;
default :
return n;
}
break;
case Token.NUMBER:
if (undefinedRight) {
result=false;
break;
}
if (Token.NUMBER != right.getType()) {
return n;
}
double lv=left.getDouble();
double rv=right.getDouble();
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=lv == rv;
break;
case Token.SHNE:
case Token.NE:
result=lv != rv;
break;
case Token.LE:
result=lv <= rv;
break;
case Token.LT:
result=lv < rv;
break;
case Token.GE:
result=lv >= rv;
break;
case Token.GT:
result=lv > rv;
break;
default :
return n;
}
break;
case Token.NAME:
if (rightLiteral) {
boolean undefinedLeft=(left.getString().equals(""String_Node_Str""));
if (undefinedLeft) {
boolean nullRight=(Token.NULL == right.getType());
boolean equivalent=undefinedRight || nullRight;
switch (op) {
case Token.EQ:
result=equivalent;
break;
case Token.NE:
result=!equivalent;
break;
case Token.SHEQ:
result=undefinedRight;
break;
case Token.SHNE:
result=!undefinedRight;
break;
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
result=false;
break;
default :
return n;
}
break;
}
}
if (Token.NAME != right.getType()) {
return n;
}
String ln=left.getString();
String rn=right.getString();
if (!ln.equals(rn)) {
return n;
}
switch (op) {
case Token.LT:
case Token.GT:
result=false;
break;
default :
return n;
}
break;
default :
return n;
}
Node newNode=new Node(result ? Token.TRUE : Token.FALSE);
n.getParent().replaceChild(n,newNode);
reportCodeChange();
return newNode;
}","/** 
 * Try to fold comparison nodes, e.g ==
 */
@SuppressWarnings(""String_Node_Str"") private Node tryFoldComparison(Node n,Node left,Node right){
  if (!NodeUtil.isLiteralValue(left,false) || !NodeUtil.isLiteralValue(right,false)) {
    if (n.getType() != Token.GT && n.getType() != Token.LT) {
      return n;
    }
  }
  int op=n.getType();
  boolean result;
  boolean rightLiteral=NodeUtil.isLiteralValue(right,false);
  boolean undefinedRight=((Token.NAME == right.getType() && right.getString().equals(""String_Node_Str"")) || (Token.VOID == right.getType() && NodeUtil.isLiteralValue(right.getFirstChild(),false)));
switch (left.getType()) {
case Token.VOID:
    if (!NodeUtil.isLiteralValue(left.getFirstChild(),false)) {
      return n;
    }
 else     if (!rightLiteral) {
      return n;
    }
 else {
      boolean nullRight=(Token.NULL == right.getType());
      boolean equivalent=undefinedRight || nullRight;
switch (op) {
case Token.EQ:
        result=equivalent;
      break;
case Token.NE:
    result=!equivalent;
  break;
case Token.SHEQ:
result=undefinedRight;
break;
case Token.SHNE:
result=!undefinedRight;
break;
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
result=false;
break;
default :
return n;
}
}
break;
case Token.NULL:
if (undefinedRight) {
result=(op == Token.EQ);
break;
}
case Token.TRUE:
case Token.FALSE:
if (undefinedRight) {
result=false;
break;
}
case Token.THIS:
int tt=right.getType();
if (tt != Token.THIS && tt != Token.TRUE && tt != Token.FALSE && tt != Token.NULL) {
return n;
}
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=left.getType() == right.getType();
break;
case Token.SHNE:
case Token.NE:
result=left.getType() != right.getType();
break;
default :
return n;
}
break;
case Token.STRING:
if (undefinedRight) {
result=false;
break;
}
if (Token.STRING != right.getType()) {
return n;
}
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=left.getString().equals(right.getString());
break;
case Token.SHNE:
case Token.NE:
result=!left.getString().equals(right.getString());
break;
default :
return n;
}
break;
case Token.NUMBER:
if (undefinedRight) {
result=false;
break;
}
if (Token.NUMBER != right.getType()) {
return n;
}
double lv=left.getDouble();
double rv=right.getDouble();
switch (op) {
case Token.SHEQ:
case Token.EQ:
result=lv == rv;
break;
case Token.SHNE:
case Token.NE:
result=lv != rv;
break;
case Token.LE:
result=lv <= rv;
break;
case Token.LT:
result=lv < rv;
break;
case Token.GE:
result=lv >= rv;
break;
case Token.GT:
result=lv > rv;
break;
default :
return n;
}
break;
case Token.NAME:
if (rightLiteral) {
boolean undefinedLeft=(left.getString().equals(""String_Node_Str""));
if (undefinedLeft) {
boolean nullRight=(Token.NULL == right.getType());
boolean equivalent=undefinedRight || nullRight;
switch (op) {
case Token.EQ:
result=equivalent;
break;
case Token.NE:
result=!equivalent;
break;
case Token.SHEQ:
result=undefinedRight;
break;
case Token.SHNE:
result=!undefinedRight;
break;
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
result=false;
break;
default :
return n;
}
break;
}
}
if (Token.NAME != right.getType()) {
return n;
}
String ln=left.getString();
String rn=right.getString();
if (!ln.equals(rn)) {
return n;
}
switch (op) {
case Token.LT:
case Token.GT:
result=false;
break;
default :
return n;
}
break;
default :
return n;
}
Node newNode=new Node(result ? Token.TRUE : Token.FALSE);
n.getParent().replaceChild(n,newNode);
reportCodeChange();
return newNode;
}"
18890,"/** 
 * Folds ""typeof expression"" based on the JSType of ""expression"" if the expression  has no side effects. <p>E.g., <pre> var x = 6; if (typeof(x) == ""number"") { } </pre> folds to <pre> var x = 6; if (""number"" == ""number"") { } </pre> <p>This method doesn't fold literal values -- we leave that to PeepholeFoldConstants.
 */
private Node tryFoldTypeof(Node typeofNode){
  Preconditions.checkArgument(typeofNode.getType() == Token.TYPEOF);
  Preconditions.checkArgument(typeofNode.getFirstChild() != null);
  Node argumentNode=typeofNode.getFirstChild();
  if (!NodeUtil.isLiteralValue(argumentNode) && !NodeUtil.mayHaveSideEffects(argumentNode)) {
    JSType argumentType=argumentNode.getJSType();
    String typeName=null;
    if (argumentType != null) {
      if (argumentType.isObject() || argumentType.isNullType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isStringValueType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isNumberValueType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isBooleanValueType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isVoidType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isUnionType()) {
        typeName=null;
      }
      if (typeName != null) {
        Node newNode=Node.newString(typeName);
        typeofNode.getParent().replaceChild(typeofNode,newNode);
        reportCodeChange();
        return newNode;
      }
    }
  }
  return typeofNode;
}","/** 
 * Folds ""typeof expression"" based on the JSType of ""expression"" if the expression  has no side effects. <p>E.g., <pre> var x = 6; if (typeof(x) == ""number"") { } </pre> folds to <pre> var x = 6; if (""number"" == ""number"") { } </pre> <p>This method doesn't fold literal values -- we leave that to PeepholeFoldConstants.
 */
private Node tryFoldTypeof(Node typeofNode){
  Preconditions.checkArgument(typeofNode.getType() == Token.TYPEOF);
  Preconditions.checkArgument(typeofNode.getFirstChild() != null);
  Node argumentNode=typeofNode.getFirstChild();
  if (!NodeUtil.isLiteralValue(argumentNode,true) && !NodeUtil.mayHaveSideEffects(argumentNode)) {
    JSType argumentType=argumentNode.getJSType();
    String typeName=null;
    if (argumentType != null) {
      if (argumentType.isObject() || argumentType.isNullType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isStringValueType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isNumberValueType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isBooleanValueType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isVoidType()) {
        typeName=""String_Node_Str"";
      }
 else       if (argumentType.isUnionType()) {
        typeName=null;
      }
      if (typeName != null) {
        Node newNode=Node.newString(typeName);
        typeofNode.getParent().replaceChild(typeofNode,newNode);
        reportCodeChange();
        return newNode;
      }
    }
  }
  return typeofNode;
}"
18891,"/** 
 * Try folding :? (hook) and IF nodes by removing dead branches.
 * @return the replacement node, if changed, or the original if not
 */
private Node tryFoldHookIf(Node n){
  Node parent=n.getParent();
  int type=n.getType();
  Node cond=n.getFirstChild();
  Node thenBody=cond.getNext();
  Node elseBody=thenBody.getNext();
  boolean changes=false;
  if (type == Token.IF) {
    if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {
      n.removeChild(elseBody);
      elseBody=null;
      reportCodeChange();
      changes=true;
    }
    if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {
      n.removeChild(elseBody);
      n.replaceChild(thenBody,elseBody);
      Node notCond=new Node(Token.NOT);
      n.replaceChild(cond,notCond);
      notCond.addChildToFront(cond);
      cond=notCond;
      thenBody=cond.getNext();
      elseBody=null;
      reportCodeChange();
      changes=true;
    }
    if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {
      if (NodeUtil.mayHaveSideEffects(cond)) {
        n.removeChild(cond);
        Node replacement=NodeUtil.newExpr(cond);
        parent.replaceChild(n,replacement);
        reportCodeChange();
        return replacement;
      }
 else {
        NodeUtil.removeChild(parent,n);
        reportCodeChange();
        return null;
      }
    }
  }
 else {
    Preconditions.checkState(type == Token.HOOK);
    if (NodeUtil.isExpressionNode(parent)) {
      if (!NodeUtil.mayHaveSideEffects(thenBody)) {
        Node ifNode=new Node(Token.IF);
        if (cond.getType() == Token.NOT) {
          Node expr=cond.getFirstChild();
          cond.removeChild(expr);
          ifNode.addChildToBack(expr);
        }
 else {
          Node not=new Node(Token.NOT).copyInformationFrom(cond);
          n.removeChild(cond);
          not.addChildToBack(cond);
          ifNode.addChildToBack(not);
        }
        n.removeChild(elseBody);
        ifNode.addChildToBack(new Node(Token.BLOCK,NodeUtil.newExpr(elseBody)).copyInformationFrom(elseBody));
        parent.getParent().replaceChild(parent,ifNode);
        reportCodeChange();
        return ifNode;
      }
 else       if (!NodeUtil.mayHaveSideEffects(elseBody)) {
        Node ifNode=new Node(Token.IF);
        n.removeChild(cond);
        ifNode.addChildToBack(cond);
        n.removeChild(thenBody);
        ifNode.addChildToBack(new Node(Token.BLOCK,NodeUtil.newExpr(thenBody)).copyInformationFrom(thenBody));
        parent.getParent().replaceChild(parent,ifNode);
        reportCodeChange();
        return ifNode;
      }
    }
  }
  if (!NodeUtil.isLiteralValue(cond)) {
    return n;
  }
  TernaryValue condValue=NodeUtil.getBooleanValue(cond);
  if (condValue == TernaryValue.UNKNOWN) {
    return n;
  }
  boolean condTrue=condValue.toBoolean(true);
  if (n.getChildCount() == 2) {
    Preconditions.checkState(type == Token.IF);
    if (condTrue) {
      Node thenStmt=n.getFirstChild().getNext();
      n.removeChild(thenStmt);
      parent.replaceChild(n,thenStmt);
      reportCodeChange();
      return thenStmt;
    }
 else {
      NodeUtil.redeclareVarsInsideBranch(n);
      NodeUtil.removeChild(parent,n);
      reportCodeChange();
      return null;
    }
  }
 else {
    Node firstBranch=n.getFirstChild().getNext();
    Node secondBranch=firstBranch.getNext();
    Node branch=condTrue ? firstBranch : secondBranch;
    Node notBranch=condTrue ? secondBranch : firstBranch;
    NodeUtil.redeclareVarsInsideBranch(notBranch);
    n.removeChild(branch);
    parent.replaceChild(n,branch);
    reportCodeChange();
    return branch;
  }
}","/** 
 * Try folding :? (hook) and IF nodes by removing dead branches.
 * @return the replacement node, if changed, or the original if not
 */
private Node tryFoldHookIf(Node n){
  Node parent=n.getParent();
  int type=n.getType();
  Node cond=n.getFirstChild();
  Node thenBody=cond.getNext();
  Node elseBody=thenBody.getNext();
  boolean changes=false;
  if (type == Token.IF) {
    if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {
      n.removeChild(elseBody);
      elseBody=null;
      reportCodeChange();
      changes=true;
    }
    if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {
      n.removeChild(elseBody);
      n.replaceChild(thenBody,elseBody);
      Node notCond=new Node(Token.NOT);
      n.replaceChild(cond,notCond);
      notCond.addChildToFront(cond);
      cond=notCond;
      thenBody=cond.getNext();
      elseBody=null;
      reportCodeChange();
      changes=true;
    }
    if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {
      if (NodeUtil.mayHaveSideEffects(cond)) {
        n.removeChild(cond);
        Node replacement=NodeUtil.newExpr(cond);
        parent.replaceChild(n,replacement);
        reportCodeChange();
        return replacement;
      }
 else {
        NodeUtil.removeChild(parent,n);
        reportCodeChange();
        return null;
      }
    }
  }
 else {
    Preconditions.checkState(type == Token.HOOK);
    if (NodeUtil.isExpressionNode(parent)) {
      if (!NodeUtil.mayHaveSideEffects(thenBody)) {
        Node ifNode=new Node(Token.IF);
        if (cond.getType() == Token.NOT) {
          Node expr=cond.getFirstChild();
          cond.removeChild(expr);
          ifNode.addChildToBack(expr);
        }
 else {
          Node not=new Node(Token.NOT).copyInformationFrom(cond);
          n.removeChild(cond);
          not.addChildToBack(cond);
          ifNode.addChildToBack(not);
        }
        n.removeChild(elseBody);
        ifNode.addChildToBack(new Node(Token.BLOCK,NodeUtil.newExpr(elseBody)).copyInformationFrom(elseBody));
        parent.getParent().replaceChild(parent,ifNode);
        reportCodeChange();
        return ifNode;
      }
 else       if (!NodeUtil.mayHaveSideEffects(elseBody)) {
        Node ifNode=new Node(Token.IF);
        n.removeChild(cond);
        ifNode.addChildToBack(cond);
        n.removeChild(thenBody);
        ifNode.addChildToBack(new Node(Token.BLOCK,NodeUtil.newExpr(thenBody)).copyInformationFrom(thenBody));
        parent.getParent().replaceChild(parent,ifNode);
        reportCodeChange();
        return ifNode;
      }
    }
  }
  if (!NodeUtil.isLiteralValue(cond,true)) {
    return n;
  }
  TernaryValue condValue=NodeUtil.getBooleanValue(cond);
  if (condValue == TernaryValue.UNKNOWN) {
    return n;
  }
  boolean condTrue=condValue.toBoolean(true);
  if (n.getChildCount() == 2) {
    Preconditions.checkState(type == Token.IF);
    if (condTrue) {
      Node thenStmt=n.getFirstChild().getNext();
      n.removeChild(thenStmt);
      parent.replaceChild(n,thenStmt);
      reportCodeChange();
      return thenStmt;
    }
 else {
      NodeUtil.redeclareVarsInsideBranch(n);
      NodeUtil.removeChild(parent,n);
      reportCodeChange();
      return null;
    }
  }
 else {
    Node firstBranch=n.getFirstChild().getNext();
    Node secondBranch=firstBranch.getNext();
    Node branch=condTrue ? firstBranch : secondBranch;
    Node notBranch=condTrue ? secondBranch : firstBranch;
    NodeUtil.redeclareVarsInsideBranch(notBranch);
    n.removeChild(branch);
    parent.replaceChild(n,branch);
    reportCodeChange();
    return branch;
  }
}"
18892,"/** 
 * Try turning IF nodes into smaller HOOKs Returns the replacement for n or the original if no replacement was necessary.
 */
private Node tryMinimizeIf(Node n){
  Node parent=n.getParent();
  Node cond=n.getFirstChild();
  if (NodeUtil.isLiteralValue(cond)) {
    return n;
  }
  Node thenBranch=cond.getNext();
  Node elseBranch=thenBranch.getNext();
  if (elseBranch == null) {
    if (isExpressBlock(thenBranch)) {
      Node expr=getBlockExpression(thenBranch);
      if (isPropertyAssignmentInExpression(expr)) {
        return n;
      }
      if (cond.getType() == Token.NOT) {
        if (isLowerPrecedenceInExpression(cond,OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(),OR_PRECEDENCE)) {
          return n;
        }
        Node or=new Node(Token.OR,cond.removeFirstChild(),expr.removeFirstChild()).copyInformationFrom(n);
        Node newExpr=NodeUtil.newExpr(or);
        parent.replaceChild(n,newExpr);
        reportCodeChange();
        return newExpr;
      }
      if (isLowerPrecedenceInExpression(cond,AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(),AND_PRECEDENCE)) {
        return n;
      }
      n.removeChild(cond);
      Node and=new Node(Token.AND,cond,expr.removeFirstChild()).copyInformationFrom(n);
      Node newExpr=NodeUtil.newExpr(and);
      parent.replaceChild(n,newExpr);
      reportCodeChange();
      return newExpr;
    }
    return n;
  }
  tryRemoveRepeatedStatements(n);
  if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
    n.replaceChild(cond,cond.removeFirstChild());
    n.removeChild(thenBranch);
    n.addChildToBack(thenBranch);
    reportCodeChange();
    return n;
  }
  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
    Node thenExpr=getBlockReturnExpression(thenBranch);
    Node elseExpr=getBlockReturnExpression(elseBranch);
    n.removeChild(cond);
    thenExpr.detachFromParent();
    elseExpr.detachFromParent();
    Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
    Node returnNode=new Node(Token.RETURN,hookNode);
    parent.replaceChild(n,returnNode);
    reportCodeChange();
    return returnNode;
  }
  boolean thenBranchIsExpressionBlock=isExpressBlock(thenBranch);
  boolean elseBranchIsExpressionBlock=isExpressBlock(elseBranch);
  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
    Node thenOp=getBlockExpression(thenBranch).getFirstChild();
    Node elseOp=getBlockExpression(elseBranch).getFirstChild();
    if (thenOp.getType() == elseOp.getType()) {
      if (NodeUtil.isAssignmentOp(thenOp)) {
        Node lhs=thenOp.getFirstChild();
        if (areNodesEqualForInlining(lhs,elseOp.getFirstChild()) && !NodeUtil.mayEffectMutableState(lhs)) {
          n.removeChild(cond);
          Node assignName=thenOp.removeFirstChild();
          Node thenExpr=thenOp.removeFirstChild();
          Node elseExpr=elseOp.getLastChild();
          elseOp.removeChild(elseExpr);
          Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
          Node assign=new Node(thenOp.getType(),assignName,hookNode).copyInformationFrom(thenOp);
          Node expr=NodeUtil.newExpr(assign);
          parent.replaceChild(n,expr);
          reportCodeChange();
          return expr;
        }
      }
 else       if (NodeUtil.isCall(thenOp)) {
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node hookNode=new Node(Token.HOOK,cond,thenOp,elseOp).copyInformationFrom(n);
        Node expr=NodeUtil.newExpr(hookNode);
        parent.replaceChild(n,expr);
        reportCodeChange();
        return expr;
      }
    }
    return n;
  }
  boolean thenBranchIsVar=isVarBlock(thenBranch);
  boolean elseBranchIsVar=isVarBlock(elseBranch);
  if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
    Node var=getBlockVar(thenBranch);
    Node elseAssign=getBlockExpression(elseBranch).getFirstChild();
    Node name1=var.getFirstChild();
    Node maybeName2=elseAssign.getFirstChild();
    if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
      Node thenExpr=name1.removeChildren();
      Node elseExpr=elseAssign.getLastChild().detachFromParent();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name1.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
 else   if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
    Node var=getBlockVar(elseBranch);
    Node thenAssign=getBlockExpression(thenBranch).getFirstChild();
    Node maybeName1=thenAssign.getFirstChild();
    Node name2=var.getFirstChild();
    if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
      Node thenExpr=thenAssign.getLastChild().detachFromParent();
      Node elseExpr=name2.removeChildren();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name2.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
  return n;
}","/** 
 * Try turning IF nodes into smaller HOOKs Returns the replacement for n or the original if no replacement was necessary.
 */
private Node tryMinimizeIf(Node n){
  Node parent=n.getParent();
  Node cond=n.getFirstChild();
  if (NodeUtil.isLiteralValue(cond,true)) {
    return n;
  }
  Node thenBranch=cond.getNext();
  Node elseBranch=thenBranch.getNext();
  if (elseBranch == null) {
    if (isExpressBlock(thenBranch)) {
      Node expr=getBlockExpression(thenBranch);
      if (isPropertyAssignmentInExpression(expr)) {
        return n;
      }
      if (cond.getType() == Token.NOT) {
        if (isLowerPrecedenceInExpression(cond,OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(),OR_PRECEDENCE)) {
          return n;
        }
        Node or=new Node(Token.OR,cond.removeFirstChild(),expr.removeFirstChild()).copyInformationFrom(n);
        Node newExpr=NodeUtil.newExpr(or);
        parent.replaceChild(n,newExpr);
        reportCodeChange();
        return newExpr;
      }
      if (isLowerPrecedenceInExpression(cond,AND_PRECEDENCE) || isLowerPrecedenceInExpression(expr.getFirstChild(),AND_PRECEDENCE)) {
        return n;
      }
      n.removeChild(cond);
      Node and=new Node(Token.AND,cond,expr.removeFirstChild()).copyInformationFrom(n);
      Node newExpr=NodeUtil.newExpr(and);
      parent.replaceChild(n,newExpr);
      reportCodeChange();
      return newExpr;
    }
    return n;
  }
  tryRemoveRepeatedStatements(n);
  if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
    n.replaceChild(cond,cond.removeFirstChild());
    n.removeChild(thenBranch);
    n.addChildToBack(thenBranch);
    reportCodeChange();
    return n;
  }
  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
    Node thenExpr=getBlockReturnExpression(thenBranch);
    Node elseExpr=getBlockReturnExpression(elseBranch);
    n.removeChild(cond);
    thenExpr.detachFromParent();
    elseExpr.detachFromParent();
    Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
    Node returnNode=new Node(Token.RETURN,hookNode);
    parent.replaceChild(n,returnNode);
    reportCodeChange();
    return returnNode;
  }
  boolean thenBranchIsExpressionBlock=isExpressBlock(thenBranch);
  boolean elseBranchIsExpressionBlock=isExpressBlock(elseBranch);
  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
    Node thenOp=getBlockExpression(thenBranch).getFirstChild();
    Node elseOp=getBlockExpression(elseBranch).getFirstChild();
    if (thenOp.getType() == elseOp.getType()) {
      if (NodeUtil.isAssignmentOp(thenOp)) {
        Node lhs=thenOp.getFirstChild();
        if (areNodesEqualForInlining(lhs,elseOp.getFirstChild()) && !NodeUtil.mayEffectMutableState(lhs)) {
          n.removeChild(cond);
          Node assignName=thenOp.removeFirstChild();
          Node thenExpr=thenOp.removeFirstChild();
          Node elseExpr=elseOp.getLastChild();
          elseOp.removeChild(elseExpr);
          Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
          Node assign=new Node(thenOp.getType(),assignName,hookNode).copyInformationFrom(thenOp);
          Node expr=NodeUtil.newExpr(assign);
          parent.replaceChild(n,expr);
          reportCodeChange();
          return expr;
        }
      }
 else       if (NodeUtil.isCall(thenOp)) {
        n.removeChild(cond);
        thenOp.detachFromParent();
        elseOp.detachFromParent();
        Node hookNode=new Node(Token.HOOK,cond,thenOp,elseOp).copyInformationFrom(n);
        Node expr=NodeUtil.newExpr(hookNode);
        parent.replaceChild(n,expr);
        reportCodeChange();
        return expr;
      }
    }
    return n;
  }
  boolean thenBranchIsVar=isVarBlock(thenBranch);
  boolean elseBranchIsVar=isVarBlock(elseBranch);
  if (thenBranchIsVar && elseBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {
    Node var=getBlockVar(thenBranch);
    Node elseAssign=getBlockExpression(elseBranch).getFirstChild();
    Node name1=var.getFirstChild();
    Node maybeName2=elseAssign.getFirstChild();
    if (name1.hasChildren() && maybeName2.getType() == Token.NAME && name1.getString().equals(maybeName2.getString())) {
      Node thenExpr=name1.removeChildren();
      Node elseExpr=elseAssign.getLastChild().detachFromParent();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name1.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
 else   if (elseBranchIsVar && thenBranchIsExpressionBlock && NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {
    Node var=getBlockVar(elseBranch);
    Node thenAssign=getBlockExpression(thenBranch).getFirstChild();
    Node maybeName1=thenAssign.getFirstChild();
    Node name2=var.getFirstChild();
    if (name2.hasChildren() && maybeName1.getType() == Token.NAME && maybeName1.getString().equals(name2.getString())) {
      Node thenExpr=thenAssign.getLastChild().detachFromParent();
      Node elseExpr=name2.removeChildren();
      cond.detachFromParent();
      Node hookNode=new Node(Token.HOOK,cond,thenExpr,elseExpr).copyInformationFrom(n);
      var.detachFromParent();
      name2.addChildrenToBack(hookNode);
      parent.replaceChild(n,var);
      reportCodeChange();
      return var;
    }
  }
  return n;
}"
18893,"/** 
 * Look at all the property assigns to all variables in the given scope. These may or may not count as references. For example, <code> var x = {}; x.foo = 3; // not a reference. var y = foo(); y.foo = 3; // is a reference. </code>
 */
private void interpretAssigns(Scope scope){
  for (Iterator<Var> it=scope.getVars(); it.hasNext(); ) {
    Var var=it.next();
    if (!referenced.contains(var)) {
      boolean assignedToUnknownValue=false;
      boolean hasPropertyAssign=false;
      if (var.getParentNode().getType() == Token.VAR) {
        Node value=var.getInitialValue();
        assignedToUnknownValue=value != null && !NodeUtil.isLiteralValue(value);
      }
 else {
        assignedToUnknownValue=true;
      }
      for (      Assign assign : assigns.get(var)) {
        if (assign.isPropertyAssign) {
          hasPropertyAssign=true;
        }
 else         if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild())) {
          assignedToUnknownValue=true;
        }
      }
      if (assignedToUnknownValue && hasPropertyAssign) {
        markReferencedVar(var);
      }
    }
  }
}","/** 
 * Look at all the property assigns to all variables in the given scope. These may or may not count as references. For example, <code> var x = {}; x.foo = 3; // not a reference. var y = foo(); y.foo = 3; // is a reference. </code>
 */
private void interpretAssigns(Scope scope){
  for (Iterator<Var> it=scope.getVars(); it.hasNext(); ) {
    Var var=it.next();
    if (!referenced.contains(var)) {
      boolean assignedToUnknownValue=false;
      boolean hasPropertyAssign=false;
      if (var.getParentNode().getType() == Token.VAR) {
        Node value=var.getInitialValue();
        assignedToUnknownValue=value != null && !NodeUtil.isLiteralValue(value,true);
      }
 else {
        assignedToUnknownValue=true;
      }
      for (      Assign assign : assigns.get(var)) {
        if (assign.isPropertyAssign) {
          hasPropertyAssign=true;
        }
 else         if (!NodeUtil.isLiteralValue(assign.assignNode.getLastChild(),true)) {
          assignedToUnknownValue=true;
        }
      }
      if (assignedToUnknownValue && hasPropertyAssign) {
        markReferencedVar(var);
      }
    }
  }
}"
18894,"public void assertNotLiteral(Node n){
  assertFalse(NodeUtil.isLiteralValue(n));
  assertFalse(NodeUtil.isImmutableValue(n));
}","public void assertNotLiteral(Node n){
  assertFalse(NodeUtil.isLiteralValue(n,true));
  assertFalse(NodeUtil.isLiteralValue(n,false));
  assertFalse(NodeUtil.isImmutableValue(n));
}"
18895,"public void assertLiteralButNotImmutable(Node n){
  assertTrue(NodeUtil.isLiteralValue(n));
  assertFalse(NodeUtil.isImmutableValue(n));
}","public void assertLiteralButNotImmutable(Node n){
  assertTrue(NodeUtil.isLiteralValue(n,true));
  assertTrue(NodeUtil.isLiteralValue(n,false));
  assertFalse(NodeUtil.isImmutableValue(n));
}"
18896,"public void testMayEffectMutableState(){
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
}","public void testMayEffectMutableState(){
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(false,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
  assertMutableState(true,""String_Node_Str"");
}"
18897,"public void assertLiteralAndImmutable(Node n){
  assertTrue(NodeUtil.isLiteralValue(n));
  assertTrue(NodeUtil.isImmutableValue(n));
}","public void assertLiteralAndImmutable(Node n){
  assertTrue(NodeUtil.isLiteralValue(n,true));
  assertTrue(NodeUtil.isLiteralValue(n,false));
  assertTrue(NodeUtil.isImmutableValue(n));
}"
18898,"public void testFoldTypeof(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
}","public void testFoldTypeof(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
}"
18899,"public void testFoldInstanceOf(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
}","public void testFoldInstanceOf(){
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  foldSame(""String_Node_Str"");
  fold(""String_Node_Str"",""String_Node_Str"");
}"
18900,"/** 
 * Returns a version of   {@code type} that is restricted by some knowledgeabout the result of the  {@code typeof} operation..<p> The behavior of the  {@code typeof} operator can be summarized by thefollowing table: <table> <tr><th>type</th><th>result</th></tr> <tr><td> {@code undefined}</td><td>""undefined""</td></tr> <tr><td>  {@code null}</td><td>""object""</td></tr> <tr><td>  {@code boolean}</td><td>""boolean""</td></tr> <tr><td>  {@code number}</td><td>""number""</td></tr> <tr><td>  {@code string}</td><td>""string""</td></tr> <tr><td>  {@code Object} (which doesn't implement [[Call]])</td><td>""object""</td></tr> <tr><td> {@code Object} (which implements [[Call]])</td><td>""function""</td></tr> </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the{@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is knownto equal  {@code value};   {@code false} if it is known <em>not</em> toequal  {@code value}
 * @return the restricted type or null if no version of the type matches therestriction
 */
JSType getRestrictedByTypeOfResult(JSType type,String value,boolean resultEqualsValue){
  return type == null ? null : type.visit(new RestrictByOneTypeOfResultVisitor(value,resultEqualsValue));
}","/** 
 * Returns a version of   {@code type} that is restricted by some knowledgeabout the result of the  {@code typeof} operation.<p> The behavior of the  {@code typeof} operator can be summarized by thefollowing table: <table> <tr><th>type</th><th>result</th></tr> <tr><td> {@code undefined}</td><td>""undefined""</td></tr> <tr><td>  {@code null}</td><td>""object""</td></tr> <tr><td>  {@code boolean}</td><td>""boolean""</td></tr> <tr><td>  {@code number}</td><td>""number""</td></tr> <tr><td>  {@code string}</td><td>""string""</td></tr> <tr><td>  {@code Object} (which doesn't implement [[Call]])</td><td>""object""</td></tr> <tr><td> {@code Object} (which implements [[Call]])</td><td>""function""</td></tr> </table>
 * @param type the type to restrict
 * @param value A value known to be equal or not equal to the result of the{@code typeof} operation
 * @param resultEqualsValue {@code true} if the {@code typeOf} result is knownto equal  {@code value};   {@code false} if it is known <em>not</em> toequal  {@code value}
 * @return the restricted type or null if no version of the type matches therestriction
 */
JSType getRestrictedByTypeOfResult(JSType type,String value,boolean resultEqualsValue){
  if (type == null) {
    if (resultEqualsValue) {
      JSType result=getNativeTypeForTypeOf(value);
      return result == null ? getNativeType(UNKNOWN_TYPE) : result;
    }
 else {
      return null;
    }
  }
  return type.visit(new RestrictByOneTypeOfResultVisitor(value,resultEqualsValue));
}"
18901,"/** 
 * Declares a refined type in   {@code scope} for the name represented by{@code node}. It must be possible to refine the type of the given node in the given scope, as determined by   {@link #getTypeIfRefinable}.
 */
protected void declareNameInScope(FlowScope scope,Node node,JSType type){
switch (node.getType()) {
case Token.NAME:
    scope.inferSlotType(node.getString(),type);
  break;
case Token.GETPROP:
String qualifiedName=node.getQualifiedName();
Preconditions.checkNotNull(qualifiedName);
JSType origType=node.getJSType();
origType=origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
scope.inferQualifiedSlot(qualifiedName,origType,type);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","/** 
 * Declares a refined type in   {@code scope} for the name represented by{@code node}. It must be possible to refine the type of the given node in the given scope, as determined by   {@link #getTypeIfRefinable}.
 */
protected void declareNameInScope(FlowScope scope,Node node,JSType type){
switch (node.getType()) {
case Token.NAME:
    scope.inferSlotType(node.getString(),type);
  break;
case Token.GETPROP:
String qualifiedName=node.getQualifiedName();
Preconditions.checkNotNull(qualifiedName);
JSType origType=node.getJSType();
origType=origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
scope.inferQualifiedSlot(qualifiedName,origType,type);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + node.toStringTree());
}
}"
18902,"@Override protected JSType caseTopType(JSType topType){
  if (resultEqualsValue) {
    if (value.equals(""String_Node_Str"")) {
      return getNativeType(NUMBER_TYPE);
    }
 else     if (value.equals(""String_Node_Str"")) {
      return getNativeType(BOOLEAN_TYPE);
    }
 else     if (value.equals(""String_Node_Str"")) {
      return getNativeType(STRING_TYPE);
    }
 else     if (value.equals(""String_Node_Str"")) {
      return getNativeType(VOID_TYPE);
    }
 else     if (value.equals(""String_Node_Str"")) {
      return getNativeType(U2U_CONSTRUCTOR_TYPE);
    }
  }
  return topType;
}","@Override protected JSType caseTopType(JSType topType){
  JSType result=topType;
  if (resultEqualsValue) {
    JSType typeByName=getNativeTypeForTypeOf(value);
    if (typeByName != null) {
      result=typeByName;
    }
  }
  return result;
}"
18903,"public JSType apply(TypeRestriction p){
  Visitor<JSType> visitor=p.outcome ? restrictToObjectVisitor : restrictToNotObjectVisitor;
  return p.type == null ? null : p.type.visit(visitor);
}","public JSType apply(TypeRestriction p){
  if (p.type == null) {
    return p.outcome ? getNativeType(OBJECT_TYPE) : null;
  }
  Visitor<JSType> visitor=p.outcome ? restrictToObjectVisitor : restrictToNotObjectVisitor;
  return p.type.visit(visitor);
}"
18904,"public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,FlowScope blindScope,boolean outcome){
  if (condition.getType() == CALL && condition.getChildCount() == 2) {
    Node callee=condition.getFirstChild();
    Node param=condition.getLastChild();
    if (callee.getType() == GETPROP) {
      JSType paramType=getTypeIfRefinable(param,blindScope);
      if (paramType != null) {
        Node left=callee.getFirstChild();
        Node right=callee.getLastChild();
        if (left.getType() == NAME && ""String_Node_Str"".equals(left.getString()) && right.getType() == STRING) {
          Function<TypeRestriction,JSType> restricter=restricters.get(right.getString());
          if (restricter != null) {
            return restrictParameter(param,paramType,blindScope,restricter,outcome);
          }
        }
      }
    }
  }
  return nextPreciserScopeKnowingConditionOutcome(condition,blindScope,outcome);
}","@Override public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,FlowScope blindScope,boolean outcome){
  if (condition.getType() == CALL && condition.getChildCount() == 2) {
    Node callee=condition.getFirstChild();
    Node param=condition.getLastChild();
    if (callee.getType() == GETPROP && param.isQualifiedName()) {
      JSType paramType=getTypeIfRefinable(param,blindScope);
      Node left=callee.getFirstChild();
      Node right=callee.getLastChild();
      if (left.getType() == NAME && ""String_Node_Str"".equals(left.getString()) && right.getType() == STRING) {
        Function<TypeRestriction,JSType> restricter=restricters.get(right.getString());
        if (restricter != null) {
          return restrictParameter(param,paramType,blindScope,restricter,outcome);
        }
      }
    }
  }
  return nextPreciserScopeKnowingConditionOutcome(condition,blindScope,outcome);
}"
18905,"/** 
 * Creates a   {@link ClosureReverseAbstractInterpreter}.
 */
ClosureReverseAbstractInterpreter(CodingConvention convention,final JSTypeRegistry typeRegistry){
  super(convention,typeRegistry);
  this.restricters=new ImmutableMap.Builder<String,Function<TypeRestriction,JSType>>().put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.outcome) {
        return getRestrictedWithoutUndefined(p.type);
      }
 else {
        return null;
      }
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.outcome) {
        return getNativeType(NULL_TYPE);
      }
 else {
        return getRestrictedWithoutNull(p.type);
      }
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.outcome) {
        return getRestrictedWithoutUndefined(getRestrictedWithoutNull(p.type));
      }
 else {
        return null;
      }
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      Visitor<JSType> visitor=p.outcome ? restrictToArrayVisitor : restrictToNotArrayVisitor;
      return p.type == null ? null : p.type.visit(visitor);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      Visitor<JSType> visitor=p.outcome ? restrictToObjectVisitor : restrictToNotObjectVisitor;
      return p.type == null ? null : p.type.visit(visitor);
    }
  }
).build();
}","/** 
 * Creates a   {@link ClosureReverseAbstractInterpreter}.
 */
ClosureReverseAbstractInterpreter(CodingConvention convention,final JSTypeRegistry typeRegistry){
  super(convention,typeRegistry);
  this.restricters=new ImmutableMap.Builder<String,Function<TypeRestriction,JSType>>().put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.outcome) {
        return getRestrictedWithoutUndefined(p.type);
      }
 else {
        return null;
      }
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.outcome) {
        return getNativeType(NULL_TYPE);
      }
 else {
        return getRestrictedWithoutNull(p.type);
      }
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.outcome) {
        return getRestrictedWithoutUndefined(getRestrictedWithoutNull(p.type));
      }
 else {
        return null;
      }
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      return getRestrictedByTypeOfResult(p.type,""String_Node_Str"",p.outcome);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.type == null) {
        return p.outcome ? getNativeType(ARRAY_TYPE) : null;
      }
      Visitor<JSType> visitor=p.outcome ? restrictToArrayVisitor : restrictToNotArrayVisitor;
      return p.type.visit(visitor);
    }
  }
).put(""String_Node_Str"",new Function<TypeRestriction,JSType>(){
    public JSType apply(    TypeRestriction p){
      if (p.type == null) {
        return p.outcome ? getNativeType(OBJECT_TYPE) : null;
      }
      Visitor<JSType> visitor=p.outcome ? restrictToObjectVisitor : restrictToNotObjectVisitor;
      return p.type.visit(visitor);
    }
  }
).build();
}"
18906,"private FlowScope traverseName(Node n,FlowScope scope){
  String varName=n.getString();
  Node value=n.getFirstChild();
  JSType type=n.getJSType();
  if (value != null) {
    scope=traverse(value,scope);
    updateScopeForTypeChange(scope,n,n.getJSType(),getJSType(value));
    return scope;
  }
 else {
    StaticSlot<JSType> var=scope.getSlot(varName);
    if (var != null && !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {
      type=var.getType();
      if (type == null) {
        type=getNativeType(UNKNOWN_TYPE);
      }
    }
  }
  n.setJSType(type);
  return scope;
}","private FlowScope traverseName(Node n,FlowScope scope){
  String varName=n.getString();
  Node value=n.getFirstChild();
  JSType type=n.getJSType();
  if (value != null) {
    scope=traverse(value,scope);
    updateScopeForTypeChange(scope,n,n.getJSType(),getJSType(value));
    return scope;
  }
 else {
    StaticSlot<JSType> var=scope.getSlot(varName);
    if (var != null) {
      boolean isInferred=var.isTypeInferred();
      boolean unflowable=isInferred && unflowableVarNames.contains(varName);
      boolean nonLocalInferredSlot=isInferred && syntacticScope.getParent() != null && var == syntacticScope.getParent().getSlot(varName);
      if (!unflowable && !nonLocalInferredSlot) {
        type=var.getType();
        if (type == null) {
          type=getNativeType(UNKNOWN_TYPE);
        }
      }
    }
  }
  n.setJSType(type);
  return scope;
}"
18907,"private List<JspcWorker> initJspcWorkers(StringBuilder classpathStr,String[] jspFiles,List<String> jspFilesList) throws JasperException, IOException {
  List<JspcWorker> workers=new ArrayList<>();
  int minItem=jspFiles.length / threads;
  int maxItem=minItem + 1;
  int threadsWithMaxItems=jspFiles.length - threads * minItem;
  int start=0;
  JspCContextAccessor topJspC=initJspc(classpathStr,-1,null);
  for (int index=0; index < threads; index++) {
    int itemsCount=(index < threadsWithMaxItems ? maxItem : minItem);
    int end=start + itemsCount;
    List<String> jspFilesSubList=jspFilesList.subList(start,end);
    JspC firstJspC=initJspc(classpathStr,index,topJspC);
    JspcWorker worker=new JspcWorker(firstJspC,jspFilesSubList);
    workers.add(worker);
    start=end;
    getLog().info(""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ jspFilesSubList.size());
  }
  return workers;
}","private List<JspcWorker> initJspcWorkers(StringBuilder classpathStr,String[] jspFiles,List<String> jspFilesList) throws JasperException, IOException {
  List<JspcWorker> workers=new ArrayList<>();
  int minItem=jspFiles.length / threads;
  int maxItem=minItem + 1;
  int threadsWithMaxItems=jspFiles.length - threads * minItem;
  int start=0;
  JspCContextAccessor topJspC=initJspc(classpathStr,-1,null);
  for (int index=0; index < threads; index++) {
    int threadNumber=index + 1;
    int itemsCount=(index < threadsWithMaxItems ? maxItem : minItem);
    int end=start + itemsCount;
    List<String> jspFilesSubList=jspFilesList.subList(start,end);
    if (jspFilesSubList.isEmpty()) {
      getLog().info(""String_Node_Str"" + threadNumber + ""String_Node_Str"");
    }
 else {
      JspC firstJspC=initJspc(classpathStr,index,topJspC);
      JspcWorker worker=new JspcWorker(firstJspC,jspFilesSubList);
      workers.add(worker);
      start=end;
      getLog().info(""String_Node_Str"" + threadNumber + ""String_Node_Str""+ jspFilesSubList.size());
    }
  }
  return workers;
}"
18908,"private JspCContextAccessor initJspc(StringBuilder classpathStr,int threadIndex,JspCContextAccessor topJspC) throws IOException, JasperException {
  JspCContextAccessor jspc=new JspCContextAccessor();
  jspc.setWebXmlFragment(getwebXmlFragmentFilename(threadIndex));
  jspc.setUriroot(webAppSourceDirectory);
  jspc.setPackage(packageRoot);
  jspc.setOutputDir(generatedClasses);
  jspc.setValidateXml(validateXml);
  jspc.setClassPath(classpathStr.toString());
  jspc.setCompile(true);
  jspc.setSmapSuppressed(suppressSmap);
  jspc.setSmapDumped(!suppressSmap);
  jspc.setJavaEncoding(javaEncoding);
  jspc.setFailOnError(stopAtFirstError);
  jspc.setPoolingEnabled(enableJspTagPooling);
  jspc.setTrimSpaces(trimSpaces);
  jspc.setGenStringAsCharArray(genStringAsCharArray);
  jspc.setCompilerSourceVM(compilerVersion);
  jspc.setCompilerTargetVM(compilerVersion);
  jspc.setcompilerClass(compilerClass);
  jspc.setResourcesCache(resourcesCache);
  if (topJspC == null) {
    jspc.initClassLoader();
    jspc.initServletContext();
  }
 else {
    jspc.initContext(topJspC);
  }
  getLog().info(""String_Node_Str"" + StringUtils.join(includes,""String_Node_Str""));
  if (excludes != null) {
    getLog().info(""String_Node_Str"" + StringUtils.join(excludes,""String_Node_Str""));
  }
  if (verbose) {
    jspc.setVerbose(99);
  }
 else {
    jspc.setVerbose(0);
  }
  return jspc;
}","private JspCContextAccessor initJspc(StringBuilder classpathStr,int threadIndex,JspCContextAccessor topJspC) throws IOException, JasperException {
  JspCContextAccessor jspc=new JspCContextAccessor();
  jspc.setWebXmlFragment(getwebXmlFragmentFilename(threadIndex));
  jspc.setUriroot(webAppSourceDirectory);
  jspc.setPackage(packageRoot);
  jspc.setOutputDir(generatedClasses);
  jspc.setValidateXml(validateXml);
  jspc.setClassPath(classpathStr.toString());
  jspc.setCompile(true);
  jspc.setSmapSuppressed(suppressSmap);
  jspc.setSmapDumped(!suppressSmap);
  jspc.setJavaEncoding(javaEncoding);
  jspc.setFailOnError(stopAtFirstError);
  jspc.setPoolingEnabled(enableJspTagPooling);
  jspc.setTrimSpaces(trimSpaces);
  jspc.setGenStringAsCharArray(genStringAsCharArray);
  jspc.setCompilerSourceVM(compilerVersion);
  jspc.setCompilerTargetVM(compilerVersion);
  jspc.setcompilerClass(compilerClass);
  jspc.setResourcesCache(resourcesCache);
  if (topJspC == null) {
    jspc.initClassLoader();
    jspc.initServletContext();
  }
 else {
    jspc.initContext(topJspC);
  }
  if (topJspC != null) {
    getLog().info(""String_Node_Str"" + StringUtils.join(includes,""String_Node_Str""));
    if (excludes != null) {
      getLog().info(""String_Node_Str"" + StringUtils.join(excludes,""String_Node_Str""));
    }
  }
  if (verbose) {
    jspc.setVerbose(99);
  }
 else {
    jspc.setVerbose(0);
  }
  return jspc;
}"
18909,"/** 
 * Set up the execution classpath for Jasper. <p> Put everything in the classesDirectory and all of the dependencies on the classpath.
 * @param urls a list to which to add the urls of the dependencies
 * @throws IOException
 */
private void setUpClassPath(List<URL> urls) throws IOException {
  String classesDir=classesDirectory.getCanonicalPath();
  classesDir=classesDir + (classesDir.endsWith(File.pathSeparator) ? ""String_Node_Str"" : File.separator);
  urls.add(new File(classesDir).toURI().toURL());
  if (getLog().isDebugEnabled()) {
    getLog().debug(""String_Node_Str"" + classesDir);
  }
  for (Iterator<?> iter=project.getArtifacts().iterator(); iter.hasNext(); ) {
    Artifact artifact=(Artifact)iter.next();
    if (!Artifact.SCOPE_TEST.equals(artifact.getScope())) {
      String filePath=artifact.getFile().getCanonicalPath();
      if (getLog().isDebugEnabled()) {
        getLog().debug(""String_Node_Str"" + filePath);
      }
      urls.add(artifact.getFile().toURI().toURL());
    }
  }
}","/** 
 * Set up the execution classpath for Jasper. <p> Put everything in the classesDirectory and all of the dependencies on the classpath.
 * @param urls a list to which to add the urls of the dependencies
 * @throws IOException
 */
private void setUpClassPath(List<URL> urls) throws IOException {
  String classesDir=classesDirectory.getCanonicalPath();
  classesDir=classesDir + (classesDir.endsWith(File.pathSeparator) ? ""String_Node_Str"" : File.separator);
  urls.add(new File(classesDir).toURL());
  if (getLog().isDebugEnabled()) {
    getLog().debug(""String_Node_Str"" + classesDir);
  }
  for (Iterator<?> iter=project.getArtifacts().iterator(); iter.hasNext(); ) {
    Artifact artifact=(Artifact)iter.next();
    if (!Artifact.SCOPE_TEST.equals(artifact.getScope())) {
      String filePath=artifact.getFile().getCanonicalPath();
      if (getLog().isDebugEnabled()) {
        getLog().debug(""String_Node_Str"" + filePath);
      }
      urls.add(artifact.getFile().toURL());
    }
  }
}"
18910,"private List<JspcWorker> initJspcWorkers(StringBuilder classpathStr,String[] jspFiles,List<String> jspFilesList){
  List<JspcWorker> workers=new ArrayList<>();
  int minItem=jspFiles.length / threads;
  int maxItem=minItem + 1;
  int threadsWithMaxItems=jspFiles.length - threads * minItem;
  int start=0;
  for (int index=0; index < threads; index++) {
    int itemsCount=(index < threadsWithMaxItems ? maxItem : minItem);
    int end=start + itemsCount;
    List<String> jspFilesSubList=jspFilesList.subList(start,end);
    JspcWorker worker=new JspcWorker(initJspc(classpathStr,index),jspFilesSubList);
    workers.add(worker);
    start=end;
    getLog().info(""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ jspFilesSubList.size());
  }
  return workers;
}","private List<JspcWorker> initJspcWorkers(StringBuilder classpathStr,String[] jspFiles,List<String> jspFilesList) throws JasperException, IOException {
  List<JspcWorker> workers=new ArrayList<>();
  int minItem=jspFiles.length / threads;
  int maxItem=minItem + 1;
  int threadsWithMaxItems=jspFiles.length - threads * minItem;
  int start=0;
  JspCContextAccessor topJspC=initJspc(classpathStr,-1,null);
  for (int index=0; index < threads; index++) {
    int itemsCount=(index < threadsWithMaxItems ? maxItem : minItem);
    int end=start + itemsCount;
    List<String> jspFilesSubList=jspFilesList.subList(start,end);
    JspC firstJspC=initJspc(classpathStr,index,topJspC);
    JspcWorker worker=new JspcWorker(firstJspC,jspFilesSubList);
    workers.add(worker);
    start=end;
    getLog().info(""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ jspFilesSubList.size());
  }
  return workers;
}"
18911,"private JspC initJspc(StringBuilder classpathStr,int threadIndex){
  JspC jspc=new JspC();
  jspc.setWebXmlFragment(getwebXmlFragmentFilename(threadIndex));
  jspc.setUriroot(webAppSourceDirectory);
  jspc.setPackage(packageRoot);
  jspc.setOutputDir(generatedClasses);
  jspc.setValidateXml(validateXml);
  jspc.setClassPath(classpathStr.toString());
  jspc.setCompile(true);
  jspc.setSmapSuppressed(suppressSmap);
  jspc.setSmapDumped(!suppressSmap);
  jspc.setJavaEncoding(javaEncoding);
  jspc.setFailOnError(stopAtFirstError);
  jspc.setPoolingEnabled(enableJspTagPooling);
  jspc.setTrimSpaces(trimSpaces);
  jspc.setGenStringAsCharArray(genStringAsCharArray);
  jspc.setCompilerSourceVM(compilerVersion);
  jspc.setCompilerTargetVM(compilerVersion);
  getLog().info(""String_Node_Str"" + StringUtils.join(includes,""String_Node_Str""));
  if (excludes != null) {
    getLog().info(""String_Node_Str"" + StringUtils.join(excludes,""String_Node_Str""));
  }
  if (verbose) {
    jspc.setVerbose(99);
  }
 else {
    jspc.setVerbose(0);
  }
  return jspc;
}","private JspCContextAccessor initJspc(StringBuilder classpathStr,int threadIndex,JspCContextAccessor topJspC) throws IOException, JasperException {
  JspCContextAccessor jspc=new JspCContextAccessor();
  jspc.setWebXmlFragment(getwebXmlFragmentFilename(threadIndex));
  jspc.setUriroot(webAppSourceDirectory);
  jspc.setPackage(packageRoot);
  jspc.setOutputDir(generatedClasses);
  jspc.setValidateXml(validateXml);
  jspc.setClassPath(classpathStr.toString());
  jspc.setCompile(true);
  jspc.setSmapSuppressed(suppressSmap);
  jspc.setSmapDumped(!suppressSmap);
  jspc.setJavaEncoding(javaEncoding);
  jspc.setFailOnError(stopAtFirstError);
  jspc.setPoolingEnabled(enableJspTagPooling);
  jspc.setTrimSpaces(trimSpaces);
  jspc.setGenStringAsCharArray(genStringAsCharArray);
  jspc.setCompilerSourceVM(compilerVersion);
  jspc.setCompilerTargetVM(compilerVersion);
  if (topJspC == null) {
    jspc.initClassLoader();
    jspc.initServletContext();
  }
 else {
    jspc.setContext(topJspC.getContext());
  }
  getLog().info(""String_Node_Str"" + StringUtils.join(includes,""String_Node_Str""));
  if (excludes != null) {
    getLog().info(""String_Node_Str"" + StringUtils.join(excludes,""String_Node_Str""));
  }
  if (verbose) {
    jspc.setVerbose(99);
  }
 else {
    jspc.setVerbose(0);
  }
  return jspc;
}"
18912,"@Test public void should_return_webfrag_equal_to_reference_when_executeMojo_on_project_one_jsp_with_no_options() throws Exception {
  File oneJspProject=new File(""String_Node_Str"");
  Path expectedWebfrag=Paths.get(""String_Node_Str"");
  rule.executeMojo(oneJspProject,""String_Node_Str"");
  Path webfrag=Paths.get(""String_Node_Str"");
  assertThat(Files.readAllBytes(webfrag)).isEqualTo(Files.readAllBytes(expectedWebfrag));
}","@Test public void should_return_webfrag_equal_to_reference_when_executeMojo_on_project_one_jsp_with_no_options() throws Exception {
  File oneJspProject=new File(""String_Node_Str"");
  Path expectedWebfrag=Paths.get(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  rule.executeMojo(oneJspProject,""String_Node_Str"");
  Path webfrag=Paths.get(""String_Node_Str"");
  byte[] actualWebfrag=Files.readAllBytes(webfrag);
  byte[] expectedWebFrag=Files.readAllBytes(expectedWebfrag);
  String actualWebFragStr=new String(actualWebfrag).replaceAll(""String_Node_Str"",""String_Node_Str"");
  String expectedWebFragStr=new String(expectedWebFrag);
  assertThat(actualWebFragStr).isEqualTo(expectedWebFragStr);
}"
18913,"private List<JspcWorker> initJspcWorkers(StringBuilder classpathStr,String[] jspFiles,List<String> jspFilesList){
  List<JspcWorker> workers=new ArrayList<>();
  int minItem=jspFiles.length / threads;
  int maxItem=minItem + 1;
  int threadsWithMaxItems=jspFiles.length - threads * minItem;
  int start=0;
  for (int index=0; index < threads; index++) {
    int itemsCount=(index < threadsWithMaxItems ? maxItem : minItem);
    int end=start + itemsCount;
    List<String> jspFilesSubList=jspFilesList.subList(start,end);
    JspcWorker worker=new JspcWorker(initJspc(classpathStr,index),jspFilesSubList);
    workers.add(worker);
    start=end;
    getLog().info(""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ jspFilesSubList.size());
  }
  return workers;
}","private List<JspcWorker> initJspcWorkers(StringBuilder classpathStr,String[] jspFiles,List<String> jspFilesList) throws JasperException, IOException {
  List<JspcWorker> workers=new ArrayList<>();
  int minItem=jspFiles.length / threads;
  int maxItem=minItem + 1;
  int threadsWithMaxItems=jspFiles.length - threads * minItem;
  int start=0;
  JspCContextAccessor topJspC=initJspc(classpathStr,-1,null);
  for (int index=0; index < threads; index++) {
    int itemsCount=(index < threadsWithMaxItems ? maxItem : minItem);
    int end=start + itemsCount;
    List<String> jspFilesSubList=jspFilesList.subList(start,end);
    JspC firstJspC=initJspc(classpathStr,index,topJspC);
    JspcWorker worker=new JspcWorker(firstJspC,jspFilesSubList);
    workers.add(worker);
    start=end;
    getLog().info(""String_Node_Str"" + (index + 1) + ""String_Node_Str""+ jspFilesSubList.size());
  }
  return workers;
}"
18914,"private JspC initJspc(StringBuilder classpathStr,int threadIndex){
  JspC jspc=new JspC();
  jspc.setWebXmlFragment(getwebXmlFragmentFilename(threadIndex));
  jspc.setUriroot(webAppSourceDirectory);
  jspc.setPackage(packageRoot);
  jspc.setOutputDir(generatedClasses);
  jspc.setValidateXml(validateXml);
  jspc.setClassPath(classpathStr.toString());
  jspc.setCompile(true);
  jspc.setSmapSuppressed(suppressSmap);
  jspc.setSmapDumped(!suppressSmap);
  jspc.setJavaEncoding(javaEncoding);
  jspc.setFailOnError(stopAtFirstError);
  jspc.setPoolingEnabled(enableJspTagPooling);
  jspc.setTrimSpaces(trimSpaces);
  jspc.setGenStringAsCharArray(genStringAsCharArray);
  jspc.setCompilerSourceVM(compilerVersion);
  jspc.setCompilerTargetVM(compilerVersion);
  getLog().info(""String_Node_Str"" + StringUtils.join(includes,""String_Node_Str""));
  if (excludes != null) {
    getLog().info(""String_Node_Str"" + StringUtils.join(excludes,""String_Node_Str""));
  }
  if (verbose) {
    jspc.setVerbose(99);
  }
 else {
    jspc.setVerbose(0);
  }
  return jspc;
}","private JspCContextAccessor initJspc(StringBuilder classpathStr,int threadIndex,JspCContextAccessor topJspC) throws IOException, JasperException {
  JspCContextAccessor jspc=new JspCContextAccessor();
  jspc.setWebXmlFragment(getwebXmlFragmentFilename(threadIndex));
  jspc.setUriroot(webAppSourceDirectory);
  jspc.setPackage(packageRoot);
  jspc.setOutputDir(generatedClasses);
  jspc.setValidateXml(validateXml);
  jspc.setClassPath(classpathStr.toString());
  jspc.setCompile(true);
  jspc.setSmapSuppressed(suppressSmap);
  jspc.setSmapDumped(!suppressSmap);
  jspc.setJavaEncoding(javaEncoding);
  jspc.setFailOnError(stopAtFirstError);
  jspc.setPoolingEnabled(enableJspTagPooling);
  jspc.setTrimSpaces(trimSpaces);
  jspc.setGenStringAsCharArray(genStringAsCharArray);
  jspc.setCompilerSourceVM(compilerVersion);
  jspc.setCompilerTargetVM(compilerVersion);
  if (topJspC == null) {
    jspc.initClassLoader();
    jspc.initServletContext();
  }
 else {
    jspc.initContext(topJspC);
  }
  getLog().info(""String_Node_Str"" + StringUtils.join(includes,""String_Node_Str""));
  if (excludes != null) {
    getLog().info(""String_Node_Str"" + StringUtils.join(excludes,""String_Node_Str""));
  }
  if (verbose) {
    jspc.setVerbose(99);
  }
 else {
    jspc.setVerbose(0);
  }
  return jspc;
}"
18915,"@Test public void should_return_webfrag_equal_to_reference_when_executeMojo_on_project_one_jsp_with_no_options() throws Exception {
  File oneJspProject=new File(""String_Node_Str"");
  Path expectedWebfrag=Paths.get(""String_Node_Str"");
  rule.executeMojo(oneJspProject,""String_Node_Str"");
  Path webfrag=Paths.get(""String_Node_Str"");
  assertThat(Files.readAllBytes(webfrag)).isEqualTo(Files.readAllBytes(expectedWebfrag));
}","@Test public void should_return_webfrag_equal_to_reference_when_executeMojo_on_project_one_jsp_with_no_options() throws Exception {
  File oneJspProject=new File(""String_Node_Str"");
  Path expectedWebfrag=Paths.get(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  rule.executeMojo(oneJspProject,""String_Node_Str"");
  Path webfrag=Paths.get(""String_Node_Str"");
  byte[] actualWebfrag=Files.readAllBytes(webfrag);
  byte[] expectedWebFrag=Files.readAllBytes(expectedWebfrag);
  String actualWebFragStr=new String(actualWebfrag).replaceAll(""String_Node_Str"",""String_Node_Str"");
  String expectedWebFragStr=new String(expectedWebFrag);
  assertThat(actualWebFragStr).isEqualTo(expectedWebFragStr);
}"
18916,"public static ChefService findOrCreateChefService(String api,String name,String clientName,String clientCredential,String clientKeyFile,String validatorName,String validatorCredential,String validatorKeyFile,String endpoint,List<ChefService> chefServices){
  if ((name == null && api == null) && (chefServices != null && chefServices.size() == 1)) {
    return chefServices.get(0);
  }
  ChefService chefService=null;
  String apiValue=ChefHelper.getChefApi(api);
  String clientNameValue=ChefHelper.getClientName(clientName);
  String clientCredentialValue=ChefHelper.getClientCredential(clientCredential);
  String clientKeyFileValue=ChefHelper.getClientName(clientKeyFile);
  String validatorNameValue=ChefHelper.getClientName(validatorName);
  String validatorCredentialValue=ChefHelper.getValidatorCredential(validatorCredential);
  String validatorKeyFileValue=ChefHelper.getClientName(validatorKeyFile);
  String endpointValue=ChefHelper.getChefEndpoint(endpoint);
  boolean contextNameProvided=!Strings.isNullOrEmpty(name);
  boolean canCreateService=(!Strings.isNullOrEmpty(clientNameValue) || !Strings.isNullOrEmpty(clientKeyFileValue)) && !Strings.isNullOrEmpty(validatorNameValue) && !Strings.isNullOrEmpty(validatorKeyFileValue);
  apiValue=!Strings.isNullOrEmpty(apiValue) ? apiValue : ""String_Node_Str"";
  try {
    chefService=ChefHelper.getChefService(name,apiValue,chefServices);
  }
 catch (  Throwable t) {
    if (contextNameProvided) {
      throw new RuntimeException(""String_Node_Str"" + name);
    }
 else     if (!canCreateService) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"").append(""String_Node_Str"");
      if (apiValue == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (clientNameValue == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (clientKeyFileValue == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (validatorName == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (validatorKeyFile == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      throw new RuntimeException(sb.toString());
    }
  }
  if (chefService == null && canCreateService) {
    try {
      chefService=ChefHelper.createChefService(Apis.withId(apiValue),name,clientNameValue,clientCredentialValue,clientKeyFile,validatorNameValue,validatorCredentialValue,validatorKeyFileValue,endpointValue);
    }
 catch (    Exception ex) {
      throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
    }
  }
  return chefService;
}","public static ChefService findOrCreateChefService(String api,String name,String clientName,String clientCredential,String clientKeyFile,String validatorName,String validatorCredential,String validatorKeyFile,String endpoint,List<ChefService> chefServices){
  if ((name == null && api == null) && (chefServices != null && chefServices.size() == 1)) {
    return chefServices.get(0);
  }
  ChefService chefService=null;
  String apiValue=ChefHelper.getChefApi(api);
  String clientNameValue=ChefHelper.getClientName(clientName);
  String clientCredentialValue=ChefHelper.getClientCredential(clientCredential);
  String clientKeyFileValue=ChefHelper.getClientKeyFile(clientKeyFile);
  String validatorNameValue=ChefHelper.getValidatorName(validatorName);
  String validatorCredentialValue=ChefHelper.getValidatorCredential(validatorCredential);
  String validatorKeyFileValue=ChefHelper.getValidatorKeyFile(validatorKeyFile);
  String endpointValue=ChefHelper.getChefEndpoint(endpoint);
  boolean contextNameProvided=!Strings.isNullOrEmpty(name);
  boolean canCreateService=(!Strings.isNullOrEmpty(clientNameValue) || !Strings.isNullOrEmpty(clientKeyFileValue)) && !Strings.isNullOrEmpty(validatorNameValue) && !Strings.isNullOrEmpty(validatorKeyFileValue);
  apiValue=!Strings.isNullOrEmpty(apiValue) ? apiValue : ""String_Node_Str"";
  name=!Strings.isNullOrEmpty(name) ? name : apiValue;
  try {
    chefService=ChefHelper.getChefService(name,apiValue,chefServices);
  }
 catch (  Throwable t) {
    if (contextNameProvided) {
      throw new RuntimeException(""String_Node_Str"" + name);
    }
 else     if (!canCreateService) {
      StringBuilder sb=new StringBuilder();
      sb.append(""String_Node_Str"").append(""String_Node_Str"");
      if (apiValue == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (clientNameValue == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (clientKeyFileValue == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (validatorName == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      if (validatorKeyFile == null) {
        sb.append(""String_Node_Str"").append(""String_Node_Str"");
      }
      throw new RuntimeException(sb.toString());
    }
  }
  if (chefService == null && canCreateService) {
    try {
      chefService=ChefHelper.createChefService(Apis.withId(apiValue),name,clientNameValue,clientCredentialValue,clientKeyFileValue,validatorNameValue,validatorCredentialValue,validatorKeyFileValue,endpointValue);
    }
 catch (    Exception ex) {
      throw new RuntimeException(""String_Node_Str"" + ex.getMessage());
    }
  }
  return chefService;
}"
18917,"protected void printImages(Set<? extends Image> images,String indent,PrintStream out){
  out.println(String.format(IMAGEFORMAT,indent,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  Image image : images) {
    String id=image.getId();
    String location=image.getLocation() != null ? image.getLocation().getId() : ""String_Node_Str"";
    String description=image.getDescription();
    out.println(String.format(IMAGEFORMAT,indent,id,location,description));
    cacheProvider.getProviderCacheForType(""String_Node_Str"").put(image.getProviderId(),image.getId());
  }
}","protected void printImages(Set<? extends Image> images,String indent,PrintStream out){
  out.println(String.format(IMAGEFORMAT,indent,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  Image image : images) {
    String id=image.getId();
    String location=image.getLocation() != null ? image.getLocation().getId() : ""String_Node_Str"";
    String description=image.getDescription();
    out.println(String.format(IMAGEFORMAT,indent,id,location,description));
    cacheProvider.getProviderCacheForType(Constants.IMAGE_CACHE).put(image.getProviderId(),image.getId());
  }
}"
18918,"protected void printNodes(Set<? extends ComputeMetadata> nodes,String indent,PrintStream out){
  out.println(String.format(NODEFORMAT,indent,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  ComputeMetadata metadata : nodes) {
    NodeMetadata node=(NodeMetadata)metadata;
    out.println(String.format(NODEFORMAT,indent,node.getId(),node.getLocation().getId(),node.getHardware().getId(),node.getGroup(),node.getState().toString().toLowerCase()));
    cacheProvider.getProviderCacheForType(""String_Node_Str"").put(node.getProviderId(),node.getId());
    cacheProvider.getProviderCacheForType(""String_Node_Str"").put(node.getProviderId(),node.getGroup());
  }
}","protected void printNodes(Set<? extends ComputeMetadata> nodes,String indent,PrintStream out){
  out.println(String.format(NODEFORMAT,indent,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  ComputeMetadata metadata : nodes) {
    NodeMetadata node=(NodeMetadata)metadata;
    out.println(String.format(NODEFORMAT,indent,node.getId(),node.getLocation().getId(),node.getHardware().getId(),node.getGroup(),node.getState().toString().toLowerCase()));
    cacheProvider.getProviderCacheForType(Constants.GROUP).put(node.getProviderId(),node.getGroup());
  }
}"
18919,"protected Set<? extends Location> getAllLocations(ComputeService computeService){
  Set<Location> all=new HashSet<Location>();
  for (  Location loc : computeService.listAssignableLocations()) {
    for (Location p=loc; p != null; p=p.getParent()) {
      all.add(p);
      cacheProvider.getProviderCacheForType(""String_Node_Str"").put(computeService.getContext().getProviderSpecificContext().getId(),p.getId());
    }
  }
  return all;
}","protected Set<? extends Location> getAllLocations(ComputeService computeService){
  Set<Location> all=new HashSet<Location>();
  for (  Location loc : computeService.listAssignableLocations()) {
    for (Location p=loc; p != null; p=p.getParent()) {
      all.add(p);
      cacheProvider.getProviderCacheForType(Constants.LOCATION_CACHE).put(computeService.getContext().getProviderSpecificContext().getId(),p.getId());
    }
  }
  return all;
}"
18920,"protected void printHardwares(Set<? extends Hardware> hardwares,String indent,PrintStream out){
  out.println(String.format(HARDWAREFORMAT,indent,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  Hardware hardware : hardwares) {
    out.println(String.format(HARDWAREFORMAT,indent,hardware.getId(),getCpuUnits(hardware),getCpuCores(hardware),getMemory(hardware)));
  }
}","protected void printHardwares(Set<? extends Hardware> hardwares,String indent,PrintStream out){
  out.println(String.format(HARDWAREFORMAT,indent,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  for (  Hardware hardware : hardwares) {
    out.println(String.format(HARDWAREFORMAT,indent,hardware.getId(),getCpuUnits(hardware),getCpuCores(hardware),getMemory(hardware)));
    cacheProvider.getProviderCacheForType(Constants.HARDWARE_CACHE).put(hardware.getProviderId(),hardware.getId());
  }
}"
18921,"@Override protected Object doExecute() throws Exception {
  Set<? extends NodeMetadata> nodeMetadatas=getComputeService().destroyNodesMatching(new Predicate<NodeMetadata>(){
    @Override public boolean apply(    @Nullable NodeMetadata input){
      return input.getGroup().contains(group);
    }
  }
);
  if (nodeMetadatas != null && !nodeMetadatas.isEmpty()) {
    System.out.println(""String_Node_Str"");
    printNodes(nodeMetadatas,""String_Node_Str"",System.out);
  }
  return null;
}","@Override protected Object doExecute() throws Exception {
  Set<? extends NodeMetadata> nodeMetadatas=getComputeService().destroyNodesMatching(new Predicate<NodeMetadata>(){
    @Override public boolean apply(    @Nullable NodeMetadata input){
      return input.getGroup().contains(group);
    }
  }
);
  if (nodeMetadatas != null && !nodeMetadatas.isEmpty()) {
    System.out.println(""String_Node_Str"");
    printNodes(nodeMetadatas,""String_Node_Str"",System.out);
  }
  for (  NodeMetadata node : nodeMetadatas) {
    cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
    cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
    cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
  }
  return null;
}"
18922,"@Override protected Object doExecute() throws Exception {
  ComputeService service=getComputeService();
  TemplateBuilder builder=service.templateBuilder();
  builder.any();
  if (smallest) {
    builder.smallest();
  }
  if (fastest) {
    builder.fastest();
  }
  if (biggest) {
    builder.biggest();
  }
  if (locationId != null) {
    builder.locationId(locationId);
  }
  if (imageId != null) {
    builder.imageId(imageId);
  }
  if (hardwareId != null) {
    builder.hardwareId(hardwareId);
  }
  if (osFamily != null) {
    builder.osFamily(OsFamily.fromValue(osFamily));
  }
  if (osVersion != null) {
    builder.osVersionMatches(osVersion);
  }
  TemplateOptions options=service.templateOptions();
  if (adminAccess) {
    options.runScript(AdminAccess.standard());
  }
  if (ec2SecurityGroups != null) {
    options.as(EC2TemplateOptions.class).securityGroups(ec2SecurityGroups);
  }
  if (ec2KeyPair != null) {
    options.as(EC2TemplateOptions.class).keyPair(ec2KeyPair);
  }
  if (ec2NoKeyPair != null) {
    options.as(EC2TemplateOptions.class).noKeyPair();
  }
  Set<? extends NodeMetadata> metadatas=null;
  try {
    metadatas=service.createNodesInGroup(group,number,builder.options(options).build());
  }
 catch (  RunNodesException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
  if (metadatas != null && !metadatas.isEmpty()) {
    System.out.println(""String_Node_Str"");
    printNodes(metadatas,""String_Node_Str"",System.out);
  }
  return null;
}","@Override protected Object doExecute() throws Exception {
  ComputeService service=getComputeService();
  TemplateBuilder builder=service.templateBuilder();
  builder.any();
  if (smallest) {
    builder.smallest();
  }
  if (fastest) {
    builder.fastest();
  }
  if (biggest) {
    builder.biggest();
  }
  if (locationId != null) {
    builder.locationId(locationId);
  }
  if (imageId != null) {
    builder.imageId(imageId);
  }
  if (hardwareId != null) {
    builder.hardwareId(hardwareId);
  }
  if (osFamily != null) {
    builder.osFamily(OsFamily.fromValue(osFamily));
  }
  if (osVersion != null) {
    builder.osVersionMatches(osVersion);
  }
  TemplateOptions options=service.templateOptions();
  if (adminAccess) {
    options.runScript(AdminAccess.standard());
  }
  if (ec2SecurityGroups != null) {
    options.as(EC2TemplateOptions.class).securityGroups(ec2SecurityGroups);
  }
  if (ec2KeyPair != null) {
    options.as(EC2TemplateOptions.class).keyPair(ec2KeyPair);
  }
  if (ec2NoKeyPair != null) {
    options.as(EC2TemplateOptions.class).noKeyPair();
  }
  Set<? extends NodeMetadata> metadatas=null;
  try {
    metadatas=service.createNodesInGroup(group,number,builder.options(options).build());
  }
 catch (  RunNodesException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
  if (metadatas != null && !metadatas.isEmpty()) {
    System.out.println(""String_Node_Str"");
    printNodes(metadatas,""String_Node_Str"",System.out);
  }
  for (  NodeMetadata node : metadatas) {
    cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).put(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
    cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).put(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
    cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).put(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
  }
  return null;
}"
18923,"@Override protected Object doExecute() throws Exception {
  Set<? extends NodeMetadata> nodeMetadatas=getComputeService().destroyNodesMatching(new Predicate<NodeMetadata>(){
    @Override public boolean apply(    @Nullable NodeMetadata input){
      return true;
    }
  }
);
  if (nodeMetadatas != null && !nodeMetadatas.isEmpty()) {
    System.out.println(""String_Node_Str"");
    printNodes(nodeMetadatas,""String_Node_Str"",System.out);
  }
  return null;
}","@Override protected Object doExecute() throws Exception {
  Set<? extends NodeMetadata> nodeMetadatas=getComputeService().destroyNodesMatching(new Predicate<NodeMetadata>(){
    @Override public boolean apply(    @Nullable NodeMetadata input){
      return true;
    }
  }
);
  if (nodeMetadatas != null && !nodeMetadatas.isEmpty()) {
    System.out.println(""String_Node_Str"");
    printNodes(nodeMetadatas,""String_Node_Str"",System.out);
  }
  for (  NodeMetadata node : nodeMetadatas) {
    cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
    cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
    cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
  }
  return null;
}"
18924,"@Override protected Object doExecute() throws Exception {
  getComputeService().destroyNode(id);
  return null;
}","@Override protected Object doExecute() throws Exception {
  getComputeService().destroyNode(id);
  cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),id);
  cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),id);
  cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),id);
  return null;
}"
18925,"@Override protected Object doExecute() throws Exception {
  printNodes(getComputeService().listNodes(),""String_Node_Str"",System.out);
  return null;
}","@Override protected Object doExecute() throws Exception {
  printNodes(getComputeService().listNodes(),""String_Node_Str"",System.out);
  for (  ComputeMetadata node : getComputeService().listNodes()) {
    if (node instanceof NodeMetadata) {
      NodeMetadata metadata=(NodeMetadata)node;
      if (metadata.getState().equals(NodeState.RUNNING)) {
        cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).put(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
        cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
        cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
      }
 else       if (metadata.getState().equals(NodeState.SUSPENDED)) {
        cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
        cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).put(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
        cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).put(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
      }
 else       if (metadata.getState().equals(NodeState.TERMINATED)) {
        cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
        cacheProvider.getProviderCacheForType(Constants.INACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
        cacheProvider.getProviderCacheForType(Constants.SUSPENDED_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
      }
 else {
        cacheProvider.getProviderCacheForType(Constants.ACTIVE_NODE_CACHE).remove(getComputeService().getContext().getProviderSpecificContext().getId(),node.getId());
      }
    }
  }
  return null;
}"
18926,"public void init(){
  cache=cacheProvider.getProviderCacheForType(""String_Node_Str"");
}","public void init(){
  cache=cacheProvider.getProviderCacheForType(Constants.GROUP);
}"
18927,"public void init(){
  cache=cacheProvider.getProviderCacheForType(""String_Node_Str"");
}","public void init(){
  cache=cacheProvider.getProviderCacheForType(Constants.HARDWARE_CACHE);
}"
18928,"public void init(){
  cache=cacheProvider.getProviderCacheForType(""String_Node_Str"");
}","public void init(){
  cache=cacheProvider.getProviderCacheForType(Constants.IMAGE_CACHE);
}"
18929,"public void init(){
  cache=cacheProvider.getProviderCacheForType(""String_Node_Str"");
}","public void init(){
  cache=cacheProvider.getProviderCacheForType(Constants.LOCATION_CACHE);
}"
18930,"public void init(){
  cache=cacheProvider.getProviderCacheForType(""String_Node_Str"");
}","public void init(){
  cache=cacheProvider.getProviderCacheForType(Constants.NODE_CACHE);
}"
18931,"@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock() && event.getClickedBlock().getType().equals(Material.STEP)) {
    ShowcaseItem showItem=Showcase.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        if (showItem != null) {
          showItem.getExtra().onRightClick(player);
          return;
        }
 else {
          return;
        }
      }
      if (event.getPlayer().getLocation().getBlock().getRelative(BlockFace.DOWN).getTypeId() == 0) {
        return;
      }
      if (event.hasBlock() && showItem == null && player.mayCreateHere(event.getClickedBlock())) {
        if (event.getItem() == null && !Showcase.hasOddItem()) {
          player.sendMessage(Showcase.tr(""String_Node_Str""));
          event.setCancelled(true);
          return;
        }
        if (event.getClickedBlock().getType().equals(Material.STEP)) {
          event.setCancelled(true);
          if (Showcase.instance.providers.size() == 1 && Showcase.instance.providers.containsKey(""String_Node_Str"")) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            Showcase.instance.showcasedItems.add(new ShowcaseItem(loc,mat,data,event.getPlayer().getName(),""String_Node_Str""));
            event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str""));
          }
 else {
            ShowcaseCreationAssistant assistant=new ShowcaseCreationAssistant(event.getPlayer(),event.getItem(),event.getClickedBlock().getLocation());
            assistant.start();
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName()) || player.hasPermission(""String_Node_Str"",true)) {
          if (showItem.getExtra() == null) {
            showItem.remove();
            Showcase.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str""));
            System.out.println(""String_Node_Str"");
            return;
          }
          if (showItem.getExtra().onDestroy(player)) {
            showItem.remove();
            Showcase.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str""));
          }
        }
 else {
          event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str"",showItem.getPlayer()));
        }
        event.setCancelled(true);
      }
    }
    if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null) {
        if (showItem.getExtra() != null)         showItem.getExtra().onClick(player);
      }
    }
  }
}","@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock() && event.getClickedBlock().getType().equals(Material.STEP)) {
    ShowcaseItem showItem=Showcase.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        if (showItem != null) {
          showItem.getExtra().onRightClick(player);
          return;
        }
 else {
          return;
        }
      }
      if (event.getPlayer().getLocation().getBlock().getRelative(BlockFace.DOWN).getTypeId() == 0) {
        return;
      }
      if (event.hasBlock() && showItem == null && player.mayCreateHere(event.getClickedBlock())) {
        if (event.getItem() == null && !Showcase.hasOddItem()) {
          player.sendMessage(Showcase.tr(""String_Node_Str""));
          event.setCancelled(true);
          return;
        }
        if (event.getClickedBlock().getType().equals(Material.STEP)) {
          event.setCancelled(true);
          if (Showcase.instance.providers.size() == 1 && Showcase.instance.providers.containsKey(""String_Node_Str"")) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            Showcase.instance.showcasedItems.add(new ShowcaseItem(loc,mat,data,event.getPlayer().getName(),""String_Node_Str""));
            event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str""));
          }
 else {
            try {
              ShowcaseCreationAssistant assistant=new ShowcaseCreationAssistant(event.getPlayer(),event.getItem(),event.getClickedBlock().getLocation());
              assistant.start();
            }
 catch (            NoClassDefFoundError e) {
              for (              StackTraceElement element : e.getCause().getStackTrace()) {
                System.out.println(element.getFileName() + ""String_Node_Str"" + element.getLineNumber());
              }
            }
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName()) || player.hasPermission(""String_Node_Str"",true)) {
          if (showItem.getExtra() == null) {
            showItem.remove();
            Showcase.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str""));
            System.out.println(""String_Node_Str"");
            return;
          }
          if (showItem.getExtra().onDestroy(player)) {
            showItem.remove();
            Showcase.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str""));
          }
        }
 else {
          event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str"",showItem.getPlayer()));
        }
        event.setCancelled(true);
      }
    }
    if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null) {
        if (showItem.getExtra() != null)         showItem.getExtra().onClick(player);
      }
    }
  }
}"
18932,"public void onEnable(){
  checkForLibs();
  trans=new Translation();
  instance=this;
  log=getServer().getLogger();
  try {
    dclistener=new DropChestListener();
  }
 catch (  NoClassDefFoundError e) {
    dclistener=null;
  }
  try {
    worldguard=(WorldGuardPlugin)getServer().getPluginManager().getPlugin(""String_Node_Str"");
  }
 catch (  Exception e) {
    worldguard=null;
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_PICKUP_ITEM,playerListener,Priority.Low,this);
  pm.registerEvent(Type.BLOCK_BREAK,blockListener,Priority.Low,this);
  pm.registerEvent(Type.PLAYER_DROP_ITEM,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_LOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_UNLOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.BLOCK_PHYSICS,blockListener,Priority.Normal,this);
  if (dclistener != null) {
    pm.registerEvent(Type.CUSTOM_EVENT,dclistener,Priority.Normal,this);
  }
  for (  World w : getServer().getWorlds()) {
    for (    Entity e : w.getEntities()) {
      if (e instanceof Item) {
        Location loc=e.getLocation();
        Block b=loc.getBlock();
        if (b.getType().equals(Material.GLASS) || b.getType().equals(Material.STEP)) {
          e.remove();
        }
      }
    }
  }
  load();
  config=new Configuration();
  if (pm.getPlugin(""String_Node_Str"") != null) {
    config.setUseSpout(true);
  }
  if (config.useSpout()) {
    if (!NarrowtuxLib.getInstance().installSpout()) {
      config.setUseSpout(false);
    }
  }
  odditem=(OddItem)pm.getPlugin(""String_Node_Str"");
  trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
  if (trans.getVersion() < 5) {
    try {
      copyFromJarToDisk(""String_Node_Str"" + config.getLocale() + ""String_Node_Str"",getDataFolder());
      log.log(Level.INFO,""String_Node_Str"" + config.getLocale() + ""String_Node_Str"");
      trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
  playerListener.config=config;
  registerProvider(new BasicShowcase());
  registerProvider(new FiniteShowcase());
  registerProvider(new InfiniteShowcase());
  registerProvider(new ExchangeShowcase());
  registerProvider(new TutorialShowcase());
  getServer().getScheduler().scheduleSyncDelayedTask(this,new ItemSpawner(),20);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,watcher,10,40);
  setupPermissions();
  if (config.getAutosaveInterval() != -1) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      public void run(){
        save();
        if (config.isShowingAutosaveNotification()) {
          log.log(Level.INFO,""String_Node_Str"");
        }
      }
    }
,0,config.getAutosaveInterval() * 20);
  }
  String logText=trans.tr(""String_Node_Str"",pdfFile.getName(),pdfFile.getVersion());
  log.log(Level.INFO,logText);
}","public void onEnable(){
  checkForLibs();
  trans=new Translation();
  instance=this;
  log=getServer().getLogger();
  try {
    dclistener=new DropChestListener();
  }
 catch (  NoClassDefFoundError e) {
    dclistener=null;
  }
  try {
    worldguard=(WorldGuardPlugin)getServer().getPluginManager().getPlugin(""String_Node_Str"");
  }
 catch (  Exception e) {
    worldguard=null;
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_PICKUP_ITEM,playerListener,Priority.Low,this);
  pm.registerEvent(Type.BLOCK_BREAK,blockListener,Priority.Low,this);
  pm.registerEvent(Type.PLAYER_DROP_ITEM,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_LOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_UNLOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.BLOCK_PLACE,blockListener,Priority.Normal,this);
  if (dclistener != null) {
    pm.registerEvent(Type.CUSTOM_EVENT,dclistener,Priority.Normal,this);
  }
  for (  World w : getServer().getWorlds()) {
    for (    Entity e : w.getEntities()) {
      if (e instanceof Item) {
        Location loc=e.getLocation();
        Block b=loc.getBlock();
        if (b.getType().equals(Material.GLASS) || b.getType().equals(Material.STEP)) {
          e.remove();
        }
      }
    }
  }
  load();
  config=new Configuration();
  if (pm.getPlugin(""String_Node_Str"") != null) {
    config.setUseSpout(true);
  }
  if (config.useSpout()) {
    if (!NarrowtuxLib.getInstance().installSpout()) {
      config.setUseSpout(false);
    }
  }
  odditem=(OddItem)pm.getPlugin(""String_Node_Str"");
  trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
  if (trans.getVersion() < 5) {
    try {
      copyFromJarToDisk(""String_Node_Str"" + config.getLocale() + ""String_Node_Str"",getDataFolder());
      log.log(Level.INFO,""String_Node_Str"" + config.getLocale() + ""String_Node_Str"");
      trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
  playerListener.config=config;
  registerProvider(new BasicShowcase());
  registerProvider(new FiniteShowcase());
  registerProvider(new InfiniteShowcase());
  registerProvider(new ExchangeShowcase());
  registerProvider(new TutorialShowcase());
  getServer().getScheduler().scheduleSyncDelayedTask(this,new ItemSpawner(),20);
  getServer().getScheduler().scheduleSyncRepeatingTask(this,watcher,10,40);
  setupPermissions();
  if (config.getAutosaveInterval() != -1) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      public void run(){
        save();
        if (config.isShowingAutosaveNotification()) {
          log.log(Level.INFO,""String_Node_Str"");
        }
      }
    }
,0,config.getAutosaveInterval() * 20);
  }
  String logText=trans.tr(""String_Node_Str"",pdfFile.getName(),pdfFile.getVersion());
  log.log(Level.INFO,logText);
}"
18933,"public void addShowcase(ShowcaseItem item){
  if (item.isChunkLoaded() && item.getItem() != null) {
    itemsByDrop.put(item.getItem().getEntityId(),item);
  }
  showcasedItems.add(item);
}","public void addShowcase(ShowcaseItem item){
  if (item.isChunkLoaded() && item.getItem() != null) {
    itemsByDrop.put(item.getItem().getEntityId(),item);
  }
  itemsByBlock.put(item.getBlock(),item);
  showcasedItems.add(item);
}"
18934,"public ShowcaseItem getItemByBlock(Block b){
  for (  ShowcaseItem item : showcasedItems) {
    if (b.equals(item.getBlock())) {
      return item;
    }
  }
  return null;
}","public ShowcaseItem getItemByBlock(Block b){
  return itemsByBlock.get(b);
}"
18935,"public void removeShowcase(ShowcaseItem showItem){
  itemsByDrop.remove(showItem.getItem().getEntityId());
  showcasedItems.remove(showItem);
}","public void removeShowcase(ShowcaseItem showItem){
  itemsByBlock.remove(showItem.getBlock());
  itemsByDrop.remove(showItem.getItem().getEntityId());
  showcasedItems.remove(showItem);
}"
18936,"@Override public void onBlockBreak(BlockBreakEvent event){
  if (!event.getBlock().getType().equals(Material.STEP)) {
    return;
  }
  ShowcaseItem item=Showcase.instance.getItemByBlock(event.getBlock());
  if (item != null) {
    event.setCancelled(true);
    event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str"",item.getPlayer()));
  }
  if (event.isCancelled()) {
    event.getPlayer().sendBlockChange(event.getBlock().getLocation(),event.getBlock().getType(),event.getBlock().getData());
  }
}","@Override public void onBlockBreak(BlockBreakEvent event){
  if (!event.getBlock().getType().equals(Material.STEP)) {
    return;
  }
  ShowcaseItem item=Showcase.instance.getItemByBlock(event.getBlock());
  if (item != null) {
    event.setCancelled(true);
    event.getPlayer().sendMessage(Showcase.tr(""String_Node_Str"",item.getPlayer()));
  }
  if (event.isCancelled()) {
    event.getPlayer().sendBlockChange(event.getBlock().getLocation(),event.getBlock().getType(),event.getBlock().getData());
    if (item != null) {
      item.getItem().setVelocity(new Vector(0,0.2,0));
    }
  }
}"
18937,"@Override public boolean onDestroy(ShowcasePlayer player){
  ShowcasePlayer owner=ShowcasePlayer.getPlayer(item.getPlayer());
  owner.addItems(item.getMaterial(),item.getData(),itemAmount);
  return true;
}","@Override public boolean onDestroy(ShowcasePlayer player){
  ShowcasePlayer owner=ShowcasePlayer.getPlayer(item.getPlayer());
  owner.addItems(item.getMaterial(),item.getData(),itemAmount);
  itemAmount=0;
  return true;
}"
18938,"public void load(){
  disabledTypes.clear();
  showcaseProtection=reader.getBoolean(""String_Node_Str"",true);
  priceForBasic=reader.getDouble(""String_Node_Str"",0);
  priceForFiniteShop=reader.getDouble(""String_Node_Str"",0);
  basicMode=reader.getBoolean(""String_Node_Str"",false);
  priceForExchangeShop=reader.getDouble(""String_Node_Str"",0);
  removeWhenEmpty=reader.getBoolean(""String_Node_Str"",false);
  locale=reader.getString(""String_Node_Str"",""String_Node_Str"");
  autoSaveInterval=reader.getInteger(""String_Node_Str"",60);
  maxStackSize.clear();
  loadMaxStackSize();
  String list=reader.getString(""String_Node_Str"",""String_Node_Str"");
  String items[]=list.split(""String_Node_Str"");
  for (  String item : items) {
    disabledTypes.add(item);
  }
}","public void load(){
  disabledTypes.clear();
  showcaseProtection=reader.getBoolean(""String_Node_Str"",true);
  priceForBasic=reader.getDouble(""String_Node_Str"",0);
  priceForFiniteShop=reader.getDouble(""String_Node_Str"",0);
  basicMode=reader.getBoolean(""String_Node_Str"",false);
  priceForExchangeShop=reader.getDouble(""String_Node_Str"",0);
  removeWhenEmpty=reader.getBoolean(""String_Node_Str"",false);
  locale=reader.getString(""String_Node_Str"",""String_Node_Str"");
  autoSaveInterval=reader.getInteger(""String_Node_Str"",60);
  showAutosaveNotification=reader.getBoolean(""String_Node_Str"",false);
  maxStackSize.clear();
  loadMaxStackSize();
  String list=reader.getString(""String_Node_Str"",""String_Node_Str"");
  String items[]=list.split(""String_Node_Str"");
  for (  String item : items) {
    disabledTypes.add(item);
  }
}"
18939,"@Override public void run(){
  for (  ShowcaseItem item : ShowcaseMain.instance.showcasedItems) {
    if (item.getItem() == null || item.getItem().isDead()) {
      item.respawn();
    }
    item.updatePosition();
    if (item.getMaterial().equals(Material.TORCH)) {
      int x, y, z;
      x=item.getBlock().getX();
      y=item.getBlock().getY();
      z=item.getBlock().getZ();
      CraftWorld world=(CraftWorld)item.getBlock().getWorld();
      world.getHandle().b(EnumSkyBlock.BLOCK,x,y,z,14);
    }
  }
}","@Override public void run(){
  for (  ShowcaseItem item : ShowcaseMain.instance.showcasedItems) {
    if (item.getItem() == null || item.getItem().isDead()) {
      item.respawn();
    }
    item.updatePosition();
  }
}"
18940,"public ShowcaseCreationAssistant(Player p,ItemStack item,Location loc){
  super(p);
  player=ShowcasePlayer.getPlayer(getPlayer());
  setTitle(ShowcaseMain.tr(""String_Node_Str""));
  ShowcaseTypeSelectionPage page=new ShowcaseTypeSelectionPage(player,this);
  page.assistant=this;
  addPage(page);
  material=item.getType();
  data=item.getDurability();
  this.loc=loc;
}","public ShowcaseCreationAssistant(Player p,ItemStack item,Location loc){
  super(p);
  player=ShowcasePlayer.getPlayer(getPlayer());
  setTitle(ShowcaseMain.tr(""String_Node_Str""));
  ShowcaseTypeSelectionPage typeSelectionPage=new ShowcaseTypeSelectionPage(player,this);
  typeSelectionPage.assistant=this;
  if (item == null) {
    addPage(new AssistantPage(this){
{
        setTitle(ShowcaseMain.tr(""String_Node_Str""));
        setText(ShowcaseMain.tr(""String_Node_Str""));
      }
      @Override public AssistantAction onPageInput(      String text){
        ItemStack result=null;
        OddItem odd=(OddItem)Bukkit.getServer().getPluginManager().getPlugin(""String_Node_Str"");
        try {
          result=odd.getItemStack(text);
        }
 catch (        IllegalArgumentException e) {
          sendMessage(formatLine(ShowcaseMain.tr(""String_Node_Str"",e.getMessage())));
          return AssistantAction.SILENT_REPEAT;
        }
        material=result.getType();
        data=result.getDurability();
        return AssistantAction.CONTINUE;
      }
    }
);
  }
 else {
    material=item.getType();
    data=item.getDurability();
  }
  addPage(typeSelectionPage);
  this.loc=loc;
}"
18941,"@Override public void run(){
  save();
  log.log(Level.INFO,""String_Node_Str"");
}","@Override public void run(){
  save();
  if (config.isShowingAutosaveNotification()) {
    log.log(Level.INFO,""String_Node_Str"");
  }
}"
18942,"@Override public void onEnable(){
  checkForLibs();
  trans=new Translation();
  instance=this;
  log=getServer().getLogger();
  try {
    dclistener=new DropChestListener();
  }
 catch (  NoClassDefFoundError e) {
    dclistener=null;
  }
  try {
    worldguard=(WorldGuardPlugin)getServer().getPluginManager().getPlugin(""String_Node_Str"");
  }
 catch (  Exception e) {
    worldguard=null;
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_PICKUP_ITEM,playerListener,Priority.Low,this);
  pm.registerEvent(Type.BLOCK_BREAK,blockListener,Priority.Low,this);
  pm.registerEvent(Type.PLUGIN_ENABLE,serverListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_DISABLE,serverListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_DROP_ITEM,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_LOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_UNLOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.BLOCK_PHYSICS,blockListener,Priority.Normal,this);
  if (dclistener != null) {
    pm.registerEvent(Type.CUSTOM_EVENT,dclistener,Priority.Normal,this);
  }
  for (  World w : getServer().getWorlds()) {
    for (    Entity e : w.getEntities()) {
      if (e instanceof Item) {
        Location loc=e.getLocation();
        Block b=loc.getBlock();
        if (b.getType().equals(Material.GLASS) || b.getType().equals(Material.STEP)) {
          e.remove();
        }
      }
    }
  }
  load();
  config=new Configuration();
  trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
  if (trans.getVersion() < 4) {
    try {
      copyFromJarToDisk(""String_Node_Str"" + config.getLocale() + ""String_Node_Str"",getDataFolder());
      log.log(Level.INFO,""String_Node_Str"" + config.getLocale() + ""String_Node_Str"");
      trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
  playerListener.config=config;
  registerProvider(new BasicShowcase());
  registerProvider(new FiniteShowcase());
  registerProvider(new InfiniteShowcase());
  registerProvider(new ExchangeShowcase());
  registerProvider(new TutorialShowcase());
  getServer().getScheduler().scheduleSyncRepeatingTask(this,watcher,0,40);
  setupPermissions();
  if (config.getAutosaveInterval() != -1) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      @Override public void run(){
        save();
        log.log(Level.INFO,""String_Node_Str"");
      }
    }
,0,config.getAutosaveInterval() * 20);
  }
  String logText=trans.tr(""String_Node_Str"",pdfFile.getName(),pdfFile.getVersion());
  log.log(Level.INFO,logText);
}","@Override public void onEnable(){
  checkForLibs();
  trans=new Translation();
  instance=this;
  log=getServer().getLogger();
  try {
    dclistener=new DropChestListener();
  }
 catch (  NoClassDefFoundError e) {
    dclistener=null;
  }
  try {
    worldguard=(WorldGuardPlugin)getServer().getPluginManager().getPlugin(""String_Node_Str"");
  }
 catch (  Exception e) {
    worldguard=null;
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_PICKUP_ITEM,playerListener,Priority.Low,this);
  pm.registerEvent(Type.BLOCK_BREAK,blockListener,Priority.Low,this);
  pm.registerEvent(Type.PLUGIN_ENABLE,serverListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_DISABLE,serverListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_DROP_ITEM,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_LOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.CHUNK_UNLOAD,worldListener,Priority.Normal,this);
  pm.registerEvent(Type.BLOCK_PHYSICS,blockListener,Priority.Normal,this);
  if (dclistener != null) {
    pm.registerEvent(Type.CUSTOM_EVENT,dclistener,Priority.Normal,this);
  }
  for (  World w : getServer().getWorlds()) {
    for (    Entity e : w.getEntities()) {
      if (e instanceof Item) {
        Location loc=e.getLocation();
        Block b=loc.getBlock();
        if (b.getType().equals(Material.GLASS) || b.getType().equals(Material.STEP)) {
          e.remove();
        }
      }
    }
  }
  load();
  config=new Configuration();
  trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
  if (trans.getVersion() < 5) {
    try {
      copyFromJarToDisk(""String_Node_Str"" + config.getLocale() + ""String_Node_Str"",getDataFolder());
      log.log(Level.INFO,""String_Node_Str"" + config.getLocale() + ""String_Node_Str"");
      trans.reload(new File(getDataFolder(),""String_Node_Str"" + config.getLocale() + ""String_Node_Str""));
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"");
    }
  }
  playerListener.config=config;
  registerProvider(new BasicShowcase());
  registerProvider(new FiniteShowcase());
  registerProvider(new InfiniteShowcase());
  registerProvider(new ExchangeShowcase());
  registerProvider(new TutorialShowcase());
  registerProvider(new SellShowcase());
  getServer().getScheduler().scheduleSyncRepeatingTask(this,watcher,0,40);
  setupPermissions();
  if (config.getAutosaveInterval() != -1) {
    getServer().getScheduler().scheduleSyncRepeatingTask(this,new Runnable(){
      @Override public void run(){
        save();
        if (config.isShowingAutosaveNotification()) {
          log.log(Level.INFO,""String_Node_Str"");
        }
      }
    }
,0,config.getAutosaveInterval() * 20);
  }
  String logText=trans.tr(""String_Node_Str"",pdfFile.getName(),pdfFile.getVersion());
  log.log(Level.INFO,logText);
}"
18943,"@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock() && event.getClickedBlock().getType().equals(Material.STEP)) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        if (showItem != null) {
          showItem.getExtra().onRightClick(player);
          return;
        }
 else {
          return;
        }
      }
      if (event.getPlayer().getLocation().getBlock().getFace(BlockFace.DOWN).getTypeId() == 0) {
        return;
      }
      if (event.hasBlock() && showItem == null && player.mayCreateHere(event.getClickedBlock())) {
        if (event.getItem() == null) {
          player.sendMessage(ShowcaseMain.tr(""String_Node_Str""));
          event.setCancelled(true);
          return;
        }
        if (event.getClickedBlock().getType().equals(Material.STEP)) {
          event.setCancelled(true);
          if (ShowcaseMain.instance.providers.size() == 1 && ShowcaseMain.instance.providers.containsKey(""String_Node_Str"")) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            ShowcaseMain.instance.showcasedItems.add(new ShowcaseItem(loc,mat,data,event.getPlayer().getName(),""String_Node_Str""));
            event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str""));
          }
 else {
            ShowcaseCreationAssistant assistant=new ShowcaseCreationAssistant(event.getPlayer(),event.getItem(),event.getClickedBlock().getLocation());
            assistant.start();
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName()) || player.hasPermission(""String_Node_Str"",true)) {
          if (showItem.getExtra() == null) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str""));
            System.out.println(""String_Node_Str"");
            return;
          }
          if (showItem.getExtra().onDestroy(player)) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str""));
          }
        }
 else {
          event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str"",showItem.getPlayer()));
        }
        event.setCancelled(true);
      }
    }
    if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null) {
        if (showItem.getExtra() != null)         showItem.getExtra().onClick(player);
      }
    }
  }
}","@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock() && event.getClickedBlock().getType().equals(Material.STEP)) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        if (showItem != null) {
          showItem.getExtra().onRightClick(player);
          return;
        }
 else {
          return;
        }
      }
      if (event.getPlayer().getLocation().getBlock().getRelative(BlockFace.DOWN).getTypeId() == 0) {
        return;
      }
      if (event.hasBlock() && showItem == null && player.mayCreateHere(event.getClickedBlock())) {
        if (event.getClickedBlock().getType().equals(Material.STEP)) {
          event.setCancelled(true);
          if (ShowcaseMain.instance.providers.size() == 1 && ShowcaseMain.instance.providers.containsKey(""String_Node_Str"")) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            ShowcaseMain.instance.showcasedItems.add(new ShowcaseItem(loc,mat,data,event.getPlayer().getName(),""String_Node_Str""));
            event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str""));
          }
 else {
            ShowcaseCreationAssistant assistant=new ShowcaseCreationAssistant(event.getPlayer(),event.getItem(),event.getClickedBlock().getLocation());
            assistant.start();
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName()) || player.hasPermission(""String_Node_Str"",true)) {
          if (showItem.getExtra() == null) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str""));
            System.out.println(""String_Node_Str"");
            return;
          }
          if (showItem.getExtra().onDestroy(player)) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str""));
          }
        }
 else {
          event.getPlayer().sendMessage(ShowcaseMain.tr(""String_Node_Str"",showItem.getPlayer()));
        }
        event.setCancelled(true);
      }
    }
    if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null) {
        if (showItem.getExtra() != null)         showItem.getExtra().onClick(player);
      }
    }
  }
}"
18944,"@Override public ShowcaseExtra createShowcase(ShowcaseCreationAssistant assistant){
  return null;
}","@Override public ShowcaseExtra createShowcase(ShowcaseCreationAssistant assistant){
  return new SellShowcaseExtra();
}"
18945,"@Override public ShowcaseExtra loadShowcase(String values){
  return null;
}","@Override public ShowcaseExtra loadShowcase(String values){
  SellShowcaseExtra extra=new SellShowcaseExtra();
  String args[]=values.split(""String_Node_Str"");
  if (args.length >= 3) {
    extra.setAmountLeft(Integer.valueOf(args[0]));
    extra.setPricePerItem(Double.valueOf(args[1]));
    extra.setAmountOfItems(Integer.valueOf(args[2]));
    return extra;
  }
  return null;
}"
18946,"public void save(){
  File folder=getDataFolder();
  if (!folder.exists()) {
    folder.mkdir();
  }
  File datafile=new File(folder.getAbsolutePath() + ""String_Node_Str"");
  if (!datafile.exists()) {
    try {
      datafile.createNewFile();
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + e.getCause() + ""String_Node_Str"");
      return;
    }
  }
  try {
    FileOutputStream output=new FileOutputStream(datafile.getAbsoluteFile());
    BufferedWriter w=new BufferedWriter(new OutputStreamWriter(output));
    for (    ShowcaseItem item : showcasedItems) {
      String line=""String_Node_Str"";
      Location loc=item.getBlock().getLocation();
      Material type=item.getMaterial();
      short data=item.getData();
      String player=item.getPlayer();
      String showtype=item.getType();
      line+=loc.getBlockX() + ""String_Node_Str"" + loc.getBlockY()+ ""String_Node_Str""+ loc.getBlockZ()+ ""String_Node_Str"";
      line+=type.getId() + ""String_Node_Str"" + data+ ""String_Node_Str"";
      line+=player + ""String_Node_Str"";
      line+=loc.getWorld().getName() + ""String_Node_Str"";
      line+=showtype + ""String_Node_Str"";
      if (item.getExtra() != null) {
        line+=item.getExtra().save();
      }
 else {
        line+=item.getExtraLoad();
      }
      line+=""String_Node_Str"";
      w.write(line);
    }
    w.flush();
    output.close();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}","public void save(){
  File folder=getDataFolder();
  if (!folder.exists()) {
    folder.mkdir();
  }
  File datafile=new File(folder.getAbsolutePath() + ""String_Node_Str"");
  if (!datafile.exists()) {
    try {
      datafile.createNewFile();
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + e.getCause() + ""String_Node_Str"");
      return;
    }
  }
  try {
    FileOutputStream output=new FileOutputStream(datafile.getAbsoluteFile());
    BufferedWriter w=new BufferedWriter(new OutputStreamWriter(output));
    for (    ShowcaseItem item : showcasedItems) {
      try {
        String line=""String_Node_Str"";
        Location loc=item.getBlock().getLocation();
        Material type=item.getMaterial();
        short data=item.getData();
        String player=item.getPlayer();
        String showtype=item.getType();
        line+=loc.getBlockX() + ""String_Node_Str"" + loc.getBlockY()+ ""String_Node_Str""+ loc.getBlockZ()+ ""String_Node_Str"";
        line+=type.getId() + ""String_Node_Str"" + data+ ""String_Node_Str"";
        line+=player + ""String_Node_Str"";
        line+=loc.getWorld().getName() + ""String_Node_Str"";
        line+=showtype + ""String_Node_Str"";
        line+=loc.getWorld().getEnvironment().toString() + ""String_Node_Str"";
        if (item.getExtra() != null) {
          line+=item.getExtra().save();
        }
 else {
          line+=item.getExtraLoad();
        }
        line+=""String_Node_Str"";
        w.write(line);
      }
 catch (      Exception e) {
        continue;
      }
    }
    w.flush();
    output.close();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}"
18947,"public void load(){
  File folder=getDataFolder();
  if (!folder.exists()) {
    folder.mkdir();
  }
  File datafile=new File(folder.getAbsolutePath() + ""String_Node_Str"");
  if (datafile.exists()) {
    FileInputStream input;
    try {
      input=new FileInputStream(datafile.getAbsoluteFile());
      InputStreamReader ir=new InputStreamReader(input);
      BufferedReader r=new BufferedReader(ir);
      String locline;
      while (true) {
        locline=r.readLine();
        if (locline == null) {
          break;
        }
        String line[]=locline.split(""String_Node_Str"");
        if (line.length == 10) {
          int x, y, z;
          x=Integer.valueOf(line[0]);
          y=Integer.valueOf(line[1]);
          z=Integer.valueOf(line[2]);
          Material type=Material.getMaterial(Integer.valueOf(line[3]));
          short data=Short.valueOf(line[4]);
          String player=line[5];
          World world=getServer().getWorld(line[6]);
          String showtype=line[7].toLowerCase();
          if (showtype.equals(""String_Node_Str"")) {
            showtype=""String_Node_Str"";
          }
          if (showtype.equals(""String_Node_Str"")) {
            showtype=""String_Node_Str"";
          }
          int amount=Integer.valueOf(line[8]);
          double price=Double.valueOf(line[9]);
          Location loc=new Location(world,x,y,z);
          ShowcaseItem showItem=new ShowcaseItem(loc,type,data,player,showtype);
          showcasedItems.add(showItem);
          if (showtype.equals(""String_Node_Str"")) {
            showItem.setExtraLoad(amount + ""String_Node_Str"" + price);
          }
 else           if (showtype.equals(""String_Node_Str"")) {
            showItem.setExtraLoad(""String_Node_Str"" + price);
          }
        }
 else         if (line.length == 9) {
          int x, y, z;
          x=Integer.valueOf(line[0]);
          y=Integer.valueOf(line[1]);
          z=Integer.valueOf(line[2]);
          Material type=Material.getMaterial(Integer.valueOf(line[3]));
          short data=Short.valueOf(line[4]);
          String player=line[5];
          World world=getServer().getWorld(line[6]);
          String showtype=line[7].toLowerCase();
          Location loc=new Location(world,x,y,z);
          ShowcaseItem showItem=new ShowcaseItem(loc,type,data,player,showtype);
          showcasedItems.add(showItem);
          String extra=line[8];
          showItem.setExtraLoad(extra);
        }
 else {
          continue;
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public void load(){
  File folder=getDataFolder();
  if (!folder.exists()) {
    folder.mkdir();
  }
  File datafile=new File(folder.getAbsolutePath() + ""String_Node_Str"");
  if (datafile.exists()) {
    FileInputStream input;
    try {
      input=new FileInputStream(datafile.getAbsoluteFile());
      InputStreamReader ir=new InputStreamReader(input);
      BufferedReader r=new BufferedReader(ir);
      String locline;
      while (true) {
        locline=r.readLine();
        if (locline == null) {
          break;
        }
        String line[]=locline.split(""String_Node_Str"");
        if (line.length == 10) {
          int x, y, z;
          x=Integer.valueOf(line[0]);
          y=Integer.valueOf(line[1]);
          z=Integer.valueOf(line[2]);
          Material type=Material.getMaterial(Integer.valueOf(line[3]));
          short data=Short.valueOf(line[4]);
          String player=line[5];
          Environment environment=Environment.NORMAL;
          try {
            environment=Environment.valueOf(line[8]);
          }
 catch (          Exception e) {
            environment=Environment.NORMAL;
          }
          World world=getServer().createWorld(line[6],environment);
          String showtype=line[7].toLowerCase();
          Location loc=new Location(world,x,y,z);
          ShowcaseItem showItem=new ShowcaseItem(loc,type,data,player,showtype);
          showcasedItems.add(showItem);
          String extra=line[9];
          showItem.setExtraLoad(extra);
        }
 else         if (line.length == 9) {
          int x, y, z;
          x=Integer.valueOf(line[0]);
          y=Integer.valueOf(line[1]);
          z=Integer.valueOf(line[2]);
          Material type=Material.getMaterial(Integer.valueOf(line[3]));
          short data=Short.valueOf(line[4]);
          String player=line[5];
          World world=getServer().getWorld(line[6]);
          String showtype=line[7].toLowerCase();
          Location loc=new Location(world,x,y,z);
          ShowcaseItem showItem=new ShowcaseItem(loc,type,data,player,showtype);
          showcasedItems.add(showItem);
          String extra=line[8];
          showItem.setExtraLoad(extra);
        }
 else {
          continue;
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}"
18948,"@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock() && event.getClickedBlock().getType().equals(Material.STEP)) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        return;
      }
      if (event.getPlayer().getLocation().getBlock().getFace(BlockFace.DOWN).getTypeId() == 0) {
        return;
      }
      if (event.hasBlock() && showItem == null && player.mayCreateHere(event.getClickedBlock())) {
        if (event.getItem() == null) {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
          event.setCancelled(true);
          return;
        }
        if (event.getClickedBlock().getType().equals(Material.STEP)) {
          event.setCancelled(true);
          if (ShowcaseMain.instance.providers.size() == 1 && ShowcaseMain.instance.providers.containsKey(""String_Node_Str"")) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            ShowcaseMain.instance.showcasedItems.add(new ShowcaseItem(loc,mat,data,event.getPlayer().getName(),""String_Node_Str""));
          }
 else {
            ShowcaseCreationAssistant assistant=new ShowcaseCreationAssistant(event.getPlayer(),event.getItem(),event.getClickedBlock().getLocation());
            assistant.start();
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName()) || player.hasPermission(""String_Node_Str"",true)) {
          if (showItem.getExtra() == null || showItem.getExtra().onDestroy(player)) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"" + showItem.getPlayer()+ ""String_Node_Str"");
        }
        event.setCancelled(true);
      }
    }
    if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null) {
        if (showItem.getExtra() != null)         showItem.getExtra().onClick(player);
      }
    }
  }
}","@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock() && event.getClickedBlock().getType().equals(Material.STEP)) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        return;
      }
      if (event.getPlayer().getLocation().getBlock().getFace(BlockFace.DOWN).getTypeId() == 0) {
        return;
      }
      if (event.hasBlock() && showItem == null && player.mayCreateHere(event.getClickedBlock())) {
        if (event.getItem() == null) {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
          event.setCancelled(true);
          return;
        }
        if (event.getClickedBlock().getType().equals(Material.STEP)) {
          event.setCancelled(true);
          if (ShowcaseMain.instance.providers.size() == 1 && ShowcaseMain.instance.providers.containsKey(""String_Node_Str"")) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            ShowcaseMain.instance.showcasedItems.add(new ShowcaseItem(loc,mat,data,event.getPlayer().getName(),""String_Node_Str""));
            event.getPlayer().sendMessage(ChatColor.GREEN + ""String_Node_Str"");
          }
 else {
            ShowcaseCreationAssistant assistant=new ShowcaseCreationAssistant(event.getPlayer(),event.getItem(),event.getClickedBlock().getLocation());
            assistant.start();
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName()) || player.hasPermission(""String_Node_Str"",true)) {
          if (showItem.getExtra() == null) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            return;
          }
          if (showItem.getExtra().onDestroy(player)) {
            showItem.remove();
            ShowcaseMain.instance.showcasedItems.remove(showItem);
            event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
          }
        }
 else {
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"" + showItem.getPlayer()+ ""String_Node_Str"");
        }
        event.setCancelled(true);
      }
    }
    if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null) {
        if (showItem.getExtra() != null)         showItem.getExtra().onClick(player);
      }
    }
  }
}"
18949,"public ShowcaseTypeSelectionPage(ShowcasePlayer player){
  setTitle(""String_Node_Str"");
  String text=""String_Node_Str"";
  for (  ShowcaseProvider provider : ShowcaseMain.instance.providers.values()) {
    if (player.hasPermission(provider.getPermission(),provider.isOpMethod())) {
      text+=ChatColor.YELLOW + provider.getType() + ChatColor.WHITE;
      text+=""String_Node_Str"" + ChatColor.YELLOW + getPrice(provider.getPriceForCreation(player))+ ChatColor.WHITE+ ""String_Node_Str"";
    }
  }
  text=text.substring(0,text.length() - 2) + ""String_Node_Str"";
  text+=""String_Node_Str"";
  setText(text);
}","public ShowcaseTypeSelectionPage(ShowcasePlayer player){
  setTitle(""String_Node_Str"");
  String text=""String_Node_Str"";
  for (  ShowcaseProvider provider : ShowcaseMain.instance.providers.values()) {
    if (player.hasPermission(provider.getPermission(),provider.isOpMethod())) {
      text+=ChatColor.YELLOW + provider.getType() + ChatColor.WHITE;
      text+=""String_Node_Str"" + ChatColor.YELLOW + getPrice(provider.getPriceForCreation(player))+ ChatColor.WHITE+ ""String_Node_Str"";
    }
  }
  if (text.equals(""String_Node_Str"")) {
    text=""String_Node_Str"";
    getAssistant().cancel();
  }
 else {
    text=text.substring(0,text.length() - 2) + ""String_Node_Str"";
    text+=""String_Node_Str"";
  }
  setText(text);
}"
18950,"public static int getVersion(){
  String args[]=version.split(""String_Node_Str"");
  int result=0;
  for (int i=0; i < args.length; i++) {
    try {
      int v=Integer.valueOf(args[args.length - i - 1]);
      result+=v * Math.pow(i,10);
    }
 catch (    Exception e) {
    }
  }
  System.out.println(version + ""String_Node_Str"" + result);
  return result;
}","public static int getVersion(){
  return version;
}"
18951,"private static void load(){
  FlatFileReader reader=new FlatFileReader(file,true);
  for (  String key : reader.keys()) {
    if (!key.equals(""String_Node_Str"")) {
      String trans=parseColors(reader.getString(key,""String_Node_Str"" + key + ""String_Node_Str""));
      trans=trans.replaceAll(""String_Node_Str"",""String_Node_Str"");
      translations.put(key,trans);
    }
  }
  version=reader.getString(""String_Node_Str"",""String_Node_Str"");
}","private static void load(){
  FlatFileReader reader=new FlatFileReader(file,true);
  for (  String key : reader.keys()) {
    if (!key.equals(""String_Node_Str"")) {
      String trans=parseColors(reader.getString(key,""String_Node_Str"" + key + ""String_Node_Str""));
      trans=trans.replaceAll(""String_Node_Str"",""String_Node_Str"");
      translations.put(key,trans);
    }
  }
  version=reader.getInteger(""String_Node_Str"",0);
}"
18952,"@Override public void run(){
  for (  ShowcaseItem item : ShowcaseMain.instance.showcasedItems) {
    Chunk c=item.getBlock().getChunk();
    if (item.getItem().getWorld().isChunkLoaded(c)) {
      if (!item.isChunkLoaded()) {
        for (        Entity e : c.getEntities()) {
          if (e instanceof Item) {
            if (e.getLocation().getBlock().equals(item.getBlock())) {
              item.setItem((Item)e);
              System.out.println(""String_Node_Str"");
            }
          }
        }
      }
      item.setChunkLoaded(true);
    }
 else {
      item.setChunkLoaded(false);
    }
    if (item.getItem().isDead()) {
      item.respawn();
    }
    item.updatePosition();
  }
}","@Override public void run(){
  for (  ShowcaseItem item : ShowcaseMain.instance.showcasedItems) {
    Chunk c=item.getBlock().getChunk();
    if (c.getWorld().isChunkLoaded(c)) {
      if (!item.isChunkLoaded()) {
        System.out.println(""String_Node_Str"");
        boolean itemFound=false;
        for (        Entity e : c.getEntities()) {
          if (e instanceof Item) {
            if (e.getLocation().getBlock().equals(item.getBlock())) {
              item.setItem((Item)e);
              System.out.println(""String_Node_Str"");
              itemFound=true;
              break;
            }
          }
        }
        if (!itemFound) {
          item.respawn();
        }
      }
    }
    item.setChunkLoaded(c.getWorld().isChunkLoaded(c));
    if ((item.getItem() == null || item.getItem().isDead()) && item.isChunkLoaded()) {
      item.respawn();
    }
    item.updatePosition();
  }
}"
18953,"public void respawn(){
  item.remove();
  ItemStack stack=new ItemStack(getMaterial(),1,getData());
  item=item.getLocation().getWorld().dropItemNaturally(location,stack);
  updatedPosition=false;
}","public void respawn(){
  if (item != null) {
    item.remove();
  }
  ItemStack stack=new ItemStack(getMaterial(),1,getData());
  item=getLocation().getWorld().dropItemNaturally(location,stack);
  updatedPosition=false;
}"
18954,"public void remove(){
  item.remove();
}","public void remove(){
  checkForDupedItem();
  item.remove();
}"
18955,"public void updatePosition(){
  if (!updatedPosition || item.getLocation().getY() >= block.getLocation().getBlockY() + 0.5) {
    item.teleport(location);
    item.setVelocity(new Vector(0,0,0));
    updatedPosition=true;
  }
}","public void updatePosition(){
  if (item != null && (!updatedPosition || item.getLocation().getY() >= block.getLocation().getBlockY() + 0.5)) {
    item.teleport(location);
    item.setVelocity(new Vector(0,0,0));
    updatedPosition=true;
  }
}"
18956,"public ShowcaseItem(Location loc,Material mat,short data,String player,ShowcaseType type,int amount,double price){
  setItem(loc.getWorld().dropItemNaturally(loc,new ItemStack(mat,1,data)));
  setLocation(loc);
  setMaterial(mat);
  setData(data);
  setPlayer(player);
  setType(type);
  setItemAmount(amount);
  setPricePerItem(price);
}","public ShowcaseItem(Location loc,Material mat,short data,String player,ShowcaseType type,int amount,double price){
  setMaterial(mat);
  setData(data);
  setPlayer(player);
  setType(type);
  setItemAmount(amount);
  setPricePerItem(price);
  setBlock(loc.getBlock());
  setChunkLoaded(block.getWorld().isChunkLoaded(block.getChunk()));
  if (isChunkLoaded()) {
    setItem(loc.getWorld().dropItemNaturally(loc,new ItemStack(mat,1,data)));
    setLocation(loc);
    checkForDupedItem();
  }
 else {
    location=loc;
    setItem(null);
    System.out.println(""String_Node_Str"");
  }
}"
18957,"public void save(){
  File folder=getDataFolder();
  if (!folder.exists()) {
    folder.mkdir();
  }
  File datafile=new File(folder.getAbsolutePath() + ""String_Node_Str"");
  if (!datafile.exists()) {
    try {
      datafile.createNewFile();
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + e.getCause() + ""String_Node_Str"");
      return;
    }
  }
  try {
    FileOutputStream output=new FileOutputStream(datafile.getAbsoluteFile());
    BufferedWriter w=new BufferedWriter(new OutputStreamWriter(output));
    for (    ShowcaseItem item : showcasedItems) {
      String line=""String_Node_Str"";
      Location loc=item.getBlock().getLocation();
      Material type=item.getItem().getItemStack().getType();
      short data=item.getItem().getItemStack().getDurability();
      String player=item.getPlayer();
      ShowcaseType showtype=item.getType();
      int amount=item.getItemAmount();
      double price=item.getPricePerItem();
      line+=loc.getBlockX() + ""String_Node_Str"" + loc.getBlockY()+ ""String_Node_Str""+ loc.getBlockZ()+ ""String_Node_Str"";
      line+=type.getId() + ""String_Node_Str"" + data+ ""String_Node_Str"";
      line+=player + ""String_Node_Str"";
      line+=loc.getWorld().getName() + ""String_Node_Str"";
      line+=showtype + ""String_Node_Str"" + amount+ ""String_Node_Str""+ price+ ""String_Node_Str"";
      w.write(line);
    }
    w.flush();
    output.close();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}","public void save(){
  File folder=getDataFolder();
  if (!folder.exists()) {
    folder.mkdir();
  }
  File datafile=new File(folder.getAbsolutePath() + ""String_Node_Str"");
  if (!datafile.exists()) {
    try {
      datafile.createNewFile();
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + e.getCause() + ""String_Node_Str"");
      return;
    }
  }
  try {
    FileOutputStream output=new FileOutputStream(datafile.getAbsoluteFile());
    BufferedWriter w=new BufferedWriter(new OutputStreamWriter(output));
    for (    ShowcaseItem item : showcasedItems) {
      String line=""String_Node_Str"";
      Location loc=item.getBlock().getLocation();
      Material type=item.getMaterial();
      short data=item.getData();
      String player=item.getPlayer();
      ShowcaseType showtype=item.getType();
      int amount=item.getItemAmount();
      double price=item.getPricePerItem();
      line+=loc.getBlockX() + ""String_Node_Str"" + loc.getBlockY()+ ""String_Node_Str""+ loc.getBlockZ()+ ""String_Node_Str"";
      line+=type.getId() + ""String_Node_Str"" + data+ ""String_Node_Str"";
      line+=player + ""String_Node_Str"";
      line+=loc.getWorld().getName() + ""String_Node_Str"";
      line+=showtype + ""String_Node_Str"" + amount+ ""String_Node_Str""+ price+ ""String_Node_Str"";
      w.write(line);
    }
    w.flush();
    output.close();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}"
18958,"public void addShowcase(Location loc,Material material,short data,Player owner,ShowcaseType type,int amount,double price){
  ItemStack stack=new ItemStack(material,1,data);
  Item item=loc.getWorld().dropItemNaturally(loc,stack);
  ShowcaseItem shit=new ShowcaseItem(item,loc,owner.getName());
  ShowcaseMain.instance.showcasedItems.add(shit);
  shit.setItemAmount(amount);
  shit.setPricePerItem(price);
  shit.setType(type);
}","public void addShowcase(Location loc,Material material,short data,Player owner,ShowcaseType type,int amount,double price){
  ShowcaseItem shit=new ShowcaseItem(loc,material,data,owner.getName(),type,amount,price);
  ShowcaseMain.instance.showcasedItems.add(shit);
}"
18959,"public void remove(){
  if (type.equals(ShowcaseType.FINITE_SHOP)) {
    ShowcasePlayer player=ShowcasePlayer.getPlayer(this.player);
    ItemStack stack=item.getItemStack().clone();
    stack.setAmount(itemAmount);
    player.getPlayer().getInventory().addItem(stack);
  }
  item.remove();
}","public void remove(){
  item.remove();
}"
18960,"@Override public void onEnable(){
  instance=this;
  log=getServer().getLogger();
  try {
    dclistener=new DropChestListener();
  }
 catch (  NoClassDefFoundError e) {
    dclistener=null;
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  log.log(Level.INFO,pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_PICKUP_ITEM,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.BLOCK_BREAK,blockListener,Priority.Low,this);
  pm.registerEvent(Type.PLAYER_CHAT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_ENABLE,serverListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_DISABLE,serverListener,Priority.Normal,this);
  if (dclistener != null) {
    pm.registerEvent(Type.CUSTOM_EVENT,dclistener,Priority.Normal,this);
  }
  getServer().getScheduler().scheduleSyncRepeatingTask(this,watcher,0,10);
  load();
  setupPermissions();
}","@Override public void onEnable(){
  instance=this;
  log=getServer().getLogger();
  try {
    dclistener=new DropChestListener();
  }
 catch (  NoClassDefFoundError e) {
    dclistener=null;
  }
  PluginDescriptionFile pdfFile=this.getDescription();
  log.log(Level.INFO,pdfFile.getName() + ""String_Node_Str"" + pdfFile.getVersion()+ ""String_Node_Str"");
  PluginManager pm=getServer().getPluginManager();
  pm.registerEvent(Type.PLAYER_INTERACT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLAYER_PICKUP_ITEM,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.BLOCK_BREAK,blockListener,Priority.Low,this);
  pm.registerEvent(Type.PLAYER_CHAT,playerListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_ENABLE,serverListener,Priority.Normal,this);
  pm.registerEvent(Type.PLUGIN_DISABLE,serverListener,Priority.Normal,this);
  if (dclistener != null) {
    pm.registerEvent(Type.CUSTOM_EVENT,dclistener,Priority.Normal,this);
  }
  getServer().getScheduler().scheduleSyncRepeatingTask(this,watcher,0,10);
  for (  World w : getServer().getWorlds()) {
    for (    Entity e : w.getEntities()) {
      if (e instanceof Item) {
        Location loc=e.getLocation();
        Block b=loc.getBlock();
        if (b.getType().equals(Material.GLASS)) {
          e.remove();
        }
      }
    }
  }
  load();
  setupPermissions();
}"
18961,"public void remove(Material mat,short data,int amount){
  Inventory inv=getPlayer().getInventory();
  for (int i=0; i < inv.getSize(); i++) {
    ItemStack stack=inv.getItem(i);
    if (stack.getType().equals(mat) && stack.getDurability() == data) {
      if (stack.getAmount() >= amount) {
        stack.setAmount(stack.getAmount() - amount);
        inv.setItem(i,stack);
        return;
      }
 else {
        amount-=stack.getAmount();
        inv.setItem(i,null);
      }
    }
  }
}","public void remove(Material mat,short data,int amount){
  Inventory inv=getPlayer().getInventory();
  for (int i=0; i < inv.getSize(); i++) {
    ItemStack stack=inv.getItem(i).clone();
    if (stack.getType().equals(mat) && stack.getDurability() == data) {
      if (stack.getAmount() > amount) {
        stack.setAmount(stack.getAmount() - amount);
        inv.setItem(i,stack);
        return;
      }
 else {
        amount-=stack.getAmount();
        inv.setItem(i,null);
      }
    }
  }
}"
18962,"public void printAmountMenu(Player p){
  ShowcasePlayer player=ShowcasePlayer.getPlayer(p);
  ShowcaseType type=player.getRequestedType();
  String print=ChatColor.YELLOW + ""String_Node_Str"" + player.getRequestedPrice()+ ChatColor.YELLOW+ ""String_Node_Str"";
  print+=ChatColor.YELLOW + ""String_Node_Str"";
  print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE;
  ItemStack stack=player.getRequestedItem();
  print+=player.getAmountOfType(stack.getType(),stack.getDurability());
  print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ stack.getType()+ ChatColor.YELLOW+ ""String_Node_Str"";
  player.sendMessage(print);
}","public void printAmountMenu(Player p){
  ShowcasePlayer player=ShowcasePlayer.getPlayer(p);
  String print=ChatColor.YELLOW + ""String_Node_Str"" + player.getRequestedPrice()+ ChatColor.YELLOW+ ""String_Node_Str"";
  print+=ChatColor.YELLOW + ""String_Node_Str"";
  print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE;
  ItemStack stack=player.getRequestedItem();
  print+=player.getAmountOfType(stack.getType(),stack.getDurability());
  print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ stack.getType()+ ChatColor.YELLOW+ ""String_Node_Str"";
  player.sendMessage(print);
}"
18963,"@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock()) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        return;
      }
      if (event.getItem() == null) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        event.setCancelled(true);
        return;
      }
      if (event.hasBlock() && event.hasItem() && showItem == null) {
        if (event.getClickedBlock().getType().equals(Material.GLASS)) {
          event.setCancelled(true);
          if (!isSafePlace(event.getClickedBlock())) {
            player.sendMessage(ChatColor.RED + ""String_Node_Str"");
            return;
          }
          printTypeMenu(event.getPlayer());
          player.setDialogState(1);
          player.setRequestedItem(event.getItem().clone());
          player.setRequestedBlock(event.getClickedBlock());
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName())) {
          showItem.remove();
          ShowcaseMain.instance.showcasedItems.remove(showItem);
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
 else {
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"" + showItem.getPlayer()+ ""String_Node_Str"");
        }
        event.setCancelled(true);
      }
    }
 else     if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null && showItem.getType().toString().contains(""String_Node_Str"")) {
        if (!player.hasReadPrice() || !player.standsOnReadPosition()) {
          String print=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getPricePerItem()+ ""String_Node_Str"";
          player.setHasReadPrice(true);
          player.setReadPriceLocation(player.getPlayer().getLocation());
          if (showItem.getType().equals(ShowcaseType.FINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getItemAmount();
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
 else           if (showItem.getType().equals(ShowcaseType.INFINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
          player.sendMessage(print);
        }
 else {
          if (player.standsOnReadPosition()) {
            ItemStack stack=showItem.getItem().getItemStack().clone();
            stack.setAmount(1);
            if (player.withdraw(showItem.getPricePerItem())) {
switch (showItem.getType()) {
case INFINITE_SHOP:
                if (player.hasPermission(""String_Node_Str"",false)) {
                  player.getPlayer().getInventory().addItem(stack);
                  player.sendMessage(""String_Node_Str"");
                }
 else {
                  player.sendMessage(""String_Node_Str"");
                }
              break;
case FINITE_SHOP:
            if (player.hasPermission(""String_Node_Str"",false)) {
              player.getPlayer().getInventory().addItem(stack);
              showItem.setItemAmount(showItem.getItemAmount() - 1);
              ShowcasePlayer owner=ShowcasePlayer.getPlayer(showItem.getPlayer());
              owner.giveMoney(showItem.getPricePerItem());
              player.sendMessage(""String_Node_Str"" + showItem.getItemAmount());
            }
 else {
              player.sendMessage(""String_Node_Str"");
            }
          break;
      }
    }
 else {
      player.sendMessage(""String_Node_Str"");
    }
  }
 else {
    player.setHasReadPrice(false);
  }
}
}
}
}
}","@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock()) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        return;
      }
      if (event.hasBlock() && showItem == null) {
        if (event.getItem() == null) {
          player.sendMessage(ChatColor.RED + ""String_Node_Str"");
          event.setCancelled(true);
          return;
        }
        if (event.getClickedBlock().getType().equals(Material.GLASS)) {
          event.setCancelled(true);
          if (!isSafePlace(event.getClickedBlock())) {
            player.sendMessage(ChatColor.RED + ""String_Node_Str"");
            return;
          }
          if (player.hasPermission(""String_Node_Str"",false) && !player.hasPermission(""String_Node_Str"",true) && !player.hasPermission(""String_Node_Str"",false)) {
            Location loc=event.getClickedBlock().getLocation();
            Material mat=event.getItem().getType();
            short data=event.getItem().getDurability();
            addShowcase(loc,mat,data,player.getPlayer(),ShowcaseType.BASIC,1,0);
            player.sendMessage(ChatColor.GREEN + ""String_Node_Str"" + mat+ ""String_Node_Str"");
            player.resetDialog();
          }
 else {
            printTypeMenu(event.getPlayer());
            player.setDialogState(1);
            player.setRequestedItem(event.getItem().clone());
            player.setRequestedBlock(event.getClickedBlock());
          }
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName())) {
          showItem.giveItemsBack();
          showItem.remove();
          ShowcaseMain.instance.showcasedItems.remove(showItem);
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
 else {
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"" + showItem.getPlayer()+ ""String_Node_Str"");
        }
        event.setCancelled(true);
      }
    }
 else     if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null && showItem.getType().toString().contains(""String_Node_Str"")) {
        if (!player.hasReadPrice() || !player.standsOnReadPosition()) {
          String print=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getPricePerItem()+ ""String_Node_Str"";
          player.setHasReadPrice(true);
          player.setReadPriceLocation(player.getPlayer().getLocation());
          if (showItem.getType().equals(ShowcaseType.FINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getItemAmount();
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
 else           if (showItem.getType().equals(ShowcaseType.INFINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
          player.sendMessage(print);
        }
 else {
          if (player.standsOnReadPosition()) {
            ItemStack stack=showItem.getItem().getItemStack().clone();
            stack.setAmount(1);
            if (player.withdraw(showItem.getPricePerItem())) {
switch (showItem.getType()) {
case INFINITE_SHOP:
                if (player.hasPermission(""String_Node_Str"",false)) {
                  player.getPlayer().getInventory().addItem(stack);
                  player.sendMessage(""String_Node_Str"");
                }
 else {
                  player.sendMessage(""String_Node_Str"");
                }
              break;
case FINITE_SHOP:
            if (player.hasPermission(""String_Node_Str"",false)) {
              player.getPlayer().getInventory().addItem(stack);
              showItem.setItemAmount(showItem.getItemAmount() - 1);
              ShowcasePlayer owner=ShowcasePlayer.getPlayer(showItem.getPlayer());
              owner.giveMoney(showItem.getPricePerItem());
              player.sendMessage(""String_Node_Str"" + showItem.getItemAmount());
            }
 else {
              player.sendMessage(""String_Node_Str"");
            }
          break;
      }
    }
 else {
      player.sendMessage(""String_Node_Str"");
    }
  }
 else {
    player.setHasReadPrice(false);
  }
}
}
}
}
}"
18964,"public void updatePosition(){
  if (!updatedPosition) {
    item.teleport(location);
    item.setVelocity(new Vector(0,0,0));
    updatedPosition=true;
  }
}","public void updatePosition(){
  if (!updatedPosition || item.getLocation().getY() >= block.getLocation().getBlockY() + 0.5) {
    item.teleport(location);
    item.setVelocity(new Vector(0,0,0));
    updatedPosition=true;
  }
}"
18965,"/** 
 * @param location the location to set
 */
public void setLocation(Location location){
  Vector vec=location.toVector();
  vec.add(new Vector(0.5,0.1,0.5));
  location=vec.toLocation(location.getWorld());
  this.location=location;
  item.teleport(location);
}","/** 
 * @param location the location to set
 */
public void setLocation(Location location){
  Vector vec=location.toVector();
  vec.add(new Vector(0.5,0.0,0.5));
  location=vec.toLocation(location.getWorld());
  this.location=location;
  item.teleport(location);
}"
18966,"@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock()) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        return;
      }
      if (event.getItem() == null) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        event.setCancelled(true);
        return;
      }
      if (event.hasBlock() && event.hasItem() && showItem == null) {
        if (event.getClickedBlock().getType().equals(Material.GLASS)) {
          printTypeMenu(event.getPlayer());
          player.setDialogState(1);
          player.setRequestedItem(event.getItem().clone());
          player.setRequestedBlock(event.getClickedBlock());
          event.setCancelled(true);
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName())) {
          showItem.remove();
          ShowcaseMain.instance.showcasedItems.remove(showItem);
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
 else {
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"" + showItem.getPlayer()+ ""String_Node_Str"");
        }
        event.setCancelled(true);
      }
    }
 else     if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null && showItem.getType().toString().contains(""String_Node_Str"")) {
        if (!player.hasReadPrice() || !player.standsOnReadPosition()) {
          String print=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getPricePerItem()+ ""String_Node_Str"";
          player.setHasReadPrice(true);
          player.setReadPriceLocation(player.getPlayer().getLocation());
          if (showItem.getType().equals(ShowcaseType.FINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getItemAmount();
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
 else           if (showItem.getType().equals(ShowcaseType.INFINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
          player.sendMessage(print);
        }
 else {
          if (player.standsOnReadPosition()) {
            ItemStack stack=showItem.getItem().getItemStack().clone();
            stack.setAmount(1);
switch (showItem.getType()) {
case INFINITE_SHOP:
              if (player.withdraw(showItem.getPricePerItem())) {
                player.getPlayer().getInventory().addItem(stack);
                player.sendMessage(""String_Node_Str"");
              }
            break;
case FINITE_SHOP:
          if (player.withdraw(showItem.getPricePerItem())) {
            player.getPlayer().getInventory().addItem(stack);
            showItem.setItemAmount(showItem.getItemAmount() - 1);
            ShowcasePlayer owner=ShowcasePlayer.getPlayer(showItem.getPlayer());
            owner.giveMoney(showItem.getPricePerItem());
            player.sendMessage(""String_Node_Str"" + showItem.getItemAmount());
          }
        break;
    }
  }
 else {
    player.setHasReadPrice(false);
  }
}
}
}
}
}","@Override public void onPlayerInteract(PlayerInteractEvent event){
  if (event.hasBlock()) {
    ShowcaseItem showItem=ShowcaseMain.instance.getItemByBlock(event.getClickedBlock());
    ShowcasePlayer player=ShowcasePlayer.getPlayer(event.getPlayer());
    if (event.getAction().equals(Action.RIGHT_CLICK_BLOCK)) {
      if (!event.getPlayer().isSneaking()) {
        return;
      }
      if (event.getItem() == null) {
        player.sendMessage(ChatColor.RED + ""String_Node_Str"");
        event.setCancelled(true);
        return;
      }
      if (event.hasBlock() && event.hasItem() && showItem == null) {
        if (event.getClickedBlock().getType().equals(Material.GLASS)) {
          printTypeMenu(event.getPlayer());
          player.setDialogState(1);
          player.setRequestedItem(event.getItem().clone());
          player.setRequestedBlock(event.getClickedBlock());
          event.setCancelled(true);
        }
      }
 else       if (showItem != null) {
        if (showItem.getPlayer().equals(event.getPlayer().getName())) {
          showItem.remove();
          ShowcaseMain.instance.showcasedItems.remove(showItem);
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"");
        }
 else {
          event.getPlayer().sendMessage(ChatColor.RED + ""String_Node_Str"" + showItem.getPlayer()+ ""String_Node_Str"");
        }
        event.setCancelled(true);
      }
    }
 else     if (event.getAction().equals(Action.LEFT_CLICK_BLOCK)) {
      if (showItem != null && showItem.getType().toString().contains(""String_Node_Str"")) {
        if (!player.hasReadPrice() || !player.standsOnReadPosition()) {
          String print=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getPricePerItem()+ ""String_Node_Str"";
          player.setHasReadPrice(true);
          player.setReadPriceLocation(player.getPlayer().getLocation());
          if (showItem.getType().equals(ShowcaseType.FINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"" + ChatColor.WHITE+ showItem.getItemAmount();
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
 else           if (showItem.getType().equals(ShowcaseType.INFINITE_SHOP)) {
            print+=ChatColor.YELLOW + ""String_Node_Str"";
          }
          player.sendMessage(print);
        }
 else {
          if (player.standsOnReadPosition()) {
            ItemStack stack=showItem.getItem().getItemStack().clone();
            stack.setAmount(1);
            if (player.withdraw(showItem.getPricePerItem())) {
switch (showItem.getType()) {
case INFINITE_SHOP:
                player.getPlayer().getInventory().addItem(stack);
              player.sendMessage(""String_Node_Str"");
            break;
case FINITE_SHOP:
          player.getPlayer().getInventory().addItem(stack);
        showItem.setItemAmount(showItem.getItemAmount() - 1);
      ShowcasePlayer owner=ShowcasePlayer.getPlayer(showItem.getPlayer());
    owner.giveMoney(showItem.getPricePerItem());
  player.sendMessage(""String_Node_Str"" + showItem.getItemAmount());
break;
}
}
 else {
player.sendMessage(""String_Node_Str"");
}
}
 else {
player.setHasReadPrice(false);
}
}
}
}
}
}"
18967,"@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit){
  return super.scheduleAtFixedRate(wrapRunnable(command),initialDelay,period,unit);
}","@Override public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit){
  return super.scheduleAtFixedRate(WrappedRunnable.wrap(LOG,command),initialDelay,period,unit);
}"
18968,"@Override public ScheduledFuture<?> schedule(Runnable command,long delay,TimeUnit unit){
  return super.schedule(wrapRunnable(command),delay,unit);
}","@Override public ScheduledFuture<?> schedule(Runnable command,long delay,TimeUnit unit){
  return super.schedule(WrappedRunnable.wrap(LOG,command),delay,unit);
}"
18969,"@Override public Future<?> submit(Runnable task){
  return super.submit(wrapRunnable(task));
}","@Override public Future<?> submit(Runnable task){
  return super.submit(WrappedRunnable.wrap(LOG,task));
}"
18970,"@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit){
  return super.scheduleWithFixedDelay(wrapRunnable(command),initialDelay,delay,unit);
}","@Override public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit){
  return super.scheduleWithFixedDelay(WrappedRunnable.wrap(LOG,command),initialDelay,delay,unit);
}"
18971,"@Override public void execute(Runnable command){
  super.execute(wrapRunnable(command));
}","@Override public void execute(Runnable command){
  super.execute(WrappedRunnable.wrap(LOG,command));
}"
18972,"@Override public Future<?> submit(Runnable task){
  return super.submit(wrapRunnable(task));
}","@Override public Future<?> submit(Runnable task){
  return super.submit(WrappedRunnable.wrap(LOG,task));
}"
18973,"@Override public void execute(Runnable command){
  super.execute(wrapRunnable(command));
}","@Override public void execute(Runnable command){
  super.execute(WrappedRunnable.wrap(LOG,command));
}"
18974,"/** 
 * Set the menu's autosave status - will menus be automatically saved to disk when modified?
 * @param autosave	true or false
 * @return			the previous autosave status - true or false
 * @deprecated method is a no-op now, autosave is always true
 */
@Deprecated public boolean setAutosave(boolean autosave){
  return true;
}","/** 
 * Set the menu's autosave status - will menus be automatically saved to disk when modified?
 * @param autosave	true or false
 * @return			the previous autosave status - true or false
 */
public boolean setAutosave(boolean autosave){
  boolean prevAutosave=this.autosave;
  this.autosave=autosave;
  if (autosave) {
    autosave();
  }
  return prevAutosave;
}"
18975,"public void setAttribute(String k,String val) throws SMSException {
  if (!attributes.contains(k)) {
    throw new SMSException(""String_Node_Str"" + k);
  }
  attributes.set(k,val);
}","public void setAttribute(String k,String val){
  if (!attributes.contains(k)) {
    throw new SMSException(""String_Node_Str"" + k);
  }
  attributes.set(k,val);
}"
18976,"/** 
 * Temporarily delete a menu.  The menu object is dereferenced but saved menu data is not  deleted from disk.
 */
void deleteTemporary(){
  try {
    SMSMenu.unregisterMenu(getName());
    notifyObservers(SMSMenuAction.DELETE_TEMP);
  }
 catch (  SMSException e) {
    LogUtils.warning(""String_Node_Str"");
  }
}","/** 
 * Temporarily delete a menu.  The menu object is dereferenced but saved menu data is not  deleted from disk.
 */
void deleteTemporary(){
  try {
    SMSMenu.unregisterMenu(getName());
    notifyObservers(SMSMenuAction.DELETE_TEMP);
  }
 catch (  SMSException e) {
    LogUtils.warning(""String_Node_Str"" + e.getMessage());
  }
}"
18977,"/** 
 * Retrieve the menu with the given name
 * @param menuName	The name of the menu to retrieve
 * @return	The menu object
 * @throws SMSException if the menu name is not found
 */
public static SMSMenu getMenu(String menuName) throws SMSException {
  if (!menus.containsKey(menuName))   throw new SMSException(""String_Node_Str"" + menuName + ""String_Node_Str"");
  return menus.get(menuName);
}","/** 
 * Retrieve the menu with the given name.
 * @param menuName	The name of the menu to retrieve
 * @return	The menu object
 * @throws SMSException if the menu name is not found
 */
public static SMSMenu getMenu(String menuName){
  if (!menus.containsKey(menuName))   throw new SMSException(""String_Node_Str"" + menuName + ""String_Node_Str"");
  return menus.get(menuName);
}"
18978,"public void autosave(){
  if (SMSMenu.checkForMenu(getName()))   SMSPersistence.save(this);
}","public void autosave(){
  if (SMSMenu.checkForMenu(getName()) && isAutosave()) {
    SMSPersistence.save(this);
  }
}"
18979,"/** 
 * Remove a menu from the list, destroying the reference to it.
 * @param menuName	The menu's name
 * @param action	Action to take on removal
 * @throws SMSException
 */
static void unregisterMenu(String menuName) throws SMSException {
  menus.remove(menuName);
}","/** 
 * Remove a menu from the list, destroying the reference to it.
 * @param menuName	The menu's name
 * @param action	Action to take on removal
 * @throws SMSException
 */
static void unregisterMenu(String menuName){
  deletedMenus.put(menuName,getMenu(menuName));
  menus.remove(menuName);
}"
18980,"/** 
 * Get the menu's autosave status - will menus be automatically saved to disk when modified?
 * @return	true or false
 * @deprecated always true now, not necessary to use anymore
 */
@Deprecated public boolean isAutosave(){
  return true;
}","/** 
 * Get the menu's autosave status - will menus be automatically saved to disk when modified?
 * @return	true or false
 */
public boolean isAutosave(){
  return autosave;
}"
18981,"/** 
 * Get the menu at the given location
 * @param loc	The location
 * @return	The menu object
 * @throws SMSException if there is no menu sign at the location
 */
static SMSMenu getMenuAt(Location loc) throws SMSException {
  return getMenu(getMenuNameAt(loc));
}","/** 
 * Get the menu at the given location
 * @param loc	The location
 * @return	The menu object
 * @throws SMSException if there is no menu sign at the location
 */
static SMSMenu getMenuAt(Location loc){
  return getMenu(getMenuNameAt(loc));
}"
18982,"/** 
 * Cause the views on all menus to be redrawn
 */
public static void updateAllMenus(){
  for (  SMSMenu menu : listMenus()) {
    menu.notifyObservers(SMSMenuAction.REPAINT);
  }
}","/** 
 * Force the views on all menus to be redrawn.
 */
public static void updateAllMenus(){
  for (  SMSMenu menu : listMenus()) {
    menu.notifyObservers(SMSMenuAction.REPAINT);
  }
}"
18983,"/** 
 * Construct a new menu from data read from the save file
 * @param node 		A ConfigurationSection containing the menu's properties
 * @throws SMSException If there is already a menu at this location
 */
@SuppressWarnings(""String_Node_Str"") SMSMenu(ConfigurationSection node) throws SMSException {
  SMSPersistence.mustHaveField(node,""String_Node_Str"");
  SMSPersistence.mustHaveField(node,""String_Node_Str"");
  SMSPersistence.mustHaveField(node,""String_Node_Str"");
  this.name=node.getString(""String_Node_Str"");
  this.uses=new SMSRemainingUses(this,node.getConfigurationSection(""String_Node_Str""));
  this.attributes=new AttributeCollection(this);
  registerAttributes();
  for (  String k : node.getKeys(false)) {
    if (!node.isConfigurationSection(k) && attributes.hasAttribute(k)) {
      setAttribute(k,node.getString(k));
    }
  }
  String owner=attributes.get(OWNER).toString();
  if (owner.equals(""String_Node_Str"")) {
    setAttribute(OWNER,CONSOLE_OWNER);
  }
  List<Map<String,Object>> items=(List<Map<String,Object>>)node.getList(""String_Node_Str"");
  for (  Map<String,Object> item : items) {
    MemoryConfiguration itemNode=new MemoryConfiguration();
    SMSPersistence.expandMapIntoConfig(itemNode,item);
    SMSMenuItem menuItem=new SMSMenuItem(this,itemNode);
    SMSMenuItem actual=menuItem.uniqueItem();
    if (!actual.getLabel().equals(menuItem.getLabel()))     LogUtils.warning(""String_Node_Str"" + getName() + ""String_Node_Str""+ menuItem.getLabelStripped()+ ""String_Node_Str""+ actual.getLabelStripped()+ ""String_Node_Str"");
    addItem(actual);
  }
}","/** 
 * Construct a new menu from data read from the save file
 * @param node 		A ConfigurationSection containing the menu's properties
 * @throws SMSException If there is already a menu at this location
 */
@SuppressWarnings(""String_Node_Str"") SMSMenu(ConfigurationSection node){
  SMSPersistence.mustHaveField(node,""String_Node_Str"");
  SMSPersistence.mustHaveField(node,""String_Node_Str"");
  SMSPersistence.mustHaveField(node,""String_Node_Str"");
  this.name=node.getString(""String_Node_Str"");
  this.uses=new SMSRemainingUses(this,node.getConfigurationSection(""String_Node_Str""));
  this.attributes=new AttributeCollection(this);
  registerAttributes();
  for (  String k : node.getKeys(false)) {
    if (!node.isConfigurationSection(k) && attributes.hasAttribute(k)) {
      setAttribute(k,node.getString(k));
    }
  }
  String owner=attributes.get(OWNER).toString();
  if (owner.equals(""String_Node_Str"")) {
    setAttribute(OWNER,ScrollingMenuSign.CONSOLE_OWNER);
  }
  List<Map<String,Object>> items=(List<Map<String,Object>>)node.getList(""String_Node_Str"");
  for (  Map<String,Object> item : items) {
    MemoryConfiguration itemNode=new MemoryConfiguration();
    SMSPersistence.expandMapIntoConfig(itemNode,item);
    SMSMenuItem menuItem=new SMSMenuItem(this,itemNode);
    SMSMenuItem actual=menuItem.uniqueItem();
    if (!actual.getLabel().equals(menuItem.getLabel()))     LogUtils.warning(""String_Node_Str"" + getName() + ""String_Node_Str""+ menuItem.getLabelStripped()+ ""String_Node_Str""+ actual.getLabelStripped()+ ""String_Node_Str"");
    addItem(actual);
  }
}"
18984,"/** 
 * Permanently delete a menu, dereferencing the object and removing saved data from disk.
 */
void deletePermanent(){
  try {
    setChanged();
    notifyObservers(SMSMenuAction.DELETE_PERM);
    SMSMenu.unregisterMenu(getName());
    SMSPersistence.unPersist(this);
  }
 catch (  SMSException e) {
    LogUtils.warning(""String_Node_Str"");
  }
}","/** 
 * Permanently delete a menu, dereferencing the object and removing saved data from disk.
 */
void deletePermanent(){
  try {
    setChanged();
    notifyObservers(SMSMenuAction.DELETE_PERM);
    SMSMenu.unregisterMenu(getName());
    SMSPersistence.unPersist(this);
  }
 catch (  SMSException e) {
    LogUtils.warning(""String_Node_Str"" + e.getMessage());
  }
}"
18985,"private void registerCommands(){
  cmds.registerCommand(new AddItemCommand());
  cmds.registerCommand(new AddMacroCommand());
  cmds.registerCommand(new AddViewCommand());
  cmds.registerCommand(new CreateMenuCommand());
  cmds.registerCommand(new DeleteMenuCommand());
  cmds.registerCommand(new EditMenuCommand());
  cmds.registerCommand(new FontCommand());
  cmds.registerCommand(new GetConfigCommand());
  cmds.registerCommand(new GiveCommand());
  cmds.registerCommand(new ItemUseCommand());
  cmds.registerCommand(new ListMacroCommand());
  cmds.registerCommand(new ListMenusCommand());
  cmds.registerCommand(new MenuCommand());
  cmds.registerCommand(new PageCommand());
  cmds.registerCommand(new ReloadCommand());
  cmds.registerCommand(new RemoveItemCommand());
  cmds.registerCommand(new RemoveMacroCommand());
  cmds.registerCommand(new RemoveViewCommand());
  cmds.registerCommand(new SaveCommand());
  cmds.registerCommand(new SetConfigCommand());
  cmds.registerCommand(new VarCommand());
  cmds.registerCommand(new ViewCommand());
}","private void registerCommands(){
  cmds.registerCommand(new AddItemCommand());
  cmds.registerCommand(new AddMacroCommand());
  cmds.registerCommand(new AddViewCommand());
  cmds.registerCommand(new CreateMenuCommand());
  cmds.registerCommand(new DeleteMenuCommand());
  cmds.registerCommand(new EditMenuCommand());
  cmds.registerCommand(new FontCommand());
  cmds.registerCommand(new GetConfigCommand());
  cmds.registerCommand(new GiveCommand());
  cmds.registerCommand(new ItemUseCommand());
  cmds.registerCommand(new ListMacroCommand());
  cmds.registerCommand(new ListMenusCommand());
  cmds.registerCommand(new MenuCommand());
  cmds.registerCommand(new PageCommand());
  cmds.registerCommand(new ReloadCommand());
  cmds.registerCommand(new RemoveItemCommand());
  cmds.registerCommand(new RemoveMacroCommand());
  cmds.registerCommand(new RemoveViewCommand());
  cmds.registerCommand(new SaveCommand());
  cmds.registerCommand(new SetConfigCommand());
  cmds.registerCommand(new UndeleteMenuCommand());
  cmds.registerCommand(new VarCommand());
  cmds.registerCommand(new ViewCommand());
}"
18986,"@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args){
  String menuName=args[0];
  SMSMenu menu=SMSMenu.getMenu(menuName);
  if (args.length < 3 && menu.getDefaultCommand().isEmpty()) {
    throw new SMSException(getUsage()[0]);
  }
  menu.ensureAllowedToModify(sender);
  int pos=hasOption(""String_Node_Str"") ? getIntOption(""String_Node_Str"") : -1;
  String label=MiscUtil.parseColourSpec(sender,args[1]);
  String cmd=args.length >= 3 ? args[2] : ""String_Node_Str"";
  String msg=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : ""String_Node_Str"";
  String iconMat=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : plugin.getConfig().getString(""String_Node_Str"",""String_Node_Str"");
  String[] lore=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"").split(""String_Node_Str"") : new String[0];
  if (sender instanceof Player && !new CommandParser().verifyCreationPerms((Player)sender,cmd)) {
    throw new SMSException(""String_Node_Str"");
  }
  SMSMenuItem newItem=new SMSMenuItem(menu,label,cmd,msg,iconMat,lore);
  if (pos < 0) {
    menu.addItem(newItem);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menuName);
  }
 else {
    menu.insertItem(pos,newItem);
    int actualPos=menu.indexOfItem(label);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menuName+ ""String_Node_Str""+ actualPos);
  }
  menu.notifyObservers(SMSMenuAction.REPAINT);
  return true;
}","@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args){
  String menuName=args[0];
  SMSMenu menu=getMenu(sender,menuName);
  if (args.length < 3 && menu.getDefaultCommand().isEmpty()) {
    throw new SMSException(getUsage()[0]);
  }
  menu.ensureAllowedToModify(sender);
  int pos=hasOption(""String_Node_Str"") ? getIntOption(""String_Node_Str"") : -1;
  String label=MiscUtil.parseColourSpec(sender,args[1]);
  String cmd=args.length >= 3 ? args[2] : ""String_Node_Str"";
  String msg=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : ""String_Node_Str"";
  String iconMat=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : plugin.getConfig().getString(""String_Node_Str"",""String_Node_Str"");
  String[] lore=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"").split(""String_Node_Str"") : new String[0];
  if (sender instanceof Player && !new CommandParser().verifyCreationPerms((Player)sender,cmd)) {
    throw new SMSException(""String_Node_Str"");
  }
  SMSMenuItem newItem=new SMSMenuItem(menu,label,cmd,msg,iconMat,lore);
  if (pos < 0) {
    menu.addItem(newItem);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menu.getName());
  }
 else {
    menu.insertItem(pos,newItem);
    int actualPos=menu.indexOfItem(label);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menu.getName()+ ""String_Node_Str""+ actualPos);
  }
  menu.notifyObservers(SMSMenuAction.REPAINT);
  return true;
}"
18987,"@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args) throws SMSException {
  ScrollingMenuSign smsPlugin=(ScrollingMenuSign)plugin;
  SMSView view=null;
  SMSMenu menu=SMSMenu.getMenu(args[0]);
  String viewName=getStringOption(""String_Node_Str"");
  Location loc=hasOption(""String_Node_Str"") ? MiscUtil.parseLocation(getStringOption(""String_Node_Str"")) : null;
  if (hasOption(""String_Node_Str"")) {
    if (smsPlugin.isSpoutEnabled())     view=SMSSpoutView.addSpoutViewToMenu(viewName,menu);
 else     throw new SMSException(""String_Node_Str"");
  }
 else   if (hasOption(""String_Node_Str"")) {
    if (loc == null) {
      interactiveCreation(sender,viewName,menu,""String_Node_Str"");
      return true;
    }
 else {
      view=SMSSignView.addSignToMenu(viewName,menu,loc);
    }
  }
 else   if (hasOption(""String_Node_Str"")) {
    if (loc == null) {
      interactiveCreation(sender,viewName,menu,""String_Node_Str"");
      return true;
    }
 else {
      view=SMSRedstoneView.addRedstoneViewToMenu(viewName,menu,loc);
    }
  }
 else   if (hasOption(""String_Node_Str"") || hasOption(""String_Node_Str"")) {
    view=SMSInventoryView.addInventoryViewToMenu(viewName,menu);
  }
 else   if (hasOption(""String_Node_Str"") && loc != null) {
    view=SMSMultiSignView.addSignToMenu(viewName,menu,loc);
  }
 else   if (hasOption(""String_Node_Str"")) {
    try {
      short mapId=(short)getIntOption(""String_Node_Str"");
      view=SMSMapView.addMapToMenu(viewName,menu,mapId);
    }
 catch (    NumberFormatException e) {
      throw new SMSException(e.getMessage());
    }
  }
 else   if (args.length > 1) {
    throw new SMSException(""String_Node_Str"" + args[1]);
  }
  if (view == null) {
    notFromConsole(sender);
    Player player=(Player)sender;
    if (player.getItemInHand().getType() == Material.MAP) {
      PermissionUtils.requirePerms(sender,""String_Node_Str"");
      short mapId=player.getItemInHand().getDurability();
      view=SMSMapView.addMapToMenu(viewName,menu,mapId);
      ((SMSMapView)view).setMapItemName(player.getItemInHand());
    }
 else {
      try {
        Block b=player.getTargetBlock(null,ScrollingMenuSign.BLOCK_TARGET_DIST);
        if (hasOption(""String_Node_Str"") && b.getType() == Material.WALL_SIGN) {
          view=SMSMultiSignView.addSignToMenu(viewName,menu,b.getLocation());
        }
 else         if (b.getType() == Material.WALL_SIGN || b.getType() == Material.SIGN_POST) {
          view=SMSSignView.addSignToMenu(viewName,menu,b.getLocation());
        }
      }
 catch (      IllegalStateException e) {
      }
    }
  }
  if (view != null) {
    MiscUtil.statusMessage(sender,String.format(""String_Node_Str"",view.getType(),view.getName(),menu.getName()));
  }
 else {
    throw new SMSException(""String_Node_Str"");
  }
  return true;
}","@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args) throws SMSException {
  ScrollingMenuSign smsPlugin=(ScrollingMenuSign)plugin;
  SMSView view=null;
  SMSMenu menu=SMSMenu.getMenu(args[0]);
  String viewName=getStringOption(""String_Node_Str"");
  Location loc=hasOption(""String_Node_Str"") ? MiscUtil.parseLocation(getStringOption(""String_Node_Str"")) : null;
  if (hasOption(""String_Node_Str"")) {
    if (smsPlugin.isSpoutEnabled())     view=SMSSpoutView.addSpoutViewToMenu(viewName,menu,sender);
 else     throw new SMSException(""String_Node_Str"");
  }
 else   if (hasOption(""String_Node_Str"")) {
    if (loc == null) {
      interactiveCreation(sender,viewName,menu,""String_Node_Str"");
      return true;
    }
 else {
      view=SMSSignView.addSignToMenu(viewName,menu,loc,sender);
    }
  }
 else   if (hasOption(""String_Node_Str"")) {
    if (loc == null) {
      interactiveCreation(sender,viewName,menu,""String_Node_Str"");
      return true;
    }
 else {
      view=SMSRedstoneView.addRedstoneViewToMenu(viewName,menu,loc,sender);
    }
  }
 else   if (hasOption(""String_Node_Str"") || hasOption(""String_Node_Str"")) {
    view=SMSInventoryView.addInventoryViewToMenu(viewName,menu,sender);
  }
 else   if (hasOption(""String_Node_Str"") && loc != null) {
    view=SMSMultiSignView.addSignToMenu(viewName,menu,loc,sender);
  }
 else   if (hasOption(""String_Node_Str"")) {
    try {
      short mapId=(short)getIntOption(""String_Node_Str"");
      view=SMSMapView.addMapToMenu(viewName,menu,mapId,sender);
    }
 catch (    NumberFormatException e) {
      throw new SMSException(e.getMessage());
    }
  }
 else   if (args.length > 1) {
    throw new SMSException(""String_Node_Str"" + args[1]);
  }
  if (view == null) {
    notFromConsole(sender);
    Player player=(Player)sender;
    if (player.getItemInHand().getType() == Material.MAP) {
      PermissionUtils.requirePerms(sender,""String_Node_Str"");
      short mapId=player.getItemInHand().getDurability();
      view=SMSMapView.addMapToMenu(viewName,menu,mapId,sender);
      ((SMSMapView)view).setMapItemName(player.getItemInHand());
    }
 else {
      try {
        Block b=player.getTargetBlock(null,ScrollingMenuSign.BLOCK_TARGET_DIST);
        if (hasOption(""String_Node_Str"") && b.getType() == Material.WALL_SIGN) {
          view=SMSMultiSignView.addSignToMenu(viewName,menu,b.getLocation(),sender);
        }
 else         if (b.getType() == Material.WALL_SIGN || b.getType() == Material.SIGN_POST) {
          view=SMSSignView.addSignToMenu(viewName,menu,b.getLocation(),sender);
        }
      }
 catch (      IllegalStateException e) {
      }
    }
  }
  if (view != null) {
    MiscUtil.statusMessage(sender,String.format(""String_Node_Str"",view.getType(),view.getName(),menu.getName()));
  }
 else {
    throw new SMSException(""String_Node_Str"");
  }
  return true;
}"
18988,"@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args) throws SMSException {
  String menuName=args[0];
  ScrollingMenuSign smsPlugin=(ScrollingMenuSign)plugin;
  SMSHandler handler=smsPlugin.getHandler();
  if (handler.checkMenu(menuName)) {
    throw new SMSException(""String_Node_Str"" + menuName + ""String_Node_Str"");
  }
  Location signLoc=null;
  short mapId=-1;
  String owner=null;
  boolean autoCreateView=ScrollingMenuSign.getInstance().getConfig().getBoolean(""String_Node_Str"");
  if (autoCreateView && sender instanceof Player) {
    Player player=(Player)sender;
    owner=sender.getName();
    Block b=null;
    try {
      b=player.getTargetBlock(null,ScrollingMenuSign.BLOCK_TARGET_DIST);
    }
 catch (    IllegalStateException e) {
    }
    if (b != null && (b.getType() == Material.SIGN_POST || b.getType() == Material.WALL_SIGN)) {
      if (handler.getMenuNameAt(b.getLocation()) == null) {
        PermissionUtils.requirePerms(sender,""String_Node_Str"");
        signLoc=b.getLocation();
      }
    }
 else     if (player.getItemInHand().getType() == Material.MAP) {
      short id=player.getItemInHand().getDurability();
      if (!SMSMapView.checkForMapId(id)) {
        PermissionUtils.requirePerms(sender,""String_Node_Str"");
        mapId=id;
      }
    }
  }
  String menuTitle=MiscUtil.parseColourSpec(sender,combine(args,1));
  SMSMenu menu=handler.createMenu(menuName,menuTitle,owner);
  if (signLoc != null) {
    SMSSignView.addSignToMenu(menu,signLoc);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + menuName + ""String_Node_Str""+ MiscUtil.formatLocation(signLoc));
  }
 else   if (mapId >= 0) {
    SMSMapView mapView=SMSMapView.addMapToMenu(menu,mapId);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + menuName + ""String_Node_Str""+ mapId);
    Player player=(Player)sender;
    mapView.setMapItemName(player.getItemInHand());
  }
 else {
    MiscUtil.statusMessage(sender,""String_Node_Str"" + menuName + ""String_Node_Str"");
  }
  return true;
}","@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args) throws SMSException {
  String menuName=args[0];
  ScrollingMenuSign smsPlugin=(ScrollingMenuSign)plugin;
  SMSHandler handler=smsPlugin.getHandler();
  if (handler.checkMenu(menuName)) {
    throw new SMSException(""String_Node_Str"" + menuName + ""String_Node_Str"");
  }
  Location signLoc=null;
  short mapId=-1;
  String owner=null;
  boolean autoCreateView=ScrollingMenuSign.getInstance().getConfig().getBoolean(""String_Node_Str"");
  if (autoCreateView && sender instanceof Player) {
    Player player=(Player)sender;
    owner=sender.getName();
    Block b=null;
    try {
      b=player.getTargetBlock(null,ScrollingMenuSign.BLOCK_TARGET_DIST);
    }
 catch (    IllegalStateException e) {
    }
    if (b != null && (b.getType() == Material.SIGN_POST || b.getType() == Material.WALL_SIGN)) {
      if (handler.getMenuNameAt(b.getLocation()) == null) {
        PermissionUtils.requirePerms(sender,""String_Node_Str"");
        signLoc=b.getLocation();
      }
    }
 else     if (player.getItemInHand().getType() == Material.MAP) {
      short id=player.getItemInHand().getDurability();
      if (!SMSMapView.checkForMapId(id) && !SMSMapView.usedByOtherPlugin(id)) {
        PermissionUtils.requirePerms(sender,""String_Node_Str"");
        mapId=id;
      }
    }
  }
  String menuTitle=MiscUtil.parseColourSpec(sender,combine(args,1));
  SMSMenu menu=handler.createMenu(menuName,menuTitle,owner);
  if (signLoc != null) {
    SMSSignView.addSignToMenu(menu,signLoc,sender);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + menuName + ""String_Node_Str""+ MiscUtil.formatLocation(signLoc));
  }
 else   if (mapId >= 0) {
    SMSMapView mapView=SMSMapView.addMapToMenu(menu,mapId,sender);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + menuName + ""String_Node_Str""+ mapId);
    Player player=(Player)sender;
    mapView.setMapItemName(player.getItemInHand());
  }
 else {
    MiscUtil.statusMessage(sender,""String_Node_Str"" + menuName + ""String_Node_Str"");
  }
  return true;
}"
18989,"@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args) throws SMSException {
  SMSHandler handler=((ScrollingMenuSign)plugin).getHandler();
  SMSMenu menu=null;
  if (args.length > 0) {
    menu=handler.getMenu(args[0]);
  }
 else {
    notFromConsole(sender);
    Player player=(Player)sender;
    SMSView view=SMSView.getTargetedView(player,true);
    menu=view.getActiveMenu(player.getName());
  }
  menu.ensureAllowedToModify(sender);
  handler.deleteMenu(menu.getName());
  MiscUtil.statusMessage(sender,""String_Node_Str"" + menu.getName());
  return true;
}","@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args) throws SMSException {
  SMSHandler handler=((ScrollingMenuSign)plugin).getHandler();
  SMSMenu menu=null;
  if (args.length > 0) {
    menu=getMenu(sender,args[0]);
  }
 else {
    notFromConsole(sender);
    Player player=(Player)sender;
    SMSView view=SMSView.getTargetedView(player,true);
    menu=view.getActiveMenu(player.getName());
  }
  menu.ensureAllowedToModify(sender);
  handler.deleteMenu(menu.getName());
  MiscUtil.statusMessage(sender,""String_Node_Str"" + menu.getName() + ""String_Node_Str""+ menu.getName()+ ""String_Node_Str"");
  return true;
}"
18990,"@Override public List<String> onTabComplete(Plugin plugin,CommandSender sender,String[] args){
switch (args.length) {
case 1:
    return getMenuCompletions(plugin,sender,args[0]);
case 2:
  SMSMenu menu=SMSMenu.getMenu(args[0]);
return getMenuItemCompletions(sender,menu,args[1]);
default :
showUsage(sender);
return noCompletions(sender);
}
}","@Override public List<String> onTabComplete(Plugin plugin,CommandSender sender,String[] args){
switch (args.length) {
case 1:
    return getMenuCompletions(plugin,sender,args[0]);
case 2:
  SMSMenu menu=getMenu(sender,args[0]);
return getMenuItemCompletions(sender,menu,args[1]);
default :
showUsage(sender);
return noCompletions(sender);
}
}"
18991,"@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args){
  SMSMenu menu=SMSMenu.getMenu(args[0]);
  menu.ensureAllowedToModify(sender);
  int pos=0;
  if (args[1].startsWith(""String_Node_Str"")) {
    try {
      pos=Integer.parseInt(args[1].substring(1));
    }
 catch (    NumberFormatException e) {
      throw new SMSException(e.getMessage() + ""String_Node_Str"");
    }
  }
 else {
    pos=menu.indexOfItem(args[1]);
  }
  SMSMenuItem currentItem=menu.getItemAt(pos,true);
  String label=hasOption(""String_Node_Str"") ? MiscUtil.parseColourSpec(getStringOption(""String_Node_Str"")) : currentItem.getLabel();
  String command=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : currentItem.getCommand();
  String message=hasOption(""String_Node_Str"") ? MiscUtil.parseColourSpec(getStringOption(""String_Node_Str"")) : currentItem.getMessage();
  String iconMat=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : currentItem.getIconMaterial().toString();
  List<String> lore=currentItem.getLoreAsList();
  if (hasOption(""String_Node_Str"")) {
    String l=getStringOption(""String_Node_Str"");
    String l1;
    if (l.startsWith(""String_Node_Str"") && l.length() > 1) {
      l1=l.substring(1);
    }
 else {
      lore.clear();
      l1=l;
    }
    if (!l1.isEmpty()) {
      for (      String s : l1.split(""String_Node_Str"")) {
        lore.add(s);
      }
    }
  }
  if (!command.isEmpty() && sender instanceof Player && !new CommandParser().verifyCreationPerms((Player)sender,command)) {
    throw new SMSException(""String_Node_Str"");
  }
  SMSMenuItem newItem=new SMSMenuItem(menu,label,command,message,iconMat,lore.toArray(new String[lore.size()]));
  newItem.setUseLimits(currentItem.getUseLimits());
  if (hasOption(""String_Node_Str"")) {
    int newPos=getIntOption(""String_Node_Str"");
    if (newPos < 1 || newPos > menu.getItemCount()) {
      throw new SMSException(""String_Node_Str"" + newPos);
    }
    menu.removeItem(pos);
    menu.insertItem(newPos,newItem);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menu.getName()+ ""String_Node_Str""+ newPos);
  }
 else {
    menu.replaceItem(pos,newItem);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menu.getName()+ ""String_Node_Str""+ pos);
  }
  menu.notifyObservers(SMSMenuAction.REPAINT);
  return true;
}","@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args){
  SMSMenu menu=getMenu(sender,args[0]);
  menu.ensureAllowedToModify(sender);
  int pos=0;
  if (args[1].startsWith(""String_Node_Str"")) {
    try {
      pos=Integer.parseInt(args[1].substring(1));
    }
 catch (    NumberFormatException e) {
      throw new SMSException(e.getMessage() + ""String_Node_Str"");
    }
  }
 else {
    pos=menu.indexOfItem(args[1]);
  }
  SMSMenuItem currentItem=menu.getItemAt(pos,true);
  String label=hasOption(""String_Node_Str"") ? MiscUtil.parseColourSpec(getStringOption(""String_Node_Str"")) : currentItem.getLabel();
  String command=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : currentItem.getCommand();
  String message=hasOption(""String_Node_Str"") ? MiscUtil.parseColourSpec(getStringOption(""String_Node_Str"")) : currentItem.getMessage();
  String iconMat=hasOption(""String_Node_Str"") ? getStringOption(""String_Node_Str"") : currentItem.getIconMaterial().toString();
  List<String> lore=currentItem.getLoreAsList();
  if (hasOption(""String_Node_Str"")) {
    String l=getStringOption(""String_Node_Str"");
    String l1;
    if (l.startsWith(""String_Node_Str"") && l.length() > 1) {
      l1=l.substring(1);
    }
 else {
      lore.clear();
      l1=l;
    }
    if (!l1.isEmpty()) {
      for (      String s : l1.split(""String_Node_Str"")) {
        lore.add(s);
      }
    }
  }
  if (!command.isEmpty() && sender instanceof Player && !new CommandParser().verifyCreationPerms((Player)sender,command)) {
    throw new SMSException(""String_Node_Str"");
  }
  SMSMenuItem newItem=new SMSMenuItem(menu,label,command,message,iconMat,lore.toArray(new String[lore.size()]));
  newItem.setUseLimits(currentItem.getUseLimits());
  if (hasOption(""String_Node_Str"")) {
    int newPos=getIntOption(""String_Node_Str"");
    if (newPos < 1 || newPos > menu.getItemCount()) {
      throw new SMSException(""String_Node_Str"" + newPos);
    }
    menu.removeItem(pos);
    menu.insertItem(newPos,newItem);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menu.getName()+ ""String_Node_Str""+ newPos);
  }
 else {
    menu.replaceItem(pos,newItem);
    MiscUtil.statusMessage(sender,""String_Node_Str"" + label + ""String_Node_Str""+ menu.getName()+ ""String_Node_Str""+ pos);
  }
  menu.notifyObservers(SMSMenuAction.REPAINT);
  return true;
}"
18992,"@Override public void pushMenu(String playerName,SMSMenu newActive){
  super.pushMenu(playerName,newActive);
  String menuName=newActive.getName();
  if (playersUsing(menuName).isEmpty()) {
    iconMenus.put(menuName,new IconMenu(this));
  }
  playersUsing(menuName).add(playerName);
}","@Override public void pushMenu(String playerName,SMSMenu newActive){
  super.pushMenu(playerName,newActive);
  String menuName=newActive.getName();
  if (playersUsing(menuName).isEmpty()) {
    iconMenus.put(menuName,new IconMenu(this,menuName));
  }
  playersUsing(menuName).add(playerName);
}"
18993,"public SMSInventoryView(String name,SMSMenu menu){
  super(name,menu);
  registerAttribute(WIDTH,9,""String_Node_Str"");
  registerAttribute(AUTOPOPDOWN,true,""String_Node_Str"");
  iconMenus=new HashMap<String,IconMenu>();
  iconMenus.put(getNativeMenu().getName(),new IconMenu(this));
  users=new HashMap<String,Set<String>>();
}","public SMSInventoryView(String name,SMSMenu menu){
  super(name,menu);
  registerAttribute(WIDTH,9,""String_Node_Str"");
  registerAttribute(AUTOPOPDOWN,true,""String_Node_Str"");
  iconMenus=new HashMap<String,IconMenu>();
  iconMenus.put(getNativeMenu().getName(),new IconMenu(this,getNativeMenu().getName()));
  users=new HashMap<String,Set<String>>();
}"
18994,"public IconMenu(SMSInventoryView view){
  this.view=view;
  Bukkit.getPluginManager().registerEvents(this,ScrollingMenuSign.getInstance());
}","public IconMenu(SMSInventoryView view,String menuName){
  this.view=view;
  this.menuName=menuName;
  LogUtils.fine(""String_Node_Str"" + this + ""String_Node_Str""+ view.getName());
  Bukkit.getPluginManager().registerEvents(this,ScrollingMenuSign.getInstance());
}"
18995,"public void destroy(){
  HandlerList.unregisterAll(this);
}","public void destroy(){
  LogUtils.fine(""String_Node_Str"" + this + ""String_Node_Str""+ view.getName());
  HandlerList.unregisterAll(this);
}"
18996,"@EventHandler(priority=EventPriority.MONITOR) void onInventoryClick(InventoryClickEvent event){
  String playerName=event.getWhoClicked().getName();
  String name=getView().variableSubs(getView().getActiveMenuTitle(playerName));
  if (event.getInventory().getTitle().equals(name)) {
    LogUtils.fine(""String_Node_Str"" + playerName + ""String_Node_Str""+ getView().getName()+ ""String_Node_Str""+ event.getInventory().getTitle());
    event.setCancelled(true);
    int slot=event.getRawSlot();
    if (slot >= 0 && slot < size && optionNames[slot] != null) {
      OptionClickEvent optionEvent=new OptionClickEvent((Player)event.getWhoClicked(),getMenuIndexForSlot(slot),optionNames[slot]);
      view.onOptionClick(optionEvent);
      if (optionEvent.willClose()) {
        final Player p=(Player)event.getWhoClicked();
        Bukkit.getScheduler().scheduleSyncDelayedTask(ScrollingMenuSign.getInstance(),new Runnable(){
          public void run(){
            p.closeInventory();
          }
        }
,1);
      }
      if (optionEvent.willDestroy()) {
        destroy();
      }
    }
  }
}","@EventHandler(priority=EventPriority.MONITOR) void onInventoryClick(InventoryClickEvent event){
  if (!(event.getWhoClicked() instanceof Player)) {
    return;
  }
  Player player=(Player)event.getWhoClicked();
  String playerName=player.getName();
  String menuTitle=getView().variableSubs(getView().getActiveMenuTitle(playerName));
  String activeMenuName=view.getActiveMenu(playerName).getName();
  if (isPoppedUp(player) && event.getInventory().getTitle().equals(menuTitle) && menuName.equals(activeMenuName)) {
    LogUtils.fine(""String_Node_Str"" + playerName + ""String_Node_Str""+ getView().getName()+ ""String_Node_Str""+ event.getInventory().getTitle()+ ""String_Node_Str""+ this);
    event.setCancelled(true);
    int slot=event.getRawSlot();
    if (slot >= 0 && slot < size && optionNames[slot] != null) {
      OptionClickEvent optionEvent=new OptionClickEvent((Player)event.getWhoClicked(),getMenuIndexForSlot(slot),optionNames[slot]);
      try {
        view.onOptionClick(optionEvent);
      }
 catch (      SMSException e) {
        if (event.getWhoClicked() instanceof Player) {
          MiscUtil.errorMessage((Player)event.getWhoClicked(),e.getMessage());
        }
 else {
          LogUtils.warning(event.getWhoClicked().getName() + ""String_Node_Str"" + e.getMessage());
        }
      }
      if (optionEvent.willClose()) {
        final Player p=(Player)event.getWhoClicked();
        Bukkit.getScheduler().scheduleSyncDelayedTask(ScrollingMenuSign.getInstance(),new Runnable(){
          public void run(){
            p.closeInventory();
          }
        }
,1);
      }
      if (optionEvent.willDestroy()) {
        destroy();
      }
    }
  }
}"
18997,"public static boolean showTextEntryPopup(final Player player,final String prompt){
  final SpoutPlayer sp=(SpoutPlayer)player;
  if (!sp.isSpoutCraftEnabled()) {
    return false;
  }
  Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(ScrollingMenuSign.getInstance(),new Runnable(){
    @Override public void run(){
      TextEntryPopup.show(sp,prompt);
    }
  }
);
  return true;
}","public static boolean showTextEntryPopup(final Player player,final String prompt){
  final SpoutPlayer sp=(SpoutPlayer)player;
  if (!sp.isSpoutCraftEnabled()) {
    return false;
  }
  LogUtils.fine(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ prompt);
  Bukkit.getServer().getScheduler().scheduleSyncDelayedTask(ScrollingMenuSign.getInstance(),new Runnable(){
    @Override public void run(){
      TextEntryPopup.show(sp,prompt);
    }
  }
,5L);
  return true;
}"
18998,"/** 
 * A Spout keypress event was received.
 * @param sp		The Spout player who pressed the key(s)
 * @param pressed	Represents the set of keys currently pressed
 * @return			True if a spout view was actually popped up or down, false otherwise
 */
public static boolean handleKeypress(SpoutPlayer sp,SMSSpoutKeyMap pressed){
  if (pressed.keysPressed() == 0)   return false;
  String s=pressed.toString();
  String viewName=keyMap.get(s);
  if (viewName != null) {
    if (SMSView.checkForView(viewName)) {
      try {
        SMSView v=SMSView.getView(viewName);
        if (v instanceof SMSSpoutView) {
          if (!PermissionUtils.isAllowedTo(sp,""String_Node_Str""))           return false;
          if (!v.hasOwnerPermission(sp))           return false;
          ((SMSSpoutView)v).toggleGUI(sp);
          return true;
        }
 else {
          LogUtils.warning(""String_Node_Str"" + v.getName() + ""String_Node_Str""+ s);
        }
      }
 catch (      SMSException e) {
      }
    }
 else {
      keyMap.remove(s);
    }
  }
  return false;
}","/** 
 * A Spout keypress event was received.
 * @param sp		The Spout player who pressed the key(s)
 * @param pressed	Represents the set of keys currently pressed
 * @return			True if a spout view was actually popped up or down, false otherwise
 */
public static boolean handleKeypress(SpoutPlayer sp,SMSSpoutKeyMap pressed){
  if (pressed.keysPressed() == 0)   return false;
  if (TextEntryPopup.hasActivePopup(sp.getName())) {
    return false;
  }
  String s=pressed.toString();
  String viewName=keyMap.get(s);
  if (viewName != null) {
    if (SMSView.checkForView(viewName)) {
      try {
        SMSView v=SMSView.getView(viewName);
        if (v instanceof SMSSpoutView) {
          if (!PermissionUtils.isAllowedTo(sp,""String_Node_Str""))           return false;
          if (!v.hasOwnerPermission(sp))           return false;
          ((SMSSpoutView)v).toggleGUI(sp);
          return true;
        }
 else {
          LogUtils.warning(""String_Node_Str"" + v.getName() + ""String_Node_Str""+ s);
        }
      }
 catch (      SMSException e) {
      }
    }
 else {
      keyMap.remove(s);
    }
  }
  return false;
}"
18999,"@SuppressWarnings(""String_Node_Str"") private void giveBook(CommandSender sender,Player targetPlayer,String viewName,int amount){
  SMSView view=SMSView.getView(viewName);
  if (!(view instanceof PoppableView)) {
    throw new SMSException(""String_Node_Str"" + viewName + ""String_Node_Str"");
  }
  PopupBook book=new PopupBook(targetPlayer,view);
  ItemStack writtenbook=book.toItemStack();
  targetPlayer.getInventory().addItem(writtenbook);
  targetPlayer.updateInventory();
  String s=amount == 1 ? ""String_Node_Str"" : ""String_Node_Str"";
  MiscUtil.statusMessage(sender,String.format(""String_Node_Str"",amount,s,viewName,targetPlayer.getName()));
  if (sender != targetPlayer) {
    MiscUtil.statusMessage(targetPlayer,String.format(""String_Node_Str"",amount,s,view.getMenu().getTitle()));
  }
}","@SuppressWarnings(""String_Node_Str"") private void giveBook(CommandSender sender,Player targetPlayer,String argStr,int amount){
  SMSView view;
  if (SMSView.checkForView(argStr)) {
    view=SMSView.getView(argStr);
    if (!(view instanceof PoppableView)) {
      throw new SMSException(""String_Node_Str"" + argStr + ""String_Node_Str"");
    }
  }
 else {
    SMSMenu menu=SMSMenu.getMenu(argStr);
    view=SMSView.findView(menu,PoppableView.class);
    if (view == null) {
      view=SMSInventoryView.addInventoryViewToMenu(menu);
    }
  }
  PopupBook book=new PopupBook(targetPlayer,view);
  ItemStack writtenbook=book.toItemStack();
  targetPlayer.getInventory().addItem(writtenbook);
  targetPlayer.updateInventory();
  String s=amount == 1 ? ""String_Node_Str"" : ""String_Node_Str"";
  MiscUtil.statusMessage(sender,String.format(""String_Node_Str"",amount,s,argStr,targetPlayer.getName()));
  if (sender != targetPlayer) {
    MiscUtil.statusMessage(targetPlayer,String.format(""String_Node_Str"",amount,s,view.getMenu().getTitle()));
  }
}"
19000,"@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args){
  int amount=1;
  if (args.length >= 3) {
    try {
      amount=Math.min(64,Math.max(1,Integer.parseInt(args[2])));
    }
 catch (    NumberFormatException e) {
      throw new SMSException(""String_Node_Str"" + args[1] + ""String_Node_Str"");
    }
  }
  Player targetPlayer;
  if (args.length >= 4) {
    targetPlayer=Bukkit.getPlayer(args[3]);
    if (targetPlayer == null) {
      throw new SMSException(""String_Node_Str"" + args[3] + ""String_Node_Str"");
    }
  }
 else {
    notFromConsole(sender);
    targetPlayer=(Player)sender;
  }
  if (args[0].startsWith(""String_Node_Str"")) {
    short mapId;
    try {
      mapId=Short.parseShort(args[0]);
      giveMap(sender,targetPlayer,mapId,amount);
    }
 catch (    NumberFormatException e) {
      throw new SMSException(""String_Node_Str"" + args[0] + ""String_Node_Str"");
    }
  }
 else   if (args[0].startsWith(""String_Node_Str"")) {
    giveBook(sender,targetPlayer,args[1],amount);
  }
 else {
    showUsage(sender);
  }
  return true;
}","@Override public boolean execute(Plugin plugin,CommandSender sender,String[] args){
  int amount=1;
  if (args.length >= 3) {
    try {
      amount=Math.min(64,Math.max(1,Integer.parseInt(args[2])));
    }
 catch (    NumberFormatException e) {
      throw new SMSException(""String_Node_Str"" + args[1] + ""String_Node_Str"");
    }
  }
  Player targetPlayer;
  if (args.length >= 4) {
    targetPlayer=Bukkit.getPlayer(args[3]);
    if (targetPlayer == null) {
      throw new SMSException(""String_Node_Str"" + args[3] + ""String_Node_Str"");
    }
  }
 else {
    notFromConsole(sender);
    targetPlayer=(Player)sender;
  }
  if (args[0].startsWith(""String_Node_Str"")) {
    short mapId=getMapId(targetPlayer,args[1]);
    giveMap(sender,targetPlayer,mapId,amount);
  }
 else   if (args[0].startsWith(""String_Node_Str"")) {
    giveBook(sender,targetPlayer,args[1],amount);
  }
 else {
    showUsage(sender);
  }
  return true;
}"
