record_number,buggy_code,fixed_code
55001,"@Override public void run(){
  SamplePacket packet;
  SamplePacket filteredPacket=new SamplePacket(packetSize);
  double[] doublePacket;
  short[] shortPacket=new short[packetSize];
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioTrack.play();
  while (!stopRequested) {
    try {
      packet=inputQueue.poll(1000,TimeUnit.MILLISECONDS);
      if (packet == null) {
        Log.d(LOGTAG,""String_Node_Str"");
        continue;
      }
      applyAudioFilter(packet,filteredPacket);
      doublePacket=filteredPacket.re();
      for (int i=0; i < filteredPacket.size(); i++) {
        shortPacket[i]=(short)(doublePacket[i] * 32767);
      }
      if (audioTrack.write(shortPacket,0,filteredPacket.size()) != filteredPacket.size()) {
        Log.e(LOGTAG,""String_Node_Str"");
        stopRequested=true;
      }
      outputQueue.offer(packet);
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      stopRequested=true;
    }
  }
  audioTrack.stop();
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  SamplePacket packet;
  SamplePacket filteredPacket=new SamplePacket(packetSize);
  double[] doublePacket;
  short[] shortPacket=new short[packetSize];
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioTrack.play();
  while (!stopRequested) {
    try {
      packet=inputQueue.poll(1000,TimeUnit.MILLISECONDS);
      if (packet == null) {
        continue;
      }
      applyAudioFilter(packet,filteredPacket);
      doublePacket=filteredPacket.re();
      for (int i=0; i < filteredPacket.size(); i++) {
        shortPacket[i]=(short)(doublePacket[i] * 32767);
      }
      if (audioTrack.write(shortPacket,0,filteredPacket.size()) != filteredPacket.size()) {
        Log.e(LOGTAG,""String_Node_Str"");
        stopRequested=true;
      }
      outputQueue.offer(packet);
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      stopRequested=true;
    }
  }
  audioTrack.stop();
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
55002,"@Override public void run(){
  SamplePacket inputSamples;
  SamplePacket outputSamples;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  while (!stopRequested) {
    try {
      inputSamples=inputQueue.poll(1000,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopRequested=true;
      break;
    }
    if (inputSamples == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
    if (inputSamples.getSampleRate() != INPUT_RATE) {
      Log.d(LOGTAG,""String_Node_Str"" + inputSamples.getSampleRate() + ""String_Node_Str""+ INPUT_RATE+ ""String_Node_Str"");
      continue;
    }
    try {
      outputSamples=outputReturnQueue.poll(1000,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopRequested=true;
      break;
    }
    if (outputSamples == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
    downsampling(inputSamples,outputSamples);
    inputReturnQueue.offer(inputSamples);
    outputQueue.offer(outputSamples);
  }
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  SamplePacket inputSamples;
  SamplePacket outputSamples;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  while (!stopRequested) {
    try {
      inputSamples=inputQueue.poll(1000,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopRequested=true;
      break;
    }
    if (inputSamples == null) {
      continue;
    }
    if (inputSamples.getSampleRate() != INPUT_RATE) {
      Log.d(LOGTAG,""String_Node_Str"" + inputSamples.getSampleRate() + ""String_Node_Str""+ INPUT_RATE+ ""String_Node_Str"");
      continue;
    }
    try {
      outputSamples=outputReturnQueue.poll(1000,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopRequested=true;
      break;
    }
    if (outputSamples == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
    downsampling(inputSamples,outputSamples);
    inputReturnQueue.offer(inputSamples);
    outputQueue.offer(outputSamples);
  }
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
55003,"@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    if (squelch <= 0 || testSquelchThreshold(quadratureSamples)) {
      audioBuffer=audioSink.getPacketBuffer(1000);
switch (demodulationMode) {
case DEMODULATION_OFF:
        break;
case DEMODULATION_AM:
      demodulateAM(quadratureSamples,audioBuffer);
    break;
case DEMODULATION_NFM:
  demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    audioBuffer=audioSink.getPacketBuffer(1000);
switch (demodulationMode) {
case DEMODULATION_OFF:
      break;
case DEMODULATION_AM:
    demodulateAM(quadratureSamples,audioBuffer);
  break;
case DEMODULATION_NFM:
demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
55004,"public int mixPacketIntoSamplePacket(byte[] packet,SamplePacket samplePacket,long channelFrequency){
  int mixFrequency=(int)(frequency - channelFrequency);
  if (mixFrequency == 0 || (sampleRate / Math.abs(mixFrequency) > MAX_COSINE_LENGTH))   mixFrequency+=sampleRate;
  if (cosineRealLookupTable == null || cosineFrequency != mixFrequency) {
    cosineFrequency=mixFrequency;
    double cycleLength=sampleRate / Math.abs((double)mixFrequency);
    int bestLength=(int)cycleLength;
    double bestLengthError=Math.abs(bestLength - cycleLength);
    for (int i=1; i * cycleLength < MAX_COSINE_LENGTH; i++) {
      if (Math.abs(i * cycleLength - (int)(i * cycleLength)) < bestLengthError) {
        bestLength=(int)(i * cycleLength);
        bestLengthError=Math.abs(bestLength - (i * cycleLength));
      }
    }
    Log.d(LOGTAG,""String_Node_Str"" + mixFrequency + ""String_Node_Str""+ bestLength+ ""String_Node_Str""+ bestLengthError);
    cosineRealLookupTable=new double[bestLength][256];
    cosineImagLookupTable=new double[bestLength][256];
    double cosineAtT;
    double sineAtT;
    for (int t=0; t < bestLength; t++) {
      cosineAtT=Math.cos(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      sineAtT=Math.sin(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      for (int i=0; i < 256; i++) {
        cosineRealLookupTable[t][i]=(i - 128) / 128.0 * cosineAtT;
        cosineImagLookupTable[t][i]=(i - 128) / 128.0 * sineAtT;
      }
    }
    cosineIndex=0;
  }
  int capacity=samplePacket.capacity();
  int count=0;
  int startIndex=samplePacket.size();
  double[] re=samplePacket.re();
  double[] im=samplePacket.im();
  for (int i=0; i < packet.length; i+=2) {
    re[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i] + 128] - cosineImagLookupTable[cosineIndex][packet[i + 1] + 128];
    im[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i + 1] + 128] + cosineImagLookupTable[cosineIndex][packet[i] + 128];
    cosineIndex=(cosineIndex + 1) % cosineRealLookupTable.length;
    count++;
    if (startIndex + count >= capacity)     break;
  }
  samplePacket.setSize(samplePacket.size() + count);
  samplePacket.setSampleRate(sampleRate);
  samplePacket.setFrequency(frequency);
  return count;
}","public int mixPacketIntoSamplePacket(byte[] packet,SamplePacket samplePacket,long channelFrequency){
  int mixFrequency=(int)(frequency - channelFrequency);
  if (mixFrequency == 0 || (sampleRate / Math.abs(mixFrequency) > MAX_COSINE_LENGTH))   mixFrequency+=sampleRate;
  if (cosineRealLookupTable == null || cosineFrequency != mixFrequency) {
    cosineFrequency=mixFrequency;
    double cycleLength=sampleRate / Math.abs((double)mixFrequency);
    int bestLength=(int)cycleLength;
    double bestLengthError=Math.abs(bestLength - cycleLength);
    for (int i=1; i * cycleLength < MAX_COSINE_LENGTH; i++) {
      if (Math.abs(i * cycleLength - (int)(i * cycleLength)) < bestLengthError) {
        bestLength=(int)(i * cycleLength);
        bestLengthError=Math.abs(bestLength - (i * cycleLength));
      }
    }
    cosineRealLookupTable=new double[bestLength][256];
    cosineImagLookupTable=new double[bestLength][256];
    double cosineAtT;
    double sineAtT;
    for (int t=0; t < bestLength; t++) {
      cosineAtT=Math.cos(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      sineAtT=Math.sin(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      for (int i=0; i < 256; i++) {
        cosineRealLookupTable[t][i]=(i - 128) / 128.0 * cosineAtT;
        cosineImagLookupTable[t][i]=(i - 128) / 128.0 * sineAtT;
      }
    }
    cosineIndex=0;
  }
  int capacity=samplePacket.capacity();
  int count=0;
  int startIndex=samplePacket.size();
  double[] re=samplePacket.re();
  double[] im=samplePacket.im();
  for (int i=0; i < packet.length; i+=2) {
    re[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i] + 128] - cosineImagLookupTable[cosineIndex][packet[i + 1] + 128];
    im[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i + 1] + 128] + cosineImagLookupTable[cosineIndex][packet[i] + 128];
    cosineIndex=(cosineIndex + 1) % cosineRealLookupTable.length;
    count++;
    if (startIndex + count >= capacity)     break;
  }
  samplePacket.setSize(samplePacket.size() + count);
  samplePacket.setSampleRate(sampleRate);
  samplePacket.setFrequency(frequency);
  return count;
}"
55005,"public int mixPacketIntoSamplePacket(byte[] packet,SamplePacket samplePacket,long channelFrequency){
  int mixFrequency=(int)(frequency - channelFrequency);
  if (mixFrequency == 0 || (sampleRate / Math.abs(mixFrequency) > MAX_COSINE_LENGTH))   mixFrequency+=sampleRate;
  if (cosineRealLookupTable == null || cosineFrequency != mixFrequency) {
    cosineFrequency=mixFrequency;
    double cycleLength=sampleRate / Math.abs((double)mixFrequency);
    int bestLength=(int)cycleLength;
    double bestLengthError=Math.abs(bestLength - cycleLength);
    for (int i=1; i * cycleLength < MAX_COSINE_LENGTH; i++) {
      if (Math.abs(i * cycleLength - (int)(i * cycleLength)) < bestLengthError) {
        bestLength=(int)(i * cycleLength);
        bestLengthError=Math.abs(bestLength - (i * cycleLength));
      }
    }
    Log.d(LOGTAG,""String_Node_Str"" + mixFrequency + ""String_Node_Str""+ bestLength+ ""String_Node_Str""+ bestLengthError);
    cosineRealLookupTable=new double[bestLength][256];
    cosineImagLookupTable=new double[bestLength][256];
    double cosineAtT;
    double sineAtT;
    for (int t=0; t < bestLength; t++) {
      cosineAtT=Math.cos(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      sineAtT=Math.sin(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      for (int i=0; i < 256; i++) {
        cosineRealLookupTable[t][i]=(i - 128) / 128.0 * cosineAtT;
        cosineImagLookupTable[t][i]=(i - 128) / 128.0 * sineAtT;
      }
    }
    cosineIndex=0;
  }
  int capacity=samplePacket.capacity();
  int count=0;
  int startIndex=samplePacket.size();
  double[] re=samplePacket.re();
  double[] im=samplePacket.im();
  for (int i=0; i < packet.length; i+=2) {
    re[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i] + 128] - cosineImagLookupTable[cosineIndex][packet[i + 1] + 128];
    im[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i + 1] + 128] + cosineImagLookupTable[cosineIndex][packet[i] + 128];
    cosineIndex=(cosineIndex + 1) % cosineRealLookupTable.length;
    count++;
    if (startIndex + count >= capacity)     break;
  }
  samplePacket.setSize(samplePacket.size() + count);
  samplePacket.setSampleRate(sampleRate);
  samplePacket.setFrequency(frequency);
  return count;
}","public int mixPacketIntoSamplePacket(byte[] packet,SamplePacket samplePacket,long channelFrequency){
  int mixFrequency=(int)(frequency - channelFrequency);
  if (mixFrequency == 0 || (sampleRate / Math.abs(mixFrequency) > MAX_COSINE_LENGTH))   mixFrequency+=sampleRate;
  if (cosineRealLookupTable == null || cosineFrequency != mixFrequency) {
    cosineFrequency=mixFrequency;
    double cycleLength=sampleRate / Math.abs((double)mixFrequency);
    int bestLength=(int)cycleLength;
    double bestLengthError=Math.abs(bestLength - cycleLength);
    for (int i=1; i * cycleLength < MAX_COSINE_LENGTH; i++) {
      if (Math.abs(i * cycleLength - (int)(i * cycleLength)) < bestLengthError) {
        bestLength=(int)(i * cycleLength);
        bestLengthError=Math.abs(bestLength - (i * cycleLength));
      }
    }
    cosineRealLookupTable=new double[bestLength][256];
    cosineImagLookupTable=new double[bestLength][256];
    double cosineAtT;
    double sineAtT;
    for (int t=0; t < bestLength; t++) {
      cosineAtT=Math.cos(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      sineAtT=Math.sin(2 * Math.PI * mixFrequency* t / (double)sampleRate);
      for (int i=0; i < 256; i++) {
        cosineRealLookupTable[t][i]=(i - 128) / 128.0 * cosineAtT;
        cosineImagLookupTable[t][i]=(i - 128) / 128.0 * sineAtT;
      }
    }
    cosineIndex=0;
  }
  int capacity=samplePacket.capacity();
  int count=0;
  int startIndex=samplePacket.size();
  double[] re=samplePacket.re();
  double[] im=samplePacket.im();
  for (int i=0; i < packet.length; i+=2) {
    re[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i] + 128] - cosineImagLookupTable[cosineIndex][packet[i + 1] + 128];
    im[startIndex + count]=cosineRealLookupTable[cosineIndex][packet[i + 1] + 128] + cosineImagLookupTable[cosineIndex][packet[i] + 128];
    cosineIndex=(cosineIndex + 1) % cosineRealLookupTable.length;
    count++;
    if (startIndex + count >= capacity)     break;
  }
  samplePacket.setSize(samplePacket.size() + count);
  samplePacket.setSampleRate(sampleRate);
  samplePacket.setFrequency(frequency);
  return count;
}"
55006,"@Override protected void onStart(){
  super.onStart();
  checkForChangedPreferences();
  if (running)   startAnalyzer();
  if (savedInstanceState != null) {
    analyzerSurface.setVirtualFrequency(savedInstanceState.getLong(getString(R.string.save_state_virtualFrequency)));
    analyzerSurface.setVirtualSampleRate(savedInstanceState.getInt(getString(R.string.save_state_virtualSampleRate)));
    analyzerSurface.setDBScale(savedInstanceState.getFloat(getString(R.string.save_state_minDB)),savedInstanceState.getFloat(getString(R.string.save_state_maxDB)));
    analyzerSurface.setChannelFrequency(savedInstanceState.getLong(getString(R.string.save_state_channelFrequency)));
    analyzerSurface.setChannelWidth(savedInstanceState.getInt(getString(R.string.save_state_channelWidth)));
    analyzerSurface.setSquelch(savedInstanceState.getFloat(getString(R.string.save_state_squelch)));
    if (demodulator != null && scheduler != null) {
      demodulator.setChannelWidth(savedInstanceState.getInt(getString(R.string.save_state_channelWidth)));
      demodulator.setSquelch(savedInstanceState.getFloat(getString(R.string.save_state_squelch)));
      scheduler.setChannelFrequency(savedInstanceState.getLong(getString(R.string.save_state_channelFrequency)));
    }
    savedInstanceState=null;
  }
}","@Override protected void onStart(){
  super.onStart();
  checkForChangedPreferences();
  if (running)   startAnalyzer();
  if (savedInstanceState != null) {
    analyzerSurface.setVirtualFrequency(savedInstanceState.getLong(getString(R.string.save_state_virtualFrequency)));
    analyzerSurface.setVirtualSampleRate(savedInstanceState.getInt(getString(R.string.save_state_virtualSampleRate)));
    analyzerSurface.setDBScale(savedInstanceState.getFloat(getString(R.string.save_state_minDB)),savedInstanceState.getFloat(getString(R.string.save_state_maxDB)));
    analyzerSurface.setChannelFrequency(savedInstanceState.getLong(getString(R.string.save_state_channelFrequency)));
    analyzerSurface.setChannelWidth(savedInstanceState.getInt(getString(R.string.save_state_channelWidth)));
    analyzerSurface.setSquelch(savedInstanceState.getFloat(getString(R.string.save_state_squelch)));
    if (demodulator != null && scheduler != null) {
      demodulator.setChannelWidth(savedInstanceState.getInt(getString(R.string.save_state_channelWidth)));
      scheduler.setChannelFrequency(savedInstanceState.getLong(getString(R.string.save_state_channelFrequency)));
    }
    savedInstanceState=null;
  }
}"
55007,"/** 
 * Will pop up a dialog to let the user input a new frequency. Note: A frequency can be entered either in Hz or in MHz. If the input value is a number smaller than the maximum frequency of the source in MHz, then it is interpreted as a frequency in MHz. Otherwise it will be handled as frequency in Hz.
 */
private void tuneToFrequency(){
  if (source == null)   return;
  final double maxFreqMHz=source.getMaxFrequency() / 1000000f;
  final EditText et_input=new EditText(this);
  et_input.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
  new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"" + source.getFrequency() / 1000000f + ""String_Node_Str"" + maxFreqMHz + ""String_Node_Str"").setView(et_input).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      try {
        double newFreq=Double.valueOf(et_input.getText().toString());
        if (newFreq < maxFreqMHz)         newFreq=newFreq * 1000000;
        if (newFreq <= source.getMaxFrequency() && newFreq >= source.getMinFrequency()) {
          source.setFrequency((long)newFreq);
          analyzerSurface.setVirtualFrequency((long)newFreq);
        }
 else {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + (long)newFreq + ""String_Node_Str"",Toast.LENGTH_LONG).show();
        }
      }
 catch (      NumberFormatException e) {
        Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).show();
}","/** 
 * Will pop up a dialog to let the user input a new frequency. Note: A frequency can be entered either in Hz or in MHz. If the input value is a number smaller than the maximum frequency of the source in MHz, then it is interpreted as a frequency in MHz. Otherwise it will be handled as frequency in Hz.
 */
private void tuneToFrequency(){
  if (source == null)   return;
  final double maxFreqMHz=source.getMaxFrequency() / 1000000f;
  final EditText et_input=new EditText(this);
  et_input.setInputType(InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL);
  new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"" + source.getFrequency() / 1000000f + ""String_Node_Str"" + maxFreqMHz + ""String_Node_Str"").setView(et_input).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      try {
        double newFreq=Double.valueOf(et_input.getText().toString());
        if (newFreq < maxFreqMHz)         newFreq=newFreq * 1000000;
        if (newFreq <= source.getMaxFrequency() && newFreq >= source.getMinFrequency()) {
          source.setFrequency((long)newFreq);
          analyzerSurface.setVirtualFrequency((long)newFreq);
          if (demodulationMode != Demodulator.DEMODULATION_OFF)           analyzerSurface.setDemodulationEnabled(true);
        }
 else {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + (long)newFreq + ""String_Node_Str"",Toast.LENGTH_LONG).show();
        }
      }
 catch (      NumberFormatException e) {
        Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).show();
}"
55008,"@Override public void run(){
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  SamplePacket fftBuffer=null;
  SamplePacket demodBuffer=null;
  SamplePacket tmpFlushBuffer=null;
  while (!stopRequested) {
    byte[] packet=source.getPacket(1000);
    if (packet == null) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopScheduler();
      break;
    }
    if (demodulationActivated) {
      demodBuffer=demodInputQueue.poll();
      if (demodBuffer != null) {
        demodBuffer.setSize(0);
        source.mixPacketIntoSamplePacket(packet,demodBuffer,channelFrequency);
        demodOutputQueue.offer(demodBuffer);
      }
 else {
        Log.d(LOGTAG,""String_Node_Str"");
        while ((tmpFlushBuffer=demodOutputQueue.poll()) != null)         demodInputQueue.offer(tmpFlushBuffer);
      }
    }
    if (fftBuffer == null) {
      fftBuffer=fftInputQueue.poll();
      if (fftBuffer != null)       fftBuffer.setSize(0);
    }
    if (fftBuffer != null) {
      source.fillPacketIntoSamplePacket(packet,fftBuffer);
      if (fftBuffer.capacity() == fftBuffer.size()) {
        fftOutputQueue.offer(fftBuffer);
        fftBuffer=null;
      }
    }
    source.returnPacket(packet);
  }
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  SamplePacket fftBuffer=null;
  SamplePacket demodBuffer=null;
  SamplePacket tmpFlushBuffer=null;
  while (!stopRequested) {
    byte[] packet=source.getPacket(1000);
    if (packet == null) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopScheduler();
      break;
    }
    if (demodulationActivated && squelchSatisfied) {
      demodBuffer=demodInputQueue.poll();
      if (demodBuffer != null) {
        demodBuffer.setSize(0);
        source.mixPacketIntoSamplePacket(packet,demodBuffer,channelFrequency);
        demodOutputQueue.offer(demodBuffer);
      }
 else {
        Log.d(LOGTAG,""String_Node_Str"");
        while ((tmpFlushBuffer=demodOutputQueue.poll()) != null)         demodInputQueue.offer(tmpFlushBuffer);
      }
    }
    if (fftBuffer == null) {
      fftBuffer=fftInputQueue.poll();
      if (fftBuffer != null)       fftBuffer.setSize(0);
    }
    if (fftBuffer != null) {
      source.fillPacketIntoSamplePacket(packet,fftBuffer);
      if (fftBuffer.capacity() == fftBuffer.size()) {
        fftOutputQueue.offer(fftBuffer);
        fftBuffer=null;
      }
    }
    source.returnPacket(packet);
  }
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
55009,"/** 
 * Set the font size
 * @param fontSize FONT_SIZE_SMALL, *_MEDIUM or *_LARGE
 */
public void setFontSize(int fontSize){
  int normalTextSize;
  int smallTextSize;
switch (fontSize) {
case FONT_SIZE_SMALL:
    normalTextSize=(int)(getGridSize() / 2.5);
  smallTextSize=(int)(normalTextSize * 0.7);
break;
case FONT_SIZE_MEDIUM:
normalTextSize=(int)(getGridSize() / 2.1);
smallTextSize=(int)(normalTextSize * 0.5);
break;
case FONT_SIZE_LARGE:
normalTextSize=(int)(getGridSize() / 1.8);
smallTextSize=(int)(normalTextSize * 0.3);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + fontSize);
return;
}
this.fontSize=fontSize;
this.textPaint.setTextSize(normalTextSize);
this.textSmallPaint.setTextSize(smallTextSize);
}","/** 
 * Set the font size
 * @param fontSize FONT_SIZE_SMALL, *_MEDIUM or *_LARGE
 */
public void setFontSize(int fontSize){
  int normalTextSize;
  int smallTextSize;
switch (fontSize) {
case FONT_SIZE_SMALL:
    normalTextSize=(int)(getGridSize() * 0.3);
  smallTextSize=(int)(getGridSize() * 0.2);
break;
case FONT_SIZE_MEDIUM:
normalTextSize=(int)(getGridSize() * 0.476);
smallTextSize=(int)(getGridSize() * 0.25);
break;
case FONT_SIZE_LARGE:
normalTextSize=(int)(getGridSize() * 0.7);
smallTextSize=(int)(getGridSize() * 0.35);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + fontSize);
return;
}
this.fontSize=fontSize;
this.textPaint.setTextSize(normalTextSize);
this.textSmallPaint.setTextSize(smallTextSize);
}"
55010,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  this.savedInstanceState=savedInstanceState;
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String extStorage=Environment.getExternalStorageDirectory().getAbsolutePath();
  String defaultFile=getString(R.string.pref_filesource_file_default);
  if (preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_filesource_file),extStorage + ""String_Node_Str"" + defaultFile).apply();
  defaultFile=getString(R.string.pref_logfile_default);
  if (preferences.getString(getString(R.string.pref_logfile),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_logfile),extStorage + ""String_Node_Str"" + defaultFile).apply();
  if (preferences.getBoolean(getString(R.string.pref_logging),false)) {
    try {
      File logfile=new File(preferences.getString(getString(R.string.pref_logfile),""String_Node_Str""));
      logfile.getParentFile().mkdir();
      logcat=Runtime.getRuntime().exec(""String_Node_Str"" + logfile);
      Log.i(""String_Node_Str"",""String_Node_Str"" + logcat.toString() + ""String_Node_Str""+ logfile);
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
  fl_analyzerFrame=(FrameLayout)findViewById(R.id.fl_analyzerFrame);
  analyzerSurface=new AnalyzerSurface(this,this);
  analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
  analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
  analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
  analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
  analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
  analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
  fl_analyzerFrame.addView(analyzerSurface);
  if (savedInstanceState != null) {
    running=savedInstanceState.getBoolean(getString(R.string.save_state_running));
    demodulationMode=savedInstanceState.getInt(getString(R.string.save_state_demodulatorMode));
  }
 else {
    running=preferences.getBoolean((getString(R.string.pref_autostart)),false);
  }
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  this.savedInstanceState=savedInstanceState;
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String extStorage=Environment.getExternalStorageDirectory().getAbsolutePath();
  String defaultFile=getString(R.string.pref_filesource_file_default);
  if (preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_filesource_file),extStorage + ""String_Node_Str"" + defaultFile).apply();
  defaultFile=getString(R.string.pref_logfile_default);
  if (preferences.getString(getString(R.string.pref_logfile),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_logfile),extStorage + ""String_Node_Str"" + defaultFile).apply();
  if (preferences.getBoolean(getString(R.string.pref_logging),false)) {
    try {
      File logfile=new File(preferences.getString(getString(R.string.pref_logfile),""String_Node_Str""));
      logfile.getParentFile().mkdir();
      logcat=Runtime.getRuntime().exec(""String_Node_Str"" + logfile);
      Log.i(""String_Node_Str"",""String_Node_Str"" + logcat.toString() + ""String_Node_Str""+ logfile);
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
  fl_analyzerFrame=(FrameLayout)findViewById(R.id.fl_analyzerFrame);
  analyzerSurface=new AnalyzerSurface(this,this);
  analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
  analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
  analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
  analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
  analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
  analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
  analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
  fl_analyzerFrame.addView(analyzerSurface);
  if (savedInstanceState != null) {
    running=savedInstanceState.getBoolean(getString(R.string.save_state_running));
    demodulationMode=savedInstanceState.getInt(getString(R.string.save_state_demodulatorMode));
  }
 else {
    running=preferences.getBoolean((getString(R.string.pref_autostart)),false);
  }
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
}"
55011,"/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource))       createSource();
    long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
  int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat()) {
createSource();
}
break;
case HACKRF_SOURCE:
if (!(source instanceof HackrfSource)) createSource();
break;
case RTLSDR_SOURCE:
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}","/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource))       createSource();
    long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
  int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat()) {
createSource();
}
break;
case HACKRF_SOURCE:
if (!(source instanceof HackrfSource)) createSource();
break;
case RTLSDR_SOURCE:
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}"
55012,"/** 
 * This method will do the signal processing (fft) on the given samples
 * @param samples	input samples for the signal processing
 */
public void doProcessing(SamplePacket samples){
  this.fftBlock.applyWindow(samples.re(),samples.im());
  this.fftBlock.fft(samples.re(),samples.im());
  double realPower;
  double imagPower;
  int size=samples.size();
  for (int i=0; i < size; i++) {
    int targetIndex=(i + size / 2) % size;
    realPower=samples.re(i) / fftSize;
    realPower=realPower * realPower;
    imagPower=samples.im(i) / fftSize;
    imagPower=imagPower * imagPower;
    mag[targetIndex]=Math.log(realPower + imagPower);
  }
}","/** 
 * This method will do the signal processing (fft) on the given samples
 * @param samples	input samples for the signal processing
 */
public void doProcessing(SamplePacket samples){
  this.fftBlock.applyWindow(samples.re(),samples.im());
  this.fftBlock.fft(samples.re(),samples.im());
  double realPower;
  double imagPower;
  int size=samples.size();
  for (int i=0; i < size; i++) {
    int targetIndex=(i + size / 2) % size;
    realPower=samples.re(i) / fftSize;
    realPower=realPower * realPower;
    imagPower=samples.im(i) / fftSize;
    imagPower=imagPower * imagPower;
    mag[targetIndex]=10 * Math.log10(Math.sqrt(realPower + imagPower));
  }
}"
55013,"public void setDemodulationEnabled(boolean demodulationEnabled){
synchronized (this.getHolder()) {
    if (demodulationEnabled) {
      this.virtualSampleRate=(int)(source.getSampleRate() * 0.9);
      source.setFrequency(virtualFrequency);
      this.channelFrequency=virtualFrequency;
      this.squelch=minDB + (maxDB - minDB) / 10;
    }
    this.demodulationEnabled=demodulationEnabled;
  }
}","public void setDemodulationEnabled(boolean demodulationEnabled){
synchronized (this.getHolder()) {
    if (demodulationEnabled) {
      this.virtualSampleRate=(int)(source.getSampleRate() * 0.9);
      source.setFrequency(virtualFrequency);
      if (channelFrequency < virtualFrequency - virtualSampleRate / 2 || channelFrequency > virtualFrequency + virtualSampleRate / 2) {
        this.channelFrequency=virtualFrequency;
        callbackHandler.onUpdateChannelFrequency(channelFrequency);
      }
      this.channelWidth=callbackHandler.onCurrentChannelWidthRequested();
      if (squelch < minDB || squelch > maxDB) {
        this.squelch=minDB + (maxDB - minDB) / 4;
        callbackHandler.onUpdateSquelch(squelch);
      }
    }
    this.demodulationEnabled=demodulationEnabled;
  }
}"
55014,"/** 
 * Returns the squelch threshold in dB!
 * @return	squelch threshold in dB
 */
public double getSquelch(){
  return Math.log(squelch);
}","/** 
 * Returns the squelch threshold in dB!
 * @return	squelch threshold in dB
 */
public double getSquelch(){
  return 10 * Math.log10(squelch);
}"
55015,"private void applyUserFilter(SamplePacket input,SamplePacket output){
  if (userFilter == null || ((int)userFilter.getCutOffFrequency()) != userFilterCutOff) {
    this.userFilter=FirFilter.createLowPass(1,1,input.getSampleRate(),userFilterCutOff,input.getSampleRate() * 0.10,USER_FILTER_ATTENUATION);
    Log.d(LOGTAG,""String_Node_Str"" + userFilter.getNumberOfTaps() + ""String_Node_Str""+ userFilter.getDecimation()+ ""String_Node_Str""+ userFilter.getCutOffFrequency()+ ""String_Node_Str""+ userFilter.getTransitionWidth());
  }
  output.setSize(0);
  if (userFilter.filter(input,output,0,input.size()) < input.size()) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
}","private void applyUserFilter(SamplePacket input,SamplePacket output){
  if (userFilter == null || ((int)userFilter.getCutOffFrequency()) != userFilterCutOff) {
    this.userFilter=FirFilter.createLowPass(1,1,input.getSampleRate(),userFilterCutOff,input.getSampleRate() * 0.10,USER_FILTER_ATTENUATION);
    if (userFilter == null)     return;
    Log.d(LOGTAG,""String_Node_Str"" + userFilter.getNumberOfTaps() + ""String_Node_Str""+ userFilter.getDecimation()+ ""String_Node_Str""+ userFilter.getCutOffFrequency()+ ""String_Node_Str""+ userFilter.getTransitionWidth());
  }
  output.setSize(0);
  if (userFilter.filter(input,output,0,input.size()) < input.size()) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
}"
55016,"@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    if (squelch <= 0 || testSquelchThreshold(quadratureSamples)) {
      audioBuffer=audioSink.getPacketBuffer(1000);
switch (demodulationMode) {
case DEMODULATION_OFF:
        break;
case DEMODULATION_AM:
      break;
case DEMODULATION_NFM:
    demodulateFM(quadratureSamples,audioBuffer,5000);
  break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    if (squelch <= 0 || testSquelchThreshold(quadratureSamples)) {
      audioBuffer=audioSink.getPacketBuffer(1000);
switch (demodulationMode) {
case DEMODULATION_OFF:
        break;
case DEMODULATION_AM:
      demodulateAM(quadratureSamples,audioBuffer);
    break;
case DEMODULATION_NFM:
  demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
55017,"private void demodulateAM(SamplePacket input,SamplePacket output){
  double[] reIn=input.re();
  double[] imIn=input.im();
  double[] reOut=output.re();
  for (int i=0; i < input.size(); i++)   reOut[i]=(reIn[i] * reIn[i] + imIn[i] * imIn[i]) * 0.5;
  output.setSize(input.size());
  output.setSampleRate(QUADRATURE_RATE[demodulationMode]);
}","private void demodulateAM(SamplePacket input,SamplePacket output){
  double[] reIn=input.re();
  double[] imIn=input.im();
  double[] reOut=output.re();
  for (int i=0; i < input.size(); i++)   reOut[i]=(reIn[i] * reIn[i] + imIn[i] * imIn[i]) - 1;
  output.setSize(input.size());
  output.setSampleRate(QUADRATURE_RATE[demodulationMode]);
}"
55018,"private boolean testSquelchThreshold(SamplePacket input){
  double[] re=input.re();
  double[] im=input.im();
  double sum=0;
  int size=input.size();
  int stepSize=size / 10;
  for (int i=0; i < size; i+=stepSize)   sum=re[i] * re[i] + im[i] * im[i];
  return sum / (size / stepSize) > squelch;
}","private boolean testSquelchThreshold(SamplePacket input){
  double[] re=input.re();
  double[] im=input.im();
  double sum=0;
  int size=input.size();
  int stepSize=size / 10;
  for (int i=0; i < size; i+=stepSize)   sum=re[i] * re[i] + im[i] * im[i];
  if (System.currentTimeMillis() % 100 == 0)   Log.d(LOGTAG,""String_Node_Str"" + squelch + ""String_Node_Str""+ 10 * Math.log10(squelch) + ""String_Node_Str"" + sum / (size / stepSize) + ""String_Node_Str"" + 10 * Math.log10(Math.sqrt(sum / (size / stepSize))) + ""String_Node_Str"");
  return sum / (size / stepSize) > squelch;
}"
55019,"/** 
 * Sets the squelch threshold
 * @param squelch squelch threshold in dB!
 */
public void setSquelch(double squelch){
  this.squelch=Math.pow(10,squelch);
}","/** 
 * Sets the squelch threshold
 * @param squelch squelch threshold in dB!
 */
public void setSquelch(double squelch){
  this.squelch=Math.pow(10,0.1 * squelch);
}"
55020,"/** 
 * Will set the modulation mode to the given value. Takes care of adjusting the scheduler and the demodulator respectively and updates the action bar menu item.
 * @param mode	Demodulator.DEMODULATION_OFF, *_AM, *_NFM, *_WFM
 */
public void setDemodulationMode(int mode){
  if (scheduler == null || demodulator == null || source == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  if (mode == Demodulator.DEMODULATION_OFF) {
    scheduler.setDemodulationActivated(false);
  }
 else {
    source.setSampleRate(Demodulator.INPUT_RATE);
    if (source.getSampleRate() != Demodulator.INPUT_RATE) {
      Log.e(LOGTAG,""String_Node_Str"");
      Toast.makeText(MainActivity.this,""String_Node_Str"" + Demodulator.INPUT_RATE / 1000000 + ""String_Node_Str"",Toast.LENGTH_LONG).show();
      scheduler.setDemodulationActivated(false);
      mode=Demodulator.DEMODULATION_OFF;
    }
 else {
      scheduler.setDemodulationActivated(true);
    }
  }
  demodulator.setDemodulationMode(mode);
  this.demodulationMode=mode;
  if (mode == Demodulator.DEMODULATION_OFF) {
    analyzerSurface.setDemodulationEnabled(false);
  }
 else {
    analyzerSurface.setDemodulationEnabled(true);
    analyzerSurface.setChannelWidth(demodulator.getChannelWidth());
  }
  updateActionBar();
}","/** 
 * Will set the modulation mode to the given value. Takes care of adjusting the scheduler and the demodulator respectively and updates the action bar menu item.
 * @param mode	Demodulator.DEMODULATION_OFF, *_AM, *_NFM, *_WFM
 */
public void setDemodulationMode(int mode){
  if (scheduler == null || demodulator == null || source == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  if (mode == Demodulator.DEMODULATION_OFF) {
    scheduler.setDemodulationActivated(false);
  }
 else {
    source.setSampleRate(Demodulator.INPUT_RATE);
    if (source.getSampleRate() != Demodulator.INPUT_RATE) {
      Log.e(LOGTAG,""String_Node_Str"");
      Toast.makeText(MainActivity.this,""String_Node_Str"" + Demodulator.INPUT_RATE / 1000000 + ""String_Node_Str"",Toast.LENGTH_LONG).show();
      scheduler.setDemodulationActivated(false);
      mode=Demodulator.DEMODULATION_OFF;
    }
 else {
      scheduler.setDemodulationActivated(true);
    }
  }
  demodulator.setDemodulationMode(mode);
  this.demodulationMode=mode;
  if (mode == Demodulator.DEMODULATION_OFF) {
    analyzerSurface.setDemodulationEnabled(false);
  }
 else {
    analyzerSurface.setDemodulationEnabled(true);
  }
  updateActionBar();
}"
55021,"@Override public boolean onOptionsItemSelected(MenuItem item){
  int id=item.getItemId();
switch (id) {
case R.id.action_startStop:
    if (running) {
      stopAnalyzer();
      this.setDemodulationMode(Demodulator.DEMODULATION_OFF);
    }
 else     startAnalyzer();
  break;
case R.id.action_setDemodulation:
showDemodulationDialog();
break;
case R.id.action_setFrequency:
tuneToFrequency();
break;
case R.id.action_setGain:
adjustGain();
break;
case R.id.action_autoscale:
analyzerSurface.autoscale();
break;
case R.id.action_settings:
Intent intentShowSettings=new Intent(getApplicationContext(),SettingsActivity.class);
startActivity(intentShowSettings);
break;
case R.id.action_help:
Intent intentShowHelp=new Intent(Intent.ACTION_VIEW);
intentShowHelp.setData(Uri.parse(getString(R.string.help_url)));
startActivity(intentShowHelp);
break;
default :
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  int id=item.getItemId();
switch (id) {
case R.id.action_startStop:
    if (running)     stopAnalyzer();
 else     startAnalyzer();
  break;
case R.id.action_setDemodulation:
showDemodulationDialog();
break;
case R.id.action_setFrequency:
tuneToFrequency();
break;
case R.id.action_setGain:
adjustGain();
break;
case R.id.action_autoscale:
analyzerSurface.autoscale();
break;
case R.id.action_settings:
Intent intentShowSettings=new Intent(getApplicationContext(),SettingsActivity.class);
startActivity(intentShowSettings);
break;
case R.id.action_help:
Intent intentShowHelp=new Intent(Intent.ACTION_VIEW);
intentShowHelp.setData(Uri.parse(getString(R.string.help_url)));
startActivity(intentShowHelp);
break;
default :
}
return true;
}"
55022,"@Override protected void onStart(){
  super.onStart();
  checkForChangedPreferences();
  if (running)   startAnalyzer();
  this.setDemodulationMode(demodulationMode);
}","@Override protected void onStart(){
  super.onStart();
  checkForChangedPreferences();
  if (running)   startAnalyzer();
  if (savedInstanceState != null) {
    analyzerSurface.setVirtualFrequency(savedInstanceState.getLong(getString(R.string.save_state_virtualFrequency)));
    analyzerSurface.setVirtualSampleRate(savedInstanceState.getInt(getString(R.string.save_state_virtualSampleRate)));
    analyzerSurface.setDBScale(savedInstanceState.getFloat(getString(R.string.save_state_minDB)),savedInstanceState.getFloat(getString(R.string.save_state_maxDB)));
    analyzerSurface.setChannelFrequency(savedInstanceState.getLong(getString(R.string.save_state_channelFrequency)));
    analyzerSurface.setChannelWidth(savedInstanceState.getInt(getString(R.string.save_state_channelWidth)));
    analyzerSurface.setSquelch(savedInstanceState.getFloat(getString(R.string.save_state_squelch)));
    if (demodulator != null && scheduler != null) {
      demodulator.setChannelWidth(savedInstanceState.getInt(getString(R.string.save_state_channelWidth)));
      demodulator.setSquelch(savedInstanceState.getFloat(getString(R.string.save_state_squelch)));
      scheduler.setChannelFrequency(savedInstanceState.getLong(getString(R.string.save_state_channelFrequency)));
    }
    savedInstanceState=null;
  }
}"
55023,"/** 
 * Will start the RF Analyzer. This includes creating a source (if null), open a source (if not open), starting the scheduler (which starts the source) and starting the processing loop.
 */
public void startAnalyzer(){
  this.stopAnalyzer();
  int fftSize=Integer.valueOf(preferences.getString(getString(R.string.pref_fftSize),""String_Node_Str""));
  int frameRate=Integer.valueOf(preferences.getString(getString(R.string.pref_frameRate),""String_Node_Str""));
  boolean dynamicFrameRate=preferences.getBoolean(getString(R.string.pref_dynamicFrameRate),true);
  running=true;
  if (source == null) {
    if (!this.createSource())     return;
  }
  if (!source.isOpen()) {
    if (!source.open(this,this)) {
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
      running=false;
      return;
    }
    return;
  }
  scheduler=new Scheduler(fftSize,source);
  analyzerProcessingLoop=new AnalyzerProcessingLoop(analyzerSurface,fftSize,scheduler.getFftOutputQueue(),scheduler.getFftInputQueue());
  if (dynamicFrameRate)   analyzerProcessingLoop.setDynamicFrameRate(true);
 else {
    analyzerProcessingLoop.setDynamicFrameRate(false);
    analyzerProcessingLoop.setFrameRate(frameRate);
  }
  scheduler.start();
  analyzerProcessingLoop.start();
  scheduler.setChannelFrequency(analyzerSurface.getChannelFrequency());
  demodulator=new Demodulator(scheduler.getDemodOutputQueue(),scheduler.getDemodInputQueue(),source.getPacketSize());
  demodulator.start();
  updateActionBar();
}","/** 
 * Will start the RF Analyzer. This includes creating a source (if null), open a source (if not open), starting the scheduler (which starts the source) and starting the processing loop.
 */
public void startAnalyzer(){
  this.stopAnalyzer();
  int fftSize=Integer.valueOf(preferences.getString(getString(R.string.pref_fftSize),""String_Node_Str""));
  int frameRate=Integer.valueOf(preferences.getString(getString(R.string.pref_frameRate),""String_Node_Str""));
  boolean dynamicFrameRate=preferences.getBoolean(getString(R.string.pref_dynamicFrameRate),true);
  running=true;
  if (source == null) {
    if (!this.createSource())     return;
  }
  if (!source.isOpen()) {
    if (!source.open(this,this)) {
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
      running=false;
      return;
    }
    return;
  }
  scheduler=new Scheduler(fftSize,source);
  analyzerProcessingLoop=new AnalyzerProcessingLoop(analyzerSurface,fftSize,scheduler.getFftOutputQueue(),scheduler.getFftInputQueue());
  if (dynamicFrameRate)   analyzerProcessingLoop.setDynamicFrameRate(true);
 else {
    analyzerProcessingLoop.setDynamicFrameRate(false);
    analyzerProcessingLoop.setFrameRate(frameRate);
  }
  scheduler.start();
  analyzerProcessingLoop.start();
  scheduler.setChannelFrequency(analyzerSurface.getChannelFrequency());
  demodulator=new Demodulator(scheduler.getDemodOutputQueue(),scheduler.getDemodInputQueue(),source.getPacketSize());
  demodulator.start();
  this.setDemodulationMode(demodulationMode);
  updateActionBar();
}"
55024,"/** 
 * Will create a IQ Source instance according to the user settings.
 * @return true on success; false on error
 */
public boolean createSource(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
switch (sourceType) {
case FILE_SOURCE:
    long frequency;
  int sampleRate;
try {
  frequency=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
  sampleRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
}
 catch (NumberFormatException e) {
  this.runOnUiThread(new Runnable(){
    @Override public void run(){
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
  }
);
  return false;
}
String filename=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
source=new FileIQSource(filename,sampleRate,frequency,16384,repeat);
break;
case HACKRF_SOURCE:
source=new HackrfSource();
source.setFrequency(preferences.getLong(getString(R.string.pref_frequency),97000000));
source.setSampleRate(preferences.getInt(getString(R.string.pref_sampleRate),HackrfSource.MAX_SAMPLERATE));
((HackrfSource)source).setVgaRxGain(preferences.getInt(getString(R.string.pref_hackrf_vgaRxGain),HackrfSource.MAX_VGA_RX_GAIN / 2));
((HackrfSource)source).setLnaGain(preferences.getInt(getString(R.string.pref_hackrf_lnaGain),HackrfSource.MAX_LNA_GAIN / 2));
break;
case RTLSDR_SOURCE:
Log.e(LOGTAG,""String_Node_Str"");
Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
return false;
default :
Log.e(LOGTAG,""String_Node_Str"" + sourceType);
return false;
}
analyzerSurface.setSource(source);
if (savedInstanceState != null) {
analyzerSurface.setVirtualFrequency(savedInstanceState.getLong(getString(R.string.save_state_virtualFrequency)));
analyzerSurface.setVirtualSampleRate(savedInstanceState.getInt(getString(R.string.save_state_virtualSampleRate)));
analyzerSurface.setDBScale(savedInstanceState.getFloat(getString(R.string.save_state_minDB)),savedInstanceState.getFloat(getString(R.string.save_state_maxDB)));
savedInstanceState=null;
}
return true;
}","/** 
 * Will create a IQ Source instance according to the user settings.
 * @return true on success; false on error
 */
public boolean createSource(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
switch (sourceType) {
case FILE_SOURCE:
    long frequency;
  int sampleRate;
try {
  frequency=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
  sampleRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
}
 catch (NumberFormatException e) {
  this.runOnUiThread(new Runnable(){
    @Override public void run(){
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
  }
);
  return false;
}
String filename=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
source=new FileIQSource(filename,sampleRate,frequency,16384,repeat);
break;
case HACKRF_SOURCE:
source=new HackrfSource();
source.setFrequency(preferences.getLong(getString(R.string.pref_frequency),97000000));
source.setSampleRate(preferences.getInt(getString(R.string.pref_sampleRate),HackrfSource.MAX_SAMPLERATE));
((HackrfSource)source).setVgaRxGain(preferences.getInt(getString(R.string.pref_hackrf_vgaRxGain),HackrfSource.MAX_VGA_RX_GAIN / 2));
((HackrfSource)source).setLnaGain(preferences.getInt(getString(R.string.pref_hackrf_lnaGain),HackrfSource.MAX_LNA_GAIN / 2));
break;
case RTLSDR_SOURCE:
Log.e(LOGTAG,""String_Node_Str"");
Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
return false;
default :
Log.e(LOGTAG,""String_Node_Str"" + sourceType);
return false;
}
analyzerSurface.setSource(source);
return true;
}"
55025,"@Override protected void onSaveInstanceState(Bundle outState){
  outState.putBoolean(getString(R.string.save_state_running),running);
  outState.putInt(getString(R.string.save_state_demodulatorMode),demodulationMode);
  if (analyzerSurface != null) {
    outState.putLong(getString(R.string.save_state_virtualFrequency),analyzerSurface.getVirtualFrequency());
    outState.putInt(getString(R.string.save_state_virtualSampleRate),analyzerSurface.getVirtualSampleRate());
    outState.putFloat(getString(R.string.save_state_minDB),analyzerSurface.getMinDB());
    outState.putFloat(getString(R.string.save_state_maxDB),analyzerSurface.getMaxDB());
  }
}","@Override protected void onSaveInstanceState(Bundle outState){
  outState.putBoolean(getString(R.string.save_state_running),running);
  outState.putInt(getString(R.string.save_state_demodulatorMode),demodulationMode);
  if (analyzerSurface != null) {
    outState.putLong(getString(R.string.save_state_channelFrequency),analyzerSurface.getChannelFrequency());
    outState.putInt(getString(R.string.save_state_channelWidth),analyzerSurface.getChannelWidth());
    outState.putFloat(getString(R.string.save_state_squelch),analyzerSurface.getSquelch());
    outState.putLong(getString(R.string.save_state_virtualFrequency),analyzerSurface.getVirtualFrequency());
    outState.putInt(getString(R.string.save_state_virtualSampleRate),analyzerSurface.getVirtualSampleRate());
    outState.putFloat(getString(R.string.save_state_minDB),analyzerSurface.getMinDB());
    outState.putFloat(getString(R.string.save_state_maxDB),analyzerSurface.getMaxDB());
  }
}"
55026,"@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){
  if (source != null) {
    virtualFrequency=Math.min(Math.max(virtualFrequency + (long)((virtualSampleRate / width) * distanceX),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (verticalScrollEnabled) {
      float yDiff=(maxDB - minDB) * (distanceY / (float)getFftHeight());
      if (maxDB - yDiff > MAX_DB)       yDiff=MAX_DB - maxDB;
      if (minDB - yDiff < MIN_DB)       yDiff=MIN_DB - minDB;
      this.setDBScale(minDB - yDiff,maxDB - yDiff);
    }
  }
  return true;
}","@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){
  if (source != null) {
    virtualFrequency=Math.min(Math.max(virtualFrequency + (long)(((virtualSampleRate / (float)width) * distanceX)),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (virtualFrequency <= 0)     virtualFrequency=1;
    if (verticalScrollEnabled) {
      float yDiff=(maxDB - minDB) * (distanceY / (float)getFftHeight());
      if (maxDB - yDiff > MAX_DB)       yDiff=MAX_DB - maxDB;
      if (minDB - yDiff < MIN_DB)       yDiff=MIN_DB - minDB;
      this.setDBScale(minDB - yDiff,maxDB - yDiff);
    }
  }
  return true;
}"
55027,"@Override public boolean onScale(ScaleGestureDetector detector){
  if (source != null) {
    float xScale=detector.getCurrentSpanX() / detector.getPreviousSpanX();
    long frequencyFocus=virtualFrequency + (int)((detector.getFocusX() / width - 0.5) * virtualSampleRate);
    virtualSampleRate=(int)Math.min(Math.max(virtualSampleRate / xScale,1),source.getMaxSampleRate());
    virtualFrequency=Math.min(Math.max(frequencyFocus + (long)((virtualFrequency - frequencyFocus) / xScale),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (verticalZoomEnabled) {
      float yScale=detector.getCurrentSpanY() / detector.getPreviousSpanY();
      float dBFocus=maxDB - (maxDB - minDB) * (detector.getFocusY() / getFftHeight());
      float newMinDB=Math.min(Math.max(dBFocus - (dBFocus - minDB) / yScale,MIN_DB),MAX_DB - 10);
      float newMaxDB=Math.min(Math.max(dBFocus - (dBFocus - maxDB) / yScale,newMinDB + 10),MAX_DB);
      this.setDBScale(newMinDB,newMaxDB);
    }
  }
  return true;
}","@Override public boolean onScale(ScaleGestureDetector detector){
  if (source != null) {
    float xScale=detector.getCurrentSpanX() / detector.getPreviousSpanX();
    long frequencyFocus=virtualFrequency + (int)((detector.getFocusX() / width - 0.5) * virtualSampleRate);
    virtualSampleRate=(int)Math.min(Math.max(virtualSampleRate / xScale,MIN_VIRTUAL_SAMPLERATE),source.getMaxSampleRate());
    virtualFrequency=Math.min(Math.max(frequencyFocus + (long)((virtualFrequency - frequencyFocus) / xScale),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (verticalZoomEnabled) {
      float yScale=detector.getCurrentSpanY() / detector.getPreviousSpanY();
      float dBFocus=maxDB - (maxDB - minDB) * (detector.getFocusY() / getFftHeight());
      float newMinDB=Math.min(Math.max(dBFocus - (dBFocus - minDB) / yScale,MIN_DB),MAX_DB - 10);
      float newMaxDB=Math.min(Math.max(dBFocus - (dBFocus - maxDB) / yScale,newMinDB + 10),MAX_DB);
      this.setDBScale(newMinDB,newMaxDB);
    }
  }
  return true;
}"
55028,"/** 
 * Will pop up a dialog to let the user input a new frequency.
 */
private void tuneToFrequency(){
  if (source == null)   return;
  final EditText et_input=new EditText(this);
  et_input.setInputType(InputType.TYPE_CLASS_NUMBER);
  new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"" + source.getFrequency() + ""String_Node_Str"").setView(et_input).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      try {
        long newFreq=Long.valueOf(et_input.getText().toString());
        source.setFrequency(newFreq);
        analyzerSurface.setVirtualFrequency(newFreq);
      }
 catch (      NumberFormatException e) {
        Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).show();
}","/** 
 * Will pop up a dialog to let the user input a new frequency.
 */
private void tuneToFrequency(){
  if (source == null)   return;
  final EditText et_input=new EditText(this);
  et_input.setInputType(InputType.TYPE_CLASS_NUMBER);
  new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"" + source.getFrequency() + ""String_Node_Str"").setView(et_input).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      try {
        long newFreq=Long.valueOf(et_input.getText().toString());
        if (newFreq <= source.getMaxFrequency() && newFreq >= source.getMinFrequency()) {
          source.setFrequency(newFreq);
          analyzerSurface.setVirtualFrequency(newFreq);
        }
 else {
          Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        }
      }
 catch (      NumberFormatException e) {
        Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      }
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
    }
  }
).show();
}"
55029,"@GetMapping(value={""String_Node_Str"",""String_Node_Str""}) public ModelAndView rootNode(@PathVariable(required=false) String version){
  final String root=getRoot();
  final List<String> versions=nodeService.listChildren(root).stream().filter(e -> !e.endsWith(COMMENT_SUFFIX)).sorted(Comparator.comparing(String::toString).reversed()).collect(Collectors.toList());
  final String theVersion=com.google.common.base.Objects.firstNonNull(version,Iterables.getFirst(versions,null));
  final ModelAndView mv=new ModelAndView(""String_Node_Str"");
  mv.addObject(""String_Node_Str"",root);
  mv.addObject(""String_Node_Str"",versions);
  mv.addObject(""String_Node_Str"",theVersion);
  if (Iterables.contains(versions,theVersion)) {
    final List<String> groups=nodeService.listChildren(makePaths(root,theVersion)).stream().sorted().collect(Collectors.toList());
    mv.addObject(""String_Node_Str"",groups);
  }
  return mv;
}","@GetMapping(value={""String_Node_Str"",""String_Node_Str""}) public ModelAndView rootNode(@PathVariable(required=false) String version){
  final String root=getRoot();
  final List<String> versions=nodeService.listChildren(root).stream().filter(e -> !e.endsWith(COMMENT_SUFFIX)).sorted(Comparator.comparing(String::toString).reversed()).collect(Collectors.toList());
  final String theVersion=version != null ? version : Iterables.getFirst(versions,null);
  final ModelAndView mv=new ModelAndView(""String_Node_Str"");
  mv.addObject(""String_Node_Str"",root);
  mv.addObject(""String_Node_Str"",versions);
  mv.addObject(""String_Node_Str"",theVersion);
  if (Iterables.contains(versions,theVersion)) {
    final List<String> groups=nodeService.listChildren(makePaths(root,theVersion)).stream().sorted().collect(Collectors.toList());
    mv.addObject(""String_Node_Str"",groups);
  }
  return mv;
}"
55030,"/** 
 * @param inputstream
 * @return
 * @throws IOException
 */
private List<PropertyItemVO> parseInputFile(InputStream inputstream) throws IOException {
  List<String> lines=IOUtils.readLines(inputstream,Charsets.UTF_8.name());
  List<PropertyItemVO> items=Lists.newArrayList();
  String previousLine=null;
  for (int i=1; i < lines.size(); i++) {
    String line=lines.get(i);
    if (!line.startsWith(""String_Node_Str"")) {
      Iterable<String> parts=PROPERTY_SPLITTER.split(line);
      if (Iterables.size(parts) == 2) {
        PropertyItemVO item=new PropertyItemVO(Iterables.getFirst(parts,null).trim(),Iterables.getLast(parts).trim());
        if (previousLine != null && previousLine.startsWith(""String_Node_Str"")) {
          item.setComment(StringUtils.trimLeadingCharacter(previousLine,'#').trim());
        }
        items.add(item);
      }
    }
    previousLine=line;
  }
  return items;
}","/** 
 * @param inputstream
 * @return
 * @throws IOException
 */
private List<PropertyItemVO> parseInputFile(InputStream inputstream) throws IOException {
  List<String> lines=IOUtils.readLines(inputstream,Charsets.UTF_8.name());
  List<PropertyItemVO> items=Lists.newArrayList();
  String previousLine=null;
  for (int i=0; i < lines.size(); i++) {
    String line=lines.get(i);
    if (!line.startsWith(""String_Node_Str"")) {
      Iterable<String> parts=PROPERTY_SPLITTER.split(line);
      if (Iterables.size(parts) == 2) {
        PropertyItemVO item=new PropertyItemVO(Iterables.getFirst(parts,null).trim(),Iterables.getLast(parts).trim());
        if (previousLine != null && previousLine.startsWith(""String_Node_Str"")) {
          item.setComment(StringUtils.trimLeadingCharacter(previousLine,'#').trim());
        }
        items.add(item);
      }
    }
    previousLine=line;
  }
  return items;
}"
55031,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.layout_novel_info);
  aid=getIntent().getIntExtra(""String_Node_Str"",1);
  from=getIntent().getStringExtra(""String_Node_Str"");
  title=getIntent().getStringExtra(""String_Node_Str"");
  Toolbar mToolbar=findViewById(R.id.toolbar_actionbar);
  setSupportActionBar(mToolbar);
  final Drawable upArrow=getResources().getDrawable(R.drawable.ic_svg_back);
  if (getSupportActionBar() != null && upArrow != null) {
    getSupportActionBar().setHomeButtonEnabled(true);
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    upArrow.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
    getSupportActionBar().setHomeAsUpIndicator(upArrow);
  }
  if (Build.VERSION.SDK_INT >= 16) {
    SystemBarTintManager tintManager=new SystemBarTintManager(this);
    tintManager.setStatusBarTintEnabled(true);
    tintManager.setNavigationBarTintEnabled(true);
    tintManager.setTintAlpha(0.15f);
    tintManager.setNavigationBarAlpha(0.0f);
    tintManager.setTintColor(getResources().getColor(android.R.color.black));
    if (Build.VERSION.SDK_INT >= 21)     getWindow().setNavigationBarColor(getResources().getColor(R.color.myNavigationColor));
  }
  if (ImageLoader.getInstance() == null || !ImageLoader.getInstance().isInited()) {
    GlobalConfig.initImageLoader(this);
  }
  rlMask=findViewById(R.id.white_mask);
  mLinearLayout=findViewById(R.id.novel_info_scroll);
  LinearLayout llCardLayout=findViewById(R.id.item_card);
  ImageView ivNovelCover=findViewById(R.id.novel_cover);
  tvNovelTitle=findViewById(R.id.novel_title);
  tvNovelAuthor=findViewById(R.id.novel_author);
  tvNovelStatus=findViewById(R.id.novel_status);
  tvNovelUpdate=findViewById(R.id.novel_update);
  TextView tvLatestChapterNameText=findViewById(R.id.novel_item_text_shortinfo);
  tvLatestChapter=findViewById(R.id.novel_intro);
  tvNovelFullIntro=findViewById(R.id.novel_intro_full);
  ImageButton ibNovelOption=findViewById(R.id.novel_option);
  fabFavorite=findViewById(R.id.fab_favorate);
  FloatingActionButton fabDownload=findViewById(R.id.fab_download);
  famMenu=findViewById(R.id.multiple_actions);
  spb=findViewById(R.id.spb);
  tvNovelTitle.setText(title);
  if (LightCache.testFileExist(GlobalConfig.getFirstStoragePath() + ""String_Node_Str"" + File.separator+ aid+ ""String_Node_Str""))   ImageLoader.getInstance().displayImage(""String_Node_Str"" + GlobalConfig.getFirstStoragePath() + ""String_Node_Str""+ File.separator+ aid+ ""String_Node_Str"",ivNovelCover);
 else   if (LightCache.testFileExist(GlobalConfig.getSecondStoragePath() + ""String_Node_Str"" + File.separator+ aid+ ""String_Node_Str""))   ImageLoader.getInstance().displayImage(""String_Node_Str"" + GlobalConfig.getSecondStoragePath() + ""String_Node_Str""+ File.separator+ aid+ ""String_Node_Str"",ivNovelCover);
 else   ImageLoader.getInstance().displayImage(Wenku8API.getCoverURL(aid),ivNovelCover);
  tvLatestChapterNameText.setText(getResources().getText(R.string.novel_item_latest_chapter));
  ibNovelOption.setVisibility(ImageButton.INVISIBLE);
  fabFavorite.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  fabDownload.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  llCardLayout.setBackgroundResource(R.color.menu_transparent);
  if (GlobalConfig.testInLocalBookshelf(aid)) {
    fabFavorite.setIcon(R.drawable.ic_favorate_pressed);
  }
  getSupportActionBar().setTitle(R.string.action_novel_info);
  spb.setVisibility(View.INVISIBLE);
  Handler handler=new Handler();
  handler.postDelayed(() -> {
    spb.setVisibility(View.VISIBLE);
    if (from.equals(FromLocal))     refreshInfoFromLocal();
 else     refreshInfoFromCloud();
  }
,500);
  famMenu.setOnFloatingActionsMenuUpdateListener(new FloatingActionsMenu.OnFloatingActionsMenuUpdateListener(){
    @Override public void onMenuExpanded(){
      rlMask.setVisibility(View.VISIBLE);
    }
    @Override public void onMenuCollapsed(){
      rlMask.setVisibility(View.INVISIBLE);
    }
  }
);
  rlMask.setOnClickListener(v -> {
    if (famMenu.isExpanded())     famMenu.collapse();
  }
);
  if (Build.VERSION.SDK_INT >= 16) {
    tvNovelTitle.setBackground(getResources().getDrawable(R.drawable.btn_menu_item));
    tvNovelAuthor.setBackground(getResources().getDrawable(R.drawable.btn_menu_item));
    tvLatestChapter.setBackground(getResources().getDrawable(R.drawable.btn_menu_item));
  }
  tvNovelTitle.setOnClickListener(v -> {
    if (isLoading) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
      return;
    }
    new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).titleColorRes(R.color.dlgTitleColor).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).title(R.string.dialog_content_novel_title).content(aid + ""String_Node_Str"" + mNovelItemMeta.title).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_known).show();
  }
);
  tvNovelAuthor.setOnClickListener(v -> {
    if (isLoading) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
      return;
    }
    new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).onPositive((ignored1,ignored2) -> {
      Intent intent=new Intent(NovelInfoActivity.this,SearchResultActivity.class);
      intent.putExtra(""String_Node_Str"",mNovelItemMeta.author);
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
      startActivity(intent);
      overridePendingTransition(R.anim.fade_in,R.anim.hold);
    }
).content(R.string.dialog_content_search_author).positiveText(R.string.dialog_positive_ok).negativeText(R.string.dialog_negative_biao).show();
  }
);
  fabFavorite.setOnClickListener(v -> {
    if (isLoading) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
      return;
    }
    if (GlobalConfig.testInLocalBookshelf(aid)) {
      new MaterialDialog.Builder(NovelInfoActivity.this).onPositive((ignored1,ignored2) -> {
        AsyncRemoveBookFromCloud arbfc=new AsyncRemoveBookFromCloud();
        arbfc.execute(aid);
      }
).theme(Theme.LIGHT).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).negativeColorRes(R.color.dlgNegativeButtonColor).content(R.string.dialog_content_sure_to_unfav).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_yes).negativeText(R.string.dialog_negative_preferno).show();
    }
 else {
      GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullMeta);
      GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullIntro);
      GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullVolume);
      GlobalConfig.addToLocalBookshelf(aid);
      if (GlobalConfig.testInLocalBookshelf(aid)) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_added),Toast.LENGTH_SHORT).show();
        fabFavorite.setIcon(R.drawable.ic_favorate_pressed);
      }
 else {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_error),Toast.LENGTH_SHORT).show();
      }
    }
  }
);
  fabDownload.setOnClickListener(v -> {
    if (isLoading) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
      return;
    }
 else     if (!GlobalConfig.testInLocalBookshelf(aid)) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_fav_it_first),Toast.LENGTH_SHORT).show();
      return;
    }
    new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).title(R.string.dialog_title_choose_download_option).backgroundColorRes(R.color.dlgBackgroundColor).titleColorRes(R.color.dlgTitleColor).negativeText(R.string.dialog_negative_pass).negativeColorRes(R.color.dlgNegativeButtonColor).itemsGravity(GravityEnum.CENTER).items(R.array.download_option).itemsCallback((dialog,view,which,text) -> {
switch (which) {
case 0:
        optionCheckUpdates();
      break;
case 1:
    optionDownloadUpdates();
  break;
case 2:
optionDownloadOverride();
break;
case 3:
optionDownloadSelected();
break;
}
}
).show();
}
);
tvLatestChapter.setOnClickListener(view -> {
if (mNovelItemMeta != null && mNovelItemMeta.latestSectionCid != 0) showDirectJumpToReaderDialog(mNovelItemMeta.latestSectionCid);
 else Toast.makeText(this,getResources().getText(R.string.reader_msg_please_refresh_and_retry),Toast.LENGTH_SHORT).show();
}
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.layout_novel_info);
  aid=getIntent().getIntExtra(""String_Node_Str"",1);
  from=getIntent().getStringExtra(""String_Node_Str"");
  title=getIntent().getStringExtra(""String_Node_Str"");
  Toolbar mToolbar=findViewById(R.id.toolbar_actionbar);
  setSupportActionBar(mToolbar);
  final Drawable upArrow=getResources().getDrawable(R.drawable.ic_svg_back);
  if (getSupportActionBar() != null && upArrow != null) {
    getSupportActionBar().setHomeButtonEnabled(true);
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    upArrow.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
    getSupportActionBar().setHomeAsUpIndicator(upArrow);
  }
  if (Build.VERSION.SDK_INT >= 16) {
    SystemBarTintManager tintManager=new SystemBarTintManager(this);
    tintManager.setStatusBarTintEnabled(true);
    tintManager.setNavigationBarTintEnabled(true);
    tintManager.setTintAlpha(0.15f);
    tintManager.setNavigationBarAlpha(0.0f);
    tintManager.setTintColor(getResources().getColor(android.R.color.black));
    if (Build.VERSION.SDK_INT >= 21)     getWindow().setNavigationBarColor(getResources().getColor(R.color.myNavigationColor));
  }
  if (ImageLoader.getInstance() == null || !ImageLoader.getInstance().isInited()) {
    GlobalConfig.initImageLoader(this);
  }
  rlMask=findViewById(R.id.white_mask);
  mLinearLayout=findViewById(R.id.novel_info_scroll);
  LinearLayout llCardLayout=findViewById(R.id.item_card);
  ImageView ivNovelCover=findViewById(R.id.novel_cover);
  tvNovelTitle=findViewById(R.id.novel_title);
  tvNovelAuthor=findViewById(R.id.novel_author);
  tvNovelStatus=findViewById(R.id.novel_status);
  tvNovelUpdate=findViewById(R.id.novel_update);
  TextView tvLatestChapterNameText=findViewById(R.id.novel_item_text_shortinfo);
  tvLatestChapter=findViewById(R.id.novel_intro);
  tvNovelFullIntro=findViewById(R.id.novel_intro_full);
  ImageButton ibNovelOption=findViewById(R.id.novel_option);
  fabFavorite=findViewById(R.id.fab_favorate);
  FloatingActionButton fabDownload=findViewById(R.id.fab_download);
  famMenu=findViewById(R.id.multiple_actions);
  spb=findViewById(R.id.spb);
  tvNovelTitle.setText(title);
  if (LightCache.testFileExist(GlobalConfig.getFirstStoragePath() + ""String_Node_Str"" + File.separator+ aid+ ""String_Node_Str""))   ImageLoader.getInstance().displayImage(""String_Node_Str"" + GlobalConfig.getFirstStoragePath() + ""String_Node_Str""+ File.separator+ aid+ ""String_Node_Str"",ivNovelCover);
 else   if (LightCache.testFileExist(GlobalConfig.getSecondStoragePath() + ""String_Node_Str"" + File.separator+ aid+ ""String_Node_Str""))   ImageLoader.getInstance().displayImage(""String_Node_Str"" + GlobalConfig.getSecondStoragePath() + ""String_Node_Str""+ File.separator+ aid+ ""String_Node_Str"",ivNovelCover);
 else   ImageLoader.getInstance().displayImage(Wenku8API.getCoverURL(aid),ivNovelCover);
  tvLatestChapterNameText.setText(getResources().getText(R.string.novel_item_latest_chapter));
  ibNovelOption.setVisibility(ImageButton.INVISIBLE);
  fabFavorite.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  fabDownload.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  llCardLayout.setBackgroundResource(R.color.menu_transparent);
  if (GlobalConfig.testInLocalBookshelf(aid)) {
    fabFavorite.setIcon(R.drawable.ic_favorate_pressed);
  }
  getSupportActionBar().setTitle(R.string.action_novel_info);
  spb.setVisibility(View.INVISIBLE);
  Handler handler=new Handler();
  handler.postDelayed(() -> {
    spb.setVisibility(View.VISIBLE);
    if (from.equals(FromLocal))     refreshInfoFromLocal();
 else     refreshInfoFromCloud();
  }
,500);
  famMenu.setOnFloatingActionsMenuUpdateListener(new FloatingActionsMenu.OnFloatingActionsMenuUpdateListener(){
    @Override public void onMenuExpanded(){
      rlMask.setVisibility(View.VISIBLE);
    }
    @Override public void onMenuCollapsed(){
      rlMask.setVisibility(View.INVISIBLE);
    }
  }
);
  rlMask.setOnClickListener(v -> {
    if (famMenu.isExpanded())     famMenu.collapse();
  }
);
  if (Build.VERSION.SDK_INT >= 16) {
    tvNovelTitle.setBackground(getResources().getDrawable(R.drawable.btn_menu_item));
    tvNovelAuthor.setBackground(getResources().getDrawable(R.drawable.btn_menu_item));
    tvLatestChapter.setBackground(getResources().getDrawable(R.drawable.btn_menu_item));
  }
  tvNovelTitle.setOnClickListener(v -> {
    if (runLoadingChecker())     return;
    new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).titleColorRes(R.color.dlgTitleColor).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).title(R.string.dialog_content_novel_title).content(aid + ""String_Node_Str"" + mNovelItemMeta.title).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_known).show();
  }
);
  tvNovelAuthor.setOnClickListener(v -> {
    if (runLoadingChecker())     return;
    new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).onPositive((ignored1,ignored2) -> {
      Intent intent=new Intent(NovelInfoActivity.this,SearchResultActivity.class);
      intent.putExtra(""String_Node_Str"",mNovelItemMeta.author);
      intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
      startActivity(intent);
      overridePendingTransition(R.anim.fade_in,R.anim.hold);
    }
).content(R.string.dialog_content_search_author).positiveText(R.string.dialog_positive_ok).negativeText(R.string.dialog_negative_biao).show();
  }
);
  fabFavorite.setOnClickListener(v -> {
    if (runLoadingChecker())     return;
    if (GlobalConfig.testInLocalBookshelf(aid)) {
      new MaterialDialog.Builder(NovelInfoActivity.this).onPositive((ignored1,ignored2) -> {
        AsyncRemoveBookFromCloud arbfc=new AsyncRemoveBookFromCloud();
        arbfc.execute(aid);
      }
).theme(Theme.LIGHT).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).negativeColorRes(R.color.dlgNegativeButtonColor).content(R.string.dialog_content_sure_to_unfav).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_yes).negativeText(R.string.dialog_negative_preferno).show();
    }
 else {
      GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullMeta);
      GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullIntro);
      GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullVolume);
      GlobalConfig.addToLocalBookshelf(aid);
      if (GlobalConfig.testInLocalBookshelf(aid)) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_added),Toast.LENGTH_SHORT).show();
        fabFavorite.setIcon(R.drawable.ic_favorate_pressed);
      }
 else {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_error),Toast.LENGTH_SHORT).show();
      }
    }
  }
);
  fabDownload.setOnClickListener(v -> {
    if (runLoadingChecker())     return;
    if (!GlobalConfig.testInLocalBookshelf(aid)) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_fav_it_first),Toast.LENGTH_SHORT).show();
      return;
    }
    new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).title(R.string.dialog_title_choose_download_option).backgroundColorRes(R.color.dlgBackgroundColor).titleColorRes(R.color.dlgTitleColor).negativeText(R.string.dialog_negative_pass).negativeColorRes(R.color.dlgNegativeButtonColor).itemsGravity(GravityEnum.CENTER).items(R.array.download_option).itemsCallback((dialog,view,which,text) -> {
switch (which) {
case 0:
        optionCheckUpdates();
      break;
case 1:
    optionDownloadUpdates();
  break;
case 2:
optionDownloadOverride();
break;
case 3:
optionDownloadSelected();
break;
}
}
).show();
}
);
tvLatestChapter.setOnClickListener(view -> {
if (runLoadingChecker()) return;
if (mNovelItemMeta != null && mNovelItemMeta.latestSectionCid != 0) showDirectJumpToReaderDialog(mNovelItemMeta.latestSectionCid);
 else Toast.makeText(this,getResources().getText(R.string.reader_msg_please_refresh_and_retry),Toast.LENGTH_SHORT).show();
}
);
}"
55032,"@Override public boolean onOptionsItemSelected(MenuItem menuItem){
  if (menuItem.getItemId() == android.R.id.home) {
    if (Build.VERSION.SDK_INT < 21)     finish();
 else     finishAfterTransition();
  }
 else   if (menuItem.getItemId() == R.id.action_continue_read_progress) {
    if (isLoading) {
      Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
      return true;
    }
    final GlobalConfig.ReadSavesV1 rs=GlobalConfig.getReadSavesRecordV1(aid);
    if (rs != null) {
      showDirectJumpToReaderDialog(rs.cid);
      return true;
    }
    Toast.makeText(this,getResources().getText(R.string.reader_msg_no_saved_reading_progress),Toast.LENGTH_SHORT).show();
  }
 else   if (menuItem.getItemId() == R.id.action_go_to_forum) {
    Intent intent=new Intent(NovelInfoActivity.this,NovelReviewListActivity.class);
    intent.putExtra(""String_Node_Str"",aid);
    startActivity(intent);
  }
  return super.onOptionsItemSelected(menuItem);
}","@Override public boolean onOptionsItemSelected(MenuItem menuItem){
  if (menuItem.getItemId() == android.R.id.home) {
    if (Build.VERSION.SDK_INT < 21)     finish();
 else     finishAfterTransition();
  }
 else   if (menuItem.getItemId() == R.id.action_continue_read_progress) {
    if (runLoadingChecker())     return true;
    final GlobalConfig.ReadSavesV1 rs=GlobalConfig.getReadSavesRecordV1(aid);
    if (rs != null) {
      showDirectJumpToReaderDialog(rs.cid);
      return true;
    }
    Toast.makeText(this,getResources().getText(R.string.reader_msg_no_saved_reading_progress),Toast.LENGTH_SHORT).show();
  }
 else   if (menuItem.getItemId() == R.id.action_go_to_forum) {
    Intent intent=new Intent(NovelInfoActivity.this,NovelReviewListActivity.class);
    intent.putExtra(""String_Node_Str"",aid);
    startActivity(intent);
  }
  return super.onOptionsItemSelected(menuItem);
}"
55033,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.layout_main);
  LightCache.saveFile(GlobalConfig.getFirstStoragePath() + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"".getBytes(),false);
  GlobalConfig.setFirstStoragePathStatus(LightCache.testFileExist(GlobalConfig.getFirstStoragePath() + ""String_Node_Str"" + File.separator+ ""String_Node_Str""));
  LightCache.saveFile(GlobalConfig.getSecondStoragePath() + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"".getBytes(),false);
  UnlimitedDiscCache localUnlimitedDiscCache=new UnlimitedDiscCache(new File(GlobalConfig.getFirstStoragePath() + ""String_Node_Str""),new File(getCacheDir() + File.separator + ""String_Node_Str""));
  DisplayImageOptions localDisplayImageOptions=new DisplayImageOptions.Builder().resetViewBeforeLoading(true).cacheOnDisk(true).cacheInMemory(true).bitmapConfig(Bitmap.Config.RGB_565).resetViewBeforeLoading(true).displayer(new FadeInBitmapDisplayer(250)).build();
  ImageLoaderConfiguration localImageLoaderConfiguration=new ImageLoaderConfiguration.Builder(this).diskCache(localUnlimitedDiscCache).defaultDisplayImageOptions(localDisplayImageOptions).build();
  ImageLoader.getInstance().init(localImageLoaderConfiguration);
  GlobalConfig.initVolleyNetwork();
  MobclickAgent.updateOnlineConfig(this);
  mToolbar=(Toolbar)findViewById(R.id.toolbar_actionbar);
  setSupportActionBar(mToolbar);
  mNavigationDrawerFragment=(NavigationDrawerFragment)getFragmentManager().findFragmentById(R.id.fragment_drawer);
  mNavigationDrawerFragment.setup(R.id.fragment_drawer,(DrawerLayout)findViewById(R.id.drawer),mToolbar);
  mToolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      if (item.getItemId() == R.id.action_search) {
        startActivity(new Intent(MainActivity.this,SearchActivity.class));
        overridePendingTransition(R.anim.fade_in,R.anim.hold);
      }
      return true;
    }
  }
);
  if (Build.VERSION.SDK_INT >= 16) {
    SystemBarTintManager tintManager=new SystemBarTintManager(this);
    tintManager.setStatusBarTintEnabled(true);
    tintManager.setNavigationBarTintEnabled(true);
    tintManager.setTintAlpha(0.15f);
    tintManager.setTintColor(getResources().getColor(android.R.color.black));
    if (Build.VERSION.SDK_INT >= 21)     getWindow().setNavigationBarColor(getResources().getColor(R.color.myNavigationColor));
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.layout_main);
  LightCache.saveFile(GlobalConfig.getFirstStoragePath() + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"".getBytes(),false);
  GlobalConfig.setFirstStoragePathStatus(LightCache.testFileExist(GlobalConfig.getFirstStoragePath() + ""String_Node_Str"" + File.separator+ ""String_Node_Str""));
  LightCache.saveFile(GlobalConfig.getSecondStoragePath() + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str"".getBytes(),false);
  if (ImageLoader.getInstance() == null || !ImageLoader.getInstance().isInited()) {
    GlobalConfig.initImageLoader(this);
  }
  GlobalConfig.initVolleyNetwork();
  MobclickAgent.updateOnlineConfig(this);
  mToolbar=(Toolbar)findViewById(R.id.toolbar_actionbar);
  setSupportActionBar(mToolbar);
  mNavigationDrawerFragment=(NavigationDrawerFragment)getFragmentManager().findFragmentById(R.id.fragment_drawer);
  mNavigationDrawerFragment.setup(R.id.fragment_drawer,(DrawerLayout)findViewById(R.id.drawer),mToolbar);
  mToolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener(){
    @Override public boolean onMenuItemClick(    MenuItem item){
      if (item.getItemId() == R.id.action_search) {
        startActivity(new Intent(MainActivity.this,SearchActivity.class));
        overridePendingTransition(R.anim.fade_in,R.anim.hold);
      }
      return true;
    }
  }
);
  if (Build.VERSION.SDK_INT >= 16) {
    SystemBarTintManager tintManager=new SystemBarTintManager(this);
    tintManager.setStatusBarTintEnabled(true);
    tintManager.setNavigationBarTintEnabled(true);
    tintManager.setTintAlpha(0.15f);
    tintManager.setTintColor(getResources().getColor(android.R.color.black));
    if (Build.VERSION.SDK_INT >= 21)     getWindow().setNavigationBarColor(getResources().getColor(R.color.myNavigationColor));
  }
}"
55034,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.layout_novel_info);
  aid=getIntent().getIntExtra(""String_Node_Str"",1);
  from=getIntent().getStringExtra(""String_Node_Str"");
  mToolbar=(Toolbar)findViewById(R.id.toolbar_actionbar);
  setSupportActionBar(mToolbar);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  getSupportActionBar().setHomeButtonEnabled(true);
  final Drawable upArrow=getResources().getDrawable(R.drawable.abc_ic_ab_back_mtrl_am_alpha);
  upArrow.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  getSupportActionBar().setHomeAsUpIndicator(upArrow);
  if (Build.VERSION.SDK_INT >= 16) {
    SystemBarTintManager tintManager=new SystemBarTintManager(this);
    tintManager.setStatusBarTintEnabled(true);
    tintManager.setNavigationBarTintEnabled(true);
    tintManager.setTintAlpha(0.15f);
    tintManager.setTintColor(getResources().getColor(android.R.color.black));
  }
  rlMask=(RelativeLayout)findViewById(R.id.white_mask);
  mLinearLayout=(LinearLayout)findViewById(R.id.novel_info_scroll);
  llCardLayout=(LinearLayout)findViewById(R.id.item_card);
  ivNovelCover=(ImageView)findViewById(R.id.novel_cover);
  tvNovelTitle=(TextView)findViewById(R.id.novel_title);
  tvNovelAuthor=(TextView)findViewById(R.id.novel_author);
  tvNovelStatus=(TextView)findViewById(R.id.novel_status);
  tvNovelUpdate=(TextView)findViewById(R.id.novel_update);
  tvNovelShortIntro=(TableRow)findViewById(R.id.novel_intro_row);
  tvNovelFullIntro=(TextView)findViewById(R.id.novel_intro_full);
  ibNovelOption=(ImageButton)findViewById(R.id.novel_option);
  fabFavorate=(FloatingActionButton)findViewById(R.id.fab_favorate);
  fabDownload=(FloatingActionButton)findViewById(R.id.fab_download);
  famMenu=(FloatingActionsMenu)findViewById(R.id.multiple_actions);
  spb=(SmoothProgressBar)findViewById(R.id.spb);
  ImageLoader.getInstance().displayImage(Wenku8API.getCoverURL(aid),ivNovelCover);
  tvNovelShortIntro.setVisibility(TextView.GONE);
  ibNovelOption.setVisibility(ImageButton.INVISIBLE);
  fabFavorate.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  fabDownload.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  llCardLayout.setBackgroundResource(R.color.menu_transparent);
  spb.progressiveStart();
  if (GlobalConfig.testInLocalBookshelf(aid)) {
    fabFavorate.setIcon(R.drawable.ic_favorate_pressed);
  }
  getSupportActionBar().setTitle(R.string.action_novel_info);
  isLoading=true;
  FetchInfoAsyncTask fetchInfoAsyncTask=new FetchInfoAsyncTask();
  fetchInfoAsyncTask.execute(aid);
  famMenu.setOnFloatingActionsMenuUpdateListener(new FloatingActionsMenu.OnFloatingActionsMenuUpdateListener(){
    @Override public void onMenuExpanded(){
      rlMask.setVisibility(View.VISIBLE);
    }
    @Override public void onMenuCollapsed(){
      rlMask.setVisibility(View.INVISIBLE);
    }
  }
);
  rlMask.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (famMenu.isExpanded())       famMenu.collapse();
    }
  }
);
  tvNovelTitle.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isLoading) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
        return;
      }
      new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).titleColor(R.color.default_text_color_black).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).title(R.string.dialog_content_novel_title).content(aid + ""String_Node_Str"" + mNovelItemMeta.title).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_known).show();
    }
  }
);
  fabFavorate.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isLoading) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
        return;
      }
      if (GlobalConfig.testInLocalBookshelf(aid)) {
        new MaterialDialog.Builder(NovelInfoActivity.this).callback(new MaterialDialog.ButtonCallback(){
          @Override public void onPositive(          MaterialDialog dialog){
            super.onPositive(dialog);
            for (            VolumeList tempVl : listVolume) {
              for (              ChapterInfo tempCi : tempVl.chapterList) {
                LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + tempCi.cid+ ""String_Node_Str"");
                LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + tempCi.cid+ ""String_Node_Str"");
              }
            }
            LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            GlobalConfig.removeFromLocalBookshelf(aid);
            if (!GlobalConfig.testInLocalBookshelf(aid)) {
              Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_removed),Toast.LENGTH_SHORT).show();
              fabFavorate.setIcon(R.drawable.ic_favorate);
            }
 else {
              Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_error),Toast.LENGTH_SHORT).show();
            }
          }
        }
).theme(Theme.LIGHT).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).negativeColorRes(R.color.dlgNegativeButtonColor).content(R.string.dialog_content_sure_to_unfav).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_yes).negativeText(R.string.dialog_negative_preferno).show();
      }
 else {
        GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullMeta);
        GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullIntro);
        GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullVolume);
        GlobalConfig.addToLocalBookshelf(aid);
        if (GlobalConfig.testInLocalBookshelf(aid)) {
          Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_added),Toast.LENGTH_SHORT).show();
          fabFavorate.setIcon(R.drawable.ic_favorate_pressed);
        }
 else {
          Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_error),Toast.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  fabDownload.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isLoading) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
        return;
      }
 else       if (!GlobalConfig.testInLocalBookshelf(aid)) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_fav_it_first),Toast.LENGTH_SHORT).show();
        return;
      }
      new MaterialDialog.Builder(NovelInfoActivity.this).callback(new MaterialDialog.ButtonCallback(){
        @Override public void onPositive(        MaterialDialog dialog){
          super.onPositive(dialog);
          isLoading=true;
          final AsyncUpdateCacheTask auct=new AsyncUpdateCacheTask();
          auct.execute(aid);
          pDialog=new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).content(R.string.dialog_content_downloading).progress(false,1,true).cancelable(true).cancelListener(new DialogInterface.OnCancelListener(){
            @Override public void onCancel(            DialogInterface dialog){
              isLoading=false;
              auct.cancel(true);
              pDialog.dismiss();
              pDialog=null;
            }
          }
).show();
          pDialog.setProgress(0);
          pDialog.setMaxProgress(1);
          pDialog.show();
        }
      }
).theme(Theme.LIGHT).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).negativeColorRes(R.color.dlgNegativeButtonColor).content(R.string.dialog_content_verify_download).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_likethis).negativeText(R.string.dialog_negative_preferno).show();
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.layout_novel_info);
  aid=getIntent().getIntExtra(""String_Node_Str"",1);
  from=getIntent().getStringExtra(""String_Node_Str"");
  mToolbar=(Toolbar)findViewById(R.id.toolbar_actionbar);
  setSupportActionBar(mToolbar);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  getSupportActionBar().setHomeButtonEnabled(true);
  final Drawable upArrow=getResources().getDrawable(R.drawable.abc_ic_ab_back_mtrl_am_alpha);
  upArrow.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  getSupportActionBar().setHomeAsUpIndicator(upArrow);
  if (Build.VERSION.SDK_INT >= 16) {
    SystemBarTintManager tintManager=new SystemBarTintManager(this);
    tintManager.setStatusBarTintEnabled(true);
    tintManager.setNavigationBarTintEnabled(true);
    tintManager.setTintAlpha(0.15f);
    tintManager.setTintColor(getResources().getColor(android.R.color.black));
  }
  if (ImageLoader.getInstance() == null || !ImageLoader.getInstance().isInited()) {
    GlobalConfig.initImageLoader(this);
  }
  rlMask=(RelativeLayout)findViewById(R.id.white_mask);
  mLinearLayout=(LinearLayout)findViewById(R.id.novel_info_scroll);
  llCardLayout=(LinearLayout)findViewById(R.id.item_card);
  ivNovelCover=(ImageView)findViewById(R.id.novel_cover);
  tvNovelTitle=(TextView)findViewById(R.id.novel_title);
  tvNovelAuthor=(TextView)findViewById(R.id.novel_author);
  tvNovelStatus=(TextView)findViewById(R.id.novel_status);
  tvNovelUpdate=(TextView)findViewById(R.id.novel_update);
  tvNovelShortIntro=(TableRow)findViewById(R.id.novel_intro_row);
  tvNovelFullIntro=(TextView)findViewById(R.id.novel_intro_full);
  ibNovelOption=(ImageButton)findViewById(R.id.novel_option);
  fabFavorate=(FloatingActionButton)findViewById(R.id.fab_favorate);
  fabDownload=(FloatingActionButton)findViewById(R.id.fab_download);
  famMenu=(FloatingActionsMenu)findViewById(R.id.multiple_actions);
  spb=(SmoothProgressBar)findViewById(R.id.spb);
  ImageLoader.getInstance().displayImage(Wenku8API.getCoverURL(aid),ivNovelCover);
  tvNovelShortIntro.setVisibility(TextView.GONE);
  ibNovelOption.setVisibility(ImageButton.INVISIBLE);
  fabFavorate.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  fabDownload.setColorFilter(getResources().getColor(R.color.default_white),PorterDuff.Mode.SRC_ATOP);
  llCardLayout.setBackgroundResource(R.color.menu_transparent);
  spb.progressiveStart();
  if (GlobalConfig.testInLocalBookshelf(aid)) {
    fabFavorate.setIcon(R.drawable.ic_favorate_pressed);
  }
  getSupportActionBar().setTitle(R.string.action_novel_info);
  isLoading=true;
  FetchInfoAsyncTask fetchInfoAsyncTask=new FetchInfoAsyncTask();
  fetchInfoAsyncTask.execute(aid);
  famMenu.setOnFloatingActionsMenuUpdateListener(new FloatingActionsMenu.OnFloatingActionsMenuUpdateListener(){
    @Override public void onMenuExpanded(){
      rlMask.setVisibility(View.VISIBLE);
    }
    @Override public void onMenuCollapsed(){
      rlMask.setVisibility(View.INVISIBLE);
    }
  }
);
  rlMask.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (famMenu.isExpanded())       famMenu.collapse();
    }
  }
);
  tvNovelTitle.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isLoading) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
        return;
      }
      new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).titleColor(R.color.dlgTitleColor).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).title(R.string.dialog_content_novel_title).content(aid + ""String_Node_Str"" + mNovelItemMeta.title).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_known).show();
    }
  }
);
  fabFavorate.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isLoading) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
        return;
      }
      if (GlobalConfig.testInLocalBookshelf(aid)) {
        new MaterialDialog.Builder(NovelInfoActivity.this).callback(new MaterialDialog.ButtonCallback(){
          @Override public void onPositive(          MaterialDialog dialog){
            super.onPositive(dialog);
            for (            VolumeList tempVl : listVolume) {
              for (              ChapterInfo tempCi : tempVl.chapterList) {
                LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + tempCi.cid+ ""String_Node_Str"");
                LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + tempCi.cid+ ""String_Node_Str"");
              }
            }
            LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getFirstFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            LightCache.deleteFile(GlobalConfig.getSecondFullSaveFilePath(),""String_Node_Str"" + File.separator + aid+ ""String_Node_Str"");
            GlobalConfig.removeFromLocalBookshelf(aid);
            if (!GlobalConfig.testInLocalBookshelf(aid)) {
              Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_removed),Toast.LENGTH_SHORT).show();
              fabFavorate.setIcon(R.drawable.ic_favorate);
            }
 else {
              Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_error),Toast.LENGTH_SHORT).show();
            }
          }
        }
).theme(Theme.LIGHT).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).negativeColorRes(R.color.dlgNegativeButtonColor).content(R.string.dialog_content_sure_to_unfav).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_yes).negativeText(R.string.dialog_negative_preferno).show();
      }
 else {
        GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullMeta);
        GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullIntro);
        GlobalConfig.writeFullFileIntoSaveFolder(""String_Node_Str"",aid + ""String_Node_Str"",novelFullVolume);
        GlobalConfig.addToLocalBookshelf(aid);
        if (GlobalConfig.testInLocalBookshelf(aid)) {
          Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_added),Toast.LENGTH_SHORT).show();
          fabFavorate.setIcon(R.drawable.ic_favorate_pressed);
        }
 else {
          Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.bookshelf_error),Toast.LENGTH_SHORT).show();
        }
      }
    }
  }
);
  fabDownload.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isLoading) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_loading_please_wait),Toast.LENGTH_SHORT).show();
        return;
      }
 else       if (!GlobalConfig.testInLocalBookshelf(aid)) {
        Toast.makeText(NovelInfoActivity.this,getResources().getString(R.string.system_fav_it_first),Toast.LENGTH_SHORT).show();
        return;
      }
      new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).title(R.string.dialog_title_choose_download_option).backgroundColorRes(R.color.dlgBackgroundColor).titleColor(R.color.dlgTitleColor).negativeText(R.string.dialog_negative_pass).negativeColorRes(R.color.dlgNegativeButtonColor).itemsGravity(GravityEnum.CENTER).items(R.array.download_option).itemsCallback(new MaterialDialog.ListCallback(){
        @Override public void onSelection(        MaterialDialog dialog,        View view,        int which,        CharSequence text){
switch (which) {
case 0:
            break;
case 1:
          new MaterialDialog.Builder(NovelInfoActivity.this).callback(new MaterialDialog.ButtonCallback(){
            @Override public void onPositive(            MaterialDialog dialog){
              super.onPositive(dialog);
              isLoading=true;
              final AsyncUpdateCacheTask auct=new AsyncUpdateCacheTask();
              auct.execute(aid);
              pDialog=new MaterialDialog.Builder(NovelInfoActivity.this).theme(Theme.LIGHT).content(R.string.dialog_content_downloading).progress(false,1,true).cancelable(true).cancelListener(new DialogInterface.OnCancelListener(){
                @Override public void onCancel(                DialogInterface dialog){
                  isLoading=false;
                  auct.cancel(true);
                  pDialog.dismiss();
                  pDialog=null;
                }
              }
).show();
              pDialog.setProgress(0);
              pDialog.setMaxProgress(1);
              pDialog.show();
            }
          }
).theme(Theme.LIGHT).backgroundColorRes(R.color.dlgBackgroundColor).contentColorRes(R.color.dlgContentColor).positiveColorRes(R.color.dlgPositiveButtonColor).negativeColorRes(R.color.dlgNegativeButtonColor).content(R.string.dialog_content_verify_download).contentGravity(GravityEnum.CENTER).positiveText(R.string.dialog_positive_likethis).negativeText(R.string.dialog_negative_preferno).show();
        break;
case 2:
      break;
case 3:
    break;
}
}
}
).show();
}
}
);
}"
55035,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.layout_vertical_reader_temp);
  aid=getIntent().getIntExtra(""String_Node_Str"",1);
  volumeList=(VolumeList)getIntent().getSerializableExtra(""String_Node_Str"");
  cid=getIntent().getIntExtra(""String_Node_Str"",1);
  from=getIntent().getStringExtra(""String_Node_Str"");
  typeface=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  getNovelContent();
  TextListLayout=(LinearLayout)VerticalReaderActivity.this.findViewById(R.id.novel_content_layout);
  Toast.makeText(this,getString(R.string.notice_volume_to_dark_mode),Toast.LENGTH_SHORT).show();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.layout_vertical_reader_temp);
  aid=getIntent().getIntExtra(""String_Node_Str"",1);
  volumeList=(VolumeList)getIntent().getSerializableExtra(""String_Node_Str"");
  cid=getIntent().getIntExtra(""String_Node_Str"",1);
  from=getIntent().getStringExtra(""String_Node_Str"");
  if (ImageLoader.getInstance() == null || !ImageLoader.getInstance().isInited()) {
    GlobalConfig.initImageLoader(this);
  }
  typeface=Typeface.createFromAsset(getAssets(),""String_Node_Str"");
  getNovelContent();
  TextListLayout=(LinearLayout)VerticalReaderActivity.this.findViewById(R.id.novel_content_layout);
  Toast.makeText(this,getString(R.string.notice_volume_to_dark_mode),Toast.LENGTH_SHORT).show();
}"
55036,"@Override protected void onPostExecute(Wenku8Error.ErrorCode errorCode){
  super.onPostExecute(errorCode);
  isLoading=false;
  md.dismiss();
  if (errorCode != Wenku8Error.ErrorCode.SYSTEM_1_SUCCEEDED) {
    Toast.makeText(getActivity(),errorCode.toString(),Toast.LENGTH_SHORT).show();
  }
  AsyncLoadAllLocal alal=new AsyncLoadAllLocal();
  alal.execute();
}","@Override protected void onPostExecute(Wenku8Error.ErrorCode errorCode){
  super.onPostExecute(errorCode);
  isLoading=false;
  md.dismiss();
  if (errorCode != Wenku8Error.ErrorCode.SYSTEM_1_SUCCEEDED) {
    Toast.makeText(MyApp.getContext(),errorCode.toString(),Toast.LENGTH_SHORT).show();
  }
  AsyncLoadAllLocal alal=new AsyncLoadAllLocal();
  alal.execute();
}"
55037,"public Preference(Context context){
  this(context,null);
}","public Preference(Context context){
  super(context);
}"
55038,"@Override public SlackMessageHandle<SlackMessageReply> sendMessage(SlackChannel channel,SlackPreparedMessage preparedMessage,SlackChatConfiguration chatConfiguration){
  SlackMessageHandle<SlackMessageReply> handle=new SlackMessageHandle<>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",preparedMessage.getMessage());
  if (chatConfiguration.isAsUser()) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (chatConfiguration.getAvatar() == Avatar.ICON_URL) {
    arguments.put(""String_Node_Str"",chatConfiguration.getAvatarDescription());
  }
  if (chatConfiguration.getAvatar() == Avatar.EMOJI) {
    arguments.put(""String_Node_Str"",chatConfiguration.getAvatarDescription());
  }
  if (chatConfiguration.getUserName() != null) {
    arguments.put(""String_Node_Str"",chatConfiguration.getUserName());
  }
  if (preparedMessage.getAttachments() != null && preparedMessage.getAttachments().length > 0) {
    arguments.put(""String_Node_Str"",SlackJSONAttachmentFormatter.encodeAttachments(preparedMessage.getAttachments()).toString());
  }
  if (!preparedMessage.isUnfurl()) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (preparedMessage.isLinkNames()) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (preparedMessage.getThreadTimestamp() != null) {
    arguments.put(""String_Node_Str"",preparedMessage.getThreadTimestamp());
    if (preparedMessage.isReplyBroadcast()) {
      arguments.put(""String_Node_Str"",""String_Node_Str"");
    }
  }
  postSlackCommand(arguments,CHAT_POST_MESSAGE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackMessageReply> sendMessage(SlackChannel channel,SlackPreparedMessage preparedMessage,SlackChatConfiguration chatConfiguration){
  if (channel == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  SlackMessageHandle<SlackMessageReply> handle=new SlackMessageHandle<>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",preparedMessage.getMessage());
  if (chatConfiguration.isAsUser()) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (chatConfiguration.getAvatar() == Avatar.ICON_URL) {
    arguments.put(""String_Node_Str"",chatConfiguration.getAvatarDescription());
  }
  if (chatConfiguration.getAvatar() == Avatar.EMOJI) {
    arguments.put(""String_Node_Str"",chatConfiguration.getAvatarDescription());
  }
  if (chatConfiguration.getUserName() != null) {
    arguments.put(""String_Node_Str"",chatConfiguration.getUserName());
  }
  if (preparedMessage.getAttachments() != null && preparedMessage.getAttachments().length > 0) {
    arguments.put(""String_Node_Str"",SlackJSONAttachmentFormatter.encodeAttachments(preparedMessage.getAttachments()).toString());
  }
  if (!preparedMessage.isUnfurl()) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (preparedMessage.isLinkNames()) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (preparedMessage.getThreadTimestamp() != null) {
    arguments.put(""String_Node_Str"",preparedMessage.getThreadTimestamp());
    if (preparedMessage.isReplyBroadcast()) {
      arguments.put(""String_Node_Str"",""String_Node_Str"");
    }
  }
  postSlackCommand(arguments,CHAT_POST_MESSAGE_COMMAND,handle);
  return handle;
}"
55039,"public static void main(String[] args) throws IOException {
  SlackSession session=SlackSessionFactory.getSlackSessionBuilder(""String_Node_Str"").withProxy(Proxy.Type.HTTP,""String_Node_Str"",1234).withAutoreconnectOnDisconnection(false).withConnectionHeartbeat(10,TimeUnit.SECONDS).withCustomWebSocketContainer(new WebSocketContainerProvider(){
    @Override public WebSocketContainer getWebSocketContainer(){
      return new WebSocketContainer(){
        @Override public long getDefaultAsyncSendTimeout(){
          return 0;
        }
        @Override public void setAsyncSendTimeout(        long timeoutmillis){
        }
        @Override public Session connectToServer(        Object annotatedEndpointInstance,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public Session connectToServer(        Class<?> annotatedEndpointClass,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public Session connectToServer(        Endpoint endpointInstance,        ClientEndpointConfig cec,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public Session connectToServer(        Class<? extends Endpoint> endpointClass,        ClientEndpointConfig cec,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public long getDefaultMaxSessionIdleTimeout(){
          return 0;
        }
        @Override public void setDefaultMaxSessionIdleTimeout(        long timeout){
        }
        @Override public int getDefaultMaxBinaryMessageBufferSize(){
          return 0;
        }
        @Override public void setDefaultMaxBinaryMessageBufferSize(        int max){
        }
        @Override public int getDefaultMaxTextMessageBufferSize(){
          return 0;
        }
        @Override public void setDefaultMaxTextMessageBufferSize(        int max){
        }
        @Override public Set<Extension> getInstalledExtensions(){
          return null;
        }
      }
;
    }
  }
).build();
  session.connect();
}","public static void main(String[] args) throws IOException {
  SlackSession session=SlackSessionFactory.getSlackSessionBuilder(""String_Node_Str"").withProxy(Proxy.Type.HTTP,""String_Node_Str"",1234).withAutoreconnectOnDisconnection(false).withConnectionHeartbeat(10,TimeUnit.SECONDS).withCustomWebSocketContainer(new WebSocketContainerProvider(){
    @Override public WebSocketContainer getWebSocketContainer(){
      return new WebSocketContainer(){
        @Override public long getDefaultAsyncSendTimeout(){
          return 0;
        }
        @Override public void setAsyncSendTimeout(        long timeoutmillis){
        }
        @Override public Session connectToServer(        Object annotatedEndpointInstance,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public Session connectToServer(        Class<?> annotatedEndpointClass,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public Session connectToServer(        Endpoint endpointInstance,        ClientEndpointConfig cec,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public Session connectToServer(        Class<? extends Endpoint> endpointClass,        ClientEndpointConfig cec,        URI path) throws DeploymentException, IOException {
          return null;
        }
        @Override public long getDefaultMaxSessionIdleTimeout(){
          return 0;
        }
        @Override public void setDefaultMaxSessionIdleTimeout(        long timeout){
        }
        @Override public int getDefaultMaxBinaryMessageBufferSize(){
          return 0;
        }
        @Override public void setDefaultMaxBinaryMessageBufferSize(        int max){
        }
        @Override public int getDefaultMaxTextMessageBufferSize(){
          return 0;
        }
        @Override public void setDefaultMaxTextMessageBufferSize(        int max){
        }
        @Override public Set<Extension> getInstalledExtensions(){
          return null;
        }
      }
;
    }
  }
).withRateLimitSupport(false).build();
  session.connect();
}"
55040,"public SlackSession build(){
  return new SlackWebSocketSessionImpl(provider,authToken,proxyType,proxyAddress,proxyPort,proxyUser,proxyPassword,autoreconnection,heartbeat,unit);
}","public SlackSession build(){
  return new SlackWebSocketSessionImpl(provider,authToken,proxyType,proxyAddress,proxyPort,proxyUser,proxyPassword,autoreconnection,rateLimitSupport,heartbeat,unit);
}"
55041,"public static SlackSession createWebSocketSlackSession(String authToken){
  return new SlackWebSocketSessionImpl(null,authToken,true,0,null);
}","public static SlackSession createWebSocketSlackSession(String authToken){
  return new SlackWebSocketSessionImpl(null,authToken,true,true,0,null);
}"
55042,"SlackWebSocketSessionImpl(WebSocketContainerProvider webSocketContainerProvider,String authToken,Proxy.Type proxyType,String proxyAddress,int proxyPort,String proxyUser,String proxyPassword,boolean reconnectOnDisconnection,long heartbeat,TimeUnit unit){
  this.authToken=authToken;
  if (proxyType != null && proxyType != Proxy.Type.DIRECT) {
    this.proxyAddress=proxyAddress;
    this.proxyPort=proxyPort;
    this.proxyHost=new HttpHost(proxyAddress,proxyPort);
    this.proxyUser=proxyUser;
    this.proxyPassword=proxyPassword;
  }
  this.reconnectOnDisconnection=reconnectOnDisconnection;
  this.heartbeat=heartbeat != 0 ? unit.toMillis(heartbeat) : DEFAULT_HEARTBEAT_IN_MILLIS;
  this.webSocketContainerProvider=webSocketContainerProvider != null ? webSocketContainerProvider : new DefaultWebSocketContainerProvider(this.proxyAddress,this.proxyPort,this.proxyUser,this.proxyPassword);
  addInternalListeners();
}","SlackWebSocketSessionImpl(WebSocketContainerProvider webSocketContainerProvider,String authToken,Proxy.Type proxyType,String proxyAddress,int proxyPort,String proxyUser,String proxyPassword,boolean reconnectOnDisconnection,boolean isRateLimitSupported,long heartbeat,TimeUnit unit){
  this.authToken=authToken;
  if (proxyType != null && proxyType != Proxy.Type.DIRECT) {
    this.proxyAddress=proxyAddress;
    this.proxyPort=proxyPort;
    this.proxyHost=new HttpHost(proxyAddress,proxyPort);
    this.proxyUser=proxyUser;
    this.proxyPassword=proxyPassword;
  }
  this.reconnectOnDisconnection=reconnectOnDisconnection;
  this.isRateLimitSupported=isRateLimitSupported;
  this.heartbeat=heartbeat != 0 ? unit.toMillis(heartbeat) : DEFAULT_HEARTBEAT_IN_MILLIS;
  this.webSocketContainerProvider=webSocketContainerProvider != null ? webSocketContainerProvider : new DefaultWebSocketContainerProvider(this.proxyAddress,this.proxyPort,this.proxyUser,this.proxyPassword);
  addInternalListeners();
}"
55043,"private void connectImpl() throws IOException {
  LOGGER.info(""String_Node_Str"");
  HttpClient httpClient=getHttpClient();
  HttpGet request=new HttpGet(SLACK_HTTPS_AUTH_URL + authToken);
  HttpResponse response;
  response=httpClient.execute(request);
  LOGGER.debug(response.getStatusLine().toString());
  String jsonResponse=consumeToString(response.getEntity().getContent());
  SlackJSONSessionStatusParser sessionParser=new SlackJSONSessionStatusParser(jsonResponse);
  sessionParser.parse();
  if (sessionParser.getError() != null) {
    LOGGER.error(""String_Node_Str"" + sessionParser.getError());
    throw new ConnectException(sessionParser.getError());
  }
  users=sessionParser.getUsers();
  integrations=sessionParser.getIntegrations();
  channels=sessionParser.getChannels();
  sessionPersona=sessionParser.getSessionPersona();
  team=sessionParser.getTeam();
  LOGGER.info(""String_Node_Str"" + team.getId() + ""String_Node_Str""+ team.getName());
  LOGGER.info(""String_Node_Str"" + sessionPersona.getId() + ""String_Node_Str""+ sessionPersona.getUserName());
  LOGGER.info(users.size() + ""String_Node_Str"");
  LOGGER.info(channels.size() + ""String_Node_Str"");
  webSocketConnectionURL=sessionParser.getWebSocketURL();
  LOGGER.debug(""String_Node_Str"" + webSocketConnectionURL);
  establishWebsocketConnection();
}","private void connectImpl() throws IOException {
  LOGGER.info(""String_Node_Str"");
  HttpClient httpClient=getHttpClient();
  HttpGet request=new HttpGet(SLACK_HTTPS_AUTH_URL + authToken);
  HttpResponse response=httpClient.execute(request);
  LOGGER.debug(response.getStatusLine().toString());
  String jsonResponse=consumeToString(response.getEntity().getContent());
  SlackJSONSessionStatusParser sessionParser=new SlackJSONSessionStatusParser(jsonResponse);
  sessionParser.parse();
  if (sessionParser.getError() != null) {
    LOGGER.error(""String_Node_Str"" + sessionParser.getError());
    throw new ConnectException(sessionParser.getError());
  }
  users=sessionParser.getUsers();
  integrations=sessionParser.getIntegrations();
  channels=sessionParser.getChannels();
  sessionPersona=sessionParser.getSessionPersona();
  team=sessionParser.getTeam();
  LOGGER.info(""String_Node_Str"" + team.getId() + ""String_Node_Str""+ team.getName());
  LOGGER.info(""String_Node_Str"" + sessionPersona.getId() + ""String_Node_Str""+ sessionPersona.getUserName());
  LOGGER.info(users.size() + ""String_Node_Str"");
  LOGGER.info(channels.size() + ""String_Node_Str"");
  webSocketConnectionURL=sessionParser.getWebSocketURL();
  LOGGER.debug(""String_Node_Str"" + webSocketConnectionURL);
  establishWebsocketConnection();
}"
55044,"private HttpClient getHttpClient(){
  HttpClient client;
  if (proxyHost != null) {
    if (null == this.proxyUser) {
      client=HttpClientBuilder.create().setRoutePlanner(new DefaultProxyRoutePlanner(proxyHost)).build();
    }
 else {
      RequestConfig config=RequestConfig.custom().setProxy(this.proxyHost).build();
      CredentialsProvider credsProvider=new BasicCredentialsProvider();
      credsProvider.setCredentials(new AuthScope(this.proxyHost),new UsernamePasswordCredentials(this.proxyUser,this.proxyPassword));
      client=HttpClientBuilder.create().setDefaultCredentialsProvider(credsProvider).setDefaultRequestConfig(config).build();
    }
  }
 else {
    client=HttpClientBuilder.create().build();
  }
  return client;
}","private HttpClient getHttpClient(){
  HttpClientBuilder builder=HttpClientBuilder.create();
  if (proxyHost != null) {
    if (null == this.proxyUser) {
      builder.setRoutePlanner(new DefaultProxyRoutePlanner(proxyHost));
    }
 else {
      RequestConfig config=RequestConfig.custom().setProxy(this.proxyHost).build();
      CredentialsProvider credsProvider=new BasicCredentialsProvider();
      credsProvider.setCredentials(new AuthScope(this.proxyHost),new UsernamePasswordCredentials(this.proxyUser,this.proxyPassword));
      builder.setDefaultCredentialsProvider(credsProvider).setDefaultRequestConfig(config);
    }
  }
  if (isRateLimitSupported) {
    builder.setServiceUnavailableRetryStrategy(new SlackRateLimitRetryStrategy());
  }
  return builder.build();
}"
55045,"@Test(expected=IllegalArgumentException.class) public void testSendMessageWithNullChanel(@Mocked WebSocketContainerProvider provider) throws Exception {
  SlackWebSocketSessionImpl webSocketSession=new SlackWebSocketSessionImpl(provider,""String_Node_Str"",false,42L,TimeUnit.MILLISECONDS);
  try {
    webSocketSession.sendMessage(null,""String_Node_Str"");
  }
 catch (  NullPointerException e) {
    fail(""String_Node_Str"");
  }
}","@Test(expected=IllegalArgumentException.class) public void testSendMessageWithNullChanel(@Mocked WebSocketContainerProvider provider) throws Exception {
  SlackWebSocketSessionImpl webSocketSession=new SlackWebSocketSessionImpl(provider,""String_Node_Str"",false,false,42L,TimeUnit.MILLISECONDS);
  try {
    webSocketSession.sendMessage(null,""String_Node_Str"");
  }
 catch (  NullPointerException e) {
    fail(""String_Node_Str"");
  }
}"
55046,"@Test public void testParsingNewMessageFromIntegration() throws Exception {
  JSONParser parser=new JSONParser();
  JSONObject object=(JSONObject)parser.parse(TEST_NEW_MESSAGE_FROM_INTEGRATION);
  SlackEvent event=SlackJSONMessageParser.decode(session,object);
  Assertions.assertThat(event).isInstanceOf(SlackMessagePosted.class);
  SlackMessagePosted slackMessage=(SlackMessagePosted)event;
  Assertions.assertThat(slackMessage.getSender().getId()).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(slackMessage.getChannel().getId()).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(slackMessage.getMessageContent()).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(slackMessage.getTimeStamp()).isEqualTo(""String_Node_Str"");
}","@Test public void testParsingNewMessageFromIntegration() throws Exception {
  JsonParser parser=new JsonParser();
  JsonObject object=parser.parse(TEST_NEW_MESSAGE_FROM_INTEGRATION).getAsJsonObject();
  SlackEvent event=SlackJSONMessageParser.decode(session,object);
  Assertions.assertThat(event).isInstanceOf(SlackMessagePosted.class);
  SlackMessagePosted slackMessage=(SlackMessagePosted)event;
  Assertions.assertThat(slackMessage.getSender().getId()).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(slackMessage.getChannel().getId()).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(slackMessage.getMessageContent()).isEqualTo(""String_Node_Str"");
  Assertions.assertThat(slackMessage.getTimeStamp()).isEqualTo(""String_Node_Str"");
}"
55047,"@Before public void setup(){
  session=new AbstractSlackSessionImpl(){
    @Override public void setPresence(    SlackPersona.SlackPresence presence){
    }
    @Override public void connect(){
      SlackUser user1=new SlackUserImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,false,false,false,false,false,""String_Node_Str"",""String_Node_Str"",new Integer(0));
      SlackUser user2=new SlackUserImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,false,false,false,false,false,""String_Node_Str"",""String_Node_Str"",new Integer(0));
      SlackUser user3=new SlackUserImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,false,false,false,false,false,""String_Node_Str"",""String_Node_Str"",new Integer(0));
      users.put(user1.getId(),user1);
      users.put(user2.getId(),user2);
      users.put(user3.getId(),user3);
      SlackChannel channel1=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",null,null,false);
      SlackChannel channel2=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",null,null,false);
      SlackChannel channel3=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",null,null,false);
      SlackChannel channel4=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
      channels.put(channel1.getId(),channel1);
      channels.put(channel2.getId(),channel2);
      channels.put(channel3.getId(),channel3);
      channels.put(channel4.getId(),channel4);
    }
    @Override public void disconnect(){
    }
    @Override public SlackMessageHandle sendMessageOverWebSocket(    SlackChannel channel,    String message){
      throw new UnsupportedOperationException();
    }
    @Override public SlackPersona.SlackPresence getPresence(    SlackPersona persona){
      return null;
    }
    @Override public SlackMessageHandle deleteMessage(    String timeStamp,    SlackChannel channel){
      return null;
    }
    @Override public SlackMessageHandle<SlackMessageReply> sendMessage(    SlackChannel channel,    SlackPreparedMessage preparedMessage,    SlackChatConfiguration chatConfiguration){
      throw new UnsupportedOperationException();
    }
    @Override public SlackMessageHandle updateMessage(    String timeStamp,    SlackChannel channel,    String message){
      return null;
    }
    @Override public SlackMessageHandle addReactionToMessage(    SlackChannel channel,    String messageTimeStamp,    String emojiCode){
      return null;
    }
    @Override public SlackMessageHandle joinChannel(    String channelName){
      return null;
    }
    @Override public SlackMessageHandle leaveChannel(    SlackChannel channel){
      return null;
    }
    @Override public SlackMessageHandle<SlackChannelReply> openDirectMessageChannel(    SlackUser user){
      return null;
    }
    @Override public SlackMessageHandle<SlackChannelReply> openMultipartyDirectMessageChannel(    SlackUser... users){
      return null;
    }
    @Override public SlackMessageHandle inviteUser(    String email,    String firstName,    boolean setActive){
      return null;
    }
    @Override public boolean isConnected(){
      return true;
    }
    @Override public SlackMessageHandle<SlackChannelReply> inviteToChannel(    SlackChannel channel,    SlackUser user){
      return null;
    }
    @Override public SlackMessageHandle sendMessageToUser(    SlackUser user,    String message,    SlackAttachment attachment){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public SlackMessageHandle sendMessageToUser(    String userName,    String message,    SlackAttachment attachment){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public SlackMessageHandle<GenericSlackReply> postGenericSlackCommand(    Map<String,String> params,    String command){
      return null;
    }
    @Override public SlackMessageHandle<ParsedSlackReply> archiveChannel(    SlackChannel channel){
      return null;
    }
  }
;
  try {
    session.connect();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Before public void setup(){
  session=new AbstractSlackSessionImpl(){
    @Override public long getHeartbeat(){
      return 0;
    }
    @Override public void setHeartbeat(    long heartbeat,    TimeUnit unit){
    }
    @Override public void setPresence(    SlackPersona.SlackPresence presence){
    }
    @Override public void connect(){
      SlackUser user1=new SlackUserImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,false,false,false,false,false,""String_Node_Str"",""String_Node_Str"",new Integer(0));
      SlackUser user2=new SlackUserImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,false,false,false,false,false,""String_Node_Str"",""String_Node_Str"",new Integer(0));
      SlackUser user3=new SlackUserImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false,false,false,false,false,false,""String_Node_Str"",""String_Node_Str"",new Integer(0));
      users.put(user1.getId(),user1);
      users.put(user2.getId(),user2);
      users.put(user3.getId(),user3);
      SlackChannel channel1=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",null,null,false);
      SlackChannel channel2=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",null,null,false);
      SlackChannel channel3=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",null,null,false);
      SlackChannel channel4=new SlackChannelImpl(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false);
      channels.put(channel1.getId(),channel1);
      channels.put(channel2.getId(),channel2);
      channels.put(channel3.getId(),channel3);
      channels.put(channel4.getId(),channel4);
    }
    @Override public void disconnect(){
    }
    @Override public SlackMessageHandle sendMessageOverWebSocket(    SlackChannel channel,    String message){
      throw new UnsupportedOperationException();
    }
    @Override public SlackPersona.SlackPresence getPresence(    SlackPersona persona){
      return null;
    }
    @Override public SlackMessageHandle deleteMessage(    String timeStamp,    SlackChannel channel){
      return null;
    }
    @Override public SlackMessageHandle<SlackMessageReply> sendMessage(    SlackChannel channel,    SlackPreparedMessage preparedMessage,    SlackChatConfiguration chatConfiguration){
      throw new UnsupportedOperationException();
    }
    @Override public SlackMessageHandle updateMessage(    String timeStamp,    SlackChannel channel,    String message){
      return null;
    }
    @Override public SlackMessageHandle addReactionToMessage(    SlackChannel channel,    String messageTimeStamp,    String emojiCode){
      return null;
    }
    @Override public SlackMessageHandle joinChannel(    String channelName){
      return null;
    }
    @Override public SlackMessageHandle leaveChannel(    SlackChannel channel){
      return null;
    }
    @Override public SlackMessageHandle<SlackChannelReply> openDirectMessageChannel(    SlackUser user){
      return null;
    }
    @Override public SlackMessageHandle<SlackChannelReply> openMultipartyDirectMessageChannel(    SlackUser... users){
      return null;
    }
    @Override public SlackMessageHandle inviteUser(    String email,    String firstName,    boolean setActive){
      return null;
    }
    @Override public boolean isConnected(){
      return true;
    }
    @Override public SlackMessageHandle<SlackChannelReply> inviteToChannel(    SlackChannel channel,    SlackUser user){
      return null;
    }
    @Override public SlackMessageHandle sendMessageToUser(    SlackUser user,    String message,    SlackAttachment attachment){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public SlackMessageHandle sendMessageToUser(    String userName,    String message,    SlackAttachment attachment){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    @Override public SlackMessageHandle<GenericSlackReply> postGenericSlackCommand(    Map<String,String> params,    String command){
      return null;
    }
    @Override public SlackMessageHandle<ParsedSlackReply> archiveChannel(    SlackChannel channel){
      return null;
    }
  }
;
  try {
    session.connect();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
55048,"SlackMessageHandle inviteUser(String email,String firstName,boolean setActive);","SlackMessageHandle<GenericSlackReply> inviteUser(String email,String firstName,boolean setActive);"
55049,"@Override public SlackMessageHandle sendMessage(SlackChannel channel,String message,SlackAttachment attachment){
  return sendMessage(channel,message,attachment,DEFAULT_CONFIGURATION);
}","@Override public SlackMessageHandle<SlackMessageReply> sendMessage(SlackChannel channel,String message,SlackAttachment attachment){
  return sendMessage(channel,message,attachment,DEFAULT_CONFIGURATION);
}"
55050,"@Override public JSONObject getPlainAnswer(){
  return null;
}","@Override public JSONObject getPlainAnswer(){
  return obj;
}"
55051,"@Override public SlackMessageHandle sendMessageToUser(String userName,String message,SlackAttachment attachment){
  return sendMessageToUser(findUserByUserName(userName),message,attachment);
}","@Override public SlackMessageHandle<SlackMessageReply> sendMessageToUser(String userName,String message,SlackAttachment attachment){
  return sendMessageToUser(findUserByUserName(userName),message,attachment);
}"
55052,"@Override public SlackMessageHandle<GenericSlackReply> postGenericSlackCommand(Map<String,String> params,String command){
  HttpClient client=getHttpClient();
  HttpPost request=new HttpPost(SLACK_API_HTTPS_ROOT + command);
  List<NameValuePair> nameValuePairList=new ArrayList<>();
  for (  Map.Entry<String,String> arg : params.entrySet()) {
    nameValuePairList.add(new BasicNameValuePair(arg.getKey(),arg.getValue()));
  }
  try {
    SlackMessageHandleImpl<GenericSlackReply> handle=new SlackMessageHandleImpl<>(getNextMessageId());
    request.setEntity(new UrlEncodedFormEntity(nameValuePairList,""String_Node_Str""));
    HttpResponse response=client.execute(request);
    String jsonResponse=CharStreams.toString(new InputStreamReader(response.getEntity().getContent()));
    LOGGER.debug(""String_Node_Str"" + jsonResponse);
    GenericSlackReplyImpl reply=new GenericSlackReplyImpl(parseObject(jsonResponse));
    handle.setReply(reply);
    return handle;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","@Override public SlackMessageHandle<GenericSlackReply> postGenericSlackCommand(Map<String,String> params,String command){
  HttpClient client=getHttpClient();
  HttpPost request=new HttpPost(SLACK_API_HTTPS_ROOT + command);
  List<NameValuePair> nameValuePairList=new ArrayList<>();
  for (  Map.Entry<String,String> arg : params.entrySet()) {
    if (!""String_Node_Str"".equals(arg.getKey())) {
      nameValuePairList.add(new BasicNameValuePair(arg.getKey(),arg.getValue()));
    }
  }
  nameValuePairList.add(new BasicNameValuePair(""String_Node_Str"",authToken));
  try {
    SlackMessageHandleImpl<GenericSlackReply> handle=new SlackMessageHandleImpl<>(getNextMessageId());
    request.setEntity(new UrlEncodedFormEntity(nameValuePairList,""String_Node_Str""));
    HttpResponse response=client.execute(request);
    String jsonResponse=CharStreams.toString(new InputStreamReader(response.getEntity().getContent()));
    LOGGER.debug(""String_Node_Str"" + jsonResponse);
    GenericSlackReplyImpl reply=new GenericSlackReplyImpl(parseObject(jsonResponse));
    handle.setReply(reply);
    return handle;
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}"
55053,"@Override public SlackMessageHandle<SlackChannelReply> joinChannel(String channelName){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channelName);
  postSlackCommand(arguments,CHANNELS_JOIN_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackChannelReply> joinChannel(String channelName){
  SlackMessageHandleImpl<SlackChannelReply> handle=new SlackMessageHandleImpl<SlackChannelReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channelName);
  postSlackCommand(arguments,CHANNELS_JOIN_COMMAND,handle);
  return handle;
}"
55054,"@Override public SlackMessageHandle<SlackChannelReply> openDirectMessageChannel(SlackUser user){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",user.getId());
  postSlackCommand(arguments,DIRECT_MESSAGE_OPEN_CHANNEL_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackChannelReply> openDirectMessageChannel(SlackUser user){
  SlackMessageHandleImpl<SlackChannelReply> handle=new SlackMessageHandleImpl<SlackChannelReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",user.getId());
  postSlackCommand(arguments,DIRECT_MESSAGE_OPEN_CHANNEL_COMMAND,handle);
  return handle;
}"
55055,"@Override public SlackMessageHandle inviteUser(String email,String firstName,boolean setActive){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",email);
  arguments.put(""String_Node_Str"",firstName);
  arguments.put(""String_Node_Str"",""String_Node_Str"" + setActive);
  postSlackCommand(arguments,INVITE_USER_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<GenericSlackReply> inviteUser(String email,String firstName,boolean setActive){
  SlackMessageHandleImpl<GenericSlackReply> handle=new SlackMessageHandleImpl<GenericSlackReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",email);
  arguments.put(""String_Node_Str"",firstName);
  arguments.put(""String_Node_Str"",""String_Node_Str"" + setActive);
  postSlackCommand(arguments,INVITE_USER_COMMAND,handle);
  return handle;
}"
55056,"@Override public SlackMessageHandle<SlackChannelReply> openMultipartyDirectMessageChannel(SlackUser... users){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  StringBuilder strBuilder=new StringBuilder();
  for (int i=0; i < users.length; i++) {
    if (i != 0) {
      strBuilder.append(',');
    }
    strBuilder.append(users[i].getId());
  }
  arguments.put(""String_Node_Str"",strBuilder.toString());
  postSlackCommand(arguments,MULTIPARTY_DIRECT_MESSAGE_OPEN_CHANNEL_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackChannelReply> openMultipartyDirectMessageChannel(SlackUser... users){
  SlackMessageHandleImpl<SlackChannelReply> handle=new SlackMessageHandleImpl<SlackChannelReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  StringBuilder strBuilder=new StringBuilder();
  for (int i=0; i < users.length; i++) {
    if (i != 0) {
      strBuilder.append(',');
    }
    strBuilder.append(users[i].getId());
  }
  arguments.put(""String_Node_Str"",strBuilder.toString());
  postSlackCommand(arguments,MULTIPARTY_DIRECT_MESSAGE_OPEN_CHANNEL_COMMAND,handle);
  return handle;
}"
55057,"@Override public SlackMessageHandle<SlackReply> archiveChannel(SlackChannel channel){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  postSlackCommand(arguments,CHANNELS_ARCHIVE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackReply> archiveChannel(SlackChannel channel){
  SlackMessageHandleImpl<SlackReply> handle=new SlackMessageHandleImpl<SlackReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  postSlackCommand(arguments,CHANNELS_ARCHIVE_COMMAND,handle);
  return handle;
}"
55058,"@Override public SlackMessageHandle<SlackMessageReply> sendMessage(SlackChannel channel,String message,SlackAttachment attachment,SlackChatConfiguration chatConfiguration){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",message);
  if (chatConfiguration.asUser) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (chatConfiguration.avatar == Avatar.ICON_URL) {
    arguments.put(""String_Node_Str"",chatConfiguration.avatarDescription);
  }
  if (chatConfiguration.avatar == Avatar.EMOJI) {
    arguments.put(""String_Node_Str"",chatConfiguration.avatarDescription);
  }
  if (chatConfiguration.userName != null) {
    arguments.put(""String_Node_Str"",chatConfiguration.userName);
  }
  if (attachment != null) {
    arguments.put(""String_Node_Str"",SlackJSONAttachmentFormatter.encodeAttachments(attachment).toString());
  }
  postSlackCommand(arguments,CHAT_POST_MESSAGE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackMessageReply> sendMessage(SlackChannel channel,String message,SlackAttachment attachment,SlackChatConfiguration chatConfiguration){
  SlackMessageHandleImpl<SlackMessageReply> handle=new SlackMessageHandleImpl<SlackMessageReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",message);
  if (chatConfiguration.asUser) {
    arguments.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (chatConfiguration.avatar == Avatar.ICON_URL) {
    arguments.put(""String_Node_Str"",chatConfiguration.avatarDescription);
  }
  if (chatConfiguration.avatar == Avatar.EMOJI) {
    arguments.put(""String_Node_Str"",chatConfiguration.avatarDescription);
  }
  if (chatConfiguration.userName != null) {
    arguments.put(""String_Node_Str"",chatConfiguration.userName);
  }
  if (attachment != null) {
    arguments.put(""String_Node_Str"",SlackJSONAttachmentFormatter.encodeAttachments(attachment).toString());
  }
  postSlackCommand(arguments,CHAT_POST_MESSAGE_COMMAND,handle);
  return handle;
}"
55059,"@Override public SlackMessageHandle<SlackMessageReply> deleteMessage(String timeStamp,SlackChannel channel){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",timeStamp);
  postSlackCommand(arguments,CHAT_DELETE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackMessageReply> deleteMessage(String timeStamp,SlackChannel channel){
  SlackMessageHandleImpl<SlackMessageReply> handle=new SlackMessageHandleImpl<SlackMessageReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",timeStamp);
  postSlackCommand(arguments,CHAT_DELETE_COMMAND,handle);
  return handle;
}"
55060,"@Override public SlackMessageHandle<SlackMessageReply> addReactionToMessage(SlackChannel channel,String messageTimeStamp,String emojiCode){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",messageTimeStamp);
  arguments.put(""String_Node_Str"",emojiCode);
  postSlackCommand(arguments,REACTIONS_ADD_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackMessageReply> addReactionToMessage(SlackChannel channel,String messageTimeStamp,String emojiCode){
  SlackMessageHandleImpl<SlackMessageReply> handle=new SlackMessageHandleImpl<SlackMessageReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",messageTimeStamp);
  arguments.put(""String_Node_Str"",emojiCode);
  postSlackCommand(arguments,REACTIONS_ADD_COMMAND,handle);
  return handle;
}"
55061,"@Override public SlackMessageHandle<SlackChannelReply> leaveChannel(SlackChannel channel){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  postSlackCommand(arguments,CHANNELS_LEAVE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackChannelReply> leaveChannel(SlackChannel channel){
  SlackMessageHandleImpl<SlackChannelReply> handle=new SlackMessageHandleImpl<SlackChannelReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  postSlackCommand(arguments,CHANNELS_LEAVE_COMMAND,handle);
  return handle;
}"
55062,"@Override public SlackMessageHandle sendMessageOverWebSocket(SlackChannel channel,String message,SlackAttachment attachment){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  try {
    JSONObject messageJSON=new JSONObject();
    messageJSON.put(""String_Node_Str"",""String_Node_Str"");
    messageJSON.put(""String_Node_Str"",channel.getId());
    messageJSON.put(""String_Node_Str"",message);
    if (attachment != null) {
      messageJSON.put(""String_Node_Str"",SlackJSONAttachmentFormatter.encodeAttachments(attachment));
    }
    websocketSession.getBasicRemote().sendText(messageJSON.toJSONString());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return handle;
}","@Override public SlackMessageHandle<SlackMessageReply> sendMessageOverWebSocket(SlackChannel channel,String message,SlackAttachment attachment){
  SlackMessageHandleImpl<SlackMessageReply> handle=new SlackMessageHandleImpl<SlackMessageReply>(getNextMessageId());
  try {
    JSONObject messageJSON=new JSONObject();
    messageJSON.put(""String_Node_Str"",""String_Node_Str"");
    messageJSON.put(""String_Node_Str"",channel.getId());
    messageJSON.put(""String_Node_Str"",message);
    if (attachment != null) {
      messageJSON.put(""String_Node_Str"",SlackJSONAttachmentFormatter.encodeAttachments(attachment));
    }
    websocketSession.getBasicRemote().sendText(messageJSON.toJSONString());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return handle;
}"
55063,"@Override public SlackMessageHandle<SlackChannelReply> inviteToChannel(SlackChannel channel,SlackUser user){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",user.getId());
  postSlackCommand(arguments,CHANNELS_INVITE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackChannelReply> inviteToChannel(SlackChannel channel,SlackUser user){
  SlackMessageHandleImpl<SlackChannelReply> handle=new SlackMessageHandleImpl<SlackChannelReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",user.getId());
  postSlackCommand(arguments,CHANNELS_INVITE_COMMAND,handle);
  return handle;
}"
55064,"@Override public SlackMessageHandle<SlackMessageReply> updateMessage(String timeStamp,SlackChannel channel,String message){
  SlackMessageHandleImpl handle=new SlackMessageHandleImpl(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",timeStamp);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",message);
  postSlackCommand(arguments,CHAT_UPDATE_COMMAND,handle);
  return handle;
}","@Override public SlackMessageHandle<SlackMessageReply> updateMessage(String timeStamp,SlackChannel channel,String message){
  SlackMessageHandleImpl<SlackMessageReply> handle=new SlackMessageHandleImpl<SlackMessageReply>(getNextMessageId());
  Map<String,String> arguments=new HashMap<>();
  arguments.put(""String_Node_Str"",authToken);
  arguments.put(""String_Node_Str"",timeStamp);
  arguments.put(""String_Node_Str"",channel.getId());
  arguments.put(""String_Node_Str"",message);
  postSlackCommand(arguments,CHAT_UPDATE_COMMAND,handle);
  return handle;
}"
55065,"public ReactionAddedImpl(String emojiName,String messageID,SlackChannel channel){
  this.emojiName=emojiName;
  this.messageID=messageID;
  this.channel=channel;
}","public ReactionAddedImpl(String emojiName,SlackUser user,SlackChannel channel,String messageID,String fileID,String fileCommentID){
  this.emojiName=emojiName;
  this.user=user;
  this.channel=channel;
  this.messageID=messageID;
  this.fileID=fileID;
  this.fileCommentID=fileCommentID;
}"
55066,"public ReactionRemovedImpl(String emojiName,String messageID,SlackChannel channel){
  this.emojiName=emojiName;
  this.messageID=messageID;
  this.channel=channel;
}","public ReactionRemovedImpl(String emojiName,SlackUser user,SlackChannel channel,String messageID,String fileID,String fileCommentID){
  this.emojiName=emojiName;
  this.user=user;
  this.channel=channel;
  this.messageID=messageID;
  this.fileID=fileID;
  this.fileCommentID=fileCommentID;
}"
55067,"private static ReactionAdded extractReactionAddedEvent(SlackSession slackSession,JSONObject obj){
  JSONObject message=(JSONObject)obj.get(""String_Node_Str"");
  String emojiName=(String)obj.get(""String_Node_Str"");
  String messageId=(String)message.get(""String_Node_Str"");
  String channelId=(String)message.get(""String_Node_Str"");
  return new ReactionAddedImpl(emojiName,messageId,slackSession.findChannelById(channelId));
}","private static ReactionAdded extractReactionAddedEvent(SlackSession slackSession,JSONObject obj){
  JSONObject item=(JSONObject)obj.get(""String_Node_Str"");
  String emojiName=(String)obj.get(""String_Node_Str"");
  String messageId=(String)item.get(""String_Node_Str"");
  String fileId=(String)item.get(""String_Node_Str"");
  String fileCommentId=(String)item.get(""String_Node_Str"");
  String channelId=(String)item.get(""String_Node_Str"");
  SlackChannel channel=(channelId != null) ? slackSession.findChannelById(channelId) : null;
  SlackUser user=slackSession.findUserById((String)obj.get(""String_Node_Str""));
  return new ReactionAddedImpl(emojiName,user,channel,messageId,fileId,fileCommentId);
}"
55068,"private static ReactionRemoved extractReactionRemovedEvent(SlackSession slackSession,JSONObject obj){
  JSONObject message=(JSONObject)obj.get(""String_Node_Str"");
  String emojiName=(String)obj.get(""String_Node_Str"");
  String messageId=(String)message.get(""String_Node_Str"");
  String channelId=(String)message.get(""String_Node_Str"");
  return new ReactionRemovedImpl(emojiName,messageId,slackSession.findChannelById(channelId));
}","private static ReactionRemoved extractReactionRemovedEvent(SlackSession slackSession,JSONObject obj){
  JSONObject item=(JSONObject)obj.get(""String_Node_Str"");
  String emojiName=(String)obj.get(""String_Node_Str"");
  String messageId=(String)item.get(""String_Node_Str"");
  String fileId=(String)item.get(""String_Node_Str"");
  String fileCommentId=(String)item.get(""String_Node_Str"");
  String channelId=(String)item.get(""String_Node_Str"");
  SlackChannel channel=(channelId != null) ? slackSession.findChannelById(channelId) : null;
  SlackUser user=slackSession.findUserById((String)obj.get(""String_Node_Str""));
  return new ReactionRemovedImpl(emojiName,user,channel,messageId,fileId,fileCommentId);
}"
55069,"private static SlackChannel parseChannelDescription(JSONObject channelJSONObject){
  String id=(String)channelJSONObject.get(""String_Node_Str"");
  String name=(String)channelJSONObject.get(""String_Node_Str"");
  String topic=(String)((Map)channelJSONObject.get(""String_Node_Str"")).get(""String_Node_Str"");
  String purpose=(String)((Map)channelJSONObject.get(""String_Node_Str"")).get(""String_Node_Str"");
  return new SlackChannelImpl(id,name,topic,purpose,true);
}","private static SlackChannel parseChannelDescription(JSONObject channelJSONObject){
  String id=(String)channelJSONObject.get(""String_Node_Str"");
  String name=(String)channelJSONObject.get(""String_Node_Str"");
  String topic=(String)((Map)channelJSONObject.get(""String_Node_Str"")).get(""String_Node_Str"");
  String purpose=(String)((Map)channelJSONObject.get(""String_Node_Str"")).get(""String_Node_Str"");
  return new SlackChannelImpl(id,name,topic,purpose,id.startsWith(""String_Node_Str""));
}"
55070,"@Override public String waitForCode() throws IOException {
  lock.lock();
  try {
    while (code == null && error == null) {
      gotAuthorizationResponse.awaitUninterruptibly();
    }
    if (error != null) {
      throw new IOException(""String_Node_Str"" + error + ""String_Node_Str"");
    }
    return code;
  }
  finally {
    lock.unlock();
  }
}","@Override public String waitForCode() throws IOException {
  waitUntilSignaled.acquireUninterruptibly();
  if (error != null) {
    throw new IOException(""String_Node_Str"" + error + ""String_Node_Str"");
  }
  return code;
}"
55071,"@Override public void handle(String target,HttpServletRequest request,HttpServletResponse response,int dispatch) throws IOException {
  if (!CALLBACK_PATH.equals(target)) {
    return;
  }
  ((Request)request).setHandled(true);
  lock.lock();
  try {
    error=request.getParameter(""String_Node_Str"");
    code=request.getParameter(""String_Node_Str"");
    gotAuthorizationResponse.signal();
    if (error == null && successLandingPageUrl != null) {
      response.sendRedirect(successLandingPageUrl);
    }
 else     if (error != null && failureLandingPageUrl != null) {
      response.sendRedirect(failureLandingPageUrl);
    }
 else {
      writeLandingHtml(response);
    }
    response.flushBuffer();
  }
  finally {
    lock.unlock();
  }
}","@Override public void handle(String target,HttpServletRequest request,HttpServletResponse response,int dispatch) throws IOException {
  if (!CALLBACK_PATH.equals(target)) {
    return;
  }
  try {
    ((Request)request).setHandled(true);
    error=request.getParameter(""String_Node_Str"");
    code=request.getParameter(""String_Node_Str"");
    if (error == null && successLandingPageUrl != null) {
      response.sendRedirect(successLandingPageUrl);
    }
 else     if (error != null && failureLandingPageUrl != null) {
      response.sendRedirect(failureLandingPageUrl);
    }
 else {
      writeLandingHtml(response);
    }
    response.flushBuffer();
  }
  finally {
    waitUntilSignaled.release();
  }
}"
55072,"@Override public void stop() throws IOException {
  if (server != null) {
    try {
      server.stop();
    }
 catch (    Exception e) {
      Throwables.propagateIfPossible(e);
      throw new IOException(e);
    }
    server=null;
  }
}","@Override public void stop() throws IOException {
  waitUntilSignaled.release();
  if (server != null) {
    try {
      server.stop();
    }
 catch (    Exception e) {
      Throwables.propagateIfPossible(e);
      throw new IOException(e);
    }
    server=null;
  }
}"
55073,"@Override public String getRedirectUri() throws IOException {
  if (port == -1) {
    port=getUnusedPort();
  }
  server=new Server(port);
  for (  Connector c : server.getConnectors()) {
    c.setHost(host);
  }
  server.addHandler(new CallbackHandler());
  try {
    server.start();
  }
 catch (  Exception e) {
    Throwables.propagateIfPossible(e);
    throw new IOException(e);
  }
  return ""String_Node_Str"" + host + ""String_Node_Str""+ port+ CALLBACK_PATH;
}","@Override public String getRedirectUri() throws IOException {
  server=new Server(port != -1 ? port : 0);
  Connector connector=server.getConnectors()[0];
  connector.setHost(host);
  server.addHandler(new CallbackHandler());
  try {
    server.start();
    port=connector.getLocalPort();
  }
 catch (  Exception e) {
    Throwables.propagateIfPossible(e);
    throw new IOException(e);
  }
  return ""String_Node_Str"" + host + ""String_Node_Str""+ port+ CALLBACK_PATH;
}"
55074,"private void verifyDefaultLandingPage(){
  Assert.assertEquals(200,responseCode);
  Assert.assertNull(redirectedLandingPageUrl);
  Assert.assertTrue(responseOutput.toString().contains(""String_Node_Str""));
  Assert.assertTrue(responseOutput.toString().contains(""String_Node_Str""));
}","private void verifyDefaultLandingPage(){
  assertEquals(200,responseCode);
  assertNull(redirectedLandingPageUrl);
  assertTrue(responseOutput.toString().contains(""String_Node_Str""));
  assertTrue(responseOutput.toString().contains(""String_Node_Str""));
}"
55075,"private void verifyRedirectedLandingPageUrl(String landingPageUrlMatch){
  Assert.assertEquals(302,responseCode);
  Assert.assertEquals(landingPageUrlMatch,redirectedLandingPageUrl);
  Assert.assertTrue(responseOutput.toString().isEmpty());
}","private void verifyRedirectedLandingPageUrl(String landingPageUrlMatch){
  assertEquals(302,responseCode);
  assertEquals(landingPageUrlMatch,redirectedLandingPageUrl);
  assertTrue(responseOutput.toString().isEmpty());
}"
55076,"@Override public void onTokenResponse(Credential credential,TokenResponse tokenResponse) throws IOException {
  calledOnResponse=true;
}","public void onTokenResponse(Credential credential,TokenResponse tokenResponse) throws IOException {
  calledOnResponse=true;
}"
55077,"@Override public void onCredentialCreated(Credential credential,TokenResponse tokenResponse) throws IOException {
  called=true;
}","public void onCredentialCreated(Credential credential,TokenResponse tokenResponse) throws IOException {
  called=true;
}"
55078,"@Override public void onTokenErrorResponse(Credential credential,TokenErrorResponse tokenErrorResponse) throws IOException {
  calledOnError=true;
}","public void onTokenErrorResponse(Credential credential,TokenErrorResponse tokenErrorResponse) throws IOException {
  calledOnError=true;
}"
55079,"public void testConstructor_expiredQueryParam() throws Exception {
  HttpRequest request=subtestConstructor_expired(BearerToken.queryParameterAccessMethod(),new CheckAuth(){
    @Override public boolean checkAuth(    MockLowLevelHttpRequest req){
      return req.getUrl().contains(""String_Node_Str"");
    }
  }
);
  assertEquals(NEW_ACCESS_TOKEN,request.getUrl().get(""String_Node_Str""));
}","public void testConstructor_expiredQueryParam() throws Exception {
  HttpRequest request=subtestConstructor_expired(BearerToken.queryParameterAccessMethod(),new CheckAuth(){
    public boolean checkAuth(    MockLowLevelHttpRequest req){
      return req.getUrl().contains(""String_Node_Str"");
    }
  }
);
  assertEquals(NEW_ACCESS_TOKEN,request.getUrl().get(""String_Node_Str""));
}"
55080,"public void testConstructor_expiredBody() throws Exception {
  HttpRequest request=subtestConstructor_expired(BearerToken.formEncodedBodyAccessMethod(),new CheckAuth(){
    @Override public boolean checkAuth(    MockLowLevelHttpRequest req){
      return NEW_ACCESS_TOKEN.equals(((Map<?,?>)((UrlEncodedContent)req.getStreamingContent()).getData()).get(""String_Node_Str""));
    }
  }
);
  assertEquals(NEW_ACCESS_TOKEN,((Map<?,?>)((UrlEncodedContent)request.getContent()).getData()).get(""String_Node_Str""));
}","public void testConstructor_expiredBody() throws Exception {
  HttpRequest request=subtestConstructor_expired(BearerToken.formEncodedBodyAccessMethod(),new CheckAuth(){
    public boolean checkAuth(    MockLowLevelHttpRequest req){
      return NEW_ACCESS_TOKEN.equals(((Map<?,?>)((UrlEncodedContent)req.getStreamingContent()).getData()).get(""String_Node_Str""));
    }
  }
);
  assertEquals(NEW_ACCESS_TOKEN,((Map<?,?>)((UrlEncodedContent)request.getContent()).getData()).get(""String_Node_Str""));
}"
55081,"public void testConstructor_expiredHeader() throws Exception {
  HttpRequest request=subtestConstructor_expired(BearerToken.authorizationHeaderAccessMethod(),new CheckAuth(){
    @Override public boolean checkAuth(    MockLowLevelHttpRequest req){
      return req.getFirstHeaderValue(""String_Node_Str"").equals(""String_Node_Str"");
    }
  }
);
  assertEquals(""String_Node_Str"",request.getHeaders().getAuthorization());
}","public void testConstructor_expiredHeader() throws Exception {
  HttpRequest request=subtestConstructor_expired(BearerToken.authorizationHeaderAccessMethod(),new CheckAuth(){
    public boolean checkAuth(    MockLowLevelHttpRequest req){
      return req.getFirstHeaderValue(""String_Node_Str"").equals(""String_Node_Str"");
    }
  }
);
  assertEquals(""String_Node_Str"",request.getHeaders().getAuthorization());
}"
55082,"/** 
 * Returns whether the   {@link #getExpirationTimeSeconds} and {@link #getIssuedAtTimeSeconds} arevalid relative to the current time, optionally allowing for a clock skew. <p> Default implementation checks that the  {@link #getExpirationTimeSeconds() expiration time}and   {@link #getIssuedAtTimeSeconds() issued at time} are valid based on the{@link System#currentTimeMillis() current time}, allowing for the clock skew. Subclasses may override. </p>
 * @param acceptableTimeSkewSeconds seconds of acceptable clock skew
 */
public boolean isValidTime(long acceptableTimeSkewSeconds){
  long now=System.currentTimeMillis();
  return (expirationTimeSeconds == null || now <= (expirationTimeSeconds + acceptableTimeSkewSeconds) * 1000) && (issuedAtTimeSeconds == null || now >= (issuedAtTimeSeconds + acceptableTimeSkewSeconds) * 1000);
}","/** 
 * Returns whether the   {@link #getExpirationTimeSeconds} and {@link #getIssuedAtTimeSeconds} arevalid relative to the current time, optionally allowing for a clock skew. <p> Default implementation checks that the  {@link #getExpirationTimeSeconds() expiration time}and   {@link #getIssuedAtTimeSeconds() issued at time} are valid based on the{@link System#currentTimeMillis() current time}, allowing for the clock skew. Subclasses may override. </p>
 * @param acceptableTimeSkewSeconds seconds of acceptable clock skew
 */
public boolean isValidTime(long acceptableTimeSkewSeconds){
  long now=System.currentTimeMillis();
  return (expirationTimeSeconds == null || now <= (expirationTimeSeconds + acceptableTimeSkewSeconds) * 1000) && (issuedAtTimeSeconds == null || now >= (issuedAtTimeSeconds - acceptableTimeSkewSeconds) * 1000);
}"
55083,"public void initialize(HttpRequest request) throws IOException {
  authorizer.initialize(request);
}","public void initialize(HttpRequest request) throws IOException {
  authorizer.initialize(request);
  request.setUnsuccessfulResponseHandler(this);
}"
55084,"public boolean handleResponse(HttpRequest request,HttpResponse response,boolean retrySupported){
  return false;
}","public boolean handleResponse(HttpRequest request,HttpResponse response,boolean retrySupported){
  if (response.getStatusCode() == 401) {
    token=null;
  }
  return false;
}"
55085,"@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws IOException, ServletException {
  PersistenceManager pm=getPersistenceManagerFactory().getPersistenceManager();
  String userId=getUserId();
  ThreeLeggedFlow oauthFlow=newFlow(userId);
  oauthFlow.setJsonFactory(getJsonFactory());
  oauthFlow.setHttpTransport(getHttpTransport());
  try {
    Credential cred=oauthFlow.loadCredential(pm);
    if (cred == null) {
      pm.makePersistent(oauthFlow);
      String authorizationUrl=oauthFlow.getAuthorizationUrl();
      resp.sendRedirect(authorizationUrl);
    }
 else {
      req.setAttribute(AUTH_CREDENTIAL,cred);
      super.service(req,resp);
    }
  }
  finally {
    pm.close();
  }
}","@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws IOException, ServletException {
  PersistenceManager pm=getPersistenceManagerFactory().getPersistenceManager();
  String userId=getUserId();
  ThreeLeggedFlow oauthFlow=newFlow(userId);
  oauthFlow.setJsonFactory(getJsonFactory());
  oauthFlow.setHttpTransport(getHttpTransport());
  try {
    Credential cred=oauthFlow.loadCredential(pm);
    if (cred != null && cred.isInvalid()) {
      pm.deletePersistent(cred);
      cred=null;
    }
    if (cred != null) {
      req.setAttribute(AUTH_CREDENTIAL,cred);
      try {
        super.service(req,resp);
      }
 catch (      HttpResponseException e) {
        e.getResponse().ignore();
        if (cred.isInvalid()) {
          pm.deletePersistent(cred);
          startAuthFlow(resp,pm,oauthFlow);
        }
 else {
          throw e;
        }
      }
    }
 else {
      startAuthFlow(resp,pm,oauthFlow);
    }
  }
  finally {
    pm.close();
  }
}"
55086,"/** 
 * Request a new access token from the authorization endpoint. <p> Default implementation executes the refresh token grant parameter passed to the constructor or  {@code false} if it was {@code null}. Subclasses may override. If a new access token was retrieved, implementations must call   {@link #setAccessToken(String)}. Implementations can assume proper thread synchronization is already taken care of inside   {@link #refreshToken()}, where this is called from. </p>
 * @return whether a new access token was retrieved
 * @throws IOException I/O exception
 */
protected boolean executeRefreshToken() throws IOException {
  if (refreshToken != null) {
    RefreshTokenGrant request=new RefreshTokenGrant(transport,jsonFactory,authorizationServerUrl,clientId,clientSecret,refreshToken);
    setAccessToken(request.execute().accessToken);
    return true;
  }
  return false;
}","/** 
 * Request a new access token from the authorization endpoint. <p> Default implementation executes the refresh token grant parameter passed to the constructor or  {@code false} if it was {@code null}. Subclasses may override. If a new access token was retrieved, implementations must call   {@link #setAccessToken(String)}. Implementations can assume proper thread synchronization is already taken care of inside   {@link #refreshToken()}, where this is called from. </p>
 * @return whether a new access token was retrieved
 * @throws IOException I/O exception
 */
protected boolean executeRefreshToken() throws IOException {
  if (refreshToken != null) {
    RefreshTokenGrant request=new RefreshTokenGrant(transport,jsonFactory,authorizationServerUrl,clientId,clientSecret,refreshToken);
    try {
      setAccessToken(request.execute().accessToken);
    }
 catch (    HttpResponseException e) {
      setAccessToken(null);
    }
    return true;
  }
  return false;
}"
55087,"@ExpectPermission(Permission.PROJECT_ADMINISTRATION) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public int updateMailTicketConfig(@PathVariable(""String_Node_Str"") String projectShortName,@PathVariable(""String_Node_Str"") int configId,@PathVariable(""String_Node_Str"") int id,@RequestBody ProjectMailTicket updatedTicket){
  int projectId=projectService.findIdByShortName(projectShortName);
  ProjectMailTicket ticket=mailTicketService.findTicket(id);
  ProjectMailTicketConfig config=mailTicketService.findConfig(ticket.getConfigId());
  Validate.isTrue(config.getProjectId() == projectId);
  BoardColumn column=boardColumnRepository.findById(updatedTicket.getColumnId());
  Board board=boardRepository.findBoardById(column.getBoardId());
  Validate.isTrue(board.getProjectId() == projectId);
  return mailTicketService.updateTicket(id,updatedTicket.getName(),updatedTicket.getEnabled(),updatedTicket.getAlias(),updatedTicket.getSendByAlias(),updatedTicket.getColumnId(),updatedTicket.getConfigId(),updatedTicket.getMetadata());
}","@ExpectPermission(Permission.PROJECT_ADMINISTRATION) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public int updateMailTicketConfig(@PathVariable(""String_Node_Str"") String projectShortName,@PathVariable(""String_Node_Str"") int id,@RequestBody ProjectMailTicket updatedTicket){
  int projectId=projectService.findIdByShortName(projectShortName);
  ProjectMailTicket ticket=mailTicketService.findTicket(id);
  ProjectMailTicketConfig config=mailTicketService.findConfig(ticket.getConfigId());
  Validate.isTrue(config.getProjectId() == projectId);
  BoardColumn column=boardColumnRepository.findById(updatedTicket.getColumnId());
  Board board=boardRepository.findBoardById(column.getBoardId());
  Validate.isTrue(board.getProjectId() == projectId);
  return mailTicketService.updateTicket(id,updatedTicket.getName(),updatedTicket.getEnabled(),updatedTicket.getAlias(),updatedTicket.getSendByAlias(),updatedTicket.getColumnId(),updatedTicket.getConfigId(),updatedTicket.getMetadata());
}"
55088,"@Override public JsonElement serialize(Date date,Type type,JsonSerializationContext jsonSerializationContext){
  return new JsonPrimitive(DateFormatUtils.format(date,Constants.DATE_FORMAT,TimeZone.getTimeZone(""String_Node_Str"")));
}","@Override public JsonElement serialize(Date date,Type type,JsonSerializationContext jsonSerializationContext){
  return date == null ? JsonNull.INSTANCE : new JsonPrimitive(DateFormatUtils.format(date,Constants.DATE_FORMAT,TimeZone.getTimeZone(""String_Node_Str"")));
}"
55089,"@Override protected void doFilterInternal(HttpServletRequest req,HttpServletResponse resp,FilterChain chain) throws IOException, ServletException {
  String token=CSRFToken.getToken(req);
  if (token == null) {
    token=UUID.randomUUID().toString();
    req.getSession().setAttribute(CSRFToken.CSRF_TOKEN,token);
  }
  resp.setHeader(CSRF_TOKEN_HEADER,token);
  if (mustCheckCSRF(req)) {
    ImmutablePair<Boolean,ImmutablePair<Integer,String>> res=checkCSRF(req);
    if (!res.left) {
      LOG.info(""String_Node_Str"");
      resp.sendError(res.right.left,res.right.right);
      return;
    }
  }
  chain.doFilter(req,resp);
}","@Override protected void doFilterInternal(HttpServletRequest req,HttpServletResponse resp,FilterChain chain) throws IOException, ServletException {
  String token=CSRFToken.getToken(req);
  if (token == null) {
    token=UUID.randomUUID().toString();
    CSRFToken.setToken(req,token);
  }
  resp.setHeader(CSRF_TOKEN_HEADER,token);
  if (mustCheckCSRF(req)) {
    ImmutablePair<Boolean,ImmutablePair<Integer,String>> res=checkCSRF(req);
    if (!res.left) {
      LOG.info(""String_Node_Str"");
      resp.sendError(res.right.left,res.right.right);
      return;
    }
  }
  chain.doFilter(req,resp);
}"
55090,"private static ImmutablePair<Boolean,ImmutablePair<Integer,String>> checkCSRF(HttpServletRequest request) throws IOException {
  String expectedToken=(String)request.getSession().getAttribute(CSRFToken.CSRF_TOKEN);
  String token=request.getHeader(CSRF_TOKEN_HEADER);
  if (token == null) {
    token=request.getParameter(CSRF_FORM_PARAMETER);
  }
  if (token == null) {
    return of(false,of(HttpServletResponse.SC_FORBIDDEN,""String_Node_Str""));
  }
  if (expectedToken == null) {
    return of(false,of(HttpServletResponse.SC_FORBIDDEN,""String_Node_Str""));
  }
  if (!safeArrayEquals(token.getBytes(""String_Node_Str""),expectedToken.getBytes(""String_Node_Str""))) {
    return of(false,of(HttpServletResponse.SC_FORBIDDEN,""String_Node_Str""));
  }
  return of(true,null);
}","private static ImmutablePair<Boolean,ImmutablePair<Integer,String>> checkCSRF(HttpServletRequest request) throws IOException {
  String expectedToken=CSRFToken.getToken(request);
  String token=request.getHeader(CSRF_TOKEN_HEADER);
  if (token == null) {
    token=request.getParameter(CSRF_FORM_PARAMETER);
  }
  if (token == null) {
    return of(false,of(HttpServletResponse.SC_FORBIDDEN,""String_Node_Str""));
  }
  if (expectedToken == null) {
    return of(false,of(HttpServletResponse.SC_FORBIDDEN,""String_Node_Str""));
  }
  if (!safeArrayEquals(token.getBytes(""String_Node_Str""),expectedToken.getBytes(""String_Node_Str""))) {
    return of(false,of(HttpServletResponse.SC_FORBIDDEN,""String_Node_Str""));
  }
  return of(true,null);
}"
55091,"public Map<String,Object> modelForLoginPage(HttpServletRequest request){
  String tokenValue=(String)request.getSession().getAttribute(CSRFToken.CSRF_TOKEN);
  Map<String,Object> r=new HashMap<>();
  r.put(""String_Node_Str"",tokenValue);
  r.put(""String_Node_Str"",UriComponentsBuilder.fromPath(request.getParameter(""String_Node_Str"")).build().encode().toUriString());
  return r;
}","public Map<String,Object> modelForLoginPage(HttpServletRequest request){
  String tokenValue=CSRFToken.getToken(request);
  Map<String,Object> r=new HashMap<>();
  r.put(""String_Node_Str"",tokenValue);
  r.put(""String_Node_Str"",UriComponentsBuilder.fromPath(request.getParameter(""String_Node_Str"")).build().encode().toUriString());
  return r;
}"
55092,"@Test public void testPOSTWithWrongToken() throws IOException, ServletException {
  CSFRFilter filter=new CSFRFilter();
  MockHttpServletRequest request=new MockHttpServletRequest();
  request.setMethod(""String_Node_Str"");
  MockHttpServletResponse response=new MockHttpServletResponse();
  FilterChain chain=Mockito.mock(FilterChain.class);
  filter.init(filterConfig);
  filter.doFilterInternal(request,response,chain);
  Mockito.verify(chain).doFilter(request,response);
  request.setMethod(""String_Node_Str"");
  request.setParameter(""String_Node_Str"",response.getHeader(""String_Node_Str""));
  request.getSession().setAttribute(CSRFToken.CSRF_TOKEN,""String_Node_Str"");
  filter.doFilterInternal(request,response,chain);
  Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,response.getStatus());
}","@Test public void testPOSTWithWrongToken() throws IOException, ServletException {
  CSFRFilter filter=new CSFRFilter();
  MockHttpServletRequest request=new MockHttpServletRequest();
  request.setMethod(""String_Node_Str"");
  MockHttpServletResponse response=new MockHttpServletResponse();
  FilterChain chain=Mockito.mock(FilterChain.class);
  filter.init(filterConfig);
  filter.doFilterInternal(request,response,chain);
  Mockito.verify(chain).doFilter(request,response);
  request.setMethod(""String_Node_Str"");
  request.setParameter(""String_Node_Str"",response.getHeader(""String_Node_Str""));
  CSRFToken.setToken(request,""String_Node_Str"");
  filter.doFilterInternal(request,response,chain);
  Assert.assertEquals(HttpServletResponse.SC_FORBIDDEN,response.getStatus());
}"
55093,"@ExpectPermission(Permission.UPDATE_PROFILE) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public int updateUserProfile(UserWithPermission user,@RequestBody DisplayNameEmail toUpdate){
  int result=userRepository.updateProfile(user,toUpdate.getEmail(),toUpdate.getDisplayName(),toUpdate.isEmailNotification(),toUpdate.isSkipOwnNotifications());
  eventEmitter.emitUpdateUserProfile(user.getId());
  return result;
}","@ExpectPermission(Permission.UPDATE_PROFILE) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public int updateUserProfile(UserWithPermission user,@RequestBody DisplayNameEmail toUpdate){
  int result=userRepository.updateProfile(user,toUpdate.getEmail(),toUpdate.getDisplayName(),toUpdate.getEmailNotification(),toUpdate.getSkipOwnNotifications());
  eventEmitter.emitUpdateUserProfile(user.getId());
  return result;
}"
55094,"@Transactional(readOnly=false) public ImmutablePair<Boolean,CardData> createFile(String name,String digest,long fileSize,int cardId,InputStream content,String contentType,User user,Date time){
  if (!cardDataRepository.fileExists(digest)) {
    cardDataRepository.addUploadContent(digest,fileSize,content,contentType);
  }
  if (!cardDataRepository.isFileAvailableByCard(digest,cardId)) {
    CardData file=cardDataRepository.createData(cardId,CardType.FILE,digest);
    cardDataRepository.createUploadInfo(digest,name,name,file.getId());
    eventRepository.insertFileEvent(file.getId(),cardId,EventType.FILE_UPLOAD,user.getId(),file.getId(),name,time);
    return ImmutablePair.of(true,file);
  }
  return ImmutablePair.of(false,null);
}","@Transactional(readOnly=false) public ImmutablePair<Boolean,CardData> createFile(String name,String digest,long fileSize,int cardId,InputStream content,String contentType,User user,Date time){
  if (!cardDataRepository.fileExists(digest)) {
    cardDataRepository.addUploadContent(digest,fileSize,content,contentType);
  }
  if (!cardDataRepository.isFileAvailableByCard(digest,cardId)) {
    CardData file=cardDataRepository.createData(cardId,CardType.FILE,digest);
    cardDataRepository.createUploadInfo(digest,name,name,file.getId());
    eventRepository.insertFileEvent(file.getId(),cardId,EventType.FILE_UPLOAD,user.getId(),file.getId(),name,time);
    return ImmutablePair.of(true,file);
  }
  return ImmutablePair.<Boolean,CardData>of(false,null);
}"
55095,"private WebSecurityUser(io.lavagna.model.User user){
  this.id=user.getId();
  this.anonymous=user.isAnonymous();
}","private WebSecurityUser(io.lavagna.model.User user){
  this.id=user.getId();
  this.anonymous=user.getAnonymous();
}"
55096,"@Transactional(readOnly=false) public CardLabelValue addLabelValueToCard(CardLabel label,int cardId,LabelValue val){
  queries.addLabelValueToCard(cardId,label.isUnique() ? true : null,label.getId(),label.getType().toString(),val.getValueString(),val.getValueTimestamp(),val.getValueInt(),val.getValueCard(),val.getValueUser(),val.getValueList());
  return queries.findLastCreatedLabelValue();
}","@Transactional(readOnly=false) public CardLabelValue addLabelValueToCard(CardLabel label,int cardId,LabelValue val){
  queries.addLabelValueToCard(cardId,label.getUnique() ? true : null,label.getId(),label.getType().toString(),val.getValueString(),val.getValueTimestamp(),val.getValueInt(),val.getValueCard(),val.getValueUser(),val.getValueList());
  return queries.findLastCreatedLabelValue();
}"
55097,"private void importLabels(Path tempFile,Project createdProject,String projectNameDir){
  List<Pair<CardLabel,List<LabelListValueWithMetadata>>> labels=readObject(projectNameDir + ""String_Node_Str"",tempFile,new TypeToken<List<Pair<CardLabel,List<LabelListValueWithMetadata>>>>(){
  }
);
  for (  Pair<CardLabel,List<LabelListValueWithMetadata>> pLabel : labels) {
    CardLabel label=pLabel.getFirst();
    if (label.getDomain() == LabelDomain.USER) {
      cardLabelRepository.addLabel(createdProject.getId(),label.isUnique(),label.getType(),label.getDomain(),label.getName(),label.getColor());
    }
    if (label.getType() == LabelType.LIST && !pLabel.getSecond().isEmpty()) {
      CardLabel importedCl=cardLabelRepository.findLabelByName(createdProject.getId(),label.getName(),label.getDomain());
      for (      LabelListValueWithMetadata llv : pLabel.getSecond()) {
        LabelListValue addedLabeListValue=cardLabelRepository.addLabelListValue(importedCl.getId(),llv.getValue());
        if (llv.getMetadata() != null) {
          for (          Entry<String,String> metadataKV : llv.getMetadata().entrySet()) {
            cardLabelRepository.createLabelListMetadata(addedLabeListValue.getId(),metadataKV.getKey(),metadataKV.getValue());
          }
        }
      }
    }
  }
}","private void importLabels(Path tempFile,Project createdProject,String projectNameDir){
  List<Pair<CardLabel,List<LabelListValueWithMetadata>>> labels=readObject(projectNameDir + ""String_Node_Str"",tempFile,new TypeToken<List<Pair<CardLabel,List<LabelListValueWithMetadata>>>>(){
  }
);
  for (  Pair<CardLabel,List<LabelListValueWithMetadata>> pLabel : labels) {
    CardLabel label=pLabel.getFirst();
    if (label.getDomain() == LabelDomain.USER) {
      cardLabelRepository.addLabel(createdProject.getId(),label.getUnique(),label.getType(),label.getDomain(),label.getName(),label.getColor());
    }
    if (label.getType() == LabelType.LIST && !pLabel.getSecond().isEmpty()) {
      CardLabel importedCl=cardLabelRepository.findLabelByName(createdProject.getId(),label.getName(),label.getDomain());
      for (      LabelListValueWithMetadata llv : pLabel.getSecond()) {
        LabelListValue addedLabeListValue=cardLabelRepository.addLabelListValue(importedCl.getId(),llv.getValue());
        if (llv.getMetadata() != null) {
          for (          Entry<String,String> metadataKV : llv.getMetadata().entrySet()) {
            cardLabelRepository.createLabelListMetadata(addedLabeListValue.getId(),metadataKV.getKey(),metadataKV.getValue());
          }
        }
      }
    }
  }
}"
55098,"private void importMissingBoard(Project project,BoardInfo boardInfo,Path tempFile,ImportContext idMapping){
  Board createdBoard=boardRepository.createEmptyBoard(boardInfo.getName(),boardInfo.getShortName(),boardInfo.getDescription(),project.getId());
  boardRepository.updateBoard(createdBoard.getId(),createdBoard.getName(),createdBoard.getDescription(),boardInfo.isArchived());
  List<BoardColumn> boardColumns=readObject(""String_Node_Str"" + boardInfo.getShortName() + ""String_Node_Str"",tempFile,new TypeToken<List<BoardColumn>>(){
  }
);
  int boardId=boardRepository.findBoardIdByShortName(boardInfo.getShortName());
  Map<ColumnDefinition,BoardColumnDefinition> colsDef=projectService.findMappedColumnDefinitionsByProjectId(project.getId());
  for (  BoardColumn bc : boardColumns) {
    BoardColumn added=boardColumnRepository.addColumnToBoard(bc.getName(),colsDef.get(bc.getStatus()).getId(),bc.getLocation(),boardId);
    boardColumnRepository.updateOrder(added.getId(),bc.getOrder());
    idMapping.getColumns().put(bc.getId(),added.getId());
  }
  List<StatisticForExport> stats=readObject(""String_Node_Str"" + boardInfo.getShortName() + ""String_Node_Str"",tempFile,new TypeToken<List<StatisticForExport>>(){
  }
);
  for (  StatisticForExport stat : stats) {
    statisticsQuery.addFromImport(stat.getDate(),boardId,colsDef.get(stat.getColumnDefinition()).getId(),stat.getLocation().toString(),stat.getCount());
  }
}","private void importMissingBoard(Project project,BoardInfo boardInfo,Path tempFile,ImportContext idMapping){
  Board createdBoard=boardRepository.createEmptyBoard(boardInfo.getName(),boardInfo.getShortName(),boardInfo.getDescription(),project.getId());
  boardRepository.updateBoard(createdBoard.getId(),createdBoard.getName(),createdBoard.getDescription(),boardInfo.getArchived());
  List<BoardColumn> boardColumns=readObject(""String_Node_Str"" + boardInfo.getShortName() + ""String_Node_Str"",tempFile,new TypeToken<List<BoardColumn>>(){
  }
);
  int boardId=boardRepository.findBoardIdByShortName(boardInfo.getShortName());
  Map<ColumnDefinition,BoardColumnDefinition> colsDef=projectService.findMappedColumnDefinitionsByProjectId(project.getId());
  for (  BoardColumn bc : boardColumns) {
    BoardColumn added=boardColumnRepository.addColumnToBoard(bc.getName(),colsDef.get(bc.getStatus()).getId(),bc.getLocation(),boardId);
    boardColumnRepository.updateOrder(added.getId(),bc.getOrder());
    idMapping.getColumns().put(bc.getId(),added.getId());
  }
  List<StatisticForExport> stats=readObject(""String_Node_Str"" + boardInfo.getShortName() + ""String_Node_Str"",tempFile,new TypeToken<List<StatisticForExport>>(){
  }
);
  for (  StatisticForExport stat : stats) {
    statisticsQuery.addFromImport(stat.getDate(),boardId,colsDef.get(stat.getColumnDefinition()).getId(),stat.getLocation().toString(),stat.getCount());
  }
}"
55099,"/** 
 * Send email (if all the conditions are met) to the user.
 * @param userId
 * @param upTo
 * @param emailEnabled
 * @param mailConfig
 */
public void notifyUser(int userId,Date upTo,boolean emailEnabled,MailConfig mailConfig){
  Date lastSent=queries.lastEmailSent(userId);
  User user=userRepository.findById(userId);
  Date fromDate=ObjectUtils.firstNonNull(lastSent,DateUtils.addDays(upTo,-1));
  List<Event> events=user.isSkipOwnNotifications() ? queries.eventsForUserWithoutHisOwns(userId,fromDate,upTo) : queries.eventsForUser(userId,fromDate,upTo);
  if (!events.isEmpty() && mailConfig != null && mailConfig.isMinimalConfigurationPresent() && emailEnabled && user.canSendEmail()) {
    try {
      sendEmailToUser(user,events,mailConfig);
    }
 catch (    MustacheException|IOException|MailException e) {
      LOG.warn(""String_Node_Str"" + user.getId(),e);
    }
  }
  queries.updateSentEmailDate(upTo,userId);
}","/** 
 * Send email (if all the conditions are met) to the user.
 * @param userId
 * @param upTo
 * @param emailEnabled
 * @param mailConfig
 */
public void notifyUser(int userId,Date upTo,boolean emailEnabled,MailConfig mailConfig){
  Date lastSent=queries.lastEmailSent(userId);
  User user=userRepository.findById(userId);
  Date fromDate=ObjectUtils.firstNonNull(lastSent,DateUtils.addDays(upTo,-1));
  List<Event> events=user.getSkipOwnNotifications() ? queries.eventsForUserWithoutHisOwns(userId,fromDate,upTo) : queries.eventsForUser(userId,fromDate,upTo);
  if (!events.isEmpty() && mailConfig != null && mailConfig.getMinimalConfigurationPresent() && emailEnabled && user.canSendEmail()) {
    try {
      sendEmailToUser(user,events,mailConfig);
    }
 catch (    MustacheException|IOException|MailException e) {
      LOG.warn(""String_Node_Str"" + user.getId(),e);
    }
  }
  queries.updateSentEmailDate(upTo,userId);
}"
55100,"private void checkRoleCondition(String roleName,Set<Integer> usersId){
  if (""String_Node_Str"".equals(roleName) && !usersId.isEmpty()) {
    Validate.isTrue(usersId.size() == 1);
    Validate.isTrue(userRepository.findById(usersId.iterator().next()).isAnonymous());
  }
}","private void checkRoleCondition(String roleName,Set<Integer> usersId){
  if (""String_Node_Str"".equals(roleName) && !usersId.isEmpty()) {
    Validate.isTrue(usersId.size() == 1);
    Validate.isTrue(userRepository.findById(usersId.iterator().next()).getAnonymous());
  }
}"
55101,"private RoleAndPermissions(RoleAndPermission base){
  this.name=base.getRoleName();
  this.removable=base.isRemovable();
  this.hidden=base.isHidden();
  this.readOnly=base.isReadOnly();
}","private RoleAndPermissions(RoleAndPermission base){
  this.name=base.getRoleName();
  this.removable=base.getRemovable();
  this.hidden=base.getHidden();
  this.readOnly=base.getReadOnly();
}"
55102,"@Transactional(readOnly=false) public void createMissingRolesWithPermissions(Map<RoleAndPermission,Set<Permission>> rolesWithPermissions){
  Set<String> currentRoles=findAllRolesAndRelatedPermission().keySet();
  for (  Entry<RoleAndPermission,Set<Permission>> kv : rolesWithPermissions.entrySet()) {
    RoleAndPermission rp=kv.getKey();
    if (!currentRoles.contains(rp.getRoleName())) {
      queries.createFullRole(rp.getRoleName(),rp.isRemovable(),rp.isHidden(),rp.isHidden());
    }
    updatePermissionsToRole(new Role(rp.getRoleName()),kv.getValue());
  }
}","@Transactional(readOnly=false) public void createMissingRolesWithPermissions(Map<RoleAndPermission,Set<Permission>> rolesWithPermissions){
  Set<String> currentRoles=findAllRolesAndRelatedPermission().keySet();
  for (  Entry<RoleAndPermission,Set<Permission>> kv : rolesWithPermissions.entrySet()) {
    RoleAndPermission rp=kv.getKey();
    if (!currentRoles.contains(rp.getRoleName())) {
      queries.createFullRole(rp.getRoleName(),rp.getRemovable(),rp.getHidden(),rp.getHidden());
    }
    updatePermissionsToRole(new Role(rp.getRoleName()),kv.getValue());
  }
}"
55103,"@Transactional(readOnly=false) public void createMissingRolesWithPermissionForProjects(Map<Integer,Map<RoleAndPermission,Set<Permission>>> r){
  for (  Entry<Integer,Map<RoleAndPermission,Set<Permission>>> projIdToRolesAndPermissions : r.entrySet()) {
    int projectId=projIdToRolesAndPermissions.getKey();
    Set<String> currentRoles=findAllRolesAndRelatedPermissionInProjectId(projectId).keySet();
    for (    Entry<RoleAndPermission,Set<Permission>> kv : projIdToRolesAndPermissions.getValue().entrySet()) {
      RoleAndPermission rp=kv.getKey();
      if (!currentRoles.contains(rp.getRoleName())) {
        createFullRoleInProjectId(new Role(rp.getRoleName()),projectId,rp.isRemovable(),rp.isHidden(),rp.isReadOnly());
      }
      updatePermissionsToRoleInProjectId(new Role(rp.getRoleName()),kv.getValue(),projectId);
    }
  }
}","@Transactional(readOnly=false) public void createMissingRolesWithPermissionForProjects(Map<Integer,Map<RoleAndPermission,Set<Permission>>> r){
  for (  Entry<Integer,Map<RoleAndPermission,Set<Permission>>> projIdToRolesAndPermissions : r.entrySet()) {
    int projectId=projIdToRolesAndPermissions.getKey();
    Set<String> currentRoles=findAllRolesAndRelatedPermissionInProjectId(projectId).keySet();
    for (    Entry<RoleAndPermission,Set<Permission>> kv : projIdToRolesAndPermissions.getValue().entrySet()) {
      RoleAndPermission rp=kv.getKey();
      if (!currentRoles.contains(rp.getRoleName())) {
        createFullRoleInProjectId(new Role(rp.getRoleName()),projectId,rp.getRemovable(),rp.getHidden(),rp.getReadOnly());
      }
      updatePermissionsToRoleInProjectId(new Role(rp.getRoleName()),kv.getValue(),projectId);
    }
  }
}"
55104,"/** 
 * Bulk creation of projects. Will skip the project that already exists.
 * @param projects
 */
@Transactional(readOnly=false) public ImmutablePair<List<Project>,List<Project>> createMissing(List<Project> projects){
  List<Project> created=new ArrayList<>();
  List<Project> skipped=new ArrayList<>();
  Set<String> usedShortNames=new HashSet<>();
  for (  Project pi : findAll()) {
    usedShortNames.add(pi.getShortName());
  }
  for (  Project p : projects) {
    if (!usedShortNames.contains(p.getShortName())) {
      Project createdProject=create(p.getName(),p.getShortName(),p.getDescription());
      updateProject(createdProject.getId(),createdProject.getName(),createdProject.getDescription(),p.isArchived());
      created.add(createdProject);
    }
 else {
      skipped.add(p);
    }
  }
  return ImmutablePair.of(Collections.unmodifiableList(created),Collections.unmodifiableList(skipped));
}","/** 
 * Bulk creation of projects. Will skip the project that already exists.
 * @param projects
 */
@Transactional(readOnly=false) public ImmutablePair<List<Project>,List<Project>> createMissing(List<Project> projects){
  List<Project> created=new ArrayList<>();
  List<Project> skipped=new ArrayList<>();
  Set<String> usedShortNames=new HashSet<>();
  for (  Project pi : findAll()) {
    usedShortNames.add(pi.getShortName());
  }
  for (  Project p : projects) {
    if (!usedShortNames.contains(p.getShortName())) {
      Project createdProject=create(p.getName(),p.getShortName(),p.getDescription());
      updateProject(createdProject.getId(),createdProject.getName(),createdProject.getDescription(),p.getArchived());
      created.add(createdProject);
    }
 else {
      skipped.add(p);
    }
  }
  return ImmutablePair.of(Collections.unmodifiableList(created),Collections.unmodifiableList(skipped));
}"
55105,"private static SqlParameterSource prepareUserParameterSource(User user){
  return new MapSqlParameterSource(""String_Node_Str"",trimToNull(user.getProvider())).addValue(""String_Node_Str"",trimToNull(user.getUsername())).addValue(""String_Node_Str"",trimToNull(user.getEmail())).addValue(""String_Node_Str"",trimToNull(user.getDisplayName())).addValue(""String_Node_Str"",user.isEnabled()).addValue(""String_Node_Str"",user.isEmailNotification()).addValue(""String_Node_Str"",ObjectUtils.firstNonNull(user.getMemberSince(),new Date())).addValue(""String_Node_Str"",user.isSkipOwnNotifications()).addValue(""String_Node_Str"",user.getUserMetadataRaw());
}","private static SqlParameterSource prepareUserParameterSource(User user){
  return new MapSqlParameterSource(""String_Node_Str"",trimToNull(user.getProvider())).addValue(""String_Node_Str"",trimToNull(user.getUsername())).addValue(""String_Node_Str"",trimToNull(user.getEmail())).addValue(""String_Node_Str"",trimToNull(user.getDisplayName())).addValue(""String_Node_Str"",user.getEnabled()).addValue(""String_Node_Str"",user.getEmailNotification()).addValue(""String_Node_Str"",ObjectUtils.firstNonNull(user.getMemberSince(),new Date())).addValue(""String_Node_Str"",user.getSkipOwnNotifications()).addValue(""String_Node_Str"",user.getUserMetadataRaw());
}"
55106,"@Transactional(readOnly=false) public void createUser(UserToCreate userToCreate){
  requireNonNull(userToCreate);
  requireNonNull(userToCreate.getProvider());
  requireNonNull(userToCreate.getUsername());
  userRepository.createUser(userToCreate.getProvider(),userToCreate.getUsername(),userToCreate.getEmail(),userToCreate.getDisplayName(),userToCreate.isEnabled());
  if (userToCreate.getRoles() == null) {
    return;
  }
  User u=userRepository.findUserByName(userToCreate.getProvider(),userToCreate.getUsername());
  Set<Integer> userId=Collections.singleton(u.getId());
  for (  String r : userToCreate.getRoles()) {
    permissionService.assignRoleToUsers(new Role(r),userId);
  }
}","@Transactional(readOnly=false) public void createUser(UserToCreate userToCreate){
  requireNonNull(userToCreate);
  requireNonNull(userToCreate.getProvider());
  requireNonNull(userToCreate.getUsername());
  userRepository.createUser(userToCreate.getProvider(),userToCreate.getUsername(),userToCreate.getEmail(),userToCreate.getDisplayName(),userToCreate.getEnabled());
  if (userToCreate.getRoles() == null) {
    return;
  }
  User u=userRepository.findUserByName(userToCreate.getProvider(),userToCreate.getUsername());
  Set<Integer> userId=Collections.singleton(u.getId());
  for (  String r : userToCreate.getRoles()) {
    permissionService.assignRoleToUsers(new Role(r),userId);
  }
}"
55107,"@ExpectPermission(Permission.PROJECT_ADMINISTRATION) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public CardLabel addLabel(@PathVariable(""String_Node_Str"") String projectShortName,@RequestBody Label label){
  int projectId=projectService.findIdByShortName(projectShortName);
  CardLabel cl=cardLabelRepository.addLabel(projectId,label.isUnique(),label.getType(),LabelDomain.USER,label.getName(),label.getColor());
  eventEmitter.emitAddLabel(projectShortName);
  return cl;
}","@ExpectPermission(Permission.PROJECT_ADMINISTRATION) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public CardLabel addLabel(@PathVariable(""String_Node_Str"") String projectShortName,@RequestBody Label label){
  int projectId=projectService.findIdByShortName(projectShortName);
  CardLabel cl=cardLabelRepository.addLabel(projectId,label.getUnique(),label.getType(),LabelDomain.USER,label.getName(),label.getColor());
  eventEmitter.emitAddLabel(projectShortName);
  return cl;
}"
55108,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public void updateRole(@PathVariable(""String_Node_Str"") String roleName,@RequestBody UpdateRole updateRole){
  RoleAndMetadata role=permissionService.findRoleByName(roleName);
  Validate.isTrue(!role.isReadOnly());
  permissionService.updatePermissionsToRole(new Role(roleName),updateRole.getPermissions());
  eventEmitter.emitUpdatePermissionsToRole();
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public void updateRole(@PathVariable(""String_Node_Str"") String roleName,@RequestBody UpdateRole updateRole){
  RoleAndMetadata role=permissionService.findRoleByName(roleName);
  Validate.isTrue(!role.getReadOnly());
  permissionService.updatePermissionsToRole(new Role(roleName),updateRole.getPermissions());
  eventEmitter.emitUpdatePermissionsToRole();
}"
55109,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) public void deleteRole(@PathVariable(""String_Node_Str"") String roleName){
  RoleAndMetadata role=permissionService.findRoleByName(roleName);
  Validate.isTrue(role.isRemovable());
  permissionService.deleteRole(new Role(roleName));
  eventEmitter.emitDeleteRole();
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) public void deleteRole(@PathVariable(""String_Node_Str"") String roleName){
  RoleAndMetadata role=permissionService.findRoleByName(roleName);
  Validate.isTrue(role.getRemovable());
  permissionService.deleteRole(new Role(roleName));
  eventEmitter.emitDeleteRole();
}"
55110,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public void updateRole(@PathVariable(""String_Node_Str"") String projectShortName,@PathVariable(""String_Node_Str"") String roleName,@RequestBody UpdateRole updateRole){
  int projectId=projectService.findIdByShortName(projectShortName);
  RoleAndMetadata role=permissionService.findRoleInProjectByName(projectId,roleName);
  Validate.isTrue(!role.isReadOnly());
  permissionService.updatePermissionsToRoleInProjectId(new Role(roleName),updateRole.getPermissions(),projectId);
  eventEmitter.emitUpdatePermissionsToRole(projectShortName);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public void updateRole(@PathVariable(""String_Node_Str"") String projectShortName,@PathVariable(""String_Node_Str"") String roleName,@RequestBody UpdateRole updateRole){
  int projectId=projectService.findIdByShortName(projectShortName);
  RoleAndMetadata role=permissionService.findRoleInProjectByName(projectId,roleName);
  Validate.isTrue(!role.getReadOnly());
  permissionService.updatePermissionsToRoleInProjectId(new Role(roleName),updateRole.getPermissions(),projectId);
  eventEmitter.emitUpdatePermissionsToRole(projectShortName);
}"
55111,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) public void deleteRole(@PathVariable(""String_Node_Str"") String projectShortName,@PathVariable(""String_Node_Str"") String roleName){
  int projectId=projectService.findIdByShortName(projectShortName);
  RoleAndMetadata role=permissionService.findRoleInProjectByName(projectId,roleName);
  Validate.isTrue(role.isRemovable());
  permissionService.deleteRoleInProjectId(new Role(roleName),projectId);
  eventEmitter.emitDeleteRole(projectShortName);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) public void deleteRole(@PathVariable(""String_Node_Str"") String projectShortName,@PathVariable(""String_Node_Str"") String roleName){
  int projectId=projectService.findIdByShortName(projectShortName);
  RoleAndMetadata role=permissionService.findRoleInProjectByName(projectId,roleName);
  Validate.isTrue(role.getRemovable());
  permissionService.deleteRoleInProjectId(new Role(roleName),projectId);
  eventEmitter.emitDeleteRole(projectShortName);
}"
55112,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public Map<PermissionCategory,List<Permission>> existingPermissions(@PathVariable(""String_Node_Str"") String projectShortName){
  Map<PermissionCategory,List<Permission>> byCategory=new LinkedHashMap<>();
  for (  PermissionCategory pc : PermissionCategory.values()) {
    if (!pc.isOnlyForBase()) {
      byCategory.put(pc,new ArrayList<Permission>());
    }
  }
  for (  Permission permission : Permission.values()) {
    if (!permission.isOnlyForBase() && byCategory.containsKey(permission.getCategory())) {
      byCategory.get(permission.getCategory()).add(permission);
    }
  }
  return byCategory;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public Map<PermissionCategory,List<Permission>> existingPermissions(@PathVariable(""String_Node_Str"") String projectShortName){
  Map<PermissionCategory,List<Permission>> byCategory=new LinkedHashMap<>();
  for (  PermissionCategory pc : PermissionCategory.values()) {
    if (!pc.getOnlyForBase()) {
      byCategory.put(pc,new ArrayList<Permission>());
    }
  }
  for (  Permission permission : Permission.values()) {
    if (!permission.getOnlyForBase() && byCategory.containsKey(permission.getCategory())) {
      byCategory.get(permission.getCategory()).add(permission);
    }
  }
  return byCategory;
}"
55113,"public static void authenticateUserIfRemembered(HttpServletRequest req,HttpServletResponse resp,UserRepository userRepository){
  Cookie c;
  if (isUserAuthenticated(req) || (c=getCookie(req,CookieNames.getRememberMeCookieName())) == null) {
    return;
  }
  ImmutablePair<Integer,String> uIdToken=extractUserIdAndToken(c.getValue());
  if (uIdToken != null && userRepository.rememberMeTokenExists(uIdToken.getLeft(),uIdToken.getRight())) {
    userRepository.deleteRememberMeToken(uIdToken.getLeft(),uIdToken.getRight());
    User user=userRepository.findById(uIdToken.getLeft());
    setUser(user.getId(),user.isAnonymous(),req,resp,userRepository,true);
  }
 else {
    c.setMaxAge(0);
    c.setValue(null);
    resp.addCookie(c);
  }
}","public static void authenticateUserIfRemembered(HttpServletRequest req,HttpServletResponse resp,UserRepository userRepository){
  Cookie c;
  if (isUserAuthenticated(req) || (c=getCookie(req,CookieNames.getRememberMeCookieName())) == null) {
    return;
  }
  ImmutablePair<Integer,String> uIdToken=extractUserIdAndToken(c.getValue());
  if (uIdToken != null && userRepository.rememberMeTokenExists(uIdToken.getLeft(),uIdToken.getRight())) {
    userRepository.deleteRememberMeToken(uIdToken.getLeft(),uIdToken.getRight());
    User user=userRepository.findById(uIdToken.getLeft());
    setUser(user.getId(),user.getAnonymous(),req,resp,userRepository,true);
  }
 else {
    c.setMaxAge(0);
    c.setValue(null);
    resp.addCookie(c);
  }
}"
55114,"@Test public void testGetStandardCalendar() throws URISyntaxException, ParseException {
  Card assignedCard=cardService.createCard(""String_Node_Str"",col.getId(),new Date(),user);
  cardDataService.updateDescription(assignedCard.getId(),""String_Node_Str"",new Date(),user.getId());
  Card watchedCard=cardService.createCard(""String_Node_Str"",col.getId(),new Date(),user);
  Date now=new Date();
  CardLabel assigned=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",LabelDomain.SYSTEM);
  labelService.addLabelValueToCard(assigned,assignedCard.getId(),new CardLabelValue.LabelValue(user.getId()),user,now);
  CardLabel watched=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",LabelDomain.SYSTEM);
  labelService.addLabelValueToCard(watched,watchedCard.getId(),new CardLabelValue.LabelValue(user.getId()),user,now);
  CardLabel dueDate=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",LabelDomain.SYSTEM);
  labelService.addLabelValueToCard(dueDate,assignedCard.getId(),new CardLabelValue.LabelValue(now),user,now);
  labelService.addLabelValueToCard(dueDate,watchedCard.getId(),new CardLabelValue.LabelValue(now),user,now);
  UserWithPermission uwpGlobalRead=new UserWithPermission(user,EnumSet.of(Permission.READ),Collections.<String,Set<Permission>>emptyMap(),Collections.<Integer,Set<Permission>>emptyMap());
  CalendarEvents events=calendarService.getUserCalendar(uwpGlobalRead);
  Assert.assertNotNull(events);
  Assert.assertEquals(2,events.getDailyEvents().get(now).getCards().size());
}","@Test public void testGetStandardCalendar() throws URISyntaxException, ParseException {
  Card assignedCard=cardService.createCard(""String_Node_Str"",col.getId(),new Date(),user);
  cardDataService.updateDescription(assignedCard.getId(),""String_Node_Str"",new Date(),user.getId());
  Card watchedCard=cardService.createCard(""String_Node_Str"",col.getId(),new Date(),user);
  Date now=new Date();
  CardLabel assigned=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",LabelDomain.SYSTEM);
  labelService.addLabelValueToCard(assigned,assignedCard.getId(),new CardLabelValue.LabelValue(user.getId()),user,now);
  CardLabel watched=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",LabelDomain.SYSTEM);
  labelService.addLabelValueToCard(watched,watchedCard.getId(),new CardLabelValue.LabelValue(user.getId()),user,now);
  CardLabel dueDate=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",LabelDomain.SYSTEM);
  labelService.addLabelValueToCard(dueDate,assignedCard.getId(),new CardLabelValue.LabelValue(now),user,now);
  labelService.addLabelValueToCard(dueDate,watchedCard.getId(),new CardLabelValue.LabelValue(now),user,now);
  UserWithPermission uwpGlobalRead=new UserWithPermission(user,EnumSet.of(Permission.READ),Collections.<String,Set<Permission>>emptyMap(),Collections.<Integer,Set<Permission>>emptyMap());
  CalendarEvents events=calendarService.getUserCalendar(uwpGlobalRead);
  Assert.assertNotNull(events);
  Assert.assertEquals(2,events.getDailyEvents().values().iterator().next().getCards().size());
}"
55115,"public Calendar getUserCalendar(String userToken) throws URISyntaxException, ParseException {
  UserWithPermission user;
  try {
    user=findUserFromCalendarToken(userToken);
  }
 catch (  EmptyResultDataAccessException ex) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (userRepository.isCalendarFeedDisabled(user)) {
    throw new SecurityException(""String_Node_Str"");
  }
  final String utcTimeZone=TimeZones.getUtcTimeZone().getID();
  final TzId tzParam=new TzId(utcTimeZone);
  final Calendar calendar=new Calendar();
  calendar.getProperties().add(new ProdId(""String_Node_Str""));
  calendar.getProperties().add(Version.VERSION_2_0);
  calendar.getProperties().add(CalScale.GREGORIAN);
  calendar.getProperties().add(Method.PUBLISH);
  final String applicationUrl=StringUtils.appendIfMissing(configurationRepository.getValue(Key.BASE_APPLICATION_URL),""String_Node_Str"");
  final List<VEvent> events=new ArrayList<>();
  final SimpleDateFormat releaseDateFormatter=new SimpleDateFormat(""String_Node_Str"");
  List<Project> projects=projectService.findAllProjects(user);
  for (  Project project : projects) {
    CardLabel milestoneLabel=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",CardLabel.LabelDomain.SYSTEM);
    Url mUrl=new Url(new URI(String.format(""String_Node_Str"",applicationUrl,project.getShortName())));
    for (    LabelListValueWithMetadata m : cardLabelRepository.findListValuesByLabelId(milestoneLabel.getId())) {
      if (m.getMetadata().containsKey(""String_Node_Str"")) {
        java.util.Date date=releaseDateFormatter.parse(m.getMetadata().get(""String_Node_Str"") + ""String_Node_Str"");
        SearchFilter filter=filter(SearchFilter.FilterType.MILESTONE,SearchFilter.ValueType.STRING,m.getValue());
        SearchFilter notTrashFilter=filter(SearchFilter.FilterType.NOTLOCATION,SearchFilter.ValueType.STRING,BoardColumn.BoardColumnLocation.TRASH.toString());
        SearchResults cards=searchService.find(Arrays.asList(filter,notTrashFilter),project.getId(),null,user);
        double closed=0;
        double total=0;
        StringBuilder descBuilder=new StringBuilder();
        for (        CardFullWithCounts card : cards.getFound()) {
          if (card.getColumnDefinition() == ColumnDefinition.CLOSED) {
            closed++;
          }
          total++;
          descBuilder.append(getEventName(card));
          descBuilder.append(""String_Node_Str"");
        }
        final String name=String.format(""String_Node_Str"",project.getShortName(),m.getValue(),total > 0 ? 100 * closed / total : 100);
        final VEvent event=new VEvent(new Date(date.getTime()),name);
        event.getProperties().add(new Description(descBuilder.toString()));
        final UUID id=new UUID(getLong(m.getCardLabelId(),m.getId()),getLong(m.getOrder(),0));
        event.getProperties().add(new Uid(id.toString()));
        if (!m.getMetadata().containsKey(""String_Node_Str"") || m.getMetadata().get(""String_Node_Str"").equals(""String_Node_Str"")) {
          final VAlarm reminder=new VAlarm(new Dur(0,0,0,0));
          reminder.getProperties().add(Action.DISPLAY);
          reminder.getProperties().add(new Description(name));
          event.getAlarms().add(reminder);
        }
        event.getProperties().getProperty(Property.DTSTART).getParameters().add(tzParam);
        event.getProperties().add(mUrl);
        events.add(event);
      }
    }
  }
  Map<Integer,UserDescription> usersCache=new HashMap<>();
  Map<Integer,CardFullWithCounts> map=new LinkedHashMap<>();
  SearchFilter locationFilter=filter(SearchFilter.FilterType.LOCATION,SearchFilter.ValueType.STRING,BoardColumn.BoardColumnLocation.BOARD.toString());
  SearchFilter aFilter=filter(SearchFilter.FilterType.ASSIGNED,SearchFilter.ValueType.CURRENT_USER,""String_Node_Str"");
  for (  CardFullWithCounts card : searchService.find(Arrays.asList(locationFilter,aFilter),null,null,user).getFound()) {
    map.put(card.getId(),card);
  }
  SearchFilter wFilter=filter(SearchFilter.FilterType.WATCHED_BY,SearchFilter.ValueType.CURRENT_USER,""String_Node_Str"");
  for (  CardFullWithCounts card : searchService.find(Arrays.asList(locationFilter,wFilter),null,null,user).getFound()) {
    map.put(card.getId(),card);
  }
  for (  CardFullWithCounts card : map.values()) {
    Url cardUrl=new Url(new URI(String.format(""String_Node_Str"",applicationUrl,card.getProjectShortName(),card.getBoardShortName(),card.getSequence())));
    CardDataHistory cardDesc=cardDataService.findLatestDescriptionByCardId(card.getId());
    for (    LabelAndValue lav : card.getLabelsWithType(LabelType.TIMESTAMP)) {
      String name=getEventName(card);
      final VEvent event=new VEvent(new Date(lav.getLabelValueTimestamp()),name);
      event.getProperties().add(new Created(new DateTime(card.getCreationDate())));
      event.getProperties().add(new LastModified(new DateTime(card.getLastUpdateTime())));
      final UUID id=new UUID(getLong(card.getColumnId(),card.getId()),getLong(lav.getLabelId(),lav.getLabelValueId()));
      event.getProperties().add(new Uid(id.toString()));
      if (card.getColumnDefinition() != ColumnDefinition.CLOSED) {
        final VAlarm reminder=new VAlarm(new Dur(0,0,0,0));
        reminder.getProperties().add(Action.DISPLAY);
        reminder.getProperties().add(new Description(name));
        event.getAlarms().add(reminder);
      }
      event.getProperties().getProperty(Property.DTSTART).getParameters().add(tzParam);
      UserDescription ud=getUserDescription(card.getCreationUser(),usersCache);
      Organizer organizer=new Organizer(URI.create(ud.getEmail()));
      organizer.getParameters().add(new Cn(ud.getName()));
      event.getProperties().add(organizer);
      event.getProperties().add(cardUrl);
      if (cardDesc != null) {
        event.getProperties().add(new Description(cardDesc.getContent()));
      }
      events.add(event);
    }
  }
  calendar.getComponents().addAll(events);
  return calendar;
}","public Calendar getUserCalendar(String userToken) throws URISyntaxException, ParseException {
  UserWithPermission user;
  try {
    user=findUserFromCalendarToken(userToken);
  }
 catch (  EmptyResultDataAccessException ex) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (userRepository.isCalendarFeedDisabled(user)) {
    throw new SecurityException(""String_Node_Str"");
  }
  final Calendar calendar=new Calendar();
  calendar.getProperties().add(new ProdId(""String_Node_Str""));
  calendar.getProperties().add(Version.VERSION_2_0);
  calendar.getProperties().add(CalScale.GREGORIAN);
  calendar.getProperties().add(Method.PUBLISH);
  final String applicationUrl=StringUtils.appendIfMissing(configurationRepository.getValue(Key.BASE_APPLICATION_URL),""String_Node_Str"");
  final List<VEvent> events=new ArrayList<>();
  final SimpleDateFormat releaseDateFormatter=new SimpleDateFormat(""String_Node_Str"");
  List<Project> projects=projectService.findAllProjects(user);
  for (  Project project : projects) {
    CardLabel milestoneLabel=cardLabelRepository.findLabelByName(project.getId(),""String_Node_Str"",CardLabel.LabelDomain.SYSTEM);
    Url mUrl=new Url(new URI(String.format(""String_Node_Str"",applicationUrl,project.getShortName())));
    for (    LabelListValueWithMetadata m : cardLabelRepository.findListValuesByLabelId(milestoneLabel.getId())) {
      if (m.getMetadata().containsKey(""String_Node_Str"")) {
        java.util.Date date=releaseDateFormatter.parse(m.getMetadata().get(""String_Node_Str"") + ""String_Node_Str"");
        SearchFilter filter=filter(SearchFilter.FilterType.MILESTONE,SearchFilter.ValueType.STRING,m.getValue());
        SearchFilter notTrashFilter=filter(SearchFilter.FilterType.NOTLOCATION,SearchFilter.ValueType.STRING,BoardColumn.BoardColumnLocation.TRASH.toString());
        SearchResults cards=searchService.find(Arrays.asList(filter,notTrashFilter),project.getId(),null,user);
        double closed=0;
        double total=0;
        StringBuilder descBuilder=new StringBuilder();
        for (        CardFullWithCounts card : cards.getFound()) {
          if (card.getColumnDefinition() == ColumnDefinition.CLOSED) {
            closed++;
          }
          total++;
          descBuilder.append(getEventName(card));
          descBuilder.append(""String_Node_Str"");
        }
        final String name=String.format(""String_Node_Str"",project.getShortName(),m.getValue(),total > 0 ? 100 * closed / total : 100);
        final VEvent event=new VEvent(new Date(date.getTime()),name);
        event.getProperties().getProperty(Property.DTSTART).getParameters().add(Value.DATE);
        event.getProperties().add(new Description(descBuilder.toString()));
        final UUID id=new UUID(getLong(m.getCardLabelId(),m.getId()),getLong(m.getOrder(),0));
        event.getProperties().add(new Uid(id.toString()));
        if (!m.getMetadata().containsKey(""String_Node_Str"") || m.getMetadata().get(""String_Node_Str"").equals(""String_Node_Str"")) {
          final VAlarm reminder=new VAlarm(new Dur(0,0,0,0));
          reminder.getProperties().add(Action.DISPLAY);
          reminder.getProperties().add(new Description(name));
          event.getAlarms().add(reminder);
        }
        event.getProperties().add(mUrl);
        events.add(event);
      }
    }
  }
  Map<Integer,UserDescription> usersCache=new HashMap<>();
  Map<Integer,CardFullWithCounts> map=new LinkedHashMap<>();
  SearchFilter locationFilter=filter(SearchFilter.FilterType.LOCATION,SearchFilter.ValueType.STRING,BoardColumn.BoardColumnLocation.BOARD.toString());
  SearchFilter aFilter=filter(SearchFilter.FilterType.ASSIGNED,SearchFilter.ValueType.CURRENT_USER,""String_Node_Str"");
  for (  CardFullWithCounts card : searchService.find(Arrays.asList(locationFilter,aFilter),null,null,user).getFound()) {
    map.put(card.getId(),card);
  }
  SearchFilter wFilter=filter(SearchFilter.FilterType.WATCHED_BY,SearchFilter.ValueType.CURRENT_USER,""String_Node_Str"");
  for (  CardFullWithCounts card : searchService.find(Arrays.asList(locationFilter,wFilter),null,null,user).getFound()) {
    map.put(card.getId(),card);
  }
  for (  CardFullWithCounts card : map.values()) {
    Url cardUrl=new Url(new URI(String.format(""String_Node_Str"",applicationUrl,card.getProjectShortName(),card.getBoardShortName(),card.getSequence())));
    CardDataHistory cardDesc=cardDataService.findLatestDescriptionByCardId(card.getId());
    for (    LabelAndValue lav : card.getLabelsWithType(LabelType.TIMESTAMP)) {
      String name=getEventName(card);
      final VEvent event=new VEvent(new Date(lav.getLabelValueTimestamp()),name);
      event.getProperties().getProperty(Property.DTSTART).getParameters().add(Value.DATE);
      event.getProperties().add(new Created(new DateTime(card.getCreationDate())));
      event.getProperties().add(new LastModified(new DateTime(card.getLastUpdateTime())));
      final UUID id=new UUID(getLong(card.getColumnId(),card.getId()),getLong(lav.getLabelId(),lav.getLabelValueId()));
      event.getProperties().add(new Uid(id.toString()));
      if (card.getColumnDefinition() != ColumnDefinition.CLOSED) {
        final VAlarm reminder=new VAlarm(new Dur(0,0,0,0));
        reminder.getProperties().add(Action.DISPLAY);
        reminder.getProperties().add(new Description(name));
        event.getAlarms().add(reminder);
      }
      UserDescription ud=getUserDescription(card.getCreationUser(),usersCache);
      Organizer organizer=new Organizer(URI.create(ud.getEmail()));
      organizer.getParameters().add(new Cn(ud.getName()));
      event.getProperties().add(organizer);
      event.getProperties().add(cardUrl);
      if (cardDesc != null) {
        event.getProperties().add(new Description(cardDesc.getContent()));
      }
      events.add(event);
    }
  }
  calendar.getComponents().addAll(events);
  return calendar;
}"
55116,"public UserPublicProfile(User user,List<EventsCount> dailyActivity,List<ProjectWithEventCounts> activeProjects,List<Event> lastWeekActivity,List<Event> latestActivityByPage){
  this.user=new User(user.getId(),user.getProvider(),user.getUsername(),null,user.getDisplayName(),user.isEnabled(),user.isEmailNotification(),user.getMemberSince(),user.isSkipOwnNotifications());
  this.activeProjects=activeProjects;
  this.dailyActivity=dailyActivity;
  this.lastWeekActivity=lastWeekActivity;
  this.latestActivityByPage=latestActivityByPage;
}","public UserPublicProfile(User user,List<EventsCount> dailyActivity,List<ProjectWithEventCounts> activeProjects,List<Event> latestActivityByPage){
  this.user=new User(user.getId(),user.getProvider(),user.getUsername(),null,user.getDisplayName(),user.isEnabled(),user.isEmailNotification(),user.getMemberSince(),user.isSkipOwnNotifications());
  this.activeProjects=activeProjects;
  this.dailyActivity=dailyActivity;
  this.latestActivityByPage=latestActivityByPage;
}"
55117,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public UserPublicProfile getUserProfile(@PathVariable(""String_Node_Str"") String provider,@PathVariable(""String_Node_Str"") String name,UserWithPermission currentUser,@RequestParam(value=""String_Node_Str"",defaultValue=""String_Node_Str"") int page){
  User user=userRepository.findUserByName(provider,name);
  final List<EventsCount> dailyActivity;
  final List<ProjectWithEventCounts> activeProjects;
  final List<Event> lastWeekActivity;
  final List<Event> activitiesByPage;
  Date lastYear=DateUtils.setDays(DateUtils.addMonths(new Date(),-11),1);
  Date lastWeek=DateUtils.addDays(new Date(),-7);
  if (currentUser.getBasePermissions().containsKey(Permission.READ)) {
    dailyActivity=eventRepository.getUserActivity(user.getId(),lastYear);
    activeProjects=projectService.findProjectsActivityByUser(user.getId());
    lastWeekActivity=eventRepository.getLatestActivity(user.getId(),lastWeek);
    activitiesByPage=eventRepository.getLatestActivityByPage(user.getId(),page);
  }
 else {
    Collection<Integer> visibleProjectsIds=currentUser.projectsIdWithPermission(Permission.READ);
    dailyActivity=eventRepository.getUserActivityForProjects(user.getId(),lastYear,visibleProjectsIds);
    activeProjects=projectService.findProjectsActivityByUserInProjects(user.getId(),visibleProjectsIds);
    lastWeekActivity=eventRepository.getLatestActivityByProjects(user.getId(),lastWeek,visibleProjectsIds);
    activitiesByPage=eventRepository.getLatestActivityByPageAndProjects(user.getId(),page,visibleProjectsIds);
  }
  return new UserPublicProfile(user,dailyActivity,activeProjects,lastWeekActivity,activitiesByPage);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public UserPublicProfile getUserProfile(@PathVariable(""String_Node_Str"") String provider,@PathVariable(""String_Node_Str"") String name,UserWithPermission currentUser,@RequestParam(value=""String_Node_Str"",defaultValue=""String_Node_Str"") int page){
  User user=userRepository.findUserByName(provider,name);
  final List<EventsCount> dailyActivity;
  final List<ProjectWithEventCounts> activeProjects;
  final List<Event> activitiesByPage;
  Date lastYear=DateUtils.setDays(DateUtils.addMonths(new Date(),-11),1);
  if (currentUser.getBasePermissions().containsKey(Permission.READ)) {
    dailyActivity=eventRepository.getUserActivity(user.getId(),lastYear);
    activeProjects=projectService.findProjectsActivityByUser(user.getId());
    activitiesByPage=eventRepository.getLatestActivityByPage(user.getId(),page);
  }
 else {
    Collection<Integer> visibleProjectsIds=currentUser.projectsIdWithPermission(Permission.READ);
    dailyActivity=eventRepository.getUserActivityForProjects(user.getId(),lastYear,visibleProjectsIds);
    activeProjects=projectService.findProjectsActivityByUserInProjects(user.getId(),visibleProjectsIds);
    activitiesByPage=eventRepository.getLatestActivityByPageAndProjects(user.getId(),page,visibleProjectsIds);
  }
  return new UserPublicProfile(user,dailyActivity,activeProjects,activitiesByPage);
}"
55118,"@ExpectPermission({Permission.ADMINISTRATION,Permission.PROJECT_ADMINISTRATION}) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public List<User> findAllUsers(){
  return userRepository.findAll();
}","@ExpectPermission(Permission.ADMINISTRATION) @RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public List<User> findAllUsers(){
  return userRepository.findAll();
}"
55119,"@Override public boolean preHandle(HttpServletRequest request,HttpServletResponse response,Object handler) throws Exception {
  ExpectPermission expectPermission=ExpectPermission.Helper.getAnnotation(handler);
  if (expectPermission == null) {
    return true;
  }
  Class<? extends OwnershipChecker> ownershipChecker=expectPermission.ownershipChecker();
  UserWithPermission user=UserSession.fetchFromRequest(request,userService);
  if (containtsOneKeyOf(user,expectPermission.value())) {
    return true;
  }
  if (NoOpOwnershipChecker.class != ownershipChecker && user.getBasePermissions().containsKey(Permission.READ) && context.getBean(expectPermission.ownershipChecker()).hasOwnership(request,user)) {
    return true;
  }
  Set<String> projectIds=extractProjectIdsFromRequestUri(request.getRequestURI(),projectService);
  if (allProjectsIdsHavePermission(projectIds,user,expectPermission.value())) {
    return true;
  }
  if (NoOpOwnershipChecker.class != ownershipChecker && allProjectsIdsHavePermission(projectIds,user,Permission.READ) && context.getBean(expectPermission.ownershipChecker()).hasOwnership(request,user)) {
    return true;
  }
  response.sendError(HttpStatus.FORBIDDEN.value());
  return false;
}","@Override public boolean preHandle(HttpServletRequest request,HttpServletResponse response,Object handler) throws Exception {
  ExpectPermission expectPermission=ExpectPermission.Helper.getAnnotation(handler);
  if (expectPermission == null) {
    return true;
  }
  Class<? extends OwnershipChecker> ownershipChecker=expectPermission.ownershipChecker();
  UserWithPermission user=UserSession.fetchFromRequest(request,userService);
  if (user.getBasePermissions().containsKey(expectPermission.value())) {
    return true;
  }
  if (NoOpOwnershipChecker.class != ownershipChecker && user.getBasePermissions().containsKey(Permission.READ) && context.getBean(expectPermission.ownershipChecker()).hasOwnership(request,user)) {
    return true;
  }
  Set<String> projectIds=extractProjectIdsFromRequestUri(request.getRequestURI(),projectService);
  if (allProjectsIdsHavePermission(projectIds,user,expectPermission.value())) {
    return true;
  }
  if (NoOpOwnershipChecker.class != ownershipChecker && allProjectsIdsHavePermission(projectIds,user,Permission.READ) && context.getBean(expectPermission.ownershipChecker()).hasOwnership(request,user)) {
    return true;
  }
  response.sendError(HttpStatus.FORBIDDEN.value());
  return false;
}"
55120,"private long calculateDelayNanosAfterWillBePossibleToConsumeForIntervalBandwidth(int bandwidthIndex,Bandwidth bandwidth,long deficit,long currentTimeNanos){
  long refillPeriodNanos=bandwidth.refillPeriodNanos;
  long refillPeriodTokens=bandwidth.refillTokens;
  long previousRefillNanos=getLastRefillTimeNanos(bandwidthIndex);
  long timeOfNextRefillNanos=previousRefillNanos + refillPeriodNanos;
  long waitForNextRefillNanos=timeOfNextRefillNanos - currentTimeNanos;
  if (deficit <= refillPeriodTokens) {
    return waitForNextRefillNanos;
  }
  deficit-=waitForNextRefillNanos;
  long deficitPeriods=deficit / refillPeriodTokens + (deficit % refillPeriodTokens == 0L ? 0 : 1);
  if (deficit < refillPeriodNanos) {
    return waitForNextRefillNanos + refillPeriodNanos;
  }
  long deficitNanos=multiplyExactOrReturnMaxValue(deficitPeriods,refillPeriodNanos) + waitForNextRefillNanos;
  if (deficitNanos <= 0) {
    return Long.MAX_VALUE;
  }
  return deficitNanos;
}","private long calculateDelayNanosAfterWillBePossibleToConsumeForIntervalBandwidth(int bandwidthIndex,Bandwidth bandwidth,long deficit,long currentTimeNanos){
  long refillPeriodNanos=bandwidth.refillPeriodNanos;
  long refillTokens=bandwidth.refillTokens;
  long previousRefillNanos=getLastRefillTimeNanos(bandwidthIndex);
  long timeOfNextRefillNanos=previousRefillNanos + refillPeriodNanos;
  long waitForNextRefillNanos=timeOfNextRefillNanos - currentTimeNanos;
  if (deficit <= refillTokens) {
    return waitForNextRefillNanos;
  }
  deficit-=refillTokens;
  if (deficit < refillTokens) {
    return waitForNextRefillNanos + refillPeriodNanos;
  }
  long deficitPeriods=deficit / refillTokens + (deficit % refillTokens == 0L ? 0 : 1);
  long deficitNanos=multiplyExactOrReturnMaxValue(deficitPeriods,refillPeriodNanos);
  if (deficitNanos == Long.MAX_VALUE) {
    return Long.MAX_VALUE;
  }
  deficitNanos+=waitForNextRefillNanos;
  if (deficitNanos < 0) {
    return Long.MAX_VALUE;
  }
  return deficitNanos;
}"
55121,"/** 
 * Creates the   {@link Refill} that does refill of tokens in of manner,it will try to add the tokens to bucket as soon as possible. For example ""of"" refill ""10 tokens per 1 second"" will add 1 token per each 100 millisecond, in other words refill will not wait 1 second to regenerate whole bunch of 10 tokens. <p> The three refills bellow do refill of tokens with same speed: <pre> <code>Refill.greedy(600, Duration.ofMinutes(1));</code> <code>Refill.greedy(10, Duration.ofSeconds(1));</code> <code>Refill.greedy(1, Duration.ofMillis(100));</code> </pre> <p> If greediness is undesired then you can specify the fixed interval refill via  {@link #intervally(long,Duration)}
 * @param tokens amount of tokens
 * @param period the period within {@code tokens} will be fully regenerated
 * @return the {@link Refill} that does refill of tokens in of manner
 */
public static Refill greedy(long tokens,Duration period){
  return new Refill(tokens,period,false);
}","/** 
 * Creates the   {@link Refill} that does refill of tokens in greedy manner,it will try to add the tokens to bucket as soon as possible. For example ""of"" refill ""10 tokens per 1 second"" will add 1 token per each 100 millisecond, in other words refill will not wait 1 second to regenerate whole bunch of 10 tokens. <p> The three refills bellow do refill of tokens with same speed: <pre> <code>Refill.greedy(600, Duration.ofMinutes(1));</code> <code>Refill.greedy(10, Duration.ofSeconds(1));</code> <code>Refill.greedy(1, Duration.ofMillis(100));</code> </pre> <p> If greediness is undesired then you can specify the fixed interval refill via  {@link #intervally(long,Duration)}
 * @param tokens amount of tokens
 * @param period the period within {@code tokens} will be fully regenerated
 * @return the {@link Refill} that does refill of tokens in of manner
 */
public static Refill greedy(long tokens,Duration period){
  return new Refill(tokens,period,false);
}"
55122,"/** 
 * Creates the   {@link Refill} that does refill of tokens in intervally manner,in opposite to ""of"" refill the ""intervally"" refill will wait until whole  {@code period} will be elapsed before regenerate {@code tokens}
 * @param tokens amount of tokens
 * @param period the period within {@code tokens} will be fully regenerated
 * @return the {@link Refill} that does refill of tokens in intervally manner
 */
public static Refill intervally(long tokens,Duration period){
  return new Refill(tokens,period,true);
}","/** 
 * Creates the   {@link Refill} that does refill of tokens in intervally manner.""Intervally"" in opposite to ""greedy""  will wait until whole  {@code period} will be elapsed before regenerate {@code tokens}
 * @param tokens amount of tokens
 * @param period the period within {@code tokens} will be fully regenerated
 * @return the {@link Refill} that does refill of tokens in intervally manner
 */
public static Refill intervally(long tokens,Duration period){
  return new Refill(tokens,period,true);
}"
55123,"public boolean isCompatible(BucketConfiguration newConfiguration){
  return bandwidths.length != newConfiguration.bandwidths.length;
}","public boolean isCompatible(BucketConfiguration newConfiguration){
  return bandwidths.length == newConfiguration.bandwidths.length;
}"
55124,"private static String generateMessage(BucketConfiguration previousConfiguration,BucketConfiguration newConfiguration){
  return MessageFormat.format(""String_Node_Str"",newConfiguration,previousConfiguration);
}","private static String generateMessage(BucketConfiguration previousConfiguration,BucketConfiguration newConfiguration){
  String format=""String_Node_Str"";
  return MessageFormat.format(format,newConfiguration,previousConfiguration);
}"
55125,"@Override protected CompletableFuture<Void> replaceConfigurationAsyncImpl(BucketConfiguration newConfiguration){
  ReplaceConfigurationOrReturnPreviousCommand replaceConfigCommand=new ReplaceConfigurationOrReturnPreviousCommand(newConfiguration);
  CompletableFuture<BucketConfiguration> result=executeAsync(replaceConfigCommand);
  return result.thenCompose(previousConfiguration -> {
    if (previousConfiguration == null) {
      return CompletableFuture.completedFuture(null);
    }
 else {
      CompletableFuture<Void> future=new CompletableFuture<>();
      future.completeExceptionally(new IncompatibleConfigurationException(newConfiguration,previousConfiguration));
      return future;
    }
  }
);
}","@Override protected CompletableFuture<Void> replaceConfigurationAsyncImpl(BucketConfiguration newConfiguration){
  ReplaceConfigurationOrReturnPreviousCommand replaceConfigCommand=new ReplaceConfigurationOrReturnPreviousCommand(newConfiguration);
  CompletableFuture<BucketConfiguration> result=executeAsync(replaceConfigCommand);
  return result.thenCompose(previousConfiguration -> {
    if (previousConfiguration == null) {
      return CompletableFuture.completedFuture(null);
    }
 else {
      CompletableFuture<Void> future=new CompletableFuture<>();
      future.completeExceptionally(new IncompatibleConfigurationException(previousConfiguration,newConfiguration));
      return future;
    }
  }
);
}"
55126,"@Override protected void replaceConfigurationImpl(BucketConfiguration newConfiguration){
  ReplaceConfigurationOrReturnPreviousCommand replaceConfigCommand=new ReplaceConfigurationOrReturnPreviousCommand(newConfiguration);
  BucketConfiguration previousConfiguration=execute(replaceConfigCommand);
  if (previousConfiguration != null) {
    throw new IncompatibleConfigurationException(newConfiguration,previousConfiguration);
  }
}","@Override protected void replaceConfigurationImpl(BucketConfiguration newConfiguration){
  ReplaceConfigurationOrReturnPreviousCommand replaceConfigCommand=new ReplaceConfigurationOrReturnPreviousCommand(newConfiguration);
  BucketConfiguration previousConfiguration=execute(replaceConfigCommand);
  if (previousConfiguration != null) {
    throw new IncompatibleConfigurationException(previousConfiguration,newConfiguration);
  }
}"
55127,"@Override public BucketConfiguration execute(GridBucketState state,long currentTimeNanos){
  BucketConfiguration previousConfiguration=state.replaceConfigurationOrReturnPrevious(newConfiguration);
  if (previousConfiguration != null) {
    return previousConfiguration;
  }
  state.refillAllBandwidth(currentTimeNanos);
  replaced=true;
  return null;
}","@Override public BucketConfiguration execute(GridBucketState state,long currentTimeNanos){
  state.refillAllBandwidth(currentTimeNanos);
  BucketConfiguration previousConfiguration=state.replaceConfigurationOrReturnPrevious(newConfiguration);
  if (previousConfiguration != null) {
    return previousConfiguration;
  }
  replaced=true;
  return null;
}"
55128,"@Override protected void replaceConfigurationImpl(BucketConfiguration newConfiguration){
  StateWithConfiguration previousState=stateReference.get();
  StateWithConfiguration newState=previousState.copy();
  long currentTimeNanos=timeMeter.currentTimeNanos();
  while (true) {
    previousState.configuration.checkCompatibility(newConfiguration);
    newState.configuration=newConfiguration;
    newState.refillAllBandwidth(currentTimeNanos);
    if (stateReference.compareAndSet(previousState,newState)) {
      return;
    }
 else {
      previousState=stateReference.get();
      newState.copyStateFrom(previousState);
    }
  }
}","@Override protected void replaceConfigurationImpl(BucketConfiguration newConfiguration){
  StateWithConfiguration previousState=stateReference.get();
  StateWithConfiguration newState=previousState.copy();
  long currentTimeNanos=timeMeter.currentTimeNanos();
  while (true) {
    previousState.configuration.checkCompatibility(newConfiguration);
    newState.refillAllBandwidth(currentTimeNanos);
    newState.configuration=newConfiguration;
    if (stateReference.compareAndSet(previousState,newState)) {
      return;
    }
 else {
      previousState=stateReference.get();
      newState.copyStateFrom(previousState);
    }
  }
}"
55129,"@Override protected void replaceConfigurationImpl(BucketConfiguration newConfiguration){
  long currentTimeNanos=timeMeter.currentTimeNanos();
  lock.lock();
  try {
    configuration.checkCompatibility(newConfiguration);
    this.configuration=newConfiguration;
    this.bandwidths=newConfiguration.getBandwidths();
    this.state.refillAllBandwidth(bandwidths,currentTimeNanos);
  }
  finally {
    lock.unlock();
  }
}","@Override protected void replaceConfigurationImpl(BucketConfiguration newConfiguration){
  long currentTimeNanos=timeMeter.currentTimeNanos();
  lock.lock();
  try {
    configuration.checkCompatibility(newConfiguration);
    this.state.refillAllBandwidth(bandwidths,currentTimeNanos);
    this.configuration=newConfiguration;
    this.bandwidths=newConfiguration.getBandwidths();
  }
  finally {
    lock.unlock();
  }
}"
55130,"public AbstractBucket(){
  asyncView=new AsyncBucket(){
    @Override public CompletableFuture<Boolean> tryConsume(    long tokensToConsume){
      checkTokensToConsume(tokensToConsume);
      return tryConsumeAsyncImpl(tokensToConsume);
    }
    @Override public CompletableFuture<ConsumptionProbe> tryConsumeAndReturnRemaining(    long tokensToConsume){
      checkTokensToConsume(tokensToConsume);
      return tryConsumeAndReturnRemainingTokensAsyncImpl(tokensToConsume);
    }
    @Override public CompletableFuture<Long> tryConsumeAsMuchAsPossible(){
      return tryConsumeAsMuchAsPossibleAsyncImpl(Long.MAX_VALUE);
    }
    @Override public CompletableFuture<Long> tryConsumeAsMuchAsPossible(    long limit){
      checkTokensToConsume(limit);
      return tryConsumeAsMuchAsPossibleAsyncImpl(limit);
    }
    @Override public CompletableFuture<Boolean> consume(    long tokensToConsume,    long maxWaitTimeNanos,    ScheduledExecutorService scheduler) throws InterruptedException {
      checkTokensToConsume(tokensToConsume);
      checkMaxWaitTime(maxWaitTimeNanos);
      CompletableFuture<Boolean> resultFuture=new CompletableFuture<>();
      CompletableFuture<Long> reservationFuture=reserveAndCalculateTimeToSleepAsyncImpl(tokensToConsume,maxWaitTimeNanos);
      reservationFuture.whenComplete((nanosToSleep,exception) -> {
        if (exception != null) {
          resultFuture.completeExceptionally(exception);
          return;
        }
        if (nanosToSleep == Long.MAX_VALUE) {
          resultFuture.complete(false);
        }
        if (nanosToSleep == 0L) {
          resultFuture.complete(true);
        }
        try {
          Runnable delayedComplection=() -> resultFuture.complete(true);
          scheduler.schedule(delayedComplection,nanosToSleep,TimeUnit.NANOSECONDS);
        }
 catch (        Throwable t) {
          resultFuture.completeExceptionally(t);
        }
      }
);
      return resultFuture;
    }
    @Override public CompletableFuture<Void> consume(    long tokensToConsume,    ScheduledExecutorService scheduler) throws InterruptedException {
      return consume(tokensToConsume,UNSPECIFIED_WAITING_LIMIT,scheduler).thenApply(bool -> null);
    }
    @Override public CompletableFuture<Void> addTokens(    long tokensToAdd){
      checkTokensToAdd(tokensToAdd);
      return addTokensAsyncImpl(tokensToAdd);
    }
  }
;
}","public AbstractBucket(){
  asyncView=new AsyncBucket(){
    @Override public CompletableFuture<Boolean> tryConsume(    long tokensToConsume){
      checkTokensToConsume(tokensToConsume);
      return tryConsumeAsyncImpl(tokensToConsume);
    }
    @Override public CompletableFuture<ConsumptionProbe> tryConsumeAndReturnRemaining(    long tokensToConsume){
      checkTokensToConsume(tokensToConsume);
      return tryConsumeAndReturnRemainingTokensAsyncImpl(tokensToConsume);
    }
    @Override public CompletableFuture<Long> tryConsumeAsMuchAsPossible(){
      return tryConsumeAsMuchAsPossibleAsyncImpl(Long.MAX_VALUE);
    }
    @Override public CompletableFuture<Long> tryConsumeAsMuchAsPossible(    long limit){
      checkTokensToConsume(limit);
      return tryConsumeAsMuchAsPossibleAsyncImpl(limit);
    }
    @Override public CompletableFuture<Boolean> consume(    long tokensToConsume,    long maxWaitTimeNanos,    ScheduledExecutorService scheduler) throws InterruptedException {
      return consumeImpl(tokensToConsume,maxWaitTimeNanos,true,scheduler);
    }
    @Override public CompletableFuture<Void> consume(    long tokensToConsume,    ScheduledExecutorService scheduler) throws InterruptedException {
      return consumeImpl(tokensToConsume,UNSPECIFIED_WAITING_LIMIT,false,scheduler).thenApply(bool -> null);
    }
    @Override public CompletableFuture<Void> addTokens(    long tokensToAdd){
      checkTokensToAdd(tokensToAdd);
      return addTokensAsyncImpl(tokensToAdd);
    }
    private CompletableFuture<Boolean> consumeImpl(    long tokensToConsume,    long maxWaitTimeNanos,    boolean limitedWaiting,    ScheduledExecutorService scheduler){
      if (limitedWaiting) {
        checkMaxWaitTime(maxWaitTimeNanos);
      }
      checkTokensToConsume(tokensToConsume);
      CompletableFuture<Boolean> resultFuture=new CompletableFuture<>();
      CompletableFuture<Long> reservationFuture=reserveAndCalculateTimeToSleepAsyncImpl(tokensToConsume,maxWaitTimeNanos);
      reservationFuture.whenComplete((nanosToSleep,exception) -> {
        if (exception != null) {
          resultFuture.completeExceptionally(exception);
          return;
        }
        if (nanosToSleep == Long.MAX_VALUE) {
          resultFuture.complete(false);
          return;
        }
        if (nanosToSleep == 0L) {
          resultFuture.complete(true);
          return;
        }
        try {
          Runnable delayedCompletion=() -> resultFuture.complete(true);
          scheduler.schedule(delayedCompletion,nanosToSleep,TimeUnit.NANOSECONDS);
        }
 catch (        Throwable t) {
          resultFuture.completeExceptionally(t);
        }
      }
);
      return resultFuture;
    }
  }
;
}"
55131,"@Override public boolean consume(long tokensToConsume,long maxWaitTimeNanos,BlockingStrategy blockingStrategy) throws InterruptedException {
  checkTokensToConsume(tokensToConsume);
  checkMaxWaitTime(maxWaitTimeNanos);
  long nanosToSleep=reserveAndCalculateTimeToSleepImpl(tokensToConsume,maxWaitTimeNanos);
  if (nanosToSleep == Long.MAX_VALUE) {
    return false;
  }
  if (nanosToSleep > 0L) {
    blockingStrategy.park(nanosToSleep);
  }
  return true;
}","@Override public boolean consume(long tokensToConsume,long maxWaitTimeNanos,BlockingStrategy blockingStrategy) throws InterruptedException {
  return consumeImpl(tokensToConsume,maxWaitTimeNanos,true,blockingStrategy);
}"
55132,"@Override public boolean consumeUninterruptibly(long tokensToConsume,long maxWaitTimeNanos,BlockingStrategy blockingStrategy){
  checkTokensToConsume(tokensToConsume);
  checkMaxWaitTime(maxWaitTimeNanos);
  long nanosToSleep=reserveAndCalculateTimeToSleepImpl(tokensToConsume,maxWaitTimeNanos);
  if (nanosToSleep == Long.MAX_VALUE) {
    return false;
  }
  if (nanosToSleep > 0L) {
    blockingStrategy.parkUninterruptibly(nanosToSleep);
  }
  return true;
}","@Override public boolean consumeUninterruptibly(long tokensToConsume,long maxWaitTimeNanos,BlockingStrategy blockingStrategy){
  return consumeUninterruptiblyImpl(tokensToConsume,maxWaitTimeNanos,true,blockingStrategy);
}"
55133,"/** 
 * Consumes multiple tokens from the bucket.  If enough tokens are not currently available then this method will block until
 * @param numTokens The number of tokens to consume from teh bucket, must be a positive number.
 */
public void consume(long numTokens){
  while (true) {
    if (tryConsume(numTokens)) {
      break;
    }
    sleepStrategy.sleep();
  }
}","/** 
 * Consumes multiple tokens from the bucket.  If enough tokens are not currently available then this method will block until
 * @param numTokens The number of tokens to consume from teh bucket, must be a positive number.
 */
void consume(long numTokens);"
55134,"/** 
 * Attempt to consume a specified number of tokens from the bucket.  If the tokens were consumed then   {@code true}is returned, otherwise   {@code false} is returned.
 * @param numTokens The number of tokens to consume from the bucket, must be a positive number.
 * @return {@code true} if the tokens were consumed, {@code false} otherwise.
 */
public synchronized boolean tryConsume(long numTokens){
  checkArgument(numTokens > 0,""String_Node_Str"");
  checkArgument(numTokens <= capacity,""String_Node_Str"");
  long newTokens=Math.max(0,refillStrategy.refill());
  this.size=Math.max(0,Math.min(this.size + newTokens,capacity));
  if (numTokens <= this.size) {
    this.size-=numTokens;
    return true;
  }
  return false;
}","/** 
 * Attempt to consume a specified number of tokens from the bucket.  If the tokens were consumed then   {@code true}is returned, otherwise   {@code false} is returned.
 * @param numTokens The number of tokens to consume from the bucket, must be a positive number.
 * @return {@code true} if the tokens were consumed, {@code false} otherwise.
 */
boolean tryConsume(long numTokens);"
55135,"/** 
 * Construct a token bucket that uses a fixed interval refill strategy.  Initially the bucket will start with  {@code capacityTokens} tokens in it, and every {@code period} time units {@code refillTokens} will be added toit.  The tokens are added all at one time on the interval boundaries.  By default the system clock is used for keeping time.
 * @deprecated Use {@link org.isomorphism.util.TokenBuckets.Builder} instead.
 */
public static TokenBucket newFixedIntervalRefill(long capacityTokens,long refillTokens,long period,TimeUnit unit){
  return builder().withCapacity(capacityTokens).withYieldingSleepStrategy().withFixedIntervalRefillStrategy(refillTokens,period,unit).build();
}","/** 
 * Construct a token bucket that uses a fixed interval refill strategy.  Initially the bucket will start with  {@code capacityTokens} tokens in it, and every {@code period} time units {@code refillTokens} will be added toit.  The tokens are added all at one time on the interval boundaries.  By default the system clock is used for keeping time.
 * @deprecated Use {@link org.isomorphism.util.TokenBuckets.Builder} instead.
 */
public static TokenBucketImpl newFixedIntervalRefill(long capacityTokens,long refillTokens,long period,TimeUnit unit){
  return builder().withCapacity(capacityTokens).withYieldingSleepStrategy().withFixedIntervalRefillStrategy(refillTokens,period,unit).build();
}"
55136,"/** 
 * Build the token bucket. 
 */
public TokenBucket build(){
  checkNotNull(capacity,""String_Node_Str"");
  checkNotNull(refillStrategy,""String_Node_Str"");
  return new TokenBucket(capacity,refillStrategy,sleepStrategy);
}","/** 
 * Build the token bucket. 
 */
public TokenBucketImpl build(){
  checkNotNull(capacity,""String_Node_Str"");
  checkNotNull(refillStrategy,""String_Node_Str"");
  return new TokenBucketImpl(capacity,refillStrategy,sleepStrategy);
}"
55137,"public static Path exportSubgraphToHDFS(GraphDatabaseService db) throws IOException, URISyntaxException {
  FileSystem fs=FileUtil.getHadoopFileSystem();
  Path pt=new Path(ConfigurationLoader.getInstance().getHadoopHdfsUri() + EDGE_LIST_RELATIVE_FILE_PATH);
  BufferedWriter br=new BufferedWriter(new OutputStreamWriter(fs.create(pt)));
  Transaction tx=db.beginTx();
  Iterable<Node> nodes=GlobalGraphOperations.at(db).getAllNodes();
  br.write(""String_Node_Str"" + ""String_Node_Str"");
  int nodeTotal=IteratorUtil.count(nodes);
  final int[] nodeCount={0};
  final int[] pathCount={0};
  int pathCountBlocks=10000;
  int size=IteratorUtil.count(nodes.iterator());
  nodes.iterator().forEachRemaining(n -> {
    Iterable<org.neo4j.graphdb.Path> nPaths=db.traversalDescription().depthFirst().relationships(withName(ConfigurationLoader.getInstance().getMazerunnerRelationshipType()),Direction.OUTGOING).evaluator(Evaluators.fromDepth(1)).evaluator(Evaluators.toDepth(1)).traverse(n);
    for (    org.neo4j.graphdb.Path path : nPaths) {
      try {
        String line=path.startNode().getId() + ""String_Node_Str"" + path.endNode().getId();
        br.write(line + ""String_Node_Str"");
        pathCount[0]++;
        if (pathCount[0] > pathCountBlocks) {
          pathCount[0]=0;
          System.out.println(""String_Node_Str"" + MessageFormat.format(""String_Node_Str"",((double)nodeCount[0] / (double)nodeTotal)));
        }
      }
 catch (      Exception ex) {
        System.out.println(ex.getMessage());
      }
    }
    nodeCount[0]++;
  }
);
  System.out.println(""String_Node_Str"" + MessageFormat.format(""String_Node_Str"",1.0));
  br.flush();
  br.close();
  tx.success();
  tx.close();
  return pt;
}","public static Path exportSubgraphToHDFS(GraphDatabaseService db) throws IOException, URISyntaxException {
  FileSystem fs=FileUtil.getHadoopFileSystem();
  Path pt=new Path(ConfigurationLoader.getInstance().getHadoopHdfsUri() + EDGE_LIST_RELATIVE_FILE_PATH.replace(""String_Node_Str"",""String_Node_Str""));
  BufferedWriter br=new BufferedWriter(new OutputStreamWriter(fs.create(pt)));
  Transaction tx=db.beginTx();
  Iterable<Node> nodes=GlobalGraphOperations.at(db).getAllNodes();
  br.write(""String_Node_Str"" + ""String_Node_Str"");
  int nodeTotal=IteratorUtil.count(nodes);
  final int[] nodeCount={0};
  final int[] pathCount={0};
  int pathCountBlocks=10000;
  int size=IteratorUtil.count(nodes.iterator());
  nodes.iterator().forEachRemaining(n -> {
    Iterable<org.neo4j.graphdb.Path> nPaths=db.traversalDescription().depthFirst().relationships(withName(ConfigurationLoader.getInstance().getMazerunnerRelationshipType()),Direction.OUTGOING).evaluator(Evaluators.fromDepth(1)).evaluator(Evaluators.toDepth(1)).traverse(n);
    for (    org.neo4j.graphdb.Path path : nPaths) {
      try {
        String line=path.startNode().getId() + ""String_Node_Str"" + path.endNode().getId();
        br.write(line + ""String_Node_Str"");
        pathCount[0]++;
        if (pathCount[0] > pathCountBlocks) {
          pathCount[0]=0;
          System.out.println(""String_Node_Str"" + MessageFormat.format(""String_Node_Str"",((double)nodeCount[0] / (double)nodeTotal)));
        }
      }
 catch (      Exception ex) {
        System.out.println(ex.getMessage());
      }
    }
    nodeCount[0]++;
  }
);
  System.out.println(""String_Node_Str"" + MessageFormat.format(""String_Node_Str"",1.0));
  br.flush();
  br.close();
  tx.success();
  tx.close();
  return pt;
}"
55138,"public static void writeBlockForNode(Node n,GraphDatabaseService db,BufferedWriter bufferedWriter,int reportBlockSize,String relationshipType) throws IOException {
  Iterator<Relationship> rels=n.getRelationships(withName(relationshipType),Direction.OUTGOING).iterator();
  while (rels.hasNext()) {
    try {
      Relationship rel=rels.next();
      String line=rel.getStartNode().getId() + ""String_Node_Str"" + rel.getEndNode().getId();
      bufferedWriter.write(line + ""String_Node_Str"");
      Writer.counter++;
      if (Writer.counter % reportBlockSize == 0) {
        System.out.println(""String_Node_Str"" + Writer.counter);
      }
    }
 catch (    Exception ex) {
      System.out.println(ex.getMessage());
    }
  }
}","public static void writeBlockForNode(Node n,GraphDatabaseService db,BufferedWriter bufferedWriter,int reportBlockSize,String relationshipType) throws IOException {
  Transaction tx=((GraphDatabaseAPI)db).tx().unforced().begin();
  Iterator<Relationship> rels=n.getRelationships(withName(relationshipType),Direction.OUTGOING).iterator();
  while (rels.hasNext()) {
    try {
      Relationship rel=rels.next();
      String line=rel.getStartNode().getId() + ""String_Node_Str"" + rel.getEndNode().getId();
      bufferedWriter.write(line + ""String_Node_Str"");
      Writer.counter++;
      if (Writer.counter % reportBlockSize == 0) {
        System.out.println(""String_Node_Str"" + Writer.counter);
      }
    }
 catch (    Exception ex) {
      System.out.println(ex.getMessage());
    }
  }
}"
55139,"public static Path exportSubgraphToHDFSParallel(GraphDatabaseService db) throws IOException, URISyntaxException {
  FileSystem fs=FileUtil.getHadoopFileSystem();
  Path pt=new Path(ConfigurationLoader.getInstance().getHadoopHdfsUri() + EDGE_LIST_RELATIVE_FILE_PATH);
  BufferedWriter br=new BufferedWriter(new OutputStreamWriter(fs.create(pt)));
  Integer reportBlockSize=20000;
  Transaction tx=db.beginTx();
  Iterable<Node> nodes=GlobalGraphOperations.at(db).getAllNodes();
  br.write(""String_Node_Str"" + ""String_Node_Str"");
  List<Spliterator<Node>> spliteratorList=new ArrayList<>();
  boolean hasSpliterator=true;
  Spliterator<Node> nodeSpliterator=nodes.spliterator();
  while (hasSpliterator) {
    Spliterator<Node> localSpliterator=nodeSpliterator.trySplit();
    hasSpliterator=localSpliterator != null;
    if (hasSpliterator)     spliteratorList.add(localSpliterator);
  }
  tx.success();
  tx.close();
  counter=0;
  if (spliteratorList.size() > 4) {
    ParallelWriter parallelWriter=new ParallelWriter(spliteratorList.toArray(new Spliterator[spliteratorList.size()]),0,spliteratorList.size(),db,br,spliteratorList.size(),reportBlockSize,ConfigurationLoader.getInstance().getMazerunnerRelationshipType());
    ForkJoinPool pool=new ForkJoinPool();
    pool.invoke(parallelWriter);
  }
 else {
    spliteratorList.forEach(sl -> sl.forEachRemaining(n -> {
      try {
        writeBlockForNode(n,db,br,reportBlockSize,ConfigurationLoader.getInstance().getMazerunnerRelationshipType());
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
));
  }
  System.out.println(""String_Node_Str"" + MessageFormat.format(""String_Node_Str"",1.0));
  br.flush();
  br.close();
  return pt;
}","public static Path exportSubgraphToHDFSParallel(GraphDatabaseService db) throws IOException, URISyntaxException {
  FileSystem fs=FileUtil.getHadoopFileSystem();
  Path pt=new Path(ConfigurationLoader.getInstance().getHadoopHdfsUri() + EDGE_LIST_RELATIVE_FILE_PATH.replace(""String_Node_Str"",""String_Node_Str""));
  BufferedWriter br=new BufferedWriter(new OutputStreamWriter(fs.create(pt)));
  Integer reportBlockSize=20000;
  Transaction tx=db.beginTx();
  Iterable<Node> nodes=GlobalGraphOperations.at(db).getAllNodes();
  br.write(""String_Node_Str"" + ""String_Node_Str"");
  List<Spliterator<Node>> spliteratorList=new ArrayList<>();
  boolean hasSpliterator=true;
  Spliterator<Node> nodeSpliterator=nodes.spliterator();
  while (hasSpliterator) {
    Spliterator<Node> localSpliterator=nodeSpliterator.trySplit();
    hasSpliterator=localSpliterator != null;
    if (hasSpliterator)     spliteratorList.add(localSpliterator);
  }
  tx.success();
  tx.close();
  counter=0;
  if (spliteratorList.size() > 4) {
    ParallelWriter parallelWriter=new ParallelWriter(spliteratorList.toArray(new Spliterator[spliteratorList.size()]),0,spliteratorList.size(),db,br,spliteratorList.size(),reportBlockSize,ConfigurationLoader.getInstance().getMazerunnerRelationshipType());
    ForkJoinPool pool=new ForkJoinPool();
    pool.invoke(parallelWriter);
  }
 else {
    spliteratorList.forEach(sl -> sl.forEachRemaining(n -> {
      try {
        writeBlockForNode(n,db,br,reportBlockSize,ConfigurationLoader.getInstance().getMazerunnerRelationshipType());
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
));
  }
  System.out.println(""String_Node_Str"" + MessageFormat.format(""String_Node_Str"",1.0));
  br.flush();
  br.close();
  return pt;
}"
55140,"@Override protected Boolean doInBackground(View... views){
  final View poem=views[0];
  boolean result=false;
  if (App.isExternalStorageWritable()) {
    final Bitmap bitmap=Bitmap.createBitmap(getResources().getDimensionPixelSize(R.dimen.share_width_px),getResources().getDimensionPixelSize(R.dimen.share_height_px),Bitmap.Config.ARGB_8888);
    final Canvas canvas=new Canvas(bitmap);
    poem.draw(canvas);
    final File picFile=App.getPoemFile(""String_Node_Str"" + poem.getTag() + ""String_Node_Str"");
    try {
      picFile.createNewFile();
      final FileOutputStream picOut=new FileOutputStream(picFile);
      final boolean saved=bitmap.compress(Bitmap.CompressFormat.JPEG,90,picOut);
      if (saved) {
        final CharSequence hashtag=((TextView)poem.findViewById(R.id.poem_theme)).getText();
        final Uri imageUri=Uri.parse(picFile.getAbsolutePath());
        final TweetComposer.Builder builder=new TweetComposer.Builder(PoemHistoryActivity.this).text(getApplicationContext().getResources().getString(R.string.share_poem_tweet_text) + ""String_Node_Str"" + hashtag).image(imageUri);
        builder.show();
        result=true;
      }
 else {
        Crashlytics.log(Log.ERROR,TAG,""String_Node_Str"");
        Toast.makeText(getApplicationContext(),getResources().getString(R.string.toast_share_error),Toast.LENGTH_SHORT).show();
      }
      picOut.close();
    }
 catch (    IOException e) {
      Toast.makeText(getApplicationContext(),getResources().getString(R.string.toast_share_error),Toast.LENGTH_SHORT).show();
      Crashlytics.logException(e);
      e.printStackTrace();
    }
    poem.destroyDrawingCache();
  }
 else {
    Toast.makeText(getApplicationContext(),getResources().getString(R.string.toast_share_error),Toast.LENGTH_SHORT).show();
    Crashlytics.log(Log.ERROR,TAG,""String_Node_Str"");
  }
  return result;
}","@Override protected Boolean doInBackground(View... views){
  final View poem=views[0];
  boolean result=false;
  if (App.isExternalStorageWritable()) {
    final Bitmap bitmap=Bitmap.createBitmap(getResources().getDimensionPixelSize(R.dimen.share_width_px),getResources().getDimensionPixelSize(R.dimen.share_height_px),Bitmap.Config.ARGB_8888);
    final Canvas canvas=new Canvas(bitmap);
    poem.draw(canvas);
    final File picFile=App.getPoemFile(""String_Node_Str"" + poem.getTag() + ""String_Node_Str"");
    try {
      picFile.createNewFile();
      final FileOutputStream picOut=new FileOutputStream(picFile);
      final boolean saved=bitmap.compress(Bitmap.CompressFormat.JPEG,90,picOut);
      if (saved) {
        final CharSequence hashtag=((TextView)poem.findViewById(R.id.poem_theme)).getText();
        final Uri imageUri=Uri.fromFile(picFile);
        final TweetComposer.Builder builder=new TweetComposer.Builder(PoemHistoryActivity.this).text(getApplicationContext().getResources().getString(R.string.share_poem_tweet_text) + ""String_Node_Str"" + hashtag).image(imageUri);
        builder.show();
        result=true;
      }
 else {
        Crashlytics.log(Log.ERROR,TAG,""String_Node_Str"");
        Toast.makeText(getApplicationContext(),getResources().getString(R.string.toast_share_error),Toast.LENGTH_SHORT).show();
      }
      picOut.close();
    }
 catch (    IOException e) {
      Toast.makeText(getApplicationContext(),getResources().getString(R.string.toast_share_error),Toast.LENGTH_SHORT).show();
      Crashlytics.logException(e);
      e.printStackTrace();
    }
    poem.destroyDrawingCache();
  }
 else {
    Toast.makeText(getApplicationContext(),getResources().getString(R.string.toast_share_error),Toast.LENGTH_SHORT).show();
    Crashlytics.log(Log.ERROR,TAG,""String_Node_Str"");
  }
  return result;
}"
55141,"@Override public long hashShort(short input){
  input=NATIVE_XX.toLittleEndian(input);
  long hash=seed() + P5 + 2;
  hash^=(input & 0xFF) * P5;
  hash=Long.rotateLeft(hash,11) * P1;
  hash^=(input >> 8 & 0xFF) * P5;
  hash=Long.rotateLeft(hash,11) * P1;
  return XxHash_r39.finalize(hash);
}","@Override public long hashShort(short input){
  input=NATIVE_XX.toLittleEndian(input);
  long hash=seed() + P5 + 2;
  hash^=Primitives.unsignedByte(input) * P5;
  hash=Long.rotateLeft(hash,11) * P1;
  hash^=Primitives.unsignedByte(input >> 8) * P5;
  hash=Long.rotateLeft(hash,11) * P1;
  return XxHash_r39.finalize(hash);
}"
55142,"@Override public long hashInt(int input){
  input=NATIVE_XX.toLittleEndian(input);
  long hash=seed() + P5 + 4;
  hash^=input * P1;
  hash=Long.rotateLeft(hash,23) * P2 + P3;
  return XxHash_r39.finalize(hash);
}","@Override public long hashInt(int input){
  input=NATIVE_XX.toLittleEndian(input);
  long hash=seed() + P5 + 4;
  hash^=Primitives.unsignedInt(input) * P1;
  hash=Long.rotateLeft(hash,23) * P2 + P3;
  return XxHash_r39.finalize(hash);
}"
55143,"@Override public long hashByte(byte input){
  long hash=seed() + P5 + 1;
  hash^=input * P5;
  hash=Long.rotateLeft(hash,11) * P1;
  return XxHash_r39.finalize(hash);
}","@Override public long hashByte(byte input){
  long hash=seed() + P5 + 1;
  hash^=Primitives.unsignedByte(input) * P5;
  hash=Long.rotateLeft(hash,11) * P1;
  return XxHash_r39.finalize(hash);
}"
55144,"public static void test(LongHashFunction f,byte[] data,long eh){
  int len=data.length;
  testVoid(f,eh,len);
  testBoolean(f,len);
  ByteBuffer bb=ByteBuffer.wrap(data).order(nativeOrder());
  testPrimitives(f,eh,len,bb);
  testArrays(f,data,eh,len,bb);
  testByteBuffers(f,eh,len,bb);
  testCharSequences(f,eh,len,bb);
  testMemory(f,eh,len,bb);
}","public static void test(LongHashFunction f,byte[] data,long eh){
  int len=data.length;
  testVoid(f,eh,len);
  testBoolean(f,len);
  ByteBuffer bb=ByteBuffer.wrap(data).order(nativeOrder());
  testPrimitives(f,eh,len,bb);
  testNegativePrimitives(f);
  testArrays(f,data,eh,len,bb);
  testByteBuffers(f,eh,len,bb);
  testCharSequences(f,eh,len,bb);
  testMemory(f,eh,len,bb);
}"
55145,"@Override public long hashShort(short input){
  int unsignedInput=Primitives.unsignedShort(NATIVE_CITY.toLittleEndian(input));
  int firstByte=Primitives.unsignedByte(unsignedInput);
  int secondByte=unsignedInput >> 8;
  long hash=hash1To3Bytes(2,firstByte,secondByte,secondByte);
  return finalize(hash);
}","@Override public long hashShort(short input){
  return hashChar((char)input);
}"
55146,"@Override public long hashChar(char input){
  return hashShort((short)input);
}","@Override public long hashChar(char input){
  int unsignedInput=(int)input;
  int firstByte=(unsignedInput >> FIRST_SHORT_BYTE_SHIFT) & FIRST_SHORT_BYTE_MASK;
  int secondByte=(unsignedInput >> SECOND_SHORT_BYTE_SHIFT) & SECOND_SHORT_BYTE_MASK;
  long hash=hash1To3Bytes(2,firstByte,secondByte,secondByte);
  return finalize(hash);
}"
55147,"private void onRead0(@NotNull DocumentContext inDc,@NotNull WireOut out,@NotNull WireIn in){
  if (!YamlLogging.showHeartBeats()) {
    prevLogMessage.setLength(0);
    prevLogMessage.append(currentLogMessage);
    currentLogMessage.setLength(0);
    logToBuffer(in,currentLogMessage,in.bytes().readPosition() - 4);
  }
  logYamlToStandardOut(in);
  if (inDc.isMetaData()) {
    this.metaDataConsumer.readMarshallable(in);
  }
 else {
    try {
      if (LOG.isDebugEnabled())       Jvm.debug().on(getClass(),""String_Node_Str"" + in.bytes().toHexString());
      @NotNull Consumer<WireType> wireTypeConsumer=wt -> {
        wireType(wt);
        checkWires(in.bytes(),out.bytes(),wireType());
      }
;
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails,getMonitoringMap(),isServerSocket,this::publisher,hostIdentifier,wireTypeConsumer,wireType());
        if (!systemHandler.wasHeartBeat()) {
          if (!YamlLogging.showHeartBeats())           logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
        }
        return;
      }
      if (!YamlLogging.showHeartBeats()) {
        logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
      }
      @Nullable Map<String,UserStat> userMonitoringMap=getMonitoringMap();
      if (userMonitoringMap != null) {
        UserStat userStat=userMonitoringMap.get(sessionDetails.userId());
        if (userStat == null) {
          throw new AssertionError(""String_Node_Str"");
        }
        userStat.setRecentInteraction(LocalTime.now());
        userStat.setTotalInteractions(userStat.getTotalInteractions() + 1);
        userMonitoringMap.put(sessionDetails.userId(),userStat);
      }
      if (wireAdapter != null) {
        if (viewType == null)         return;
        if (MapView.class.isAssignableFrom(viewType)) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (EntrySetView.class.isAssignableFrom(viewType)) {
          entrySetHandler.process(in,out,(EntrySetView)view,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (KeySetView.class.isAssignableFrom(viewType)) {
          keySetHandler.process(in,out,(KeySetView)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (MapColumnView.class.isAssignableFrom(viewType) || QueueColumnView.class.isAssignableFrom(viewType) || viewType == ColumnView.class) {
          columnViewHandler.process(in,out,(ColumnViewInternal)view,tid);
          return;
        }
        if (ColumnViewIterator.class.isAssignableFrom(viewType)) {
          columnViewIteratorHandler.process(in,out,tid,(Iterator<Row>)view,cid);
          return;
        }
        if (ValuesCollection.class.isAssignableFrom(viewType)) {
          valuesHandler.process(in,out,(ValuesCollection)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (ObjectSubscription.class.isAssignableFrom(viewType)) {
          subscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(SubscriptionCollection)view);
          return;
        }
        if (TopologySubscription.class.isAssignableFrom(viewType)) {
          topologySubscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (Reference.class.isAssignableFrom(viewType)) {
          referenceHandler.process(in,requestContext,publisher(),tid,(Reference)view,cspText,outWire,wireAdapter);
          return;
        }
        if (TopicPublisher.class.isAssignableFrom(viewType) || QueueView.class.isAssignableFrom(viewType)) {
          topicPublisherHandler.process(in,publisher(),tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (Publisher.class.isAssignableFrom(viewType)) {
          publisherHandler.process(in,requestContext,publisher(),tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (Replication.class.isAssignableFrom(viewType)) {
          replicationHandler.process(in,publisher(),tid,outWire,hostIdentifier,(Replication)view,eventLoop);
          return;
        }
        if (IndexQueueView.class.isAssignableFrom(viewType)) {
          indexQueueViewHandler.process(in,requestContext,contextAsset,publisher(),tid,outWire);
          return;
        }
        if (VaadinChart.class.isAssignableFrom(viewType)) {
          barChatHandler.process(in,out,(VaadinChart)view,tid);
        }
      }
    }
 catch (    Exception e) {
      Jvm.warn().on(getClass(),in.readingPeekYaml() + ""String_Node_Str"" + in.bytes().toDebugString(),e);
    }
 finally {
      if (sessionProvider != null)       sessionProvider.remove();
      cid=0;
    }
  }
}","private void onRead0(@NotNull DocumentContext inDc,@NotNull WireOut out,@NotNull WireIn in){
  if (!YamlLogging.showHeartBeats()) {
    prevLogMessage.setLength(0);
    prevLogMessage.append(currentLogMessage);
    currentLogMessage.setLength(0);
    logToBuffer(in,currentLogMessage,in.bytes().readPosition() - 4);
  }
  logYamlToStandardOut(in);
  if (inDc.isMetaData()) {
    this.metaDataConsumer.readMarshallable(in);
  }
 else {
    try {
      if (LOG.isDebugEnabled())       Jvm.debug().on(getClass(),""String_Node_Str"" + in.bytes().toHexString());
      @NotNull Consumer<WireType> wireTypeConsumer=wt -> {
        wireType(wt);
        checkWires(in.bytes(),out.bytes(),wireType());
      }
;
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails,getMonitoringMap(),wireTypeConsumer,wireType());
        if (!systemHandler.wasHeartBeat()) {
          if (!YamlLogging.showHeartBeats())           logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
        }
        return;
      }
      if (!YamlLogging.showHeartBeats()) {
        logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
      }
      @Nullable Map<String,UserStat> userMonitoringMap=getMonitoringMap();
      if (userMonitoringMap != null) {
        UserStat userStat=userMonitoringMap.get(sessionDetails.userId());
        if (userStat == null) {
          throw new AssertionError(""String_Node_Str"");
        }
        userStat.setRecentInteraction(LocalTime.now());
        userStat.setTotalInteractions(userStat.getTotalInteractions() + 1);
        userMonitoringMap.put(sessionDetails.userId(),userStat);
      }
      if (wireAdapter != null) {
        if (viewType == null)         return;
        if (MapView.class.isAssignableFrom(viewType)) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (EntrySetView.class.isAssignableFrom(viewType)) {
          entrySetHandler.process(in,out,(EntrySetView)view,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (KeySetView.class.isAssignableFrom(viewType)) {
          keySetHandler.process(in,out,(KeySetView)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (MapColumnView.class.isAssignableFrom(viewType) || QueueColumnView.class.isAssignableFrom(viewType) || viewType == ColumnView.class) {
          columnViewHandler.process(in,out,(ColumnViewInternal)view,tid);
          return;
        }
        if (ColumnViewIterator.class.isAssignableFrom(viewType)) {
          columnViewIteratorHandler.process(in,out,tid,(Iterator<Row>)view,cid);
          return;
        }
        if (ValuesCollection.class.isAssignableFrom(viewType)) {
          valuesHandler.process(in,out,(ValuesCollection)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (ObjectSubscription.class.isAssignableFrom(viewType)) {
          subscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(SubscriptionCollection)view);
          return;
        }
        if (TopologySubscription.class.isAssignableFrom(viewType)) {
          topologySubscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (Reference.class.isAssignableFrom(viewType)) {
          referenceHandler.process(in,requestContext,publisher(),tid,(Reference)view,cspText,outWire,wireAdapter);
          return;
        }
        if (TopicPublisher.class.isAssignableFrom(viewType) || QueueView.class.isAssignableFrom(viewType)) {
          topicPublisherHandler.process(in,publisher(),tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (Publisher.class.isAssignableFrom(viewType)) {
          publisherHandler.process(in,requestContext,publisher(),tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (Replication.class.isAssignableFrom(viewType)) {
          replicationHandler.process(in,publisher(),tid,outWire,hostIdentifier,(Replication)view,eventLoop);
          return;
        }
        if (IndexQueueView.class.isAssignableFrom(viewType)) {
          indexQueueViewHandler.process(in,requestContext,contextAsset,publisher(),tid,outWire);
          return;
        }
        if (VaadinChart.class.isAssignableFrom(viewType)) {
          barChatHandler.process(in,out,(VaadinChart)view,tid);
        }
      }
    }
 catch (    Exception e) {
      Jvm.warn().on(getClass(),in.readingPeekYaml() + ""String_Node_Str"" + in.bytes().toDebugString(),e);
    }
 finally {
      if (sessionProvider != null)       sessionProvider.remove();
      cid=0;
    }
  }
}"
55148,"private void createProxy0(String type,final StringBuilder cspBuff){
  this.cspBuff.setLength(0);
  this.cspBuff.append(requestContext.fullName());
  this.cspBuff.append(""String_Node_Str"");
  this.cspBuff.append(""String_Node_Str"").append(type);
  final Class keyType=requestContext.keyType();
  if (keyType != null)   this.cspBuff.append(""String_Node_Str"").append(keyType.getName());
  final Class valueType=requestContext.valueType();
  if (valueType != null)   this.cspBuff.append(""String_Node_Str"").append(valueType.getName());
}","private void createProxy0(String type,final StringBuilder cspBuff){
  cspBuff.setLength(0);
  cspBuff.append(requestContext.fullName());
  cspBuff.append(""String_Node_Str"");
  cspBuff.append(""String_Node_Str"").append(type);
  final Class keyType=requestContext.keyType();
  if (keyType != null)   cspBuff.append(""String_Node_Str"").append(keyType.getName());
  final Class valueType=requestContext.valueType();
  if (valueType != null)   cspBuff.append(""String_Node_Str"").append(valueType.getName());
}"
55149,"@Override public long createProxy(String type,long token){
  createProxy0(type,cspBuff);
  cspBuff.append(""String_Node_Str"").append(token);
  final long cid=acquireCid(cspBuff);
  outWire.writeEventName(reply).typePrefix(""String_Node_Str"").marshallable(w -> {
    w.writeEventName(CoreFields.csp).text(cspBuff);
    w.writeEventName(CoreFields.cid).int64(cid);
  }
);
  return cid;
}","@Override public long createProxy(String type,long token){
  final StringBuilder cspBuff=new StringBuilder();
  createProxy0(type,cspBuff);
  cspBuff.append(""String_Node_Str"").append(token);
  final long cid=acquireCid(cspBuff);
  outWire.writeEventName(reply).typePrefix(""String_Node_Str"").marshallable(w -> {
    w.writeEventName(CoreFields.csp).text(cspBuff);
    w.writeEventName(CoreFields.cid).int64(cid);
  }
);
  return cid;
}"
55150,"void process(@NotNull final WireIn inWire,@NotNull final WireOut outWire,final long tid,@NotNull final SessionDetailsProvider sessionDetails,@Nullable Map<String,UserStat> monitoringMap,boolean isServerSocket,@Nullable Supplier<WireOutPublisher> publisher,@Nullable final HostIdentifier hostId,@NotNull Consumer<WireType> onWireType,@Nullable WireType wireType0){
  this.wasHeartBeat=false;
  this.sessionDetails=sessionDetails;
  this.monitoringMap=monitoringMap;
  setOutWire(outWire);
  dataConsumer.accept(inWire,tid);
  if (wireType0 == null && sessionDetails.wireType() != null)   onWireType.accept(sessionDetails.wireType());
}","void process(@NotNull final WireIn inWire,@NotNull final WireOut outWire,final long tid,@NotNull final SessionDetailsProvider sessionDetails,@Nullable Map<String,UserStat> monitoringMap,@NotNull Consumer<WireType> onWireType,@Nullable WireType wireType0){
  this.wasHeartBeat=false;
  this.sessionDetails=sessionDetails;
  this.monitoringMap=monitoringMap;
  setOutWire(outWire);
  dataConsumer.accept(inWire,tid);
  if (wireType0 == null && sessionDetails.wireType() != null)   onWireType.accept(sessionDetails.wireType());
}"
55151,"@NotNull private WireParser<Void> wireParser(){
  @NotNull final WireParser<Void> parser=new VanillaWireParser<>((s,v,$) -> {
  }
);
  parser.register(EventId.domain::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.domain(x)));
  parser.register(EventId.sessionMode::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.sessionMode(SessionMode.valueOf(x))));
  parser.register(EventId.securityToken::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.securityToken(x)));
  parser.register(EventId.clientId::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.clientId(UUID.fromString(x))));
  parser.register(EventId.wireType::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.wireType(WireType.valueOf(x))));
  parser.register(EventId.hostId::toString,(s,v,$) -> v.int8(this,(o,x) -> o.sessionDetails.hostId(x)));
  return parser;
}","@NotNull private WireParser<Void> wireParser(){
  @NotNull final WireParser<Void> parser=new VanillaWireParser<>((s,in,out) -> {
  }
,(methodId,bytes,o) -> {
  }
);
  parser.register(EventId.domain::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.domain(x)));
  parser.register(EventId.sessionMode::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.sessionMode(SessionMode.valueOf(x))));
  parser.register(EventId.securityToken::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.securityToken(x)));
  parser.register(EventId.clientId::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.clientId(UUID.fromString(x))));
  parser.register(EventId.wireType::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.wireType(WireType.valueOf(x))));
  parser.register(EventId.hostId::toString,(s,v,$) -> v.int8(this,(o,x) -> o.sessionDetails.hostId(x)));
  return parser;
}"
55152,"default void unregisterSubscriber(@NotNull RequestContext requestContext,@NotNull Subscriber<Object> subscriber){
  @NotNull final Class<SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  @Nullable final SubscriptionCollection subscription=getView(subscriptionType);
  if (subscription == null)   subscriber.onEndOfSubscription();
 else   subscription.unregisterSubscriber(subscriber);
}","default void unregisterSubscriber(@NotNull RequestContext requestContext,@NotNull Subscriber<Object> subscriber){
  @NotNull final Class<? extends SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  @Nullable final SubscriptionCollection subscription=getView(subscriptionType);
  if (subscription == null)   subscriber.onEndOfSubscription();
 else   subscription.unregisterSubscriber(subscriber);
}"
55153,"@NotNull default SubscriptionCollection acquireSubscription(@NotNull RequestContext requestContext){
  @NotNull Class<SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  requestContext.viewType(subscriptionType);
  return acquireView(subscriptionType,requestContext);
}","@NotNull default SubscriptionCollection acquireSubscription(@NotNull RequestContext requestContext){
  @NotNull Class<? extends SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  requestContext.viewType(subscriptionType);
  return acquireView(subscriptionType,requestContext);
}"
55154,"/** 
 * Acquire the Subscription view for a URI.
 * @param requestContext to find the subscription
 * @return the Subscription
 * @throws AssetNotFoundException the view could not be constructed.
 */
@NotNull default SubscriptionCollection acquireSubscription(@NotNull RequestContext requestContext) throws AssetNotFoundException {
  @NotNull Asset asset=acquireAsset(requestContext.fullName());
  @NotNull Class<SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  requestContext.viewType(subscriptionType);
  return asset.acquireView(subscriptionType,requestContext);
}","/** 
 * Acquire the Subscription view for a URI.
 * @param requestContext to find the subscription
 * @return the Subscription
 * @throws AssetNotFoundException the view could not be constructed.
 */
@NotNull default SubscriptionCollection acquireSubscription(@NotNull RequestContext requestContext) throws AssetNotFoundException {
  @NotNull Asset asset=acquireAsset(requestContext.fullName());
  @NotNull Class<? extends SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  requestContext.viewType(subscriptionType);
  return asset.acquireView(subscriptionType,requestContext);
}"
55155,"/** 
 * Get a Subscription view for a URI if ti exists.  This is useful for unsubscribing.
 * @param requestContext to find the subscription
 * @return the Subscription
 * @throws AssetNotFoundException the view could not be constructed.
 */
@Nullable default SubscriptionCollection getSubscription(@NotNull RequestContext requestContext){
  @Nullable Asset asset=getAsset(requestContext.fullName());
  @NotNull Class<SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  requestContext.viewType(subscriptionType);
  return asset == null ? null : asset.getView(subscriptionType);
}","/** 
 * Get a Subscription view for a URI if ti exists.  This is useful for unsubscribing.
 * @param requestContext to find the subscription
 * @return the Subscription
 * @throws AssetNotFoundException the view could not be constructed.
 */
@Nullable default SubscriptionCollection getSubscription(@NotNull RequestContext requestContext){
  @Nullable Asset asset=getAsset(requestContext.fullName());
  @NotNull Class<? extends SubscriptionCollection> subscriptionType=requestContext.getSubscriptionType();
  requestContext.viewType(subscriptionType);
  return asset == null ? null : asset.getView(subscriptionType);
}"
55156,"@NotNull public WireParser<Void> getWireParser(){
  @NotNull WireParser<Void> parser=new VanillaWireParser<>((s,v,$) -> {
  }
);
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.text(this,(o,x) -> o.cluster=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.text(this,RequestContext::view));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.bootstrap=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.putReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.removeReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.nullOldValueOnUpdateEvent=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.viewType=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.endSubscriptionAfterBootstrap=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int32(this,(o,x) -> o.throttlePeriodMs=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int64(this,(o,x) -> o.entries=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int64(this,(o,x) -> o.averageValueSize=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.dontPersist=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int64(this,(o,x) -> o.token=x));
  return parser;
}","@NotNull public WireParser<Void> getWireParser(){
  @NotNull WireParser<Void> parser=new VanillaWireParser<>((s,in,out) -> {
  }
,null);
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.text(this,(o,x) -> o.cluster=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.text(this,RequestContext::view));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.bootstrap=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.putReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.removeReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.nullOldValueOnUpdateEvent=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.viewType=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.endSubscriptionAfterBootstrap=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int32(this,(o,x) -> o.throttlePeriodMs=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int64(this,(o,x) -> o.entries=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int64(this,(o,x) -> o.averageValueSize=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.bool(this,(o,x) -> o.dontPersist=x));
  parser.register(() -> ""String_Node_Str"",(s,v,$) -> v.int64(this,(o,x) -> o.token=x));
  return parser;
}"
55157,"@NotNull public Class<SubscriptionCollection> getSubscriptionType(){
  @NotNull Class elementType=elementType();
  return elementType == TopologicalEvent.class ? (Class)TopologySubscription.class : elementType == BytesStore.class ? (Class)RawKVSSubscription.class : (Class)ObjectSubscription.class;
}","@NotNull public Class<? extends SubscriptionCollection> getSubscriptionType(){
  @NotNull Class elementType=elementType();
  return elementType == TopologicalEvent.class ? TopologySubscription.class : elementType == BytesStore.class ? RawKVSSubscription.class : ObjectSubscription.class;
}"
55158,"@NotNull private WireParser<Void> wireParser(){
  @NotNull final WireParser<Void> parser=new VanillaWireParser<>((s,in,out) -> {
  }
,(methodId,bytes,o) -> {
  }
);
  parser.register(EventId.domain::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.domain(x)));
  parser.register(EventId.sessionMode::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.sessionMode(SessionMode.valueOf(x))));
  parser.register(EventId.securityToken::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.securityToken(x)));
  parser.register(EventId.clientId::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.clientId(UUID.fromString(x))));
  parser.register(EventId.wireType::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.wireType(WireType.valueOf(x))));
  parser.register(EventId.hostId::toString,(s,v,$) -> v.int8(this,(o,x) -> o.sessionDetails.hostId(x)));
  return parser;
}","@NotNull private WireParser<Void> wireParser(){
  @NotNull final WireParser<Void> parser=new VanillaWireParser<>((s,in,out) -> {
  }
,null);
  parser.register(EventId.domain::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.domain(x)));
  parser.register(EventId.sessionMode::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.sessionMode(SessionMode.valueOf(x))));
  parser.register(EventId.securityToken::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.securityToken(x)));
  parser.register(EventId.clientId::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.clientId(UUID.fromString(x))));
  parser.register(EventId.wireType::toString,(s,v,$) -> v.text(this,(o,x) -> o.sessionDetails.wireType(WireType.valueOf(x))));
  parser.register(EventId.hostId::toString,(s,v,$) -> v.int8(this,(o,x) -> o.sessionDetails.hostId(x)));
  return parser;
}"
55159,"/** 
 * adds some test data to a queue
 * @param tradesQ
 * @return returns all the trade ID's that where used
 */
private Set<String> publishMockData(final String tradesQ){
  Set<String> tradeIds=new LinkedHashSet<>();
  deleteDir(new File(tradesQ));
  try (ChronicleQueue queue=SingleChronicleQueueBuilder.binary(tradesQ).build()){
    ExcerptAppender excerptAppender=queue.acquireAppender();
    MockTradeGenerator mockTrade=new MockTradeGenerator();
    for (int i=0; i < COUNT; i++) {
      try (DocumentContext dc=excerptAppender.writingDocument()){
        Trade tradeId=mockTrade.apply(i);
        dc.wire().write(TRADES).marshallable(tradeId);
        tradeIds.add(tradeId.getTradeId());
      }
     }
    return tradeIds;
  }
 }","/** 
 * adds some test data to a queue
 * @return returns all the trade ID's that where used
 */
private static Set<String> publishMockData(){
  Set<String> tradeIds=new LinkedHashSet<>();
  try (ChronicleQueue queue=SingleChronicleQueueBuilder.binary(TRADES_Q).build()){
    ExcerptAppender excerptAppender=queue.acquireAppender();
    MockTradeGenerator mockTrade=new MockTradeGenerator();
    for (int i=0; i < COUNT; i++) {
      try (DocumentContext dc=excerptAppender.writingDocument()){
        Trade tradeId=mockTrade.apply(i);
        dc.wire().write(TRADES).marshallable(tradeId);
        tradeIds.add(tradeId.getTradeId());
      }
     }
    return tradeIds;
  }
 }"
55160,"private void onRead0(@NotNull DocumentContext inDc,@NotNull WireOut out,@NotNull WireIn in){
  if (!YamlLogging.showHeartBeats()) {
    prevLogMessage.setLength(0);
    prevLogMessage.append(currentLogMessage);
    currentLogMessage.setLength(0);
    logToBuffer(in,currentLogMessage,in.bytes().readPosition() - 4);
  }
 else {
    logYamlToStandardOut(in);
  }
  if (inDc.isMetaData()) {
    this.metaDataConsumer.readMarshallable(in);
  }
 else {
    try {
      if (LOG.isDebugEnabled())       Jvm.debug().on(getClass(),""String_Node_Str"" + in.bytes().toHexString());
      @NotNull Consumer<WireType> wireTypeConsumer=wt -> {
        wireType(wt);
        checkWires(in.bytes(),out.bytes(),wireType());
      }
;
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails,getMonitoringMap(),isServerSocket,this::publisher,hostIdentifier,wireTypeConsumer,wireType());
        if (!systemHandler.wasHeartBeat()) {
          if (!YamlLogging.showHeartBeats())           logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
        }
        return;
      }
      if (!YamlLogging.showHeartBeats()) {
        logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
      }
      @Nullable Map<String,UserStat> userMonitoringMap=getMonitoringMap();
      if (userMonitoringMap != null) {
        UserStat userStat=userMonitoringMap.get(sessionDetails.userId());
        if (userStat == null) {
          throw new AssertionError(""String_Node_Str"");
        }
        userStat.setRecentInteraction(LocalTime.now());
        userStat.setTotalInteractions(userStat.getTotalInteractions() + 1);
        userMonitoringMap.put(sessionDetails.userId(),userStat);
      }
      if (wireAdapter != null) {
        if (viewType == null)         return;
        if (MapView.class.isAssignableFrom(viewType)) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (EntrySetView.class.isAssignableFrom(viewType)) {
          entrySetHandler.process(in,out,(EntrySetView)view,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (KeySetView.class.isAssignableFrom(viewType)) {
          keySetHandler.process(in,out,(KeySetView)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (MapColumnView.class.isAssignableFrom(viewType) || QueueColumnView.class.isAssignableFrom(viewType) || viewType == ColumnView.class) {
          columnViewHandler.process(in,out,(ColumnViewInternal)view,tid);
          return;
        }
        if (ColumnViewIterator.class.isAssignableFrom(viewType)) {
          columnViewIteratorHandler.process(in,out,tid,(Iterator<Row>)view,cid);
          return;
        }
        if (ValuesCollection.class.isAssignableFrom(viewType)) {
          valuesHandler.process(in,out,(ValuesCollection)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (ObjectSubscription.class.isAssignableFrom(viewType)) {
          subscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(SubscriptionCollection)view);
          return;
        }
        if (TopologySubscription.class.isAssignableFrom(viewType)) {
          topologySubscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (Reference.class.isAssignableFrom(viewType)) {
          referenceHandler.process(in,requestContext,publisher(),tid,(Reference)view,cspText,outWire,wireAdapter);
          return;
        }
        if (TopicPublisher.class.isAssignableFrom(viewType) || QueueView.class.isAssignableFrom(viewType)) {
          topicPublisherHandler.process(in,publisher(),tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (Publisher.class.isAssignableFrom(viewType)) {
          publisherHandler.process(in,requestContext,publisher(),tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (Replication.class.isAssignableFrom(viewType)) {
          replicationHandler.process(in,publisher(),tid,outWire,hostIdentifier,(Replication)view,eventLoop);
          return;
        }
        if (IndexQueueView.class.isAssignableFrom(viewType)) {
          indexQueueViewHandler.process(in,requestContext,contextAsset,publisher(),tid,outWire);
          return;
        }
        if (VaadinChart.class.isAssignableFrom(viewType)) {
          barChatHandler.process(in,out,(VaadinChart)view,tid);
        }
      }
    }
 catch (    Exception e) {
      Jvm.warn().on(getClass(),in.readingPeekYaml() + ""String_Node_Str"" + in.bytes().toDebugString(),e);
    }
 finally {
      if (sessionProvider != null)       sessionProvider.remove();
      cid=0;
    }
  }
}","private void onRead0(@NotNull DocumentContext inDc,@NotNull WireOut out,@NotNull WireIn in){
  if (!YamlLogging.showHeartBeats()) {
    prevLogMessage.setLength(0);
    prevLogMessage.append(currentLogMessage);
    currentLogMessage.setLength(0);
    logToBuffer(in,currentLogMessage,in.bytes().readPosition() - 4);
  }
  logYamlToStandardOut(in);
  if (inDc.isMetaData()) {
    this.metaDataConsumer.readMarshallable(in);
  }
 else {
    try {
      if (LOG.isDebugEnabled())       Jvm.debug().on(getClass(),""String_Node_Str"" + in.bytes().toHexString());
      @NotNull Consumer<WireType> wireTypeConsumer=wt -> {
        wireType(wt);
        checkWires(in.bytes(),out.bytes(),wireType());
      }
;
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails,getMonitoringMap(),isServerSocket,this::publisher,hostIdentifier,wireTypeConsumer,wireType());
        if (!systemHandler.wasHeartBeat()) {
          if (!YamlLogging.showHeartBeats())           logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
        }
        return;
      }
      if (!YamlLogging.showHeartBeats()) {
        logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
      }
      @Nullable Map<String,UserStat> userMonitoringMap=getMonitoringMap();
      if (userMonitoringMap != null) {
        UserStat userStat=userMonitoringMap.get(sessionDetails.userId());
        if (userStat == null) {
          throw new AssertionError(""String_Node_Str"");
        }
        userStat.setRecentInteraction(LocalTime.now());
        userStat.setTotalInteractions(userStat.getTotalInteractions() + 1);
        userMonitoringMap.put(sessionDetails.userId(),userStat);
      }
      if (wireAdapter != null) {
        if (viewType == null)         return;
        if (MapView.class.isAssignableFrom(viewType)) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (EntrySetView.class.isAssignableFrom(viewType)) {
          entrySetHandler.process(in,out,(EntrySetView)view,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (KeySetView.class.isAssignableFrom(viewType)) {
          keySetHandler.process(in,out,(KeySetView)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (MapColumnView.class.isAssignableFrom(viewType) || QueueColumnView.class.isAssignableFrom(viewType) || viewType == ColumnView.class) {
          columnViewHandler.process(in,out,(ColumnViewInternal)view,tid);
          return;
        }
        if (ColumnViewIterator.class.isAssignableFrom(viewType)) {
          columnViewIteratorHandler.process(in,out,tid,(Iterator<Row>)view,cid);
          return;
        }
        if (ValuesCollection.class.isAssignableFrom(viewType)) {
          valuesHandler.process(in,out,(ValuesCollection)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (ObjectSubscription.class.isAssignableFrom(viewType)) {
          subscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(SubscriptionCollection)view);
          return;
        }
        if (TopologySubscription.class.isAssignableFrom(viewType)) {
          topologySubscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (Reference.class.isAssignableFrom(viewType)) {
          referenceHandler.process(in,requestContext,publisher(),tid,(Reference)view,cspText,outWire,wireAdapter);
          return;
        }
        if (TopicPublisher.class.isAssignableFrom(viewType) || QueueView.class.isAssignableFrom(viewType)) {
          topicPublisherHandler.process(in,publisher(),tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (Publisher.class.isAssignableFrom(viewType)) {
          publisherHandler.process(in,requestContext,publisher(),tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (Replication.class.isAssignableFrom(viewType)) {
          replicationHandler.process(in,publisher(),tid,outWire,hostIdentifier,(Replication)view,eventLoop);
          return;
        }
        if (IndexQueueView.class.isAssignableFrom(viewType)) {
          indexQueueViewHandler.process(in,requestContext,contextAsset,publisher(),tid,outWire);
          return;
        }
        if (VaadinChart.class.isAssignableFrom(viewType)) {
          barChatHandler.process(in,out,(VaadinChart)view,tid);
        }
      }
    }
 catch (    Exception e) {
      Jvm.warn().on(getClass(),in.readingPeekYaml() + ""String_Node_Str"" + in.bytes().toDebugString(),e);
    }
 finally {
      if (sessionProvider != null)       sessionProvider.remove();
      cid=0;
    }
  }
}"
55161,"@After public void checkThreadDump(){
  threadDump.ignore(""String_Node_Str"");
  threadDump.assertNoNewThreads();
}","@After public void checkThreadDump(){
  if (threadDump != null) {
    threadDump.ignore(""String_Node_Str"");
    threadDump.assertNoNewThreads();
  }
}"
55162,"@Nullable private Marshallable value(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator,final long from,@NotNull final LongSupplier lastIndexOfSnapshot){
  if (iterator.hasNext()) {
    IndexedValue<V> indexedValue=iterator.next();
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    if (!iterator.hasNext()) {
      if (lastIndexOfSnapshot.getAsLong() == -1)       indexedValue.isEndOfSnapshot(true);
    }
 else {
      indexedValue.isEndOfSnapshot(false);
    }
    return indexedValue;
  }
  final String eventName=vanillaIndexQuery.eventName();
  final Predicate<V> filter=vanillaIndexQuery.filter();
  if (isClosed.get())   throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
  try (DocumentContext dc=tailer.readingDocument()){
    try {
      if (!dc.isData())       return null;
      if (LOG.isDebugEnabled())       Jvm.debug().on(getClass(),""String_Node_Str"" + fromSizePrefixedBlobs(dc));
      if (from > dc.index())       return null;
      Class<? extends Marshallable> type=typeToString.toType(eventName);
      if (type == null)       return null;
      final StringBuilder serialisedEventName=eventNameDeserialiserPool.acquireStringBuilder();
      @NotNull final ValueIn valueIn=dc.wire().read(serialisedEventName);
      if (valueIn instanceof DefaultValueIn)       return null;
      if (!eventNamesMatch(serialisedEventName,eventName)) {
        return null;
      }
      @NotNull final V v=(V)VanillaObjectCacheFactory.INSTANCE.get().apply(type);
      valueIn.marshallable(v);
      if (!filter.test(v))       return null;
      final IndexedValue<V> indexedValue=this.indexedValue.get();
      long index=dc.index();
      indexedValue.index(index);
      indexedValue.v(v);
      indexedValue.timePublished(System.currentTimeMillis());
      indexedValue.isEndOfSnapshot(indexedValue == lastIndexOfSnapshot);
      indexedValue.maxIndex(Math.max(dc.index(),lastIndexRead));
      return indexedValue;
    }
  finally {
      if (dc.isPresent())       while (dc.wire().hasMore()) {
        dc.wire().read().skipValue();
      }
    }
  }
 }","@Nullable private Marshallable value(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator,final long from,@NotNull final LongSupplier lastIndexOfSnapshot){
  if (iterator.hasNext()) {
    IndexedValue<V> indexedValue=iterator.next();
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    if (!iterator.hasNext()) {
      if (lastIndexOfSnapshot.getAsLong() == -1)       indexedValue.isEndOfSnapshot(true);
    }
 else {
      indexedValue.isEndOfSnapshot(false);
    }
    return indexedValue;
  }
  final String eventName=vanillaIndexQuery.eventName();
  final Predicate<V> filter=vanillaIndexQuery.filter();
  if (isClosed.get())   throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
  try (DocumentContext dc=tailer.readingDocument()){
    try {
      if (!dc.isData())       return null;
      if (LOG.isDebugEnabled())       Jvm.debug().on(getClass(),""String_Node_Str"" + fromSizePrefixedBlobs(dc));
      if (from > dc.index())       return null;
      Class<? extends Marshallable> type=typeToString.toType(eventName);
      if (type == null)       return null;
      final StringBuilder serialisedEventName=eventNameDeserialiserPool.acquireStringBuilder();
      @NotNull final ValueIn valueIn=dc.wire().read(serialisedEventName);
      if (valueIn instanceof DefaultValueIn)       return null;
      if (!eventNamesMatch(serialisedEventName,eventName)) {
        return null;
      }
      @NotNull final V v=(V)VanillaObjectCacheFactory.INSTANCE.get().apply(type);
      valueIn.marshallable(v);
      if (!filter.test(v))       return null;
      final IndexedValue<V> indexedValue=this.indexedValue.get();
      long index=dc.index();
      indexedValue.index(index);
      indexedValue.v(v);
      indexedValue.timePublished(System.currentTimeMillis());
      indexedValue.isEndOfSnapshot(index == lastIndexOfSnapshot.getAsLong());
      indexedValue.maxIndex(Math.max(dc.index(),lastIndexRead));
      return indexedValue;
    }
  finally {
      if (dc.isPresent())       while (dc.wire().hasMore()) {
        dc.wire().read().skipValue();
      }
    }
  }
 }"
55163,"public VanillaIndexQueueView(@NotNull RequestContext context,@NotNull Asset asset,@NotNull QueueView<?,V> queueView){
  this.asset=asset;
  @NotNull final EventLoop eventLoop=asset.acquireView(EventLoop.class);
  @NotNull final ChronicleQueueView chronicleQueueView=(ChronicleQueueView)queueView;
  chronicleQueue=chronicleQueueView.chronicleQueue();
  @NotNull final ExcerptTailer tailer=chronicleQueue.createTailer();
  @NotNull AtomicBoolean hasMovedToStart=new AtomicBoolean();
  typeToString=asset.root().findView(TypeToString.class);
  eventLoop.addHandler(() -> {
    if (!hasMovedToStart.get()) {
      @NotNull final RollingChronicleQueue chronicleQueue=(RollingChronicleQueue)this.chronicleQueue;
      final int cycle=chronicleQueue.cycle();
      long startOfCurrentCycle=chronicleQueue.rollCycle().toIndex(cycle,0);
      final boolean success=tailer.moveToIndex(startOfCurrentCycle);
      hasMovedToStart.set(success);
      if (!success)       return false;
    }
    long currentSecond=TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());
    if (currentSecond >= lastSecond + 10) {
      lastSecond=currentSecond;
      LOG.info(""String_Node_Str"" + messagesReadPerSecond / 10);
      messagesReadPerSecond=0;
    }
    if (isClosed.get())     throw new InvalidEventHandlerException();
    try (DocumentContext dc=tailer.readingDocument()){
      if (!dc.isPresent())       return false;
      long start=dc.wire().bytes().readPosition();
      try {
        for (; ; ) {
          dc.wire().consumePadding();
          if (dc.wire().bytes().readRemaining() == 0)           return true;
          final StringBuilder sb=acquireStringBuilder();
          @NotNull final ValueIn read=dc.wire().read(sb);
          if (""String_Node_Str"".contentEquals(sb)) {
            read.marshallable(MessageHistory.get());
            return true;
          }
          if (sb.length() == 0)           continue;
          Class<? extends Marshallable> type=typeToString.toType(sb);
          if (type == null)           continue;
          @NotNull final V v=(V)VanillaObjectCacheFactory.INSTANCE.get().apply(type);
          long readPosition=dc.wire().bytes().readPosition();
          try {
            read.marshallable(v);
          }
 catch (          Exception e) {
            @NotNull final String msg=dc.wire().bytes().toHexString(readPosition,dc.wire().bytes().readLimit() - readPosition);
            LOG.error(""String_Node_Str"" + v.getClass().getSimpleName() + ""String_Node_Str""+ msg,e);
            return false;
          }
          Object k;
          if (v instanceof KeyedMarshallable) {
            final Bytes bytes=Wires.acquireBytes();
            ((KeyedMarshallable)v).writeKey(bytes);
            k=bytesToKey.get(bytes);
            if (k == null) {
              BytesStore copy=bytes.copy();
              bytesToKey.put(copy.bytesForRead(),copy);
              k=copy;
            }
          }
 else           continue;
          messagesReadPerSecond++;
          @NotNull final String eventName=sb.toString();
synchronized (lastIndexLock) {
            multiMap.computeIfAbsent(eventName,e -> new ConcurrentHashMap<>()).compute(k,(k1,vOld) -> {
              if (vOld == null)               return new IndexedValue<>(deepCopy(v),dc.index());
 else {
                copyTo(v,vOld.v());
                vOld.index(dc.index());
                return vOld;
              }
            }
);
            lastIndexRead=dc.index();
          }
        }
      }
 catch (      RuntimeException e) {
        Jvm.warn().on(getClass(),fromSizePrefixedBlobs(dc.wire().bytes(),start - 4),e);
      }
    }
     return true;
  }
);
}","public VanillaIndexQueueView(@NotNull RequestContext context,@NotNull Asset asset,@NotNull QueueView<?,V> queueView){
  this.asset=asset;
  @NotNull final EventLoop eventLoop=asset.acquireView(EventLoop.class);
  @NotNull final ChronicleQueueView chronicleQueueView=(ChronicleQueueView)queueView;
  chronicleQueue=chronicleQueueView.chronicleQueue();
  @NotNull final ExcerptTailer tailer=chronicleQueue.createTailer();
  @NotNull AtomicBoolean hasMovedToStart=new AtomicBoolean();
  typeToString=asset.root().findView(TypeToString.class);
  eventLoop.addHandler(() -> handleAction(tailer,hasMovedToStart));
}"
55164,"@Test public void updateTheMapView(){
  @NotNull MapView<String,String> map=acquireMap(""String_Node_Str"",String.class,String.class);
  @NotNull List<String> values=new ArrayList<>();
  @NotNull TopicSubscriber<String,String> subscriber=(topic,message) -> values.add(""String_Node_Str"" + topic + ""String_Node_Str""+ message+ ""String_Node_Str"");
  registerTopicSubscriber(""String_Node_Str"",String.class,String.class,subscriber);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(1,map.applyTo(Map::size),0);
  map.remove(""String_Node_Str"");
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  map.asyncUpdate(m -> map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  assertEquals(0,map.syncUpdate(m -> m.remove(""String_Node_Str""),Map::size),0);
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
}","@Test public void updateTheMapView(){
  @NotNull MapView<String,String> map=acquireMap(""String_Node_Str"",String.class,String.class);
  @NotNull List<String> values=new ArrayList<>();
  @NotNull TopicSubscriber<String,String> subscriber=(topic,message) -> values.add(""String_Node_Str"" + topic + ""String_Node_Str""+ message+ ""String_Node_Str"");
  registerTopicSubscriber(""String_Node_Str"",String.class,String.class,subscriber);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(1,(int)map.applyTo(Map::size),0);
  map.remove(""String_Node_Str"");
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  map.asyncUpdate(m -> map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  assertEquals(0,(int)map.syncUpdate(m -> m.remove(""String_Node_Str""),Map::size),0);
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
}"
55165,"@Test public void updateTheMapView(){
  @NotNull MapView<String,String> map=acquireMap(""String_Node_Str"",String.class,String.class);
  @NotNull List<String> values=new ArrayList<>();
  @NotNull TopicSubscriber<String,String> subscriber=(topic,message) -> values.add(""String_Node_Str"" + topic + ""String_Node_Str""+ message+ ""String_Node_Str"");
  registerTopicSubscriber(""String_Node_Str"",String.class,String.class,subscriber);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(1,map.applyTo(Map::size),0);
  map.remove(""String_Node_Str"");
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  map.asyncUpdate(m -> map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  assertEquals(0,map.syncUpdate(m -> m.remove(""String_Node_Str""),Map::size),0);
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
}","@Test public void updateTheMapView(){
  @NotNull MapView<String,String> map=acquireMap(""String_Node_Str"",String.class,String.class);
  @NotNull List<String> values=new ArrayList<>();
  @NotNull TopicSubscriber<String,String> subscriber=(topic,message) -> values.add(""String_Node_Str"" + topic + ""String_Node_Str""+ message+ ""String_Node_Str"");
  registerTopicSubscriber(""String_Node_Str"",String.class,String.class,subscriber);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(1,(int)map.applyTo(Map::size),0);
  map.remove(""String_Node_Str"");
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  map.asyncUpdate(m -> map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
  assertEquals(0,(int)map.syncUpdate(m -> m.remove(""String_Node_Str""),Map::size),0);
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",values.toString());
}"
55166,"/** 
 * Apply a function to visitable potentially asynchronously.  This argument may contain a combination of data. This function is assumed to replace the value and trigger and events or replciated changes.
 * @param key            to update within this collection
 * @param updateFunction to update the state of the visitable.
 * @param argument       for the functions use.
 * @param < T >            type of the argument
 */
default <T>void asyncUpdateKey(K key,@NotNull SerializableBiFunction<E,T,E> updateFunction,T argument){
  set(key,updateFunction.apply(get(key),argument));
}","/** 
 * Apply a function to visitable potentially asynchronously.  This argument may contain a combination of data. This function is assumed to replace the value and trigger and events or replicated changes.
 * @param key            to update within this collection
 * @param updateFunction to update the state of the visitable.
 * @param argument       for the functions use.
 * @param < T >            type of the argument
 */
default <T>void asyncUpdateKey(K key,@NotNull SerializableBiFunction<E,T,E> updateFunction,T argument){
  set(key,updateFunction.apply(get(key),argument));
}"
55167,"/** 
 * Update an Updatable potentially asynchronously.  This function is assumed to update Updateable.
 * @param updateFunction to apply.
 */
default <A>void asyncUpdate(@NotNull SerializableUpdaterWithArg<E,A> updateFunction,A arg){
  updateFunction.accept((E)this,arg);
}","/** 
 * Update an Updatable potentially asynchronously.  This function is assumed to update Updatable.
 * @param updateFunction to apply.
 */
default <A>void asyncUpdate(@NotNull SerializableUpdaterWithArg<E,A> updateFunction,A arg){
  updateFunction.accept((E)this,arg);
}"
55168,"/** 
 * There is no longer any valid session detaisl and get() will return null.
 */
public void remove(){
  throw new UnsupportedOperationException();
}","/** 
 * There is no longer any valid session details and get() will return null.
 */
public void remove(){
  throw new UnsupportedOperationException();
}"
55169,"/** 
 * @param publisher
 * @return If the throttlePeriodMs is set returns a throttled wire out publisher, otherwise theorigional
 */
@NotNull WireOutPublisher publisher(@NotNull final WireOutPublisher publisher){
  return requestContext.throttlePeriodMs() == 0 ? publisher : newThrottledWireOutPublisher(requestContext.throttlePeriodMs(),publisher);
}","/** 
 * @param publisher
 * @return If the throttlePeriodMs is set returns a throttled wire out publisher, otherwise theoriginal
 */
@NotNull WireOutPublisher publisher(@NotNull final WireOutPublisher publisher){
  return requestContext.throttlePeriodMs() == 0 ? publisher : newThrottledWireOutPublisher(requestContext.throttlePeriodMs(),publisher);
}"
55170,"/** 
 * android-changed Android does not use a SecurityManager. This will simply execute the runnable ingoring permisions.
 */
private void runWithPermissions(@NotNull Runnable r,Permission... permissions){
  r.run();
}","/** 
 * android-changed Android does not use a SecurityManager. This will simply execute the runnable ignoring permissions.
 */
private void runWithPermissions(@NotNull Runnable r,Permission... permissions){
  r.run();
}"
55171,"/** 
 * android-changed Android does not use a SecurityManager. This will simply execute the runnable ingoring permisions.
 */
public void runWithSecurityManagerWithPermissions(@NotNull Runnable r,Permission... permissions){
  r.run();
}","/** 
 * android-changed Android does not use a SecurityManager. This will simply execute the runnable ignoring permissions.
 */
public void runWithSecurityManagerWithPermissions(@NotNull Runnable r,Permission... permissions){
  r.run();
}"
55172,"@NotNull @Override public List<Column> columns(){
  @NotNull List<Column> result=new ArrayList<>();
  if ((Marshallable.class.isAssignableFrom(keyType()))) {
    for (    @NotNull final FieldInfo info : Wires.fieldInfos(keyType())) {
      result.add(new Column(info.name(),true,false,""String_Node_Str"",info.type(),true));
    }
  }
 else {
    result.add(new Column(""String_Node_Str"",true,true,""String_Node_Str"",keyType(),true));
  }
  boolean isReadOnly=requestContext.toUri().startsWith(""String_Node_Str"");
  if ((Marshallable.class.isAssignableFrom(valueType()))) {
    for (    @NotNull final FieldInfo info : Wires.fieldInfos(valueType())) {
      result.add(new Column(info.name(),isReadOnly,false,""String_Node_Str"",info.type(),true));
    }
  }
 else {
    result.add(new Column(""String_Node_Str"",isReadOnly,false,""String_Node_Str"",valueType(),true));
  }
  return result;
}","@NotNull @Override public List<Column> columns(){
  @NotNull List<Column> result=new ArrayList<>();
  if ((Marshallable.class.isAssignableFrom(keyType()))) {
    for (    @NotNull final FieldInfo info : Wires.fieldInfos(keyType())) {
      result.add(new Column(info.name(),true,true,""String_Node_Str"",info.type(),true));
    }
  }
 else {
    result.add(new Column(""String_Node_Str"",true,true,""String_Node_Str"",keyType(),true));
  }
  boolean isReadOnly=requestContext.toUri().startsWith(""String_Node_Str"");
  if ((Marshallable.class.isAssignableFrom(valueType()))) {
    for (    @NotNull final FieldInfo info : Wires.fieldInfos(valueType())) {
      result.add(new Column(info.name(),isReadOnly,false,""String_Node_Str"",info.type(),true));
    }
  }
 else {
    result.add(new Column(""String_Node_Str"",isReadOnly,false,""String_Node_Str"",valueType(),true));
  }
  return result;
}"
55173,"private Number number(String op,String value,Class<? extends Number> clazz){
  @NotNull final String number;
  number=(operationAtStart) ? value.substring(op.length()).trim() : value.substring(0,value.length() - op.length()).trim();
  return convertTo(clazz,number);
}","private Number number(String op,String value,Class<? extends Number> clazz) throws Exception {
  @NotNull final String number;
  number=(operationAtStart) ? value.substring(op.length()).trim() : value.substring(0,value.length() - op.length()).trim();
  if (!number.isEmpty())   return convertTo(clazz,number);
  throw new RuntimeException(""String_Node_Str"" + value + ""String_Node_Str"");
}"
55174,"@Nullable private Predicate<Map.Entry<K,V>> filter(@NotNull List<MarshableFilter> filters){
  return entry -> {
    if (filters.isEmpty())     return true;
    try {
      for (      @NotNull MarshableFilter f : filters) {
        Object item;
        if (""String_Node_Str"".equals(f.columnName)) {
          item=entry.getKey();
        }
 else         if (!(Marshallable.class.isAssignableFrom(mapView.valueType())) && ""String_Node_Str"".equals(f.columnName)) {
          item=entry.getValue();
        }
 else         if (Marshallable.class.isAssignableFrom(mapView.valueType())) {
          try {
            final Class valueClass=entry.getValue().getClass();
            final FieldInfo info=Wires.fieldInfo(valueClass,f.columnName);
            final Object o=info.get(entry.getValue());
            if (o == null)             return false;
            if (o instanceof Number) {
              if (toRange((Number)o,f.filter.trim()))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence) {
          if (!item.toString().toLowerCase().contains(f.filter.toLowerCase()))           return false;
        }
 else         if (item instanceof Number) {
          if (!toRange((Number)item,f.filter.trim()))           return false;
        }
 else {
          if (!item.equals(convertTo(item.getClass(),f.filter.trim())))           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}","@Nullable private Predicate<Map.Entry<K,V>> filter(@NotNull List<MarshableFilter> filters){
  final Predicate<Number> predicate=predicate(filters);
  return entry -> {
    if (filters.isEmpty())     return true;
    try {
      for (      @NotNull MarshableFilter f : filters) {
        Object item;
        if (""String_Node_Str"".equals(f.columnName)) {
          item=entry.getKey();
        }
 else         if (!(Marshallable.class.isAssignableFrom(mapView.valueType())) && ""String_Node_Str"".equals(f.columnName)) {
          item=entry.getValue();
        }
 else         if (Marshallable.class.isAssignableFrom(mapView.valueType())) {
          try {
            final Class valueClass=entry.getValue().getClass();
            final FieldInfo info=Wires.fieldInfo(valueClass,f.columnName);
            final Object o=info.get(entry.getValue());
            if (o == null)             return false;
            if (o instanceof Number) {
              if (predicate.test((Number)o))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence) {
          if (!item.toString().toLowerCase().contains(f.filter.toLowerCase()))           return false;
        }
 else         if (item instanceof Number) {
          if (!predicate.test((Number)item))           return false;
        }
 else {
          if (!item.equals(convertTo(item.getClass(),f.filter.trim())))           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}"
55175,"@Nullable public Predicate<QueueView.Excerpt<String,V>> filter(@Nullable List<MarshableFilter> filters){
  return excerpt -> {
    if (filters == null || filters.isEmpty())     return true;
    try {
      for (      @NotNull MarshableFilter f : filters) {
        Object item;
        final Class messageClass=excerpt.message().getClass();
        if (Marshallable.class.isAssignableFrom(messageClass)) {
          try {
            V message=excerpt.message();
            FieldInfo info=Wires.fieldInfo(message.getClass(),f.columnName);
            final Object o=info.get(message);
            if (o == null)             return false;
            if (o instanceof Number) {
              if (toRange((Number)o,f.filter.trim()))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence) {
          if (!item.toString().toLowerCase().contains(f.filter.toLowerCase()))           return false;
        }
 else         if (item instanceof Number) {
          if (!toRange((Number)item,f.filter.trim()))           return false;
        }
 else {
          if (!item.equals(convertTo(item.getClass(),f.filter.trim())))           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}","@Nullable public Predicate<QueueView.Excerpt<String,V>> filter(@Nullable List<MarshableFilter> filters){
  final Predicate predicate=predicate(filters);
  return excerpt -> {
    if (filters == null || filters.isEmpty())     return true;
    try {
      for (      @NotNull MarshableFilter f : filters) {
        Object item;
        final Class messageClass=excerpt.message().getClass();
        if (Marshallable.class.isAssignableFrom(messageClass)) {
          try {
            V message=excerpt.message();
            FieldInfo info=Wires.fieldInfo(message.getClass(),f.columnName);
            final Object o=info.get(message);
            if (o == null)             return false;
            if (o instanceof Number) {
              if (predicate.test(o))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence) {
          if (!item.toString().toLowerCase().contains(f.filter.toLowerCase()))           return false;
        }
 else         if (item instanceof Number) {
          if (!predicate.test(item))           return false;
        }
 else {
          if (!item.equals(convertTo(item.getClass(),f.filter.trim())))           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}"
55176,"@Test public void test2(){
  MapWrappingColumnView cv=ObjectUtils.newInstance(MapWrappingColumnView.class);
  ArrayList results=new ArrayList();
  int[] numbers={1,2,3,4};
  for (  Number n : numbers) {
    if (cv.toRange(n,""String_Node_Str""))     results.add(n);
  }
  Assert.assertEquals(""String_Node_Str"",results.toString());
}","@Test public void test2(){
  MapWrappingColumnView cv=ObjectUtils.newInstance(MapWrappingColumnView.class);
  ArrayList results=new ArrayList();
  int[] numbers={1,2,3,4};
  Predicate<Number> predicate=cv.toPedicate(""String_Node_Str"");
  for (  Number n : numbers) {
    if (predicate.test(n))     results.add(n);
  }
  Assert.assertEquals(""String_Node_Str"",results.toString());
}"
55177,"@Test public void testRange(){
  Assert.assertTrue(ColumnViewInternal.DOp.toRange(3,""String_Node_Str"",false));
  Assert.assertTrue(ColumnViewInternal.DOp.toRange(3,""String_Node_Str"",false));
  Assert.assertFalse(ColumnViewInternal.DOp.toRange(3,""String_Node_Str"",false));
  Assert.assertTrue(ColumnViewInternal.DOp.toRange(3,""String_Node_Str"",false));
}","@Test public void testRange(){
  Assert.assertTrue(ColumnViewInternal.DOp.toPredicate(""String_Node_Str"",false).test(3));
  Assert.assertTrue(ColumnViewInternal.DOp.toPredicate(""String_Node_Str"",false).test(3));
  Assert.assertFalse(ColumnViewInternal.DOp.toPredicate(""String_Node_Str"",false).test(3));
  Assert.assertTrue(ColumnViewInternal.DOp.toPredicate(""String_Node_Str"",false).test(3));
}"
55178,"@Test public void test(){
  MapWrappingColumnView cv=ObjectUtils.newInstance(MapWrappingColumnView.class);
  ArrayList results=new ArrayList();
  int[] numbers={1,2,3,4};
  for (  Number n : numbers) {
    if (cv.toRange(n,""String_Node_Str""))     results.add(n);
  }
  Assert.assertEquals(""String_Node_Str"",results.toString());
}","@Test public void test(){
  MapWrappingColumnView cv=ObjectUtils.newInstance(MapWrappingColumnView.class);
  ArrayList results=new ArrayList();
  int[] numbers={1,2,3,4};
  Predicate<Number> predicate=cv.toPedicate(""String_Node_Str"");
  for (  Number n : numbers) {
    if (predicate.test(n))     results.add(n);
  }
  Assert.assertEquals(""String_Node_Str"",results.toString());
}"
55179,"@SuppressWarnings(""String_Node_Str"") @Override public void accept(WireIn wireIn,Long inputTid){
  eventName.setLength(0);
  final ValueIn valueIn=inWire.readEventName(eventName);
  try {
    outWire.writeDocument(true,wire -> outWire.writeEventName(CoreFields.tid).int64(tid));
    writeData(inWire.bytes(),out -> {
      if (columns.contentEquals(eventName)) {
        outWire.writeEventName(reply).object(columnView.columns());
        return;
      }
      if (rowCount.contentEquals(eventName)) {
        ColumnViewInternal.SortedFilter filters=valueIn.object(ColumnViewInternal.SortedFilter.class);
        int count=columnView.rowCount(filters == null ? new ColumnViewInternal.SortedFilter() : filters);
        outWire.writeEventName(reply).int32(count);
        return;
      }
      if (changedRow.contentEquals(eventName)) {
        valueIn.marshallable(wire -> {
          wire.read(rowCount.params()[0]).object(newRow,Map.class);
          wire.read(rowCount.params()[1]).object(oldRow,Map.class);
          final int result=columnView.changedRow(newRow,oldRow);
          outWire.writeEventName(reply).int32(result);
        }
);
        return;
      }
      if (canDeleteRows.contentEquals(eventName)) {
        outWire.writeEventName(reply).bool(columnView.canDeleteRows());
        return;
      }
      if (containsRowWithKey.contentEquals(eventName)) {
        keysList.clear();
        final List keys=valueIn.object(keysList,List.class);
        final boolean result=columnView.containsRowWithKey(keys);
        outWire.writeEventName(reply).bool(result);
        return;
      }
      if (iterator.contentEquals(eventName)) {
        valueIn.marshallable(sortedFilter);
        long token=nextToken.incrementAndGet();
        final long cid=cspManager.createProxy(""String_Node_Str"",token);
        final Iterator<? extends Row> iterator=columnView.iterator(sortedFilter);
        cspManager.storeObject(cid,iterator);
        return;
      }
      throw new IllegalStateException(""String_Node_Str"" + eventName);
    }
);
  }
 catch (  Exception e) {
    Jvm.warn().on(getClass(),e);
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void accept(WireIn wireIn,Long inputTid){
  eventName.setLength(0);
  final ValueIn valueIn=inWire.readEventName(eventName);
  try {
    outWire.writeDocument(true,wire -> outWire.writeEventName(CoreFields.tid).int64(tid));
    writeData(inWire.bytes(),out -> {
      if (columns.contentEquals(eventName)) {
        outWire.writeEventName(reply).object(columnView.columns());
        return;
      }
      if (rowCount.contentEquals(eventName)) {
        ColumnViewInternal.SortedFilter filters=valueIn.object(ColumnViewInternal.SortedFilter.class);
        int count=columnView.rowCount(filters == null ? new ColumnViewInternal.SortedFilter() : filters);
        outWire.writeEventName(reply).int32(count);
        return;
      }
      if (changedRow.contentEquals(eventName)) {
        valueIn.marshallable(wire -> {
          newRow.clear();
          oldRow.clear();
          wire.read(changedRow.params()[0]).object(newRow,Map.class);
          wire.read(changedRow.params()[1]).object(oldRow,Map.class);
          final int result=columnView.changedRow(newRow,oldRow);
          outWire.writeEventName(reply).int32(result);
        }
);
        return;
      }
      if (canDeleteRows.contentEquals(eventName)) {
        outWire.writeEventName(reply).bool(columnView.canDeleteRows());
        return;
      }
      if (containsRowWithKey.contentEquals(eventName)) {
        keysList.clear();
        final List keys=valueIn.object(keysList,List.class);
        final boolean result=columnView.containsRowWithKey(keys);
        outWire.writeEventName(reply).bool(result);
        return;
      }
      if (iterator.contentEquals(eventName)) {
        valueIn.marshallable(sortedFilter);
        long token=nextToken.incrementAndGet();
        final long cid=cspManager.createProxy(""String_Node_Str"",token);
        final Iterator<? extends Row> iterator=columnView.iterator(sortedFilter);
        cspManager.storeObject(cid,iterator);
        return;
      }
      throw new IllegalStateException(""String_Node_Str"" + eventName);
    }
);
  }
 catch (  Exception e) {
    Jvm.warn().on(getClass(),e);
  }
}"
55180,"/** 
 * @param queueSource
 * @param acknowledgment each replication event sends back an enableAcknowledgment, which isthen stored in the chronicle queue.
 */
public QueueConfig(Function<String,Integer> queueSource,boolean acknowledgment,@Nullable MessageAdaptor messageAdaptor,WireType wireType){
  this.sourceB=queueSource;
  this.messageAdaptor=messageAdaptor;
  this.acknowledgment=acknowledgment;
  this.wireType=wireType;
}","/** 
 * @param queueSource
 * @param acknowledgment each replication event sends back an enableAcknowledgment, which isthen stored in the chronicle queue.
 */
public QueueConfig(@NotNull Function<String,Integer> queueSource,boolean acknowledgment,@Nullable MessageAdaptor messageAdaptor,@NotNull WireType wireType){
  this.sourceB=queueSource;
  this.messageAdaptor=messageAdaptor;
  this.acknowledgment=acknowledgment;
  this.wireType=wireType;
}"
55181,"private Excerpt<T,M> next(ExcerptTailer excerptTailer,final LocalExcept excerpt){
  excerpt.clear();
  try (DocumentContext dc=excerptTailer.readingDocument()){
    if (!dc.isPresent())     return null;
    final Wire wire=dc.wire();
    final T topic=wire.readEvent(messageTypeClass);
    final ValueIn valueIn=wire.getValueIn();
    if (Bytes.class.isAssignableFrom(elementTypeClass)) {
      valueIn.text(excerpt.text());
    }
 else {
      final M message=valueIn.object(elementTypeClass);
      excerpt.message(message);
    }
    return excerpt.topic(topic).index(excerptTailer.index());
  }
 }","private Excerpt<T,M> next(ExcerptTailer excerptTailer,final LocalExcept excerpt){
  excerpt.clear();
  try (DocumentContext dc=excerptTailer.readingDocument()){
    if (!dc.isPresent())     return null;
    final Wire wire=dc.wire();
    long pos=wire.bytes().readPosition();
    final T topic=wire.readEvent(messageTypeClass);
    final ValueIn valueIn=wire.getValueIn();
    if (Bytes.class.isAssignableFrom(elementTypeClass)) {
      valueIn.text(excerpt.text());
    }
 else {
      final M message=valueIn.object(elementTypeClass);
      excerpt.message(message);
      System.out.println(pos + ""String_Node_Str"" + topic+ ""String_Node_Str""+ message);
    }
    return excerpt.topic(topic).index(excerptTailer.index());
  }
 }"
55182,"@SuppressWarnings(""String_Node_Str"") public static WriteMarshallable newSource(long nextIndexRequired,@NotNull Class topicType,@NotNull Class elementType,boolean acknowledgement,@Nullable MessageAdaptor messageAdaptor){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getDeclaredConstructor(long.class,Class.class,Class.class,boolean.class,MessageAdaptor.class);
    return (WriteMarshallable)declaredConstructor.newInstance(nextIndexRequired,topicType,elementType,acknowledgement,messageAdaptor);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    Jvm.warn().on(ChronicleQueueView.class,licence.getMessage());
    throw licence;
  }
}","@SuppressWarnings(""String_Node_Str"") public static WriteMarshallable newSource(long nextIndexRequired,@NotNull Class topicType,@NotNull Class elementType,boolean acknowledgement,@Nullable MessageAdaptor messageAdaptor){
  Objects.requireNonNull(topicType);
  Objects.requireNonNull(elementType);
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getDeclaredConstructor(long.class,Class.class,Class.class,boolean.class,MessageAdaptor.class);
    return (WriteMarshallable)declaredConstructor.newInstance(nextIndexRequired,topicType,elementType,acknowledgement,messageAdaptor);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    Jvm.warn().on(ChronicleQueueView.class,licence.getMessage());
    throw licence;
  }
}"
55183,"public VanillaBarChart dataSource(QueueView mapView){
  this.columnView=mapView.asset().acquireView(MapColumnView.class);
  return this;
}","public VanillaBarChart dataSource(QueueView mapView){
  this.columnView=mapView.asset().acquireView(QueueColumnView.class);
  return this;
}"
55184,"private static void addMyNumbers(VanillaAssetTree tree){
  @NotNull MapView<Integer,Double> intView=tree.acquireMap(""String_Node_Str"",Integer.class,Double.class);
  for (int i=0; i < 100; i++) {
    intView.put(i,(double)i);
  }
  @NotNull SimpleDateFormat sd=new SimpleDateFormat(""String_Node_Str"");
  @NotNull MapView<Date,MarketData> map=tree.acquireMap(""String_Node_Str"",Date.class,MarketData.class);
  try {
    map.put(sd.parse(""String_Node_Str""),new MarketData(114.31,114.56,113.51,114.06,114.06,24358400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.70,114.34,113.13,113.89,113.89,28779300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.40,113.66,112.69,113.05,113.05,21453100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.06,114.31,112.63,113.00,113.00,29736800L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(112.71,113.05,112.28,112.52,112.52,21701800L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(112.46,113.37,111.80,113.05,113.05,36379100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.16,113.80,111.80,112.18,112.18,35887000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.69,114.64,113.43,113.95,113.95,29641100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.00,113.18,112.34,113.09,113.09,24607400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(111.64,113.39,111.55,112.88,112.88,29869400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(114.42,114.79,111.55,112.71,112.71,52481200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(114.35,114.94,114.00,114.62,114.62,31074000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.85,113.99,112.44,113.55,113.55,36003200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.05,114.12,112.51,113.57,113.57,34514300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(115.19,116.18,113.25,113.58,113.58,47023000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(115.12,116.13,114.04,114.92,114.92,79886900L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.86,115.73,113.49,115.57,115.57,89983600L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.73,113.03,108.60,111.77,111.77,110888700L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.51,108.79,107.24,107.95,107.95,62176200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(102.65,105.72,102.53,105.44,105.44,45292800L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(104.64,105.72,103.13,103.13,103.13,46557000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.25,107.27,105.24,105.52,105.52,53002000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.83,108.76,107.07,108.36,108.36,42364300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.90,108.30,107.51,107.70,107.70,26880400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.70,108.00,106.82,107.73,107.73,26802500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(106.14,106.80,105.62,106.73,106.73,26701500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(105.66,106.57,105.64,106.10,106.10,29662400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(105.80,106.50,105.50,106.00,106.00,24863900L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(106.62,107.44,106.29,106.82,106.82,24970300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.41,107.95,106.31,106.94,106.94,27766300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.39,107.88,106.68,107.57,107.57,25086200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.57,108.75,107.68,108.03,108.03,23675100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.59,109.32,108.53,108.85,108.85,21257700L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.86,109.10,107.85,108.51,108.51,25820200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.77,109.69,108.36,109.36,109.36,25368100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(109.23,109.60,109.02,109.08,109.08,21984700L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(109.10,109.37,108.34,109.22,109.22,25356000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(109.63,110.23,109.21,109.38,109.38,33794400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.14,109.54,108.08,109.48,109.48,25868200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.78,108.44,107.78,108.18,108.18,18660400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.52,108.93,107.85,107.93,107.93,27484500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.71,108.90,107.76,108.00,108.00,24008500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.23,108.94,108.01,108.81,108.81,26315200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.52,108.37,107.16,108.37,108.37,28037200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(106.27,107.65,106.18,107.48,107.48,40553400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(105.58,106.00,105.28,105.87,105.87,27408700L));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private static void addMyNumbers(VanillaAssetTree tree){
  @NotNull MapView<Integer,Double> intView=tree.acquireMap(""String_Node_Str"",Integer.class,Double.class);
  for (int i=0; i < 100; i++) {
    intView.put(i,(double)i);
  }
  @NotNull SimpleDateFormat sd=new SimpleDateFormat(""String_Node_Str"");
  String csp=""String_Node_Str"";
  @NotNull MapView<Date,MarketData> map=tree.acquireMap(csp,Date.class,MarketData.class);
  VanillaBarChart barChart=tree.acquireView(requestContext(csp).view(""String_Node_Str""));
  barChart.columnNameField(""String_Node_Str"");
  barChart.columnValueField(""String_Node_Str"");
  barChart.title(""String_Node_Str"");
  barChart.dataSource(map);
  try {
    map.put(sd.parse(""String_Node_Str""),new MarketData(114.31,114.56,113.51,114.06,114.06,24358400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.70,114.34,113.13,113.89,113.89,28779300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.40,113.66,112.69,113.05,113.05,21453100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.06,114.31,112.63,113.00,113.00,29736800L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(112.71,113.05,112.28,112.52,112.52,21701800L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(112.46,113.37,111.80,113.05,113.05,36379100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.16,113.80,111.80,112.18,112.18,35887000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.69,114.64,113.43,113.95,113.95,29641100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.00,113.18,112.34,113.09,113.09,24607400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(111.64,113.39,111.55,112.88,112.88,29869400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(114.42,114.79,111.55,112.71,112.71,52481200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(114.35,114.94,114.00,114.62,114.62,31074000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.85,113.99,112.44,113.55,113.55,36003200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.05,114.12,112.51,113.57,113.57,34514300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(115.19,116.18,113.25,113.58,113.58,47023000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(115.12,116.13,114.04,114.92,114.92,79886900L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(113.86,115.73,113.49,115.57,115.57,89983600L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.73,113.03,108.60,111.77,111.77,110888700L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.51,108.79,107.24,107.95,107.95,62176200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(102.65,105.72,102.53,105.44,105.44,45292800L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(104.64,105.72,103.13,103.13,103.13,46557000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.25,107.27,105.24,105.52,105.52,53002000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.83,108.76,107.07,108.36,108.36,42364300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.90,108.30,107.51,107.70,107.70,26880400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.70,108.00,106.82,107.73,107.73,26802500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(106.14,106.80,105.62,106.73,106.73,26701500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(105.66,106.57,105.64,106.10,106.10,29662400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(105.80,106.50,105.50,106.00,106.00,24863900L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(106.62,107.44,106.29,106.82,106.82,24970300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.41,107.95,106.31,106.94,106.94,27766300L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.39,107.88,106.68,107.57,107.57,25086200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.57,108.75,107.68,108.03,108.03,23675100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.59,109.32,108.53,108.85,108.85,21257700L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.86,109.10,107.85,108.51,108.51,25820200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.77,109.69,108.36,109.36,109.36,25368100L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(109.23,109.60,109.02,109.08,109.08,21984700L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(109.10,109.37,108.34,109.22,109.22,25356000L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(109.63,110.23,109.21,109.38,109.38,33794400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.14,109.54,108.08,109.48,109.48,25868200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.78,108.44,107.78,108.18,108.18,18660400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.52,108.93,107.85,107.93,107.93,27484500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.71,108.90,107.76,108.00,108.00,24008500L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(108.23,108.94,108.01,108.81,108.81,26315200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(107.52,108.37,107.16,108.37,108.37,28037200L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(106.27,107.65,106.18,107.48,107.48,40553400L));
    map.put(sd.parse(""String_Node_Str""),new MarketData(105.58,106.00,105.28,105.87,105.87,27408700L));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
55185,"@Override public void notifyEvent(TopologicalEvent event){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void notifyEvent(TopologicalEvent event){
}"
55186,"private AddedAssetEvent(String assetName,String name){
  this.assetName=assetName;
  this.name=name;
}","private AddedAssetEvent(String assetName,String name,Set<Class> viewTypes){
  this.assetName=assetName;
  this.name=name;
  this.viewTypes=viewTypes;
}"
55187,"@NotNull public static AddedAssetEvent of(String assetName,String name){
  return new AddedAssetEvent(assetName,name);
}","@NotNull public static AddedAssetEvent of(String assetName,String name,Set<Class> viewTypes){
  return new AddedAssetEvent(assetName,name,viewTypes);
}"
55188,"private ExistingAssetEvent(String assetName,String name){
  this.assetName=assetName;
  this.classes=Collections.emptySet();
  this.name=name;
}","private ExistingAssetEvent(String assetName,String name,Set<Class> viewTypes){
  this.assetName=assetName;
  this.name=name;
  this.classes=viewTypes;
}"
55189,"/** 
 * @param assetName the name of the asset path
 * @param name      the name of the asset
 * @return an instance of ExistingAssetEvent
 * @deprecated only used for testing, use net.openhft.chronicle.engine.tree"" +"".ExistingAssetEvent#of(java.lang.String, net.openhft.chronicle.engine.api.tree"" + "".Asset) instead
 */
@Deprecated() @NotNull public static ExistingAssetEvent of(String assetName,String name){
  return new ExistingAssetEvent(assetName,name);
}","@NotNull public static ExistingAssetEvent of(String assetName,String name,Set<Class> viewTypes){
  return new ExistingAssetEvent(assetName,name,viewTypes);
}"
55190,"@NotNull public static RemovedAssetEvent of(String assetName,String name){
  return new RemovedAssetEvent(assetName,name);
}","@NotNull public static RemovedAssetEvent of(String assetName,String name,Set<Class> viewTypes){
  return new RemovedAssetEvent(assetName,name,viewTypes);
}"
55191,"private RemovedAssetEvent(String assetName,String name){
  this.assetName=assetName;
  this.name=name;
}","private RemovedAssetEvent(String assetName,String name,Set<Class> viewTypes){
  this.assetName=assetName;
  this.name=name;
  this.viewTypes=viewTypes;
}"
55192,"@Override public void removeChild(String name){
  Asset removed=children.remove(name);
  if (removed == null)   return;
  TopologySubscription topologySubscription=removed.findView(TopologySubscription.class);
  if (topologySubscription != null)   topologySubscription.notifyEvent(RemovedAssetEvent.of(fullName(),name));
}","@Override public void removeChild(String name){
  Asset removed=children.remove(name);
  if (removed == null)   return;
  TopologySubscription topologySubscription=removed.findView(TopologySubscription.class);
  if (topologySubscription != null)   topologySubscription.notifyEvent(RemovedAssetEvent.of(fullName(),name,viewTypes()));
}"
55193,"private <V>V addView0(Class<V> viewType,V view){
  if (view instanceof KeyedView)   keyedAsset=((KeyedView)view).keyedView();
  Object o=viewMap.putIfAbsent(viewType,view);
  return view;
}","private <V>V addView0(Class<V> viewType,V view){
  if (view instanceof KeyedView)   keyedAsset=((KeyedView)view).keyedView();
  Object o=viewMap.putIfAbsent(viewType,view);
  TopologySubscription topologySubscription=this.root().findView(TopologySubscription.class);
  if (topologySubscription != null) {
    String parentName=parent == null ? ""String_Node_Str"" : parent.fullName();
    if (o == null) {
      topologySubscription.notifyEvent(AddedAssetEvent.of(parentName,name,viewTypes()));
    }
 else {
      topologySubscription.notifyEvent(ExistingAssetEvent.of(parentName,name,viewTypes()));
    }
  }
  return view;
}"
55194,"void bootstrapTree(@NotNull Asset asset,@NotNull Subscriber<TopologicalEvent> subscriber) throws InvalidSubscriberException {
  asset.forEachChild(c -> {
    subscriber.onMessage(ExistingAssetEvent.of(asset.fullName(),c));
    bootstrapTree(c,subscriber);
  }
);
}","void bootstrapTree(@NotNull Asset asset,@NotNull Subscriber<TopologicalEvent> subscriber) throws InvalidSubscriberException {
  asset.forEachChild(c -> {
    subscriber.onMessage(ExistingAssetEvent.of(asset.fullName(),c.name(),c.viewTypes()));
    bootstrapTree(c,subscriber);
  }
);
}"
55195,"@Override public void registerSubscriber(@NotNull RequestContext rc,@NotNull Subscriber<TopologicalEvent> subscriber,@NotNull Filter<TopologicalEvent> filter){
  try {
    if (rc.bootstrap() != Boolean.FALSE) {
      Asset parent=asset.parent();
      String assetName=parent == null ? null : parent.fullName();
      subscriber.onMessage(ExistingAssetEvent.of(assetName,asset));
      bootstrapTree(asset,subscriber);
    }
    subscribers.add(subscriber);
  }
 catch (  InvalidSubscriberException e) {
    Jvm.debug().on(getClass(),""String_Node_Str"" + subscriber,e);
  }
}","@Override public void registerSubscriber(@NotNull RequestContext rc,@NotNull Subscriber<TopologicalEvent> subscriber,@NotNull Filter<TopologicalEvent> filter){
  try {
    if (rc.bootstrap() != Boolean.FALSE) {
      Asset parent=asset.parent();
      String assetName=parent == null ? null : parent.fullName();
      subscriber.onMessage(ExistingAssetEvent.of(assetName,asset.name(),asset.viewTypes()));
      bootstrapTree(asset,subscriber);
    }
    subscribers.add(subscriber);
  }
 catch (  InvalidSubscriberException e) {
    Jvm.debug().on(getClass(),""String_Node_Str"" + subscriber,e);
  }
}"
55196,"@Ignore(""String_Node_Str"") @Test public void testSubscriptionsAtEachLevel() throws InvalidSubscriberException {
  AssetTree tree=new VanillaAssetTree().forTesting();
  Subscriber<TopologicalEvent> rootTopoSubscriber=createMock(""String_Node_Str"",Subscriber.class);
  Subscriber<MapEvent> rootMapSubscriber=createMock(Subscriber.class);
  Subscriber<String> rootNameSubscriber=createMock(Subscriber.class);
  TopicSubscriber<String,String> rootTopicSubscriber=createMock(TopicSubscriber.class);
  rootTopoSubscriber.onMessage(ExistingAssetEvent.of(null,""String_Node_Str""));
  rootTopoSubscriber.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  rootTopoSubscriber.onMessage(AddedAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  replay(rootTopoSubscriber,rootMapSubscriber,rootNameSubscriber,rootTopicSubscriber);
  tree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,rootTopoSubscriber);
  tree.registerSubscriber(""String_Node_Str"",MapEvent.class,rootMapSubscriber);
  tree.registerSubscriber(""String_Node_Str"",String.class,rootNameSubscriber);
  tree.registerTopicSubscriber(""String_Node_Str"",String.class,String.class,rootTopicSubscriber);
  Subscriber<TopologicalEvent> rootTopoSubscriber1=createMock(""String_Node_Str"",Subscriber.class);
  Subscriber<MapEvent> rootMapSubscriber1=createMock(Subscriber.class);
  Subscriber<String> rootNameSubscriber1=createMock(Subscriber.class);
  TopicSubscriber<String,String> rootTopicSubscriber1=createMock(TopicSubscriber.class);
  rootTopoSubscriber1.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  replay(rootTopoSubscriber1,rootMapSubscriber1,rootNameSubscriber1,rootTopicSubscriber1);
  tree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,rootTopoSubscriber1);
  tree.registerSubscriber(""String_Node_Str"",MapEvent.class,rootMapSubscriber1);
  tree.registerSubscriber(""String_Node_Str"",String.class,rootNameSubscriber1);
  tree.registerTopicSubscriber(""String_Node_Str"",String.class,String.class,rootTopicSubscriber1);
  verify(rootTopoSubscriber,rootMapSubscriber,rootNameSubscriber,rootTopicSubscriber);
  verify(rootTopoSubscriber1,rootMapSubscriber1,rootNameSubscriber1,rootTopicSubscriber1);
  Subscriber<TopologicalEvent> rootTopoSubscriber0=createMock(""String_Node_Str"",Subscriber.class);
  rootTopoSubscriber0.onMessage(ExistingAssetEvent.of(null,""String_Node_Str""));
  rootTopoSubscriber0.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  rootTopoSubscriber0.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  replay(rootTopoSubscriber0);
  tree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,rootTopoSubscriber0);
  verify(rootTopoSubscriber0);
  reset(rootTopoSubscriber,rootTopoSubscriber0,rootTopoSubscriber1);
  rootTopoSubscriber.onMessage(RemovedAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  rootTopoSubscriber0.onMessage(RemovedAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  rootTopoSubscriber1.onMessage(RemovedAssetEvent.of(""String_Node_Str"",""String_Node_Str""));
  replay(rootTopoSubscriber,rootTopoSubscriber0,rootTopoSubscriber1);
  tree.getAsset(""String_Node_Str"").removeChild(""String_Node_Str"");
  verify(rootTopoSubscriber,rootTopoSubscriber0,rootTopoSubscriber1);
}","@Ignore(""String_Node_Str"") @Test public void testSubscriptionsAtEachLevel() throws InvalidSubscriberException {
  AssetTree tree=new VanillaAssetTree().forTesting();
  Subscriber<TopologicalEvent> rootTopoSubscriber=createMock(""String_Node_Str"",Subscriber.class);
  Subscriber<MapEvent> rootMapSubscriber=createMock(Subscriber.class);
  Subscriber<String> rootNameSubscriber=createMock(Subscriber.class);
  TopicSubscriber<String,String> rootTopicSubscriber=createMock(TopicSubscriber.class);
  rootTopoSubscriber.onMessage(ExistingAssetEvent.of(null,""String_Node_Str"",Collections.emptySet()));
  rootTopoSubscriber.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  rootTopoSubscriber.onMessage(AddedAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  replay(rootTopoSubscriber,rootMapSubscriber,rootNameSubscriber,rootTopicSubscriber);
  tree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,rootTopoSubscriber);
  tree.registerSubscriber(""String_Node_Str"",MapEvent.class,rootMapSubscriber);
  tree.registerSubscriber(""String_Node_Str"",String.class,rootNameSubscriber);
  tree.registerTopicSubscriber(""String_Node_Str"",String.class,String.class,rootTopicSubscriber);
  Subscriber<TopologicalEvent> rootTopoSubscriber1=createMock(""String_Node_Str"",Subscriber.class);
  Subscriber<MapEvent> rootMapSubscriber1=createMock(Subscriber.class);
  Subscriber<String> rootNameSubscriber1=createMock(Subscriber.class);
  TopicSubscriber<String,String> rootTopicSubscriber1=createMock(TopicSubscriber.class);
  rootTopoSubscriber1.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  replay(rootTopoSubscriber1,rootMapSubscriber1,rootNameSubscriber1,rootTopicSubscriber1);
  tree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,rootTopoSubscriber1);
  tree.registerSubscriber(""String_Node_Str"",MapEvent.class,rootMapSubscriber1);
  tree.registerSubscriber(""String_Node_Str"",String.class,rootNameSubscriber1);
  tree.registerTopicSubscriber(""String_Node_Str"",String.class,String.class,rootTopicSubscriber1);
  verify(rootTopoSubscriber,rootMapSubscriber,rootNameSubscriber,rootTopicSubscriber);
  verify(rootTopoSubscriber1,rootMapSubscriber1,rootNameSubscriber1,rootTopicSubscriber1);
  Subscriber<TopologicalEvent> rootTopoSubscriber0=createMock(""String_Node_Str"",Subscriber.class);
  rootTopoSubscriber0.onMessage(ExistingAssetEvent.of(null,""String_Node_Str"",Collections.emptySet()));
  rootTopoSubscriber0.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  rootTopoSubscriber0.onMessage(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  replay(rootTopoSubscriber0);
  tree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,rootTopoSubscriber0);
  verify(rootTopoSubscriber0);
  reset(rootTopoSubscriber,rootTopoSubscriber0,rootTopoSubscriber1);
  rootTopoSubscriber.onMessage(RemovedAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  rootTopoSubscriber0.onMessage(RemovedAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  rootTopoSubscriber1.onMessage(RemovedAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()));
  replay(rootTopoSubscriber,rootTopoSubscriber0,rootTopoSubscriber1);
  tree.getAsset(""String_Node_Str"").removeChild(""String_Node_Str"");
  verify(rootTopoSubscriber,rootTopoSubscriber0,rootTopoSubscriber1);
}"
55197,"public TypographyTest(Boolean isRemote) throws Exception {
  if (isRemote) {
    VanillaAssetTree assetTree0=new VanillaAssetTree().forTesting();
    String hostPortDescription=""String_Node_Str"" + methodName;
    TCPRegistry.createServerSocketChannelFor(hostPortDescription);
    serverEndpoint=new ServerEndpoint(hostPortDescription,assetTree0);
    final VanillaAssetTree client=new VanillaAssetTree();
    assetTree=client.forRemoteAccess(hostPortDescription,WireType.BINARY);
  }
 else {
    assetTree=(new VanillaAssetTree(1)).forTesting();
    serverEndpoint=null;
  }
}","public TypographyTest(Boolean isRemote) throws Exception {
  if (isRemote) {
    VanillaAssetTree assetTree0=new VanillaAssetTree().forTesting();
    String hostPortDescription=""String_Node_Str"" + methodName;
    TCPRegistry.createServerSocketChannelFor(hostPortDescription);
    serverEndpoint=new ServerEndpoint(hostPortDescription,assetTree0);
    final VanillaAssetTree client=new VanillaAssetTree();
    assetTree=client.forRemoteAccess(hostPortDescription,WireType.BINARY);
    Executors.newScheduledThreadPool(1).schedule((Runnable)() -> {
      assetTree0.acquireMap(ADD_MAP_LATER,String.class,String.class).size();
    }
,500,TimeUnit.MILLISECONDS);
  }
 else {
    assetTree=(new VanillaAssetTree(1)).forTesting();
    assetTree.acquireMap(ADD_MAP_LATER,String.class,String.class).size();
    serverEndpoint=null;
  }
}"
55198,"@Parameterized.Parameters public static Collection<Object[]> data(){
  return Arrays.asList(new Boolean[][]{{true},{true}});
}","@Parameterized.Parameters public static Collection<Object[]> data(){
  return Arrays.asList(new Boolean[][]{{false},{true}});
}"
55199,"@Ignore(""String_Node_Str"") @Test public void testTopologicalEvents() throws IOException, InterruptedException {
  final BlockingQueue<TopologicalEvent> eventsQueue=new LinkedBlockingQueue<>();
  yamlLoggger(() -> {
    try {
      YamlLogging.writeMessage(""String_Node_Str"" + ""String_Node_Str"");
      Subscriber<TopologicalEvent> subscription=eventsQueue::add;
      clientAssetTree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,subscription);
{
        TopologicalEvent take=eventsQueue.poll(1,SECONDS);
        Assert.assertEquals(ExistingAssetEvent.of(null,""String_Node_Str""),take);
      }
{
        clientAssetTree.acquireMap(""String_Node_Str"" + NAME,String.class,String.class).size();
{
          TopologicalEvent take=eventsQueue.poll(1,SECONDS);
          Assert.assertEquals(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str""),take);
        }
{
          TopologicalEvent take=eventsQueue.poll(1,SECONDS);
          Assert.assertEquals(AddedAssetEvent.of(""String_Node_Str"",""String_Node_Str""),take);
        }
{
          TopologicalEvent take=eventsQueue.poll(1,SECONDS);
          Assert.assertEquals(AddedAssetEvent.of(""String_Node_Str"",NAME),take);
        }
      }
{
        serverAssetTree.acquireMap(""String_Node_Str"" + NAME + 2,String.class,String.class);
        TopologicalEvent take3=eventsQueue.poll(1,SECONDS);
        Assert.assertEquals(AddedAssetEvent.of(""String_Node_Str"",NAME + 2),take3);
      }
{
        serverAssetTree.acquireAsset(""String_Node_Str"").removeChild(NAME);
        TopologicalEvent take4=eventsQueue.poll(1,SECONDS);
        Assert.assertEquals(RemovedAssetEvent.of(""String_Node_Str"",NAME),take4);
      }
      clientAssetTree.unregisterSubscriber(NAME,subscription);
    }
 catch (    Exception e) {
      throw Jvm.rethrow(e);
    }
  }
);
}","@Ignore(""String_Node_Str"") @Test public void testTopologicalEvents() throws IOException, InterruptedException {
  final BlockingQueue<TopologicalEvent> eventsQueue=new LinkedBlockingQueue<>();
  yamlLoggger(() -> {
    try {
      YamlLogging.writeMessage(""String_Node_Str"" + ""String_Node_Str"");
      Subscriber<TopologicalEvent> subscription=eventsQueue::add;
      clientAssetTree.registerSubscriber(""String_Node_Str"",TopologicalEvent.class,subscription);
{
        TopologicalEvent take=eventsQueue.poll(1,SECONDS);
        Assert.assertEquals(ExistingAssetEvent.of(null,""String_Node_Str"",Collections.emptySet()),take);
      }
{
        clientAssetTree.acquireMap(""String_Node_Str"" + NAME,String.class,String.class).size();
{
          TopologicalEvent take=eventsQueue.poll(1,SECONDS);
          Assert.assertEquals(ExistingAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()),take);
        }
{
          TopologicalEvent take=eventsQueue.poll(1,SECONDS);
          Assert.assertEquals(AddedAssetEvent.of(""String_Node_Str"",""String_Node_Str"",Collections.emptySet()),take);
        }
{
          TopologicalEvent take=eventsQueue.poll(1,SECONDS);
          Assert.assertEquals(AddedAssetEvent.of(""String_Node_Str"",NAME,Collections.emptySet()),take);
        }
      }
{
        serverAssetTree.acquireMap(""String_Node_Str"" + NAME + 2,String.class,String.class);
        TopologicalEvent take3=eventsQueue.poll(1,SECONDS);
        Assert.assertEquals(AddedAssetEvent.of(""String_Node_Str"",NAME + 2,Collections.emptySet()),take3);
      }
{
        serverAssetTree.acquireAsset(""String_Node_Str"").removeChild(NAME);
        TopologicalEvent take4=eventsQueue.poll(1,SECONDS);
        Assert.assertEquals(RemovedAssetEvent.of(""String_Node_Str"",NAME,Collections.emptySet()),take4);
      }
      clientAssetTree.unregisterSubscriber(NAME,subscription);
    }
 catch (    Exception e) {
      throw Jvm.rethrow(e);
    }
  }
);
}"
55200,"@NotNull @Override public <V>V acquireView(@NotNull Class<V> viewType,@NotNull RequestContext rc) throws AssetNotFoundException {
}","@NotNull @Override public <V>V acquireView(@NotNull Class<V> viewType,@NotNull RequestContext rc) throws AssetNotFoundException {
  if (!fullName().equals(rc.fullName())) {
    Asset asset=this.root().acquireAsset(rc.fullName());
    return asset.acquireView(rc);
  }
synchronized (viewMap) {
    V view=getView(viewType);
    if (view != null) {
      return view;
    }
    return Threads.withThreadGroup(findView(ThreadGroup.class),() -> {
      V leafView=createLeafView(viewType,rc,this);
      if (leafView instanceof MapView && viewType == QueueView.class)       addView(MapView.class,(MapView)leafView);
      if (leafView != null)       return addView(viewType,leafView);
      V wrappingView=createWrappingView(viewType,rc,this,null);
      if (wrappingView == null)       throw new AssetNotFoundException(""String_Node_Str"" + viewType.getName() + ""String_Node_Str""+ rc);
      return addView(viewType,wrappingView);
    }
);
  }
}"
55201,"@NotNull @Override public Asset acquireAsset(@NotNull String childName){
  if (keyedAsset != Boolean.TRUE) {
    int pos=childName.indexOf('/');
    if (pos == 0) {
      childName=childName.substring(1);
      pos=childName.indexOf('/');
    }
    if (pos > 0) {
      String name1=childName.substring(0,pos);
      String name2=childName.substring(pos + 1);
      return getAssetOrANFE(name1).acquireAsset(name2);
    }
  }
  return getAssetOrANFE(childName);
}","@NotNull @Override public Asset acquireAsset(@NotNull String childName){
  if (""String_Node_Str"".contentEquals(childName))   return root();
  if (keyedAsset != Boolean.TRUE) {
    int pos=childName.indexOf('/');
    if (pos == 0) {
      childName=childName.substring(1);
      pos=childName.indexOf('/');
    }
    if (pos > 0) {
      String name1=childName.substring(0,pos);
      String name2=childName.substring(pos + 1);
      return getAssetOrANFE(name1).acquireAsset(name2);
    }
  }
  return getAssetOrANFE(childName);
}"
55202,"public TypographyTest(Boolean isRemote) throws Exception {
  if (isRemote) {
    VanillaAssetTree assetTree0=new VanillaAssetTree().forTesting();
    assetTree0.acquireMap(""String_Node_Str"",String.class,String.class);
    assetTree0.acquireMap(""String_Node_Str"",String.class,String.class);
    String hostPortDescription=""String_Node_Str"" + methodName;
    TCPRegistry.createServerSocketChannelFor(hostPortDescription);
    serverEndpoint=new ServerEndpoint(hostPortDescription,assetTree0);
    final VanillaAssetTree client=new VanillaAssetTree();
    assetTree=client.forRemoteAccess(hostPortDescription,WireType.BINARY);
  }
 else {
    assetTree=(new VanillaAssetTree(1)).forTesting();
    serverEndpoint=null;
  }
}","public TypographyTest(Boolean isRemote) throws Exception {
  if (isRemote) {
    VanillaAssetTree assetTree0=new VanillaAssetTree().forTesting();
    String hostPortDescription=""String_Node_Str"" + methodName;
    TCPRegistry.createServerSocketChannelFor(hostPortDescription);
    serverEndpoint=new ServerEndpoint(hostPortDescription,assetTree0);
    final VanillaAssetTree client=new VanillaAssetTree();
    assetTree=client.forRemoteAccess(hostPortDescription,WireType.BINARY);
  }
 else {
    assetTree=(new VanillaAssetTree(1)).forTesting();
    serverEndpoint=null;
  }
}"
55203,"public void replication(RequestContext context,Asset asset){
  final HostIdentifier hostIdentifier;
  try {
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
  }
 catch (  AssetNotFoundException anfe) {
    if (LOG.isDebugEnabled())     Jvm.debug().on(getClass(),""String_Node_Str"" + anfe.getMessage());
    return;
  }
  final int remoteSourceIdentifier=queueConfig.sourceHostId(context.fullName());
  isSource=hostIdentifier.hostId() == remoteSourceIdentifier;
  isReplicating=true;
  final Clusters clusters=asset.findView(Clusters.class);
  if (clusters == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    Jvm.debug().on(getClass(),""String_Node_Str"" + context.cluster());
    return;
  }
  final EngineCluster engineCluster=clusters.get(context.cluster());
  final String csp=context.fullName();
  if (engineCluster == null) {
    Jvm.warn().on(getClass(),""String_Node_Str"" + context.cluster());
    return;
  }
  byte localIdentifier=hostIdentifier.hostId();
  if (LOG.isDebugEnabled())   Jvm.debug().on(getClass(),""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ engineCluster.hostDetails());
  final boolean acknowledgement=queueConfig.acknowledgment();
  final MessageAdaptor messageAdaptor=queueConfig.bytesFunction();
  for (  EngineHostDetails hostDetails : engineCluster.hostDetails()) {
    byte remoteIdentifier=(byte)hostDetails.hostId();
    if (remoteIdentifier == localIdentifier)     continue;
    engineCluster.findConnectionManager(remoteIdentifier).addListener((nc,isConnected) -> {
      if (!isConnected)       return;
      if (nc.isAcceptor())       return;
      final boolean isSource0=(remoteIdentifier == remoteSourceIdentifier);
      WriteMarshallable h=isSource0 ? newSource(chronicleQueue.createTailer().toEnd().index(),context.topicType(),context.elementType(),acknowledgement,messageAdaptor) : newSync(context.topicType(),context.elementType(),acknowledgement,messageAdaptor,chronicleQueue.wireType());
      long cid=nc.newCid();
      nc.wireOutPublisher().publish(w -> w.writeDocument(true,d -> d.writeEventName(CoreFields.csp).text(csp).writeEventName(CoreFields.cid).int64(cid).writeEventName(CoreFields.handler).typedMarshallable(h)));
    }
);
  }
}","public void replication(RequestContext context,Asset asset){
  final HostIdentifier hostIdentifier;
  try {
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
  }
 catch (  AssetNotFoundException anfe) {
    if (LOG.isDebugEnabled())     Jvm.debug().on(getClass(),""String_Node_Str"" + anfe.getMessage());
    return;
  }
  final int remoteSourceIdentifier=queueConfig.sourceHostId(context.fullName());
  isSource=hostIdentifier.hostId() == remoteSourceIdentifier;
  isReplicating=true;
  final Clusters clusters=asset.findView(Clusters.class);
  if (clusters == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    Jvm.debug().on(getClass(),""String_Node_Str"" + context.cluster());
    return;
  }
  final EngineCluster engineCluster=clusters.get(context.cluster());
  final String csp=context.fullName();
  if (engineCluster == null) {
    Jvm.debug().on(getClass(),""String_Node_Str"" + context.cluster());
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  byte localIdentifier=hostIdentifier.hostId();
  if (LOG.isDebugEnabled())   Jvm.debug().on(getClass(),""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ engineCluster.hostDetails());
  final boolean acknowledgement=queueConfig.acknowledgment();
  final MessageAdaptor messageAdaptor=queueConfig.bytesFunction();
  for (  EngineHostDetails hostDetails : engineCluster.hostDetails()) {
    byte remoteIdentifier=(byte)hostDetails.hostId();
    if (remoteIdentifier == localIdentifier)     continue;
    engineCluster.findConnectionManager(remoteIdentifier).addListener((nc,isConnected) -> {
      if (!isConnected)       return;
      if (nc.isAcceptor())       return;
      final boolean isSource0=(remoteIdentifier == remoteSourceIdentifier);
      WriteMarshallable h=isSource0 ? newSource(chronicleQueue.createTailer().toEnd().index(),context.topicType(),context.elementType(),acknowledgement,messageAdaptor) : newSync(context.topicType(),context.elementType(),acknowledgement,messageAdaptor,chronicleQueue.wireType());
      long cid=nc.newCid();
      nc.wireOutPublisher().publish(w -> w.writeDocument(true,d -> d.writeEventName(CoreFields.csp).text(csp).writeEventName(CoreFields.cid).int64(cid).writeEventName(CoreFields.handler).typedMarshallable(h)));
    }
);
  }
}"
55204,"private QueueView acquireQV(){
  if (qv != null)   return qv;
  String path=""String_Node_Str"" + localIdentifier;
  RequestContext requestContext=requestContext(path).elementType(NetworkStats.class).cluster(clusterName());
  qv=asset.root().acquireAsset(requestContext.fullName()).acquireView(QueueView.class,requestContext);
  return qv;
}","private QueueView acquireQV(){
  if (qv != null)   return qv;
  String path=""String_Node_Str"" + localIdentifier;
  RequestContext requestContext=requestContext(path).elementType(NetworkStats.class);
  if (ChronicleQueueView.isQueueReplicationAvailable())   requestContext.cluster(clusterName());
  qv=asset.root().acquireAsset(requestContext.fullName()).acquireView(QueueView.class,requestContext);
  return qv;
}"
55205,"/** 
 * Add an implementation of a view to the asset.. This can be used instead of, or in addition to adding rules.
 * @param viewType to associate this implementation with.
 * @param view
 * @return the view provided.
 */
<V>V addView(Class<V> viewType,V view);","default <V>V addView(V view){
  return addView((Class<V>)view.getClass(),view);
}"
55206,"@Override public ClustersCfg install(String path,AssetTree assetTree) throws Exception {
  assetTree.root().addView(Clusters.class,clusters);
  return this;
}","@Override public ClustersCfg install(String path,AssetTree assetTree) throws Exception {
  assetTree.root().addView(Clusters.class,clusters);
  clusters.install(assetTree);
  return this;
}"
55207,"private void readMarshallable(String path,WireIn wire){
  StringBuilder name=new StringBuilder();
  while (wire.hasMore()) {
    ValueIn in=wire.read(name);
    long pos=wire.bytes().readPosition();
    String path2=path + ""String_Node_Str"" + name;
    if (wire.getValueIn().isTyped()) {
      wire.bytes().readPosition(pos);
      Object o=in.typedMarshallable();
      installableMap.put(path2,(Installable)o);
    }
 else {
      in.marshallable(w -> this.readMarshallable(path2,w));
    }
  }
}","private void readMarshallable(String path,WireIn wire){
  StringBuilder name=new StringBuilder();
  while (!wire.isEmpty()) {
    ValueIn in=wire.read(name);
    long pos=wire.bytes().readPosition();
    String path2=path + ""String_Node_Str"" + name;
    if (wire.getValueIn().isTyped()) {
      wire.bytes().readPosition(pos);
      Object o=in.typedMarshallable();
      installableMap.put(path2,(Installable)o);
    }
 else {
      in.marshallable(w -> this.readMarshallable(path2,w));
    }
  }
}"
55208,"@Override public Void install(String path,AssetTree assetTree) throws IOException {
  String uri=path + ""String_Node_Str"" + putReturnsNull+ ""String_Node_Str""+ removeReturnsNull;
  MapView mapView=assetTree.acquireMap(uri,keyType,valueType);
  if (importFile != null) {
    Wire wire=Wire.fromFile(importFile);
    StringBuilder keyStr=new StringBuilder();
    while (wire.hasMore()) {
      Object value=wire.readEventName(keyStr).object(valueType);
      Object key=ObjectUtils.convertTo(keyType,keyStr);
      mapView.put(key,value);
    }
  }
  LOGGER.info(""String_Node_Str"" + path + ""String_Node_Str""+ mapView.size());
  return null;
}","@Override public Void install(String path,AssetTree assetTree) throws IOException {
  String uri=path + ""String_Node_Str"" + putReturnsNull+ ""String_Node_Str""+ removeReturnsNull;
  MapView mapView=assetTree.acquireMap(uri,keyType,valueType);
  if (importFile != null) {
    Wire wire=Wire.fromFile(importFile);
    StringBuilder keyStr=new StringBuilder();
    while (!wire.isEmpty()) {
      Object value=wire.readEventName(keyStr).object(valueType);
      Object key=ObjectUtils.convertTo(keyType,keyStr);
      mapView.put(key,value);
    }
  }
  LOGGER.info(""String_Node_Str"" + path + ""String_Node_Str""+ mapView.size());
  return null;
}"
55209,"@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  wire.read(() -> ""String_Node_Str"").typeLiteral(this,(o,c) -> o.keyType=c).read(() -> ""String_Node_Str"").typeLiteral(this,(o,c) -> o.valueType=c).read(() -> ""String_Node_Str"").text(this,(o,c) -> o.compression=c).read(() -> ""String_Node_Str"").bool(this,(o,e) -> o.putReturnsNull=e).read(() -> ""String_Node_Str"").bool(this,(o,e) -> o.removeReturnsNull=e);
  if (wire.hasMore())   wire.read(() -> ""String_Node_Str"").text(this,(o,s) -> o.importFile=s);
}","@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  wire.read(() -> ""String_Node_Str"").typeLiteral(this,(o,c) -> o.keyType=c).read(() -> ""String_Node_Str"").typeLiteral(this,(o,c) -> o.valueType=c).read(() -> ""String_Node_Str"").text(this,(o,c) -> o.compression=c).read(() -> ""String_Node_Str"").bool(this,(o,e) -> o.putReturnsNull=e).read(() -> ""String_Node_Str"").bool(this,(o,e) -> o.removeReturnsNull=e);
  while (!wire.isEmpty())   wire.read(() -> ""String_Node_Str"").text(this,(o,s) -> o.importFile=s);
}"
55210,"public Clusters(Map<String,EngineCluster> clusterMap){
  this.clusterMap=clusterMap;
}","public Clusters(Map<String,EngineCluster> clusterMap){
  this.clusterMap.putAll(clusterMap);
}"
55211,"@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  StringBuilder clusterName=Wires.acquireStringBuilder();
  while (wire.hasMore()) {
    wire.readEventName(clusterName).marshallable(host -> {
      EngineCluster engineCluster=clusterMap.computeIfAbsent(clusterName.toString(),EngineCluster::new);
      engineCluster.readMarshallable(host);
    }
);
  }
}","@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  StringBuilder clusterName=Wires.acquireStringBuilder();
  while (!wire.isEmpty()) {
    wire.readEventName(clusterName).marshallable(host -> {
      EngineCluster engineCluster=clusterMap.computeIfAbsent(clusterName.toString(),EngineCluster::new);
      engineCluster.readMarshallable(host);
    }
);
  }
}"
55212,"@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  StringBuilder mountDesc=new StringBuilder();
  while (wire.hasMore()) {
    MountPoint mp=wire.readEventName(mountDesc).typedMarshallable();
    mounts.put(mountDesc.toString(),mp);
  }
}","@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  StringBuilder mountDesc=new StringBuilder();
  while (!wire.isEmpty()) {
    MountPoint mp=wire.readEventName(mountDesc).typedMarshallable();
    mounts.put(mountDesc.toString(),mp);
  }
}"
55213,"@Override public void onRead(@NotNull WireIn inWire,@NotNull WireOut outWire){
  if (!inWire.hasMore())   return;
  inWire.read(() -> ""String_Node_Str"").text();
}","@Override public void onRead(@NotNull WireIn inWire,@NotNull WireOut outWire){
  if (inWire.isEmpty())   return;
  inWire.read(() -> ""String_Node_Str"").text();
}"
55214,"public ThrowingFunction<NetworkContext,TcpEventHandler,IOException> tcpEventHandlerFactory(){
  return (networkContext) -> {
    final EngineWireNetworkContext nc=(EngineWireNetworkContext)networkContext;
    if (nc.isAcceptor())     nc.wireOutPublisher(new VanillaWireOutPublisher(WireType.TEXT));
    networkContext.serverThreadingStrategy(ServerThreadingStrategy.CONCURRENT);
    final TcpEventHandler handler=new TcpEventHandler(networkContext);
    final Function<Object,TcpHandler> consumer=o -> {
      if (o instanceof SessionDetailsProvider) {
        final SessionDetailsProvider sessionDetails=(SessionDetailsProvider)o;
        nc.heartbeatTimeoutMs(heartbeatTimeoutMs());
        nc.sessionDetails(sessionDetails);
        nc.wireType(sessionDetails.wireType());
        final WireType wireType=nc.sessionDetails().wireType();
        if (wireType != null)         nc.wireOutPublisher().wireType(wireType);
        return new EngineWireHandler();
      }
 else       if (o instanceof TcpHandler)       return (TcpHandler)o;
      throw new UnsupportedOperationException(""String_Node_Str"" + o.getClass());
    }
;
    if (nc.networkStatsListener() == null) {
      nc.networkStatsListener(new NetworkStatsListener(){
        String host;
        long port;
        @Override public void onNetworkStats(        long writeBps,        long readBps,        long socketPollCountPerSecond,        @NotNull NetworkContext networkContext,        boolean connectionStatus){
          LOG.info(""String_Node_Str"" + writeBps / 1000 + ""String_Node_Str"" + readBps / 1000 + ""String_Node_Str"" + socketPollCountPerSecond + ""String_Node_Str"" + host + ""String_Node_Str"" + port);
        }
        @Override public void onHostPort(        String hostName,        int port){
          host=hostName;
          this.port=port;
        }
      }
);
    }
    final Function<EngineWireNetworkContext,TcpHandler> f=x -> new HeaderTcpHandler<>(handler,consumer,x);
    final WireTypeSniffingTcpHandler sniffer=new WireTypeSniffingTcpHandler<>(handler,nc,f);
    handler.tcpHandler(sniffer);
    return handler;
  }
;
}","public ThrowingFunction<NetworkContext,TcpEventHandler,IOException> tcpEventHandlerFactory(){
  return (networkContext) -> {
    final EngineWireNetworkContext nc=(EngineWireNetworkContext)networkContext;
    if (nc.isAcceptor())     nc.wireOutPublisher(new VanillaWireOutPublisher(WireType.TEXT));
    networkContext.serverThreadingStrategy(ServerThreadingStrategy.CONCURRENT);
    final TcpEventHandler handler=new TcpEventHandler(networkContext);
    final Function<Object,TcpHandler> consumer=o -> {
      if (o instanceof SessionDetailsProvider) {
        final SessionDetailsProvider sessionDetails=(SessionDetailsProvider)o;
        nc.heartbeatTimeoutMs(heartbeatTimeoutMs());
        nc.sessionDetails(sessionDetails);
        nc.wireType(sessionDetails.wireType());
        final WireType wireType=nc.sessionDetails().wireType();
        if (wireType != null)         nc.wireOutPublisher().wireType(wireType);
        return new EngineWireHandler();
      }
 else       if (o instanceof TcpHandler)       return (TcpHandler)o;
      throw new UnsupportedOperationException(""String_Node_Str"" + o.getClass());
    }
;
    if (nc.networkStatsListener() == null)     nc.networkStatsListener(defaultNetworkStatsListener);
    notifyHostPort(nc.socketChannel(),nc.networkStatsListener());
    final Function<EngineWireNetworkContext,TcpHandler> f=x -> new HeaderTcpHandler<>(handler,consumer,x);
    final WireTypeSniffingTcpHandler sniffer=new WireTypeSniffingTcpHandler<>(handler,nc,f);
    handler.tcpHandler(sniffer);
    return handler;
  }
;
}"
55215,"@Override public void onNetworkStats(long writeBps,long readBps,long socketPollCountPerSecond,@NotNull EngineWireNetworkContext nc,boolean isConnected){
  final WireNetworkStats wireNetworkStats=this.wireNetworkStats.get();
  wireNetworkStats.writeBps(writeBps);
  wireNetworkStats.readBps(readBps);
  wireNetworkStats.socketPollCountPerSecond(socketPollCountPerSecond);
  wireNetworkStats.timestamp(System.currentTimeMillis());
  wireNetworkStats.isConnected(isConnected);
  final SessionDetailsProvider sessionDetailsProvider=nc.sessionDetails();
  if (sessionDetailsProvider != null) {
    wireNetworkStats.clientId(sessionDetailsProvider.clientId());
    wireNetworkStats.userId(sessionDetailsProvider.userId());
  }
  acquireQV().publishAndIndex(""String_Node_Str"",wireNetworkStats);
}","@Override public void onNetworkStats(long writeBps,long readBps,long socketPollCountPerSecond,@NotNull EngineWireNetworkContext nc,boolean isConnected){
  wireNetworkStats.writeBps(writeBps);
  wireNetworkStats.readBps(readBps);
  wireNetworkStats.socketPollCountPerSecond(socketPollCountPerSecond);
  wireNetworkStats.timestamp(System.currentTimeMillis());
  wireNetworkStats.isConnected(isConnected);
  if (nc.handler() instanceof AbstractSubHandler) {
    final int remoteIdentifier=((AbstractSubHandler)nc.handler()).remoteIdentifier();
    wireNetworkStats.remoteIdentifier(remoteIdentifier);
  }
 else   if (nc.handler() instanceof UberHandler) {
    final UberHandler handler=(UberHandler)nc.handler();
    wireNetworkStats.remoteIdentifier(handler.remoteIdentifier());
    wireNetworkStats.wireType(handler.wireType());
  }
  final SessionDetailsProvider sessionDetailsProvider=nc.sessionDetails();
  if (sessionDetailsProvider != null) {
    wireNetworkStats.clientId(sessionDetailsProvider.clientId());
    wireNetworkStats.userId(sessionDetailsProvider.userId());
    wireNetworkStats.wireType(sessionDetailsProvider.wireType());
  }
  wireNetworkStats.localIdentifier(localIdentifier);
  acquireQV().publishAndIndex(""String_Node_Str"",wireNetworkStats);
}"
55216,"@Override public void onHostPort(String hostName,int port){
  final WireNetworkStats wireNetworkStats=this.wireNetworkStats.get();
  wireNetworkStats.host(hostName);
  wireNetworkStats.port(port);
}","@Override public void onHostPort(String hostName,int port){
  wireNetworkStats.remoteHostName(hostName);
  wireNetworkStats.remotePort(port);
}"
55217,"public EngineNetworkStatsListener(Asset asset,int localIdentifier){
  this.localIdentifier=localIdentifier;
  wireNetworkStats=ThreadLocal.withInitial(() -> new WireNetworkStats(localIdentifier));
  this.asset=asset;
}","public EngineNetworkStatsListener(Asset asset,int localIdentifier){
  this.localIdentifier=localIdentifier;
  this.asset=asset;
}"
55218,"public Predicate<Map.Entry<K,V>> filter(@NotNull ColumnView.Query query){
  return entry -> {
    if (query.marshableFilters.isEmpty())     return true;
    try {
      for (      MarshableFilter f : query.marshableFilters) {
        Object item;
        if (""String_Node_Str"".equals(f.columnName)) {
          item=entry.getKey();
        }
 else         if (!(AbstractMarshallable.class.isAssignableFrom(valueType())) && ""String_Node_Str"".equals(f.columnName)) {
          item=entry.getValue();
        }
 else         if (AbstractMarshallable.class.isAssignableFrom(valueType())) {
          try {
            final Class valueClass=entry.getValue().getClass();
            final Field field=valueClass.getDeclaredField(f.columnName);
            field.setAccessible(true);
            final Object o=field.get(entry.getValue());
            if (o == null)             return false;
            final String trimmed=f.filter.trim();
            if (o instanceof Number) {
              if (trimmed.startsWith(""String_Node_Str"") || trimmed.startsWith(""String_Node_Str"")) {
                final String number=trimmed.substring(1,trimmed.length()).trim();
                final Object filterNumber=convertTo(o.getClass(),number);
                boolean result;
                if (trimmed.startsWith(""String_Node_Str""))                 result=((Number)o).doubleValue() > ((Number)filterNumber).doubleValue();
 else                 if (trimmed.startsWith(""String_Node_Str""))                 result=((Number)o).doubleValue() < ((Number)filterNumber).doubleValue();
 else                 throw new UnsupportedOperationException();
                if (result)                 continue;
 else                 return false;
              }
 else {
                final Object filterNumber=convertTo(o.getClass(),trimmed);
                if (o.equals(filterNumber))                 continue;
 else                 return false;
              }
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        boolean result=(item instanceof CharSequence) ? item.toString().toLowerCase().contains(f.filter.toLowerCase()) : item.equals(convertTo(item.getClass(),f.filter.trim()));
        if (!result)         return false;
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}","public Predicate<Map.Entry<K,V>> filter(@NotNull ColumnView.Query query){
  return entry -> {
    if (query.marshableFilters.isEmpty())     return true;
    try {
      for (      MarshableFilter f : query.marshableFilters) {
        Object item;
        if (""String_Node_Str"".equals(f.columnName)) {
          item=entry.getKey();
        }
 else         if (!(AbstractMarshallable.class.isAssignableFrom(valueType())) && ""String_Node_Str"".equals(f.columnName)) {
          item=entry.getValue();
        }
 else         if (AbstractMarshallable.class.isAssignableFrom(valueType())) {
          try {
            final Class valueClass=entry.getValue().getClass();
            final Field field=valueClass.getDeclaredField(f.columnName);
            field.setAccessible(true);
            final Object o=field.get(entry.getValue());
            if (o == null)             return false;
            if (o instanceof Number) {
              if (toRange((Number)o,f.filter.trim()))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence)         if (item.toString().toLowerCase().contains(f.filter.toLowerCase()))         continue;
 else         return false;
 else         if (item instanceof Number) {
          if (toRange((Number)item,f.filter.trim()))           continue;
 else           return false;
        }
 else {
          if (item.equals(convertTo(item.getClass(),f.filter.trim())))           continue;
 else           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}"
55219,public ArrayList<String> columnNames();,ArrayList<String> columnNames();
55220,"@Override public Row next(){
  final Map.Entry e=core.next();
  final Row row=new Row(columnNames());
  if (!(Marshallable.class.isAssignableFrom(keyType())))   row.add(""String_Node_Str"",e.getKey());
 else   throw new UnsupportedOperationException(""String_Node_Str"");
  if (!(Marshallable.class.isAssignableFrom(valueType())))   row.add(""String_Node_Str"",e.getValue());
 else {
    final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      if (!columnNames.contains(declaredFields.getName()))       continue;
      try {
        declaredFields.setAccessible(true);
        row.add(declaredFields.getName(),declaredFields.get(value));
      }
 catch (      Exception e1) {
        Jvm.warn().on(VanillaMapView.class,e1);
      }
    }
  }
  return row;
}","@Override public Row next(){
  final Map.Entry e=core.next();
  final Row row=new Row(columnNames());
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   row.add(""String_Node_Str"",e.getKey());
 else   throw new UnsupportedOperationException(""String_Node_Str"");
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   row.add(""String_Node_Str"",e.getValue());
 else {
    final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      if (!columnNames.contains(declaredFields.getName()))       continue;
      try {
        declaredFields.setAccessible(true);
        row.add(declaredFields.getName(),declaredFields.get(value));
      }
 catch (      Exception e1) {
        Jvm.warn().on(VanillaMapView.class,e1);
      }
    }
  }
  return row;
}"
55221,"@Override public List<Column> columns(){
  List<Column> result=new ArrayList<>();
  if (!(Marshallable.class.isAssignableFrom(keyType())))   result.add(new Column(""String_Node_Str"",false,false,false,true,""String_Node_Str"",String.class));
  if (!(Marshallable.class.isAssignableFrom(valueType())))   result.add(new Column(""String_Node_Str"",false,false,false,false,""String_Node_Str"",String.class));
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(new Column(declaredFields.getName(),false,false,false,false,""String_Node_Str"",declaredFields.getType()));
    }
  }
  return result;
}","@Override public List<Column> columns(){
  List<Column> result=new ArrayList<>();
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   result.add(new Column(""String_Node_Str"",false,false,false,true,""String_Node_Str"",keyType()));
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   result.add(new Column(""String_Node_Str"",false,false,false,false,""String_Node_Str"",valueType()));
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(new Column(declaredFields.getName(),false,false,false,false,""String_Node_Str"",declaredFields.getType()));
    }
  }
  return result;
}"
55222,"@Override public void onCellChanged(String columnName,K key,K oldKey,Object value,Object oldValue){
  if (!(Marshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put(key,kvStore.getAndRemove(oldKey));
    return;
  }
  if (!(Marshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put(key,(V)value);
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + columnName);
}","@Override public void onCellChanged(String columnName,K key,K oldKey,Object value,Object oldValue){
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put(key,kvStore.getAndRemove(oldKey));
    return;
  }
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put(key,(V)value);
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + columnName);
}"
55223,"@Override public Iterator<Row> iterator(ColumnView.Query<K> query){
  final Iterator<Map.Entry<K,V>> core=entrySet().stream().filter(query::filter).sorted(query.sorted()).iterator();
  Iterator<Row> result=new Iterator<Row>(){
    @Override public boolean hasNext(){
      return core.hasNext();
    }
    @Override public Row next(){
      final Map.Entry e=core.next();
      final Row row=new Row(columnNames());
      if (!(Marshallable.class.isAssignableFrom(keyType())))       row.add(""String_Node_Str"",e.getKey());
 else       throw new UnsupportedOperationException(""String_Node_Str"");
      if (!(Marshallable.class.isAssignableFrom(valueType())))       row.add(""String_Node_Str"",e.getValue());
 else {
        final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
        for (        final Field declaredFields : valueType().getDeclaredFields()) {
          if (!columnNames.contains(declaredFields.getName()))           continue;
          try {
            declaredFields.setAccessible(true);
            row.add(declaredFields.getName(),declaredFields.get(value));
          }
 catch (          Exception e1) {
            Jvm.warn().on(VanillaMapView.class,e1);
          }
        }
      }
      return row;
    }
  }
;
  long x=0;
  while (x++ < query.fromIndex && result.hasNext()) {
    result.next();
  }
  return result;
}","@Override public Iterator<Row> iterator(final ColumnView.Query<K> query){
  final Iterator<Map.Entry<K,V>> core=entrySet().stream().filter(query::filter).sorted(sort(query.marshableOrderBy)).iterator();
  Iterator<Row> result=new Iterator<Row>(){
    @Override public boolean hasNext(){
      return core.hasNext();
    }
    @Override public Row next(){
      final Map.Entry e=core.next();
      final Row row=new Row(columnNames());
      if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))       row.add(""String_Node_Str"",e.getKey());
 else       throw new UnsupportedOperationException(""String_Node_Str"");
      if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))       row.add(""String_Node_Str"",e.getValue());
 else {
        final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
        for (        final Field declaredFields : valueType().getDeclaredFields()) {
          if (!columnNames.contains(declaredFields.getName()))           continue;
          try {
            declaredFields.setAccessible(true);
            row.add(declaredFields.getName(),declaredFields.get(value));
          }
 catch (          Exception e1) {
            Jvm.warn().on(VanillaMapView.class,e1);
          }
        }
      }
      return row;
    }
  }
;
  long x=0;
  while (x++ < query.fromIndex && result.hasNext()) {
    result.next();
  }
  return result;
}"
55224,"@Override public ArrayList<String> columnNames(){
  if (columnNames != null)   return columnNames;
  LinkedHashSet<String> result=new LinkedHashSet<>();
  if (!(Marshallable.class.isAssignableFrom(keyType())))   result.add(""String_Node_Str"");
  if (!(Marshallable.class.isAssignableFrom(valueType())))   result.add(""String_Node_Str"");
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(declaredFields.getName());
    }
  }
  columnNames=new ArrayList<>(result);
  return columnNames;
}","@Override public ArrayList<String> columnNames(){
  if (columnNames != null)   return columnNames;
  LinkedHashSet<String> result=new LinkedHashSet<>();
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   result.add(""String_Node_Str"");
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   result.add(""String_Node_Str"");
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(declaredFields.getName());
    }
  }
  columnNames=new ArrayList<>(result);
  return columnNames;
}"
55225,"/** 
 * called when ever the user modify the cells and the data changes
 * @param columnName the column name of the cell
 * @param key        the rowID of the cell
 * @param oldKey     the old rowID of the cell
 * @param value      the new value of the cell
 * @param oldValue   the old value of the cell
 */
void onRowChanged(String columnName,K key,K oldKey,Object value,Object oldValue);","/** 
 * called when ever the user modify the cells and the data changes
 * @param columnName the column name of the cell
 * @param key        the rowID of the cell
 * @param oldKey     the old rowID of the cell
 * @param value      the new value of the cell
 * @param oldValue   the old value of the cell
 */
void onRowChanged(String columnName,Object key,Object oldKey,Object value,Object oldValue);"
55226,int rowCount(Query query);,int rowCount(@Nullable Query query);
55227,"/** 
 * @param columnNames all the column names that make up this row
 */
public Row(@NotNull List<String> columnNames){
  this.columnNames=columnNames;
}","/** 
 * @param columns all the column names that make up this row
 */
public Row(@NotNull List<Column> columns){
  columnNames=columns.stream().map(c -> c.name).collect(Collectors.toList());
}"
55228,"@Override public Row next(){
  final Map.Entry e=core.next();
  final Row row=new Row(columnNames());
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   row.set(""String_Node_Str"",e.getKey());
 else   throw new UnsupportedOperationException(""String_Node_Str"");
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   row.set(""String_Node_Str"",e.getValue());
 else {
    final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      if (!columnNames.contains(declaredFields.getName()))       continue;
      try {
        declaredFields.setAccessible(true);
        row.set(declaredFields.getName(),declaredFields.get(value));
      }
 catch (      Exception e1) {
        Jvm.warn().on(VanillaMapView.class,e1);
      }
    }
  }
  return row;
}","@Override public Row next(){
  final Map.Entry e=core.next();
  final Row row=new Row(columns());
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   row.set(""String_Node_Str"",e.getKey());
 else   throw new UnsupportedOperationException(""String_Node_Str"");
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   row.set(""String_Node_Str"",e.getValue());
 else {
    final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      if (!columnNames().contains(declaredFields.getName()))       continue;
      try {
        declaredFields.setAccessible(true);
        row.set(declaredFields.getName(),declaredFields.get(value));
      }
 catch (      Exception e1) {
        Jvm.warn().on(VanillaMapView.class,e1);
      }
    }
  }
  return row;
}"
55229,"@Override public Iterator<Row> iterator(final ColumnView.Query query){
  final Iterator<Map.Entry<K,V>> core=entrySet().stream().filter(filter(query)).sorted(sort(query.marshableOrderBy)).iterator();
  final Iterator<Row> result=new Iterator<Row>(){
    @Override public boolean hasNext(){
      return core.hasNext();
    }
    @Override public Row next(){
      final Map.Entry e=core.next();
      final Row row=new Row(columnNames());
      if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))       row.set(""String_Node_Str"",e.getKey());
 else       throw new UnsupportedOperationException(""String_Node_Str"");
      if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))       row.set(""String_Node_Str"",e.getValue());
 else {
        final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
        for (        final Field declaredFields : valueType().getDeclaredFields()) {
          if (!columnNames.contains(declaredFields.getName()))           continue;
          try {
            declaredFields.setAccessible(true);
            row.set(declaredFields.getName(),declaredFields.get(value));
          }
 catch (          Exception e1) {
            Jvm.warn().on(VanillaMapView.class,e1);
          }
        }
      }
      return row;
    }
  }
;
  long x=0;
  while (x++ < query.fromIndex && result.hasNext()) {
    result.next();
  }
  return result;
}","@Override public Iterator<Row> iterator(final ColumnView.Query query){
  final Iterator<Map.Entry<K,V>> core=entrySet().stream().filter(filter(query)).sorted(sort(query.marshableOrderBy)).iterator();
  final Iterator<Row> result=new Iterator<Row>(){
    @Override public boolean hasNext(){
      return core.hasNext();
    }
    @Override public Row next(){
      final Map.Entry e=core.next();
      final Row row=new Row(columns());
      if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))       row.set(""String_Node_Str"",e.getKey());
 else       throw new UnsupportedOperationException(""String_Node_Str"");
      if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))       row.set(""String_Node_Str"",e.getValue());
 else {
        final AbstractMarshallable value=(AbstractMarshallable)e.getValue();
        for (        final Field declaredFields : valueType().getDeclaredFields()) {
          if (!columnNames().contains(declaredFields.getName()))           continue;
          try {
            declaredFields.setAccessible(true);
            row.set(declaredFields.getName(),declaredFields.get(value));
          }
 catch (          Exception e1) {
            Jvm.warn().on(VanillaMapView.class,e1);
          }
        }
      }
      return row;
    }
  }
;
  long x=0;
  while (x++ < query.fromIndex && result.hasNext()) {
    result.next();
  }
  return result;
}"
55230,"@Override public void onRowChanged(String columnName,K key,K oldKey,Object value,Object oldValue){
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put(key,kvStore.getAndRemove(oldKey));
    return;
  }
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put(key,(V)value);
    return;
  }
  final V v=kvStore.get(key);
  if (!(v instanceof AbstractMarshallable))   throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  final Field field;
  try {
    field=v.getClass().getDeclaredField(columnName);
    field.setAccessible(true);
    field.set(v,value);
    kvStore.put(key,v);
  }
 catch (  Exception e) {
    Jvm.warn().on(VanillaMapView.class,e);
  }
}","@Override public void onRowChanged(String columnName,Object key,Object oldKey,Object value,Object oldValue){
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put((K)key,kvStore.getAndRemove((K)oldKey));
    return;
  }
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())) && ""String_Node_Str"".equals(columnName)) {
    kvStore.put((K)key,(V)value);
    return;
  }
  final V v=kvStore.get((K)key);
  if (!(v instanceof AbstractMarshallable))   throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  final Field field;
  try {
    field=v.getClass().getDeclaredField(columnName);
    field.setAccessible(true);
    field.set(v,value);
    kvStore.put((K)key,v);
  }
 catch (  Exception e) {
    Jvm.warn().on(VanillaMapView.class,e);
  }
}"
55231,"@Override public ArrayList<String> columnNames(){
  if (columnNames != null)   return columnNames;
  LinkedHashSet<String> result=new LinkedHashSet<>();
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   result.add(""String_Node_Str"");
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   result.add(""String_Node_Str"");
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(declaredFields.getName());
    }
  }
  columnNames=new ArrayList<>(result);
  return columnNames;
}","private ArrayList<String> columnNames(){
  if (columnNames != null)   return columnNames;
  LinkedHashSet<String> result=new LinkedHashSet<>();
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   result.add(""String_Node_Str"");
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   result.add(""String_Node_Str"");
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(declaredFields.getName());
    }
  }
  columnNames=new ArrayList<>(result);
  return columnNames;
}"
55232,"@Override public int rowCount(ColumnView.Query query){
  return (int)entrySet().stream().filter(filter(query)).count();
}","/** 
 * @param query if {@code query} == null all the total number of rows is returned
 * @return the number of rows the matches this query
 */
@Override public int rowCount(@Nullable ColumnView.Query query){
  if (query == null)   return (int)longSize();
  return (int)entrySet().stream().filter(filter(query)).count();
}"
55233,"public QueueWrappingColumnView(RequestContext requestContext,Asset asset,QueueView<String,V> queueView){
  this.queueView=queueView;
  final QueueView.Excerpt<String,V> excerpt=queueView.getExcerpt(0);
  messageClass=excerpt.message().getClass();
}","public QueueWrappingColumnView(RequestContext requestContext,Asset asset,QueueView<String,V> queueView){
  this.queueView=queueView;
  final QueueView.Excerpt<String,V> excerpt=queueView.getExcerpt(0);
  if (excerpt != null)   messageClass=excerpt.message().getClass();
 else   messageClass=Object.class;
}"
55234,"@Nullable public Predicate<QueueView.Excerpt<String,V>> filter(@NotNull List<MarshableFilter> filters){
  return excerpt -> {
    if (filters.isEmpty())     return true;
    try {
      for (      @NotNull MarshableFilter f : filters) {
        Object item;
        final Class messageClass=excerpt.message().getClass();
        if (AbstractMarshallable.class.isAssignableFrom(messageClass)) {
          try {
            final Field field=messageClass.getDeclaredField(f.columnName);
            field.setAccessible(true);
            final Object o=field.get(excerpt.message());
            if (o == null)             return false;
            if (o instanceof Number) {
              if (toRange((Number)o,f.filter.trim()))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence) {
          if (!item.toString().toLowerCase().contains(f.filter.toLowerCase()))           return false;
        }
 else         if (item instanceof Number) {
          if (!toRange((Number)item,f.filter.trim()))           return false;
        }
 else {
          if (!item.equals(convertTo(item.getClass(),f.filter.trim())))           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}","@Nullable public Predicate<QueueView.Excerpt<String,V>> filter(@Nullable List<MarshableFilter> filters){
  return excerpt -> {
    if (filters == null || filters.isEmpty())     return true;
    try {
      for (      @NotNull MarshableFilter f : filters) {
        Object item;
        final Class messageClass=excerpt.message().getClass();
        if (AbstractMarshallable.class.isAssignableFrom(messageClass)) {
          try {
            final Field field=messageClass.getDeclaredField(f.columnName);
            field.setAccessible(true);
            final Object o=field.get(excerpt.message());
            if (o == null)             return false;
            if (o instanceof Number) {
              if (toRange((Number)o,f.filter.trim()))               continue;
              return false;
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence) {
          if (!item.toString().toLowerCase().contains(f.filter.toLowerCase()))           return false;
        }
 else         if (item instanceof Number) {
          if (!toRange((Number)item,f.filter.trim()))           return false;
        }
 else {
          if (!item.equals(convertTo(item.getClass(),f.filter.trim())))           return false;
        }
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}"
55235,"@NotNull @Override public Iterator<Row> iterator(@NotNull final SortedFilter sortedFilter){
  final Iterator<QueueView.Excerpt<String,V>> i=new Iterator<QueueView.Excerpt<String,V>>(){
    QueueView.Excerpt<String,V> next=queueView.getExcerpt(0);
    @Override public boolean hasNext(){
      if (next == null)       next=queueView.getExcerpt(""String_Node_Str"");
      return next != null;
    }
    @Override public QueueView.Excerpt<String,V> next(){
      if (this.next == null)       throw new NoSuchElementException();
      try {
        return this.next;
      }
  finally {
        this.next=null;
      }
    }
  }
;
  final Stream<QueueView.Excerpt<String,V>> stream=StreamSupport.stream(spliteratorUnknownSize(i,Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED),false);
  final Iterator<QueueView.Excerpt<String,V>> core=stream.filter(filter(sortedFilter.marshableFilters)).iterator();
  @NotNull final Iterator<Row> result=new Iterator<Row>(){
    @Override public boolean hasNext(){
      return core.hasNext();
    }
    @NotNull @Override public Row next(){
      final QueueView.Excerpt<String,V> e=core.next();
      @NotNull final Row row=new Row(columns());
      @NotNull final AbstractMarshallable value=(AbstractMarshallable)e.message();
      row.set(""String_Node_Str"",Long.toHexString(e.index()) + ""String_Node_Str"");
      for (      @NotNull final Field declaredFields : value.getClass().getDeclaredFields()) {
        if (!columnNames().contains(declaredFields.getName()))         continue;
        try {
          declaredFields.setAccessible(true);
          row.set(declaredFields.getName(),declaredFields.get(value));
        }
 catch (        Exception e1) {
          Jvm.warn().on(VanillaMapView.class,e1);
        }
      }
      return row;
    }
  }
;
  long x=0;
  while (x++ < sortedFilter.fromIndex && result.hasNext()) {
    result.next();
  }
  return result;
}","@NotNull private Iterator<Row> iterator(@NotNull final List<MarshableFilter> filters,long fromIndex){
  if (fromIndex != 0)   System.out.println(""String_Node_Str"");
  final Iterator<QueueView.Excerpt<String,V>> i=new Iterator<QueueView.Excerpt<String,V>>(){
    QueueView.Excerpt<String,V> next=queueView.getExcerpt(0);
    @Override public boolean hasNext(){
      if (next == null)       next=queueView.getExcerpt(""String_Node_Str"");
      return next != null;
    }
    @Override public QueueView.Excerpt<String,V> next(){
      if (this.next == null)       throw new NoSuchElementException();
      try {
        return this.next;
      }
  finally {
        this.next=null;
      }
    }
  }
;
  final Spliterator<QueueView.Excerpt<String,V>> spliterator=spliteratorUnknownSize(i,Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED);
  final Iterator<QueueView.Excerpt<String,V>> core=StreamSupport.stream(spliterator,false).filter(filter(filters)).iterator();
  @NotNull final Iterator<Row> result=new Iterator<Row>(){
    @Override public boolean hasNext(){
      return core.hasNext();
    }
    @NotNull @Override public Row next(){
      final QueueView.Excerpt<String,V> e=core.next();
      @NotNull final Row row=new Row(columns());
      @NotNull final AbstractMarshallable value=(AbstractMarshallable)e.message();
      row.set(""String_Node_Str"",Long.toHexString(e.index()) + ""String_Node_Str"");
      for (      @NotNull final Field declaredFields : value.getClass().getDeclaredFields()) {
        if (!columnNames().contains(declaredFields.getName()))         continue;
        try {
          declaredFields.setAccessible(true);
          row.set(declaredFields.getName(),declaredFields.get(value));
        }
 catch (        Exception e1) {
          Jvm.warn().on(VanillaMapView.class,e1);
        }
      }
      return row;
    }
  }
;
  long x=0;
  while (x++ < fromIndex && result.hasNext()) {
    result.next();
  }
  return result;
}"
55236,"/** 
 * @param sortedFilter if {@code sortedFilter} == null or empty all the total number of rows isreturned
 * @return the number of rows the matches this query
 */
@Override public int rowCount(@Nullable List<MarshableFilter> sortedFilter){
  final QueueView.Excerpt<String,V> e=queueView.getExcerpt(0);
  if (e == null)   return 0;
  int count=1;
  while (queueView.getExcerpt(""String_Node_Str"") != null) {
    count++;
  }
  return count;
}","/** 
 * @param sortedFilter if {@code sortedFilter} == null or empty all the total number of rows isreturned
 * @return the number of rows the matches this query
 */
@Override public int rowCount(@Nullable List<MarshableFilter> sortedFilter){
  final Iterator<Row> iterator=iterator(sortedFilter,0);
  int count=0;
  while (iterator.hasNext()) {
    iterator.next();
    count++;
  }
  return count;
}"
55237,"public Predicate<Map.Entry<K,V>> filter(@NotNull ColumnView.Query<K> query){
  return entry -> {
    if (query.marshableFilters.isEmpty())     return true;
    try {
      for (      MarshableFilter f : query.marshableFilters) {
        Object item;
        if (""String_Node_Str"".equals(f.columnName)) {
          item=entry.getKey();
        }
 else         if (!(AbstractMarshallable.class.isAssignableFrom(valueType())) && ""String_Node_Str"".equals(f.columnName)) {
          item=entry.getValue();
        }
 else         if (AbstractMarshallable.class.isAssignableFrom(valueType())) {
          try {
            final Class valueClass=entry.getValue().getClass();
            final Field field=valueClass.getDeclaredField(f.columnName);
            field.setAccessible(true);
            final Object o=field.get(entry.getValue());
            if (o == null)             return false;
            final String trimmed=f.filter.trim();
            if (o instanceof Number) {
              if (trimmed.startsWith(""String_Node_Str"") || trimmed.startsWith(""String_Node_Str"")) {
                final String number=trimmed.substring(1,trimmed.length()).trim();
                final Object filterNumber=convertTo(o.getClass(),number);
                if (trimmed.startsWith(""String_Node_Str""))                 return ((Number)o).doubleValue() > ((Number)filterNumber).doubleValue();
 else                 if (trimmed.startsWith(""String_Node_Str""))                 return ((Number)o).doubleValue() < ((Number)filterNumber).doubleValue();
 else                 throw new UnsupportedOperationException();
              }
 else {
                final Object filterNumber=convertTo(o.getClass(),trimmed);
                return o.equals(filterNumber);
              }
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        if (item instanceof CharSequence)         return item.toString().toLowerCase().contains(f.filter.toLowerCase());
 else         return item.equals(convertTo(item.getClass(),f.filter.trim()));
      }
      return false;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}","public Predicate<Map.Entry<K,V>> filter(@NotNull ColumnView.Query<K> query){
  return entry -> {
    if (query.marshableFilters.isEmpty())     return true;
    try {
      for (      MarshableFilter f : query.marshableFilters) {
        Object item;
        if (""String_Node_Str"".equals(f.columnName)) {
          item=entry.getKey();
        }
 else         if (!(AbstractMarshallable.class.isAssignableFrom(valueType())) && ""String_Node_Str"".equals(f.columnName)) {
          item=entry.getValue();
        }
 else         if (AbstractMarshallable.class.isAssignableFrom(valueType())) {
          try {
            final Class valueClass=entry.getValue().getClass();
            final Field field=valueClass.getDeclaredField(f.columnName);
            field.setAccessible(true);
            final Object o=field.get(entry.getValue());
            if (o == null)             return false;
            final String trimmed=f.filter.trim();
            if (o instanceof Number) {
              if (trimmed.startsWith(""String_Node_Str"") || trimmed.startsWith(""String_Node_Str"")) {
                final String number=trimmed.substring(1,trimmed.length()).trim();
                final Object filterNumber=convertTo(o.getClass(),number);
                boolean result;
                if (trimmed.startsWith(""String_Node_Str""))                 result=((Number)o).doubleValue() > ((Number)filterNumber).doubleValue();
 else                 if (trimmed.startsWith(""String_Node_Str""))                 result=((Number)o).doubleValue() < ((Number)filterNumber).doubleValue();
 else                 throw new UnsupportedOperationException();
                if (result)                 continue;
 else                 return false;
              }
 else {
                final Object filterNumber=convertTo(o.getClass(),trimmed);
                if (o.equals(filterNumber))                 continue;
 else                 return false;
              }
            }
            item=o;
          }
 catch (          Exception e) {
            return false;
          }
        }
 else {
          throw new UnsupportedOperationException();
        }
        boolean result=(item instanceof CharSequence) ? item.toString().toLowerCase().contains(f.filter.toLowerCase()) : item.equals(convertTo(item.getClass(),f.filter.trim()));
        if (!result)         return false;
      }
      return true;
    }
 catch (    NumberFormatException e) {
      return false;
    }
  }
;
}"
55238,"public Column(String propertyId,boolean readOnly,boolean allowReadOnlyChange,boolean nullable,boolean primaryKey,Object value,Class<?> type,boolean isHidden){
  this.name=propertyId;
  this.readOnly=readOnly;
  this.allowReadOnlyChange=allowReadOnlyChange;
  this.nullable=nullable;
  this.primaryKey=primaryKey;
  this.value=value;
  this.type=type;
  this.isHidden=isHidden;
}","public Column(String name,boolean readOnly,boolean primaryKey,Object value,Class<?> type){
  this.name=name;
  this.readOnly=readOnly;
  this.primaryKey=primaryKey;
  this.value=value;
  this.type=type;
}"
55239,"@Override public List<Column> columns(){
  List<Column> result=new ArrayList<>();
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   result.add(new Column(""String_Node_Str"",false,false,false,true,""String_Node_Str"",keyType(),false));
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   result.add(new Column(""String_Node_Str"",false,false,false,false,""String_Node_Str"",valueType(),false));
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(new Column(declaredFields.getName(),false,false,false,false,""String_Node_Str"",declaredFields.getType(),false));
    }
  }
  return result;
}","@Override public List<Column> columns(){
  List<Column> result=new ArrayList<>();
  if (!(AbstractMarshallable.class.isAssignableFrom(keyType())))   result.add(new Column(""String_Node_Str"",false,true,""String_Node_Str"",keyType()));
  if (!(AbstractMarshallable.class.isAssignableFrom(valueType())))   result.add(new Column(""String_Node_Str"",false,false,""String_Node_Str"",valueType()));
 else {
    for (    final Field declaredFields : valueType().getDeclaredFields()) {
      result.add(new Column(declaredFields.getName(),false,false,""String_Node_Str"",declaredFields.getType()));
    }
  }
  return result;
}"
55240,"/** 
 * Enable JMX management of this Asset Tree
 * @param port to enable a simple web service on
 */
@NotNull default AssetTree enableManagement(int port){
  ManagementTools.enableManagement(this,port);
  return this;
}","/** 
 * Enable JMX management of this Asset Tree
 * @param port to enable a simple web service on
 */
@NotNull default AssetTree enableManagement(int port){
  ManagementTools.enableManagement(this);
  return this;
}"
55241,"private void dumpThreads(){
  for (  Map.Entry<Thread,StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) {
    Thread thread=entry.getKey();
    if (thread.getThreadGroup().getName().equals(""String_Node_Str""))     continue;
    StringBuilder sb=new StringBuilder();
    sb.append(thread).append(""String_Node_Str"").append(thread.getState());
    Jvm.trimStackTrace(sb,entry.getValue());
    sb.append(""String_Node_Str"");
    Jvm.warn().on(getClass(),""String_Node_Str"",sb);
  }
}","private void dumpThreads(){
  for (  Map.Entry<Thread,StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet()) {
    Thread thread=entry.getKey();
    if (thread.getThreadGroup().getName().equals(""String_Node_Str""))     continue;
    StringBuilder sb=new StringBuilder();
    sb.append(thread).append(""String_Node_Str"").append(thread.getState());
    Jvm.trimStackTrace(sb,entry.getValue());
    sb.append(""String_Node_Str"");
    Jvm.warn().on(getClass(),""String_Node_Str"" + sb.toString());
  }
}"
55242,"@NotNull public VanillaAssetTree forRemoteAccess(String hostPortDescription){
  return forRemoteAccess(hostPortDescription,WireType.BINARY);
}","public VanillaAssetTree forRemoteAccess(String serverAddress,WireType wireType,Consumer<Throwable> t){
  return forRemoteAccess(serverAddress,wireType);
}"
55243,"@Override public void writeMarshallable(@NotNull WireOut wire){
  wire.write(""String_Node_Str"").int64_0x(index);
  wire.write(""String_Node_Str"").typedMarshallable(v);
}","@Override public void writeMarshallable(@NotNull WireOut wire){
  wire.write(""String_Node_Str"").int64_0x(index);
  wire.write(""String_Node_Str"").typedMarshallable(v);
  wire.write(""String_Node_Str"").int64(timePublished);
  wire.write(""String_Node_Str"").int64(maxIndex);
}"
55244,"@Nullable private IndexedValue<V> value(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator,final long from){
  if (iterator.hasNext()) {
    IndexedValue<V> indexedValue=iterator.next();
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    return indexedValue;
  }
  final String eventName=vanillaIndexQuery.eventName();
  final Predicate<V> filter=vanillaIndexQuery.filter();
  if (isClosed.get())   throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
  try (DocumentContext dc=tailer.readingDocument()){
    if (!dc.isPresent())     return null;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",Wires.fromSizePrefixedBlobs(dc));
    if (from > dc.index())     return null;
    final StringBuilder sb=Wires.acquireStringBuilder();
    final ValueIn valueIn=dc.wire().read(sb);
    if (!eventName.contentEquals(sb))     return null;
    final Function<Class,ReadMarshallable> objectCache=objectCacheThreadLocal.get();
    final V v=valueIn.typedMarshallable(objectCache);
    if (!filter.test(v))     return null;
    final IndexedValue<V> indexedValue=this.indexedValue.get();
    indexedValue.index(dc.index());
    indexedValue.v(v);
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    return indexedValue;
  }
 }","@Nullable private IndexedValue<V> value(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator,final long from){
  if (iterator.hasNext()) {
    IndexedValue<V> indexedValue=iterator.next();
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    return indexedValue;
  }
  final String eventName=vanillaIndexQuery.eventName();
  final Predicate<V> filter=vanillaIndexQuery.filter();
  if (isClosed.get())   throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
  try (DocumentContext dc=tailer.readingDocument()){
    if (!dc.isPresent())     return null;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",Wires.fromSizePrefixedBlobs(dc));
    if (from > dc.index())     return null;
    final StringBuilder sb=Wires.acquireStringBuilder();
    final ValueIn valueIn=dc.wire().read(sb);
    if (!eventName.contentEquals(sb))     return null;
    final Function<Class,ReadMarshallable> objectCache=objectCacheThreadLocal.get();
    final V v=valueIn.typedMarshallable(objectCache);
    if (!filter.test(v))     return null;
    final IndexedValue<V> indexedValue=this.indexedValue.get();
    long index=dc.index();
    indexedValue.index(index);
    indexedValue.v(v);
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    return indexedValue;
  }
 }"
55245,"@Nullable private List<Marshallable> value(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator,final long from){
  List<Marshallable> indexedValues=indexedValueList.get();
  indexedValues.clear();
  if (iterator.hasNext()) {
    IndexedValue<V> indexedValue=iterator.next();
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    indexedValues.add(indexedValue);
    return indexedValues;
  }
  final String eventName=vanillaIndexQuery.eventName();
  final Predicate<V> filter=vanillaIndexQuery.filter();
  if (isClosed.get())   throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
  try (DocumentContext dc=tailer.readingDocument()){
    if (!dc.isPresent())     return null;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",Wires.fromSizePrefixedBlobs(dc));
    if (from > dc.index())     return null;
    final StringBuilder sb=Wires.acquireStringBuilder();
    while (dc.wire().bytes().readRemaining() > 0) {
      final ValueIn valueIn=dc.wire().read(sb);
      if (!eventName.contentEquals(sb))       continue;
      final Function<Class,ReadMarshallable> objectCache=objectCacheThreadLocal.get();
      final V v=valueIn.typedMarshallable(objectCache);
      if (!filter.test(v))       continue;
      final IndexedValue<V> indexedValue=this.indexedValue.get();
      long index=dc.index();
      indexedValue.index(index);
      indexedValue.v(v);
      indexedValue.timePublished(System.currentTimeMillis());
      indexedValue.maxIndex(lastIndexRead);
      indexedValues.add(indexedValue);
    }
  }
   return indexedValues;
}","@Nullable private List<Marshallable> value(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator,final long from){
  List<Marshallable> indexedValues=indexedValueList.get();
  indexedValues.clear();
  if (iterator.hasNext()) {
    IndexedValue<V> indexedValue=iterator.next();
    indexedValue.timePublished(System.currentTimeMillis());
    indexedValue.maxIndex(lastIndexRead);
    indexedValues.add(indexedValue);
    return indexedValues;
  }
  final String eventName=vanillaIndexQuery.eventName();
  final Predicate<V> filter=vanillaIndexQuery.filter();
  if (isClosed.get())   throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
  try (DocumentContext dc=tailer.readingDocument()){
    if (!dc.isPresent())     return null;
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",Wires.fromSizePrefixedBlobs(dc));
    if (from > dc.index())     return null;
    final StringBuilder sb=Wires.acquireStringBuilder();
    while (dc.wire().bytes().readRemaining() > 0) {
      final ValueIn valueIn=dc.wire().read(sb);
      if (!eventName.contentEquals(sb)) {
        valueIn.typedMarshallable();
        continue;
      }
      final Function<Class,ReadMarshallable> objectCache=objectCacheThreadLocal.get();
      final V v=valueIn.typedMarshallable(objectCache);
      if (!filter.test(v))       continue;
      final IndexedValue<V> indexedValue=this.indexedValue.get();
      long index=dc.index();
      indexedValue.index(index);
      indexedValue.v(v);
      indexedValue.timePublished(System.currentTimeMillis());
      indexedValue.maxIndex(lastIndexRead);
      indexedValues.add(indexedValue);
    }
  }
   return indexedValues;
}"
55246,"@Override public MonitorCfg install(String path,AssetTree assetTree) throws IOException, URISyntaxException {
  if (subscriptionMonitoringEnabled) {
    LOGGER.info(""String_Node_Str"" + assetTree);
    assetTree.acquireMap(""String_Node_Str"",String.class,SubscriptionStat.class);
  }
  if (userMonitoringEnabled) {
    LOGGER.info(""String_Node_Str"" + assetTree);
    assetTree.acquireMap(""String_Node_Str"",String.class,UserStat.class);
  }
  return this;
}","@Override public MonitorCfg install(String path,AssetTree assetTree) throws IOException, URISyntaxException {
  ((VanillaAsset)assetTree.acquireAsset(""String_Node_Str"")).configMapServer();
  if (subscriptionMonitoringEnabled) {
    LOGGER.info(""String_Node_Str"" + assetTree);
    assetTree.acquireMap(""String_Node_Str"",String.class,SubscriptionStat.class);
  }
  if (userMonitoringEnabled) {
    LOGGER.info(""String_Node_Str"" + assetTree);
    assetTree.acquireMap(""String_Node_Str"",String.class,UserStat.class);
  }
  return this;
}"
55247,"@Override public boolean put(K key,V value){
  return chronicleMap.update(key,value) != UpdateResult.INSERT;
}","@Override public boolean put(K key,V value){
  try {
    return chronicleMap.update(key,value) != UpdateResult.INSERT;
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + key + ""String_Node_Str""+ value);
    throw e;
  }
}"
55248,"public EngineWireNetworkContext(Asset asset){
  this.rootAsset=asset.root();
  try {
{
      String path=""String_Node_Str"";
      RequestContext requestContext=RequestContext.requestContext(path).type(ConnectionDetails.class).type2(ConnectionStatus.class);
      hostByConnectionStatus=rootAsset.root().acquireAsset(path).acquireView(MapView.class,requestContext);
    }
{
      String path=""String_Node_Str"";
      RequestContext requestContext=RequestContext.requestContext(path).type(SocketChannel.class).type2(TcpHandler.class);
      socketChannelByHandlers=rootAsset.root().acquireAsset(path).acquireView(MapView.class,requestContext);
      onHandlerChanged0(handler);
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    throw Jvm.rethrow(e);
  }
}","public EngineWireNetworkContext(Asset asset){
  this.rootAsset=asset.root();
  ((VanillaAsset)rootAsset.acquireAsset(""String_Node_Str"")).configMapServer();
  try {
{
      String path=""String_Node_Str"";
      RequestContext requestContext=RequestContext.requestContext(path).type(ConnectionDetails.class).type2(ConnectionStatus.class);
      hostByConnectionStatus=rootAsset.root().acquireAsset(path).acquireView(MapView.class,requestContext);
    }
{
      String path=""String_Node_Str"";
      RequestContext requestContext=RequestContext.requestContext(path).type(SocketChannel.class).type2(TcpHandler.class);
      socketChannelByHandlers=rootAsset.root().acquireAsset(path).acquireView(MapView.class,requestContext);
      onHandlerChanged0(handler);
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    throw Jvm.rethrow(e);
  }
}"
55249,"@Override public String toString(){
  return ""String_Node_Str"" + hostByConnectionStatus.entrySet().toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier;
}"
55250,"public void onMessageReceived(){
  lastTimeMessageReceived=System.currentTimeMillis();
  long currentSecond=TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());
  if (lastPing != currentSecond) {
    LOG.info(""String_Node_Str"" + lastTimeMessageReceived);
    lastPing=currentSecond;
  }
}","public void onMessageReceived(){
  lastTimeMessageReceived=System.currentTimeMillis();
  long currentSecond=TimeUnit.MILLISECONDS.toSeconds(lastTimeMessageReceived);
  if (lastPing != currentSecond) {
    LOG.info(""String_Node_Str"" + lastTimeMessageReceived);
    lastPing=currentSecond;
  }
}"
55251,"@NotNull private WireOutConsumer excerptConsumer(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator){
  final IndexedValue<V> indexedValue=new IndexedValue<>();
  final ObjectCache objectCache=asset.acquireView(ObjectCache.class);
  return out -> {
    if (iterator.hasNext()) {
      out.getValueOut().typedMarshallable(iterator.next());
      return;
    }
    final String eventName=vanillaIndexQuery.eventName();
    final Predicate<V> filter=vanillaIndexQuery.filter();
    if (isClosed.get()) {
      tailer.close();
      throw new InvalidEventHandlerException(""String_Node_Str"");
    }
    try (DocumentContext dc=tailer.readingDocument()){
      if (!dc.isPresent())       return;
      final StringBuilder sb=Wires.acquireStringBuilder();
      if (!eventName.contentEquals(sb))       return;
      final V v=dc.wire().read(sb).typedMarshallable(objectCache);
      if (!filter.test(v))       return;
      out.getValueOut().typedMarshallable(indexedValue);
    }
   }
;
}","@NotNull private Supplier<Marshallable> excerptConsumer(@NotNull IndexQuery<V> vanillaIndexQuery,@NotNull ExcerptTailer tailer,@NotNull Iterator<IndexedValue<V>> iterator){
  final IndexedValue<V> indexedValue=new IndexedValue<>();
  final ObjectCache objectCache=asset.acquireView(ObjectCache.class);
  return () -> {
    if (iterator.hasNext()) {
      return iterator.next();
    }
    final String eventName=vanillaIndexQuery.eventName();
    final Predicate<V> filter=vanillaIndexQuery.filter();
    if (isClosed.get()) {
      tailer.close();
      throw Jvm.rethrow(new InvalidEventHandlerException(""String_Node_Str""));
    }
    try (DocumentContext dc=tailer.readingDocument()){
      if (!dc.isPresent())       return null;
      final StringBuilder sb=Wires.acquireStringBuilder();
      if (!eventName.contentEquals(sb))       return null;
      final V v=dc.wire().read(sb).typedMarshallable(objectCache);
      if (!filter.test(v))       return null;
      return indexedValue;
    }
   }
;
}"
55252,"/** 
 * consumers wire on the NIO socket thread
 * @param sub
 * @param vanillaIndexQuery
 * @return
 */
@Nullable public void registerSubscriber(@NotNull ConsumingSubscriber<IndexedValue<V>> sub,@NotNull IndexQuery<V> vanillaIndexQuery){
  final AtomicBoolean isClosed=new AtomicBoolean();
  activeSubscriptions.put(sub,isClosed);
  final long from=vanillaIndexQuery.from() == 0 ? lastIndexRead : vanillaIndexQuery.from();
  Iterator<IndexedValue<V>> iterator=EMPTY_ITERATOR;
  if (from != 0) {
    if (from > lastIndexRead)     throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
    final String eventName=vanillaIndexQuery.eventName();
    final Predicate<V> filter=vanillaIndexQuery.filter();
    if (from == lastIndexRead) {
      multiMap.computeIfAbsent(eventName,k -> new ConcurrentHashMap<>()).values().stream().filter((      IndexedValue<V> i) -> filter.test(i.v())).forEach(sub);
    }
 else     multiMap.computeIfAbsent(eventName,k -> new ConcurrentHashMap<>()).values().stream().filter((    IndexedValue<V> i) -> i.index() <= from && filter.test(i.v())).forEach(sub);
  }
  final ExcerptTailer tailer=chronicleQueue.createTailer();
  try {
    if (from != 0)     tailer.moveToIndex(from);
    WireOutConsumer consumer=excerptConsumer(vanillaIndexQuery,tailer,iterator);
    sub.addWireConsumer(consumer);
  }
 catch (  TimeoutException e) {
    tailer.close();
    sub.onEndOfSubscription();
    LOG.error(""String_Node_Str"",e);
  }
}","/** 
 * consumers wire on the NIO socket thread
 * @param sub
 * @param vanillaIndexQuery
 * @return
 */
@Nullable public void registerSubscriber(@NotNull ConsumingSubscriber<IndexedValue<V>> sub,@NotNull IndexQuery<V> vanillaIndexQuery){
  final AtomicBoolean isClosed=new AtomicBoolean();
  activeSubscriptions.put(sub,isClosed);
  final long from=vanillaIndexQuery.from() == 0 ? lastIndexRead : vanillaIndexQuery.from();
  Iterator<IndexedValue<V>> iterator=EMPTY_ITERATOR;
  if (from != 0) {
    if (from > lastIndexRead)     throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
    final String eventName=vanillaIndexQuery.eventName();
    final Predicate<V> filter=vanillaIndexQuery.filter();
    if (from == lastIndexRead) {
      iterator=multiMap.computeIfAbsent(eventName,k -> new ConcurrentHashMap<>()).values().stream().filter((      IndexedValue<V> i) -> filter.test(i.v())).iterator();
    }
 else     iterator=multiMap.computeIfAbsent(eventName,k -> new ConcurrentHashMap<>()).values().stream().filter((    IndexedValue<V> i) -> i.index() <= from && filter.test(i.v())).iterator();
  }
  final ExcerptTailer tailer=chronicleQueue.createTailer();
  try {
    if (from != 0)     tailer.moveToIndex(from);
    final Supplier<Marshallable> consumer=excerptConsumer(vanillaIndexQuery,tailer,iterator);
    sub.addValueOutConsumer(consumer);
  }
 catch (  TimeoutException e) {
    tailer.close();
    sub.onEndOfSubscription();
    LOG.error(""String_Node_Str"",e);
  }
}"
55253,"@Override public boolean hasValueSubscribers(){
  return !topicSubscribers.isEmpty() || !subscribers.isEmpty() || !downstream.isEmpty()|| asset.hasChildren();
}","@Override public boolean hasValueSubscribers(){
  return !topicSubscribers.isEmpty() || !subscribers.isEmpty() || !downstream.isEmpty()|| asset.hasChildren()|| !subscriptionDelegate.isEmpty();
}"
55254,"private void notifyEvent1(@NotNull MapEvent<K,V> changeEvent){
  K key=changeEvent.getKey();
  if (!topicSubscribers.isEmpty()) {
    V value=changeEvent.getValue();
    notifyEachSubscriber(topicSubscribers,ts -> ts.onMessage(key,value));
  }
  if (!subscribers.isEmpty()) {
    notifyEachSubscriber(subscribers,s -> s.onMessage(changeEvent));
  }
  if (!keySubscribers.isEmpty()) {
    notifyEachSubscriber(keySubscribers,s -> s.onMessage(key));
  }
  if (!downstream.isEmpty()) {
    notifyEachSubscriber(downstream,d -> d.notifyEvent(changeEvent));
  }
}","private void notifyEvent1(@NotNull MapEvent<K,V> changeEvent){
  K key=changeEvent.getKey();
  if (!topicSubscribers.isEmpty()) {
    V value=changeEvent.getValue();
    notifyEachSubscriber(topicSubscribers,ts -> ts.onMessage(key,value));
  }
  if (!subscribers.isEmpty()) {
    notifyEachSubscriber(subscribers,s -> s.onMessage(changeEvent));
  }
  if (!keySubscribers.isEmpty()) {
    notifyEachSubscriber(keySubscribers,s -> s.onMessage(key));
  }
  if (!downstream.isEmpty()) {
    notifyEachSubscriber(downstream,d -> d.notifyEvent(changeEvent));
  }
  if (!subscriptionDelegate.isEmpty()) {
    Iterator<Subscriber> iterator=subscriptionDelegate.values().iterator();
    while (iterator.hasNext()) {
      Subscriber next=iterator.next();
      try {
        next.onMessage(changeEvent);
      }
 catch (      InvalidSubscriberException e) {
        iterator.remove();
      }
    }
  }
}"
55255,"@Override public boolean hasSubscribers(){
  return !topicSubscribers.isEmpty() || !subscribers.isEmpty() || !keySubscribers.isEmpty()|| !downstream.isEmpty()|| asset.hasChildren();
}","@Override public boolean hasSubscribers(){
  return !keySubscribers.isEmpty() || hasValueSubscribers();
}"
55256,"@Override @NotNull public Query<Map.Entry<K,V>> query(){
  return new RemoteQuery<>((subscriber,filter,contextOperations) -> {
    mapView.registerSubscriber((Subscriber)subscriber,(Filter)filter,of(BOOTSTRAP,END_SUBSCRIPTION_AFTER_BOOTSTRAP));
  }
);
}","@Override @NotNull public Query<Map.Entry<K,V>> query(){
  return new RemoteQuery<>((subscriber,filter,contextOperations) -> {
    mapView.registerSubscriber((Subscriber)subscriber,(Filter)filter,contextOperations);
  }
);
}"
55257,"@Override protected void onRead(@NotNull final DocumentContext inDc,@NotNull final WireOut out){
  WireIn in=inDc.wire();
  if (!YamlLogging.showHeartBeats()) {
    prevLogMessage.setLength(0);
    prevLogMessage.append(currentLogMessage);
    currentLogMessage.setLength(0);
    logToBuffer(in,currentLogMessage);
  }
 else {
    logYamlToStandardOut(in);
  }
  if (inDc.isMetaData()) {
    this.metaDataConsumer.readMarshallable(in);
  }
 else {
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + in.bytes().toHexString());
      Consumer<WireType> wireTypeConsumer=wt -> {
        wireType(wt);
        checkWires(in.bytes(),out.bytes(),wireType());
      }
;
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails,getMonitoringMap(),isServerSocket,this::publisher,hostIdentifier,wireTypeConsumer,wireType());
        if (!systemHandler.wasHeartBeat()) {
          if (!YamlLogging.showHeartBeats())           logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
        }
        return;
      }
      if (!YamlLogging.showHeartBeats()) {
        logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
      }
      Map<String,UserStat> userMonitoringMap=getMonitoringMap();
      if (userMonitoringMap != null) {
        UserStat userStat=userMonitoringMap.get(sessionDetails.userId());
        if (userStat == null) {
          throw new AssertionError(""String_Node_Str"");
        }
        userStat.setRecentInteraction(LocalTime.now());
        userStat.setTotalInteractions(userStat.getTotalInteractions() + 1);
        userMonitoringMap.put(sessionDetails.userId(),userStat);
      }
      if (wireAdapter != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesCollection.class) {
          valuesHandler.process(in,out,(ValuesCollection)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (viewType == ObjectSubscription.class) {
          subscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(SubscriptionCollection)view);
          return;
        }
        if (viewType == TopologySubscription.class) {
          topologySubscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (viewType == Reference.class) {
          referenceHandler.process(in,requestContext,publisher(),tid,(Reference)view,cspText,outWire,wireAdapter);
          return;
        }
        if (viewType == TopicPublisher.class || viewType == QueueView.class) {
          topicPublisherHandler.process(in,publisher(),tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (viewType == Publisher.class) {
          publisherHandler.process(in,requestContext,publisher(),tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (viewType == Replication.class) {
          replicationHandler.process(in,publisher(),tid,outWire,hostIdentifier,(Replication)view,eventLoop);
        }
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
 finally {
      if (sessionProvider != null)       sessionProvider.remove();
    }
  }
}","@Override protected void onRead(@NotNull final DocumentContext inDc,@NotNull final WireOut out){
  WireIn in=inDc.wire();
  if (!YamlLogging.showHeartBeats()) {
    prevLogMessage.setLength(0);
    prevLogMessage.append(currentLogMessage);
    currentLogMessage.setLength(0);
    logToBuffer(in,currentLogMessage,in.bytes().readPosition() - 4);
  }
 else {
    logYamlToStandardOut(in);
  }
  if (inDc.isMetaData()) {
    this.metaDataConsumer.readMarshallable(in);
  }
 else {
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + in.bytes().toHexString());
      Consumer<WireType> wireTypeConsumer=wt -> {
        wireType(wt);
        checkWires(in.bytes(),out.bytes(),wireType());
      }
;
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails,getMonitoringMap(),isServerSocket,this::publisher,hostIdentifier,wireTypeConsumer,wireType());
        if (!systemHandler.wasHeartBeat()) {
          if (!YamlLogging.showHeartBeats())           logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
        }
        return;
      }
      if (!YamlLogging.showHeartBeats()) {
        logBufferToStandardOut(prevLogMessage.append(currentLogMessage));
      }
      Map<String,UserStat> userMonitoringMap=getMonitoringMap();
      if (userMonitoringMap != null) {
        UserStat userStat=userMonitoringMap.get(sessionDetails.userId());
        if (userStat == null) {
          throw new AssertionError(""String_Node_Str"");
        }
        userStat.setRecentInteraction(LocalTime.now());
        userStat.setTotalInteractions(userStat.getTotalInteractions() + 1);
        userMonitoringMap.put(sessionDetails.userId(),userStat);
      }
      if (wireAdapter != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesCollection.class) {
          valuesHandler.process(in,out,(ValuesCollection)view,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (viewType == ObjectSubscription.class) {
          subscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(SubscriptionCollection)view);
          return;
        }
        if (viewType == TopologySubscription.class) {
          topologySubscriptionHandler.process(in,requestContext,publisher(),contextAsset,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (viewType == Reference.class) {
          referenceHandler.process(in,requestContext,publisher(),tid,(Reference)view,cspText,outWire,wireAdapter);
          return;
        }
        if (viewType == TopicPublisher.class || viewType == QueueView.class) {
          topicPublisherHandler.process(in,publisher(),tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (viewType == Publisher.class) {
          publisherHandler.process(in,requestContext,publisher(),tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (viewType == Replication.class) {
          replicationHandler.process(in,publisher(),tid,outWire,hostIdentifier,(Replication)view,eventLoop);
        }
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
 finally {
      if (sessionProvider != null)       sessionProvider.remove();
    }
  }
}"
55258,"private void logToBuffer(@NotNull WireIn in,StringBuilder logBuffer){
  if (YamlLogging.showServerReads()) {
    logBuffer.setLength(0);
    try {
      logBuffer.append(""String_Node_Str"").append(Wires.fromSizePrefixedBlobs(in.bytes()));
    }
 catch (    Exception e) {
      logBuffer.append(""String_Node_Str"").append(Bytes.toString(in.bytes()));
    }
  }
}","private void logToBuffer(@NotNull WireIn in,StringBuilder logBuffer,long start){
  if (YamlLogging.showServerReads()) {
    logBuffer.setLength(0);
    try {
      logBuffer.append(""String_Node_Str"").append(Wires.fromSizePrefixedBlobs(in.bytes(),start));
    }
 catch (    Exception e) {
      logBuffer.append(""String_Node_Str"").append(Bytes.toString(in.bytes(),start,in.bytes().readLimit() - start));
    }
  }
}"
55259,"@Before public void before() throws IOException {
  serverAssetTree=new VanillaAssetTree().forTesting(x -> t.compareAndSet(null,x));
  if (isRemote) {
    methodName(name.getMethodName());
    connection=""String_Node_Str"";
    TCPRegistry.createServerSocketChannelFor(connection);
    serverEndpoint=new ServerEndpoint(connection,serverAssetTree);
    assetTree=new VanillaAssetTree().forRemoteAccess(connection,wireType,x -> t.set(x));
  }
 else {
    assetTree=serverAssetTree;
  }
}","@Before public void before() throws IOException {
  serverAssetTree=new VanillaAssetTree().forTesting(x -> {
    t.compareAndSet(null,x);
    x.printStackTrace();
  }
);
  if (isRemote) {
    methodName(name.getMethodName());
    connection=""String_Node_Str"";
    TCPRegistry.createServerSocketChannelFor(connection);
    serverEndpoint=new ServerEndpoint(connection,serverAssetTree);
    assetTree=new VanillaAssetTree().forRemoteAccess(connection,wireType,x -> t.set(x));
  }
 else {
    assetTree=serverAssetTree;
  }
}"
55260,"@Ignore @Test public void testThatSendingAlotOfDataToTheServer() throws Exception {
  map=assetTree.acquireMap(""String_Node_Str"",String.class,String.class);
  char[] largeChar=new char[TcpChannelHub.BUFFER_SIZE - 1024];
  Arrays.fill(largeChar,'X');
  final String large2MbString=new String(largeChar);
  for (int i=0; i < SIZE; i++) {
    map.put(""String_Node_Str"" + i,large2MbString);
  }
  System.out.println(""String_Node_Str"");
  Assert.assertEquals(SIZE,map.size());
  System.out.println(""String_Node_Str"");
}","@Test public void testThatSendingAlotOfDataToTheServer() throws Exception {
  map=assetTree.acquireMap(""String_Node_Str"",String.class,String.class);
  char[] largeChar=new char[66000];
  Arrays.fill(largeChar,'X');
  final String large2MbString=new String(largeChar);
  for (int i=0; i < SIZE; i++) {
    Assert.assertEquals(i,map.size());
    map.put(""String_Node_Str"" + i,large2MbString);
  }
  System.out.println(""String_Node_Str"");
  Assert.assertEquals(SIZE,map.size());
}"
55261,"@Override public void registerTopicSubscriber(@NotNull RequestContext rc,@NotNull final TopicSubscriber<T,M> subscriber){
  addToStats(""String_Node_Str"");
  topicSubscribers.add(subscriber);
  AtomicBoolean terminate=new AtomicBoolean();
  final QueueView<T,M> chronicleQueue=asset.acquireView(QueueView.class,rc);
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<T,M> next=chronicleQueue.next();
    if (next == null)     return false;
    try {
      subscriber.onMessage(next.topic(),next.message());
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      terminate.set(true);
    }
    return true;
  }
);
}","@Override public void registerTopicSubscriber(@NotNull RequestContext rc,@NotNull final TopicSubscriber<T,M> subscriber){
  addToStats(""String_Node_Str"");
  topicSubscribers.add(subscriber);
  AtomicBoolean terminate=new AtomicBoolean();
  final ChronicleQueueView<T,M> chronicleQueue=(ChronicleQueueView)asset.acquireView(QueueView.class,rc);
  QueueView.Tailer<T,M> iterator=chronicleQueue.tailer();
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<T,M> next=iterator.read();
    if (next == null)     return false;
    try {
      subscriber.onMessage(next.topic(),next.message());
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      terminate.set(true);
    }
    return true;
  }
);
}"
55262,"@Nullable @Override public M get(){
  final QueueView.Excerpt<T,M> next=chronicleQueue.next();
  if (next == null)   return null;
  return next.message();
}","@Nullable @Override public M get(){
  final QueueView.Excerpt<T,M> next=tailer.read();
  if (next == null)   return null;
  return next.message();
}"
55263,"@Override public void registerSubscriber(boolean bootstrap,int throttlePeriodMs,Subscriber<M> subscriber) throws AssetNotFoundException {
  AtomicBoolean terminate=new AtomicBoolean();
  subscribers.put(subscriber,terminate);
  final ChronicleQueueView<T,M> chronicleQueue=(ChronicleQueueView<T,M>)asset.acquireView(QueueView.class);
  final QueueView.Iterator<T,M> iterator=chronicleQueue.iterator();
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<T,M> next=iterator.next();
    if (next == null)     return false;
    try {
      subscriber.onMessage(next.message());
    }
 catch (    InvalidSubscriberException e) {
      terminate.set(true);
    }
    return true;
  }
);
}","@Override public void registerSubscriber(boolean bootstrap,int throttlePeriodMs,Subscriber<M> subscriber) throws AssetNotFoundException {
  AtomicBoolean terminate=new AtomicBoolean();
  subscribers.put(subscriber,terminate);
  final ChronicleQueueView<T,M> chronicleQueue=(ChronicleQueueView<T,M>)asset.acquireView(QueueView.class);
  final QueueView.Tailer<T,M> iterator=chronicleQueue.tailer();
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<T,M> next=iterator.read();
    if (next == null)     return false;
    try {
      subscriber.onMessage(next.message());
    }
 catch (    InvalidSubscriberException e) {
      terminate.set(true);
    }
    return true;
  }
);
}"
55264,"public void registerSubscriber(boolean bootstrap,int throttlePeriodMs,Subscriber<E> subscriber) throws AssetNotFoundException {
  AtomicBoolean terminate=new AtomicBoolean();
  subscribers.put(subscriber,terminate);
  final QueueView.Iterator<?,E> iterator=chronicleQueue.iterator();
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<?,E> next=iterator.next();
    if (next == null)     return false;
    try {
      Object topic=next.topic();
      if (!this.topic.equals(topic.toString()))       return true;
      subscriber.onMessage(next.message());
    }
 catch (    InvalidSubscriberException e) {
      terminate.set(true);
    }
    return true;
  }
);
}","public void registerSubscriber(boolean bootstrap,int throttlePeriodMs,Subscriber<E> subscriber) throws AssetNotFoundException {
  AtomicBoolean terminate=new AtomicBoolean();
  subscribers.put(subscriber,terminate);
  final QueueView.Tailer<?,E> tailer=chronicleQueue.tailer();
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<?,E> next=tailer.read();
    if (next == null)     return false;
    try {
      Object topic=next.topic();
      if (!this.topic.equals(topic.toString()))       return true;
      subscriber.onMessage(next.message());
    }
 catch (    InvalidSubscriberException e) {
      terminate.set(true);
    }
    return true;
  }
);
}"
55265,"public QueueSimpleSubscription(Function<Object,E> valueReader,Asset parent,String topic){
  this.valueReader=valueReader;
  this.topic=topic;
  chronicleQueue=parent.acquireView(QueueView.class);
  eventLoop=parent.acquireView(EventLoop.class);
}","public QueueSimpleSubscription(Function<Object,E> valueReader,Asset parent,String topic){
  this.valueReader=valueReader;
  this.topic=topic;
  chronicleQueue=(ChronicleQueueView)parent.acquireView(QueueView.class);
  eventLoop=parent.acquireView(EventLoop.class);
}"
55266,"VanillaSubAsset(@NotNull VanillaAsset parent,String name,Class<E> type,Function<Object,E> valueReader) throws AssetNotFoundException {
  this.parent=parent;
  this.name=name;
  TcpChannelHub tcpChannelHub=parent.findView(TcpChannelHub.class);
  if (tcpChannelHub == null) {
    QueueView queueView=parent.getView(QueueView.class);
    if (queueView == null) {
      reference=new MapReference<>(name,type,parent.acquireView(MapView.class));
      subscription=new MapSimpleSubscription<>(reference,valueReader);
    }
 else {
      reference=new QueueReference<>(type,parent,queueView,name);
      subscription=new QueueSimpleSubscription<>(valueReader,parent,name);
    }
  }
 else {
    reference=new RemoteReference<>(tcpChannelHub,type,fullName());
    subscription=new RemoteSimpleSubscription<>(reference);
  }
}","public VanillaSubAsset(@NotNull VanillaAsset parent,String name,Class<E> type,Function<Object,E> valueReader) throws AssetNotFoundException {
  this.parent=parent;
  this.name=name;
  TcpChannelHub tcpChannelHub=parent.findView(TcpChannelHub.class);
  if (tcpChannelHub == null) {
    QueueView queueView=parent.getView(QueueView.class);
    if (queueView == null) {
      reference=new MapReference<>(name,type,parent.acquireView(MapView.class));
      subscription=new MapSimpleSubscription<>(reference,valueReader);
    }
 else {
      reference=new QueueReference<>(type,parent,queueView,name);
      subscription=new QueueSimpleSubscription<>(valueReader,parent,name);
    }
  }
 else {
    reference=new RemoteReference<>(tcpChannelHub,type,fullName());
    subscription=new RemoteSimpleSubscription<>(reference);
  }
}"
55267,"@Test public void testStringPublishWithTopicSubscribe() throws InterruptedException {
  Publisher<String> publisher=null;
  String uri=""String_Node_Str"" + methodName + System.nanoTime();
  String messageType=""String_Node_Str"";
  try {
    if (!isRemote)     assetTree.acquireQueue(uri,String.class,String.class);
    publisher=assetTree.acquirePublisher(uri + ""String_Node_Str"" + messageType,String.class);
    BlockingQueue<String> values=new ArrayBlockingQueue<>(1);
    TopicSubscriber<String,String> subscriber=(topic,message) -> {
      values.add(topic + ""String_Node_Str"" + message);
    }
;
    assetTree.registerTopicSubscriber(uri,String.class,String.class,subscriber);
    publisher.publish(""String_Node_Str"");
    assertEquals(""String_Node_Str"",values.poll(20,SECONDS));
  }
  finally {
    deleteFiles(publisher);
  }
}","@Test public void testStringPublishWithTopicSubscribe() throws InterruptedException {
  Publisher<String> publisher=null;
  String uri=""String_Node_Str"" + methodName + System.nanoTime();
  String messageType=""String_Node_Str"";
  try {
    if (!isRemote)     assetTree.acquireQueue(uri,String.class,String.class);
    publisher=assetTree.acquirePublisher(uri + ""String_Node_Str"" + messageType,String.class);
    BlockingQueue<String> values=new ArrayBlockingQueue<>(10);
    TopicSubscriber<String,String> subscriber=(topic,message) -> {
      values.add(topic + ""String_Node_Str"" + message);
    }
;
    assetTree.registerTopicSubscriber(uri,String.class,String.class,subscriber);
    publisher.publish(""String_Node_Str"");
    assertEquals(""String_Node_Str"",values.poll(20,SECONDS));
  }
  finally {
    deleteFiles(publisher);
  }
}"
55268,"@Test public void testPublishAtIndexCheckIndex() throws InterruptedException {
  QueueView<String,String> queueView=null;
  try {
    String uri=""String_Node_Str"" + methodName + System.nanoTime();
    String messageType=""String_Node_Str"";
    queueView=assetTree.acquireQueue(uri,String.class,String.class);
    Thread.sleep(500);
    final long index=queueView.publishAndIndex(messageType,""String_Node_Str"");
    final Excerpt<String,String> actual=queueView.next();
    assertEquals(index,actual.index());
  }
  finally {
    deleteFiles(queueView);
  }
}","@Test public void testPublishAtIndexCheckIndex() throws InterruptedException {
  QueueView<String,String> queueView=null;
  try {
    String uri=""String_Node_Str"" + methodName + System.nanoTime();
    String messageType=""String_Node_Str"";
    queueView=assetTree.acquireQueue(uri,String.class,String.class);
    Thread.sleep(500);
    final long index=queueView.publishAndIndex(messageType,""String_Node_Str"");
    final Excerpt<String,String> actual=queueView.get(index);
    assertEquals(index,actual.index());
  }
  finally {
    deleteFiles(queueView);
  }
}"
55269,"@Test public void testStringTopicPublisherWithSubscribe() throws InterruptedException {
  String uri=""String_Node_Str"" + methodName + System.nanoTime();
  String messageType=""String_Node_Str"";
  TopicPublisher<String,String> publisher=assetTree.acquireTopicPublisher(uri,String.class,String.class);
  BlockingQueue<String> values0=new ArrayBlockingQueue<>(1);
  Subscriber<String> subscriber=e -> {
    if (e != null) {
      values0.add(e);
    }
  }
;
  assetTree.registerSubscriber(uri + ""String_Node_Str"" + messageType,String.class,subscriber);
  Thread.sleep(1000);
  publisher.publish(messageType,""String_Node_Str"");
  assertEquals(""String_Node_Str"",values0.poll(3,SECONDS));
  deleteFiles(publisher);
}","@Test public void testStringTopicPublisherWithSubscribe() throws InterruptedException {
  String uri=""String_Node_Str"" + methodName + System.nanoTime();
  String messageType=""String_Node_Str"";
  TopicPublisher<String,String> publisher=assetTree.acquireTopicPublisher(uri,String.class,String.class);
  BlockingQueue<String> values0=new ArrayBlockingQueue<>(1);
  Subscriber<String> subscriber=e -> {
    if (e != null) {
      values0.add(e);
    }
  }
;
  publisher.publish(messageType,""String_Node_Str"");
  Thread.sleep(1000);
  assetTree.registerSubscriber(uri + ""String_Node_Str"" + messageType,String.class,subscriber);
  assertEquals(""String_Node_Str"",values0.poll(3,SECONDS));
  deleteFiles(publisher);
}"
55270,"@Test public void testStringTopicPublisherWithSubscribe() throws InterruptedException {
  String uri=""String_Node_Str"" + methodName + System.nanoTime();
  String messageType=""String_Node_Str"";
  TopicPublisher<String,String> publisher=assetTree.acquireTopicPublisher(uri,String.class,String.class);
  BlockingQueue<String> values0=new ArrayBlockingQueue<>(1);
  Subscriber<String> subscriber=e -> {
    if (e != null) {
      values0.add(e);
    }
  }
;
  assetTree.registerSubscriber(uri,String.class,subscriber);
  Thread.sleep(500);
  publisher.publish(messageType,""String_Node_Str"");
  assertEquals(""String_Node_Str"",values0.poll(3,SECONDS));
  deleteFiles(publisher);
}","@Ignore @Test public void testStringTopicPublisherWithSubscribe() throws InterruptedException {
  String uri=""String_Node_Str"" + methodName + System.nanoTime();
  String messageType=""String_Node_Str"";
  TopicPublisher<String,String> publisher=assetTree.acquireTopicPublisher(uri,String.class,String.class);
  BlockingQueue<String> values0=new ArrayBlockingQueue<>(1);
  Subscriber<String> subscriber=e -> {
    if (e != null) {
      values0.add(e);
    }
  }
;
  assetTree.registerSubscriber(uri + ""String_Node_Str"" + messageType,String.class,subscriber);
  Thread.sleep(500);
  publisher.publish(messageType,""String_Node_Str"");
  assertEquals(""String_Node_Str"",values0.poll(3,SECONDS));
  deleteFiles(publisher);
}"
55271,"@After public void after() throws Throwable {
  final Throwable tr=t.getAndSet(null);
  if (tr != null)   throw tr;
  if (serverEndpoint != null)   serverEndpoint.close();
  if (assetTree != null)   assetTree.close();
  methodName=""String_Node_Str"";
  TCPRegistry.reset();
}","@After public void after() throws Throwable {
  if (serverEndpoint != null)   serverEndpoint.close();
  if (assetTree != null)   assetTree.close();
  methodName=""String_Node_Str"";
  TCPRegistry.reset();
  final Throwable tr=t.getAndSet(null);
  if (tr != null)   throw tr;
}"
55272,"@Override public void registerSubscriber(@NotNull final RequestContext rc,@NotNull final Subscriber subscriber,@NotNull final Filter filter){
  final int that=this.hashCode();
  final QueueView<T,M> chronicleQueue=asset.acquireView(QueueView.class,rc);
  eventLoop.addHandler(() -> {
    final T topic=ObjectUtils.convertTo(topicType,rc.name());
    QueueView.Excerpt<T,M> excerpt=chronicleQueue.get(topic);
    if (excerpt == null)     return false;
    final M e=excerpt.message();
    if (e == null)     return false;
    subscriber.accept(e);
    return true;
  }
);
}","@Override public void registerSubscriber(@NotNull final RequestContext rc,@NotNull final Subscriber subscriber,@NotNull final Filter filter){
  final QueueView<T,M> chronicleQueue=asset.acquireView(QueueView.class,rc);
  final T topic=ObjectUtils.convertTo(topicType,rc.name());
  eventLoop.addHandler(() -> {
    QueueView.Excerpt<T,M> excerpt=chronicleQueue.get(topic);
    if (excerpt == null)     return false;
    final M e=excerpt.message();
    if (e == null)     return false;
    subscriber.accept(e);
    return true;
  }
);
}"
55273,"@Parameters public static Collection<Object[]> data(){
  return Arrays.asList(new Class[][]{{RemoteMapSupplier.class}});
}","@Parameters public static Collection<Object[]> data(){
  return Arrays.asList(new Class[][]{{LocalMapSupplier.class},{RemoteMapSupplier.class}});
}"
55274,"@Before public void clearState(){
  TcpChannelHub.closeAllHubs();
  TCPRegistry.reset();
  YamlLogging.setAll(true);
}","@Before public void clearState(){
  if (supplier == LocalMapSupplier.class)   assetTree.forTesting(x -> t.compareAndSet(null,x));
  TcpChannelHub.closeAllHubs();
  TCPRegistry.reset();
  YamlLogging.setAll(true);
}"
55275,"public Class topicType(){
  if (type == null)   return String.class;
  return type;
}","public RequestContext topicType(Class topicType){
  this.type=topicType;
  return this;
}"
55276,"@Override public void registerTopicSubscriber(@NotNull RequestContext rc,@NotNull final TopicSubscriber<T,M> subscriber){
  addToStats(""String_Node_Str"");
  topicSubscribers.add(subscriber);
  AtomicBoolean terminate=new AtomicBoolean();
  final QueueView<T,M> chronicleQueue=asset.acquireView(QueueView.class);
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<T,M> next=chronicleQueue.next();
    if (next == null)     return false;
    try {
      subscriber.onMessage(next.topic(),next.message());
    }
 catch (    InvalidSubscriberException e) {
      terminate.set(true);
    }
    return true;
  }
);
}","@Override public void registerTopicSubscriber(@NotNull RequestContext rc,@NotNull final TopicSubscriber<T,M> subscriber){
  addToStats(""String_Node_Str"");
  topicSubscribers.add(subscriber);
  AtomicBoolean terminate=new AtomicBoolean();
  final QueueView<T,M> chronicleQueue=asset.acquireView(QueueView.class,rc);
  eventLoop.addHandler(() -> {
    if (terminate.get())     throw new InvalidEventHandlerException();
    final QueueView.Excerpt<T,M> next=chronicleQueue.next();
    if (next == null)     return false;
    try {
      subscriber.onMessage(next.topic(),next.message());
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      terminate.set(true);
    }
    return true;
  }
);
}"
55277,"@Override protected void onRead(@NotNull WireIn inWire,@NotNull WireOut outWire){
  if (isClosed.get()) {
    inWire.clear();
    return;
  }
  if (YamlLogging.showServerReads() && inWire.hasMore()) {
    String s=Wires.fromSizePrefixedBlobs(inWire.bytes());
    LOG.info(""String_Node_Str"" + s);
  }
  onMessageReceived();
  while (inWire.hasMore()) {
    try (final DocumentContext dc=inWire.readingDocument()){
      if (!dc.isPresent())       continue;
      if (dc.isMetaData()) {
        if (!readMeta(inWire))         continue;
        handler().remoteIdentifier(remoteIdentifier);
        handler().localIdentifier(localIdentifier);
        handler().onInitialize(outWire);
        continue;
      }
      if (handler() == null)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      if (dc.isData()) {
        handler().onRead(inWire,outWire);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}","@Override protected void onRead(@NotNull WireIn inWire,@NotNull WireOut outWire){
  if (isClosed.get()) {
    inWire.clear();
    return;
  }
  if (YamlLogging.showServerReads() && inWire.hasMore()) {
    String s=Wires.fromSizePrefixedBlobs(inWire.bytes());
    LOG.info(""String_Node_Str"" + s);
  }
  onMessageReceived();
  while (!inWire.bytes().isEmpty()) {
    try (final DocumentContext dc=inWire.readingDocument()){
      if (!dc.isPresent())       continue;
      if (dc.isMetaData()) {
        if (!readMeta(inWire))         continue;
        handler().remoteIdentifier(remoteIdentifier);
        handler().localIdentifier(localIdentifier);
        handler().onInitialize(outWire);
        continue;
      }
      if (handler() == null)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      if (dc.isData()) {
        handler().onRead(inWire,outWire);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}"
55278,"public void replication(RequestContext context,Asset asset){
  final QueueSource queueSource;
  final HostIdentifier hostIdentifier;
  try {
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    queueSource=asset.findView(QueueSource.class);
  }
 catch (  AssetNotFoundException anfe) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + anfe.getMessage());
    return;
  }
  final int remoteSourceIdentifier=queueSource.sourceHostId(context.fullName());
  isSource=hostIdentifier.hostId() == remoteSourceIdentifier;
  isReplicating=true;
  final Clusters clusters=asset.findView(Clusters.class);
  if (clusters == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  final EngineCluster engineCluster=clusters.get(context.cluster());
  final String csp=context.fullName();
  if (engineCluster == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  byte localIdentifier=hostIdentifier.hostId();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ engineCluster.hostDetails());
  for (  EngineHostDetails hostDetails : engineCluster.hostDetails()) {
    byte remoteIdentifier=(byte)hostDetails.hostId();
    if (remoteIdentifier == localIdentifier)     continue;
    engineCluster.findConnectionManager(remoteIdentifier).addListener((nc,isConnected) -> {
      if (!isConnected)       return;
      if (nc.isAcceptor())       return;
      final boolean isSource0=(remoteIdentifier == remoteSourceIdentifier);
      WriteMarshallable h=isSource0 ? newSource(lastIndexReceived()) : newSync();
      long cid=nc.newCid();
      nc.wireOutPublisher().publish(w -> w.writeDocument(true,d -> d.writeEventName(CoreFields.csp).text(csp).writeEventName(CoreFields.cid).int64(cid).writeEventName(CoreFields.handler).typedMarshallable(h)));
    }
);
  }
}","public void replication(RequestContext context,Asset asset){
  final QueueSource queueSource;
  final HostIdentifier hostIdentifier;
  try {
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    queueSource=asset.findView(QueueSource.class);
  }
 catch (  AssetNotFoundException anfe) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + anfe.getMessage());
    return;
  }
  final int remoteSourceIdentifier=queueSource.sourceHostId(context.fullName());
  isSource=hostIdentifier.hostId() == remoteSourceIdentifier;
  isReplicating=true;
  final Clusters clusters=asset.findView(Clusters.class);
  if (clusters == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  final EngineCluster engineCluster=clusters.get(context.cluster());
  final String csp=context.fullName();
  if (engineCluster == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  byte localIdentifier=hostIdentifier.hostId();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ engineCluster.hostDetails());
  for (  EngineHostDetails hostDetails : engineCluster.hostDetails()) {
    byte remoteIdentifier=(byte)hostDetails.hostId();
    if (remoteIdentifier == localIdentifier)     continue;
    engineCluster.findConnectionManager(remoteIdentifier).addListener((nc,isConnected) -> {
      if (!isConnected)       return;
      if (nc.isAcceptor())       return;
      final boolean isSource0=(remoteIdentifier == remoteSourceIdentifier);
      WriteMarshallable h=isSource0 ? newSource(lastIndexReceived(),context.topicType(),context.elementType()) : newSync(context.topicType(),context.elementType());
      long cid=nc.newCid();
      nc.wireOutPublisher().publish(w -> w.writeDocument(true,d -> d.writeEventName(CoreFields.csp).text(csp).writeEventName(CoreFields.cid).int64(cid).writeEventName(CoreFields.handler).typedMarshallable(h)));
    }
);
  }
}"
55279,"public static WriteMarshallable newSync(){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    return (WriteMarshallable)aClass.newInstance();
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}","public static WriteMarshallable newSync(Class topicType,Class elementType){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getConstructor(Class.class,Class.class);
    return (WriteMarshallable)declaredConstructor.newInstance(topicType,elementType);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}"
55280,"public static WriteMarshallable newSource(long lastIndexReceived){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getDeclaredConstructor(long.class);
    return (WriteMarshallable)declaredConstructor.newInstance(lastIndexReceived);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}","public static WriteMarshallable newSource(long lastIndexReceived,Class topicType,Class elementType){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getDeclaredConstructor(long.class,Class.class,Class.class);
    return (WriteMarshallable)declaredConstructor.newInstance(lastIndexReceived,topicType,elementType);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}"
55281,"public ChronicleQueueView(@Nullable ChronicleQueue queue,@NotNull RequestContext context,@NotNull Asset asset){
  String s=asset.fullName();
  if (s.startsWith(""String_Node_Str""))   s=s.substring(1);
  defaultPath=s;
  final HostIdentifier hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
  final Byte hostId=hostIdentifier == null ? null : hostIdentifier.hostId();
  chronicleQueue=queue != null ? queue : newInstance(context.name(),context.basePath(),hostId);
  messageTypeClass=context.messageType();
  elementTypeClass=context.elementType();
  LOG.info(""String_Node_Str"" + context.name() + ""String_Node_Str""+ chronicleQueue);
  threadLocal=ThreadLocal.withInitial(() -> new ThreadLocalData(chronicleQueue));
  if (hostId != null)   replication(context,asset);
}","public ChronicleQueueView(@Nullable ChronicleQueue queue,@NotNull RequestContext context,@NotNull Asset asset){
  String s=asset.fullName();
  if (s.startsWith(""String_Node_Str""))   s=s.substring(1);
  defaultPath=s;
  final HostIdentifier hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
  final Byte hostId=hostIdentifier == null ? null : hostIdentifier.hostId();
  chronicleQueue=queue != null ? queue : newInstance(context.name(),context.basePath(),hostId);
  messageTypeClass=context.messageType();
  elementTypeClass=context.elementType();
  threadLocal=ThreadLocal.withInitial(() -> new ThreadLocalData(chronicleQueue));
  if (hostId != null)   replication(context,asset);
}"
55282,"/** 
 * peeks the csp or if it has a cid converts the cid into a Csp and returns that
 * @return {@code true} if if a csp was read rather than a cid
 */
boolean readMeta(@NotNull final WireIn wireIn){
}","/** 
 * peeks the csp or if it has a cid converts the cid into a Csp and returns that
 * @return {@code true} if if a csp was read rather than a cid
 */
boolean readMeta(@NotNull final WireIn wireIn,String yaml){
}"
55283,"@Override public void onInitialize(@NotNull WireOut outWire){
  if (isClosed())   return;
  Asset rootAsset=nc().rootAsset();
  final RequestContext requestContext=RequestContext.requestContext(csp());
  final Asset asset=rootAsset.acquireAsset(requestContext.fullName());
  replication=asset.acquireView(Replication.class,RequestContext.requestContext(asset.fullName()).keyType(keyType).valueType(valueType));
  if (nc().isAcceptor()) {
    final long lastUpdateTime=replication.lastModificationTime((byte)remoteIdentifier());
    WriteMarshallable writeMarshallable=newMapReplicationHandler(lastUpdateTime,keyType,valueType,csp(),cid());
    publish(writeMarshallable);
  }
  final HostIdentifier hostIdentifier=rootAsset.findOrCreateView(HostIdentifier.class);
  if (hostIdentifier != null)   localIdentifier=hostIdentifier.hostId();
  EventLoop eventLoop=rootAsset.findOrCreateView(EventLoop.class);
  eventLoop.start();
  final ModificationIterator mi=replication.acquireModificationIterator((byte)remoteIdentifier());
  if (mi != null)   mi.dirtyEntries(timestamp);
  if (mi == null)   return;
  mi.setModificationNotifier(eventLoop::unpause);
  if (!eventLoop.isAlive() && !eventLoop.isClosed())   throw new IllegalStateException(""String_Node_Str"");
  eventLoop.addHandler(true,new ReplicationEventHandler(mi,(byte)remoteIdentifier()));
}","@Override public void onInitialize(@NotNull WireOut outWire){
  if (isClosed())   return;
  Asset rootAsset=nc().rootAsset();
  final RequestContext requestContext=RequestContext.requestContext(csp());
  final Asset asset=rootAsset.acquireAsset(requestContext.fullName());
  replication=asset.acquireView(Replication.class,RequestContext.requestContext(asset.fullName()).keyType(keyType).valueType(valueType));
  final long lastUpdateTime=replication.lastModificationTime((byte)remoteIdentifier());
  WriteMarshallable writeMarshallable=newMapReplicationHandler(lastUpdateTime,keyType,valueType,csp(),cid());
  publish(writeMarshallable);
  final HostIdentifier hostIdentifier=rootAsset.findOrCreateView(HostIdentifier.class);
  if (hostIdentifier != null)   localIdentifier=hostIdentifier.hostId();
  EventLoop eventLoop=rootAsset.findOrCreateView(EventLoop.class);
  eventLoop.start();
  final ModificationIterator mi=replication.acquireModificationIterator((byte)remoteIdentifier());
  if (mi != null)   mi.dirtyEntries(timestamp);
  if (mi == null)   return;
  mi.setModificationNotifier(eventLoop::unpause);
  if (!eventLoop.isAlive() && !eventLoop.isClosed())   throw new IllegalStateException(""String_Node_Str"");
  eventLoop.addHandler(true,new ReplicationEventHandler(mi,(byte)remoteIdentifier()));
}"
55284,"@Override protected void process(@NotNull WireIn inWire,@NotNull WireOut outWire){
  String s=Wires.fromSizePrefixedBlobs(inWire.bytes());
  if (YamlLogging.showServerReads() && inWire.hasMore())   LOG.info(""String_Node_Str"" + s);
  onMessageReceived();
  boolean processedData=false;
  while (inWire.hasMore()) {
    try (final DocumentContext dc=inWire.readingDocument()){
      if (!dc.isPresent())       continue;
      if (dc.isMetaData()) {
        if (!readMeta(inWire))         continue;
        handler().remoteIdentifier(remoteIdentifier);
        handler().localIdentifier(localIdentifier);
        handler().onInitialize(outWire);
        continue;
      }
      if (dc.isData() && handler() != null) {
        handler().processData(inWire,outWire);
        processedData=true;
      }
 else {
        if (handler() == null)         throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ s);
 else         throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ s);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
  final SubHandler handler=handler();
  if (!processedData && handler != null)   handler.processData(Wires.EMPTY,outWire);
}","@Override protected void process(@NotNull WireIn inWire,@NotNull WireOut outWire){
  String s=Wires.fromSizePrefixedBlobs(inWire.bytes());
  if (YamlLogging.showServerReads() && inWire.hasMore())   LOG.info(""String_Node_Str"" + s);
  onMessageReceived();
  boolean processedData=false;
  while (inWire.hasMore()) {
    String yaml=Wires.fromSizePrefixedBlobs(inWire.bytes());
    try (final DocumentContext dc=inWire.readingDocument()){
      if (!dc.isPresent())       continue;
      if (dc.isMetaData()) {
        if (!readMeta(inWire,yaml))         continue;
        handler().remoteIdentifier(remoteIdentifier);
        handler().localIdentifier(localIdentifier);
        handler().onInitialize(outWire);
        continue;
      }
      if (handler() == null)       throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ s);
      if (dc.isData()) {
        handler().processData(inWire,outWire);
        processedData=true;
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
  final SubHandler handler=handler();
  if (!processedData && handler != null)   handler.processData(Wires.EMPTY,outWire);
}"
55285,"public void replication(RequestContext context,Asset asset){
  final QueueSource queueSource;
  final HostIdentifier hostIdentifier;
  try {
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    queueSource=asset.findView(QueueSource.class);
  }
 catch (  AssetNotFoundException anfe) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + anfe.getMessage());
    return;
  }
  final int remoteSourceIdentifier=queueSource.sourceHostId(context.fullName());
  isSource=hostIdentifier.hostId() == remoteSourceIdentifier;
  isReplicating=true;
  final Clusters clusters=asset.findView(Clusters.class);
  if (clusters == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  final EngineCluster engineCluster=clusters.get(context.cluster());
  final String csp=context.fullName();
  if (engineCluster == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  byte localIdentifier=hostIdentifier.hostId();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ engineCluster.hostDetails());
  for (  EngineHostDetails hostDetails : engineCluster.hostDetails()) {
    byte remoteIdentifier=(byte)hostDetails.hostId();
    if (remoteIdentifier == localIdentifier)     continue;
    engineCluster.findConnectionManager(remoteIdentifier).addListener((nc,isConnected) -> {
      if (!isConnected)       return;
      final boolean isSource0=(remoteIdentifier == remoteSourceIdentifier);
      WriteMarshallable h=isSource0 ? newSource(lastIndexReceived()) : newSync();
      long cid=""String_Node_Str"".hashCode();
      nc.wireOutPublisher().publish(w -> w.writeDocument(true,d -> d.writeEventName(CoreFields.csp).text(csp).writeEventName(CoreFields.cid).int64(cid).writeEventName(CoreFields.handler).typedMarshallable(h)));
    }
);
  }
}","public void replication(RequestContext context,Asset asset){
  final QueueSource queueSource;
  final HostIdentifier hostIdentifier;
  try {
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    queueSource=asset.findView(QueueSource.class);
  }
 catch (  AssetNotFoundException anfe) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + anfe.getMessage());
    return;
  }
  final int remoteSourceIdentifier=queueSource.sourceHostId(context.fullName());
  isSource=hostIdentifier.hostId() == remoteSourceIdentifier;
  isReplicating=true;
  final Clusters clusters=asset.findView(Clusters.class);
  if (clusters == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  final EngineCluster engineCluster=clusters.get(context.cluster());
  final String csp=context.fullName();
  if (engineCluster == null) {
    LOG.warn(""String_Node_Str"" + context.cluster());
    return;
  }
  byte localIdentifier=hostIdentifier.hostId();
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ engineCluster.hostDetails());
  for (  EngineHostDetails hostDetails : engineCluster.hostDetails()) {
    byte remoteIdentifier=(byte)hostDetails.hostId();
    if (remoteIdentifier == localIdentifier)     continue;
    engineCluster.findConnectionManager(remoteIdentifier).addListener((nc,isConnected) -> {
      if (!isConnected)       return;
      if (nc.isAcceptor())       return;
      final boolean isSource0=(remoteIdentifier == remoteSourceIdentifier);
      WriteMarshallable h=isSource0 ? newSource(lastIndexReceived()) : newSync();
      long cid=nc.newCid();
      nc.wireOutPublisher().publish(w -> w.writeDocument(true,d -> d.writeEventName(CoreFields.csp).text(csp).writeEventName(CoreFields.cid).int64(cid).writeEventName(CoreFields.handler).typedMarshallable(h)));
    }
);
  }
}"
55286,"private WriteMarshallable newSync(){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    return (WriteMarshallable)aClass.newInstance();
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}","public static WriteMarshallable newSync(){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    return (WriteMarshallable)aClass.newInstance();
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}"
55287,"private WriteMarshallable newSource(long lastIndexReceived){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getDeclaredConstructor(long.class);
    return (WriteMarshallable)declaredConstructor.newInstance(lastIndexReceived);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}","public static WriteMarshallable newSource(long lastIndexReceived){
  try {
    Class<?> aClass=Class.forName(""String_Node_Str"");
    Constructor<?> declaredConstructor=aClass.getDeclaredConstructor(long.class);
    return (WriteMarshallable)declaredConstructor.newInstance(lastIndexReceived);
  }
 catch (  Exception e) {
    IllegalStateException licence=new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    LOG.error(""String_Node_Str"",e);
    throw licence;
  }
}"
55288,"private void onPut0(@NotNull K key,V newValue,@Nullable V replacedValue,boolean replicationEvent,boolean added,boolean hasValueChanged){
  if (added) {
    subscriptions.notifyEvent(InsertedEvent.of(assetFullName,key,newValue,replicationEvent));
  }
 else {
    subscriptions.notifyEvent(UpdatedEvent.of(assetFullName,key,replacedValue,newValue,replicationEvent,hasValueChanged));
  }
}","private void onPut0(@NotNull K key,V newValue,@Nullable V replacedValue,boolean replicationEvent,boolean added,boolean hasValueChanged){
  if (added) {
    subscriptions.notifyEvent(InsertedEvent.of(assetFullName,key,newValue,replicationEvent));
  }
 else {
    if (hasValueChanged)     subscriptions.notifyEvent(UpdatedEvent.of(assetFullName,key,replacedValue,newValue,replicationEvent,hasValueChanged));
  }
}"
55289,"@Test public void testBootstrapAllFromMap1WithSubscription2() throws InterruptedException {
  AtomicInteger map1Updates=new AtomicInteger();
  AtomicInteger map2Updates=new AtomicInteger();
  final ConcurrentMap<String,String> map1=tree1.acquireMap(name,String.class,String.class);
  assertNotNull(map1);
  tree1.registerSubscriber(name,MapEvent.class,f -> map1Updates.incrementAndGet());
  map1.clear();
  map1.put(""String_Node_Str"",""String_Node_Str"");
  map1.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(2);
  final ConcurrentMap<String,String> map2=tree2.acquireMap(name,String.class,String.class);
  Thread.sleep(1000);
  tree2.registerSubscriber(name,MapEvent.class,f -> map2Updates.incrementAndGet());
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  assertNotNull(map2);
  for (int i=1; i <= 50; i++) {
    if (map1.size() == 2 && map2.size() == 2)     break;
    Jvm.pause(300);
  }
  for (  Map m : new Map[]{map1,map2}) {
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(2,m.size());
  }
  Assert.assertEquals(2,map1Updates.get());
}","@Test public void testBootstrapAllFromMap1WithSubscription2() throws InterruptedException {
  AtomicInteger map1Updates=new AtomicInteger();
  AtomicInteger map2Updates=new AtomicInteger();
  final ConcurrentMap<String,String> map1=tree1.acquireMap(name,String.class,String.class);
  assertNotNull(map1);
  tree1.registerSubscriber(name,MapEvent.class,f -> map1Updates.incrementAndGet());
  map1.clear();
  map1.put(""String_Node_Str"",""String_Node_Str"");
  map1.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(2);
  final ConcurrentMap<String,String> map2=tree2.acquireMap(name,String.class,String.class);
  Thread.sleep(1000);
  tree2.registerSubscriber(name,MapEvent.class,f -> {
    System.out.println((""String_Node_Str"" + f));
    map2Updates.incrementAndGet();
  }
);
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  assertNotNull(map2);
  for (int i=1; i <= 50; i++) {
    if (map1.size() == 2 && map2.size() == 2)     break;
    Jvm.pause(300);
  }
  for (  Map m : new Map[]{map1,map2}) {
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(2,m.size());
  }
  Assert.assertEquals(2,map1Updates.get());
  Assert.assertEquals(2,map2Updates.get());
}"
55290,"@Test public void testBootstrapAllFromMap1WithSubscription2() throws InterruptedException {
  AtomicInteger map1Updates=new AtomicInteger();
  AtomicInteger map2Updates=new AtomicInteger();
  final ConcurrentMap<String,String> map1=tree1.acquireMap(name,String.class,String.class);
  assertNotNull(map1);
  tree1.registerSubscriber(name,MapEvent.class,f -> map1Updates.incrementAndGet());
  map1.clear();
  map1.put(""String_Node_Str"",""String_Node_Str"");
  map1.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(2);
  final ConcurrentMap<String,String> map2=tree2.acquireMap(name,String.class,String.class);
  Thread.sleep(1000);
  tree2.registerSubscriber(name,MapEvent.class,f -> {
    System.out.println((""String_Node_Str"" + f));
    map2Updates.incrementAndGet();
  }
);
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  assertNotNull(map2);
  for (int i=1; i <= 50; i++) {
    if (map1.size() == 2 && map2.size() == 2)     break;
    Jvm.pause(300);
  }
  for (  Map m : new Map[]{map1,map2}) {
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(2,m.size());
  }
  Assert.assertEquals(2,map1Updates.get());
  Assert.assertEquals(2,map2Updates.get());
}","@Test public void testBootstrapAllFromMap1WithSubscription2() throws InterruptedException {
  AtomicInteger map1Updates=new AtomicInteger();
  AtomicInteger map2Updates=new AtomicInteger();
  final ConcurrentMap<String,String> map1=tree1.acquireMap(name,String.class,String.class);
  assertNotNull(map1);
  tree1.registerSubscriber(name,MapEvent.class,f -> map1Updates.incrementAndGet());
  map1.clear();
  map1.put(""String_Node_Str"",""String_Node_Str"");
  map1.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(2);
  final ConcurrentMap<String,String> map2=tree2.acquireMap(name,String.class,String.class);
  Thread.sleep(1000);
  tree2.registerSubscriber(name,MapEvent.class,f -> map2Updates.incrementAndGet());
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  assertNotNull(map2);
  for (int i=1; i <= 50; i++) {
    if (map1.size() == 2 && map2.size() == 2)     break;
    Jvm.pause(300);
  }
  for (  Map m : new Map[]{map1,map2}) {
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",m.get(""String_Node_Str""));
    Assert.assertEquals(2,m.size());
  }
  Assert.assertEquals(2,map1Updates.get());
  Assert.assertEquals(2,map2Updates.get());
}"
55291,"/** 
 * Get or create a view with out a RequestContext.  First it looks for a matching viewType(). If found this is returned. The viewType given overrides the type provided in the RequestContext.
 * @param viewType to obtain.
 * @return the View obtained.
 * @throws AssetNotFoundException if the Asset could not be created. This can happen if arequired rule is not provided.
 */
@NotNull default <V>V acquireView(Class<V> viewType){
  return acquireView(viewType,RequestContext.requestContext(fullName()).viewType(viewType));
}","/** 
 * Get or create a view with out a RequestContext.  First it looks for a matching viewType(). If found this is returned. The viewType given overrides the type provided in the RequestContext.
 * @param viewType to obtain.
 * @return the View obtained.
 * @throws AssetNotFoundException if the Asset could not be created. This can happen if arequired rule is not provided.
 */
@NotNull default <V>V acquireView(Class<V> viewType){
  return acquireView(viewType,RequestContext.requestContext(fullName()));
}"
55292,"@NotNull @Override public KeySetView<K> keySet(){
  return asset.acquireView(KeySetView.class);
}","@NotNull @Override public KeySetView<K> keySet(){
  return asset.acquireView(KeySetView.class,context);
}"
55293,"@Override public void registerDownstream(@NotNull EventConsumer<K,V> subscription){
  registerSubscriber(rc.clone().type(MapEvent.class).type2(null),subscription::notifyEvent,Filter.empty());
}","@Override public void registerDownstream(@NotNull EventConsumer<K,V> subscription){
  registerSubscriber(rc.clone().messageType(rc.messageType()).elementType(MapEvent.class),subscription::notifyEvent,Filter.empty());
}"
55294,"@Override public void registerKeySubscriber(@org.jetbrains.annotations.NotNull @NotNull Subscriber<K> subscriber,@org.jetbrains.annotations.NotNull @NotNull Filter filter,@org.jetbrains.annotations.NotNull @NotNull Set<RequestContext.Operation> contextOperations){
  final KVSSubscription<K,V> subscription=(KVSSubscription<K,V>)asset.subscription(true);
  final RequestContext rc=RequestContext.requestContext().type(keyClass);
  contextOperations.forEach(e -> e.apply(rc));
  subscription.registerKeySubscriber(rc,subscriber,filter);
}","@Override public void registerKeySubscriber(@org.jetbrains.annotations.NotNull @NotNull Subscriber<K> subscriber,@org.jetbrains.annotations.NotNull @NotNull Filter filter,@org.jetbrains.annotations.NotNull @NotNull Set<RequestContext.Operation> contextOperations){
  final KVSSubscription<K,V> subscription=(KVSSubscription<K,V>)asset.subscription(true);
  final RequestContext rc=RequestContext.requestContext().type(keyClass).type2(valueType);
  contextOperations.forEach(e -> e.apply(rc));
  subscription.registerKeySubscriber(rc,subscriber,filter);
}"
55295,"/** 
 * before writing the tid to the wire
 * @param tid     the tid
 * @param valueIn the value in from the wire
 * @return true if processed
 */
boolean before(Long tid,@NotNull ValueIn valueIn) throws AssetNotFoundException {
  if (registerSubscriber.contentEquals(eventName)) {
    final Class subscriptionType=valueIn.typeLiteral();
    final StringBuilder sb=Wires.acquireStringBuilder();
    final ValueIn valueIn1=valueIn.wireIn().readEventName(sb);
    final Filter filter=""String_Node_Str"".contentEquals(sb) ? valueIn1.object(Filter.class) : Filter.empty();
    if (tidToListener.containsKey(tid)) {
      LOG.info(""String_Node_Str"" + tid);
      return true;
    }
    final WireOutPublisher pub=(requestContext.throttlePeriodMs() == 0) ? publisher : newThrottledWireOutPublisher(requestContext.throttlePeriodMs(),publisher);
    Subscriber<Object> listener=new LocalSubscriber(tid,pub);
    tidToListener.put(tid,listener);
    RequestContext rc=requestContext.clone().type2(subscriptionType);
    final SubscriptionCollection subscription=assetTree.acquireSubscription(rc);
    subscription.registerSubscriber(rc,listener,filter);
    return true;
  }
  if (unregisterSubscriber.contentEquals(eventName)) {
    Subscriber<Object> listener=(Subscriber)tidToListener.remove(tid);
    if (listener == null) {
      SubscriptionHandler.LOG.warn(""String_Node_Str"" + tid + ""String_Node_Str"");
      return true;
    }
    assetTree.unregisterSubscriber(requestContext.fullName(),listener);
    return true;
  }
  return false;
}","/** 
 * before writing the tid to the wire
 * @param tid     the tid
 * @param valueIn the value in from the wire
 * @return true if processed
 */
boolean before(Long tid,@NotNull ValueIn valueIn) throws AssetNotFoundException {
  if (registerSubscriber.contentEquals(eventName)) {
    final Class subscriptionType=valueIn.typeLiteral();
    final StringBuilder sb=Wires.acquireStringBuilder();
    final ValueIn valueIn1=valueIn.wireIn().readEventName(sb);
    final Filter filter=""String_Node_Str"".contentEquals(sb) ? valueIn1.object(Filter.class) : Filter.empty();
    if (tidToListener.containsKey(tid)) {
      LOG.info(""String_Node_Str"" + tid);
      return true;
    }
    final WireOutPublisher pub=(requestContext.throttlePeriodMs() == 0) ? publisher : newThrottledWireOutPublisher(requestContext.throttlePeriodMs(),publisher);
    Subscriber<Object> listener=new LocalSubscriber(tid,pub);
    tidToListener.put(tid,listener);
    RequestContext rc=requestContext.clone().elementType(subscriptionType);
    final SubscriptionCollection subscription=assetTree.acquireSubscription(rc);
    subscription.registerSubscriber(rc,listener,filter);
    return true;
  }
  if (unregisterSubscriber.contentEquals(eventName)) {
    Subscriber<Object> listener=(Subscriber)tidToListener.remove(tid);
    if (listener == null) {
      SubscriptionHandler.LOG.warn(""String_Node_Str"" + tid + ""String_Node_Str"");
      return true;
    }
    assetTree.unregisterSubscriber(requestContext.fullName(),listener);
    return true;
  }
  return false;
}"
55296,"private void connectClientAndPerformPutGetTest(String testKey,String value,BlockingQueue<String> eventQueue) throws InterruptedException {
  VanillaAssetTree remote=new VanillaAssetTree().forRemoteAccess(CONNECTION_1,WIRE_TYPE,x -> t.set(x));
  String keySubUri=_testMapUri + ""String_Node_Str"" + testKey+ ""String_Node_Str"";
  Map<String,String> map=remote.acquireMap(_testMapUri,String.class,String.class);
  map.size();
  System.out.println(""String_Node_Str"");
  remote.registerSubscriber(keySubUri + ""String_Node_Str"",String.class,(e) -> eventQueue.add(e));
  Thread.sleep(100);
  map.put(testKey,value);
  Assert.assertEquals(value,eventQueue.poll(2,SECONDS));
  String getValue=map.get(testKey);
  Assert.assertEquals(value,getValue);
  remote.close();
}","private void connectClientAndPerformPutGetTest(String testKey,String value,BlockingQueue<String> eventQueue) throws InterruptedException {
  VanillaAssetTree remote=new VanillaAssetTree().forRemoteAccess(CONNECTION_1,WIRE_TYPE,x -> t.set(x));
  String keySubUri=_testMapUri + ""String_Node_Str"" + testKey+ ""String_Node_Str"";
  Map<String,String> map=remote.acquireMap(_testMapUri,String.class,String.class);
  map.size();
  remote.registerSubscriber(keySubUri + ""String_Node_Str"",String.class,(e) -> eventQueue.add(e));
  Thread.sleep(100);
  map.put(testKey,value);
  Assert.assertEquals(value,eventQueue.poll(2,SECONDS));
  String getValue=map.get(testKey);
  Assert.assertEquals(value,getValue);
  remote.close();
}"
55297,"@Before public void before() throws IOException {
  serverAssetTree=new VanillaAssetTree().forTesting(x -> t.compareAndSet(null,x));
  if (isRemote) {
    methodName(name.getMethodName());
    connection=""String_Node_Str"";
    TCPRegistry.createServerSocketChannelFor(connection);
    serverEndpoint=new ServerEndpoint(connection,serverAssetTree,wireType);
    assetTree=new VanillaAssetTree().forRemoteAccess(connection,wireType,x -> t.set(x));
  }
 else {
    assetTree=serverAssetTree;
  }
  map=assetTree.acquireMap(NAME,String.class,String.class);
}","@Before public void before() throws IOException {
  serverAssetTree=new VanillaAssetTree().forTesting(x -> t.compareAndSet(null,x));
  if (isRemote) {
    methodName(name.getMethodName());
    connection=""String_Node_Str"";
    TCPRegistry.createServerSocketChannelFor(connection);
    serverEndpoint=new ServerEndpoint(connection,serverAssetTree,wireType);
    assetTree=new VanillaAssetTree().forRemoteAccess(connection,wireType,x -> t.set(x));
  }
 else {
    assetTree=serverAssetTree;
  }
  YamlLogging.setAll(true);
}"
55298,"@After public void after() throws IOException {
  assetTree.close();
  Jvm.pause(1000);
  if (serverEndpoint != null)   serverEndpoint.close();
  serverAssetTree.close();
  if (map instanceof Closeable)   ((Closeable)map).close();
  TcpChannelHub.closeAllHubs();
  TCPRegistry.reset();
}","@After public void after() throws IOException {
  assetTree.close();
  Jvm.pause(1000);
  if (serverEndpoint != null)   serverEndpoint.close();
  serverAssetTree.close();
  TcpChannelHub.closeAllHubs();
  TCPRegistry.reset();
}"
55299,"@Test(timeout=10000) public void testForEach() throws Exception {
  final MapView<Integer,Integer> map=assetTree.acquireMap(""String_Node_Str"",Integer.class,Integer.class);
  map.put(1,1);
  map.put(2,2);
  map.put(3,3);
  final Query<Integer> query=map.keySet().query();
  query.filter((obj) -> obj >= 1 && obj <= 2).forEach(System.out::println);
}","@Test(timeout=100000000) public void testForEach() throws Exception {
  final MapView<Integer,Integer> map=assetTree.acquireMap(""String_Node_Str"",Integer.class,Integer.class);
  map.put(1,1);
  map.put(2,2);
  map.put(3,3);
  final Query<Integer> query=map.keySet().query();
  query.filter((obj) -> obj >= 1 && obj <= 2).forEach(System.out::println);
}"
55300,"@Override public void registerSubscriber(@NotNull RequestContext rc,@NotNull Subscriber subscriber,@NotNull Filter filter){
  Class eClass=rc.type();
  if (eClass == Entry.class || eClass == MapEvent.class)   registerSubscriber0(rc,subscriber,filter);
 else   registerKeySubscriber(rc,subscriber,filter);
}","@Override public void registerSubscriber(@NotNull RequestContext rc,@NotNull Subscriber subscriber,@NotNull Filter filter){
  Class eClass=rc.elementType();
  if (eClass == Entry.class || eClass == MapEvent.class)   registerSubscriber0(rc,subscriber,filter);
 else   registerKeySubscriber(rc,subscriber,filter);
}"
55301,"@Override public void onEndOfConnection(boolean heartbeatTimeOut){
  for (  final AbstractHandler abstractHandler : new AbstractHandler[]{mapWireHandler,subscriptionHandler,topologySubscriptionHandler,publisherHandler,replicationHandler}) {
    abstractHandler.onEndOfConnection(heartbeatTimeOut);
  }
}","@Override public void onEndOfConnection(boolean heartbeatTimeOut){
  for (  final AbstractHandler abstractHandler : new AbstractHandler[]{mapWireHandler,subscriptionHandler,topologySubscriptionHandler,publisherHandler,replicationHandler}) {
    abstractHandler.onEndOfConnection(heartbeatTimeOut);
  }
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
55302,"public static void main(String[] args) throws IOException, InterruptedException {
  YamlLogging.clientWrites=false;
  YamlLogging.clientReads=false;
  YamlLogging.setAll(false);
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  WireType writeType=WireType.BINARY;
  char[] x=new char[VALUE_SIZE];
  Arrays.fill(x,'X');
  final String s=new String(x);
  VanillaAssetTree tree1=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
  Executors.newSingleThreadExecutor().submit(() -> {
    final ConcurrentMap<String,String> map1=tree1.acquireMap(NAME,String.class,String.class);
    for (; ; ) {
      for (int i=0; i < entries; i++) {
        try {
          map1.put(""String_Node_Str"" + i,s);
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
  }
);
  YamlLogging.setAll(false);
  final ConcurrentMap<String,String> map;
  AssetTree tree3=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
  tree3.acquireMap(NAME,String.class,String.class).size();
  int[] count={0};
  tree3.registerSubscriber(NAME,MapEvent.class,me -> {
    System.out.print((me == null) ? ""String_Node_Str"" : me.getKey());
    if (++count[0] >= 20) {
      System.out.println();
      count[0]=0;
    }
 else {
      System.out.print(""String_Node_Str"");
    }
  }
);
  System.in.read();
}","public static void main(String[] args) throws IOException, InterruptedException {
  YamlLogging.clientWrites=false;
  YamlLogging.clientReads=false;
  YamlLogging.setAll(false);
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  WireType writeType=WireType.BINARY;
  char[] x=new char[VALUE_SIZE];
  Arrays.fill(x,'X');
  final String s=new String(x);
  Executors.newSingleThreadExecutor().submit(() -> {
    VanillaAssetTree tree5=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
    final ConcurrentMap<String,String> map1=tree5.acquireMap(NAME,String.class,String.class);
    for (; ; ) {
      for (int i=0; i < entries; i++) {
        try {
          map1.put(""String_Node_Str"" + i,s);
          Thread.sleep(20);
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
  }
);
  YamlLogging.setAll(false);
  final ConcurrentMap<String,String> map;
  AssetTree tree3=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
  tree3.acquireMap(NAME,String.class,String.class).size();
  int[] count={0};
  tree3.registerSubscriber(NAME,MapEvent.class,me -> {
    System.out.print((me == null) ? ""String_Node_Str"" : me.getKey());
    if (++count[0] >= 20) {
      System.out.println();
      count[0]=0;
    }
 else {
      System.out.print(""String_Node_Str"");
    }
  }
);
  System.in.read();
}"
55303,"@NotNull private net.openhft.lang.io.Bytes toLangBytes(@NotNull BytesStore b){
  if (b.underlyingObject() == null)   return wrap(b.address(b.start()),b.readRemaining());
 else {
    final ByteBuffer buffer;
    if (b.underlyingObject() instanceof byte[])     buffer=ByteBuffer.wrap((byte[])b.underlyingObject());
 else     if (b.underlyingObject() instanceof ByteBuffer)     buffer=(ByteBuffer)b.underlyingObject();
 else     throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"" + b.underlyingObject().getClass());
    IByteBufferBytes wrap=ByteBufferBytes.wrap(buffer);
    wrap.limit((int)b.readLimit());
    return wrap;
  }
}","@NotNull private net.openhft.lang.io.Bytes toLangBytes(@NotNull BytesStore b){
  long l=b.readRemaining();
  int i=(int)b.readPosition();
  IByteBufferBytes wrap=ByteBufferBytes.wrap(ByteBuffer.allocate((int)l));
  wrap.clear();
  while (wrap.remaining() > 0) {
    wrap.writeByte(b.readByte(i++));
  }
  wrap.flip();
  return wrap;
}"
55304,"@Nullable @Override public ModificationIterator acquireModificationIterator(final byte remoteIdentifier){
  final EngineModificationIterator instance=engineReplicationLang.acquireEngineModificationIterator(remoteIdentifier);
  return new ModificationIterator(){
    @Override public void forEach(    @NotNull Consumer<ReplicationEntry> consumer){
      while (hasNext()) {
        nextEntry(entry -> {
          consumer.accept(entry);
          return true;
        }
);
      }
    }
    public boolean hasNext(){
      return instance.hasNext();
    }
    public boolean nextEntry(    @NotNull Consumer<ReplicationEntry> consumer){
      return nextEntry(entry -> {
        consumer.accept(entry);
        return true;
      }
);
    }
    boolean nextEntry(    @NotNull final EntryCallback callback){
      return instance.nextEntry((key,value,timestamp,identifier,isDeleted,bootStrapTimeStamp) -> callback.onEntry(new VanillaReplicatedEntry(toKey(key),toValue(value),timestamp,identifier,isDeleted,bootStrapTimeStamp,remoteIdentifier)));
    }
    private Bytes toKey(    final @NotNull net.openhft.lang.io.Bytes key){
      NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
      PointerBytesStore result=keyLocal.get();
      result.set(key.address(),key.capacity());
      result.copyTo(byteStore);
      return byteStore.bytesForRead();
    }
    @Nullable private Bytes<Void> toValue(    final @Nullable net.openhft.lang.io.Bytes value){
      if (value == null)       return null;
      NativeBytesStore<Void> byteStore=NativeBytesStore.lazyNativeBytesStoreWithFixedCapacity(value.remaining());
      PointerBytesStore result=valueLocal.get();
      result.set(value.address(),value.capacity());
      result.copyTo(byteStore);
      return byteStore.bytesForRead();
    }
    @Override public void dirtyEntries(    final long fromTimeStamp){
      instance.dirtyEntries(fromTimeStamp);
    }
    @Override public void setModificationNotifier(    @NotNull final ModificationNotifier modificationNotifier){
      instance.setModificationNotifier(modificationNotifier::onChange);
    }
  }
;
}","@Nullable @Override public ModificationIterator acquireModificationIterator(final byte remoteIdentifier){
  final EngineModificationIterator instance=engineReplicationLang.acquireEngineModificationIterator(remoteIdentifier);
  return new ModificationIterator(){
    @Override public void forEach(    @NotNull Consumer<ReplicationEntry> consumer){
      while (hasNext()) {
        nextEntry(entry -> {
          consumer.accept(entry);
          return true;
        }
);
      }
    }
    public boolean hasNext(){
      return instance.hasNext();
    }
    public boolean nextEntry(    @NotNull Consumer<ReplicationEntry> consumer){
      return nextEntry(entry -> {
        consumer.accept(entry);
        return true;
      }
);
    }
    boolean nextEntry(    @NotNull final EntryCallback callback){
      return instance.nextEntry((key,value,timestamp,identifier,isDeleted,bootStrapTimeStamp) -> callback.onEntry(new VanillaReplicatedEntry(toKey(key),toValue(value),timestamp,identifier,isDeleted,bootStrapTimeStamp,remoteIdentifier)));
    }
    private Bytes toKey(    final @NotNull net.openhft.lang.io.Bytes key){
      final long position=key.position();
      try {
        NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
        int i=(int)key.position();
        while (key.remaining() > 0) {
          byteStore.writeByte(i++,key.readByte());
        }
        return byteStore.bytesForRead();
      }
  finally {
        key.position(position);
      }
    }
    @Nullable private Bytes<Void> toValue(    final @Nullable net.openhft.lang.io.Bytes value){
      if (value == null)       return null;
      if (value.remaining() == 0)       return null;
      final long position=value.position();
      try {
        NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(value.remaining());
        int i=(int)value.position();
        while (value.remaining() > 0) {
          byteStore.writeByte(i++,value.readByte());
        }
        return byteStore.bytesForRead();
      }
  finally {
        value.position(position);
      }
    }
    @Override public void dirtyEntries(    final long fromTimeStamp){
      instance.dirtyEntries(fromTimeStamp);
    }
    @Override public void setModificationNotifier(    @NotNull final ModificationNotifier modificationNotifier){
      instance.setModificationNotifier(modificationNotifier::onChange);
    }
  }
;
}"
55305,"@Nullable private Bytes<Void> toValue(final @Nullable net.openhft.lang.io.Bytes value){
  if (value == null)   return null;
  NativeBytesStore<Void> byteStore=NativeBytesStore.lazyNativeBytesStoreWithFixedCapacity(value.remaining());
  PointerBytesStore result=valueLocal.get();
  result.set(value.address(),value.capacity());
  result.copyTo(byteStore);
  return byteStore.bytesForRead();
}","@Nullable private Bytes<Void> toValue(final @Nullable net.openhft.lang.io.Bytes value){
  if (value == null)   return null;
  if (value.remaining() == 0)   return null;
  final long position=value.position();
  try {
    NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(value.remaining());
    int i=(int)value.position();
    while (value.remaining() > 0) {
      byteStore.writeByte(i++,value.readByte());
    }
    return byteStore.bytesForRead();
  }
  finally {
    value.position(position);
  }
}"
55306,"private Bytes toKey(final @NotNull net.openhft.lang.io.Bytes key){
  NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
  PointerBytesStore result=keyLocal.get();
  result.set(key.address(),key.capacity());
  result.copyTo(byteStore);
  return byteStore.bytesForRead();
}","private Bytes toKey(final @NotNull net.openhft.lang.io.Bytes key){
  final long position=key.position();
  try {
    NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
    int i=(int)key.position();
    while (key.remaining() > 0) {
      byteStore.writeByte(i++,key.readByte());
    }
    return byteStore.bytesForRead();
  }
  finally {
    key.position(position);
  }
}"
55307,"public static void main(String[] args) throws IOException, InterruptedException {
  YamlLogging.clientWrites=false;
  YamlLogging.clientReads=false;
  YamlLogging.setAll(false);
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  WireType writeType=WireType.BINARY;
  char[] x=new char[VALUE_SIZE];
  Arrays.fill(x,'X');
  final String s=new String(x);
  Executors.newSingleThreadExecutor().submit(() -> {
    VanillaAssetTree tree5=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
    final ConcurrentMap<String,String> map1=tree5.acquireMap(NAME,String.class,String.class);
    for (; ; ) {
      for (int i=0; i < entries; i++) {
        try {
          map1.put(""String_Node_Str"" + i,s);
          Thread.sleep(20);
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
  }
);
  YamlLogging.setAll(false);
  final ConcurrentMap<String,String> map;
  AssetTree tree3=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
  tree3.acquireMap(NAME,String.class,String.class).size();
  int[] count={0};
  tree3.registerSubscriber(NAME,MapEvent.class,me -> {
    System.out.print((me == null) ? ""String_Node_Str"" : me.getKey());
    if (++count[0] >= 20) {
      System.out.println();
      count[0]=0;
    }
 else {
      System.out.print(""String_Node_Str"");
    }
  }
);
  System.in.read();
}","public static void main(String[] args) throws IOException, InterruptedException {
  YamlLogging.clientWrites=false;
  YamlLogging.clientReads=false;
  YamlLogging.setAll(false);
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  WireType writeType=WireType.BINARY;
  char[] x=new char[VALUE_SIZE];
  Arrays.fill(x,'X');
  final String s=new String(x);
  Executors.newSingleThreadExecutor().submit(() -> {
    VanillaAssetTree tree5=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
    final ConcurrentMap<String,String> map1=tree5.acquireMap(NAME,String.class,String.class);
    for (; ; ) {
      for (int i=0; i < entries; i++) {
        try {
          map1.put(""String_Node_Str"" + i,s);
          Thread.sleep(20);
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
  }
);
  Executors.newSingleThreadExecutor().submit(() -> {
    VanillaAssetTree tree5=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
    final ConcurrentMap<String,String> map1=tree5.acquireMap(NAME,String.class,String.class);
    for (; ; ) {
      for (int i=0; i < entries; i++) {
        try {
          map1.remove(""String_Node_Str"" + i);
          Thread.sleep(20);
        }
 catch (        Throwable t) {
          t.printStackTrace();
        }
      }
    }
  }
);
  YamlLogging.setAll(false);
  final ConcurrentMap<String,String> map;
  AssetTree tree3=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
  tree3.acquireMap(NAME,String.class,String.class).size();
  int[] count={0};
  tree3.registerSubscriber(NAME,MapEvent.class,me -> {
    System.out.print((me == null) ? ""String_Node_Str"" : me.getKey());
    if (++count[0] >= 20) {
      System.out.println();
      count[0]=0;
    }
 else {
      System.out.print(""String_Node_Str"");
    }
  }
);
  System.in.read();
}"
55308,"@Nullable @Override public ModificationIterator acquireModificationIterator(final byte remoteIdentifier){
  final EngineModificationIterator instance=engineReplicationLang.acquireEngineModificationIterator(remoteIdentifier);
  return new ModificationIterator(){
    @Override public void forEach(    @NotNull Consumer<ReplicationEntry> consumer){
      while (hasNext()) {
        nextEntry(entry -> {
          consumer.accept(entry);
          return true;
        }
);
      }
    }
    public boolean hasNext(){
      return instance.hasNext();
    }
    public boolean nextEntry(    @NotNull Consumer<ReplicationEntry> consumer){
      return nextEntry(entry -> {
        consumer.accept(entry);
        return true;
      }
);
    }
    boolean nextEntry(    @NotNull final EntryCallback callback){
      return instance.nextEntry((key,value,timestamp,identifier,isDeleted,bootStrapTimeStamp) -> callback.onEntry(new VanillaReplicatedEntry(toKey(key),toValue(value),timestamp,identifier,isDeleted,bootStrapTimeStamp,remoteIdentifier)));
    }
    private Bytes toKey(    final @NotNull net.openhft.lang.io.Bytes key){
      NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
      int i=(int)key.position();
      while (key.remaining() > 0) {
        byteStore.writeByte(i++,(byte)key.readByte());
      }
      return byteStore.bytesForRead();
    }
    @Nullable private Bytes<Void> toValue(    final @Nullable net.openhft.lang.io.Bytes value){
      if (value == null)       return null;
      NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(value.remaining());
      int i=(int)value.position();
      while (value.remaining() > 0) {
        byteStore.writeByte(i++,(byte)value.readByte());
      }
      return byteStore.bytesForRead();
    }
    @Override public void dirtyEntries(    final long fromTimeStamp){
      instance.dirtyEntries(fromTimeStamp);
    }
    @Override public void setModificationNotifier(    @NotNull final ModificationNotifier modificationNotifier){
      instance.setModificationNotifier(modificationNotifier::onChange);
    }
  }
;
}","@Nullable @Override public ModificationIterator acquireModificationIterator(final byte remoteIdentifier){
  final EngineModificationIterator instance=engineReplicationLang.acquireEngineModificationIterator(remoteIdentifier);
  return new ModificationIterator(){
    @Override public void forEach(    @NotNull Consumer<ReplicationEntry> consumer){
      while (hasNext()) {
        nextEntry(entry -> {
          consumer.accept(entry);
          return true;
        }
);
      }
    }
    public boolean hasNext(){
      return instance.hasNext();
    }
    public boolean nextEntry(    @NotNull Consumer<ReplicationEntry> consumer){
      return nextEntry(entry -> {
        consumer.accept(entry);
        return true;
      }
);
    }
    boolean nextEntry(    @NotNull final EntryCallback callback){
      return instance.nextEntry((key,value,timestamp,identifier,isDeleted,bootStrapTimeStamp) -> callback.onEntry(new VanillaReplicatedEntry(toKey(key),toValue(value),timestamp,identifier,isDeleted,bootStrapTimeStamp,remoteIdentifier)));
    }
    private Bytes toKey(    final @NotNull net.openhft.lang.io.Bytes key){
      final long position=key.position();
      try {
        NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
        int i=(int)key.position();
        while (key.remaining() > 0) {
          byteStore.writeByte(i++,key.readByte());
        }
        return byteStore.bytesForRead();
      }
  finally {
        key.position(position);
      }
    }
    @Nullable private Bytes<Void> toValue(    final @Nullable net.openhft.lang.io.Bytes value){
      if (value == null)       return null;
      final long position=value.position();
      try {
        NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(value.remaining());
        int i=(int)value.position();
        while (value.remaining() > 0) {
          byteStore.writeByte(i++,value.readByte());
        }
        return byteStore.bytesForRead();
      }
  finally {
        value.position(position);
      }
    }
    @Override public void dirtyEntries(    final long fromTimeStamp){
      instance.dirtyEntries(fromTimeStamp);
    }
    @Override public void setModificationNotifier(    @NotNull final ModificationNotifier modificationNotifier){
      instance.setModificationNotifier(modificationNotifier::onChange);
    }
  }
;
}"
55309,"@Nullable private Bytes<Void> toValue(final @Nullable net.openhft.lang.io.Bytes value){
  if (value == null)   return null;
  NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(value.remaining());
  int i=(int)value.position();
  while (value.remaining() > 0) {
    byteStore.writeByte(i++,(byte)value.readByte());
  }
  return byteStore.bytesForRead();
}","@Nullable private Bytes<Void> toValue(final @Nullable net.openhft.lang.io.Bytes value){
  if (value == null)   return null;
  final long position=value.position();
  try {
    NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(value.remaining());
    int i=(int)value.position();
    while (value.remaining() > 0) {
      byteStore.writeByte(i++,value.readByte());
    }
    return byteStore.bytesForRead();
  }
  finally {
    value.position(position);
  }
}"
55310,"private Bytes toKey(final @NotNull net.openhft.lang.io.Bytes key){
  NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
  int i=(int)key.position();
  while (key.remaining() > 0) {
    byteStore.writeByte(i++,(byte)key.readByte());
  }
  return byteStore.bytesForRead();
}","private Bytes toKey(final @NotNull net.openhft.lang.io.Bytes key){
  final long position=key.position();
  try {
    NativeBytesStore<Void> byteStore=NativeBytesStore.nativeStoreWithFixedCapacity(key.remaining());
    int i=(int)key.position();
    while (key.remaining() > 0) {
      byteStore.writeByte(i++,key.readByte());
    }
    return byteStore.bytesForRead();
  }
  finally {
    key.position(position);
  }
}"
55311,"public static String generateValue(){
  char[] chars=new char[10];
  Arrays.fill(chars,'X');
  return new String(chars);
}","public static String generateValue(char c){
  char[] chars=new char[100];
  Arrays.fill(chars,c);
  return new String(chars);
}"
55312,"public void test() throws InterruptedException, IOException {
  String data=generateValue();
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  map=tree.acquireMap(NAME,String.class,String.class);
  if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
    for (int i=0; i < entries; i++) {
      map.put(getKey(i),data);
    }
  }
  for (; ; ) {
    map.forEach((k,v) -> System.out.println(""String_Node_Str"" + k + ""String_Node_Str""+ v));
    System.out.println(""String_Node_Str"");
    Thread.sleep(5000);
  }
}","public void test() throws InterruptedException, IOException {
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  map=tree.acquireMap(NAME,String.class,String.class);
  if (""String_Node_Str"".equals(type)) {
    for (int i=0; i < entries; i++) {
      map.put(getKey(i),generateValue('1'));
    }
  }
  if (""String_Node_Str"".equals(type)) {
    for (int i=0; i < entries; i++) {
      map.put(getKey(i),generateValue('5'));
    }
  }
  for (; ; ) {
    map.forEach((k,v) -> System.out.println(""String_Node_Str"" + k + ""String_Node_Str""+ (v == null ? ""String_Node_Str"" : v.substring(1,v.length() < 50 ? v.length() : 50))));
    System.out.println(""String_Node_Str"");
    Thread.sleep(5000);
  }
}"
55313,"/** 
 * publishes changes - this method pushes the replication events
 * @param mi               the modification iterator that notifies us of changes
 * @param remote           details about the remote connection
 * @param remoteIdentifier
 */
void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote,byte remoteIdentifier){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(true,new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    boolean hasSentLastUpdateTime=false;
    long lastUpdateTime=0;
    boolean hasLogged;
    @Override public boolean action() throws InvalidEventHandlerException {
      if (hub.isOutBytesLocked())       return false;
      if (!hub.isOutBytesEmpty())       return false;
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      if (!mi.hasNext()) {
        if (!hasSentLastUpdateTime && lastUpdateTime > 0) {
          wire.writeNotReadyDocument(false,wire -> {
            wire.writeEventName(CoreFields.lastUpdateTime).int64(lastUpdateTime);
            wire.write(() -> ""String_Node_Str"").int8(remoteIdentifier);
          }
);
          hasSentLastUpdateTime=true;
          if (!hasLogged) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + remoteIdentifier);
            hasLogged=true;
          }
          if (bytes.readRemaining() > 0) {
            ReplicationHub.this.sendBytes(bytes,false);
            return true;
          }
          return false;
        }
      }
      mi.nextEntry(e -> {
        long updateTime=Math.max(lastUpdateTime,e.timestamp());
        if (updateTime > lastUpdateTime) {
          hasSentLastUpdateTime=false;
          lastUpdateTime=updateTime;
        }
        wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e));
      }
);
      if (bytes.readRemaining() > 0) {
        ReplicationHub.this.sendBytes(bytes,false);
        return true;
      }
      return false;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}","/** 
 * publishes changes - this method pushes the replication events
 * @param mi               the modification iterator that notifies us of changes
 * @param remote           details about the remote connection
 * @param remoteIdentifier
 */
void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote,byte remoteIdentifier){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(true,new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    boolean hasSentLastUpdateTime=false;
    long lastUpdateTime=0;
    boolean hasLogged;
    @Override public boolean action() throws InvalidEventHandlerException {
      if (hub.isOutBytesLocked())       return false;
      if (!hub.isOutBytesEmpty())       return false;
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      if (!mi.hasNext()) {
        if (!hasSentLastUpdateTime && lastUpdateTime > 0) {
          wire.writeNotReadyDocument(false,wire -> {
            wire.writeEventName(CoreFields.lastUpdateTime).int64(lastUpdateTime);
            wire.write(() -> ""String_Node_Str"").int8(remoteIdentifier);
          }
);
          hasSentLastUpdateTime=true;
          if (!hasLogged) {
            System.out.println(""String_Node_Str"" + ""String_Node_Str"" + remoteIdentifier);
            hasLogged=true;
          }
          if (bytes.readRemaining() > 0) {
            ReplicationHub.this.sendBytes(bytes,false);
            return true;
          }
          return false;
        }
      }
      mi.nextEntry(e -> {
        long updateTime=Math.max(lastUpdateTime,e.timestamp());
        if (updateTime > lastUpdateTime) {
          hasSentLastUpdateTime=false;
          lastUpdateTime=updateTime;
        }
        wire.writeNotReadyDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e));
      }
);
      if (bytes.readRemaining() > 0) {
        ReplicationHub.this.sendBytes(bytes,false);
        return true;
      }
      return false;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}"
55314,"@Override public boolean action() throws InvalidEventHandlerException {
  if (hub.isOutBytesLocked())   return false;
  if (!hub.isOutBytesEmpty())   return false;
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  if (!mi.hasNext()) {
    if (!hasSentLastUpdateTime && lastUpdateTime > 0) {
      wire.writeNotReadyDocument(false,wire -> {
        wire.writeEventName(CoreFields.lastUpdateTime).int64(lastUpdateTime);
        wire.write(() -> ""String_Node_Str"").int8(remoteIdentifier);
      }
);
      hasSentLastUpdateTime=true;
      if (!hasLogged) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + remoteIdentifier);
        hasLogged=true;
      }
      if (bytes.readRemaining() > 0) {
        ReplicationHub.this.sendBytes(bytes,false);
        return true;
      }
      return false;
    }
  }
  mi.nextEntry(e -> {
    long updateTime=Math.max(lastUpdateTime,e.timestamp());
    if (updateTime > lastUpdateTime) {
      hasSentLastUpdateTime=false;
      lastUpdateTime=updateTime;
    }
    wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e));
  }
);
  if (bytes.readRemaining() > 0) {
    ReplicationHub.this.sendBytes(bytes,false);
    return true;
  }
  return false;
}","@Override public boolean action() throws InvalidEventHandlerException {
  if (hub.isOutBytesLocked())   return false;
  if (!hub.isOutBytesEmpty())   return false;
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  if (!mi.hasNext()) {
    if (!hasSentLastUpdateTime && lastUpdateTime > 0) {
      wire.writeNotReadyDocument(false,wire -> {
        wire.writeEventName(CoreFields.lastUpdateTime).int64(lastUpdateTime);
        wire.write(() -> ""String_Node_Str"").int8(remoteIdentifier);
      }
);
      hasSentLastUpdateTime=true;
      if (!hasLogged) {
        System.out.println(""String_Node_Str"" + ""String_Node_Str"" + remoteIdentifier);
        hasLogged=true;
      }
      if (bytes.readRemaining() > 0) {
        ReplicationHub.this.sendBytes(bytes,false);
        return true;
      }
      return false;
    }
  }
  mi.nextEntry(e -> {
    long updateTime=Math.max(lastUpdateTime,e.timestamp());
    if (updateTime > lastUpdateTime) {
      hasSentLastUpdateTime=false;
      lastUpdateTime=updateTime;
    }
    wire.writeNotReadyDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e));
  }
);
  if (bytes.readRemaining() > 0) {
    ReplicationHub.this.sendBytes(bytes,false);
    return true;
  }
  return false;
}"
55315,"/** 
 * write and exceptions and rolls back if no data was written
 */
void writeData(@NotNull Bytes inBytes,@NotNull WriteMarshallable c){
  outWire.writeDocument(false,out -> {
    final long readPosition=inBytes.readPosition();
    final long position=outWire.bytes().writePosition();
    try {
      c.writeMarshallable(outWire);
    }
 catch (    Throwable t) {
      inBytes.readPosition(readPosition);
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + inBytes.toDebugString(),""String_Node_Str"" + c,t);
      outWire.bytes().writePosition(position);
      outWire.writeEventName(() -> ""String_Node_Str"").throwable(t);
    }
    if (position == outWire.bytes().writePosition()) {
      outWire.writeEventName(reply).marshallable(EMPTY);
    }
  }
);
  logYaml();
}","/** 
 * write and exceptions and rolls back if no data was written
 */
void writeData(boolean isNotReady,@NotNull Bytes inBytes,@NotNull WriteMarshallable c){
  final WriteMarshallable marshallable=out -> {
    final long readPosition=inBytes.readPosition();
    final long position=outWire.bytes().writePosition();
    try {
      c.writeMarshallable(outWire);
    }
 catch (    Throwable t) {
      inBytes.readPosition(readPosition);
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + inBytes.toDebugString(),""String_Node_Str"" + c,t);
      outWire.bytes().writePosition(position);
      outWire.writeEventName(() -> ""String_Node_Str"").throwable(t);
    }
    if (position == outWire.bytes().writePosition()) {
      outWire.writeEventName(reply).marshallable(EMPTY);
    }
  }
;
  if (isNotReady)   outWire.writeNotReadyDocument(false,marshallable);
 else   outWire.writeDocument(false,marshallable);
  logYaml();
}"
55316,"public void test() throws InterruptedException, IOException {
  YamlLogging.setAll(false);
  String data=generateValue();
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  map=tree.acquireMap(NAME,String.class,String.class);
  if (""String_Node_Str"".equals(type)) {
    for (int i=0; i < entries; i++) {
      map.put(getKey(i),data);
    }
  }
  for (; ; ) {
    map.forEach((k,v) -> System.out.println(""String_Node_Str"" + k + ""String_Node_Str""+ v));
    System.out.println(""String_Node_Str"");
    Thread.sleep(5000);
  }
}","public void test() throws InterruptedException, IOException {
  String data=generateValue();
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  map=tree.acquireMap(NAME,String.class,String.class);
  if (""String_Node_Str"".equals(type) || ""String_Node_Str"".equals(type)) {
    for (int i=0; i < entries; i++) {
      map.put(getKey(i),data);
    }
  }
  for (; ; ) {
    map.forEach((k,v) -> System.out.println(""String_Node_Str"" + k + ""String_Node_Str""+ v));
    System.out.println(""String_Node_Str"");
    Thread.sleep(5000);
  }
}"
55317,"@BeforeClass public static void before() throws IOException {
  YamlLogging.clientWrites=true;
  YamlLogging.clientReads=true;
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  Files.deleteIfExists(Paths.get(OS.TARGET,NAME));
  WireType writeType=WireType.BINARY;
switch (System.getProperty(""String_Node_Str"",""String_Node_Str"")) {
case ""String_Node_Str"":
    tree=create(1,writeType,""String_Node_Str"");
  serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(2,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(3,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(4,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(5,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
}
}","@BeforeClass public static void before() throws IOException {
  YamlLogging.clientWrites=false;
  YamlLogging.clientReads=false;
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  Files.deleteIfExists(Paths.get(OS.TARGET,NAME));
  WireType writeType=WireType.BINARY;
switch (System.getProperty(""String_Node_Str"",""String_Node_Str"")) {
case ""String_Node_Str"":
    tree=create(1,writeType,""String_Node_Str"");
  serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(2,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(3,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(4,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=create(5,writeType,""String_Node_Str"");
serverEndpoint=new ServerEndpoint(""String_Node_Str"",tree,writeType);
break;
case ""String_Node_Str"":
tree=new VanillaAssetTree(""String_Node_Str"").forRemoteAccess(""String_Node_Str"",WIRE_TYPE);
}
}"
55318,"@Test public void testInsertFollowedByUpdateWhenPutReturnsNullTrue() throws Exception {
  final MapView<String,String> serverMap=serverAssetTree.acquireMap(""String_Node_Str"",String.class,String.class);
  final BlockingQueue<MapEvent> events=new ArrayBlockingQueue<>(128);
  clientAssetTree.registerSubscriber(""String_Node_Str"",MapEvent.class,events::add);
{
    serverMap.put(""String_Node_Str"",""String_Node_Str"");
    final MapEvent event=events.poll(10,SECONDS);
    Assert.assertTrue(event instanceof InsertedEvent);
  }
{
    serverMap.put(""String_Node_Str"",""String_Node_Str"");
    final MapEvent event=events.poll(10,SECONDS);
    Assert.assertTrue(event instanceof UpdatedEvent);
  }
}","@Test public void testInsertFollowedByUpdateWhenPutReturnsNullTrue() throws Exception {
  final MapView<String,String> serverMap=serverAssetTree.acquireMap(""String_Node_Str"",String.class,String.class);
  final BlockingQueue<MapEvent> events=new ArrayBlockingQueue<>(128);
  clientAssetTree.registerSubscriber(""String_Node_Str"",MapEvent.class,events::add);
  Jvm.pause(1000);
{
    serverMap.put(""String_Node_Str"",""String_Node_Str"");
    final MapEvent event=events.poll(10,SECONDS);
    Assert.assertTrue(event instanceof InsertedEvent);
  }
{
    serverMap.put(""String_Node_Str"",""String_Node_Str"");
    final MapEvent event=events.poll(10,SECONDS);
    Assert.assertTrue(event instanceof UpdatedEvent);
  }
}"
55319,"@NotNull private WatchKey processKey() throws InterruptedException {
  WatchKey key=watcher.take();
  for (  WatchEvent<?> event : key.pollEvents()) {
    Kind<?> kind=event.kind();
    if (kind == StandardWatchEventKinds.OVERFLOW) {
      continue;
    }
    WatchEvent<Path> ev=(WatchEvent<Path>)event;
    Path fileName=ev.context();
    String mapKey=fileName.toString();
    if (mapKey.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (kind == StandardWatchEventKinds.ENTRY_CREATE || kind == StandardWatchEventKinds.ENTRY_MODIFY) {
      Path p=dirPath.resolve(fileName);
      BytesStore mapVal=getFileContentsFromDisk(p,null);
      FileRecord<BytesStore> prev=lastFileRecordMap.get(p.toFile());
      BytesStore prevContents=prev == null ? null : prev.contents();
      try {
        if (mapVal != null && mapVal.contentEquals(prevContents)) {
          continue;
        }
        if (mapVal == null) {
          if (prev != null)           mapVal=prevContents;
        }
 else {
          lastFileRecordMap.put(p.toFile(),new FileRecord<>(p.toFile().lastModified(),mapVal.copy()));
        }
        if (prev == null) {
          subscriptions.notifyEvent(InsertedEvent.of(asset.fullName(),p.toFile().getName(),mapVal,false));
        }
 else {
          subscriptions.notifyEvent(UpdatedEvent.of(asset.fullName(),p.toFile().getName(),prevContents,mapVal,false,prevContents == null ? true : prevContents.equals(mapVal)));
        }
      }
  finally {
        if (prevContents != null)         prevContents.release();
      }
    }
 else     if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
      Path p=dirPath.resolve(fileName);
      FileRecord<BytesStore> prev=lastFileRecordMap.remove(p.toFile());
      BytesStore lastVal=prev == null ? null : prev.contents();
      try {
        subscriptions.notifyEvent(RemovedEvent.of(asset.fullName(),p.toFile().getName(),lastVal,false));
      }
  finally {
        if (lastVal != null)         lastVal.release();
      }
    }
  }
  return key;
}","@NotNull private WatchKey processKey() throws InterruptedException {
  WatchKey key=watcher.take();
  for (  WatchEvent<?> event : key.pollEvents()) {
    Kind<?> kind=event.kind();
    if (kind == StandardWatchEventKinds.OVERFLOW) {
      continue;
    }
    WatchEvent<Path> ev=(WatchEvent<Path>)event;
    Path fileName=ev.context();
    String mapKey=fileName.toString();
    if (mapKey.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (kind == StandardWatchEventKinds.ENTRY_CREATE || kind == StandardWatchEventKinds.ENTRY_MODIFY) {
      Path p=dirPath.resolve(fileName);
      BytesStore mapVal=getFileContentsFromDisk(p,null);
      FileRecord<BytesStore> prev=lastFileRecordMap.get(p.toFile());
      BytesStore prevContents=prev == null ? null : prev.contents();
      try {
        if (mapVal != null && mapVal.contentEquals(prevContents)) {
          continue;
        }
        if (mapVal == null) {
          if (prev != null)           mapVal=prevContents;
        }
 else {
          lastFileRecordMap.put(p.toFile(),new FileRecord<>(p.toFile().lastModified(),mapVal.copy()));
        }
        if (prev == null) {
          subscriptions.notifyEvent(InsertedEvent.of(asset.fullName(),p.toFile().getName(),mapVal,false));
        }
 else {
          subscriptions.notifyEvent(UpdatedEvent.of(asset.fullName(),p.toFile().getName(),prevContents,mapVal,false,prevContents == null ? true : !prevContents.equals(mapVal)));
        }
      }
  finally {
        if (prevContents != null)         prevContents.release();
      }
    }
 else     if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
      Path p=dirPath.resolve(fileName);
      FileRecord<BytesStore> prev=lastFileRecordMap.remove(p.toFile());
      BytesStore lastVal=prev == null ? null : prev.contents();
      try {
        subscriptions.notifyEvent(RemovedEvent.of(asset.fullName(),p.toFile().getName(),lastVal,false));
      }
  finally {
        if (lastVal != null)         lastVal.release();
      }
    }
  }
  return key;
}"
55320,"@Nullable @Override public V getAndPut(K key,V value){
  V oldValue=kvStore.getAndPut(key,value);
  subscriptions.notifyEvent(oldValue == null ? InsertedEvent.of(asset.fullName(),key,value,false) : UpdatedEvent.of(asset.fullName(),key,oldValue,value,false,oldValue.equals(value)));
  return oldValue;
}","@Nullable @Override public V getAndPut(K key,V value){
  V oldValue=kvStore.getAndPut(key,value);
  subscriptions.notifyEvent(oldValue == null ? InsertedEvent.of(asset.fullName(),key,value,false) : UpdatedEvent.of(asset.fullName(),key,oldValue,value,false,!oldValue.equals(value)));
  return oldValue;
}"
55321,"@Override public V replace(K key,V value){
  V oldValue=kvStore.replace(key,value);
  if (oldValue != null) {
    subscriptions.notifyEvent(UpdatedEvent.of(asset.fullName(),key,oldValue,value,false,value.equals(oldValue)));
  }
  return oldValue;
}","@Override public V replace(K key,V value){
  V oldValue=kvStore.replace(key,value);
  if (oldValue != null) {
    subscriptions.notifyEvent(UpdatedEvent.of(asset.fullName(),key,oldValue,value,false,!value.equals(oldValue)));
  }
  return oldValue;
}"
55322,"@Override public void applyReplication(@NotNull final ReplicationEntry entry){
  if (entry.isDeleted())   remove(entry);
 else   put(entry);
  setLastModificationTime(entry.identifier(),entry.bootStrapTimeStamp());
}","@Override public void applyReplication(@NotNull final ReplicationEntry entry){
  System.out.println(""String_Node_Str"");
  if (entry.isDeleted())   remove(entry);
 else   put(entry);
  System.out.println(""String_Node_Str"");
  setLastModificationTime(entry.identifier(),entry.bootStrapTimeStamp());
}"
55323,"/** 
 * publishes changes - this method pushes the replication events
 * @param mi     the modification iterator that notifies us of changes
 * @param remote details about the remote connection
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    @Override public boolean action() throws InvalidEventHandlerException {
      try {
        if (ReplicationHub.this.isClosed.get())         throw new InvalidEventHandlerException();
        mi.nextEntry(e -> {
          ReplicationHub.this.sendEventAsync(replicationEvent,(Consumer<ValueOut>)v -> v.typedMarshallable(e),false);
        }
);
        return true;
      }
 catch (      ConnectionDroppedException e) {
        throw new InvalidEventHandlerException();
      }
catch (      IORuntimeException e) {
        LOG.error(e.getMessage());
        throw new InvalidEventHandlerException();
      }
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}","/** 
 * publishes changes - this method pushes the replication events
 * @param mi     the modification iterator that notifies us of changes
 * @param remote details about the remote connection
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    @Override public boolean action() throws InvalidEventHandlerException {
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
      ReplicationHub.this.sendBytes(bytes,true);
      return true;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}"
55324,"@Override public boolean action() throws InvalidEventHandlerException {
  try {
    if (ReplicationHub.this.isClosed.get())     throw new InvalidEventHandlerException();
    mi.nextEntry(e -> {
      ReplicationHub.this.sendEventAsync(replicationEvent,(Consumer<ValueOut>)v -> v.typedMarshallable(e),false);
    }
);
    return true;
  }
 catch (  ConnectionDroppedException e) {
    throw new InvalidEventHandlerException();
  }
catch (  IORuntimeException e) {
    LOG.error(e.getMessage());
    throw new InvalidEventHandlerException();
  }
}","@Override public boolean action() throws InvalidEventHandlerException {
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
  ReplicationHub.this.sendBytes(bytes,true);
  return true;
}"
55325,"public ReplicationHub(@NotNull RequestContext context,@NotNull final TcpChannelHub hub,@NotNull EventLoop eventLoop,@NotNull AtomicBoolean isClosed){
  super(hub,(long)0,toUri(context));
  this.eventLoop=eventLoop;
  this.isClosed=isClosed;
}","public ReplicationHub(@NotNull RequestContext context,@NotNull final TcpChannelHub hub,@NotNull EventLoop eventLoop,@NotNull AtomicBoolean isClosed,@NotNull Function<Bytes,Wire> wireType){
  super(hub,(long)0,toUri(context));
  this.eventLoop=eventLoop;
  this.isClosed=isClosed;
  this.wireType=wireType;
}"
55326,"@Ignore @Test public void test() throws InterruptedException {
  YamlLogging.setAll(false);
  char[] chars=new char[1048576 * 2];
  Arrays.fill(chars,'X');
  String data=new String(chars);
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(type)) {
    map=tree1.acquireMap(NAME,String.class,String.class);
  }
 else {
    map=tree2.acquireMap(NAME,String.class,String.class);
  }
  for (int i=0; i < 50; i++) {
    map.put(""String_Node_Str"" + i,data);
  }
  for (; ; ) {
    Thread.sleep(5000);
  }
}","@Test public void test() throws InterruptedException {
  YamlLogging.setAll(false);
  char[] chars=new char[(1 << 20) * 2];
  Arrays.fill(chars,'X');
  String data=new String(chars);
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(type)) {
    map=tree1.acquireMap(NAME,String.class,String.class);
  }
 else {
    map=tree2.acquireMap(NAME,String.class,String.class);
  }
  for (int i=0; i < 500; i++) {
    map.put(""String_Node_Str"" + i,data);
  }
  for (; ; ) {
    Thread.sleep(5000);
  }
}"
55327,"/** 
 * publishes changes - this method pushes the replication events
 * @param mi     the modification iterator that notifies us of changes
 * @param remote details about the remote connection
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    @Override public boolean action() throws InvalidEventHandlerException {
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
      ReplicationHub.this.sendBytes(bytes,false);
      return true;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}","/** 
 * publishes changes - this method pushes the replication events
 * @param mi     the modification iterator that notifies us of changes
 * @param remote details about the remote connection
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    @Override public boolean action() throws InvalidEventHandlerException {
      if (!hub.outWireIsEmpty())       return true;
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
      if (bytes.readRemaining() > 0) {
        ReplicationHub.this.sendBytes(bytes,false);
        return true;
      }
      return false;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}"
55328,"@Override public boolean action() throws InvalidEventHandlerException {
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
  ReplicationHub.this.sendBytes(bytes,false);
  return true;
}","@Override public boolean action() throws InvalidEventHandlerException {
  if (!hub.outWireIsEmpty())   return true;
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
  if (bytes.readRemaining() > 0) {
    ReplicationHub.this.sendBytes(bytes,false);
    return true;
  }
  return false;
}"
55329,"@NotNull private WatchKey processKey() throws InterruptedException {
  WatchKey key=watcher.take();
  for (  WatchEvent<?> event : key.pollEvents()) {
    Kind<?> kind=event.kind();
    if (kind == StandardWatchEventKinds.OVERFLOW) {
      continue;
    }
    WatchEvent<Path> ev=(WatchEvent<Path>)event;
    Path fileName=ev.context();
    String mapKey=fileName.toString();
    if (mapKey.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (kind == StandardWatchEventKinds.ENTRY_CREATE || kind == StandardWatchEventKinds.ENTRY_MODIFY) {
      Path p=dirPath.resolve(fileName);
      BytesStore mapVal=getFileContentsFromDisk(p,null);
      FileRecord<BytesStore> prev=lastFileRecordMap.get(p.toFile());
      BytesStore prevContents=prev == null ? null : prev.contents();
      try {
        if (mapVal != null & mapVal.contentEquals(prevContents)) {
          continue;
        }
        if (mapVal == null) {
          if (prev != null)           mapVal=prevContents;
        }
 else {
          lastFileRecordMap.put(p.toFile(),new FileRecord<>(p.toFile().lastModified(),mapVal.copy()));
        }
        if (prev == null) {
          subscriptions.notifyEvent(InsertedEvent.of(asset.fullName(),p.toFile().getName(),mapVal,false));
        }
 else {
          subscriptions.notifyEvent(UpdatedEvent.of(asset.fullName(),p.toFile().getName(),prevContents,mapVal,false));
        }
      }
  finally {
        if (prevContents != null)         prevContents.release();
      }
    }
 else     if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
      Path p=dirPath.resolve(fileName);
      FileRecord<BytesStore> prev=lastFileRecordMap.remove(p.toFile());
      BytesStore lastVal=prev == null ? null : prev.contents();
      try {
        subscriptions.notifyEvent(RemovedEvent.of(asset.fullName(),p.toFile().getName(),lastVal,false));
      }
  finally {
        if (lastVal != null)         lastVal.release();
      }
    }
  }
  return key;
}","@NotNull private WatchKey processKey() throws InterruptedException {
  WatchKey key=watcher.take();
  for (  WatchEvent<?> event : key.pollEvents()) {
    Kind<?> kind=event.kind();
    if (kind == StandardWatchEventKinds.OVERFLOW) {
      continue;
    }
    WatchEvent<Path> ev=(WatchEvent<Path>)event;
    Path fileName=ev.context();
    String mapKey=fileName.toString();
    if (mapKey.startsWith(""String_Node_Str"")) {
      continue;
    }
    if (kind == StandardWatchEventKinds.ENTRY_CREATE || kind == StandardWatchEventKinds.ENTRY_MODIFY) {
      Path p=dirPath.resolve(fileName);
      BytesStore mapVal=getFileContentsFromDisk(p,null);
      FileRecord<BytesStore> prev=lastFileRecordMap.get(p.toFile());
      BytesStore prevContents=prev == null ? null : prev.contents();
      try {
        if (mapVal != null && mapVal.contentEquals(prevContents)) {
          continue;
        }
        if (mapVal == null) {
          if (prev != null)           mapVal=prevContents;
        }
 else {
          lastFileRecordMap.put(p.toFile(),new FileRecord<>(p.toFile().lastModified(),mapVal.copy()));
        }
        if (prev == null) {
          subscriptions.notifyEvent(InsertedEvent.of(asset.fullName(),p.toFile().getName(),mapVal,false));
        }
 else {
          subscriptions.notifyEvent(UpdatedEvent.of(asset.fullName(),p.toFile().getName(),prevContents,mapVal,false));
        }
      }
  finally {
        if (prevContents != null)         prevContents.release();
      }
    }
 else     if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
      Path p=dirPath.resolve(fileName);
      FileRecord<BytesStore> prev=lastFileRecordMap.remove(p.toFile());
      BytesStore lastVal=prev == null ? null : prev.contents();
      try {
        subscriptions.notifyEvent(RemovedEvent.of(asset.fullName(),p.toFile().getName(),lastVal,false));
      }
  finally {
        if (lastVal != null)         lastVal.release();
      }
    }
  }
  return key;
}"
55330,"@Override public void onEndOfSubscription(){
  subscriptionEnded=true;
  if (!publisher.isClosed()) {
    WriteMarshallable toPublish=publish -> {
      publish.writeDocument(true,wire -> wire.writeEventName(CoreFields.tid).int64(tid));
      publish.writeDocument(false,wire -> wire.writeEventName(ObjectKVSubscriptionHandler.EventId.onEndOfSubscription).text(""String_Node_Str""));
    }
;
    publisher.put(null,toPublish);
  }
}","@Override public void onEndOfSubscription(){
  subscriptionEnded=true;
synchronized (publisher) {
    if (!publisher.isClosed()) {
      WriteMarshallable toPublish=publish -> {
        publish.writeDocument(true,wire -> wire.writeEventName(CoreFields.tid).int64(tid));
        publish.writeDocument(false,wire -> wire.writeEventName(ObjectKVSubscriptionHandler.EventId.onEndOfSubscription).text(""String_Node_Str""));
      }
;
      publisher.put(null,toPublish);
    }
  }
}"
55331,"@Test public void testSubscriptionOnKey() throws InterruptedException {
  YamlLogging.showServerWrites=true;
  YamlLogging.showServerReads=true;
  YamlLogging.clientWrites=true;
  YamlLogging.clientReads=true;
  String key=""String_Node_Str"";
  String keyUri=NAME + ""String_Node_Str"" + key+ ""String_Node_Str"";
  BlockingQueue<String> q=new ArrayBlockingQueue<>(2);
  yamlLoggger(() -> {
    final MapView<String,String> server=clientTree.acquireMap(NAME,String.class,String.class);
    server.size();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      Jvm.rethrow(e);
    }
    clientTree.registerSubscriber(keyUri,String.class,q::add);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      Jvm.rethrow(e);
    }
    server.put(key,""String_Node_Str"");
    server.put(key,""String_Node_Str"");
  }
);
  Assert.assertEquals(""String_Node_Str"",q.poll(10,TimeUnit.SECONDS));
  Assert.assertEquals(""String_Node_Str"",q.poll(10,TimeUnit.SECONDS));
}","@Test(timeout=10000) public void testSubscriptionOnKey() throws InterruptedException {
  YamlLogging.showServerWrites=true;
  YamlLogging.showServerReads=true;
  YamlLogging.clientWrites=true;
  YamlLogging.clientReads=true;
  String key=""String_Node_Str"";
  String keyUri=NAME + ""String_Node_Str"" + key+ ""String_Node_Str"";
  BlockingQueue<String> q=new ArrayBlockingQueue<>(2);
  yamlLoggger(() -> {
    final MapView<String,String> server=clientTree.acquireMap(NAME,String.class,String.class);
    server.size();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      Jvm.rethrow(e);
    }
    clientTree.registerSubscriber(keyUri,String.class,q::add);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      Jvm.rethrow(e);
    }
    server.put(key,""String_Node_Str"");
    server.put(key,""String_Node_Str"");
  }
);
  Assert.assertEquals(""String_Node_Str"",q.poll(10,TimeUnit.SECONDS));
  Assert.assertEquals(""String_Node_Str"",q.poll(10,TimeUnit.SECONDS));
}"
55332,"/** 
 * test registerKeySubscriber before doing an operation ont the map
 */
@Test public void testKey() throws IOException, InterruptedException {
  BlockingQueue<String> q=new ArrayBlockingQueue<>(1);
  clientTree.acquireMap(NAME,String.class,String.class).registerKeySubscriber(q::add);
  Thread.sleep(1000);
  final MapView<String,String> serverMap=serverAssetTree.acquireMap(NAME,String.class,String.class);
  serverMap.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",q.poll(10,TimeUnit.SECONDS));
}","/** 
 * test registerKeySubscriber before doing an operation ont the map
 */
@Test(timeout=10000) public void testKey() throws IOException, InterruptedException {
  BlockingQueue<String> q=new ArrayBlockingQueue<>(1);
  clientTree.acquireMap(NAME,String.class,String.class).registerKeySubscriber(q::add);
  Thread.sleep(1000);
  final MapView<String,String> serverMap=serverAssetTree.acquireMap(NAME,String.class,String.class);
  serverMap.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",q.poll(10,TimeUnit.SECONDS));
}"
55333,"@Test public void test() throws InterruptedException {
  YamlLogging.setAll(false);
  char[] chars=new char[(1 << 20) * 2];
  Arrays.fill(chars,'X');
  String data=new String(chars);
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(type)) {
    map=tree1.acquireMap(NAME,String.class,String.class);
  }
 else {
    map=tree2.acquireMap(NAME,String.class,String.class);
  }
  for (int i=0; i < 500; i++) {
    map.put(""String_Node_Str"" + i,data);
  }
  for (; ; ) {
    Thread.sleep(5000);
  }
}","@Test @Ignore public void test() throws InterruptedException {
  YamlLogging.setAll(false);
  char[] chars=new char[(1 << 20) * 2];
  Arrays.fill(chars,'X');
  String data=new String(chars);
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(type)) {
    map=tree1.acquireMap(NAME,String.class,String.class);
  }
 else {
    map=tree2.acquireMap(NAME,String.class,String.class);
  }
  for (int i=0; i < 500; i++) {
    map.put(""String_Node_Str"" + i,data);
  }
  for (; ; ) {
    Thread.sleep(5000);
  }
}"
55334,"@Test public void testValuesCollection() throws IOException {
  try (final RemoteMapSupplier<String,String> remote=new RemoteMapSupplier<>(""String_Node_Str"",String.class,String.class,WireType.BINARY,assetTree,""String_Node_Str"")){
    final MapView<String,String> map=remote.get();
    HashMap<String,String> data=new HashMap<String,String>();
    data.put(""String_Node_Str"",""String_Node_Str"");
    data.put(""String_Node_Str"",""String_Node_Str"");
    map.putAll(data);
    assertEquals(data.size(),map.size());
    assertEquals(data.size(),map.values().size());
    Iterator<String> it=map.values().iterator();
    ArrayList<String> values=new ArrayList<String>();
    while (it.hasNext()) {
      values.add(it.next());
    }
    Collections.sort(values);
    Object[] dataValues=data.values().toArray();
    Arrays.sort(dataValues);
    assertArrayEquals(dataValues,values.toArray());
  }
 }","@Test @Ignore(""String_Node_Str"") public void testValuesCollection() throws IOException {
  try (final RemoteMapSupplier<String,String> remote=new RemoteMapSupplier<>(""String_Node_Str"",String.class,String.class,WireType.BINARY,assetTree,""String_Node_Str"")){
    final MapView<String,String> map=remote.get();
    Map<String,String> data=new HashMap<String,String>();
    data.put(""String_Node_Str"",""String_Node_Str"");
    data.put(""String_Node_Str"",""String_Node_Str"");
    map.putAll(data);
    Utils.waitFor(() -> data.size() == map.size());
    assertEquals(data.size(),map.size());
    assertEquals(data.size(),map.values().size());
    Iterator<String> it=map.values().iterator();
    ArrayList<String> values=new ArrayList<String>();
    while (it.hasNext()) {
      values.add(it.next());
    }
    Collections.sort(values);
    Object[] dataValues=data.values().toArray();
    Arrays.sort(dataValues);
    assertArrayEquals(dataValues,values.toArray());
  }
 }"
55335,"public void onRemove0(@NotNull K key,V value,boolean replicationEven){
  if (subscriptions.hasSubscribers())   subscriptions.notifyEvent(RemovedEvent.of(assetFullName,key,value,false));
}","public void onRemove0(@NotNull K key,V value,boolean replicationEven){
  if (subscriptions.hasSubscribers())   subscriptions.notifyEvent(RemovedEvent.of(assetFullName,key,value,replicationEven));
}"
55336,"@Override public void applyReplication(@NotNull final ReplicationEntry entry){
  System.out.println(""String_Node_Str"");
  if (entry.isDeleted())   remove(entry);
 else   put(entry);
  System.out.println(""String_Node_Str"");
  setLastModificationTime(entry.identifier(),entry.bootStrapTimeStamp());
}","@Override public void applyReplication(@NotNull final ReplicationEntry entry){
  if (Jvm.isDebug())   System.out.println(""String_Node_Str"");
  if (entry.isDeleted())   remove(entry);
 else   put(entry);
  if (Jvm.isDebug())   System.out.println(""String_Node_Str"");
  setLastModificationTime(entry.identifier(),entry.bootStrapTimeStamp());
}"
55337,"/** 
 * publishes changes - this method pushes the replication events
 * @param mi     the modification iterator that notifies us of changes
 * @param remote details about the remote connection
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    @Override public boolean action() throws InvalidEventHandlerException {
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
      ReplicationHub.this.sendBytes(bytes,true);
      return true;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}","/** 
 * publishes changes - this method pushes the replication events
 * @param mi     the modification iterator that notifies us of changes
 * @param remote details about the remote connection
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    final Bytes bytes=Bytes.elasticByteBuffer();
    final Wire wire=wireType.apply(bytes);
    @Override public boolean action() throws InvalidEventHandlerException {
      if (ReplicationHub.this.isClosed.get())       throw new InvalidEventHandlerException();
      bytes.clear();
      mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
      ReplicationHub.this.sendBytes(bytes,false);
      return true;
    }
    public HandlerPriority priority(){
      return HandlerPriority.REPLICATION;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}"
55338,"@Override public boolean action() throws InvalidEventHandlerException {
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
  ReplicationHub.this.sendBytes(bytes,true);
  return true;
}","@Override public boolean action() throws InvalidEventHandlerException {
  if (ReplicationHub.this.isClosed.get())   throw new InvalidEventHandlerException();
  bytes.clear();
  mi.nextEntry(e -> wire.writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
  ReplicationHub.this.sendBytes(bytes,false);
  return true;
}"
55339,"@NotNull public WireParser getWireParser(){
  WireParser parser=new VanillaWireParser();
  parser.register(() -> ""String_Node_Str"",v -> v.text(this,(o,x) -> o.cluster=x));
  parser.register(() -> ""String_Node_Str"",v -> v.text(this,RequestContext::view));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.bootstrap=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.putReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.removeReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.nullOldValueOnUpdateEvent=x));
  parser.register(() -> ""String_Node_Str"",v -> v.text(this,(o,x) -> o.basePath=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.viewType=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.endSubscriptionAfterBootstrap=x));
  parser.register(() -> ""String_Node_Str"",v -> v.int32(this,(o,x) -> o.throttlePeriodMs=x));
  parser.register(WireParser.DEFAULT,ValueIn.DISCARD);
  return parser;
}","@NotNull public WireParser getWireParser(){
  WireParser parser=new VanillaWireParser();
  parser.register(() -> ""String_Node_Str"",v -> v.text(this,(o,x) -> o.cluster=x));
  parser.register(() -> ""String_Node_Str"",v -> v.text(this,RequestContext::view));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.bootstrap=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.putReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.removeReturnsNull=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.nullOldValueOnUpdateEvent=x));
  parser.register(() -> ""String_Node_Str"",v -> v.text(this,(o,x) -> o.basePath=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.viewType=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type2=x));
  parser.register(() -> ""String_Node_Str"",v -> v.typeLiteral(this,(o,x) -> o.type=x));
  parser.register(() -> ""String_Node_Str"",v -> v.bool(this,(o,x) -> o.endSubscriptionAfterBootstrap=x));
  parser.register(() -> ""String_Node_Str"",v -> v.int32(this,(o,x) -> o.throttlePeriodMs=x));
  parser.register(() -> ""String_Node_Str"",v -> v.int64(this,(o,x) -> o.entries=x));
  parser.register(() -> ""String_Node_Str"",v -> v.int64(this,(o,x) -> o.averageValueSize=x));
  parser.register(WireParser.DEFAULT,ValueIn.DISCARD);
  return parser;
}"
55340,"@Ignore @Test public void test() throws InterruptedException {
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(type)) {
    map=tree1.acquireMap(NAME,String.class,String.class);
  }
 else {
    map=tree2.acquireMap(NAME,String.class,String.class);
  }
  map.put(type,type);
  for (; ; ) {
    System.out.println(map.entrySet().toString());
    Thread.sleep(5000);
  }
}","@Ignore @Test public void test() throws InterruptedException {
  YamlLogging.setAll(false);
  char[] chars=new char[1048576 * 2];
  Arrays.fill(chars,'X');
  String data=new String(chars);
  final ConcurrentMap<String,String> map;
  final String type=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(type)) {
    map=tree1.acquireMap(NAME,String.class,String.class);
  }
 else {
    map=tree2.acquireMap(NAME,String.class,String.class);
  }
  for (int i=0; i < 50; i++) {
    map.put(""String_Node_Str"" + i,data);
  }
  for (; ; ) {
    Thread.sleep(5000);
  }
}"
55341,"/** 
 * publishes changes - this method pushes the replication events
 * @param mi               the modification iterator that notifies us of changes
 * @param remote           details about the remote connection
 * @param localIdentifier  the identifier of this host or client
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote,byte localIdentifier){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(() -> {
    try {
      if (isClosed.get())       throw new InvalidEventHandlerException();
      hub.lock(() -> mi.forEach(e -> {
        if (e.identifier() != localIdentifier)         return;
        sendEventAsyncWithoutLock(replicationEvent,new Consumer<ValueOut>(){
          @Override public void accept(          ValueOut v){
            v.typedMarshallable(e);
          }
        }
);
      }
));
      return true;
    }
 catch (    IORuntimeException e) {
      LOG.error(e.getMessage());
      throw new InvalidEventHandlerException();
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}","/** 
 * publishes changes - this method pushes the replication events
 * @param mi               the modification iterator that notifies us of changes
 * @param remote           details about the remote connection
 * @param localIdentifier  the identifier of this host or client
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote,byte localIdentifier){
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(() -> {
    try {
      if (isClosed.get())       throw new InvalidEventHandlerException();
      hub.lock(() -> mi.forEach(e -> {
        sendEventAsyncWithoutLock(replicationEvent,new Consumer<ValueOut>(){
          @Override public void accept(          ValueOut v){
            v.typedMarshallable(e);
          }
        }
);
      }
));
      return true;
    }
 catch (    IORuntimeException e) {
      LOG.error(e.getMessage());
      throw new InvalidEventHandlerException();
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}"
55342,"@BeforeClass public static void before() throws IOException {
  YamlLogging.clientWrites=true;
  YamlLogging.clientReads=true;
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  Files.deleteIfExists(Paths.get(OS.TARGET,NAME));
  TCPRegistry.createServerSocketChannelFor(""String_Node_Str"",""String_Node_Str"");
  WireType writeType=WireType.TEXT;
  tree1=create(1,writeType,""String_Node_Str"");
  serverEndpoint1=new ServerEndpoint(""String_Node_Str"",tree1,writeType);
  tree2=create(2,writeType,""String_Node_Str"");
  serverEndpoint2=new ServerEndpoint(""String_Node_Str"",tree2,writeType);
}","@BeforeClass public static void before() throws IOException {
  YamlLogging.clientWrites=true;
  YamlLogging.clientReads=true;
  ClassAliasPool.CLASS_ALIASES.addAlias(ChronicleMapGroupFS.class);
  ClassAliasPool.CLASS_ALIASES.addAlias(FilePerKeyGroupFS.class);
  Files.deleteIfExists(Paths.get(OS.TARGET,NAME));
  TCPRegistry.createServerSocketChannelFor(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  WireType writeType=WireType.TEXT;
  tree1=create(1,writeType,""String_Node_Str"");
  serverEndpoint1=new ServerEndpoint(""String_Node_Str"",tree1,writeType);
  tree2=create(2,writeType,""String_Node_Str"");
  serverEndpoint2=new ServerEndpoint(""String_Node_Str"",tree2,writeType);
}"
55343,"@Test public void testCheckDataIsLoadedFromPersistedFile() throws InterruptedException, IOException {
  final Path basePath=Files.createTempDirectory(""String_Node_Str"");
  ConcurrentMap<String,String> map1=tree1.acquireMap(NAME + ""String_Node_Str"" + basePath,String.class,String.class);
  assertNotNull(map1);
  map1.put(""String_Node_Str"",""String_Node_Str"");
  serverEndpoint1.close();
  tree1.close();
  tree1=create(1,WireType.TEXT,""String_Node_Str"");
  serverEndpoint1=new ServerEndpoint(""String_Node_Str"",tree1,WireType.TEXT);
  ConcurrentMap<String,String> map1a=tree1.acquireMap(NAME + ""String_Node_Str"" + basePath,String.class,String.class);
  assertNotNull(map1a);
  Thread.sleep(100);
  Assert.assertEquals(1,map1a.size());
}","@Test public void testCheckDataIsLoadedFromPersistedFile() throws InterruptedException, IOException {
  final Path basePath=Files.createTempDirectory(""String_Node_Str"");
  ConcurrentMap<String,String> map1=tree1.acquireMap(NAME + ""String_Node_Str"" + ""String_Node_Str""+ basePath,String.class,String.class);
  assertNotNull(map1);
  map1.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(100);
  serverEndpoint1.close();
  tree1.close();
  tree1=create(1,WireType.TEXT,""String_Node_Str"");
  serverEndpoint1=new ServerEndpoint(""String_Node_Str"",tree1,WireType.TEXT);
  ConcurrentMap<String,String> map1a=tree1.acquireMap(NAME + ""String_Node_Str"" + ""String_Node_Str""+ basePath,String.class,String.class);
  assertNotNull(map1a);
  Thread.sleep(100);
  Assert.assertEquals(1,map1a.size());
}"
55344,"@NotNull private net.openhft.lang.io.Bytes toLangBytes(@NotNull BytesStore b){
  if (b.underlyingObject() == null)   return wrap(b.address(b.start()),b.readRemaining());
 else {
    ByteBuffer buffer=(ByteBuffer)b.underlyingObject();
    IByteBufferBytes wrap=ByteBufferBytes.wrap(buffer);
    wrap.limit((int)b.readLimit());
    return wrap;
  }
}","@NotNull private net.openhft.lang.io.Bytes toLangBytes(@NotNull BytesStore b){
  if (b.underlyingObject() == null)   return wrap(b.address(b.start()),b.readRemaining());
 else {
    ByteBuffer buffer=ByteBuffer.wrap((byte[])b.underlyingObject());
    IByteBufferBytes wrap=ByteBufferBytes.wrap(buffer);
    wrap.limit((int)b.readLimit());
    return wrap;
  }
}"
55345,"/** 
 * @param key                the key of the entry
 * @param value              the value of the entry
 * @param timestamp          the timestamp send from the remote server, this time stamp wasthe time the entry was removed
 * @param identifier         the identifier of the remote server
 * @param bootStrapTimeStamp sent to the client on every update this is the timestamp thatthe remote client should bootstrap from when there has been a
 * @param remoteIdentifier   the identifier of the server we are sending data to ( only used as a comment )
 */
VanillaReplicatedEntry(@NotNull final BytesStore key,@Nullable final BytesStore value,final long timestamp,final byte identifier,final boolean isDeleted,final long bootStrapTimeStamp,byte remoteIdentifier){
}","/** 
 * @param key                the key of the entry
 * @param value              the value of the entry
 * @param timestamp          the timestamp send from the remote server, this time stamp wasthe time the entry was removed
 * @param identifier         the identifier of the remote server
 * @param bootStrapTimeStamp sent to the client on every update this is the timestamp thatthe remote client should bootstrap from when there has been a
 * @param remoteIdentifier   the identifier of the server we are sending data to ( only usedas a comment )
 */
VanillaReplicatedEntry(@NotNull final BytesStore key,@Nullable final BytesStore value,final long timestamp,final byte identifier,final boolean isDeleted,final long bootStrapTimeStamp,byte remoteIdentifier){
}"
55346,"/** 
 * because we have set System.setProperty(""Throttler.maxEventsPreSecond"", ""1""); in the static above, we will only get one event per second, this test also checks that the messages still arrive in order.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testReceivingThrottledEventsInOrder() throws IOException, InterruptedException {
  final BlockingQueue<String> eventsQueue=new LinkedBlockingDeque<>();
  YamlLogging.showServerWrites=true;
  YamlLogging.showServerReads=true;
  yamlLoggger(() -> {
    try {
      Subscriber<String> add=eventsQueue::add;
      assetTree.registerSubscriber(NAME,String.class,add);
      Thread.sleep(1000);
      for (int i=0; i < 10; i++) {
        serverMap.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
      }
      final long start=System.currentTimeMillis();
      for (int i=0; i < 10; i++) {
        String actual=eventsQueue.poll(2,SECONDS);
        Assert.assertNotNull(actual);
        Assert.assertEquals(""String_Node_Str"" + i,actual);
      }
      Assert.assertTrue(System.currentTimeMillis() > start + TimeUnit.SECONDS.toMillis(5));
    }
 catch (    Exception e) {
      throw Jvm.rethrow(e);
    }
  }
);
}","/** 
 * because we have set System.setProperty(""Throttler.maxEventsPreSecond"", ""1""); in the static above, we will only get one event per second, this test also checks that the messages still arrive in order.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testReceivingThrottledEventsInOrder() throws IOException, InterruptedException {
  final BlockingQueue<String> eventsQueue=new LinkedBlockingDeque<>();
  YamlLogging.showServerWrites=true;
  YamlLogging.showServerReads=true;
  yamlLoggger(() -> {
    try {
      Subscriber<String> queue=eventsQueue::add;
      assetTree.registerSubscriber(NAME,String.class,queue);
      Thread.sleep(1000);
      for (int i=0; i < 10; i++) {
        serverMap.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
      }
      final long start=System.currentTimeMillis();
      for (int i=0; i < 10; i++) {
        String actual=eventsQueue.poll(2,SECONDS);
        Assert.assertNotNull(actual);
        Assert.assertEquals(""String_Node_Str"" + i,actual);
      }
      Assert.assertTrue(System.currentTimeMillis() > start + TimeUnit.SECONDS.toMillis(5));
    }
 catch (    Exception e) {
      throw Jvm.rethrow(e);
    }
  }
);
}"
55347,"/** 
 * the transaction id are generated as unique timestamps
 * @param timeMs in milliseconds
 * @return a unique transactionId
 */
public long nextUniqueTransaction(long timeMs){
  long id=timeMs;
  for (; ; ) {
    long old=transactionID.get();
    if (old == id)     id=old + 1;
    if (transactionID.compareAndSet(old,id))     break;
  }
  return id;
}","/** 
 * the transaction id are generated as unique timestamps
 * @param timeMs in milliseconds
 * @return a unique transactionId
 */
public long nextUniqueTransaction(long timeMs){
  long id=timeMs;
  for (; ; ) {
    long old=transactionID.get();
    if (old >= id)     id=old + 1;
    if (transactionID.compareAndSet(old,id))     break;
  }
  return id;
}"
55348,"@Deprecated default void registerKeySubscriber(@NotNull RequestContext rc,@NotNull Subscriber<K> subscriber){
  registerKeySubscriber(rc,subscriber,Filter.EMPTY);
}","@Deprecated default void registerKeySubscriber(@NotNull RequestContext rc,@NotNull Subscriber<K> subscriber){
  registerKeySubscriber(rc,subscriber,Filter.empty());
}"
55349,"/** 
 * because we have set System.setProperty(""Throttler.maxEventsPreSecond"", ""1""); in the static above, we will only get one event per second, this test also checks that the messages still arrive in order.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testReceivingThrottledEventsInOrder() throws IOException, InterruptedException {
  final BlockingQueue<String> eventsQueue=new LinkedBlockingDeque<>();
  YamlLogging.showServerWrites=true;
  YamlLogging.showServerReads=true;
  yamlLoggger(() -> {
    try {
      Subscriber<String> add=eventsQueue::add;
      assetTree.registerSubscriber(NAME,String.class,add);
      for (int i=0; i < 10; i++) {
        map.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
      }
      final long start=System.currentTimeMillis();
      for (int i=0; i < 10; i++) {
        String actual=eventsQueue.poll(2,SECONDS);
        Assert.assertNotNull(actual);
        Assert.assertEquals(""String_Node_Str"" + i,actual);
      }
      Assert.assertTrue(System.currentTimeMillis() > start + TimeUnit.SECONDS.toMillis(5));
    }
 catch (    Exception e) {
      throw Jvm.rethrow(e);
    }
  }
);
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * because we have set System.setProperty(""Throttler.maxEventsPreSecond"", ""1""); in the static above, we will only get one event per second, this test also checks that the messages still arrive in order.
 * @throws IOException
 * @throws InterruptedException
 */
@Test public void testReceivingThrottledEventsInOrder() throws IOException, InterruptedException {
  final BlockingQueue<String> eventsQueue=new LinkedBlockingDeque<>();
  YamlLogging.showServerWrites=true;
  YamlLogging.showServerReads=true;
  yamlLoggger(() -> {
    try {
      Subscriber<String> add=eventsQueue::add;
      assetTree.registerSubscriber(NAME,String.class,add);
      for (int i=0; i < 10; i++) {
        map.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
      }
      final long start=System.currentTimeMillis();
      for (int i=0; i < 10; i++) {
        String actual=eventsQueue.poll(2,SECONDS);
        Assert.assertNotNull(actual);
        Assert.assertEquals(""String_Node_Str"" + i,actual);
      }
      Assert.assertTrue(System.currentTimeMillis() > start + TimeUnit.SECONDS.toMillis(5));
    }
 catch (    Exception e) {
      throw Jvm.rethrow(e);
    }
  }
);
}"
55350,"@Before public void before() throws IOException {
  serverAssetTree=new VanillaAssetTree().forTesting();
  methodName(name.getMethodName());
  final String hostPort=""String_Node_Str"" + name.getMethodName() + ""String_Node_Str"";
  TCPRegistry.createServerSocketChannelFor(hostPort);
  serverEndpoint=new ServerEndpoint(hostPort,serverAssetTree,WIRE_TYPE);
  assetTree=new VanillaAssetTree().forRemoteAccess(hostPort,WIRE_TYPE);
  map=assetTree.acquireMap(NAME,String.class,String.class);
}","@Before public void before() throws IOException {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  serverAssetTree=new VanillaAssetTree().forTesting();
  methodName(name.getMethodName());
  final String hostPort=""String_Node_Str"" + name.getMethodName() + ""String_Node_Str"";
  TCPRegistry.createServerSocketChannelFor(hostPort);
  serverEndpoint=new ServerEndpoint(hostPort,serverAssetTree,WIRE_TYPE);
  assetTree=new VanillaAssetTree().forRemoteAccess(hostPort,WIRE_TYPE);
  map=assetTree.acquireMap(NAME,String.class,String.class);
}"
55351,"@After public void after() throws IOException {
  assetTree.close();
  if (serverEndpoint != null)   serverEndpoint.close();
  serverAssetTree.close();
  if (map instanceof Closeable)   ((Closeable)map).close();
  TCPRegistry.assertAllServersStopped();
  TCPRegistry.reset();
}","@After public void after() throws IOException {
  assetTree.close();
  if (serverEndpoint != null)   serverEndpoint.close();
  serverAssetTree.close();
  if (map instanceof Closeable)   ((Closeable)map).close();
  TCPRegistry.assertAllServersStopped();
  TCPRegistry.reset();
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}"
55352,"/** 
 * publishes changes - this method pushes the replication events
 * @param mi               the modification iterator that notifies us of changes
 * @param remote           details about the remote connection
 * @param localIdentifier  the identifier of this host or client
 * @param remoteIdentifier @throws InterruptedException
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote,byte localIdentifier,byte remoteIdentifier) throws InterruptedException {
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    @Override public boolean action() throws InvalidEventHandlerException {
      try {
        if (isClosed.get())         throw new InvalidEventHandlerException();
        hub.lock(() -> mi.forEach(e -> {
          if (e.identifier() != localIdentifier)           return;
          sendEventAsyncWithoutLock(replicationEvent,v -> v.typedMarshallable(e));
        }
));
        return true;
      }
 catch (      IORuntimeException e) {
        LOG.error(e.getMessage());
        throw new InvalidEventHandlerException();
      }
    }
    @NotNull @Override public HandlerPriority priority(){
      return HandlerPriority.MEDIUM;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}","/** 
 * publishes changes - this method pushes the replication events
 * @param mi               the modification iterator that notifies us of changes
 * @param remote           details about the remote connection
 * @param localIdentifier  the identifier of this host or client
 */
private void publish(@NotNull final ModificationIterator mi,@NotNull final Bootstrap remote,byte localIdentifier) throws InterruptedException {
  final TcpChannelHub hub=this.hub;
  mi.setModificationNotifier(eventLoop::unpause);
  eventLoop.addHandler(new EventHandler(){
    @Override public boolean action() throws InvalidEventHandlerException {
      try {
        if (isClosed.get())         throw new InvalidEventHandlerException();
        hub.lock(() -> mi.forEach(e -> {
          if (e.identifier() != localIdentifier)           return;
          sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)v -> v.typedMarshallable(e));
        }
));
        return true;
      }
 catch (      IORuntimeException e) {
        LOG.error(e.getMessage());
        throw new InvalidEventHandlerException();
      }
    }
    @NotNull @Override public HandlerPriority priority(){
      return HandlerPriority.MEDIUM;
    }
  }
);
  mi.dirtyEntries(remote.lastUpdatedTime());
}"
55353,"@Override public boolean action() throws InvalidEventHandlerException {
  try {
    if (isClosed.get())     throw new InvalidEventHandlerException();
    hub.lock(() -> mi.forEach(e -> {
      if (e.identifier() != localIdentifier)       return;
      sendEventAsyncWithoutLock(replicationEvent,v -> v.typedMarshallable(e));
    }
));
    return true;
  }
 catch (  IORuntimeException e) {
    LOG.error(e.getMessage());
    throw new InvalidEventHandlerException();
  }
}","@Override public boolean action() throws InvalidEventHandlerException {
  try {
    if (isClosed.get())     throw new InvalidEventHandlerException();
    hub.lock(() -> mi.forEach(e -> {
      if (e.identifier() != localIdentifier)       return;
      sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)v -> v.typedMarshallable(e));
    }
));
    return true;
  }
 catch (  IORuntimeException e) {
    LOG.error(e.getMessage());
    throw new InvalidEventHandlerException();
  }
}"
55354,"public void bootstrap(@NotNull EngineReplication replication,byte localIdentifier,byte remoteIdentifier) throws InterruptedException {
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,localIdentifier,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull WireOut wireOut){
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ remoteIdentifier);
      wireOut.writeEventName(identifier).marshallable(WriteMarshallable.EMPTY).writeComment(toString() + ""String_Node_Str"" + hub.toString()+ ""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      inWire.readDocument(null,d -> {
        byte remoteIdentifier=d.read(identifierReply).int8();
        onConnected(localIdentifier,remoteIdentifier,replication);
      }
);
    }
    @NotNull @Override public String toString(){
      return ""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str"";
    }
  }
);
}","public void bootstrap(@NotNull EngineReplication replication,byte localIdentifier,byte remoteIdentifier){
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,localIdentifier,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull WireOut wireOut){
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ remoteIdentifier);
      wireOut.writeEventName(identifier).marshallable(WriteMarshallable.EMPTY).writeComment(toString() + ""String_Node_Str"" + hub.toString()+ ""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      inWire.readDocument(null,d -> {
        byte remoteIdentifier=d.read(identifierReply).int8();
        onConnected(localIdentifier,remoteIdentifier,replication);
      }
);
    }
    @NotNull @Override public String toString(){
      return ""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str"";
    }
  }
);
}"
55355,"@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  StringBuilder clusterName=new StringBuilder();
  while (wire.hasMore()) {
    wire.readEventName(clusterName).marshallable(host -> {
      Cluster cluster=clusterMap.computeIfAbsent(clusterName.toString(),Cluster::new);
      cluster.readMarshallable(host);
    }
);
  }
}","@Override public void readMarshallable(@NotNull WireIn wire) throws IllegalStateException {
  StringBuilder clusterName=Wires.acquireStringBuilder();
  while (wire.hasMore()) {
    wire.readEventName(clusterName).marshallable(host -> {
      Cluster cluster=clusterMap.computeIfAbsent(clusterName.toString(),Cluster::new);
      cluster.readMarshallable(host);
    }
);
  }
}"
55356,"public ChronicleMapKeyValueStore(@NotNull RequestContext context,@NotNull Asset asset){
  String basePath=context.basePath();
  double averageValueSize=context.getAverageValueSize();
  long maxEntries=context.getEntries();
  this.asset=asset;
  this.assetFullName=asset.fullName();
  this.subscriptions=asset.acquireView(ObjectKVSSubscription.class,context);
  this.subscriptions.setKvStore(this);
  this.eventLoop=asset.findOrCreateView(EventLoop.class);
  eventLoop.start();
  PublishingOperations publishingOperations=new PublishingOperations();
  ChronicleMapBuilder<K,V> builder=ChronicleMapBuilder.of(context.keyType(),context.valueType());
  HostIdentifier hostIdentifier=null;
  EngineReplication engineReplicator1=null;
  try {
    engineReplicator1=asset.acquireView(EngineReplication.class);
    final EngineReplicationLangBytesConsumer langBytesConsumer=asset.findView(EngineReplicationLangBytesConsumer.class);
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    builder.replication(builder().engineReplication(langBytesConsumer).createWithId(hostIdentifier.hostId()));
  }
 catch (  AssetNotFoundException anfe) {
    if (LOGGER.isDebugEnabled())     LOGGER.debug(""String_Node_Str"" + anfe.getMessage());
  }
  this.engineReplicator=engineReplicator1;
  builder.eventListener(publishingOperations);
  if (context.putReturnsNull() != Boolean.FALSE)   builder.putReturnsNull(true);
  if (context.removeReturnsNull() != Boolean.FALSE)   builder.removeReturnsNull(true);
  if (averageValueSize > 0)   builder.averageValueSize(averageValueSize);
  if (maxEntries > 0)   builder.entries(maxEntries);
  if (basePath == null)   chronicleMap=builder.create();
 else {
    String pathname=basePath + ""String_Node_Str"" + context.name();
    new File(basePath).mkdirs();
    try {
      chronicleMap=builder.createPersistedTo(new File(pathname));
    }
 catch (    IOException e) {
      IORuntimeException iore=new IORuntimeException(""String_Node_Str"" + pathname);
      iore.initCause(e);
      throw iore;
    }
  }
  if (hostIdentifier != null) {
    Clusters clusters=asset.findView(Clusters.class);
    if (clusters == null) {
      LOGGER.warn(""String_Node_Str"");
      return;
    }
    Cluster cluster=clusters.get(context.cluster());
    if (clusters == null) {
      LOGGER.warn(""String_Node_Str"");
      return;
    }
    byte localIdentifier=hostIdentifier.hostId();
    for (    HostDetails hostDetails : cluster.hostDetails()) {
      int remoteIdentifier=hostDetails.hostId;
      if (remoteIdentifier <= localIdentifier)       continue;
      final TcpChannelHub tcpChannelHub=hostDetails.acquireTcpChannelHub(asset,eventLoop,context.wireType());
      ReplicationHub replicationHub=new ReplicationHub(context,tcpChannelHub,eventLoop,isClosed);
      try {
        replicationHub.bootstrap(engineReplicator1,localIdentifier,(byte)remoteIdentifier);
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
}","public ChronicleMapKeyValueStore(@NotNull RequestContext context,@NotNull Asset asset){
  String basePath=context.basePath();
  double averageValueSize=context.getAverageValueSize();
  long maxEntries=context.getEntries();
  this.asset=asset;
  this.assetFullName=asset.fullName();
  this.subscriptions=asset.acquireView(ObjectKVSSubscription.class,context);
  this.subscriptions.setKvStore(this);
  this.eventLoop=asset.findOrCreateView(EventLoop.class);
  eventLoop.start();
  PublishingOperations publishingOperations=new PublishingOperations();
  ChronicleMapBuilder<K,V> builder=ChronicleMapBuilder.of(context.keyType(),context.valueType());
  HostIdentifier hostIdentifier=null;
  EngineReplication engineReplicator1=null;
  try {
    engineReplicator1=asset.acquireView(EngineReplication.class);
    final EngineReplicationLangBytesConsumer langBytesConsumer=asset.findView(EngineReplicationLangBytesConsumer.class);
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    builder.replication(builder().engineReplication(langBytesConsumer).createWithId(hostIdentifier.hostId()));
  }
 catch (  AssetNotFoundException anfe) {
    if (LOGGER.isDebugEnabled())     LOGGER.debug(""String_Node_Str"" + anfe.getMessage());
  }
  this.engineReplicator=engineReplicator1;
  builder.eventListener(publishingOperations);
  if (context.putReturnsNull() != Boolean.FALSE)   builder.putReturnsNull(true);
  if (context.removeReturnsNull() != Boolean.FALSE)   builder.removeReturnsNull(true);
  if (averageValueSize > 0)   builder.averageValueSize(averageValueSize);
  if (maxEntries > 0)   builder.entries(maxEntries);
  if (basePath == null)   chronicleMap=builder.create();
 else {
    String pathname=basePath + ""String_Node_Str"" + context.name();
    new File(basePath).mkdirs();
    try {
      chronicleMap=builder.createPersistedTo(new File(pathname));
    }
 catch (    IOException e) {
      IORuntimeException iore=new IORuntimeException(""String_Node_Str"" + pathname);
      iore.initCause(e);
      throw iore;
    }
  }
  if (hostIdentifier != null) {
    Clusters clusters=asset.findView(Clusters.class);
    if (clusters == null) {
      LOGGER.warn(""String_Node_Str"");
      return;
    }
    Cluster cluster=clusters.get(context.cluster());
    if (clusters == null) {
      LOGGER.warn(""String_Node_Str"");
      return;
    }
    byte localIdentifier=hostIdentifier.hostId();
    System.out.println(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ cluster.hostDetails());
    for (    HostDetails hostDetails : cluster.hostDetails()) {
      int remoteIdentifier=hostDetails.hostId;
      if (remoteIdentifier <= localIdentifier) {
        System.out.println(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier);
        continue;
      }
      System.out.println(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier);
      final TcpChannelHub tcpChannelHub=hostDetails.acquireTcpChannelHub(asset,eventLoop,context.wireType());
      ReplicationHub replicationHub=new ReplicationHub(context,tcpChannelHub,eventLoop,isClosed);
      try {
        replicationHub.bootstrap(engineReplicator1,localIdentifier,(byte)remoteIdentifier);
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
}"
55357,"@Override public void onSubscribe(@NotNull final WireOut wireOut){
  wireOut.writeEventName(replicationSubscribe).int8(localIdentifier);
}","@Override public void onSubscribe(@NotNull final WireOut wireOut){
  wireOut.writeEventName(replicationSubscribe).int8(localIdentifier).writeComment(""String_Node_Str"" + remoteIdentifier);
}"
55358,"/** 
 * subscribes to updates
 * @param replication     the event will be applied to the EngineReplication
 * @param localIdentifier our local identifier
 */
private void subscribe(@NotNull final EngineReplication replication,final byte localIdentifier){
  hub.subscribe(new AbstractAsyncTemporarySubscription(hub,csp,localIdentifier,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(replicationSubscribe).int8(localIdentifier);
    }
    @Override public void onConsumer(    @NotNull final WireIn d){
      d.readDocument(null,w -> replication.applyReplication(w.read(replicationReply).typedMarshallable()));
    }
  }
);
}","/** 
 * subscribes to updates
 * @param replication     the event will be applied to the EngineReplication
 * @param localIdentifier our local identifier
 */
private void subscribe(@NotNull final EngineReplication replication,final byte localIdentifier,final byte remoteIdentifier){
  hub.subscribe(new AbstractAsyncTemporarySubscription(hub,csp,localIdentifier,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(replicationSubscribe).int8(localIdentifier).writeComment(""String_Node_Str"" + remoteIdentifier);
    }
    @Override public void onConsumer(    @NotNull final WireIn d){
      d.readDocument(null,w -> replication.applyReplication(w.read(replicationReply).typedMarshallable()));
    }
  }
);
}"
55359,"public void bootstrap(@NotNull EngineReplication replication,byte localIdentifier,byte remoteIdentifier) throws InterruptedException {
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,localIdentifier,""String_Node_Str""){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(identifier).marshallable(WriteMarshallable.EMPTY);
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      inWire.readDocument(null,d -> {
        byte remoteIdentifier=d.read(identifierReply).int8();
        onConnected(localIdentifier,remoteIdentifier,replication);
      }
);
    }
  }
);
}","public void bootstrap(@NotNull EngineReplication replication,byte localIdentifier,byte remoteIdentifier) throws InterruptedException {
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,localIdentifier,""String_Node_Str""){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(identifier).marshallable(WriteMarshallable.EMPTY).writeComment(toString() + ""String_Node_Str"" + hub.toString()+ ""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      inWire.readDocument(null,d -> {
        byte remoteIdentifier=d.read(identifierReply).int8();
        onConnected(localIdentifier,remoteIdentifier,replication);
      }
);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str"";
    }
  }
);
}"
55360,"/** 
 * called when the connection is established to the remote host, if the connection to the remote host is lost and re-established this method is called again each time the connection is establish.
 * @param localIdentifier  the identifier of this host
 * @param remoteIdentifier the identifier of the remote host
 * @param replication      the instance the handles the replication
 */
private void onConnected(final byte localIdentifier,byte remoteIdentifier,EngineReplication replication){
  final ModificationIterator mi=replication.acquireModificationIterator(remoteIdentifier);
  final long lastModificationTime=replication.lastModificationTime(remoteIdentifier);
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.lastUpdatedTime(lastModificationTime);
  bootstrap.identifier(localIdentifier);
  subscribe(replication,localIdentifier);
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,localIdentifier,""String_Node_Str"" + ""String_Node_Str""){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(MapWireHandler.EventId.bootstrap).typedMarshallable(bootstrap);
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      inWire.readDocument(null,d -> {
        Bootstrap b=d.read(bootstrapReply).typedMarshallable();
        try {
          publish(mi,b,localIdentifier,remoteIdentifier);
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"",e);
        }
      }
);
    }
  }
);
}","/** 
 * called when the connection is established to the remote host, if the connection to the remote host is lost and re-established this method is called again each time the connection is establish.
 * @param localIdentifier  the identifier of this host
 * @param remoteIdentifier the identifier of the remote host
 * @param replication      the instance the handles the replication
 */
private void onConnected(final byte localIdentifier,byte remoteIdentifier,EngineReplication replication){
  final ModificationIterator mi=replication.acquireModificationIterator(remoteIdentifier);
  final long lastModificationTime=replication.lastModificationTime(remoteIdentifier);
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.lastUpdatedTime(lastModificationTime);
  bootstrap.identifier(localIdentifier);
  subscribe(replication,localIdentifier,remoteIdentifier);
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,localIdentifier,""String_Node_Str"" + ""String_Node_Str""){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(MapWireHandler.EventId.bootstrap).typedMarshallable(bootstrap);
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      inWire.readDocument(null,d -> {
        Bootstrap b=d.read(bootstrapReply).typedMarshallable();
        try {
          publish(mi,b,localIdentifier,remoteIdentifier);
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"",e);
        }
      }
);
    }
  }
);
}"
55361,"void unregisterSubscriber0(Subscriber subscriber){
  Long tid=subscribersToTid.get(subscriber);
  if (tid == null) {
    AbstractRemoteSubscription.LOG.warn(""String_Node_Str"");
    return;
  }
  hub.checkConnection();
  hub.outBytesLock().lock();
  try {
    writeMetaDataForKnownTID(tid);
    hub.outWire().writeDocument(false,wireOut -> {
      wireOut.writeEventName(unregisterSubscriber).text(""String_Node_Str"");
    }
);
    try {
      hub.writeSocket(hub.outWire());
    }
 catch (    IORuntimeException e) {
    }
  }
  finally {
    hub.outBytesLock().unlock();
  }
}","void unregisterSubscriber0(Subscriber subscriber){
  Long tid=subscribersToTid.get(subscriber);
  if (tid == null) {
    AbstractRemoteSubscription.LOG.warn(""String_Node_Str"");
    return;
  }
  hub.lock(() -> {
    writeMetaDataForKnownTID(tid);
    hub.outWire().writeDocument(false,wireOut -> {
      wireOut.writeEventName(unregisterSubscriber).text(""String_Node_Str"");
    }
);
  }
);
}"
55362,"public <A>void asyncUpdate(SerializableUpdaterWithArg updateFunction,A arg){
  sendEventAsync(update2,toParameters(update2,updateFunction,arg));
}","public <A>void asyncUpdate(SerializableUpdaterWithArg updateFunction,A arg){
  sendEventAsync(update2,toParameters(update2,updateFunction,arg),true);
}"
55363,"public boolean remove(Object key){
  checkKey(key);
  sendEventAsync(remove,toParameters(remove,key));
  return false;
}","public boolean remove(Object key){
  checkKey(key);
  sendEventAsync(remove,toParameters(remove,key),true);
  return false;
}"
55364,"public boolean put(K key,V value){
  checkKey(key);
  checkValue(value);
  sendEventAsync(put,toParameters(put,key,value));
  return false;
}","public boolean put(K key,V value){
  checkKey(key);
  checkValue(value);
  sendEventAsync(put,toParameters(put,key,value),true);
  return false;
}"
55365,"@Override public void set(final E event){
  checkEvent(event);
  sendEventAsync(set,valueOut -> valueOut.object(event));
}","@Override public void set(final E event){
  checkEvent(event);
  sendEventAsync(set,valueOut -> valueOut.object(event),true);
}"
55366,"@Override public void unregisterSubscriber(Subscriber<E> subscriber){
  Long subscriberTid=subscribersToTid.remove(subscriber);
  if (subscriberTid != null) {
    sendEventAsync(unregisterSubscriber,valueOut -> valueOut.int64(subscriberTid));
  }
 else   LOG.warn(""String_Node_Str"");
}","@Override public void unregisterSubscriber(Subscriber<E> subscriber){
  Long subscriberTid=subscribersToTid.remove(subscriber);
  if (subscriberTid != null) {
    sendEventAsync(unregisterSubscriber,valueOut -> valueOut.int64(subscriberTid),false);
  }
 else   LOG.warn(""String_Node_Str"");
}"
55367,"@Override public <T>void asyncUpdate(@NotNull SerializableBiFunction<E,T,E> updateFunction,T argument){
  sendEventAsync(update2,toParameters(update2,updateFunction,argument));
}","@Override public <T>void asyncUpdate(@NotNull SerializableBiFunction<E,T,E> updateFunction,T argument){
  sendEventAsync(update2,toParameters(update2,updateFunction,argument),true);
}"
55368,"@Override public void remove(){
  sendEventAsync(remove,null);
}","@Override public void remove(){
  sendEventAsync(remove,null,true);
}"
55369,"@Override public void publish(final T topic,final M message){
  checkTopic(topic);
  checkMessage(message);
  sendEventAsync(publish,valueOut -> valueOut.marshallable(m -> {
    m.write(Params.topic).object(topic);
    m.write(Params.message).object(message);
  }
));
}","@Override public void publish(final T topic,final M message){
  checkTopic(topic);
  checkMessage(message);
  sendEventAsync(publish,valueOut -> valueOut.marshallable(m -> {
    m.write(Params.topic).object(topic);
    m.write(Params.message).object(message);
  }
),true);
}"
55370,"protected <R>R readReply(@NotNull WireIn wireIn,@NotNull WireKey replyId,@NotNull Function<ValueIn,R> function){
  final ValueIn event=wireIn.read(eventName);
  if (replyId.contentEquals(eventName))   return function.apply(event);
  if (CoreFields.exception.contentEquals(eventName)) {
    throw Jvm.rethrow(event.throwable(true));
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + eventName);
}","protected <R>R readReply(@NotNull WireIn wireIn,@NotNull WireKey replyId,@NotNull Function<ValueIn,R> function){
  StringBuilder eventName=Wires.acquireStringBuilder();
  final ValueIn event=wireIn.read(eventName);
  if (replyId.contentEquals(eventName))   return function.apply(event);
  if (CoreFields.exception.contentEquals(eventName)) {
    throw Jvm.rethrow(event.throwable(true));
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + eventName);
}"
55371,"protected void readReplyConsumer(@NotNull WireIn wireIn,@NotNull WireKey replyId,@NotNull Consumer<ValueIn> consumer){
  final ValueIn event=wireIn.read(eventName);
  if (replyId.contentEquals(eventName)) {
    consumer.accept(event);
    return;
  }
  if (CoreFields.exception.contentEquals(eventName)) {
    throw Jvm.rethrow(event.throwable(true));
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + eventName);
}","protected void readReplyConsumer(@NotNull WireIn wireIn,@NotNull WireKey replyId,@NotNull Consumer<ValueIn> consumer){
  StringBuilder eventName=Wires.acquireStringBuilder();
  final ValueIn event=wireIn.read(eventName);
  if (replyId.contentEquals(eventName)) {
    consumer.accept(event);
    return;
  }
  if (CoreFields.exception.contentEquals(eventName)) {
    throw Jvm.rethrow(event.throwable(true));
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + eventName);
}"
55372,"protected void sendEventAsync(@NotNull final WireKey eventId,@Nullable final Consumer<ValueOut> consumer){
  hub.checkConnection();
  hub.outBytesLock().lock();
  try {
    sendEventAsyncWithoutLock(eventId,consumer);
  }
 catch (  IORuntimeException e) {
  }
 finally {
    hub.outBytesLock().unlock();
  }
}","/** 
 * @param eventId
 * @param consumer
 * @param blockTillTimeout if false - will only be sent if the connection is valid
 */
protected void sendEventAsync(@NotNull final WireKey eventId,@Nullable final Consumer<ValueOut> consumer,boolean blockTillTimeout){
  if (blockTillTimeout)   hub.checkConnection();
 else   if (!hub.isOpen())   return;
  hub.outBytesLock().lock();
  try {
    sendEventAsyncWithoutLock(eventId,consumer);
  }
 catch (  IORuntimeException e) {
  }
 finally {
    hub.outBytesLock().unlock();
  }
}"
55373,"public void forRemoteAccess(String hostPortDescription,Function<Bytes,Wire> wire) throws AssetNotFoundException {
  standardStack(true);
  addWrappingRule(MapView.class,LAST + ""String_Node_Str"",RemoteMapView::new,ObjectKeyValueStore.class);
  addLeafRule(ObjectKVSSubscription.class,LAST + ""String_Node_Str"",RemoteKVSSubscription::new);
  addLeafRule(ObjectKeyValueStore.class,LAST + ""String_Node_Str"",RemoteKeyValueStore::new);
  addWrappingRule(TopicPublisher.class,LAST + ""String_Node_Str"",RemoteTopicPublisher::new,MapView.class);
  addLeafRule(TopologySubscription.class,LAST + ""String_Node_Str"",RemoteTopologySubscription::new);
  SessionProvider sessionProvider=getView(SessionProvider.class);
  VanillaSessionDetails sessionDetails=new VanillaSessionDetails();
  sessionDetails.setUserId(System.getProperty(""String_Node_Str""));
  sessionProvider.set(sessionDetails);
  EventLoop eventLoop=findOrCreateView(EventLoop.class);
  if (getView(TcpChannelHub.class) == null) {
    TcpChannelHub view=Threads.withThreadGroup(findView(ThreadGroup.class),() -> new TcpChannelHub(sessionProvider,hostPortDescription,eventLoop,wire));
    addView(TcpChannelHub.class,view);
  }
}","public void forRemoteAccess(String hostPortDescription,Function<Bytes,Wire> wire) throws AssetNotFoundException {
  standardStack(true);
  addWrappingRule(MapView.class,LAST + ""String_Node_Str"",RemoteMapView::new,ObjectKeyValueStore.class);
  addLeafRule(ObjectKVSSubscription.class,LAST + ""String_Node_Str"",RemoteKVSSubscription::new);
  addLeafRule(ObjectKeyValueStore.class,LAST + ""String_Node_Str"",RemoteKeyValueStore::new);
  addWrappingRule(TopicPublisher.class,LAST + ""String_Node_Str"",RemoteTopicPublisher::new,MapView.class);
  addLeafRule(TopologySubscription.class,LAST + ""String_Node_Str"",RemoteTopologySubscription::new);
  SessionProvider sessionProvider=getView(SessionProvider.class);
  VanillaSessionDetails sessionDetails=new VanillaSessionDetails();
  sessionDetails.setUserId(System.getProperty(""String_Node_Str""));
  sessionProvider.set(sessionDetails);
  EventLoop eventLoop=findOrCreateView(EventLoop.class);
  eventLoop.start();
  if (getView(TcpChannelHub.class) == null) {
    TcpChannelHub view=Threads.withThreadGroup(findView(ThreadGroup.class),() -> new TcpChannelHub(sessionProvider,hostPortDescription,eventLoop,wire));
    addView(TcpChannelHub.class,view);
  }
}"
55374,"void registerSubscriber0(@NotNull RequestContext rc,@NotNull Subscriber subscriber){
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  Boolean bootstrap=rc.bootstrap();
  String csp=this.csp;
  if (bootstrap != null)   csp=csp + ""String_Node_Str"" + bootstrap;
  hub.subscribe(new AbstractAsyncSubscription(hub,csp){
{
      subscribersToTid.put(subscriber,tid());
    }
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerSubscriber).typeLiteral(CLASS_ALIASES.nameFor(rc.elementType()));
    }
    @Override public void onConsumer(    @NotNull final WireIn inWire){
      inWire.readDocument(null,d -> {
        final StringBuilder eventname=Wires.acquireStringBuilder();
        final ValueIn valueIn=d.readEventName(eventname);
        if (PublisherHandler.EventId.onEndOfSubscription.contentEquals(eventname)) {
          subscriber.onEndOfSubscription();
          hub.unsubscribe(tid());
        }
 else         if (CoreFields.reply.contentEquals(eventname)) {
          final Class aClass=rc.elementType();
          final Object object=(MapEvent.class.isAssignableFrom(aClass) || (TopologicalEvent.class.isAssignableFrom(aClass))) ? valueIn.typedMarshallable() : valueIn.object(rc.elementType());
          AbstractRemoteSubscription.this.onEvent(object,subscriber);
        }
      }
);
    }
  }
);
}","void registerSubscriber0(@NotNull RequestContext rc,@NotNull Subscriber subscriber){
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  Boolean bootstrap=rc.bootstrap();
  String csp=this.csp;
  if (bootstrap != null)   csp=csp + ""String_Node_Str"" + bootstrap;
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,this.getClass().getSimpleName() + ""String_Node_Str""){
{
      subscribersToTid.put(subscriber,tid());
    }
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerSubscriber).typeLiteral(CLASS_ALIASES.nameFor(rc.elementType()));
    }
    @Override public void onConsumer(    @NotNull final WireIn inWire){
      inWire.readDocument(null,d -> {
        final StringBuilder eventname=Wires.acquireStringBuilder();
        final ValueIn valueIn=d.readEventName(eventname);
        if (PublisherHandler.EventId.onEndOfSubscription.contentEquals(eventname)) {
          subscriber.onEndOfSubscription();
          hub.unsubscribe(tid());
        }
 else         if (CoreFields.reply.contentEquals(eventname)) {
          final Class aClass=rc.elementType();
          final Object object=(MapEvent.class.isAssignableFrom(aClass) || (TopologicalEvent.class.isAssignableFrom(aClass))) ? valueIn.typedMarshallable() : valueIn.object(rc.elementType());
          AbstractRemoteSubscription.this.onEvent(object,subscriber);
        }
      }
);
    }
  }
);
}"
55375,"@Override public void registerTopicSubscriber(RequestContext rc,@NotNull TopicSubscriber<K,V> subscriber){
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  hub.subscribe(new AbstractAsyncSubscription(hub,csp){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerTopicSubscriber).marshallable(m -> {
        m.write(() -> ""String_Node_Str"").typeLiteral(kClass);
        m.write(() -> ""String_Node_Str"").typeLiteral(vClass);
      }
);
    }
    @Override public void onConsumer(    @NotNull final WireIn inWire){
      inWire.readDocument(null,d -> {
        ValueIn valueIn=d.read(reply);
        valueIn.marshallable(m -> {
          final K topic=m.read(() -> ""String_Node_Str"").object(kClass);
          final V message=m.read(() -> ""String_Node_Str"").object(vClass);
          RemoteKVSSubscription.this.onEvent(topic,message,subscriber);
        }
);
      }
);
    }
  }
);
}","@Override public void registerTopicSubscriber(RequestContext rc,@NotNull TopicSubscriber<K,V> subscriber){
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerTopicSubscriber).marshallable(m -> {
        m.write(() -> ""String_Node_Str"").typeLiteral(kClass);
        m.write(() -> ""String_Node_Str"").typeLiteral(vClass);
      }
);
    }
    @Override public void onConsumer(    @NotNull final WireIn inWire){
      inWire.readDocument(null,d -> {
        ValueIn valueIn=d.read(reply);
        valueIn.marshallable(m -> {
          final K topic=m.read(() -> ""String_Node_Str"").object(kClass);
          final V message=m.read(() -> ""String_Node_Str"").object(vClass);
          RemoteKVSSubscription.this.onEvent(topic,message,subscriber);
        }
);
      }
);
    }
  }
);
}"
55376,"@Override public void registerSubscriber(boolean bootstrap,@NotNull final Subscriber subscriber) throws AssetNotFoundException {
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  final AbstractAsyncSubscription asyncSubscription=new AbstractAsyncSubscription(hub,csp + ""String_Node_Str"" + bootstrap){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerSubscriber).text(""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull final WireIn w){
      w.readDocument(null,d -> {
        final StringBuilder eventname=Wires.acquireStringBuilder();
        final ValueIn valueIn=d.readEventName(eventname);
        if (EventId.onEndOfSubscription.contentEquals(eventname)) {
          subscriber.onEndOfSubscription();
          hub.unsubscribe(tid());
        }
 else         if (CoreFields.reply.contentEquals(eventname)) {
          valueIn.marshallable(m -> {
            final E message=m.read(() -> ""String_Node_Str"").object(messageClass);
            RemoteReference.this.onEvent(message,subscriber);
          }
);
        }
      }
);
    }
  }
;
  hub.subscribe(asyncSubscription);
}","@Override public void registerSubscriber(boolean bootstrap,@NotNull final Subscriber subscriber) throws AssetNotFoundException {
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  final AbstractAsyncSubscription asyncSubscription=new AbstractAsyncSubscription(hub,csp + ""String_Node_Str"" + bootstrap,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerSubscriber).text(""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull final WireIn w){
      w.readDocument(null,d -> {
        final StringBuilder eventname=Wires.acquireStringBuilder();
        final ValueIn valueIn=d.readEventName(eventname);
        if (EventId.onEndOfSubscription.contentEquals(eventname)) {
          subscriber.onEndOfSubscription();
          hub.unsubscribe(tid());
        }
 else         if (CoreFields.reply.contentEquals(eventname)) {
          valueIn.marshallable(m -> {
            final E message=m.read(() -> ""String_Node_Str"").object(messageClass);
            RemoteReference.this.onEvent(message,subscriber);
          }
);
        }
      }
);
    }
  }
;
  hub.subscribe(asyncSubscription);
}"
55377,"@Override public void registerTopicSubscriber(@NotNull final TopicSubscriber<T,M> topicSubscriber) throws AssetNotFoundException {
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  hub.subscribe(new AbstractAsyncSubscription(hub,csp){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerSubscriber).text(""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull final WireIn w){
      w.readDocument(null,d -> {
        final StringBuilder eventname=Wires.acquireStringBuilder();
        final ValueIn valueIn=d.readEventName(eventname);
        if (onEndOfSubscription.contentEquals(eventname)) {
          topicSubscriber.onEndOfSubscription();
          hub.unsubscribe(tid());
        }
 else         if (CoreFields.reply.contentEquals(eventname)) {
          valueIn.marshallable(m -> {
            final T topic=m.read(() -> ""String_Node_Str"").object(topicClass);
            final M message=m.read(() -> ""String_Node_Str"").object(messageClass);
            RemoteTopicPublisher.this.onEvent(topic,message,topicSubscriber);
          }
);
        }
      }
);
    }
  }
);
}","@Override public void registerTopicSubscriber(@NotNull final TopicSubscriber<T,M> topicSubscriber) throws AssetNotFoundException {
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  hub.subscribe(new AbstractAsyncSubscription(hub,csp,""String_Node_Str""){
    @Override public void onSubscribe(    @NotNull final WireOut wireOut){
      wireOut.writeEventName(registerSubscriber).text(""String_Node_Str"");
    }
    @Override public void onConsumer(    @NotNull final WireIn w){
      w.readDocument(null,d -> {
        final StringBuilder eventname=Wires.acquireStringBuilder();
        final ValueIn valueIn=d.readEventName(eventname);
        if (onEndOfSubscription.contentEquals(eventname)) {
          topicSubscriber.onEndOfSubscription();
          hub.unsubscribe(tid());
        }
 else         if (CoreFields.reply.contentEquals(eventname)) {
          valueIn.marshallable(m -> {
            final T topic=m.read(() -> ""String_Node_Str"").object(topicClass);
            final M message=m.read(() -> ""String_Node_Str"").object(messageClass);
            RemoteTopicPublisher.this.onEvent(topic,message,topicSubscriber);
          }
);
        }
      }
);
    }
  }
);
}"
55378,"public AbstractAsyncSubscription(@NotNull final TcpChannelHub hub,String csp,byte identifier){
  this.tid=hub.nextUniqueTransaction(Time.currentTimeMillis()) * identifier;
  this.hub=hub;
  this.csp=csp;
}","public AbstractAsyncSubscription(@NotNull final TcpChannelHub hub,String csp,byte identifier,String name){
  this.tid=hub.nextUniqueTransaction(Time.currentTimeMillis()) * identifier;
  this.hub=hub;
  this.csp=csp;
  this.name=name;
}"
55379,"/** 
 * @param hub handles the tcp connectivity.
 * @param csp the url of the subscription.
 * @param id  use as a seed to the tid, makes unique tid'd makes reading the logs easier.
 */
public AbstractAsyncTemporarySubscription(@NotNull TcpChannelHub hub,@Nullable String csp,byte id){
  super(hub,csp,id);
}","/** 
 * @param hub handles the tcp connectivity.
 * @param csp the url of the subscription.
 * @param id  use as a seed to the tid, makes unique tid'd makes reading the logs easier.
 * @param name
 */
public AbstractAsyncTemporarySubscription(@NotNull TcpChannelHub hub,@Nullable String csp,byte id,String name){
  super(hub,csp,id,name);
}"
55380,"/** 
 * sends a heartbeat from the client to the server and logs the round trip time
 */
private void sendHeartbeat(){
  long l=System.nanoTime();
  subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this,null){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(heartbeat).int64(Time.currentTimeMillis());
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      long roundTipTimeMicros=NANOSECONDS.toMicros(System.nanoTime() - l);
      if (LOG.isDebugEnabled())       LOG.debug(String.format(""String_Node_Str"",description,TCPRegistry.lookup(description),roundTipTimeMicros));
      inWire.clear();
    }
  }
);
}","/** 
 * sends a heartbeat from the client to the server and logs the round trip time
 */
private void sendHeartbeat(){
  long l=System.nanoTime();
  subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this,null,name){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(heartbeat).int64(Time.currentTimeMillis());
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      long roundTipTimeMicros=NANOSECONDS.toMicros(System.nanoTime() - l);
      if (LOG.isDebugEnabled())       LOG.debug(String.format(""String_Node_Str"",description,TCPRegistry.lookup(description),roundTipTimeMicros));
      inWire.clear();
    }
  }
);
}"
55381,"private void attemptConnect(){
  for (; ; ) {
    System.out.println(""String_Node_Str"" + remoteAddress);
    SocketChannel socketChannel;
    try {
      for (; ; ) {
        socketChannel=openSocketChannel();
        try {
          if (socketChannel == null || !socketChannel.connect(remoteAddress)) {
            pause(100);
            continue;
          }
 else           break;
        }
 catch (        ConnectException e) {
          pause(100);
          continue;
        }
      }
      socketChannel.socket().setTcpNoDelay(true);
      socketChannel.socket().setReceiveBufferSize(tcpBufferSize);
      socketChannel.socket().setSendBufferSize(tcpBufferSize);
      onMessageReceived();
      doHandShaking(socketChannel);
synchronized (this) {
        clientChannel=socketChannel;
      }
      eventLoop.addHandler(this);
      System.out.println(""String_Node_Str"" + remoteAddress);
      reconnect();
      onConnected();
      break;
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"" + remoteAddress + ""String_Node_Str"");
      closeSocket();
    }
  }
}","private void attemptConnect(){
  for (; ; ) {
    System.out.println(""String_Node_Str"" + remoteAddress);
    SocketChannel socketChannel;
    try {
      for (; ; ) {
        socketChannel=openSocketChannel();
        try {
          if (socketChannel == null || !socketChannel.connect(remoteAddress)) {
            LOG.error(""String_Node_Str"" + remoteAddress);
            pause(1000);
            continue;
          }
 else           break;
        }
 catch (        ConnectException e) {
          LOG.error(""String_Node_Str"" + remoteAddress);
          pause(1000);
          continue;
        }
      }
      socketChannel.socket().setTcpNoDelay(true);
      socketChannel.socket().setReceiveBufferSize(tcpBufferSize);
      socketChannel.socket().setSendBufferSize(tcpBufferSize);
      onMessageReceived();
      doHandShaking(socketChannel);
synchronized (this) {
        clientChannel=socketChannel;
      }
      eventLoop.addHandler(this);
      System.out.println(""String_Node_Str"" + remoteAddress);
      reconnect();
      onConnected();
      break;
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"" + remoteAddress + ""String_Node_Str"");
      closeSocket();
    }
  }
}"
55382,"/** 
 * blocks this thread until a response is received from the socket
 * @param timeoutTimeMs the amount of time to wait before a time out exceptions
 * @param tid           the {@code tid} of the message that we are waiting for
 * @throws InterruptedException
 */
private Wire syncBlockingReadSocket(final long timeoutTimeMs,long tid) throws InterruptedException, TimeoutException {
  long start=Time.currentTimeMillis();
  final Wire wire=syncInWireThreadLocal.get();
  wire.clear();
  Bytes<?> bytes=wire.bytes();
  ((ByteBuffer)bytes.underlyingObject()).clear();
synchronized (bytes) {
    map.put(tid,bytes);
    bytes.wait(timeoutTimeMs);
  }
  logToStandardOutMessageReceived(wire);
  if (Time.currentTimeMillis() - start >= timeoutTimeMs) {
    throw new TimeoutException(""String_Node_Str"" + timeoutTimeMs);
  }
  return wire;
}","/** 
 * blocks this thread until a response is received from the socket
 * @param timeoutTimeMs the amount of time to wait before a time out exceptions
 * @param tid           the {@code tid} of the message that we are waiting for
 * @throws InterruptedException
 */
private Wire syncBlockingReadSocket(final long timeoutTimeMs,long tid) throws InterruptedException, TimeoutException {
  long start=Time.currentTimeMillis();
  final Wire wire=syncInWireThreadLocal.get();
  wire.clear();
  Bytes<?> bytes=wire.bytes();
  ((ByteBuffer)bytes.underlyingObject()).clear();
synchronized (bytes) {
    map.put(tid,bytes);
    System.out.println(""String_Node_Str"" + tid + ""String_Node_Str""+ bytes);
    bytes.wait(timeoutTimeMs);
  }
  logToStandardOutMessageReceived(wire);
  if (Time.currentTimeMillis() - start >= timeoutTimeMs) {
    throw new TimeoutException(""String_Node_Str"" + timeoutTimeMs);
  }
  return wire;
}"
55383,"/** 
 * re-establish all the subscriptions to the server, this method calls the   {@code net.openhft.chronicle.network.connection.AsyncSubscription#applySubscribe()} for eachsubscription, this could should establish a subscriotuib with the server.
 */
private void reconnect(){
  ReentrantLock lock=outBytesLock();
  lock.lock();
  try {
    map.values().forEach(v -> {
      if (v instanceof AsyncSubscription) {
        if (!(v instanceof AsyncTemporarySubscription))         ((AsyncSubscription)v).applySubscribe();
      }
    }
);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * re-establish all the subscriptions to the server, this method calls the   {@code net.openhft.chronicle.network.connection.AsyncSubscription#applySubscribe()} for eachsubscription, this could should establish a subscription with the server.
 */
private void reconnect(){
  ReentrantLock lock=outBytesLock();
  lock.lock();
  try {
    map.values().forEach(v -> {
      if (v instanceof AsyncSubscription) {
        if (!(v instanceof AsyncTemporarySubscription))         ((AsyncSubscription)v).applySubscribe();
      }
    }
);
  }
  finally {
    lock.unlock();
  }
}"
55384,"void subscribe(@NotNull final AsyncSubscription asyncSubscription){
  if (clientChannel == null) {
    map.put(asyncSubscription.tid(),asyncSubscription);
    return;
  }
  final ReentrantLock reentrantLock=outBytesLock();
  reentrantLock.lock();
  try {
    map.put(asyncSubscription.tid(),asyncSubscription);
    asyncSubscription.applySubscribe();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    reentrantLock.unlock();
  }
}","void subscribe(@NotNull final AsyncSubscription asyncSubscription){
  if (clientChannel == null) {
    if (asyncSubscription instanceof AsyncTemporarySubscription) {
      LOG.error(""String_Node_Str"");
    }
    map.put(asyncSubscription.tid(),asyncSubscription);
    System.out.println(""String_Node_Str"" + asyncSubscription.tid() + ""String_Node_Str""+ asyncSubscription);
    return;
  }
  final ReentrantLock reentrantLock=outBytesLock();
  reentrantLock.lock();
  try {
    map.put(asyncSubscription.tid(),asyncSubscription);
    System.out.println(""String_Node_Str"" + asyncSubscription.tid() + ""String_Node_Str""+ asyncSubscription);
    asyncSubscription.applySubscribe();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    reentrantLock.unlock();
  }
}"
55385,"@Nullable public AcceptorEventHandler start(String hostPortDescription,@NotNull final AssetTree asset,WireType wireType) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(hostPortDescription,() -> new EngineWireHandler(wireType,asset,isClosed),VanillaSessionDetails::new);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}","@Nullable public AcceptorEventHandler start(String hostPortDescription,@NotNull final AssetTree asset,WireType wireType) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(hostPortDescription,() -> new EngineWireHandler(wireType,asset),VanillaSessionDetails::new);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}"
55386,"@Override protected void process(@NotNull final WireIn in,@NotNull final WireOut out,@NotNull final SessionDetailsProvider sessionDetails) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn wire) -> {
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + wire.bytes().toHexString());
      sessionProvider.set(sessionDetails);
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails);
        return;
      }
      if (wireAdapter != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext,byteToWire);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesCollection.class) {
          valuesHandler.process(in,out,(ValuesCollection)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (viewType == ObjectKVSSubscription.class) {
          subscriptionHandler.process(in,requestContext,publisher,assetTree,tid,outWire,(Subscription)view);
          return;
        }
        if (viewType == TopologySubscription.class) {
          topologySubscriptionHandler.process(in,requestContext,publisher,assetTree,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (viewType == TopicPublisher.class) {
          topicPublisherHandler.process(in,publisher,tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (viewType == Publisher.class) {
          publisherHandler.process(in,publisher,tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (viewType == Replication.class) {
          replicationHandler.process(in,publisher,tid,outWire,hostIdentifier,(Replication)view,isClosed,eventLoop);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"")) {
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
 finally {
      sessionProvider.remove();
    }
  }
);
}","@Override protected void process(@NotNull final WireIn in,@NotNull final WireOut out,@NotNull final SessionDetailsProvider sessionDetails) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn wire) -> {
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + wire.bytes().toHexString());
      sessionProvider.set(sessionDetails);
      if (isSystemMessage) {
        systemHandler.process(in,out,tid,sessionDetails);
        return;
      }
      if (wireAdapter != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,tid,wireAdapter,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesCollection.class) {
          valuesHandler.process(in,out,(ValuesCollection)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (viewType == ObjectKVSSubscription.class) {
          subscriptionHandler.process(in,requestContext,publisher,assetTree,tid,outWire,(Subscription)view);
          return;
        }
        if (viewType == TopologySubscription.class) {
          topologySubscriptionHandler.process(in,requestContext,publisher,assetTree,tid,outWire,(TopologySubscription)view);
          return;
        }
        if (viewType == TopicPublisher.class) {
          topicPublisherHandler.process(in,publisher,tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (viewType == Publisher.class) {
          publisherHandler.process(in,publisher,tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (viewType == Replication.class) {
          replicationHandler.process(in,publisher,tid,outWire,hostIdentifier,(Replication)view,eventLoop);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"")) {
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
 finally {
      sessionProvider.remove();
    }
  }
);
}"
55387,"public EngineWireHandler(@NotNull final WireType byteToWire,@NotNull final AssetTree assetTree,@NotNull final AtomicBoolean isClosed){
  super(byteToWire);
  this.byteToWire=byteToWire;
  this.sessionProvider=assetTree.root().getView(SessionProvider.class);
  this.eventLoop=assetTree.root().findOrCreateView(EventLoop.class);
  try {
    this.eventLoop.start();
  }
 catch (  RejectedExecutionException e) {
    LOG.debug(""String_Node_Str"",e);
  }
  this.hostIdentifier=assetTree.root().findOrCreateView(HostIdentifier.class);
  this.assetTree=assetTree;
  this.mapWireHandler=new MapWireHandler<>();
  this.metaDataConsumer=wireInConsumer();
  this.keySetHandler=new CollectionWireHandler();
  this.entrySetHandler=new CollectionWireHandler();
  this.valuesHandler=new CollectionWireHandler();
  this.subscriptionHandler=new ObjectKVSubscriptionHandler();
  this.topologySubscriptionHandler=new TopologySubscriptionHandler();
  this.topicPublisherHandler=new TopicPublisherHandler();
  this.publisherHandler=new PublisherHandler();
  this.replicationHandler=new ReplicationHandler();
  this.systemHandler=new SystemHandler();
  this.isClosed=isClosed;
}","public EngineWireHandler(@NotNull final WireType byteToWire,@NotNull final AssetTree assetTree){
  super(byteToWire);
  this.byteToWire=byteToWire;
  this.sessionProvider=assetTree.root().getView(SessionProvider.class);
  this.eventLoop=assetTree.root().findOrCreateView(EventLoop.class);
  try {
    this.eventLoop.start();
  }
 catch (  RejectedExecutionException e) {
    LOG.debug(""String_Node_Str"",e);
  }
  this.hostIdentifier=assetTree.root().findOrCreateView(HostIdentifier.class);
  this.assetTree=assetTree;
  this.mapWireHandler=new MapWireHandler<>();
  this.metaDataConsumer=wireInConsumer();
  this.keySetHandler=new CollectionWireHandler();
  this.entrySetHandler=new CollectionWireHandler();
  this.valuesHandler=new CollectionWireHandler();
  this.subscriptionHandler=new ObjectKVSubscriptionHandler();
  this.topologySubscriptionHandler=new TopologySubscriptionHandler();
  this.topicPublisherHandler=new TopicPublisherHandler();
  this.publisherHandler=new PublisherHandler();
  this.replicationHandler=new ReplicationHandler();
  this.systemHandler=new SystemHandler();
}"
55388,"/** 
 * @param in             the data the has come in from network
 * @param out            the data that is going out to network
 * @param map            the map that is being processed
 * @param tid            the transaction id of the event
 * @param wireAdapter    adapts keys and values to and from wire
 * @param requestContext the uri of the event
 * @param byteToWire
 * @throws StreamCorruptedException
 */
public void process(@NotNull final WireIn in,@NotNull final WireOut out,@NotNull MapView map,long tid,@NotNull final WireAdapter wireAdapter,@NotNull final RequestContext requestContext,@NotNull final WireType byteToWire) throws StreamCorruptedException {
}","/** 
 * @param byteToWire
 * @param in             the data the has come in from network
 * @param out            the data that is going out to network
 * @param map            the map that is being processed
 * @param tid            the transaction id of the event
 * @param wireAdapter    adapts keys and values to and from wire
 * @param requestContext the uri of the event
 * @throws StreamCorruptedException
 */
public void process(@NotNull final WireIn in,@NotNull final WireOut out,@NotNull MapView map,long tid,@NotNull final WireAdapter wireAdapter,@NotNull final RequestContext requestContext) throws StreamCorruptedException {
}"
55389,"void process(@NotNull final WireIn inWire,final WireOutPublisher publisher,final long tid,final Wire outWire,final HostIdentifier hostId,final Replication replication,final AtomicBoolean isClosed,final EventLoop eventLoop){
  this.isClosed=isClosed;
  this.eventLoop=eventLoop;
  setOutWire(outWire);
  this.hostId=hostId;
  this.publisher=publisher;
  this.replication=replication;
  this.tid=tid;
  dataConsumer.accept(inWire,tid);
}","void process(@NotNull final WireIn inWire,final WireOutPublisher publisher,final long tid,final Wire outWire,final HostIdentifier hostId,final Replication replication,final EventLoop eventLoop){
  this.eventLoop=eventLoop;
  setOutWire(outWire);
  this.hostId=hostId;
  this.publisher=publisher;
  this.replication=replication;
  this.tid=tid;
  dataConsumer.accept(inWire,tid);
}"
55390,"private void attemptConnect(){
  for (; ; ) {
    System.out.println(""String_Node_Str"" + remoteAddress);
    SocketChannel socketChannel;
    try {
      for (; ; ) {
        socketChannel=openSocketChannel();
        try {
          if (socketChannel == null || !socketChannel.connect(remoteAddress)) {
            pause(100);
            continue;
          }
 else           break;
        }
 catch (        ConnectException e) {
          pause(100);
          continue;
        }
      }
      socketChannel.socket().setTcpNoDelay(true);
      socketChannel.socket().setReceiveBufferSize(tcpBufferSize);
      socketChannel.socket().setSendBufferSize(tcpBufferSize);
      onMessageReceived();
      doHandShaking(socketChannel);
synchronized (this) {
        clientChannel=socketChannel;
      }
      eventLoop.addHandler(this);
      System.out.println(""String_Node_Str"" + remoteAddress);
      reconnect();
      onConnected();
      break;
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"" + remoteAddress + ""String_Node_Str"");
      disconnect();
    }
  }
}","private void attemptConnect(){
  for (; ; ) {
    System.out.println(""String_Node_Str"" + remoteAddress);
    SocketChannel socketChannel;
    try {
      for (; ; ) {
        socketChannel=openSocketChannel();
        try {
          if (socketChannel == null || !socketChannel.connect(remoteAddress)) {
            pause(100);
            continue;
          }
 else           break;
        }
 catch (        ConnectException e) {
          pause(100);
          continue;
        }
      }
      socketChannel.socket().setTcpNoDelay(true);
      socketChannel.socket().setReceiveBufferSize(tcpBufferSize);
      socketChannel.socket().setSendBufferSize(tcpBufferSize);
      onMessageReceived();
      doHandShaking(socketChannel);
synchronized (this) {
        clientChannel=socketChannel;
      }
      eventLoop.addHandler(this);
      System.out.println(""String_Node_Str"" + remoteAddress);
      reconnect();
      onConnected();
      break;
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"" + remoteAddress + ""String_Node_Str"");
      closeSocket();
    }
  }
}"
55391,"/** 
 * gets called periodically to monitor the heartbeat
 * @return true, if processing was performed
 * @throws InvalidEventHandlerException
 */
@Override public boolean action() throws InvalidEventHandlerException {
  if (clientChannel == null)   throw new InvalidEventHandlerException();
  long currentTime=Time.currentTimeMillis();
  long millisecondsSinceLastMessageReceived=currentTime - lastTimeMessageReceived;
  long millisecondsSinceLastHeatbeatSend=currentTime - lastheartbeatSentTime;
  if (millisecondsSinceLastMessageReceived >= HEATBEAT_PING_PERIOD && millisecondsSinceLastHeatbeatSend >= HEATBEAT_PING_PERIOD) {
    lastheartbeatSentTime=Time.currentTimeMillis();
    sendHeartbeat();
  }
  long x=millisecondsSinceLastMessageReceived - HEATBEAT_TIMEOUT_PERIOD;
  if (x > 0) {
    LOG.warn(""String_Node_Str"");
    disconnect();
    throw new InvalidEventHandlerException();
  }
  return true;
}","/** 
 * gets called periodically to monitor the heartbeat
 * @return true, if processing was performed
 * @throws InvalidEventHandlerException
 */
@Override public boolean action() throws InvalidEventHandlerException {
  if (clientChannel == null)   throw new InvalidEventHandlerException();
  long currentTime=Time.currentTimeMillis();
  long millisecondsSinceLastMessageReceived=currentTime - lastTimeMessageReceived;
  long millisecondsSinceLastHeatbeatSend=currentTime - lastheartbeatSentTime;
  if (millisecondsSinceLastMessageReceived >= HEATBEAT_PING_PERIOD && millisecondsSinceLastHeatbeatSend >= HEATBEAT_PING_PERIOD) {
    lastheartbeatSentTime=Time.currentTimeMillis();
    sendHeartbeat();
  }
  long x=millisecondsSinceLastMessageReceived - HEATBEAT_TIMEOUT_PERIOD;
  if (x > 0) {
    LOG.warn(""String_Node_Str"");
    closeSocket();
    throw new InvalidEventHandlerException();
  }
  return true;
}"
55392,"private void checkConnectionState(){
  if (clientChannel != null)   return;
  System.out.println(""String_Node_Str"" + remoteAddress);
  disconnect();
  attemptConnect();
}","private void checkConnectionState(){
  if (clientChannel != null)   return;
  System.out.println(""String_Node_Str"" + remoteAddress);
  attemptConnect();
}"
55393,"public Wire proxyReply(long timeoutTime,final long tid){
  checkNotClosed();
  try {
    return tcpSocketConsumer.syncBlockingReadSocket(timeoutTime,tid);
  }
 catch (  IORuntimeException|AssertionError e) {
    throw e;
  }
catch (  RuntimeException e) {
    disconnect();
    throw e;
  }
catch (  Exception e) {
    disconnect();
    throw rethrow(e);
  }
}","public Wire proxyReply(long timeoutTime,final long tid){
  checkNotClosed();
  try {
    return tcpSocketConsumer.syncBlockingReadSocket(timeoutTime,tid);
  }
 catch (  IORuntimeException|AssertionError e) {
    throw e;
  }
catch (  RuntimeException e) {
    LOG.error(""String_Node_Str"",e);
    closeSocket();
    throw e;
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
    closeSocket();
    throw rethrow(e);
  }
}"
55394,"@Test public void test() throws InterruptedException, IOException {
  ReplicationServerMain server=new ReplicationServerMain();
  ServerEndpoint s1=server.create(1,""String_Node_Str"");
  server.create(2,""String_Node_Str"");
  YamlLogging.clientReads=true;
  YamlLogging.clientWrites=true;
  WireType wireType=WireType.TEXT;
  final Integer hostId=Integer.getInteger(""String_Node_Str"",1);
  BlockingQueue q1=new ArrayBlockingQueue(1);
  BlockingQueue q2=new ArrayBlockingQueue(1);
{
    String hostname=System.getProperty(""String_Node_Str"",""String_Node_Str"");
    int port=Integer.getInteger(""String_Node_Str"",5701);
    map1=create(""String_Node_Str"",hostId,hostname + ""String_Node_Str"" + port,q1,wireType);
  }
{
    String hostname=System.getProperty(""String_Node_Str"",""String_Node_Str"");
    int port=Integer.getInteger(""String_Node_Str"",5702);
    map2=create(""String_Node_Str"",hostId,hostname + ""String_Node_Str"" + port,q2,wireType);
  }
  map2.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",q1.take().toString());
  Assert.assertEquals(""String_Node_Str"",q2.take().toString());
  Assert.assertEquals(1,map1.size());
  Assert.assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  Assert.assertEquals(1,map2.size());
  Assert.assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  map2.remove(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",q1.take().toString());
  Assert.assertEquals(""String_Node_Str"",q2.take().toString());
}","@Test public void test() throws InterruptedException, IOException {
  ReplicationServerMain server=new ReplicationServerMain();
  YamlLogging.clientReads=true;
  YamlLogging.clientWrites=true;
  WireType wireType=WireType.TEXT;
  final Integer hostId=Integer.getInteger(""String_Node_Str"",1);
  BlockingQueue q1=new ArrayBlockingQueue(10);
  BlockingQueue q2=new ArrayBlockingQueue(10);
{
    String hostname=System.getProperty(""String_Node_Str"",""String_Node_Str"");
    int port=Integer.getInteger(""String_Node_Str"",5701);
    map1=create(""String_Node_Str"",hostId,hostname + ""String_Node_Str"" + port,q1,wireType);
  }
{
    String hostname=System.getProperty(""String_Node_Str"",""String_Node_Str"");
    int port=Integer.getInteger(""String_Node_Str"",5702);
    map2=create(""String_Node_Str"",hostId,hostname + ""String_Node_Str"" + port,q2,wireType);
  }
  map2.put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",q1.take().toString());
  Assert.assertEquals(""String_Node_Str"",q2.take().toString());
  Assert.assertEquals(1,map1.size());
  Assert.assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  Assert.assertEquals(1,map2.size());
  Assert.assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  map2.remove(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",q1.take().toString());
  Assert.assertEquals(""String_Node_Str"",q2.take().toString());
}"
55395,"@SuppressWarnings(""String_Node_Str"") private int proxyReturnInt(@NotNull final EventId eventId){
  final long startTime=System.currentTimeMillis();
  return readInt(sendEvent(startTime,eventId,VOID_PARAMETERS),startTime);
}","@SuppressWarnings(""String_Node_Str"") private int proxyReturnInt(@NotNull final EventId eventId){
  final long startTime=Time.currentTimeMillis();
  return readInt(sendEvent(startTime,eventId,VOID_PARAMETERS),startTime);
}"
55396,"@SuppressWarnings(""String_Node_Str"") private boolean proxyReturnBoolean(@NotNull final EventId eventId,@Nullable final Consumer<ValueOut> consumer){
  final long startTime=System.currentTimeMillis();
  return readBoolean(sendEvent(startTime,eventId,consumer),startTime);
}","@SuppressWarnings(""String_Node_Str"") private boolean proxyReturnBoolean(@NotNull final EventId eventId,@Nullable final Consumer<ValueOut> consumer){
  final long startTime=Time.currentTimeMillis();
  return readBoolean(sendEvent(startTime,eventId,consumer),startTime);
}"
55397,"public void stop(){
  eg.stop();
}","public void stop(){
  if (eg != null)   eg.stop();
}"
55398,"public AbstractAsyncSubscription(@NotNull final TcpChannelHub hub,String csp,byte identifier){
  this.tid=hub.nextUniqueTransaction(System.currentTimeMillis()) * identifier;
  this.hub=hub;
  this.csp=csp;
}","public AbstractAsyncSubscription(@NotNull final TcpChannelHub hub,String csp,byte identifier){
  this.tid=hub.nextUniqueTransaction(Time.currentTimeMillis()) * identifier;
  this.hub=hub;
  this.csp=csp;
}"
55399,"public <T>T proxyReturnWireConsumerInOut(@NotNull final WireKey eventId,@NotNull final WireKey reply,@Nullable final Consumer<ValueOut> consumerOut,@NotNull final Function<ValueIn,T> consumerIn){
  final long startTime=System.currentTimeMillis();
  long tid=sendEvent(startTime,eventId,consumerOut);
  return readWire(tid,startTime,reply,consumerIn);
}","public <T>T proxyReturnWireConsumerInOut(@NotNull final WireKey eventId,@NotNull final WireKey reply,@Nullable final Consumer<ValueOut> consumerOut,@NotNull final Function<ValueIn,T> consumerIn){
  final long startTime=Time.currentTimeMillis();
  long tid=sendEvent(startTime,eventId,consumerOut);
  return readWire(tid,startTime,reply,consumerIn);
}"
55400,"@SuppressWarnings(""String_Node_Str"") protected boolean proxyReturnBooleanWithArgs(@NotNull final E eventId,@NotNull final Object... args){
  final long startTime=System.currentTimeMillis();
  final long tid=sendEvent(startTime,eventId,toParameters(eventId,args));
  return readBoolean(tid,startTime);
}","@SuppressWarnings(""String_Node_Str"") protected boolean proxyReturnBooleanWithArgs(@NotNull final E eventId,@NotNull final Object... args){
  final long startTime=Time.currentTimeMillis();
  final long tid=sendEvent(startTime,eventId,toParameters(eventId,args));
  return readBoolean(tid,startTime);
}"
55401,"protected void sendEventAsyncWithoutLock(@NotNull final WireKey eventId,@Nullable final Consumer<ValueOut> consumer){
  writeAsyncMetaData(System.currentTimeMillis());
  hub.outWire().writeDocument(false,wireOut -> {
    final ValueOut valueOut=wireOut.writeEventName(eventId);
    if (consumer == null)     valueOut.marshallable(WriteMarshallable.EMPTY);
 else     consumer.accept(valueOut);
  }
);
  hub.writeSocket(hub.outWire());
}","protected void sendEventAsyncWithoutLock(@NotNull final WireKey eventId,@Nullable final Consumer<ValueOut> consumer){
  writeAsyncMetaData(Time.currentTimeMillis());
  hub.outWire().writeDocument(false,wireOut -> {
    final ValueOut valueOut=wireOut.writeEventName(eventId);
    if (consumer == null)     valueOut.marshallable(WriteMarshallable.EMPTY);
 else     consumer.accept(valueOut);
  }
);
  hub.writeSocket(hub.outWire());
}"
55402,"protected boolean proxyReturnBooleanWithSequence(@NotNull final E eventId,@NotNull final Collection sequence){
  final long startTime=System.currentTimeMillis();
  final long tid=sendEvent(startTime,eventId,out -> sequence.forEach(out::object));
  return readBoolean(tid,startTime);
}","protected boolean proxyReturnBooleanWithSequence(@NotNull final E eventId,@NotNull final Collection sequence){
  final long startTime=Time.currentTimeMillis();
  final long tid=sendEvent(startTime,eventId,out -> sequence.forEach(out::object));
  return readBoolean(tid,startTime);
}"
55403,"public <T>T proxyReturnWireConsumer(@NotNull final WireKey eventId,@NotNull final Function<ValueIn,T> consumer){
  final long startTime=System.currentTimeMillis();
  long tid=sendEvent(startTime,eventId,null);
  return readWire(tid,startTime,CoreFields.reply,consumer);
}","public <T>T proxyReturnWireConsumer(@NotNull final WireKey eventId,@NotNull final Function<ValueIn,T> consumer){
  final long startTime=Time.currentTimeMillis();
  long tid=sendEvent(startTime,eventId,null);
  return readWire(tid,startTime,CoreFields.reply,consumer);
}"
55404,"@SuppressWarnings(""String_Node_Str"") protected boolean proxyReturnBoolean(@NotNull final WireKey eventId){
  final long startTime=System.currentTimeMillis();
  final long tid=sendEvent(startTime,eventId,null);
  return readBoolean(tid,startTime);
}","@SuppressWarnings(""String_Node_Str"") protected boolean proxyReturnBoolean(@NotNull final WireKey eventId){
  final long startTime=Time.currentTimeMillis();
  final long tid=sendEvent(startTime,eventId,null);
  return readBoolean(tid,startTime);
}"
55405,"/** 
 * blocks until there is a conneciton
 */
public void checkConnection(){
  long start=System.currentTimeMillis();
  while (clientChannel == null) {
    if (tcpSocketConsumer.isShutdown())     throw new IORuntimeException(""String_Node_Str"" + remoteAddress);
    if (start + timeoutMs > System.currentTimeMillis())     Jvm.pause(100);
 else     throw new IORuntimeException(""String_Node_Str"" + remoteAddress);
  }
}","/** 
 * blocks until there is a conneciton
 */
public void checkConnection(){
  long start=Time.currentTimeMillis();
  while (clientChannel == null) {
    if (tcpSocketConsumer.isShutdown())     throw new IORuntimeException(""String_Node_Str"" + remoteAddress);
    if (start + timeoutMs > Time.currentTimeMillis())     Jvm.pause(100);
 else     throw new IORuntimeException(""String_Node_Str"" + remoteAddress);
  }
}"
55406,"/** 
 * sends a heartbeat from the client to the server and logs the round trip time
 */
private void sendHeartbeat(){
  long l=System.nanoTime();
  subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this,null){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(heartbeat).int64(System.currentTimeMillis());
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      long roundTipTimeMicros=NANOSECONDS.toMicros(System.nanoTime() - l);
      if (LOG.isDebugEnabled())       LOG.debug(String.format(""String_Node_Str"",description,TCPRegistry.lookup(description),roundTipTimeMicros));
      inWire.clear();
    }
  }
);
}","/** 
 * sends a heartbeat from the client to the server and logs the round trip time
 */
private void sendHeartbeat(){
  long l=System.nanoTime();
  subscribe(new AbstractAsyncTemporarySubscription(TcpChannelHub.this,null){
    @Override public void onSubscribe(    WireOut wireOut){
      wireOut.writeEventName(heartbeat).int64(Time.currentTimeMillis());
    }
    @Override public void onConsumer(    @NotNull WireIn inWire){
      long roundTipTimeMicros=NANOSECONDS.toMicros(System.nanoTime() - l);
      if (LOG.isDebugEnabled())       LOG.debug(String.format(""String_Node_Str"",description,TCPRegistry.lookup(description),roundTipTimeMicros));
      inWire.clear();
    }
  }
);
}"
55407,"/** 
 * blocks this thread until a response is received from the socket
 * @param timeoutTimeMs the amount of time to wait before a time out exceptions
 * @param tid           the {@code tid} of the message that we are waiting for
 * @throws InterruptedException
 */
private Wire syncBlockingReadSocket(final long timeoutTimeMs,long tid) throws InterruptedException, TimeoutException {
  long start=System.currentTimeMillis();
  final Wire wire=syncInWireThreadLocal.get();
  wire.clear();
  Bytes<?> bytes=wire.bytes();
  ((ByteBuffer)bytes.underlyingObject()).clear();
synchronized (bytes) {
    map.put(tid,bytes);
    bytes.wait(timeoutTimeMs);
  }
  logToStandardOutMessageReceived(wire);
  if (System.currentTimeMillis() - start >= timeoutTimeMs) {
    throw new TimeoutException(""String_Node_Str"" + timeoutTimeMs);
  }
  return wire;
}","/** 
 * blocks this thread until a response is received from the socket
 * @param timeoutTimeMs the amount of time to wait before a time out exceptions
 * @param tid           the {@code tid} of the message that we are waiting for
 * @throws InterruptedException
 */
private Wire syncBlockingReadSocket(final long timeoutTimeMs,long tid) throws InterruptedException, TimeoutException {
  long start=Time.currentTimeMillis();
  final Wire wire=syncInWireThreadLocal.get();
  wire.clear();
  Bytes<?> bytes=wire.bytes();
  ((ByteBuffer)bytes.underlyingObject()).clear();
synchronized (bytes) {
    map.put(tid,bytes);
    bytes.wait(timeoutTimeMs);
  }
  logToStandardOutMessageReceived(wire);
  if (Time.currentTimeMillis() - start >= timeoutTimeMs) {
    throw new TimeoutException(""String_Node_Str"" + timeoutTimeMs);
  }
  return wire;
}"
55408,"/** 
 * gets called periodically to monitor the heartbeat
 * @return true, if processing was performed
 * @throws InvalidEventHandlerException
 */
@Override public boolean action() throws InvalidEventHandlerException {
  if (clientChannel == null)   throw new InvalidEventHandlerException();
  long currentTime=System.currentTimeMillis();
  long millisecondsSinceLastMessageReceived=currentTime - lastTimeMessageReceived;
  long millisecondsSinceLastHeatbeatSend=currentTime - lastheartbeatSentTime;
  if (millisecondsSinceLastMessageReceived >= HEATBEAT_PING_PERIOD && millisecondsSinceLastHeatbeatSend >= HEATBEAT_PING_PERIOD) {
    lastheartbeatSentTime=System.currentTimeMillis();
    sendHeartbeat();
  }
  long x=millisecondsSinceLastMessageReceived - HEATBEAT_TIMEOUT_PERIOD;
  if (x > 0) {
    LOG.warn(""String_Node_Str"");
    disconnect();
    throw new InvalidEventHandlerException();
  }
  return true;
}","/** 
 * gets called periodically to monitor the heartbeat
 * @return true, if processing was performed
 * @throws InvalidEventHandlerException
 */
@Override public boolean action() throws InvalidEventHandlerException {
  if (clientChannel == null)   throw new InvalidEventHandlerException();
  long currentTime=Time.currentTimeMillis();
  long millisecondsSinceLastMessageReceived=currentTime - lastTimeMessageReceived;
  long millisecondsSinceLastHeatbeatSend=currentTime - lastheartbeatSentTime;
  if (millisecondsSinceLastMessageReceived >= HEATBEAT_PING_PERIOD && millisecondsSinceLastHeatbeatSend >= HEATBEAT_PING_PERIOD) {
    lastheartbeatSentTime=Time.currentTimeMillis();
    sendHeartbeat();
  }
  long x=millisecondsSinceLastMessageReceived - HEATBEAT_TIMEOUT_PERIOD;
  if (x > 0) {
    LOG.warn(""String_Node_Str"");
    disconnect();
    throw new InvalidEventHandlerException();
  }
  return true;
}"
55409,"@Override public void onSubscribe(WireOut wireOut){
  wireOut.writeEventName(heartbeat).int64(System.currentTimeMillis());
}","@Override public void onSubscribe(WireOut wireOut){
  wireOut.writeEventName(heartbeat).int64(Time.currentTimeMillis());
}"
55410,"private void onMessageReceived(){
  lastTimeMessageReceived=System.currentTimeMillis();
}","private void onMessageReceived(){
  lastTimeMessageReceived=Time.currentTimeMillis();
}"
55411,"private void create(byte identifier,String remoteHostname) throws IOException {
  YamlLogging.clientReads=true;
  YamlLogging.clientWrites=true;
  WireType wireType=WireType.TEXT;
  System.out.println(""String_Node_Str"" + identifier);
  System.out.println(""String_Node_Str"" + remoteHostname);
  final VanillaAssetTree tree=new VanillaAssetTree(identifier);
  newCluster(identifier,tree,remoteHostname);
  tree.root().addLeafRule(EngineReplication.class,""String_Node_Str"",CMap2EngineReplicator::new);
  tree.root().addView(SessionProvider.class,new VanillaSessionProvider());
  tree.root().addWrappingRule(Replication.class,""String_Node_Str"",VanillaReplication::new,MapView.class);
  tree.root().addWrappingRule(MapView.class,""String_Node_Str"",VanillaMapView::new,AuthenticatedKeyValueStore.class);
  tree.root().addWrappingRule(TopicPublisher.class,""String_Node_Str"",VanillaTopicPublisher::new,MapView.class);
  tree.root().addWrappingRule(Publisher.class,""String_Node_Str"",VanillaReference::new,MapView.class);
  tree.root().addLeafRule(ObjectKVSSubscription.class,""String_Node_Str"",VanillaKVSSubscription::new);
  ThreadGroup threadGroup=new ThreadGroup(""String_Node_Str"");
  tree.root().addView(ThreadGroup.class,threadGroup);
  tree.root().addView(EventLoop.class,new EventGroup(false));
  Asset asset=tree.root().acquireAsset(""String_Node_Str"");
  asset.addView(AuthenticatedKeyValueStore.class,new ChronicleMapKeyValueStore<>(requestContext(""String_Node_Str""),asset));
  tree.root().addLeafRule(ObjectKVSSubscription.class,""String_Node_Str"",VanillaKVSSubscription::new);
  ReplicationClient.closeables.add(tree);
  ServerEndpoint serverEndpoint=new ServerEndpoint(""String_Node_Str"" + (5700 + identifier),tree,wireType);
  ReplicationClient.closeables.add(serverEndpoint);
}","private void create(byte identifier,String remoteHostname) throws IOException {
  YamlLogging.clientReads=true;
  YamlLogging.clientWrites=true;
  WireType wireType=WireType.TEXT;
  System.out.println(""String_Node_Str"" + identifier);
  System.out.println(""String_Node_Str"" + remoteHostname);
  final VanillaAssetTree tree=new VanillaAssetTree(identifier);
  newCluster(identifier,tree,remoteHostname);
  tree.root().addLeafRule(EngineReplication.class,""String_Node_Str"",CMap2EngineReplicator::new);
  tree.root().addView(SessionProvider.class,new VanillaSessionProvider());
  tree.root().addWrappingRule(Replication.class,""String_Node_Str"",VanillaReplication::new,MapView.class);
  tree.root().addWrappingRule(MapView.class,""String_Node_Str"",VanillaMapView::new,AuthenticatedKeyValueStore.class);
  tree.root().addWrappingRule(TopicPublisher.class,""String_Node_Str"",VanillaTopicPublisher::new,MapView.class);
  tree.root().addWrappingRule(Publisher.class,""String_Node_Str"",VanillaReference::new,MapView.class);
  tree.root().addLeafRule(ObjectKVSSubscription.class,""String_Node_Str"",VanillaKVSSubscription::new);
  ThreadGroup threadGroup=new ThreadGroup(""String_Node_Str"");
  tree.root().addView(ThreadGroup.class,threadGroup);
  tree.root().addView(EventLoop.class,new EventGroup(false));
  Asset asset=tree.root().acquireAsset(""String_Node_Str"");
  asset.addView(AuthenticatedKeyValueStore.class,new ChronicleMapKeyValueStore<>(requestContext(""String_Node_Str""),asset));
  tree.root().addLeafRule(ObjectKVSSubscription.class,""String_Node_Str"",VanillaKVSSubscription::new);
  ReplicationClientTest.closeables.add(tree);
  ServerEndpoint serverEndpoint=new ServerEndpoint(""String_Node_Str"" + (5700 + identifier),tree,wireType);
  ReplicationClientTest.closeables.add(serverEndpoint);
}"
55412,"@Test public void testDoubleValues() throws IOException, InterruptedException {
  supplyMap(Double.class,Double.class,mapProxy -> {
    mapProxy.put(1.0,1.0);
    mapProxy.put(2.0,2.0);
    assertEquals(1.0,mapProxy.get(1.0),0);
    assertEquals(2.0,mapProxy.get(2.0),0);
    assertEquals(2,mapProxy.size());
  }
);
}","@Test public void testDoubleValues() throws IOException, InterruptedException {
  supplyMap(Double.class,Double.class,mapProxy -> {
    mapProxy.put(1.0,1.0);
    mapProxy.put(2.0,2.0);
    mapProxy.put(3.0,0.0);
    assertEquals(1.0,mapProxy.get(1.0),0);
    assertEquals(2.0,mapProxy.get(2.0),0);
    assertEquals(0.0,mapProxy.get(3.0),0);
    assertEquals(3,mapProxy.size());
  }
);
}"
55413,"@Test public void testFloatValues() throws IOException, InterruptedException {
  supplyMap(Float.class,Float.class,mapProxy -> {
    mapProxy.put(1.0f,1.0f);
    mapProxy.put(2.0f,2.0f);
    assertEquals(1.0f,mapProxy.get(1.0f),0);
    assertEquals(2.0f,mapProxy.get(2.0f),0);
    assertEquals(2,mapProxy.size());
  }
);
}","@Test public void testFloatValues() throws IOException, InterruptedException {
  supplyMap(Float.class,Float.class,mapProxy -> {
    mapProxy.put(1.0f,1.0f);
    mapProxy.put(2.0f,2.0f);
    mapProxy.put(3.0f,0.0f);
    assertEquals(1.0f,mapProxy.get(1.0f),0);
    assertEquals(2.0f,mapProxy.get(2.0f),0);
    assertEquals(0.0f,mapProxy.get(3.0f),0);
    assertEquals(3,mapProxy.size());
  }
);
}"
55414,"/** 
 * write and exceptions and rolls back if no data was written
 */
void writeData(@NotNull Consumer<WireOut> c){
  outWire.writeDocument(false,out -> {
    final long position=outWire.bytes().writePosition();
    try {
      c.accept(outWire);
    }
 catch (    Exception exception) {
      LOG.error(""String_Node_Str"",exception);
      outWire.bytes().writePosition(position);
      outWire.writeEventName(() -> ""String_Node_Str"").throwable(exception);
    }
    if (position == outWire.bytes().writePosition()) {
      outWire.writeEventName(reply).marshallable(EMPTY);
    }
  }
);
  if (YamlLogging.showServerWrites)   try {
    System.out.println(""String_Node_Str"" + Wires.fromSizePrefixedBlobs(outWire.bytes(),0,outWire.bytes().writePosition()));
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + outWire.bytes().toDebugString());
  }
}","/** 
 * write and exceptions and rolls back if no data was written
 */
void writeData(Bytes inBytes,@NotNull Consumer<WireOut> c){
  outWire.writeDocument(false,out -> {
    final long readPosition=inBytes.readPosition();
    final long position=outWire.bytes().writePosition();
    try {
      c.accept(outWire);
    }
 catch (    Throwable t) {
      inBytes.readPosition(readPosition);
      LOG.info(""String_Node_Str"" + inBytes.toDebugString(),""String_Node_Str"" + c,t);
      outWire.bytes().writePosition(position);
      outWire.writeEventName(() -> ""String_Node_Str"").throwable(t);
    }
    if (position == outWire.bytes().writePosition()) {
      outWire.writeEventName(reply).marshallable(EMPTY);
    }
  }
);
  if (YamlLogging.showServerWrites)   try {
    System.out.println(""String_Node_Str"" + Wires.fromSizePrefixedBlobs(outWire.bytes(),0,outWire.bytes().writePosition()));
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + outWire.bytes().toDebugString());
  }
}"
55415,"HostPort(final String host,final int port){
  this.host=host;
  this.port=port;
}","HostPort(@NotNull final String host,final int port){
  this.host=host;
  this.port=port;
}"
55416,"public ChronicleMapKeyValueStore(@NotNull RequestContext context,Asset asset){
  String basePath=context.basePath();
  double averageValueSize=context.getAverageValueSize();
  long maxEntries=context.getEntries();
  this.asset=asset;
  this.assetFullName=asset.fullName();
  this.subscriptions=asset.acquireView(ObjectKVSSubscription.class,context);
  this.subscriptions.setKvStore(this);
  this.eventLoop=asset.findOrCreateView(EventLoop.class);
  eventLoop.start();
  PublishingOperations publishingOperations=new PublishingOperations();
  ChronicleMapBuilder<K,V> builder=ChronicleMapBuilder.of(context.keyType(),context.valueType());
  HostIdentifier hostIdentifier=null;
  EngineReplication engineReplicator1=null;
  try {
    engineReplicator1=asset.acquireView(EngineReplication.class,RequestContext.requestContext());
    final EngineReplicationLangBytesConsumer langBytesConsumer=asset.acquireView(EngineReplicationLangBytesConsumer.class,null);
    hostIdentifier=asset.acquireView(HostIdentifier.class,RequestContext.requestContext());
    builder.replication(builder().engineReplication(langBytesConsumer).createWithId(hostIdentifier.hostId()));
  }
 catch (  AssetNotFoundException anfe) {
    if (LOGGER.isDebugEnabled())     LOGGER.debug(""String_Node_Str"" + anfe.getMessage());
  }
  this.engineReplicator=engineReplicator1;
  builder.eventListener(publishingOperations);
  if (context.putReturnsNull() != Boolean.FALSE)   builder.putReturnsNull(true);
  if (context.removeReturnsNull() != Boolean.FALSE)   builder.removeReturnsNull(true);
  if (averageValueSize > 0)   builder.averageValueSize(averageValueSize);
  if (maxEntries > 0)   builder.entries(maxEntries);
  if (basePath == null)   builder.create();
 else {
    String pathname=basePath + ""String_Node_Str"" + context.name();
    new File(basePath).mkdirs();
    try {
      builder.createPersistedTo(new File(pathname));
    }
 catch (    IOException e) {
      IORuntimeException iore=new IORuntimeException(""String_Node_Str"" + pathname);
      iore.initCause(e);
      throw iore;
    }
  }
  chronicleMap=builder.create();
  if (hostIdentifier != null) {
    Clusters clusters=asset.findView(Clusters.class);
    Map<String,HostDetails> hdMap=clusters.get(""String_Node_Str"");
    int hostId=hostIdentifier.hostId();
    for (    HostDetails hostDetails : hdMap.values()) {
      if (hostDetails.hostId == hostId)       continue;
      TcpChannelHub tcpChannelHub=hostDetails.acquireTcpChannelHub();
      ReplicationHub replicationHub=new ReplicationHub(context,tcpChannelHub,eventLoop,isClosed);
      try {
        replicationHub.bootstrap(engineReplicator1,hostId);
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
}","public ChronicleMapKeyValueStore(@NotNull RequestContext context,Asset asset){
  String basePath=context.basePath();
  double averageValueSize=context.getAverageValueSize();
  long maxEntries=context.getEntries();
  this.asset=asset;
  this.assetFullName=asset.fullName();
  this.subscriptions=asset.acquireView(ObjectKVSSubscription.class,context);
  this.subscriptions.setKvStore(this);
  this.eventLoop=asset.findOrCreateView(EventLoop.class);
  eventLoop.start();
  PublishingOperations publishingOperations=new PublishingOperations();
  ChronicleMapBuilder<K,V> builder=ChronicleMapBuilder.of(context.keyType(),context.valueType());
  HostIdentifier hostIdentifier=null;
  EngineReplication engineReplicator1=null;
  try {
    engineReplicator1=asset.acquireView(EngineReplication.class,RequestContext.requestContext());
    final EngineReplicationLangBytesConsumer langBytesConsumer=asset.acquireView(EngineReplicationLangBytesConsumer.class,null);
    hostIdentifier=asset.findOrCreateView(HostIdentifier.class);
    builder.replication(builder().engineReplication(langBytesConsumer).createWithId(hostIdentifier.hostId()));
  }
 catch (  AssetNotFoundException anfe) {
    if (LOGGER.isDebugEnabled())     LOGGER.debug(""String_Node_Str"" + anfe.getMessage());
  }
  this.engineReplicator=engineReplicator1;
  builder.eventListener(publishingOperations);
  if (context.putReturnsNull() != Boolean.FALSE)   builder.putReturnsNull(true);
  if (context.removeReturnsNull() != Boolean.FALSE)   builder.removeReturnsNull(true);
  if (averageValueSize > 0)   builder.averageValueSize(averageValueSize);
  if (maxEntries > 0)   builder.entries(maxEntries);
  if (basePath == null)   builder.create();
 else {
    String pathname=basePath + ""String_Node_Str"" + context.name();
    new File(basePath).mkdirs();
    try {
      builder.createPersistedTo(new File(pathname));
    }
 catch (    IOException e) {
      IORuntimeException iore=new IORuntimeException(""String_Node_Str"" + pathname);
      iore.initCause(e);
      throw iore;
    }
  }
  chronicleMap=builder.create();
  if (hostIdentifier != null) {
    Clusters clusters=asset.findView(Clusters.class);
    Map<String,HostDetails> hdMap=clusters.get(""String_Node_Str"");
    int localIdentifer=hostIdentifier.hostId();
    for (    HostDetails hostDetails : hdMap.values()) {
      if (hostDetails.hostId <= localIdentifer)       continue;
      TcpChannelHub tcpChannelHub=hostDetails.acquireTcpChannelHub();
      ReplicationHub replicationHub=new ReplicationHub(context,tcpChannelHub,eventLoop,isClosed);
      try {
        replicationHub.bootstrap(engineReplicator1,localIdentifer);
      }
 catch (      InterruptedException e) {
        throw new AssertionError(e);
      }
    }
  }
}"
55417,"private static String toUri(final RequestContext context){
  final StringBuilder uri=new StringBuilder(""String_Node_Str"" + context.name() + ""String_Node_Str""+ ""String_Node_Str"");
  if (context.keyType() != String.class)   uri.append(""String_Node_Str"").append(context.keyType().getName());
  if (context.valueType() != String.class)   uri.append(""String_Node_Str"").append(context.valueType().getName());
  return uri.toString();
}","private static String toUri(final RequestContext context){
  final StringBuilder uri=new StringBuilder(context.fullName() + ""String_Node_Str"" + ""String_Node_Str"");
  if (context.keyType() != String.class)   uri.append(""String_Node_Str"").append(context.keyType().getName());
  if (context.valueType() != String.class)   uri.append(""String_Node_Str"").append(context.valueType().getName());
  return uri.toString();
}"
55418,"public void bootstrap(EngineReplication replication,int localIdentifer) throws InterruptedException {
  final byte remoteIdentifier=proxyReturnByte(identifierReply,identifier);
  final ModificationIterator mi=replication.acquireModificationIterator(remoteIdentifier);
  final long lastModificationTime=replication.lastModificationTime(remoteIdentifier);
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.lastUpdatedTime(lastModificationTime);
  bootstrap.identifier((byte)localIdentifer);
  final AtomicLong tid=new AtomicLong();
  final Function<ValueIn,Bootstrap> typedMarshallable=ValueIn::typedMarshallable;
  final Consumer<ValueOut> valueOutConsumer=o -> o.typedMarshallable(bootstrap);
  final Bootstrap b=(Bootstrap)proxyReturnWireConsumerInOut(bootstap,bootstrapReply,valueOutConsumer,typedMarshallable,tid::set);
  try {
    mi.setModificationNotifier(() -> {
      eventLoop.unpause();
    }
);
    AtomicLong tid0=new AtomicLong();
    this.hub.outBytesLock().lock();
    try {
      tid0.set(writeMetaDataStartTime(System.currentTimeMillis()));
      mi.forEach(e -> this.hub.outWire().writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
      this.hub.asyncReadSocket(tid.get(),d -> {
        d.readDocument(null,w -> replication.applyReplication(w.read(replicactionReply).typedMarshallable()));
      }
);
      this.hub.writeSocket(this.hub.outWire());
    }
  finally {
      this.hub.outBytesLock().unlock();
    }
    mi.dirtyEntries(b.lastUpdatedTime());
    eventLoop.addHandler(new EventHandler(){
      @Override public boolean runOnce(){
        TcpChannelHub hub=ReplicationHub.this.hub;
        hub.outBytesLock().lock();
        try {
          ReplicationHub.this.writeMetaDataForKnownTID(tid0.get());
          mi.forEach(e -> hub.outWire().writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
          hub.writeSocket(hub.outWire());
        }
 catch (        InterruptedException e) {
          throw Jvm.rethrow(e);
        }
 finally {
          hub.outBytesLock().unlock();
        }
        return !isClosed.get();
      }
      @Override public HandlerPriority priority(){
        return HandlerPriority.MEDIUM;
      }
    }
);
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
  }
}","public void bootstrap(EngineReplication replication,int localIdentifer) throws InterruptedException {
  final byte remoteIdentifier=proxyReturnByte(identifierReply,identifier);
  final ModificationIterator mi=replication.acquireModificationIterator(remoteIdentifier);
  final long lastModificationTime=replication.lastModificationTime(remoteIdentifier);
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.lastUpdatedTime(lastModificationTime);
  bootstrap.identifier((byte)localIdentifer);
  final Function<ValueIn,Bootstrap> typedMarshallable=ValueIn::typedMarshallable;
  final Consumer<ValueOut> valueOutConsumer=o -> o.typedMarshallable(bootstrap);
  final Bootstrap b=(Bootstrap)proxyReturnWireConsumerInOut(bootstap,bootstrapReply,valueOutConsumer,typedMarshallable);
  try {
    startSubscription(replication,localIdentifer);
    mi.setModificationNotifier(() -> {
      eventLoop.unpause();
    }
);
    eventLoop.addHandler(new EventHandler(){
      @Override public boolean runOnce(){
        TcpChannelHub hub=ReplicationHub.this.hub;
        hub.outBytesLock().lock();
        try {
          mi.forEach(e -> {
            sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)(v -> v.typedMarshallable(e)));
          }
);
        }
 catch (        InterruptedException e) {
          throw Jvm.rethrow(e);
        }
 finally {
          hub.outBytesLock().unlock();
        }
        return !isClosed.get();
      }
      @Override public HandlerPriority priority(){
        return HandlerPriority.MEDIUM;
      }
    }
);
    mi.dirtyEntries(b.lastUpdatedTime());
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
  }
}"
55419,"@Override public boolean runOnce(){
  TcpChannelHub hub=ReplicationHub.this.hub;
  hub.outBytesLock().lock();
  try {
    ReplicationHub.this.writeMetaDataForKnownTID(tid0.get());
    mi.forEach(e -> hub.outWire().writeDocument(false,wireOut -> wireOut.writeEventName(replicationEvent).typedMarshallable(e)));
    hub.writeSocket(hub.outWire());
  }
 catch (  InterruptedException e) {
    throw Jvm.rethrow(e);
  }
 finally {
    hub.outBytesLock().unlock();
  }
  return !isClosed.get();
}","@Override public boolean runOnce(){
  TcpChannelHub hub=ReplicationHub.this.hub;
  hub.outBytesLock().lock();
  try {
    mi.forEach(e -> {
      sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)(v -> v.typedMarshallable(e)));
    }
);
  }
 catch (  InterruptedException e) {
    throw Jvm.rethrow(e);
  }
 finally {
    hub.outBytesLock().unlock();
  }
  return !isClosed.get();
}"
55420,"@Nullable public AcceptorEventHandler start(int port,@NotNull final AssetTree asset) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(port,() -> new EngineWireHandler(WireType.wire,asset),VanillaSessionDetails::new);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}","@Nullable public AcceptorEventHandler start(int port,@NotNull final AssetTree asset) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(port,() -> new EngineWireHandler(WireType.wire,asset,isClosed),VanillaSessionDetails::new);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}"
55421,"@Override public void close(){
  stop();
  closeQuietly(eg);
  eg=null;
  closeQuietly(eah);
  eah=null;
}","@Override public void close(){
  isClosed.set(true);
  stop();
  closeQuietly(eg);
  eg=null;
  closeQuietly(eah);
  eah=null;
}"
55422,"@Override protected void process(@NotNull final Wire in,@NotNull final Wire out,@NotNull final SessionDetailsProvider sessionDetails) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn wire) -> {
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + wire.bytes().toHexString());
      sessionProvider.set(sessionDetails);
      if (isSystemMessage) {
        sessionDetails.setUserId(wire.read(() -> ""String_Node_Str"").text());
        return;
      }
      if (wireAdapter != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(KeyValueStore)((MapView)view).underlying(),tid,wireAdapter,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesCollection.class) {
          valuesHandler.process(in,out,(ValuesCollection)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (viewType == ObjectKVSSubscription.class) {
          subscriptionHandler.process(in,requestContext,publisher,assetTree,tid,outWire,(KVSSubscription)view);
          return;
        }
        if (viewType == TopicPublisher.class) {
          topicPublisherHandler.process(in,publisher,tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (viewType == Publisher.class) {
          publisherHandler.process(in,publisher,tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (viewType == Replication.class) {
          hostIdentifier=asset.acquireView(HostIdentifier.class,RequestContext.requestContext());
          replicationHandler.process(in,publisher,tid,outWire,hostIdentifier,(Replication)view);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"") && queueWireHandler != null) {
        queueWireHandler.process(in,out);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
 finally {
      sessionProvider.remove();
    }
  }
);
}","@Override protected void process(@NotNull final Wire in,@NotNull final Wire out,@NotNull final SessionDetailsProvider sessionDetails) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn wire) -> {
    try {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"" + wire.bytes().toHexString());
      sessionProvider.set(sessionDetails);
      if (isSystemMessage) {
        sessionDetails.setUserId(wire.read(() -> ""String_Node_Str"").text());
        return;
      }
      if (wireAdapter != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(KeyValueStore)((MapView)view).underlying(),tid,wireAdapter,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,wireAdapter.entryToWire(),wireAdapter.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesCollection.class) {
          valuesHandler.process(in,out,(ValuesCollection)view,cspText,wireAdapter.keyToWire(),wireAdapter.wireToKey(),ArrayList::new,tid);
          return;
        }
        if (viewType == ObjectKVSSubscription.class) {
          subscriptionHandler.process(in,requestContext,publisher,assetTree,tid,outWire,(KVSSubscription)view);
          return;
        }
        if (viewType == TopicPublisher.class) {
          topicPublisherHandler.process(in,publisher,tid,outWire,(TopicPublisher)view,wireAdapter);
          return;
        }
        if (viewType == Publisher.class) {
          publisherHandler.process(in,publisher,tid,(Publisher)view,outWire,wireAdapter);
          return;
        }
        if (viewType == Replication.class) {
          replicationHandler.process(in,publisher,tid,outWire,hostIdentifier,(Replication)view,isClosed,eventLoop);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"") && queueWireHandler != null) {
        queueWireHandler.process(in,out);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
 finally {
      sessionProvider.remove();
    }
  }
);
}"
55423,"public EngineWireHandler(@NotNull final Function<Bytes,Wire> byteToWire,@NotNull final AssetTree assetTree){
  super(byteToWire);
  this.sessionProvider=assetTree.root().getView(SessionProvider.class);
  this.assetTree=assetTree;
  this.mapWireHandler=new MapWireHandler<>();
  this.queueWireHandler=null;
  this.metaDataConsumer=wireInConsumer();
  this.keySetHandler=new CollectionWireHandlerProcessor<>();
  this.entrySetHandler=new CollectionWireHandlerProcessor<>();
  this.valuesHandler=new CollectionWireHandlerProcessor<>();
  this.subscriptionHandler=new SubscriptionHandlerProcessor();
  this.topicPublisherHandler=new TopicPublisherHandler();
  this.publisherHandler=new PublisherHandler();
  this.replicationHandler=new ReplicationHandler();
}","public EngineWireHandler(@NotNull final Function<Bytes,Wire> byteToWire,@NotNull final AssetTree assetTree,@NotNull final AtomicBoolean isClosed){
  super(byteToWire);
  this.sessionProvider=assetTree.root().getView(SessionProvider.class);
  this.eventLoop=assetTree.root().findOrCreateView(EventLoop.class);
  this.hostIdentifier=assetTree.root().findOrCreateView(HostIdentifier.class);
  this.assetTree=assetTree;
  this.mapWireHandler=new MapWireHandler<>();
  this.queueWireHandler=null;
  this.metaDataConsumer=wireInConsumer();
  this.keySetHandler=new CollectionWireHandlerProcessor<>();
  this.entrySetHandler=new CollectionWireHandlerProcessor<>();
  this.valuesHandler=new CollectionWireHandlerProcessor<>();
  this.subscriptionHandler=new SubscriptionHandlerProcessor();
  this.topicPublisherHandler=new TopicPublisherHandler();
  this.publisherHandler=new PublisherHandler();
  this.replicationHandler=new ReplicationHandler();
  this.isClosed=isClosed;
  eventLoop.start();
}"
55424,"@NotNull private Consumer<WireIn> wireInConsumer(){
  return (wire) -> {
    isSystemMessage=wire.bytes().readRemaining() == 0;
    if (isSystemMessage) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"");
      return;
    }
    try {
      readCsp(wire);
      readTid(wire);
      if (hasCspChanged(cspText)) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + wire.bytes().toHexString());
        requestContext=RequestContext.requestContext(cspText);
        viewType=requestContext.viewType();
        asset=this.assetTree.acquireAsset(viewType,requestContext);
        view=asset.acquireView(requestContext);
        mapView=this.assetTree.acquireAsset(MapView.class,requestContext);
        requestContext.keyType();
        if (viewType == MapView.class || viewType == EntrySetView.class || viewType == ValuesCollection.class || viewType == KeySetView.class || viewType == ObjectKVSSubscription.class || viewType == ObjectKVSSubscription.class || viewType == TopicPublisher.class || viewType == Publisher.class || viewType == Replication.class) {
          final Class type=requestContext.type() == null ? String.class : requestContext.keyType();
          final Class type2=requestContext.type2() == null ? String.class : requestContext.valueType();
          wireAdapter=new GenericWireAdapter(type,type2);
        }
 else         throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      rethrow(e);
    }
  }
;
}","@NotNull private Consumer<WireIn> wireInConsumer(){
  return (wire) -> {
    isSystemMessage=wire.bytes().readRemaining() == 0;
    if (isSystemMessage) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"");
      return;
    }
    try {
      readCsp(wire);
      readTid(wire);
      if (hasCspChanged(cspText)) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"" + wire.bytes().toHexString());
        requestContext=RequestContext.requestContext(cspText);
        viewType=requestContext.viewType();
        asset=this.assetTree.acquireAsset(viewType,requestContext);
        view=asset.acquireView(requestContext);
        requestContext.keyType();
        if (viewType == MapView.class || viewType == EntrySetView.class || viewType == ValuesCollection.class || viewType == KeySetView.class || viewType == ObjectKVSSubscription.class || viewType == ObjectKVSSubscription.class || viewType == TopicPublisher.class || viewType == Publisher.class || viewType == Replication.class) {
          final Class type=requestContext.type() == null ? String.class : requestContext.keyType();
          final Class type2=requestContext.type2() == null ? String.class : requestContext.valueType();
          wireAdapter=new GenericWireAdapter(type,type2);
        }
 else         throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
      rethrow(e);
    }
  }
;
}"
55425,"@Override public void readMarshallable(WireIn wire) throws IllegalStateException {
  StringBuilder clusterName=new StringBuilder();
  StringBuilder hostDescription=new StringBuilder();
  while (wire.hasMore()) {
    wire.readEventName(clusterName).marshallable(host -> {
      Map<String,HostDetails> hdMap=clusterMap.computeIfAbsent(clusterName.toString(),k -> new ConcurrentSkipListMap<>());
      host.readEventName(hostDescription).marshallable(details -> {
        HostDetails hd=new HostDetails();
        hd.readMarshallable(details);
        hdMap.put(hostDescription.toString(),hd);
      }
);
    }
);
  }
}","@Override public void readMarshallable(WireIn wire) throws IllegalStateException {
  StringBuilder clusterName=new StringBuilder();
  StringBuilder hostDescription=new StringBuilder();
  while (wire.hasMore()) {
    wire.readEventName(clusterName).marshallable(host -> {
      Map<String,HostDetails> hdMap=clusterMap.computeIfAbsent(clusterName.toString(),k -> new ConcurrentSkipListMap<>());
      while (wire.hasMore()) {
        host.readEventName(hostDescription).marshallable(details -> {
          HostDetails hd=new HostDetails();
          hd.readMarshallable(details);
          hdMap.put(hostDescription.toString(),hd);
        }
);
      }
    }
);
  }
}"
55426,"public void bootstrap(EngineReplication replication,int localIdentifer) throws InterruptedException {
  final byte remoteIdentifier=proxyReturnByte(identifierReply,identifier);
  final ModificationIterator mi=replication.acquireModificationIterator(remoteIdentifier);
  final long lastModificationTime=replication.lastModificationTime(remoteIdentifier);
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.lastUpdatedTime(lastModificationTime);
  bootstrap.identifier((byte)localIdentifer);
  final Function<ValueIn,Bootstrap> typedMarshallable=ValueIn::typedMarshallable;
  final Consumer<ValueOut> valueOutConsumer=o -> o.typedMarshallable(bootstrap);
  final Bootstrap b=(Bootstrap)proxyReturnWireConsumerInOut(bootstap,bootstrapReply,valueOutConsumer,typedMarshallable);
  try {
    startSubscription(replication,localIdentifer);
    mi.setModificationNotifier(() -> {
      eventLoop.unpause();
    }
);
    eventLoop.addHandler(new EventHandler(){
      @Override public boolean runOnce(){
        TcpChannelHub hub=ReplicationHub.this.hub;
        hub.outBytesLock().lock();
        try {
          mi.forEach(e -> {
            sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)(v -> v.typedMarshallable(e)));
          }
);
        }
 catch (        InterruptedException e) {
          throw Jvm.rethrow(e);
        }
 finally {
          hub.outBytesLock().unlock();
        }
        return !isClosed.get();
      }
      @Override public HandlerPriority priority(){
        return HandlerPriority.MEDIUM;
      }
    }
);
    mi.dirtyEntries(b.lastUpdatedTime());
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
  }
}","public void bootstrap(EngineReplication replication,int localIdentifer) throws InterruptedException {
  final byte remoteIdentifier=proxyReturnByte(identifierReply,identifier);
  final ModificationIterator mi=replication.acquireModificationIterator(remoteIdentifier);
  final long lastModificationTime=replication.lastModificationTime(remoteIdentifier);
  final Bootstrap bootstrap=new Bootstrap();
  bootstrap.lastUpdatedTime(lastModificationTime);
  bootstrap.identifier((byte)localIdentifer);
  final Function<ValueIn,Bootstrap> typedMarshallable=ValueIn::typedMarshallable;
  final Consumer<ValueOut> valueOutConsumer=o -> o.typedMarshallable(bootstrap);
  final Bootstrap b=(Bootstrap)proxyReturnWireConsumerInOut(bootstap,bootstrapReply,valueOutConsumer,typedMarshallable);
  try {
    subscribe(replication,localIdentifer);
    publish(mi,b);
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
  }
}"
55427,"@Override public boolean runOnce(){
  TcpChannelHub hub=ReplicationHub.this.hub;
  hub.outBytesLock().lock();
  try {
    mi.forEach(e -> {
      sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)(v -> v.typedMarshallable(e)));
    }
);
  }
 catch (  InterruptedException e) {
    throw Jvm.rethrow(e);
  }
 finally {
    hub.outBytesLock().unlock();
  }
  return !isClosed.get();
}","@Override public boolean runOnce(){
  hub.lock(() -> mi.forEach(e -> sendEventAsyncWithoutLock(replicationEvent,(Consumer<ValueOut>)v -> v.typedMarshallable(e))));
  return !isClosed.get();
}"
55428,"@AfterClass public static void after(){
  serverEndpoint1.close();
  serverEndpoint2.close();
  tree1.close();
  tree2.close();
}","@AfterClass public static void after(){
  if (serverEndpoint1 != null)   serverEndpoint1.close();
  if (serverEndpoint2 != null)   serverEndpoint2.close();
  if (tree1 != null)   tree1.close();
  if (tree2 != null)   tree2.close();
}"
55429,"@Override public void registerTopicSubscriber(RequestContext rc,TopicSubscriber<K,V> subscriber){
}","@Override public void registerTopicSubscriber(RequestContext rc,TopicSubscriber<K,V> subscriber){
  final long startTime=System.currentTimeMillis();
  if (hub.outBytesLock().isHeldByCurrentThread())   throw new IllegalStateException(""String_Node_Str"");
  hub.outBytesLock().lock();
  try {
    tid=writeMetaDataStartTime(startTime);
    subscribersToTid.put(subscriber,tid);
    hub.outWire().writeDocument(false,wireOut -> wireOut.writeEventName(registerTopicSubscriber).marshallable(m -> {
      m.write(() -> ""String_Node_Str"").typeLiteral(rc.keyType());
      m.write(() -> ""String_Node_Str"").typeLiteral(rc.valueType());
    }
));
    hub.asyncReadSocket(tid,w -> w.readDocument(null,d -> {
      ValueIn valueIn=d.read(reply);
      valueIn.marshallable(m -> {
        final String topic=m.read(() -> ""String_Node_Str"").text();
        final ReadMarshallable message=m.read(() -> ""String_Node_Str"").typedMarshallable();
        this.onEvent(topic,message,subscriber);
      }
);
    }
));
    hub.writeSocket(hub.outWire());
  }
  finally {
    hub.outBytesLock().unlock();
  }
}"
55430,"private void logToStandardOutMessageSent(@NotNull Wire wire,@NotNull ByteBuffer outBuffer){
  if (!YamlLogging.clientWrites || !Jvm.isDebug())   return;
  Bytes<?> bytes=wire.bytes();
  final long position=bytes.writePosition();
  final long limit=bytes.writeLimit();
  try {
    bytes.writeLimit(outBuffer.limit());
    bytes.writePosition(outBuffer.position());
    if (YamlLogging.clientWrites) {
      try {
        System.out.println(((!YamlLogging.title.isEmpty()) ? ""String_Node_Str"" + YamlLogging.title + ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + YamlLogging.writeMessage+ (YamlLogging.writeMessage.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ((wire instanceof TextWire) ? Wires.fromSizePrefixedBlobs(bytes) : BytesUtil.toHexString(bytes,bytes.writePosition(),bytes.writeRemaining()))+ ""String_Node_Str"");
        YamlLogging.title=""String_Node_Str"";
        YamlLogging.writeMessage=""String_Node_Str"";
      }
 catch (      Exception e) {
        LOG.error(Bytes.toString(bytes),e);
      }
    }
  }
  finally {
    bytes.writeLimit(limit);
    bytes.writePosition(position);
  }
}","private void logToStandardOutMessageSent(@NotNull Wire wire,@NotNull ByteBuffer outBuffer){
  if (!YamlLogging.clientWrites || !Jvm.isDebug())   return;
  Bytes<?> bytes=wire.bytes();
  final long position=bytes.writePosition();
  final long limit=bytes.writeLimit();
  try {
    bytes.writeLimit(outBuffer.limit());
    bytes.writePosition(outBuffer.position());
    if (YamlLogging.clientWrites) {
      try {
        System.out.println(((!YamlLogging.title.isEmpty()) ? ""String_Node_Str"" + YamlLogging.title + ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + YamlLogging.writeMessage+ (YamlLogging.writeMessage.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ((wire instanceof TextWire) ? Wires.fromSizePrefixedBlobs(bytes,bytes.writePosition(),bytes.writeLimit()) : BytesUtil.toHexString(bytes,bytes.writePosition(),bytes.writeRemaining()))+ ""String_Node_Str"");
        YamlLogging.title=""String_Node_Str"";
        YamlLogging.writeMessage=""String_Node_Str"";
      }
 catch (      Exception e) {
        LOG.error(Bytes.toString(bytes),e);
      }
    }
  }
  finally {
    bytes.writeLimit(limit);
    bytes.writePosition(position);
  }
}"
55431,"private void processData(final long tid,final boolean isReady,final int header,final int messageSize,Wire inWire) throws IOException {
  Object o=isReady ? map.remove(tid) : map.get(tid);
  if (o == null) {
    if (omap != null && omap.containsValue(tid)) {
      LOG.warn(""String_Node_Str"" + tid);
      o=omap.get(tid);
    }
 else {
      Jvm.pause(10);
      o=isReady ? map.remove(tid) : map.get(tid);
      if (o != null)       LOG.warn(""String_Node_Str"" + tid);
    }
  }
 else {
    if (omap != null) {
      omap.put(tid,o);
    }
  }
  if (o == null) {
    LOG.info(""String_Node_Str"" + tid);
    return;
  }
  if (o instanceof Consumer) {
    final Consumer<Wire> consumer=(Consumer<Wire>)o;
    blockingRead(inWire,messageSize);
    logToStandardOutMessageReceived(inWire);
    consumer.accept(inWire);
  }
 else {
    final Bytes bytes=(Bytes)o;
synchronized (bytes) {
      bytes.clear();
      final ByteBuffer byteBuffer=(ByteBuffer)bytes.underlyingObject();
      byteBuffer.clear();
      bytes.writeInt(0,header);
      byteBuffer.position(SIZE_OF_SIZE);
      byteBuffer.limit(SIZE_OF_SIZE + messageSize);
      readBuffer(byteBuffer);
      bytes.readLimit(byteBuffer.position());
      bytes.notifyAll();
    }
  }
}","private void processData(final long tid,final boolean isReady,final int header,final int messageSize,Wire inWire) throws IOException {
  long startTime=0;
  Object o;
  for (; ; ) {
    o=isReady ? map.remove(tid) : map.get(tid);
    if (o != null)     break;
    if (startTime == 0)     startTime=System.currentTimeMillis();
    if (System.currentTimeMillis() - startTime > 1000) {
      LOG.error(""String_Node_Str"" + tid);
      blockingRead(inWire,messageSize);
      return;
    }
  }
  if (o instanceof Consumer) {
    final Consumer<Wire> consumer=(Consumer<Wire>)o;
    blockingRead(inWire,messageSize);
    logToStandardOutMessageReceived(inWire);
    consumer.accept(inWire);
  }
 else {
    final Bytes bytes=(Bytes)o;
synchronized (bytes) {
      bytes.clear();
      final ByteBuffer byteBuffer=(ByteBuffer)bytes.underlyingObject();
      byteBuffer.clear();
      bytes.writeInt(0,header);
      byteBuffer.position(SIZE_OF_SIZE);
      byteBuffer.limit(SIZE_OF_SIZE + messageSize);
      readBuffer(byteBuffer);
      bytes.readLimit(byteBuffer.position());
      bytes.notifyAll();
    }
  }
}"
55432,"@NotNull @Override public String toString(){
  return fullName();
}","@Override public String toString(){
  return ""String_Node_Str"" + underlyingType;
}"
55433,"@Ignore(""String_Node_Str"") @Test public void testMapsAsValues() throws IOException, InterruptedException {
  supplyMap(Integer.class,Map.class,mapProxy -> {
    final Map value=new HashMap<String,String>();
{
      value.put(""String_Node_Str"",""String_Node_Str"");
      value.put(""String_Node_Str"",""String_Node_Str"");
      mapProxy.put(1,value);
    }
{
      value.put(""String_Node_Str"",""String_Node_Str"");
      value.put(""String_Node_Str"",""String_Node_Str"");
      mapProxy.put(2,value);
    }
    final Object k1=mapProxy.get(1);
    assertEquals(""String_Node_Str"",mapProxy.get(1).get(""String_Node_Str""));
    assertEquals(null,mapProxy.get(1).get(""String_Node_Str""));
    assertEquals(null,mapProxy.get(1).get(""String_Node_Str""));
    assertEquals(""String_Node_Str"",mapProxy.get(2).get(""String_Node_Str""));
    assertEquals(""String_Node_Str"",mapProxy.get(2).get(""String_Node_Str""));
    assertEquals(2,mapProxy.size());
  }
);
}","@Test public void testMapsAsValues() throws IOException, InterruptedException {
  supplyMap(Integer.class,Map.class,map -> {
    final Map value=new HashMap<String,String>();
{
      value.put(""String_Node_Str"",""String_Node_Str"");
      value.put(""String_Node_Str"",""String_Node_Str"");
      map.put(1,value);
    }
{
      value.put(""String_Node_Str"",""String_Node_Str"");
      value.put(""String_Node_Str"",""String_Node_Str"");
      map.put(2,value);
    }
    assertEquals(""String_Node_Str"",map.get(1).get(""String_Node_Str""));
    assertEquals(""String_Node_Str"",map.get(1).get(""String_Node_Str""));
    assertEquals(null,map.get(1).get(""String_Node_Str""));
    assertEquals(null,map.get(1).get(""String_Node_Str""));
    assertEquals(""String_Node_Str"",map.get(2).get(""String_Node_Str""));
    assertEquals(""String_Node_Str"",map.get(2).get(""String_Node_Str""));
    assertEquals(2,map.size());
  }
);
}"
55434,"public ClientWiredStatelessChronicleCollection(@NotNull final String channelName,@NotNull final ClientWiredStatelessTcpConnectionHub hub,final long cid,@NotNull final Function<ValueIn,U> wireToSet,@NotNull final String type,@NotNull Supplier<E> factory){
  super(channelName,hub,type,cid);
  this.consumer=wireToSet;
  this.factory=factory;
}","public ClientWiredStatelessChronicleCollection(@NotNull final String channelName,@NotNull final ClientWiredStatelessTcpConnectionHub hub,final long cid,@NotNull final Function<ValueIn,U> wireToSet,@NotNull Supplier<E> factory,String csp){
  super(channelName,hub,cid,csp);
  this.consumer=wireToSet;
  this.factory=factory;
}"
55435,"public ClientWiredStatelessChronicleSet(@NotNull String channelName,@NotNull ClientWiredStatelessTcpConnectionHub hub,long cid,@NotNull Function<ValueIn,U> wireToSet,@NotNull String type){
  super(channelName,hub,cid,wireToSet,type,HashSet::new);
}","public ClientWiredStatelessChronicleSet(@NotNull String channelName,@NotNull ClientWiredStatelessTcpConnectionHub hub,long cid,@NotNull Function<ValueIn,U> wireToSet,String csp){
  super(channelName,hub,cid,wireToSet,HashSet::new,csp);
}"
55436,"@Override protected void process(@NotNull final Wire in,@NotNull final Wire out) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn dataWire) -> {
    try {
      if (mapHandler != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,cspText,tid,mapHandler);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,mapHandler.getEntryToWire(),mapHandler.getWireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,mapHandler.getKeyToWire(),mapHandler.getWireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesView.class) {
          valuesHander.process(in,out,(ValuesView)view,cspText,mapHandler.getKeyToWire(),mapHandler.getWireToKey(),ArrayList::new,tid);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"") && queueWireHandler != null) {
        queueWireHandler.process(in,out);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
);
}","@Override protected void process(@NotNull final Wire in,@NotNull final Wire out) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn dataWire) -> {
    try {
      if (mapHandler != null) {
        final Class viewType=requestContext.viewType();
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,cspText,tid,mapHandler,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,mapHandler.getEntryToWire(),mapHandler.getWireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,mapHandler.getKeyToWire(),mapHandler.getWireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesView.class) {
          valuesHander.process(in,out,(ValuesView)view,cspText,mapHandler.getKeyToWire(),mapHandler.getWireToKey(),ArrayList::new,tid);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"") && queueWireHandler != null) {
        queueWireHandler.process(in,out);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
);
}"
55437,"@NotNull private Consumer<WireIn> getWireInConsumer() throws IOException {
  return (metaDataWire) -> {
    try {
      readCsp(metaDataWire);
      readTid(metaDataWire);
      if (!cspText.equals(lastCsp)) {
        lastCsp=cspText;
        serviceName=serviceName(cspText);
        final RequestContext requestContext=RequestContext.requestContext(cspText);
        final Asset asset=Chassis.acquireAsset(requestContext);
        view=asset.acquireView(requestContext);
        viewType=requestContext.viewType();
        requestContext.keyType();
        if (viewType == MapView.class || viewType == EntrySetView.class || viewType == ValuesView.class || viewType == KeySetView.class)         mapHandler=new GenericMapHandler(requestContext.keyType(),requestContext.valueType());
 else         throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      rethrow(e);
    }
  }
;
}","@NotNull private Consumer<WireIn> getWireInConsumer() throws IOException {
  return (metaDataWire) -> {
    try {
      readCsp(metaDataWire);
      readTid(metaDataWire);
      if (hasCspChanged(cspText)) {
        requestContext=RequestContext.requestContext(cspText);
        final Asset asset=Chassis.acquireAsset(requestContext);
        view=asset.acquireView(requestContext);
        requestContext.keyType();
        final Class viewType=requestContext.viewType();
        if (viewType == MapView.class || viewType == EntrySetView.class || viewType == ValuesView.class || viewType == KeySetView.class)         mapHandler=new GenericMapHandler(requestContext.keyType(),requestContext.valueType());
 else         throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      rethrow(e);
    }
  }
;
}"
55438,"/** 
 * peeks the csp or if it has a cid converts the cid into a Csp and returns that
 */
private void readCsp(@NotNull final WireIn wireIn){
  final StringBuilder keyName=Wires.acquireStringBuilder();
  final ValueIn read=wireIn.readEventName(keyName);
  if (csp.contentEquals(keyName)) {
    read.textTo(cspText);
  }
 else   if (cid.contentEquals(keyName)) {
    final long cid=read.int64();
    final CharSequence s=cidToCsp.get(cid);
    cspText.setLength(0);
    cspText.append(s);
  }
}","/** 
 * peeks the csp or if it has a cid converts the cid into a Csp and returns that
 */
private void readCsp(@NotNull final WireIn wireIn){
  final StringBuilder keyName=Wires.acquireStringBuilder();
  cspText.setLength(0);
  final ValueIn read=wireIn.readEventName(keyName);
  if (csp.contentEquals(keyName)) {
    read.textTo(cspText);
  }
 else   if (cid.contentEquals(keyName)) {
    final long cid=read.int64();
    final CharSequence s=cidToCsp.get(cid);
    cspText.append(s);
  }
}"
55439,"public void process(@NotNull final Wire in,@NotNull final Wire out,@NotNull Map<K,V> map,@NotNull final CharSequence csp,long tid,@NotNull final MapHandler<K,V> mapHandler) throws StreamCorruptedException {
  this.vToWire=mapHandler.getValueToWire();
  this.wireToK=mapHandler.getWireToKey();
  this.wireToV=mapHandler.getWireToValue();
  try {
    this.inWire=in;
    this.outWire=out;
    this.map=map;
    charSequenceValue=map instanceof ChronicleMap && CharSequence.class == ((ChronicleMap)map).valueClass();
    this.csp=csp;
    this.tid=tid;
    dataConsumer.accept(in);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}","public void process(@NotNull final Wire in,@NotNull final Wire out,@NotNull Map<K,V> map,@NotNull final CharSequence csp,long tid,@NotNull final MapHandler<K,V> mapHandler,@NotNull final RequestContext requestContext) throws StreamCorruptedException {
  this.vToWire=mapHandler.getValueToWire();
  this.wireToK=mapHandler.getWireToKey();
  this.wireToV=mapHandler.getWireToValue();
  this.requestContext=requestContext;
  try {
    this.inWire=in;
    this.outWire=out;
    this.map=map;
    charSequenceValue=map instanceof ChronicleMap && CharSequence.class == ((ChronicleMap)map).valueClass();
    this.csp=csp;
    this.tid=tid;
    dataConsumer.accept(in);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
55440,"private void createProxy(final String type){
  outWire.writeEventName(reply).type(""String_Node_Str"").writeValue().marshallable(w -> {
    CharSequence root=csp.subSequence(0,csp.length() - ""String_Node_Str"".length());
    final StringBuilder csp=acquireStringBuilder().append(root).append(type);
    w.writeEventName(CoreFields.csp).text(csp);
    w.writeEventName(CoreFields.cid).int64(createCid(csp));
  }
);
}","private void createProxy(final String type){
  outWire.writeEventName(reply).type(""String_Node_Str"").writeValue().marshallable(w -> {
    cpsBuff.setLength(0);
    cpsBuff.append(""String_Node_Str"").append(requestContext.name());
    cpsBuff.append(""String_Node_Str"");
    cpsBuff.append(""String_Node_Str"").append(type);
    cpsBuff.append(""String_Node_Str"");
    cpsBuff.append(""String_Node_Str"").append(requestContext.keyType().getSimpleName());
    cpsBuff.append(""String_Node_Str"");
    cpsBuff.append(""String_Node_Str"").append(requestContext.valueType().getSimpleName());
    w.writeEventName(CoreFields.csp).text(cpsBuff);
    w.writeEventName(CoreFields.cid).int64(createCid(cpsBuff));
  }
);
}"
55441,"@NotNull @Override public Collection<V> values(){
  long cid=proxyReturnWireConsumer(values,read -> {
    final StringBuilder type=Wires.acquireStringBuilder();
    read.type(type);
    return read.applyToMarshallable(w -> {
      final String csp1=csp(w).toString();
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,csp1);
      return cid0;
    }
);
  }
);
  final Function<ValueIn,V> conumer=valueIn -> valueIn.object(vClass);
  return new ClientWiredStatelessChronicleCollection<>(channelName,hub,cid,conumer,""String_Node_Str"",ArrayList::new);
}","@NotNull @Override public Collection<V> values(){
  long cid=proxyReturnWireConsumer(values,read -> {
    final StringBuilder type=Wires.acquireStringBuilder();
    read.type(type);
    return read.applyToMarshallable(w -> {
      final String csp1=csp(w).toString();
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,csp1);
      return cid0;
    }
);
  }
);
  final Function<ValueIn,V> conumer=valueIn -> valueIn.object(vClass);
  return new ClientWiredStatelessChronicleCollection<>(channelName,hub,cid,conumer,ArrayList::new,""String_Node_Str"" + channelName + ""String_Node_Str""+ ""String_Node_Str"");
}"
55442,"public ClientWiredStatelessChronicleMap(@NotNull final ClientWiredChronicleMapStatelessBuilder config,@NotNull final Class<K> kClass,@NotNull final Class<V> vClass,@NotNull final String channelName,@NotNull final ClientWiredStatelessTcpConnectionHub hub){
  super(channelName,hub,""String_Node_Str"" + kClass.getSimpleName() + ""String_Node_Str""+ vClass.getSimpleName(),0);
  this.putReturnsNull=config.putReturnsNull();
  this.removeReturnsNull=config.removeReturnsNull();
  this.kClass=kClass;
  this.vClass=vClass;
}","public ClientWiredStatelessChronicleMap(@NotNull final ClientWiredChronicleMapStatelessBuilder config,@NotNull final Class<K> kClass,@NotNull final Class<V> vClass,@NotNull final String channelName,@NotNull final ClientWiredStatelessTcpConnectionHub hub){
  super(channelName,hub,0,""String_Node_Str"" + channelName + ""String_Node_Str""+ ""String_Node_Str""+ kClass.getSimpleName()+ ""String_Node_Str""+ vClass.getSimpleName());
  this.putReturnsNull=config.putReturnsNull();
  this.removeReturnsNull=config.removeReturnsNull();
  this.kClass=kClass;
  this.vClass=vClass;
}"
55443,"@NotNull public Set<K> keySet(){
  long cid=proxyReturnWireConsumer(keySet,read -> {
    final long[] cidRef=new long[1];
    final StringBuilder type=Wires.acquireStringBuilder();
    read.type(type);
    read.marshallable(w -> {
      final String csp1=csp(w).toString();
      final long cid0=cid(w);
      cidToCsp.put(cid0,csp1);
      cidRef[0]=cid0;
    }
);
    return cidRef[0];
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,valueIn -> valueIn.object(kClass),""String_Node_Str"");
}","@NotNull public Set<K> keySet(){
  long cid=proxyReturnWireConsumer(keySet,read -> {
    final long[] cidRef=new long[1];
    final StringBuilder type=Wires.acquireStringBuilder();
    read.type(type);
    read.marshallable(w -> {
      final String csp1=csp(w).toString();
      final long cid0=cid(w);
      cidToCsp.put(cid0,csp1);
      cidRef[0]=cid0;
    }
);
    return cidRef[0];
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,valueIn -> valueIn.object(kClass),""String_Node_Str"" + channelName + ""String_Node_Str"");
}"
55444,"@NotNull public Set<Map.Entry<K,V>> entrySet(){
  long cid=proxyReturnWireConsumer(entrySet,read -> {
    final StringBuilder type=Wires.acquireStringBuilder();
    read.type(type);
    return read.applyToMarshallable(w -> {
      final String csp1=csp(w).toString();
      final long cid0=cid(w);
      cidToCsp.put(cid0,csp1);
      return cid0;
    }
);
  }
);
  Function<ValueIn,Map.Entry<K,V>> conumer=valueIn -> valueIn.applyToMarshallable(r -> {
    final K k=r.read(() -> ""String_Node_Str"").object(kClass);
    final V v=r.read(() -> ""String_Node_Str"").object(vClass);
    return new Map.Entry<K,V>(){
      @Override public K getKey(){
        return k;
      }
      @Override public V getValue(){
        return v;
      }
      @Override public V setValue(      Object value){
        throw new UnsupportedOperationException();
      }
    }
;
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,conumer,""String_Node_Str"");
}","@NotNull public Set<Map.Entry<K,V>> entrySet(){
  long cid=proxyReturnWireConsumer(entrySet,read -> {
    final StringBuilder type=Wires.acquireStringBuilder();
    read.type(type);
    return read.applyToMarshallable(w -> {
      final String csp1=csp(w).toString();
      final long cid0=cid(w);
      cidToCsp.put(cid0,csp1);
      return cid0;
    }
);
  }
);
  Function<ValueIn,Map.Entry<K,V>> conumer=valueIn -> valueIn.applyToMarshallable(r -> {
    final K k=r.read(() -> ""String_Node_Str"").object(kClass);
    final V v=r.read(() -> ""String_Node_Str"").object(vClass);
    return new Map.Entry<K,V>(){
      @Override public K getKey(){
        return k;
      }
      @Override public V getValue(){
        return v;
      }
      @Override public V setValue(      Object value){
        throw new UnsupportedOperationException();
      }
    }
;
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,conumer,""String_Node_Str"" + channelName + ""String_Node_Str"");
}"
55445,"/** 
 * @param channelName
 * @param hub
 * @param type        the type of wire handler for example ""MAP"" or ""QUEUE""
 * @param cid         used by proxies such as the entry-set
 */
public MapStatelessClient(@NotNull String channelName,@NotNull ClientWiredStatelessTcpConnectionHub hub,@NotNull String type,long cid){
  super(channelName,hub,type,cid);
}","/** 
 * @param channelName
 * @param hub
 * @param cid         used by proxies such as the entry-set
 * @param csp
 */
public MapStatelessClient(@NotNull String channelName,@NotNull ClientWiredStatelessTcpConnectionHub hub,long cid,String csp){
  super(channelName,hub,cid,csp);
}"
55446,"@NotNull @Override public Collection<V> values(){
  final StringBuilder csp=Wires.acquireStringBuilder();
  long cid=proxyReturnWireConsumer(values,read -> {
    final StringBuilder type=Wires.acquireAnotherStringBuilder(csp);
    read.type(type);
    return read.applyToMarshallable(w -> {
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,stringEvent(CoreFields.csp,csp,w).toString());
      return cid0;
    }
);
  }
);
  final Function<ValueIn,V> conumer=valueIn -> valueIn.object(vClass);
  return new ClientWiredStatelessChronicleCollection<>(channelName,hub,cid,conumer,ArrayList::new,""String_Node_Str"" + channelName + ""String_Node_Str""+ ""String_Node_Str"");
}","@NotNull @Override public Collection<V> values(){
  final StringBuilder csp=Wires.acquireStringBuilder();
  long cid=proxyReturnWireConsumer(values,read -> {
    final StringBuilder type=Wires.acquireAnotherStringBuilder(csp);
    read.type(type);
    return read.applyToMarshallable(w -> {
      stringEvent(CoreFields.csp,csp,w);
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,csp.toString());
      return cid0;
    }
);
  }
);
  final Function<ValueIn,V> conumer=valueIn -> valueIn.object(vClass);
  return new ClientWiredStatelessChronicleCollection<>(channelName,hub,cid,conumer,ArrayList::new,""String_Node_Str"" + channelName + ""String_Node_Str""+ ""String_Node_Str"");
}"
55447,"@NotNull public Set<K> keySet(){
  final StringBuilder csp=Wires.acquireStringBuilder();
  long cid=proxyReturnWireConsumer(keySet,read -> {
    final StringBuilder type=Wires.acquireAnotherStringBuilder(csp);
    read.type(type);
    return read.applyToMarshallable(w -> {
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,stringEvent(CoreFields.csp,csp,w).toString());
      return cid0;
    }
);
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,valueIn -> valueIn.object(kClass),csp.toString());
}","@NotNull public Set<K> keySet(){
  final StringBuilder csp=Wires.acquireStringBuilder();
  long cid=proxyReturnWireConsumer(keySet,read -> {
    final StringBuilder type=Wires.acquireAnotherStringBuilder(csp);
    read.type(type);
    return read.applyToMarshallable(w -> {
      stringEvent(CoreFields.csp,csp,w);
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,csp.toString());
      return cid0;
    }
);
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,valueIn -> valueIn.object(kClass),csp.toString());
}"
55448,"@NotNull public Set<Map.Entry<K,V>> entrySet(){
  final StringBuilder csp=Wires.acquireStringBuilder();
  long cid=proxyReturnWireConsumer(entrySet,read -> {
    final StringBuilder type=Wires.acquireAnotherStringBuilder(csp);
    read.type(type);
    return read.applyToMarshallable(w -> {
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,stringEvent(CoreFields.csp,csp,w).toString());
      return cid0;
    }
);
  }
);
  Function<ValueIn,Map.Entry<K,V>> conumer=valueIn -> valueIn.applyToMarshallable(r -> {
    final K k=r.read(() -> ""String_Node_Str"").object(kClass);
    final V v=r.read(() -> ""String_Node_Str"").object(vClass);
    return new Map.Entry<K,V>(){
      @Override public K getKey(){
        return k;
      }
      @Override public V getValue(){
        return v;
      }
      @Override public V setValue(      Object value){
        throw new UnsupportedOperationException();
      }
    }
;
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,conumer,csp.toString());
}","@NotNull public Set<Map.Entry<K,V>> entrySet(){
  final StringBuilder csp=Wires.acquireStringBuilder();
  long cid=proxyReturnWireConsumer(entrySet,read -> {
    final StringBuilder type=Wires.acquireAnotherStringBuilder(csp);
    read.type(type);
    return read.applyToMarshallable(w -> {
      stringEvent(CoreFields.csp,csp,w);
      final long cid0=CoreFields.cid(w);
      cidToCsp.put(cid0,csp.toString());
      return cid0;
    }
);
  }
);
  Function<ValueIn,Map.Entry<K,V>> conumer=valueIn -> valueIn.applyToMarshallable(r -> {
    final K k=r.read(() -> ""String_Node_Str"").object(kClass);
    final V v=r.read(() -> ""String_Node_Str"").object(vClass);
    return new Map.Entry<K,V>(){
      @Override public K getKey(){
        return k;
      }
      @Override public V getValue(){
        return v;
      }
      @Override public V setValue(      Object value){
        throw new UnsupportedOperationException();
      }
    }
;
  }
);
  return new ClientWiredStatelessChronicleSet<>(channelName,hub,cid,conumer,csp.toString());
}"
55449,"@Test public void testPutAll() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    final Set<Map.Entry<Integer,String>> entries=mapProxy.entrySet();
    assertEquals(0,entries.size());
    assertEquals(true,entries.isEmpty());
    Map<Integer,String> data=new HashMap<>();
    data.put(1,""String_Node_Str"");
    data.put(2,""String_Node_Str"");
    mapProxy.putAll(data);
    final Set<Map.Entry<Integer,String>> e=mapProxy.entrySet();
    final Iterator<Map.Entry<Integer,String>> iterator=e.iterator();
    Map.Entry<Integer,String> entry=iterator.next();
    if (entry.getKey() == 1) {
      assertEquals(""String_Node_Str"",entry.getValue());
      entry=iterator.next();
      assertEquals(""String_Node_Str"",entry.getValue());
    }
 else     if (entry.getKey() == 2) {
      assertEquals(""String_Node_Str"",entry.getValue());
      entry=iterator.next();
      assertEquals(""String_Node_Str"",entry.getValue());
    }
    assertEquals(2,mapProxy.size());
  }
);
}","@Test public void testPutAll() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    yamlLoggger(() -> {
      final Set<Map.Entry<Integer,String>> entries=mapProxy.entrySet();
      assertEquals(0,entries.size());
      assertEquals(true,entries.isEmpty());
      Map<Integer,String> data=new HashMap<>();
      data.put(1,""String_Node_Str"");
      data.put(2,""String_Node_Str"");
      mapProxy.putAll(data);
      final Set<Map.Entry<Integer,String>> e=mapProxy.entrySet();
      final Iterator<Map.Entry<Integer,String>> iterator=e.iterator();
      Map.Entry<Integer,String> entry=iterator.next();
      if (entry.getKey() == 1) {
        assertEquals(""String_Node_Str"",entry.getValue());
        entry=iterator.next();
        assertEquals(""String_Node_Str"",entry.getValue());
      }
 else       if (entry.getKey() == 2) {
        assertEquals(""String_Node_Str"",entry.getValue());
        entry=iterator.next();
        assertEquals(""String_Node_Str"",entry.getValue());
      }
      assertEquals(2,mapProxy.size());
    }
);
  }
);
}"
55450,"@Override protected void process(@NotNull final Wire in,@NotNull final Wire out) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn dataWire) -> {
    try {
      if (mh != null) {
        final Class viewType=requestContext.viewType();
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,tid,mh,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,mh.entryToWire(),mh.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,mh.keyToWire(),mh.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesView.class) {
          valuesHander.process(in,out,(ValuesView)view,cspText,mh.keyToWire(),mh.wireToKey(),ArrayList::new,tid);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"") && queueWireHandler != null) {
        queueWireHandler.process(in,out);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
);
}","@Override protected void process(@NotNull final Wire in,@NotNull final Wire out) throws StreamCorruptedException {
  logYamlToStandardOut(in);
  in.readDocument(this.metaDataConsumer,(  WireIn dataWire) -> {
    try {
      if (mh != null) {
        if (viewType == MapView.class) {
          mapWireHandler.process(in,out,(MapView)view,tid,mh,requestContext);
          return;
        }
        if (viewType == EntrySetView.class) {
          entrySetHandler.process(in,out,(EntrySetView)view,cspText,mh.entryToWire(),mh.wireToEntry(),HashSet::new,tid);
          return;
        }
        if (viewType == KeySetView.class) {
          keySetHandler.process(in,out,(KeySetView)view,cspText,mh.keyToWire(),mh.wireToKey(),HashSet::new,tid);
          return;
        }
        if (viewType == ValuesView.class) {
          valuesHander.process(in,out,(ValuesView)view,cspText,mh.keyToWire(),mh.wireToKey(),ArrayList::new,tid);
          return;
        }
      }
      if (endsWith(cspText,""String_Node_Str"") && queueWireHandler != null) {
        queueWireHandler.process(in,out);
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
);
}"
55451,"@NotNull private Consumer<WireIn> getWireInConsumer() throws IOException {
  return (metaDataWire) -> {
    try {
      readCsp(metaDataWire);
      readTid(metaDataWire);
      if (hasCspChanged(cspText)) {
        requestContext=RequestContext.requestContext(cspText);
        final Asset asset=Chassis.acquireAsset(requestContext);
        view=asset.acquireView(requestContext);
        requestContext.keyType();
        final Class viewType=requestContext.viewType();
        if (viewType == MapView.class || viewType == EntrySetView.class || viewType == ValuesView.class || viewType == KeySetView.class) {
          final Class kClass=requestContext.keyType() == null ? String.class : requestContext.keyType();
          final Class vClass=requestContext.valueType() == null ? String.class : requestContext.valueType();
          mh=new GenericMapHandler(kClass,vClass);
        }
 else         throw new UnsupportedOperationException(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      rethrow(e);
    }
  }
;
}","@NotNull private Consumer<WireIn> getWireInConsumer() throws IOException {
}"
55452,"@Override public void setCallback(Object callback){
  MapEventListener mel=(MapEventListener)callback;
  Consumer<FPMEvent> fpmEventConsumer=(  FPMEvent e) -> {
    System.out.println(e);
    if (subscribeAll || subscribedKeys.contains(e.getKey())) {
      mel.update(e.getKey(),e.getLastValue(),e.getValue());
    }
  }
;
  filePerKeyMap.registerForEvents(fpmEventConsumer);
}","@Override public void setCallback(Object callback){
  MapEventListener mel=(MapEventListener)callback;
  Consumer<FPMEvent> fpmEventConsumer=(  FPMEvent e) -> {
    LOG.error(""String_Node_Str"",e);
    if (subscribeAll || subscribedKeys.contains(e.getKey())) {
      mel.update(e.getKey(),e.getLastValue(),e.getValue());
    }
  }
;
  filePerKeyMap.registerForEvents(fpmEventConsumer);
}"
55453,"private void logYamlToStandardOut(@NotNull Wire in){
  if (YamlLogging.showServerReads) {
    try {
      System.out.println(""String_Node_Str"" + Wires.fromSizePrefixedBlobs(in.bytes()));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + Bytes.toDebugString(in.bytes()));
    }
  }
}","private void logYamlToStandardOut(@NotNull Wire in){
  if (YamlLogging.showServerReads) {
    try {
      LOG.info(""String_Node_Str"" + Wires.fromSizePrefixedBlobs(in.bytes()));
    }
 catch (    Exception e) {
      LOG.info(""String_Node_Str"" + Bytes.toDebugString(in.bytes()));
    }
  }
}"
55454,"@Ignore(""String_Node_Str"") @Test(timeout=500000) public void testPutAll() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    final Set<Map.Entry<Integer,String>> entries=mapProxy.entrySet();
    assertEquals(0,entries.size());
    assertEquals(true,entries.isEmpty());
    Map<Integer,String> data=new HashMap<>();
    data.put(1,""String_Node_Str"");
    data.put(2,""String_Node_Str"");
    assertEquals(true,entries.isEmpty());
    mapProxy.putAll(data);
    final Set<Map.Entry<Integer,String>> e=mapProxy.entrySet();
    final Iterator<Map.Entry<Integer,String>> iterator=e.iterator();
    Map.Entry<Integer,String> entry=iterator.next();
    if (entry.getKey() == 1) {
      assertEquals(""String_Node_Str"",entry.getValue());
      entry=iterator.next();
      assertEquals(""String_Node_Str"",entry.getValue());
    }
 else     if (entry.getKey() == 2) {
      assertEquals(""String_Node_Str"",entry.getValue());
      entry=iterator.next();
      assertEquals(""String_Node_Str"",entry.getValue());
    }
    assertEquals(2,mapProxy.size());
  }
);
}","@Test public void testPutAll() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    final Set<Map.Entry<Integer,String>> entries=mapProxy.entrySet();
    assertEquals(0,entries.size());
    assertEquals(true,entries.isEmpty());
    assertEquals(true,entries.isEmpty());
    Map<Integer,String> data=new HashMap<>();
    data.put(1,""String_Node_Str"");
    data.put(2,""String_Node_Str"");
    mapProxy.putAll(data);
    final Set<Map.Entry<Integer,String>> e=mapProxy.entrySet();
    final Iterator<Map.Entry<Integer,String>> iterator=e.iterator();
    Map.Entry<Integer,String> entry=iterator.next();
    if (entry.getKey() == 1) {
      assertEquals(""String_Node_Str"",entry.getValue());
      entry=iterator.next();
      assertEquals(""String_Node_Str"",entry.getValue());
    }
 else     if (entry.getKey() == 2) {
      assertEquals(""String_Node_Str"",entry.getValue());
      entry=iterator.next();
      assertEquals(""String_Node_Str"",entry.getValue());
    }
    assertEquals(2,mapProxy.size());
  }
);
}"
55455,"/** 
 * containsKey(null) throws NPE
 */
@Ignore(""String_Node_Str"") @Test(timeout=50000,expected=NullPointerException.class) public void testContainsKey_NullPointerException() throws IOException {
  try (ChronicleMap c=newIntString()){
    writeMessage=""String_Node_Str"";
    yamlLoggger(() -> c.containsKey(null));
  }
 }","/** 
 * containsKey(null) throws NPE
 */
@Test(timeout=50000,expected=NullPointerException.class) public void testContainsKey_NullPointerException() throws IOException {
  try (ChronicleMap c=newIntString()){
    writeMessage=""String_Node_Str"";
    yamlLoggger(() -> c.containsKey(null));
  }
 }"
55456,"/** 
 * get(null) throws NPE
 */
@Ignore(""String_Node_Str"") @Test(timeout=50000,expected=NullPointerException.class) public void testGet_NullPointerException() throws IOException {
  try (ChronicleMap c=newIntString()){
    writeMessage=""String_Node_Str"";
    yamlLoggger(() -> c.get(null));
  }
 }","/** 
 * get(null) throws NPE
 */
@Test(timeout=50000,expected=NullPointerException.class) public void testGet_NullPointerException() throws IOException {
  try (ChronicleMap c=newIntString()){
    writeMessage=""String_Node_Str"";
    yamlLoggger(() -> c.get(null));
  }
 }"
55457,"@Test(timeout=500000) public void testPutAll() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    final Set<Map.Entry<Integer,String>> entries=mapProxy.entrySet();
    assertEquals(0,entries.size());
    assertEquals(true,entries.isEmpty());
    Map<Integer,String> data=new HashMap<>();
    data.put(1,""String_Node_Str"");
    data.put(2,""String_Node_Str"");
    assertEquals(true,entries.isEmpty());
    mapProxy.putAll(data);
    assertEquals(2,mapProxy.size());
  }
);
}","@Test(timeout=500000) public void testPutAll() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    final Set<Map.Entry<Integer,String>> entries=mapProxy.entrySet();
    assertEquals(0,entries.size());
    assertEquals(true,entries.isEmpty());
    Map<Integer,String> data=new HashMap<>();
    data.put(1,""String_Node_Str"");
    data.put(2,""String_Node_Str"");
    assertEquals(true,entries.isEmpty());
    mapProxy.putAll(data);
    final Set<Map.Entry<Integer,String>> e=mapProxy.entrySet();
{
      final Map.Entry<Integer,String> entry=e.iterator().next();
      if (entry.getKey() == 1)       assertEquals(e.toString(),""String_Node_Str"",entry.getValue());
 else       if (entry.getKey() == 2)       assertEquals(e.toString(),""String_Node_Str"",entry.getValue());
    }
{
      final Map.Entry<Integer,String> entry=e.iterator().next();
      if (entry.getKey() == 1)       assertEquals(e.toString(),""String_Node_Str"",entry.getValue());
 else       if (entry.getKey() == 2)       assertEquals(e.toString(),""String_Node_Str"",entry.getValue());
    }
    assertEquals(2,mapProxy.size());
  }
);
}"
55458,"public V remove(Object key){
  if (key == null)   throw keyNotNullNPE();
  final EventId eventId=removeReturnsNull ? remove : getAndRemove;
  return this.proxyReturnTypedObject(eventId,null,vClass,key);
}","public V remove(Object key){
  if (key == null)   throw keyNotNullNPE();
  if (removeReturnsNull) {
    sendEventAsync(remove,toParameters(remove,key));
    return null;
  }
 else {
    return proxyReturnTypedObject(getAndRemove,null,vClass,key);
  }
}"
55459,"/** 
 * remove removes the correct key-value pair from the map
 */
@Test(timeout=50000) public void testRemove() throws IOException {
  try (ChronicleMap map=map5()){
    yamlLoggger(() -> map.remove(five));
    assertEquals(4,map.size());
    assertFalse(map.containsKey(five));
  }
 }","/** 
 * remove removes the correct key-value pair from the map
 */
@Ignore @Test(timeout=50000) public void testRemove() throws IOException {
  try (ChronicleMap map=map5()){
    yamlLoggger(() -> map.remove(five));
    assertEquals(4,map.size());
    assertFalse(map.containsKey(five));
  }
 }"
55460,public FilePerKeyMap getFilePerKeyMap(String name);,FilePerKeyMap getFilePerKeyMap(String name);
55461,"public AcceptorEventHandler start(int port) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(port,() -> {
    final Map<Long,CharSequence> cidToCsp=new HashMap<>();
    try {
      mapWireConnectionHub=new MapWireConnectionHub(localIdentifier,8085);
      return new EngineWireHandler(cidToCsp,chronicleEngine);
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
    return null;
  }
);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}","public AcceptorEventHandler start(int port) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(port,() -> {
    final Map<Long,String> cidToCsp=new HashMap<>();
    try {
      mapWireConnectionHub=new MapWireConnectionHub(localIdentifier,8085);
      return new EngineWireHandler(cidToCsp,chronicleEngine);
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
    return null;
  }
);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}"
55462,"public EngineWireHandler(@NotNull final Map<Long,CharSequence> cidToCsp,@NotNull final ChronicleEngine chronicleEngine) throws IOException {
  this.mapWireHandler=new MapWireHandlerProcessor<>(cidToCsp);
  this.fileMapWireHandler=new MapWireHandlerProcessor<>(cidToCsp);
  this.keySetHandler=new CollectionWireHandlerProcessor<>();
  this.queueWireHandler=null;
  this.cidToCsp=cidToCsp;
  this.chronicleEngine=chronicleEngine;
  this.entrySetHandler=new CollectionWireHandlerProcessor<>();
  this.valuesHander=new CollectionWireHandlerProcessor<>();
}","public EngineWireHandler(@NotNull final Map<Long,String> cidToCsp,@NotNull final ChronicleEngine chronicleEngine) throws IOException {
  this.mapWireHandler=new MapWireHandlerProcessor<>(cidToCsp);
  this.fileMapWireHandler=new MapWireHandlerProcessor<>(cidToCsp);
  this.keySetHandler=new CollectionWireHandlerProcessor<>();
  this.queueWireHandler=null;
  this.cidToCsp=cidToCsp;
  this.chronicleEngine=chronicleEngine;
  this.entrySetHandler=new CollectionWireHandlerProcessor<>();
  this.valuesHander=new CollectionWireHandlerProcessor<>();
}"
55463,"@Override public FilePerKeyMap getFilePerKeyMap(String name){
  return fpMaps.computeIfAbsent(name,k -> new FilePerKeyMap(k));
}","@Override public FilePerKeyMap getFilePerKeyMap(String name){
  return fpMaps.computeIfAbsent(name,k -> {
    try {
      return new FilePerKeyMap(k);
    }
 catch (    IOException e) {
      Jvm.rethrow(e);
      return null;
    }
  }
);
}"
55464,"public static void main(String[] args){
  ChronicleEngine chronicleEngine=new ChronicleEngine();
  try {
    int port=55555;
    final ServerEndpoint serverEndpoint=new ServerEndpoint(port,(byte)1,chronicleEngine);
    System.out.println(""String_Node_Str"" + serverEndpoint.getPort());
    while (true) {
      Thread.sleep(1000 * 10);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  ChronicleEngine chronicleEngine=new ChronicleEngine();
  try {
    int port=8088;
    final ServerEndpoint serverEndpoint=new ServerEndpoint(port,(byte)1,chronicleEngine);
    System.out.println(""String_Node_Str"" + serverEndpoint.getPort());
    while (true) {
      Thread.sleep(1000 * 10);
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
55465,"public EngineWireHandler(@NotNull final MapWireHandler mapWireHandler,@NotNull final WireHandler queueWireHandler,@NotNull final Map<Long,CharSequence> cidToCsp,@NotNull final ChronicleEngine chronicleEngine,@NotNull final SetWireHandler setWireHandler){
  this.mapWireHandler=mapWireHandler;
  this.setWireHandler=setWireHandler;
  this.queueWireHandler=queueWireHandler;
  this.cidToCsp=cidToCsp;
  this.chronicleEngine=chronicleEngine;
}","public EngineWireHandler(@NotNull final MapWireHandler<byte[],byte[]> mapWireHandler,@NotNull final WireHandler queueWireHandler,@NotNull final Map<Long,CharSequence> cidToCsp,@NotNull final ChronicleEngine chronicleEngine,@NotNull final SetWireHandler setWireHandler){
  this.mapWireHandler=mapWireHandler;
  this.setWireHandler=setWireHandler;
  this.queueWireHandler=queueWireHandler;
  this.cidToCsp=cidToCsp;
  this.chronicleEngine=chronicleEngine;
}"
55466,"public AcceptorEventHandler start(int port) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(port,() -> {
    final Map<Long,CharSequence> cidToCsp=new HashMap<>();
    queueWireHandler=new QueueWireHandler();
    MapWireHandlerProcessor wireHandler=null;
    try {
      mapWireConnectionHub=new MapWireConnectionHub(localIdentifier,8085);
      mapWireHandler=wireHandler=new MapWireHandlerProcessor(cidToCsp);
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
    final EngineWireHandler engineWireHandler=new EngineWireHandler(mapWireHandler,queueWireHandler,cidToCsp,chronicleEngine,new SetWireHandlerProcessor<byte[]>());
    if (wireHandler != null)     wireHandler.accept(engineWireHandler);
    return engineWireHandler;
  }
);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}","public AcceptorEventHandler start(int port) throws IOException {
  eg.start();
  AcceptorEventHandler eah=new AcceptorEventHandler(port,() -> {
    final Map<Long,CharSequence> cidToCsp=new HashMap<>();
    queueWireHandler=new QueueWireHandler();
    try {
      mapWireConnectionHub=new MapWireConnectionHub(localIdentifier,8085);
      mapWireHandler=new MapWireHandlerProcessor<>(cidToCsp);
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
    return new EngineWireHandler(mapWireHandler,queueWireHandler,cidToCsp,chronicleEngine,new SetWireHandlerProcessor<>(),new SetWireHandlerProcessor<>());
  }
);
  eg.addHandler(eah);
  this.eah=eah;
  return eah;
}"
55467,"@Override public byte[] getKey(){
  return key1;
}","@Override public byte[] getKey(){
  return key;
}"
55468,"@Override protected void process(Wire in,Wire out) throws StreamCorruptedException {
  try {
    final StringBuilder cspText=peekType(in);
    final String serviceName=serviceName(cspText);
    if (endsWith(cspText,""String_Node_Str"")) {
      final ChronicleMap<byte[],byte[]> map=chronicleEngine.getMap(serviceName,byte[].class,byte[].class);
      mapWireHandler.process(in,out,map,cspText,valueToWire,wireToKey,wireToValue);
      return;
    }
    if (endsWith(cspText,""String_Node_Str"")) {
      final ChronicleMap<byte[],byte[]> map=chronicleEngine.getMap(serviceName,byte[].class,byte[].class);
      setWireHandler.process(in,out,map.entrySet(),cspText,entryToWire,wireToEntry);
      return;
    }
    if (endsWith(cspText,""String_Node_Str"")) {
      final ChronicleMap<byte[],byte[]> map=chronicleEngine.getMap(serviceName,byte[].class,byte[].class);
      setWireHandler.process(in,out,map.keySet(),cspText,keyToWire,wireToKey);
      return;
    }
    if (endsWith(cspText,""String_Node_Str"")) {
      queueWireHandler.process(in,out);
      return;
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","@Override protected void process(Wire in,Wire out) throws StreamCorruptedException {
  try {
    final StringBuilder cspText=peekType(in);
    final String serviceName=serviceName(cspText);
    if (endsWith(cspText,""String_Node_Str"")) {
      final ChronicleMap<byte[],byte[]> map=chronicleEngine.getMap(serviceName,byte[].class,byte[].class);
      mapWireHandler.process(in,out,map,cspText,valueToWire,wireToKey,wireToValue);
      return;
    }
    if (endsWith(cspText,""String_Node_Str"")) {
      final ChronicleMap<byte[],byte[]> map=chronicleEngine.getMap(serviceName,byte[].class,byte[].class);
      entrySetHandler.process(in,out,map.entrySet(),cspText,entryToWire,wireToEntry);
      return;
    }
    if (endsWith(cspText,""String_Node_Str"")) {
      final ChronicleMap<byte[],byte[]> map=chronicleEngine.getMap(serviceName,byte[].class,byte[].class);
      keSetHandler.process(in,out,map.keySet(),cspText,keyToWire,wireToKey);
      return;
    }
    if (endsWith(cspText,""String_Node_Str"")) {
      queueWireHandler.process(in,out);
      return;
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
55469,"public EngineWireHandler(@NotNull final MapWireHandler<byte[],byte[]> mapWireHandler,@NotNull final WireHandler queueWireHandler,@NotNull final Map<Long,CharSequence> cidToCsp,@NotNull final ChronicleEngine chronicleEngine,@NotNull final SetWireHandler setWireHandler){
  this.mapWireHandler=mapWireHandler;
  this.setWireHandler=setWireHandler;
  this.queueWireHandler=queueWireHandler;
  this.cidToCsp=cidToCsp;
  this.chronicleEngine=chronicleEngine;
}","public EngineWireHandler(@NotNull final MapWireHandler<byte[],byte[]> mapWireHandler,@NotNull final WireHandler queueWireHandler,@NotNull final Map<Long,CharSequence> cidToCsp,@NotNull final ChronicleEngine chronicleEngine,@NotNull final SetWireHandler<Set<byte[]>,byte[]> keSetHandler,@NotNull final SetWireHandler<Set<Map.Entry<byte[],byte[]>>,Map.Entry<byte[],byte[]>> entrySetHandler){
  this.mapWireHandler=mapWireHandler;
  this.keSetHandler=keSetHandler;
  this.queueWireHandler=queueWireHandler;
  this.cidToCsp=cidToCsp;
  this.chronicleEngine=chronicleEngine;
  this.entrySetHandler=entrySetHandler;
}"
55470,"public RemoteTcpClientChronicleContext(String hostname,int port) throws IOException {
  this.remoteClientServiceLocator=new RemoteClientServiceLocator(hostname,port,(byte)2);
}","public RemoteTcpClientChronicleContext(String hostname,int port,byte identifier) throws IOException {
  this.remoteClientServiceLocator=new RemoteClientServiceLocator(hostname,port,identifier);
}"
55471,"@Test(timeout=50000) public void testMarshable() throws Exception {
  try (final ServerEndpoint serverEndpoint=new ServerEndpoint((byte)1)){
    int serverPort=serverEndpoint.getPort();
    try (final RemoteTcpClientChronicleContext context=new RemoteTcpClientChronicleContext(""String_Node_Str"",serverPort)){
      try (ChronicleMap<MyMarshallable,Long> numbers=context.getMap(""String_Node_Str"",MyMarshallable.class,Long.class)){
        MyMarshallable key1=new MyMarshallable(""String_Node_Str"");
        MyMarshallable key2=new MyMarshallable(""String_Node_Str"");
        numbers.put(key1,1L);
        numbers.put(key2,2L);
      }
       try (ChronicleMap<MyMarshallable,Long> numbers=context.getMap(""String_Node_Str"",MyMarshallable.class,Long.class)){
        MyMarshallable key1=new MyMarshallable(""String_Node_Str"");
        MyMarshallable key2=new MyMarshallable(""String_Node_Str"");
        assertEquals(2,numbers.size());
        assertEquals(Long.valueOf(1),numbers.get(key1));
        assertEquals(Long.valueOf(2),numbers.get(key2));
      }
     }
   }
 }","@Test(timeout=50000) public void testMarshable() throws Exception {
  try (final ServerEndpoint serverEndpoint=new ServerEndpoint((byte)1)){
    int serverPort=serverEndpoint.getPort();
    try (final RemoteTcpClientChronicleContext context=new RemoteTcpClientChronicleContext(""String_Node_Str"",serverPort,(byte)2)){
      try (ChronicleMap<MyMarshallable,Long> numbers=context.getMap(""String_Node_Str"",MyMarshallable.class,Long.class)){
        MyMarshallable key1=new MyMarshallable(""String_Node_Str"");
        MyMarshallable key2=new MyMarshallable(""String_Node_Str"");
        numbers.put(key1,1L);
        numbers.put(key2,2L);
      }
       try (ChronicleMap<MyMarshallable,Long> numbers=context.getMap(""String_Node_Str"",MyMarshallable.class,Long.class)){
        MyMarshallable key1=new MyMarshallable(""String_Node_Str"");
        MyMarshallable key2=new MyMarshallable(""String_Node_Str"");
        assertEquals(2,numbers.size());
        assertEquals(Long.valueOf(1),numbers.get(key1));
        assertEquals(Long.valueOf(2),numbers.get(key2));
      }
     }
   }
 }"
55472,"public RemoteMapSupplier(Class<K> kClass,Class<V> vClass) throws IOException {
  serverEndpoint=new ServerEndpoint((byte)1);
  int serverPort=serverEndpoint.getPort();
  context=new RemoteTcpClientChronicleContext(""String_Node_Str"",serverPort);
  map=context.getMap(""String_Node_Str"",kClass,vClass);
}","public RemoteMapSupplier(Class<K> kClass,Class<V> vClass) throws IOException {
  serverEndpoint=new ServerEndpoint((byte)1);
  int serverPort=serverEndpoint.getPort();
  context=new RemoteTcpClientChronicleContext(""String_Node_Str"",serverPort,(byte)2);
  map=context.getMap(""String_Node_Str"",kClass,vClass);
}"
55473,"public RemoteQueueSupplier() throws IOException {
  serverEndpoint=new ServerEndpoint((byte)1);
  int serverPort=serverEndpoint.getPort();
  context=new RemoteTcpClientChronicleContext(""String_Node_Str"",serverPort);
  queue=context.getQueue(""String_Node_Str"");
}","public RemoteQueueSupplier() throws IOException {
  serverEndpoint=new ServerEndpoint((byte)1);
  int serverPort=serverEndpoint.getPort();
  context=new RemoteTcpClientChronicleContext(""String_Node_Str"",serverPort,(byte)2);
  queue=context.getQueue(""String_Node_Str"");
}"
55474,"@Test(timeout=50000) public void testPutAndGet() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    mapProxy.put(1,""String_Node_Str"");
    assertEquals(1,mapProxy.size());
  }
);
}","@Test(timeout=50000) public void testPutAndGet() throws IOException, InterruptedException {
  supplyMap(Integer.class,String.class,mapProxy -> {
    mapProxy.put(1,""String_Node_Str"");
    assertEquals(""String_Node_Str"",mapProxy.get(1));
    assertEquals(1,mapProxy.size());
  }
);
}"
55475,"private <I,KI,VI>I mapInstance(Class<KI> kClass,Class<VI> vClass,short channelID) throws IOException {
  return (I)new ClientWiredChronicleMapStatelessClientBuilder<KI,VI>(hub,kClass,vClass,channelID).create();
}","private <I,KI,VI>I mapInstance(Class<KI> kClass,Class<VI> vClass,short channelID) throws IOException {
  return (I)new ClientWiredChronicleMapStatelessBuilder<KI,VI>(hub,kClass,vClass,channelID).create();
}"
55476,"public RemoteClientServiceLocator(@NotNull String hostname,int port,byte identifier) throws IOException {
  final ClientWiredChronicleMapStatelessClientBuilder<String,ServiceDescriptor> builder=new ClientWiredChronicleMapStatelessClientBuilder<>(new InetSocketAddress(hostname,port),String.class,ServiceDescriptor.class,(short)1);
  builder.identifier(identifier);
  serviceLocator=builder.create();
  hub=builder.hub();
}","public RemoteClientServiceLocator(@NotNull String hostname,int port,byte identifier) throws IOException {
  final ClientWiredChronicleMapStatelessBuilder<String,ServiceDescriptor> builder=new ClientWiredChronicleMapStatelessBuilder<>(new InetSocketAddress(hostname,port),String.class,ServiceDescriptor.class,(short)1);
  builder.identifier(identifier);
  serviceLocator=builder.create();
  hub=builder.hub();
}"
55477,"private static String computeStatus(@Nullable TestResult input){
  String result=input.getResultStatus().name().toLowerCase();
  if (input.getResultStatus() == ResultStatus.PASS && input.getTotalFailureCount() > 0) {
    result=""String_Node_Str"";
  }
  return result;
}","private static String computeStatus(@Nullable TestResult input){
  String result=input.getResultStatus().name().toLowerCase();
  if (input.getResultStatus() == PASS && input.getTotalFailureCount() > 0) {
    result=""String_Node_Str"";
  }
  return result;
}"
55478,"private void generateCssFromLess(){
  try {
    LessCompiler compiler=new LessCompiler();
    String less=Resources.toString(getClass().getResource(""String_Node_Str""),UTF_8);
    String css=compiler.compile(less);
    File cssFile=new File(staticOutput,""String_Node_Str"");
    writeStringToFile(cssFile,css);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","private void generateCssFromLess(){
  try {
    LessCompiler compiler=new LessCompiler();
    String less=Resources.toString(getClass().getResource(""String_Node_Str""),UTF_8);
    String css=compiler.compile(less);
    File cssFile=new File(staticOutput,""String_Node_Str"");
    writeStringToFile(cssFile,css);
  }
 catch (  Exception e) {
    throw new ForkException(e);
  }
}"
55479,"@SuppressWarnings(""String_Node_Str"") @Test public void populatesTestCaseEvents() throws Exception {
  Map<String,String> multiPropertiesMap=new HashMap(){
{
      put(""String_Node_Str"",""String_Node_Str"");
      put(""String_Node_Str"",""String_Node_Str"");
    }
  }
;
  TestSuiteLoader testSuiteLoader=new TestSuiteLoader(ANY_INSTRUMENTATION_APK_FILE,fakeDexFileExtractor,fakeTestClassMatcher);
  assertThat(testSuiteLoader.loadTestSuite(),containsInAnyOrder(sameTestEventAs(""String_Node_Str"",""String_Node_Str"",true),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",true),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false,asList(""String_Node_Str"",""String_Node_Str"")),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",singletonMap(""String_Node_Str"",""String_Node_Str"")),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",multiPropertiesMap)));
}","@SuppressWarnings(""String_Node_Str"") @Test public void populatesTestCaseEvents() throws Exception {
  Map<String,String> multiPropertiesMap=new HashMap();
  multiPropertiesMap.put(""String_Node_Str"",""String_Node_Str"");
  multiPropertiesMap.put(""String_Node_Str"",""String_Node_Str"");
  TestSuiteLoader testSuiteLoader=new TestSuiteLoader(ANY_INSTRUMENTATION_APK_FILE,fakeDexFileExtractor,fakeTestClassMatcher);
  assertThat(testSuiteLoader.loadTestSuite(),containsInAnyOrder(sameTestEventAs(""String_Node_Str"",""String_Node_Str"",true),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",true),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false,asList(""String_Node_Str"",""String_Node_Str"")),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",false),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",singletonMap(""String_Node_Str"",""String_Node_Str"")),sameTestEventAs(""String_Node_Str"",""String_Node_Str"",multiPropertiesMap)));
}"
55480,"public static DexFileExtractor dexFileExtractor(){
  return new DexFileExtractor(configuration().getOutput());
}","public static DexFileExtractor dexFileExtractor(){
  return new ClassesDexFileExtractor(configuration().getOutput());
}"
55481,"static TestClassMatcher testClassMatcher(){
  Configuration configuration=configuration();
  String testPackage=configuration.getTestPackage();
  log.info(""String_Node_Str"",testPackage);
  Pattern testPackagePattern=compilePatternFor(testPackage);
  return new TestClassMatcher(testPackagePattern,configuration.getTestClassPattern());
}","static TestClassMatcher testClassMatcher(){
  Configuration configuration=configuration();
  String testPackage=configuration.getTestPackage();
  log.info(""String_Node_Str"",testPackage);
  Pattern testPackagePattern=compilePatternFor(testPackage);
  return new PackageAndClassNameMatcher(testPackagePattern,configuration.getTestClassPattern());
}"
55482,"private Configuration aConfiguration(int totalRetry,int singleMethodRetry){
  return new Configuration(null,null,null,null,null,null,null,null,0,false,totalRetry,singleMethodRetry);
}","private Configuration aConfiguration(int totalRetry,int singleMethodRetry){
  return new Configuration(null,null,null,null,null,null,null,null,0,false,totalRetry,singleMethodRetry,true);
}"
55483,"public Builder withTestSize(String testSize){
  this.testSize=IRemoteAndroidTestRunner.TestSize.getTestSize(testSize);
  return this;
}","public Builder withTestSize(String testSize){
  this.testSize=(testSize == null ? null : IRemoteAndroidTestRunner.TestSize.getTestSize(testSize));
  return this;
}"
55484,"/** 
 * We need to make sure zero or one strategy has been passed. If zero default to pool per device. If more than one we throw an exception.
 */
private PoolingStrategy validatePoolingStrategy(PoolingStrategy poolingStrategy){
  if (poolingStrategy == null) {
    logger.warn(""String_Node_Str"");
    poolingStrategy=new PoolingStrategy();
    poolingStrategy.eachDevice=true;
  }
 else {
    long selectedStrategies=asList(poolingStrategy.eachDevice,poolingStrategy.splitTablets,poolingStrategy.computed,poolingStrategy.manual).stream().filter(p -> p == null).count();
    if (selectedStrategies > Defaults.STRATEGY_LIMIT) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return poolingStrategy;
}","/** 
 * We need to make sure zero or one strategy has been passed. If zero default to pool per device. If more than one we throw an exception.
 */
private PoolingStrategy validatePoolingStrategy(PoolingStrategy poolingStrategy){
  if (poolingStrategy == null) {
    logger.warn(""String_Node_Str"");
    poolingStrategy=new PoolingStrategy();
    poolingStrategy.eachDevice=true;
  }
 else {
    long selectedStrategies=asList(poolingStrategy.eachDevice,poolingStrategy.splitTablets,poolingStrategy.computed,poolingStrategy.manual).stream().filter(p -> p != null).count();
    if (selectedStrategies > Defaults.STRATEGY_LIMIT) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  return poolingStrategy;
}"
55485,"public boolean run(){
  ExecutorService poolExecutor=null;
  try {
    Collection<Pool> pools=poolLoader.loadPools();
    int numberOfPools=pools.size();
    CountDownLatch poolCountDownLatch=new CountDownLatch(numberOfPools);
    poolExecutor=namedExecutor(numberOfPools,""String_Node_Str"");
    List<TestCaseEvent> testCases=testClassLoader.loadTestClasses();
    summaryGeneratorHook.registerHook(pools,testCases);
    progressReporter.start();
    for (    Pool pool : pools) {
      PoolTestRunner poolTestRunner=poolTestRunnerFactory.createPoolTestRunner(pool,testCases,poolCountDownLatch,progressReporter);
      poolExecutor.execute(poolTestRunner);
    }
    poolCountDownLatch.await();
    progressReporter.stop();
    boolean overallSuccess=summaryGeneratorHook.defineOutcome();
    logger.info(""String_Node_Str"" + overallSuccess);
    return overallSuccess;
  }
 catch (  NoPoolLoaderConfiguredException|NoDevicesForPoolException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
catch (  TestClassScanningException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
 finally {
    if (poolExecutor != null) {
      poolExecutor.shutdown();
    }
  }
}","public boolean run(){
  ExecutorService poolExecutor=null;
  try {
    Collection<Pool> pools=poolLoader.loadPools();
    int numberOfPools=pools.size();
    CountDownLatch poolCountDownLatch=new CountDownLatch(numberOfPools);
    poolExecutor=namedExecutor(numberOfPools,""String_Node_Str"");
    List<TestCaseEvent> testCases=testClassLoader.loadTestClasses();
    summaryGeneratorHook.registerHook(pools,testCases);
    progressReporter.start();
    for (    Pool pool : pools) {
      Runnable poolTestRunner=poolTestRunnerFactory.createPoolTestRunner(pool,testCases,poolCountDownLatch,progressReporter);
      poolExecutor.execute(poolTestRunner);
    }
    poolCountDownLatch.await();
    progressReporter.stop();
    boolean overallSuccess=summaryGeneratorHook.defineOutcome();
    logger.info(""String_Node_Str"" + overallSuccess);
    return overallSuccess;
  }
 catch (  NoPoolLoaderConfiguredException|NoDevicesForPoolException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
catch (  TestClassScanningException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
 finally {
    if (poolExecutor != null) {
      poolExecutor.shutdown();
    }
  }
}"
55486,"public PoolTestRunner createPoolTestRunner(Pool pool,List<TestCaseEvent> testCases,CountDownLatch poolCountDownLatch,ProgressReporter progressReporter){
  int totalTests=testCases.size();
  progressReporter.addPoolProgress(pool,new PoolProgressTrackerImpl(totalTests));
  return new PoolTestRunner(deviceTestRunnerFactory,pool,new LinkedList<>(testCases),poolCountDownLatch,progressReporter);
}","public Runnable createPoolTestRunner(Pool pool,List<TestCaseEvent> testCases,CountDownLatch poolCountDownLatch,ProgressReporter progressReporter){
  int totalTests=testCases.size();
  progressReporter.addPoolProgress(pool,new PoolProgressTrackerImpl(totalTests));
  return new PoolTestRunner(deviceTestRunnerFactory,pool,new LinkedList<>(testCases),poolCountDownLatch,progressReporter);
}"
55487,"private Set<Resource> findPathMatchingKeys(String keyPattern,List<String> matchingBuckets){
  Set<Resource> resources=new HashSet<>();
  if (this.pathMatcher.isPattern(keyPattern)) {
    for (    String bucketName : matchingBuckets) {
      findPathMatchingKeyInBucket(bucketName,resources,null,keyPattern);
    }
  }
 else {
    for (    String matchingBucket : matchingBuckets) {
      Resource resource=this.simpleStorageResourceLoader.getResource(SimpleStorageNameUtils.getLocationForBucketAndObject(matchingBucket,keyPattern));
      if (resource.exists()) {
        resources.add(resource);
      }
    }
  }
  return resources;
}","private Set<Resource> findPathMatchingKeys(String keyPattern,List<String> matchingBuckets){
  Set<Resource> resources=new HashSet<>();
  if (this.pathMatcher.isPattern(keyPattern)) {
    for (    String bucketName : matchingBuckets) {
      findPathMatchingKeyInBucket(bucketName,resources,getValidPrefix(keyPattern),keyPattern);
    }
  }
 else {
    for (    String matchingBucket : matchingBuckets) {
      Resource resource=this.simpleStorageResourceLoader.getResource(SimpleStorageNameUtils.getLocationForBucketAndObject(matchingBucket,keyPattern));
      if (resource.exists()) {
        resources.add(resource);
      }
    }
  }
  return resources;
}"
55488,"@Override public String resolveDestination(String name) throws DestinationResolutionException {
  String queueName=name;
  if (this.resourceIdResolver != null) {
    queueName=this.resourceIdResolver.resolveToPhysicalResourceId(name);
  }
  if (isValidQueueUrl(queueName)) {
    return queueName;
  }
  if (this.autoCreate) {
    CreateQueueResult createQueueResult=this.amazonSqs.createQueue(new CreateQueueRequest(name));
    return createQueueResult.getQueueUrl();
  }
 else {
    try {
      GetQueueUrlResult getQueueUrlResult=this.amazonSqs.getQueueUrl(new GetQueueUrlRequest(name));
      return getQueueUrlResult.getQueueUrl();
    }
 catch (    QueueDoesNotExistException e) {
      throw new DestinationResolutionException(e.getMessage(),e);
    }
  }
}","@Override public String resolveDestination(String name) throws DestinationResolutionException {
  String queueName=name;
  if (this.resourceIdResolver != null) {
    queueName=this.resourceIdResolver.resolveToPhysicalResourceId(name);
  }
  if (isValidQueueUrl(queueName)) {
    return queueName;
  }
  if (this.autoCreate) {
    CreateQueueResult createQueueResult=this.amazonSqs.createQueue(new CreateQueueRequest(queueName));
    return createQueueResult.getQueueUrl();
  }
 else {
    try {
      GetQueueUrlResult getQueueUrlResult=this.amazonSqs.getQueueUrl(new GetQueueUrlRequest(queueName));
      return getQueueUrlResult.getQueueUrl();
    }
 catch (    QueueDoesNotExistException e) {
      throw new DestinationResolutionException(e.getMessage(),e);
    }
  }
}"
55489,"/** 
 * Registers an   {@link com.amazonaws.services.sqs.buffered.AmazonSQSBufferedAsyncClient} client instance under the default bean name {@link #BUFFERED_SQS_CLIENT_BEAN_NAME} of not already registered. Creates a {@link com.amazonaws.services.sqs.buffered.AmazonSQSBufferedAsyncClient} to improveperformance especially while listening to to messages from a queue.
 * @param registry - the bean definition registry to which the bean should be registered. This registry will be checked if there is already a bean definition.
 * @param taskExecutor - the task executor bean name used to create the client, might be null if no external task executor is used.
 * @param regionProvider - regionProvider if a custom is to be configured
 * @param region - region if the region itself is configured
 * @return the {@link org.springframework.beans.factory.config.BeanDefinitionHolder} containing the definition along with the registered bean name
 */
public static BeanDefinitionHolder registerAmazonSqsClient(BeanDefinitionRegistry registry,String taskExecutor,String regionProvider,String region){
  if (!registry.containsBeanDefinition(BUFFERED_SQS_CLIENT_BEAN_NAME)) {
    BeanDefinitionHolder sqsClient=AmazonWebserviceClientConfigurationUtils.registerAmazonWebserviceClient(registry,""String_Node_Str"",regionProvider,region);
    if (StringUtils.hasText(taskExecutor)) {
      BeanDefinitionBuilder executorBuilder=BeanDefinitionBuilder.genericBeanDefinition(SuppressingExecutorServiceAdapter.class);
      sqsClient.getBeanDefinition().getConstructorArgumentValues().addGenericArgumentValue(executorBuilder.getBeanDefinition());
    }
    BeanDefinitionBuilder bufferedClientBuilder=BeanDefinitionBuilder.rootBeanDefinition(AMAZON_BUFFER_CLIENT_CLASS_NAME);
    bufferedClientBuilder.addConstructorArgReference(sqsClient.getBeanName());
    registry.registerBeanDefinition(BUFFERED_SQS_CLIENT_BEAN_NAME,bufferedClientBuilder.getBeanDefinition());
  }
  return new BeanDefinitionHolder(registry.getBeanDefinition(BUFFERED_SQS_CLIENT_BEAN_NAME),BUFFERED_SQS_CLIENT_BEAN_NAME);
}","/** 
 * Registers an   {@link com.amazonaws.services.sqs.buffered.AmazonSQSBufferedAsyncClient} client instance under the default bean name {@link #BUFFERED_SQS_CLIENT_BEAN_NAME} of not already registered. Creates a {@link com.amazonaws.services.sqs.buffered.AmazonSQSBufferedAsyncClient} to improveperformance especially while listening to to messages from a queue.
 * @param registry - the bean definition registry to which the bean should be registered. This registry will be checked if there is already a bean definition.
 * @param taskExecutor - the task executor bean name used to create the client, might be null if no external task executor is used.
 * @param regionProvider - regionProvider if a custom is to be configured
 * @param region - region if the region itself is configured
 * @return the {@link org.springframework.beans.factory.config.BeanDefinitionHolder} containing the definition along with the registered bean name
 */
public static BeanDefinitionHolder registerAmazonSqsClient(BeanDefinitionRegistry registry,String taskExecutor,String regionProvider,String region){
  if (!registry.containsBeanDefinition(BUFFERED_SQS_CLIENT_BEAN_NAME)) {
    BeanDefinitionHolder sqsClient=AmazonWebserviceClientConfigurationUtils.registerAmazonWebserviceClient(registry,""String_Node_Str"",regionProvider,region);
    if (StringUtils.hasText(taskExecutor)) {
      BeanDefinitionBuilder executorBuilder=BeanDefinitionBuilder.genericBeanDefinition(SuppressingExecutorServiceAdapter.class);
      executorBuilder.addConstructorArgReference(taskExecutor);
      sqsClient.getBeanDefinition().getConstructorArgumentValues().addGenericArgumentValue(executorBuilder.getBeanDefinition());
    }
    BeanDefinitionBuilder bufferedClientBuilder=BeanDefinitionBuilder.rootBeanDefinition(AMAZON_BUFFER_CLIENT_CLASS_NAME);
    bufferedClientBuilder.addConstructorArgReference(sqsClient.getBeanName());
    registry.registerBeanDefinition(BUFFERED_SQS_CLIENT_BEAN_NAME,bufferedClientBuilder.getBeanDefinition());
  }
  return new BeanDefinitionHolder(registry.getBeanDefinition(BUFFERED_SQS_CLIENT_BEAN_NAME),BUFFERED_SQS_CLIENT_BEAN_NAME);
}"
55490,"@Test public void parseInternal_customTaskExecutor_shouldCreateContainerAndClientWithCustomTaskExecutor() throws Exception {
  SimpleBeanDefinitionRegistry registry=new SimpleBeanDefinitionRegistry();
  XmlBeanDefinitionReader reader=new XmlBeanDefinitionReader(registry);
  reader.loadBeanDefinitions(new ClassPathResource(getClass().getSimpleName() + ""String_Node_Str"",getClass()));
  BeanDefinition executor=registry.getBeanDefinition(""String_Node_Str"");
  assertNotNull(executor);
  BeanDefinition abstractContainerDefinition=registry.getBeanDefinition(SimpleMessageListenerContainer.class.getName() + ""String_Node_Str"");
  assertNotNull(abstractContainerDefinition);
  assertEquals(4,abstractContainerDefinition.getPropertyValues().size());
  assertEquals(""String_Node_Str"",((RuntimeBeanReference)abstractContainerDefinition.getPropertyValues().getPropertyValue(""String_Node_Str"").getValue()).getBeanName());
}","@Test public void parseInternal_customTaskExecutor_shouldCreateContainerAndClientWithCustomTaskExecutor() throws Exception {
  DefaultListableBeanFactory beanFactory=new DefaultListableBeanFactory();
  XmlBeanDefinitionReader reader=new XmlBeanDefinitionReader(beanFactory);
  reader.loadBeanDefinitions(new ClassPathResource(getClass().getSimpleName() + ""String_Node_Str"",getClass()));
  BeanDefinition executor=beanFactory.getBeanDefinition(""String_Node_Str"");
  assertNotNull(executor);
  BeanDefinition abstractContainerDefinition=beanFactory.getBeanDefinition(SimpleMessageListenerContainer.class.getName() + ""String_Node_Str"");
  assertNotNull(abstractContainerDefinition);
  assertEquals(4,abstractContainerDefinition.getPropertyValues().size());
  assertEquals(""String_Node_Str"",((RuntimeBeanReference)abstractContainerDefinition.getPropertyValues().getPropertyValue(""String_Node_Str"").getValue()).getBeanName());
  AmazonSQSBufferedAsyncClient bufferedAsyncClient=beanFactory.getBean(AmazonSQSBufferedAsyncClient.class);
  assertNotNull(bufferedAsyncClient);
}"
55491,"/** 
 * Set the PathMatcher implementation to use for this resource pattern resolver. Default is AntPathMatcher.
 * @see org.springframework.util.AntPathMatcher
 */
public void setPathMatcher(PathMatcher pathMatcher){
  Assert.notNull(pathMatcher,""String_Node_Str"");
  this.pathMatcher=pathMatcher;
}","/** 
 * Set the PathMatcher implementation to use for this resource pattern resolver. Default is AntPathMatcher.
 * @param pathMatcher The pathMatches implementation used, must not be null
 * @see org.springframework.util.AntPathMatcher
 */
public void setPathMatcher(PathMatcher pathMatcher){
  Assert.notNull(pathMatcher,""String_Node_Str"");
  this.pathMatcher=pathMatcher;
}"
55492,"/** 
 * Destroys the instance if the instance itself implement   {@link DisposableBean}
 * @param instance the instance which has been created by  {@link #createInstance()}
 * @throws Exception
 */
@Override protected final void destroyInstance(Object instance) throws Exception {
  if (instance instanceof DisposableBean) {
    ((DisposableBean)instance).destroy();
  }
}","/** 
 * Destroys the instance if the instance itself implement   {@link DisposableBean}
 * @param instance the instance which has been created by  {@link #createInstance()}
 * @throws Exception if the underlying disposable bean throws one
 */
@Override protected final void destroyInstance(Object instance) throws Exception {
  if (instance instanceof DisposableBean) {
    ((DisposableBean)instance).destroy();
  }
}"
55493,"/** 
 * Create a default TaskExecutor. Called if no explicit TaskExecutor has been specified. <p>The default implementation builds a   {@link org.springframework.core.task.SimpleAsyncTaskExecutor}with the specified bean name (or the class name, if no bean name specified) as thread name prefix.
 * @see org.springframework.core.task.SimpleAsyncTaskExecutor#SimpleAsyncTaskExecutor(String)
 */
protected TaskExecutor createDefaultTaskExecutor(){
  String beanName=getBeanName();
  String threadNamePrefix=(beanName != null ? beanName + ""String_Node_Str"" : DEFAULT_THREAD_NAME_PREFIX);
  return new SimpleAsyncTaskExecutor(threadNamePrefix);
}","/** 
 * Create a default TaskExecutor. Called if no explicit TaskExecutor has been specified. <p>The default implementation builds a   {@link org.springframework.core.task.SimpleAsyncTaskExecutor}with the specified bean name (or the class name, if no bean name specified) as thread name prefix.
 * @return a {@link org.springframework.core.task.SimpleAsyncTaskExecutor} configured with the thread name prefix
 * @see org.springframework.core.task.SimpleAsyncTaskExecutor#SimpleAsyncTaskExecutor(String)
 */
protected TaskExecutor createDefaultTaskExecutor(){
  String beanName=getBeanName();
  String threadNamePrefix=(beanName != null ? beanName + ""String_Node_Str"" : DEFAULT_THREAD_NAME_PREFIX);
  return new SimpleAsyncTaskExecutor(threadNamePrefix);
}"
55494,"/** 
 * Resolves the provided logical resource id to the corresponding physical resource id. If the implementation is unable to resolve the logical resource id to a physical one based on the specific resource information available, the logical resource id is returned as the physical one. <p/> This resolving mechanism provides no guarantees on existence of the resource denoted by the resolved physical resource id.
 * @param logicalResourceId the logical resource id to be resolved
 * @return the physical resource id
 */
String resolveToPhysicalResourceId(String logicalResourceId);","/** 
 * Resolves the provided logical resource id to the corresponding physical resource id. If the implementation is unable to resolve the logical resource id to a physical one based on the specific resource information available, the logical resource id is returned as the physical one. <p> This resolving mechanism provides no guarantees on existence of the resource denoted by the resolved physical resource id. </p>
 * @param logicalResourceId the logical resource id to be resolved
 * @return the physical resource id
 */
String resolveToPhysicalResourceId(String logicalResourceId);"
55495,"/** 
 * Configures the maximum number of retries. This number should be a trade-off between having enough retries to survive a database outage due to failure and a responsive and not stalling application. The default value for the maximum number is 3. <p/> <p><b>Note:</b>Consider using a   {@link BackOffPolicy} which ensures that there isenough time left between the retry attempts instead of increasing this value to a high number. The back-off policy ensures that there is a delay in between the retry operations.</p>
 * @param maxNumberOfRetries - the maximum number of retries should be a positive number, otherwise all retries will fail.
 */
public void setMaxNumberOfRetries(int maxNumberOfRetries){
  this.maxNumberOfRetries=maxNumberOfRetries;
}","/** 
 * Configures the maximum number of retries. This number should be a trade-off between having enough retries to survive a database outage due to failure and a responsive and not stalling application. The default value for the maximum number is 3. <p><b>Note:</b>Consider using a   {@link BackOffPolicy} which ensures that there isenough time left between the retry attempts instead of increasing this value to a high number. The back-off policy ensures that there is a delay in between the retry operations.</p>
 * @param maxNumberOfRetries - the maximum number of retries should be a positive number, otherwise all retries will fail.
 */
public void setMaxNumberOfRetries(int maxNumberOfRetries){
  this.maxNumberOfRetries=maxNumberOfRetries;
}"
55496,"private boolean isRetryAbleException(Throwable throwable){
  boolean retryAble=this.binaryExceptionClassifier.classify(throwable);
  if (!retryAble) {
    if (LOGGER.isTraceEnabled()) {
      LOGGER.trace(""String_Node_Str"",throwable.getClass().getName());
    }
    if (throwable.getCause() != null) {
      return isRetryAbleException(throwable.getCause());
    }
    return false;
  }
 else {
    if (LOGGER.isTraceEnabled()) {
      LOGGER.trace(""String_Node_Str"",throwable.getClass().getName());
    }
    return retryAble;
  }
}","private boolean isRetryAbleException(Throwable throwable){
  boolean retryAble=this.binaryExceptionClassifier.classify(throwable);
  if (!retryAble) {
    if (LOGGER.isTraceEnabled()) {
      LOGGER.trace(""String_Node_Str"",throwable.getClass().getName());
    }
    if (throwable.getCause() != null) {
      return isRetryAbleException(throwable.getCause());
    }
    return false;
  }
 else {
    if (LOGGER.isTraceEnabled()) {
      LOGGER.trace(""String_Node_Str"",throwable.getClass().getName());
    }
    return true;
  }
}"
55497,"/** 
 * Constructs this base class with all collaborators and configuration information. This constructor creates and uses a  {@link DynamicTopicDestinationResolver} which will be used to resolve the topic arn based on the logical topicname.
 * @param amazonSns - the Amazon SNS client used, must not be null
 * @param topicName - the topic name which can be the logical topic name (e.g. ""myTopic"") or the topic arn which is the fully qualified name following the amazon resource notation.
 * @param protocol - the protocol for which the endpoint will be configured. This class will only check if there is a valid subscription based on the protocol and subscription available, but will not execute any protocol specific behaviour. The value must not be null
 * @param endpoint - the endpoint address for this endpoint. The endpoint address must match to a valid subscription. The value must not be null
 * @param target - the target bean which will be called by the endpoint. The bean could by of any type as long it is accessible. Must not be null
 * @param method - the method name that will be called by the endpoint. The method must exist and be accessible on the target object. Must not be null
 * @throws IllegalArgumentException if one of the mandatory parameters is null
 */
AbstractNotificationEndpointFactoryBean(AmazonSNS amazonSns,String topicName,TopicListener.NotificationProtocol protocol,String endpoint,Object target,String method){
  Assert.notNull(amazonSns,""String_Node_Str"");
  Assert.notNull(topicName,""String_Node_Str"");
  Assert.notNull(protocol,""String_Node_Str"");
  Assert.notNull(endpoint,""String_Node_Str"");
  Assert.notNull(method,""String_Node_Str"");
  this.amazonSns=amazonSns;
  this.topicName=topicName;
  this.protocol=protocol;
  this.endpoint=endpoint;
  this.target=target;
  this.method=method;
  this.destinationResolver=new CachingDestinationResolver(new DynamicTopicDestinationResolver(amazonSns));
}","/** 
 * Constructs this base class with all collaborators and configuration information. This constructor creates and uses a  {@link DynamicTopicDestinationResolver} which will be used to resolve the topic arn based on the logical topicname.
 * @param amazonSns - the Amazon SNS client used, must not be null
 * @param topicName - the topic name which can be the logical topic name (e.g. ""myTopic"") or the topic arn which is the fully qualified name following the amazon resource notation.
 * @param protocol - the protocol for which the endpoint will be configured. This class will only check if there is a valid subscription based on the protocol and subscription available, but will not execute any protocol specific behaviour. The value must not be null
 * @param endpoint - the endpoint address for this endpoint. The endpoint address must match to a valid subscription. The value must not be null
 * @param target - the target bean which will be called by the endpoint. The bean could by of any type as long it is accessible. Must not be null
 * @param method - the method name that will be called by the endpoint. The method must exist and be accessible on the target object. Must not be null
 * @throws IllegalArgumentException if one of the mandatory parameters is null
 */
AbstractNotificationEndpointFactoryBean(AmazonSNS amazonSns,String topicName,TopicListener.NotificationProtocol protocol,String endpoint,Object target,String method){
  Assert.notNull(amazonSns,""String_Node_Str"");
  Assert.notNull(topicName,""String_Node_Str"");
  Assert.notNull(protocol,""String_Node_Str"");
  Assert.notNull(endpoint,""String_Node_Str"");
  Assert.notNull(method,""String_Node_Str"");
  this.amazonSns=amazonSns;
  this.topicName=topicName;
  this.protocol=protocol;
  this.endpoint=endpoint;
  this.target=target;
  this.method=method;
  this.destinationResolver=new CachingDestinationResolver<MessageChannel>(new DynamicTopicDestinationResolver(amazonSns));
}"
55498,"@Test public void testDestinationResolverIsCreatedIfNull() throws Exception {
  AbstractMessageListenerContainer container=new StubAbstractMessageListenerContainer();
  container.setAmazonSqs(Mockito.mock(AmazonSQSAsync.class));
  container.setMessageListener(Mockito.mock(MessageListener.class));
  container.setDestinationName(""String_Node_Str"");
  container.afterPropertiesSet();
  DestinationResolver destinationResolver=container.getDestinationResolver();
  Assert.assertNotNull(destinationResolver);
  Assert.assertTrue(CachingDestinationResolver.class.isInstance(destinationResolver));
}","@Test public void testDestinationResolverIsCreatedIfNull() throws Exception {
  AbstractMessageListenerContainer container=new StubAbstractMessageListenerContainer();
  container.setAmazonSqs(Mockito.mock(AmazonSQSAsync.class));
  container.setMessageListener(Mockito.mock(MessageListener.class));
  container.setDestinationName(""String_Node_Str"");
  container.afterPropertiesSet();
  DestinationResolver<String> destinationResolver=container.getDestinationResolver();
  Assert.assertNotNull(destinationResolver);
  Assert.assertTrue(CachingDestinationResolver.class.isInstance(destinationResolver));
}"
55499,"private static String nullSafeGetTextValue(JsonNode jsonNode,String attribute){
  return jsonNode.has(attribute) ? jsonNode.get(attribute).getValueAsText() : null;
}","private static String nullSafeGetTextValue(JsonNode jsonNode,String attribute){
  return jsonNode.has(attribute) ? jsonNode.get(attribute).asText() : null;
}"
55500,"@Override public NotificationMessage fromMessage(Message<String> message){
  try {
    JsonNode jsonNode=this.objectMapper.readValue(message.getPayload(),JsonNode.class);
    if (!jsonNode.has(""String_Node_Str"")) {
      throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"");
    }
    if (!""String_Node_Str"".equals(jsonNode.get(""String_Node_Str"").getTextValue())) {
      throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"");
    }
    if (!jsonNode.has(""String_Node_Str"")) {
      throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"");
    }
    return new NotificationMessage(nullSafeGetTextValue(jsonNode,""String_Node_Str""),nullSafeGetTextValue(jsonNode,""String_Node_Str""));
  }
 catch (  IOException e) {
    throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"",e);
  }
}","@Override public NotificationMessage fromMessage(Message<String> message){
  try {
    JsonNode jsonNode=this.objectMapper.readValue(message.getPayload(),JsonNode.class);
    if (!jsonNode.has(""String_Node_Str"")) {
      throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"");
    }
    if (!""String_Node_Str"".equals(jsonNode.get(""String_Node_Str"").asText())) {
      throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"");
    }
    if (!jsonNode.has(""String_Node_Str"")) {
      throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"");
    }
    return new NotificationMessage(nullSafeGetTextValue(jsonNode,""String_Node_Str""),nullSafeGetTextValue(jsonNode,""String_Node_Str""));
  }
 catch (  IOException e) {
    throw new MessageConversionException(""String_Node_Str"" + message.getPayload() + ""String_Node_Str"",e);
  }
}"
55501,"private static void addRegionProviderBeanDefinition(Element element,ParserContext parserContext,BeanDefinitionBuilder parent){
  if (StringUtils.hasText(element.getAttribute(""String_Node_Str"")) && StringUtils.hasText(element.getAttribute(""String_Node_Str""))) {
    parserContext.getReaderContext().error(""String_Node_Str"",element);
    return;
  }
  if (StringUtils.hasText(element.getAttribute(""String_Node_Str""))) {
    parent.addConstructorArgReference(element.getAttribute(""String_Node_Str""));
    return;
  }
  BeanDefinitionBuilder beanDefinitionBuilder=BeanDefinitionBuilder.rootBeanDefinition(StaticRegionProvider.class);
  if (StringUtils.hasText(element.getAttribute(""String_Node_Str""))) {
    beanDefinitionBuilder.addConstructorArgValue(S3ServiceEndpoint.valueOf(element.getAttribute(""String_Node_Str"")));
    parent.addConstructorArgValue(beanDefinitionBuilder.getBeanDefinition());
  }
 else {
    beanDefinitionBuilder.addConstructorArgValue(S3ServiceEndpoint.US_STANDARD);
  }
  parent.addConstructorArgValue(beanDefinitionBuilder.getBeanDefinition());
}","private static void addRegionProviderBeanDefinition(Element element,ParserContext parserContext,BeanDefinitionBuilder parent){
  if (StringUtils.hasText(element.getAttribute(""String_Node_Str"")) && StringUtils.hasText(element.getAttribute(""String_Node_Str""))) {
    parserContext.getReaderContext().error(""String_Node_Str"",element);
    return;
  }
  if (StringUtils.hasText(element.getAttribute(""String_Node_Str""))) {
    parent.addConstructorArgReference(element.getAttribute(""String_Node_Str""));
    return;
  }
  BeanDefinitionBuilder beanDefinitionBuilder=BeanDefinitionBuilder.rootBeanDefinition(StaticRegionProvider.class);
  if (StringUtils.hasText(element.getAttribute(""String_Node_Str""))) {
    beanDefinitionBuilder.addConstructorArgValue(Region.valueOf(element.getAttribute(""String_Node_Str"")));
    parent.addConstructorArgValue(beanDefinitionBuilder.getBeanDefinition());
  }
 else {
    beanDefinitionBuilder.addConstructorArgValue(Region.US_STANDARD);
  }
  parent.addConstructorArgValue(beanDefinitionBuilder.getBeanDefinition());
}"
55502,"private void createBucketWithFile(String bucketName,Region region){
  this.amazonS3.createBucket(bucketName,region);
  ObjectMetadata objectMetadata=new ObjectMetadata();
  objectMetadata.setContentLength(bucketName.getBytes().length);
  this.amazonS3.putObject(bucketName,DEFAULT_FILENAME,new ByteArrayInputStream(bucketName.getBytes()),objectMetadata);
}","private void createBucketWithFile(String bucketName,Region region){
  if (!isBucketAlreadyExisting(bucketName)) {
    this.amazonS3.createBucket(bucketName,region);
  }
  ObjectMetadata objectMetadata=new ObjectMetadata();
  objectMetadata.setContentLength(bucketName.getBytes().length);
  this.amazonS3.putObject(bucketName,DEFAULT_FILENAME,new ByteArrayInputStream(bucketName.getBytes()),objectMetadata);
}"
55503,"public AmazonEC2PropertyPlaceHolder(String accessKey,String secretKey,InstanceIdProvider instanceIdProvider){
  this.amazonEC2=new AmazonEC2Client(new BasicAWSCredentials(accessKey,secretKey));
  this.instanceIdProvider=instanceIdProvider;
}","public AmazonEC2PropertyPlaceHolder(String accessKey,String secretKey,InstanceIdProvider instanceIdProvider){
  this.amazonEC2=new AmazonEC2Client(new BasicAWSCredentials(accessKey,secretKey));
  this.instanceIdProvider=instanceIdProvider;
  super.setValueSeparator(DEFAULT_VALUE_SEPARATOR);
}"
55504,"public void afterPropertiesSet() throws Exception {
  String currentInstanceId=this.instanceIdProvider.getCurrentInstanceId();
  if (this.resolveUserDataForInstance) {
    this.instanceUserAttributes=new HashMap<String,String>();
    DescribeInstanceAttributeResult attributes=this.getAmazonEC2().describeInstanceAttribute(new DescribeInstanceAttributeRequest(currentInstanceId,USER_DATA_ATTRIBUTE_NAME));
    String encodedUserData=attributes.getInstanceAttribute().getUserData();
    if (StringUtils.hasText(encodedUserData)) {
      byte[] bytes=Base64.decodeBase64(encodedUserData);
      String userData=new String(bytes,this.userDataAttributeEncoding);
      String[] userDataAttributes=userData.split(this.userDataAttributeSeparator);
      for (      String userDataAttribute : userDataAttributes) {
        String[] userDataAttributesParts=StringUtils.split(userDataAttribute,this.valueSeparator);
        String key=userDataAttributesParts[0];
        String value=userDataAttributesParts[1];
        this.instanceUserAttributes.put(key,value);
      }
    }
  }
  if (this.resolveUserTagsForInstance) {
    this.instanceUserTags=new HashMap<String,String>();
    DescribeInstancesResult describeInstancesResult=this.getAmazonEC2().describeInstances(new DescribeInstancesRequest().withInstanceIds(currentInstanceId));
    for (    Reservation reservation : describeInstancesResult.getReservations()) {
      for (      Instance instance : reservation.getInstances()) {
        if (instance.getInstanceId().equals(currentInstanceId)) {
          for (          Tag tag : instance.getTags()) {
            this.instanceUserTags.put(tag.getKey(),tag.getValue());
          }
          break;
        }
      }
    }
  }
}","public void afterPropertiesSet() throws Exception {
  String currentInstanceId=this.instanceIdProvider.getCurrentInstanceId();
  if (this.resolveUserDataForInstance) {
    this.instanceUserAttributes=new HashMap<String,String>();
    DescribeInstanceAttributeResult attributes=this.getAmazonEC2().describeInstanceAttribute(new DescribeInstanceAttributeRequest(currentInstanceId,USER_DATA_ATTRIBUTE_NAME));
    if (attributes != null) {
      String encodedUserData=attributes.getInstanceAttribute().getUserData();
      if (StringUtils.hasText(encodedUserData)) {
        byte[] bytes=Base64.decodeBase64(encodedUserData);
        String userData=new String(bytes,this.userDataAttributeEncoding);
        String[] userDataAttributes=userData.split(this.userDataAttributeSeparator);
        for (        String userDataAttribute : userDataAttributes) {
          String[] userDataAttributesParts=StringUtils.split(userDataAttribute,this.valueSeparator);
          String key=userDataAttributesParts[0];
          String value=userDataAttributesParts[1];
          this.instanceUserAttributes.put(key,value);
        }
      }
    }
  }
  if (this.resolveUserTagsForInstance) {
    this.instanceUserTags=new HashMap<String,String>();
    DescribeInstancesResult describeInstancesResult=this.getAmazonEC2().describeInstances(new DescribeInstancesRequest().withInstanceIds(currentInstanceId));
    for (    Reservation reservation : describeInstancesResult.getReservations()) {
      for (      Instance instance : reservation.getInstances()) {
        if (instance.getInstanceId().equals(currentInstanceId)) {
          for (          Tag tag : instance.getTags()) {
            this.instanceUserTags.put(tag.getKey(),tag.getValue());
          }
          break;
        }
      }
    }
  }
}"
55505,"public Object invoke(Object target,Method method,Object[] arguments) throws Throwable {
  if (method.getDeclaringClass() == ResourceLoader.class) {
    return ReflectionUtils.invokeMethod(method,this.resourceLoader,arguments);
  }
  return ReflectionUtils.invokeMethod(method,this.delegate,arguments);
}","public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  if (method.getDeclaringClass() == ResourceLoader.class) {
    return ReflectionUtils.invokeMethod(method,this.resourceLoader,args);
  }
  return ReflectionUtils.invokeMethod(method,this.delegate,args);
}"
55506,"@Override public long contentLength() throws IOException {
  assertThatResourceExists();
  return objectMetadata.getContentLength();
}","@Override public long contentLength() throws IOException {
  assertThatResourceExists();
  return this.objectMetadata.getContentLength();
}"
55507,"@Override public long lastModified() throws IOException {
  assertThatResourceExists();
  return objectMetadata.getLastModified().getTime();
}","@Override public long lastModified() throws IOException {
  assertThatResourceExists();
  return this.objectMetadata.getLastModified().getTime();
}"
55508,"public Resource getResource(String location){
  if (location.startsWith(S3_PROTOCOL_PREFIX)) {
    Matcher matcher=S3_LOCATION_PATTERN.matcher(location);
    if (matcher.matches()) {
      return new SimpleStorageResource(getBucketNameFromUri(matcher),getObjectNameFromUri(matcher),this.getAmazonS3());
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + location + ""String_Node_Str"");
    }
  }
  return delegate.getResource(location);
}","public Resource getResource(String location){
  if (location.startsWith(S3_PROTOCOL_PREFIX)) {
    Matcher matcher=S3_LOCATION_PATTERN.matcher(location);
    if (matcher.matches()) {
      return new SimpleStorageResource(getBucketNameFromUri(matcher),getObjectNameFromUri(matcher),this.getAmazonS3());
    }
 else {
      throw new IllegalArgumentException(String.format(""String_Node_Str"",location));
    }
  }
  return this.delegate.getResource(location);
}"
55509,"public ClassLoader getClassLoader(){
  return delegate.getClassLoader();
}","public ClassLoader getClassLoader(){
  return this.delegate.getClassLoader();
}"
55510,"public void handle(HttpExchange httpExchange) throws IOException {
  httpExchange.sendResponseHeaders(200,this.result.length());
  OutputStream outputStream=httpExchange.getResponseBody();
  OutputStreamWriter outputStreamWriter=new OutputStreamWriter(outputStream);
  outputStreamWriter.write(this.result);
  outputStreamWriter.flush();
  httpExchange.close();
}","public void handle(HttpExchange exchange) throws IOException {
  exchange.sendResponseHeaders(200,this.result.length());
  OutputStream outputStream=exchange.getResponseBody();
  OutputStreamWriter outputStreamWriter=new OutputStreamWriter(outputStream);
  outputStreamWriter.write(this.result);
  outputStreamWriter.flush();
  exchange.close();
}"
55511,"@Test public void testResolveUserTagProperties() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserDataForInstance(false);
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstancesRequest describeInstancesRequest=new DescribeInstancesRequest().withInstanceIds(""String_Node_Str"");
  Instance targetInstance=new Instance().withTags(new Tag(""String_Node_Str"",""String_Node_Str""),new Tag(""String_Node_Str"",""String_Node_Str"")).withInstanceId(""String_Node_Str"");
  Instance anotherInstanceInSameReservation=new Instance().withTags(new Tag(""String_Node_Str"",""String_Node_Str"")).withInstanceId(""String_Node_Str"");
  Reservation reservation=new Reservation().withInstances(targetInstance,anotherInstanceInSameReservation);
  DescribeInstancesResult describeInstancesResult=new DescribeInstancesResult().withReservations(reservation);
  Mockito.when(amazonEC2.describeInstances(Matchers.refEq(describeInstancesRequest))).thenReturn(describeInstancesResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
  Assert.assertNull(amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
}","@Test public void testResolveUserTagProperties() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserDataForInstance(false);
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstancesRequest describeInstancesRequest=new DescribeInstancesRequest().withInstanceIds(""String_Node_Str"");
  Instance targetInstance=new Instance().withTags(new Tag(""String_Node_Str"",""String_Node_Str""),new Tag(""String_Node_Str"",""String_Node_Str"")).withInstanceId(""String_Node_Str"");
  Instance anotherInstanceInSameReservation=new Instance().withTags(new Tag(""String_Node_Str"",""String_Node_Str"")).withInstanceId(""String_Node_Str"");
  Reservation reservation=new Reservation().withInstances(targetInstance,anotherInstanceInSameReservation);
  DescribeInstancesResult describeInstancesResult=new DescribeInstancesResult().withReservations(reservation);
  Mockito.when(amazonEC2.describeInstances(describeInstancesRequest)).thenReturn(describeInstancesResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
  Assert.assertNull(amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
}"
55512,"@Test public void testResolveUserWithCustomSeparatorsAndCharset() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserTagsForInstance(false);
  amazonEC2PropertyPlaceHolder.setUserDataAttributeEncoding(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setUserDataAttributeSeparator(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setValueSeparator(""String_Node_Str"");
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstanceAttributeRequest describeInstanceAttributeRequest=new DescribeInstanceAttributeRequest(""String_Node_Str"",AmazonEC2PropertyPlaceHolder.USER_DATA_ATTRIBUTE_NAME);
  String encodedUserData=Base64.encodeBase64String(""String_Node_Str"".getBytes(Charset.forName(""String_Node_Str"")));
  DescribeInstanceAttributeResult describeInstanceAttributeResult=new DescribeInstanceAttributeResult().withInstanceAttribute(new InstanceAttribute().withUserData(encodedUserData));
  Mockito.when(amazonEC2.describeInstanceAttribute(Matchers.refEq(describeInstanceAttributeRequest))).thenReturn(describeInstanceAttributeResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
}","@Test public void testResolveUserWithCustomSeparatorsAndCharset() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserTagsForInstance(false);
  amazonEC2PropertyPlaceHolder.setUserDataAttributeEncoding(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setUserDataAttributeSeparator(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setValueSeparator(""String_Node_Str"");
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstanceAttributeRequest describeInstanceAttributeRequest=new DescribeInstanceAttributeRequest(""String_Node_Str"",AmazonEC2PropertyPlaceHolder.USER_DATA_ATTRIBUTE_NAME);
  String encodedUserData=Base64.encodeBase64String(""String_Node_Str"".getBytes(Charset.forName(""String_Node_Str"")));
  DescribeInstanceAttributeResult describeInstanceAttributeResult=new DescribeInstanceAttributeResult().withInstanceAttribute(new InstanceAttribute().withUserData(encodedUserData));
  Mockito.when(amazonEC2.describeInstanceAttribute(describeInstanceAttributeRequest)).thenReturn(describeInstanceAttributeResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
}"
55513,"@Test public void testResolveUserWithOutUserDataDefinedForInstance() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserTagsForInstance(false);
  amazonEC2PropertyPlaceHolder.setUserDataAttributeEncoding(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setUserDataAttributeSeparator(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setValueSeparator(""String_Node_Str"");
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstanceAttributeRequest describeInstanceAttributeRequest=new DescribeInstanceAttributeRequest(""String_Node_Str"",AmazonEC2PropertyPlaceHolder.USER_DATA_ATTRIBUTE_NAME);
  DescribeInstanceAttributeResult describeInstanceAttributeResult=new DescribeInstanceAttributeResult().withInstanceAttribute(new InstanceAttribute().withUserData(null));
  Mockito.when(amazonEC2.describeInstanceAttribute(Matchers.refEq(describeInstanceAttributeRequest))).thenReturn(describeInstanceAttributeResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertNull(amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
}","@Test public void testResolveUserWithOutUserDataDefinedForInstance() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserTagsForInstance(false);
  amazonEC2PropertyPlaceHolder.setUserDataAttributeEncoding(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setUserDataAttributeSeparator(""String_Node_Str"");
  amazonEC2PropertyPlaceHolder.setValueSeparator(""String_Node_Str"");
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstanceAttributeRequest describeInstanceAttributeRequest=new DescribeInstanceAttributeRequest(""String_Node_Str"",AmazonEC2PropertyPlaceHolder.USER_DATA_ATTRIBUTE_NAME);
  DescribeInstanceAttributeResult describeInstanceAttributeResult=new DescribeInstanceAttributeResult().withInstanceAttribute(new InstanceAttribute().withUserData(null));
  Mockito.when(amazonEC2.describeInstanceAttribute(describeInstanceAttributeRequest)).thenReturn(describeInstanceAttributeResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertNull(amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
}"
55514,"@Test public void testResolveUserDataProperties() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserTagsForInstance(false);
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstanceAttributeRequest describeInstanceAttributeRequest=new DescribeInstanceAttributeRequest(""String_Node_Str"",AmazonEC2PropertyPlaceHolder.USER_DATA_ATTRIBUTE_NAME);
  String encodedUserData=Base64.encodeBase64String(""String_Node_Str"".getBytes(""String_Node_Str""));
  DescribeInstanceAttributeResult describeInstanceAttributeResult=new DescribeInstanceAttributeResult().withInstanceAttribute(new InstanceAttribute().withUserData(encodedUserData));
  Mockito.when(amazonEC2.describeInstanceAttribute(Matchers.refEq(describeInstanceAttributeRequest))).thenReturn(describeInstanceAttributeResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",null));
}","@Test public void testResolveUserDataProperties() throws Exception {
  AmazonEC2 amazonEC2=Mockito.mock(AmazonEC2.class);
  InstanceIdProvider instanceIdProvider=Mockito.mock(InstanceIdProvider.class);
  AmazonEC2PropertyPlaceHolder amazonEC2PropertyPlaceHolder=getAmazonEC2PropertyPlaceHolder(""String_Node_Str"",""String_Node_Str"",amazonEC2,instanceIdProvider);
  amazonEC2PropertyPlaceHolder.setResolveUserTagsForInstance(false);
  Mockito.when(instanceIdProvider.getCurrentInstanceId()).thenReturn(""String_Node_Str"");
  DescribeInstanceAttributeRequest describeInstanceAttributeRequest=new DescribeInstanceAttributeRequest(""String_Node_Str"",AmazonEC2PropertyPlaceHolder.USER_DATA_ATTRIBUTE_NAME);
  String encodedUserData=Base64.encodeBase64String(""String_Node_Str"".getBytes(""String_Node_Str""));
  DescribeInstanceAttributeResult describeInstanceAttributeResult=new DescribeInstanceAttributeResult().withInstanceAttribute(new InstanceAttribute().withUserData(encodedUserData));
  Mockito.when(amazonEC2.describeInstanceAttribute(describeInstanceAttributeRequest)).thenReturn(describeInstanceAttributeResult);
  amazonEC2PropertyPlaceHolder.afterPropertiesSet();
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
  Assert.assertEquals(""String_Node_Str"",amazonEC2PropertyPlaceHolder.resolvePlaceholder(""String_Node_Str"",new Properties()));
}"
55515,"@Test public void testCreate() throws Exception {
  AWSElasticBeanstalk awsElasticBeanstalk=new AWSElasticBeanstalkClient(new PropertiesCredentials(new ClassPathResource(""String_Node_Str"").getInputStream()));
  CheckDNSAvailabilityResult checkDNSAvailabilityResult=awsElasticBeanstalk.checkDNSAvailability(new CheckDNSAvailabilityRequest(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + checkDNSAvailabilityResult.getAvailable());
  System.out.println(""String_Node_Str"" + checkDNSAvailabilityResult.getFullyQualifiedCNAME());
  ListAvailableSolutionStacksResult listAvailableSolutionStacksResult=awsElasticBeanstalk.listAvailableSolutionStacks();
  DescribeConfigurationOptionsResult configurationOptionsResult=awsElasticBeanstalk.describeConfigurationOptions(new DescribeConfigurationOptionsRequest().withApplicationName(""String_Node_Str"").withTemplateName(""String_Node_Str""));
  configurationOptionsResult=awsElasticBeanstalk.describeConfigurationOptions(new DescribeConfigurationOptionsRequest().withSolutionStackName(""String_Node_Str""));
  DescribeConfigurationSettingsResult describeConfigurationSettingsResult=awsElasticBeanstalk.describeConfigurationSettings(new DescribeConfigurationSettingsRequest().withApplicationName(""String_Node_Str"").withTemplateName(""String_Node_Str""));
  for (  ConfigurationSettingsDescription description : describeConfigurationSettingsResult.getConfigurationSettings()) {
    System.out.println(""String_Node_Str"" + description);
    Collections.sort(description.getOptionSettings(),new Comparator<ConfigurationOptionSetting>(){
      public int compare(      ConfigurationOptionSetting o,      ConfigurationOptionSetting o1){
        return o.getNamespace().compareTo(o1.getNamespace());
      }
    }
);
    for (    ConfigurationOptionSetting setting : description.getOptionSettings()) {
      System.out.println(""String_Node_Str"" + setting);
    }
  }
  DescribeEnvironmentsResult describeEnvironmentsResult=awsElasticBeanstalk.describeEnvironments(new DescribeEnvironmentsRequest().withEnvironmentIds(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + describeEnvironmentsResult);
  DescribeEnvironmentResourcesResult describeEnvironmentResourcesResult=awsElasticBeanstalk.describeEnvironmentResources(new DescribeEnvironmentResourcesRequest().withEnvironmentId(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + describeEnvironmentResourcesResult);
  AmazonEC2 amazonEC2=new AmazonEC2Client(new PropertiesCredentials(new ClassPathResource(""String_Node_Str"").getInputStream()));
  DescribeInstancesResult instancesResult=amazonEC2.describeInstances(new DescribeInstancesRequest().withInstanceIds(""String_Node_Str""));
  for (  Reservation reservation : instancesResult.getReservations()) {
    System.out.println(""String_Node_Str"" + reservation);
    for (    Instance instance : reservation.getInstances()) {
    }
  }
}","@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testCreate() throws Exception {
  AWSElasticBeanstalk awsElasticBeanstalk=new AWSElasticBeanstalkClient(new PropertiesCredentials(new ClassPathResource(""String_Node_Str"").getInputStream()));
  CheckDNSAvailabilityResult checkDNSAvailabilityResult=awsElasticBeanstalk.checkDNSAvailability(new CheckDNSAvailabilityRequest(""String_Node_Str""));
  ListAvailableSolutionStacksResult listAvailableSolutionStacksResult=awsElasticBeanstalk.listAvailableSolutionStacks();
  DescribeConfigurationOptionsResult configurationOptionsResult=awsElasticBeanstalk.describeConfigurationOptions(new DescribeConfigurationOptionsRequest().withApplicationName(""String_Node_Str"").withTemplateName(""String_Node_Str""));
  DescribeConfigurationSettingsResult describeConfigurationSettingsResult=awsElasticBeanstalk.describeConfigurationSettings(new DescribeConfigurationSettingsRequest().withApplicationName(""String_Node_Str"").withTemplateName(""String_Node_Str""));
  for (  ConfigurationSettingsDescription description : describeConfigurationSettingsResult.getConfigurationSettings()) {
    System.out.println(""String_Node_Str"" + description);
    Collections.sort(description.getOptionSettings(),new Comparator<ConfigurationOptionSetting>(){
      public int compare(      ConfigurationOptionSetting o,      ConfigurationOptionSetting o1){
        return o.getNamespace().compareTo(o1.getNamespace());
      }
    }
);
    for (    ConfigurationOptionSetting setting : description.getOptionSettings()) {
      System.out.println(""String_Node_Str"" + setting);
    }
  }
  DescribeEnvironmentsResult describeEnvironmentsResult=awsElasticBeanstalk.describeEnvironments(new DescribeEnvironmentsRequest().withEnvironmentIds(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + describeEnvironmentsResult);
  DescribeEnvironmentResourcesResult describeEnvironmentResourcesResult=awsElasticBeanstalk.describeEnvironmentResources(new DescribeEnvironmentResourcesRequest().withEnvironmentId(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + describeEnvironmentResourcesResult);
  AmazonEC2 amazonEC2=new AmazonEC2Client(new PropertiesCredentials(new ClassPathResource(""String_Node_Str"").getInputStream()));
  DescribeInstancesResult instancesResult=amazonEC2.describeInstances(new DescribeInstancesRequest().withInstanceIds(""String_Node_Str""));
  for (  Reservation reservation : instancesResult.getReservations()) {
    System.out.println(""String_Node_Str"" + reservation);
    for (    Instance instance : reservation.getInstances()) {
    }
  }
}"
55516,"@org.junit.Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testSendMail() throws Exception {
  SimpleMailMessage simpleMailMessage=new SimpleMailMessage();
  simpleMailMessage.setFrom(this.senderAddress);
  simpleMailMessage.setTo(this.recipientAddress);
  simpleMailMessage.setSubject(""String_Node_Str"");
  simpleMailMessage.setText(""String_Node_Str"");
  mailSender.send(simpleMailMessage);
}","@org.junit.Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testSendMail() throws Exception {
  SimpleMailMessage simpleMailMessage=new SimpleMailMessage();
  simpleMailMessage.setFrom(this.senderAddress);
  simpleMailMessage.setTo(this.recipientAddress);
  simpleMailMessage.setSubject(""String_Node_Str"");
  simpleMailMessage.setText(""String_Node_Str"");
  this.mailSender.send(simpleMailMessage);
}"
55517,"@Test public void testExistingDataSourceInstance() throws Exception {
  Properties properties=new Properties();
  properties.load(new ClassPathResource(""String_Node_Str"").getInputStream());
  String accessKey=properties.getProperty(""String_Node_Str"");
  String secretKey=properties.getProperty(""String_Node_Str"");
  AmazonRDSDataSourceFactoryBean factoryBean=new AmazonRDSDataSourceFactoryBean(accessKey,secretKey);
  factoryBean.setDatabaseName(""String_Node_Str"");
  CommonsDbcpDataSourceFactory dataSourceFactory=new CommonsDbcpDataSourceFactory();
  Properties dbProperties=new Properties();
  dbProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  dbProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  dataSourceFactory.setConnectionProperties(dbProperties);
  factoryBean.setDataSourceFactory(dataSourceFactory);
  factoryBean.setDbInstanceIdentifier(""String_Node_Str"");
  factoryBean.setMasterUserName(""String_Node_Str"");
  factoryBean.setMasterUserPassword(""String_Node_Str"");
  factoryBean.afterPropertiesSet();
  DataSource dataSource=factoryBean.getObject();
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
  jdbcTemplate.query(""String_Node_Str"",new RowMapper<Object>(){
    public Object mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return null;
    }
  }
);
  factoryBean.destroy();
}","@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testExistingDataSourceInstance() throws Exception {
  Properties properties=new Properties();
  properties.load(new ClassPathResource(""String_Node_Str"").getInputStream());
  String accessKey=properties.getProperty(""String_Node_Str"");
  String secretKey=properties.getProperty(""String_Node_Str"");
  AmazonRDSDataSourceFactoryBean factoryBean=new AmazonRDSDataSourceFactoryBean(accessKey,secretKey);
  factoryBean.setDatabaseName(""String_Node_Str"");
  CommonsDbcpDataSourceFactory dataSourceFactory=new CommonsDbcpDataSourceFactory();
  Properties dbProperties=new Properties();
  dbProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  dbProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  dataSourceFactory.setConnectionProperties(dbProperties);
  factoryBean.setDataSourceFactory(dataSourceFactory);
  factoryBean.setDbInstanceIdentifier(""String_Node_Str"");
  factoryBean.setMasterUserName(""String_Node_Str"");
  factoryBean.setMasterUserPassword(""String_Node_Str"");
  factoryBean.afterPropertiesSet();
  DataSource dataSource=factoryBean.getObject();
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
  jdbcTemplate.query(""String_Node_Str"",new RowMapper<Object>(){
    public Object mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return null;
    }
  }
);
  factoryBean.destroy();
}"
55518,"@Test public void testCreateDataSource() throws Exception {
  Properties properties=new Properties();
  properties.load(new ClassPathResource(""String_Node_Str"").getInputStream());
  String accessKey=properties.getProperty(""String_Node_Str"");
  String secretKey=properties.getProperty(""String_Node_Str"");
  AmazonRDSDataSourceFactoryBean factoryBean=new AmazonRDSDataSourceFactoryBean(accessKey,secretKey);
  factoryBean.setDatabaseName(""String_Node_Str"");
  factoryBean.setDataSourceFactory(new CommonsDbcpDataSourceFactory());
  factoryBean.setDbInstanceIdentifier(""String_Node_Str"");
  factoryBean.setMasterUserName(""String_Node_Str"");
  factoryBean.setMasterUserPassword(""String_Node_Str"");
  factoryBean.setEngine(""String_Node_Str"");
  factoryBean.setEngineVersion(""String_Node_Str"");
  factoryBean.setAutoMinorVersionUpgrade(true);
  factoryBean.setMultiAz(false);
  factoryBean.setAvailabilityZone(""String_Node_Str"");
  factoryBean.setPreferredBackupWindow(""String_Node_Str"");
  factoryBean.setPreferredMaintenanceWindow(""String_Node_Str"");
  factoryBean.setBackupRetentionPeriod(1);
  factoryBean.setAllocatedStorage(5);
  factoryBean.setAutoCreate(true);
  factoryBean.setPort(3306);
  factoryBean.setDbInstanceClass(""String_Node_Str"");
  factoryBean.setDataSourceFactory(new CommonsDbcpDataSourceFactory());
  factoryBean.setDbSecurityGroups(Collections.singletonList(""String_Node_Str""));
  factoryBean.afterPropertiesSet();
  DataSource dataSource=factoryBean.getObject();
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
  jdbcTemplate.query(""String_Node_Str"",new RowMapper<Object>(){
    public Object mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return null;
    }
  }
);
  factoryBean.destroy();
}","@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testCreateDataSource() throws Exception {
  Properties properties=new Properties();
  properties.load(new ClassPathResource(""String_Node_Str"").getInputStream());
  String accessKey=properties.getProperty(""String_Node_Str"");
  String secretKey=properties.getProperty(""String_Node_Str"");
  AmazonRDSDataSourceFactoryBean factoryBean=new AmazonRDSDataSourceFactoryBean(accessKey,secretKey);
  factoryBean.setDatabaseName(""String_Node_Str"");
  factoryBean.setDataSourceFactory(new CommonsDbcpDataSourceFactory());
  factoryBean.setDbInstanceIdentifier(""String_Node_Str"");
  factoryBean.setMasterUserName(""String_Node_Str"");
  factoryBean.setMasterUserPassword(""String_Node_Str"");
  factoryBean.setEngine(""String_Node_Str"");
  factoryBean.setEngineVersion(""String_Node_Str"");
  factoryBean.setAutoMinorVersionUpgrade(true);
  factoryBean.setMultiAz(false);
  factoryBean.setAvailabilityZone(""String_Node_Str"");
  factoryBean.setPreferredBackupWindow(""String_Node_Str"");
  factoryBean.setPreferredMaintenanceWindow(""String_Node_Str"");
  factoryBean.setBackupRetentionPeriod(1);
  factoryBean.setAllocatedStorage(5);
  factoryBean.setAutoCreate(true);
  factoryBean.setPort(3306);
  factoryBean.setDbInstanceClass(""String_Node_Str"");
  factoryBean.setDataSourceFactory(new CommonsDbcpDataSourceFactory());
  factoryBean.setDbSecurityGroups(Collections.singletonList(""String_Node_Str""));
  factoryBean.afterPropertiesSet();
  DataSource dataSource=factoryBean.getObject();
  JdbcTemplate jdbcTemplate=new JdbcTemplate(dataSource);
  jdbcTemplate.query(""String_Node_Str"",new RowMapper<Object>(){
    public Object mapRow(    ResultSet rs,    int rowNum) throws SQLException {
      return null;
    }
  }
);
  factoryBean.destroy();
}"
55519,"@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testSendAndReceiveStringMessage() throws Exception {
  String messageContent=""String_Node_Str"";
  stringMessageOperations.convertAndSend(messageContent);
  String receivedMessage=(String)stringMessageOperations.receiveAndConvert();
  Assert.assertEquals(messageContent,receivedMessage);
}","@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testSendAndReceiveStringMessage() throws Exception {
  String messageContent=""String_Node_Str"";
  this.stringMessageOperations.convertAndSend(messageContent);
  String receivedMessage=(String)this.stringMessageOperations.receiveAndConvert();
  Assert.assertEquals(messageContent,receivedMessage);
}"
55520,"@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testSendAndReceiveObjectMessage() throws Exception {
  List<String> payload=Collections.singletonList(""String_Node_Str"");
  objectMessageOperations.convertAndSend(payload);
  @SuppressWarnings({""String_Node_Str""}) List<String> result=(List<String>)objectMessageOperations.receiveAndConvert();
  Assert.assertEquals(""String_Node_Str"",result.get(0));
}","@Test @IfProfileValue(name=""String_Node_Str"",value=""String_Node_Str"") public void testSendAndReceiveObjectMessage() throws Exception {
  List<String> payload=Collections.singletonList(""String_Node_Str"");
  this.objectMessageOperations.convertAndSend(payload);
  @SuppressWarnings({""String_Node_Str""}) List<String> result=(List<String>)this.objectMessageOperations.receiveAndConvert();
  Assert.assertEquals(""String_Node_Str"",result.get(0));
}"
55521,"/** 
 * Determine the maximum total number of attempts to make when selecting random nodes to recommend.
 * @param context of the current computation.
 * @return maximum number of attempts. By default 10 * {@link com.graphaware.reco.generic.context.Context#limit()}
 */
protected int numberOfAttempts(Context<Node,Node> context){
  return context.config().limit() * 10;
}","/** 
 * Determine the maximum total number of attempts to make when selecting random nodes to recommend.
 * @param context of the current computation.
 * @return maximum number of attempts. By default 10 * {@link Context#config()} {@link Config#limit()}
 */
protected int numberOfAttempts(Context<Node,Node> context){
  return context.config().limit() * 10;
}"
55522,"/** 
 * Determine the maximum number of random nodes to recommend. <p/> The reason for this setting is the following: usually, this engine will be used as the last one to make up the desired number of recommendations. If only   {@link com.graphaware.reco.generic.context.Context#limit()} recommendationswere produced, there could be a possibility that the produced recommendations are the ones already computed by previous engines, thus not making up the desired number. The higher the return value of this method, the lower the chance of the desired number of recommendations not being satisfied.
 * @param context of the current computation.
 * @return maximum number of recommendations. By default 2 * {@link com.graphaware.reco.generic.context.Context#limit()}
 */
protected int numberOfRecommendations(Context<Node,Node> context){
  return context.config().limit() * 2;
}","/** 
 * Determine the maximum number of random nodes to recommend. <p/> The reason for this setting is the following: usually, this engine will be used as the last one to make up the desired number of recommendations. If only   {@link Context#config()} {@link Config#limit()} recommendationswere produced, there could be a possibility that the produced recommendations are the ones already computed by previous engines, thus not making up the desired number. The higher the return value of this method, the lower the chance of the desired number of recommendations not being satisfied.
 * @param context of the current computation.
 * @return maximum number of recommendations. By default 2 * {@link Context#config()} {@link Config#limit()}
 */
protected int numberOfRecommendations(Context<Node,Node> context){
  return context.config().limit() * 2;
}"
55523,"/** 
 * {@inheritDoc}<p/> A maximum of   {@link com.graphaware.reco.generic.context.Context#limit()} number of nodes is returned, each witha score determined by  {@link #score(org.neo4j.graphdb.Node)}. The total number of attempts made to find a suitable node is determined by   {@link #numberOfAttempts(com.graphaware.reco.generic.context.Context)}.
 */
@Override protected final Map<Node,PartialScore> doRecommendSingle(Node input,Context<Node,Node> context){
  Map<Node,PartialScore> result=new HashMap<>();
  int attempts=0;
  int numberOfAttempts=numberOfAttempts(context);
  int numberOfRecommendations=numberOfRecommendations(context);
  while (attempts++ < numberOfAttempts && result.size() < numberOfRecommendations) {
    Node node=selector.selectNode(input.getGraphDatabase());
    result.put(node,score(node));
  }
  return result;
}","/** 
 * {@inheritDoc}<p/> A maximum of   {@link Context#config()} {@link Config#limit()} number of nodes is returned, each witha score determined by  {@link #score(org.neo4j.graphdb.Node)}. The total number of attempts made to find a suitable node is determined by   {@link #numberOfAttempts(com.graphaware.reco.generic.context.Context)}.
 */
@Override protected final Map<Node,PartialScore> doRecommendSingle(Node input,Context<Node,Node> context){
  Map<Node,PartialScore> result=new HashMap<>();
  int attempts=0;
  int numberOfAttempts=numberOfAttempts(context);
  int numberOfRecommendations=numberOfRecommendations(context);
  while (attempts++ < numberOfAttempts && result.size() < numberOfRecommendations) {
    Node node=selector.selectNode(input.getGraphDatabase());
    if (node != null) {
      result.put(node,score(node));
    }
  }
  return result;
}"
55524,"public Category[] awaitCategoriesLikeName(String partialName){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_categories_like_path)).appendPath(partialName).build().toString();
  return get(url,Category[].class);
}","public Category[] awaitCategoriesLikeName(String partialName){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_categories_like_path));
  if (partialName != null)   uriBuilder.appendPath(partialName);
  return get(uriBuilder.build().toString(),Category[].class);
}"
55525,"public Poi[] awaitSearchByCategory(Location location,Integer radius,String categoryFoursquareId){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_search_path)).appendQueryParameter(""String_Node_Str"",location != null ? location.stringValues() : null).appendQueryParameter(""String_Node_Str"",radius != null ? radius.toString() : null).appendQueryParameter(""String_Node_Str"",categoryFoursquareId).build().toString();
  return get(url,Poi[].class);
}","public Poi[] awaitSearchByCategory(Location location,Integer radius,String categoryFoursquareId){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_search_path));
  if (location != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",location.stringValues());
  if (radius != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",radius.toString());
  if (categoryFoursquareId != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",categoryFoursquareId);
  return get(uriBuilder.build().toString(),Poi[].class);
}"
55526,"public Poi[] awaitRoute(String poiFoursquareId){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_route_path)).appendQueryParameter(""String_Node_Str"",poiFoursquareId).build().toString();
  return get(url,Poi[].class);
}","public Poi[] awaitRoute(String poiFoursquareId){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_route_path));
  if (poiFoursquareId != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",poiFoursquareId);
  return get(uriBuilder.build().toString(),Poi[].class);
}"
55527,"public Recommendation[] awaitRecommendations(String accessToken,Location location,Integer radius){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_recommend_path)).appendQueryParameter(""String_Node_Str"",accessToken).appendQueryParameter(""String_Node_Str"",location != null ? location.stringValues() : null).appendQueryParameter(""String_Node_Str"",radius != null ? radius.toString() : null).build().toString();
  return get(url,Recommendation[].class);
}","public Recommendation[] awaitRecommendations(String accessToken,Location location,Integer radius){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_pois_path)).appendEncodedPath(getString(R.string.gf_api_pois_recommend_path));
  if (accessToken != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",accessToken);
  if (location != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",location.stringValues());
  if (radius != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",radius.toString());
  return get(uriBuilder.build().toString(),Recommendation[].class);
}"
55528,"public User[] awaitSelfUserFriends(String accessToken){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendEncodedPath(getString(R.string.gf_api_users_friends_path)).appendQueryParameter(""String_Node_Str"",accessToken).build().toString();
  return get(url,User[].class);
}","public User[] awaitSelfUserFriends(String accessToken){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendEncodedPath(getString(R.string.gf_api_users_friends_path));
  if (accessToken != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",accessToken);
  return get(uriBuilder.build().toString(),User[].class);
}"
55529,"public String awaitAccessToken(String foursquareAuthorizationCode){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_register_with_foursquare_path)).appendQueryParameter(""String_Node_Str"",foursquareAuthorizationCode).build().toString();
  return get(url,AccessToken.class).getToken();
}","public String awaitAccessToken(String foursquareAuthorizationCode){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_register_with_foursquare_path));
  if (foursquareAuthorizationCode != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",foursquareAuthorizationCode);
  return get(uriBuilder.build().toString(),AccessToken.class).getToken();
}"
55530,"public User awaitSelfUser(String accessToken){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendQueryParameter(""String_Node_Str"",accessToken).build().toString();
  return get(url,User.class);
}","public User awaitSelfUser(String accessToken){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path));
  if (accessToken != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",accessToken);
  return get(uriBuilder.build().toString(),User.class);
}"
55531,"public Category[] awaitUserLikes(String accessToken,String userFoursquareId){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendPath(userFoursquareId).appendEncodedPath(getString(R.string.gf_api_users_likes_path)).appendQueryParameter(""String_Node_Str"",accessToken).build().toString();
  return get(url,Category[].class);
}","public Category[] awaitUserLikes(String accessToken,String userFoursquareId){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path));
  if (userFoursquareId != null)   uriBuilder.appendPath(userFoursquareId);
  uriBuilder.appendEncodedPath(getString(R.string.gf_api_users_likes_path));
  if (accessToken != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",accessToken);
  return get(uriBuilder.build().toString(),Category[].class);
}"
55532,"public UpdateResponse awaitAddLike(String accessToken,String categoryFoursquareId){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendEncodedPath(getString(R.string.gf_api_users_update_path)).appendEncodedPath(getString(R.string.gf_api_users_add_like_path)).appendQueryParameter(""String_Node_Str"",accessToken).appendQueryParameter(""String_Node_Str"",categoryFoursquareId).build().toString();
  return put(url,null,UpdateResponse.class);
}","public UpdateResponse awaitAddLike(String accessToken,String categoryFoursquareId){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendEncodedPath(getString(R.string.gf_api_users_update_path)).appendEncodedPath(getString(R.string.gf_api_users_add_like_path));
  if (accessToken != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",accessToken);
  if (categoryFoursquareId != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",categoryFoursquareId);
  return put(uriBuilder.build().toString(),null,UpdateResponse.class);
}"
55533,"public UpdateResponse awaitRemoveLike(String accessToken,String categoryFoursquareId){
  String url=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendEncodedPath(getString(R.string.gf_api_users_update_path)).appendEncodedPath(getString(R.string.gf_api_users_remove_like_path)).appendQueryParameter(""String_Node_Str"",accessToken).appendQueryParameter(""String_Node_Str"",categoryFoursquareId).build().toString();
  return delete(url,null,UpdateResponse.class);
}","public UpdateResponse awaitRemoveLike(String accessToken,String categoryFoursquareId){
  Uri.Builder uriBuilder=Uri.parse(getString(R.string.gf_api_base_url)).buildUpon().appendEncodedPath(getString(R.string.gf_api_users_path)).appendEncodedPath(getString(R.string.gf_api_users_self_path)).appendEncodedPath(getString(R.string.gf_api_users_update_path)).appendEncodedPath(getString(R.string.gf_api_users_remove_like_path));
  if (accessToken != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",accessToken);
  if (categoryFoursquareId != null)   uriBuilder.appendQueryParameter(""String_Node_Str"",categoryFoursquareId);
  return delete(uriBuilder.build().toString(),null,UpdateResponse.class);
}"
55534,"private void onSelectRecommendation(Recommendation recommendation){
  getActivity().startActivity(RecommendedRouteActivity.getIntent(getActivity(),currentLocation,recommendation.getPoi()));
}","private void onSelectRecommendation(Recommendation recommendation){
  if (currentLocation != null) {
    getActivity().startActivity(RecommendedRouteActivity.getIntent(getActivity(),currentLocation,recommendation.getPoi()));
  }
}"
55535,"private void onSelectPoi(Poi poi){
  getActivity().startActivity(RecommendedRouteActivity.getIntent(getActivity(),currentLocation,poi));
}","private void onSelectPoi(Poi poi){
  if (currentLocation != null) {
    getActivity().startActivity(RecommendedRouteActivity.getIntent(getActivity(),currentLocation,poi));
  }
}"
55536,"private void showCurrentLocationInMap(){
  if (currentLocation != null) {
    LatLng latLng=new LatLng(currentLocation.getLatitude(),currentLocation.getLongitude());
    googleMap.addMarker(new MarkerOptions().position(latLng).title(getString(R.string.current_location)).icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_map_location)));
    googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng,13f));
  }
}","private void showCurrentLocationInMap(){
  if (currentLocation != null) {
    LatLng latLng=new LatLng(currentLocation.getLatitude(),currentLocation.getLongitude());
    googleMap.addMarker(new MarkerOptions().position(latLng).title(getString(R.string.current_location)).icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_map_location)));
    googleMap.moveCamera(CameraUpdateFactory.newLatLng(latLng));
  }
}"
55537,"private void onDrawerMenuSelected(int position){
switch (position) {
case 0:
    if (user != null)     startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(getString(R.string.foursquare_user_url,user.getFoursquareId()))));
  drawerLayout.closeDrawers();
break;
case 3:
supportInvalidateOptionsMenu();
setupFragment(new ExploreByLikesFragment());
setTitle(R.string.drawer_explore_by_your_likes_option);
drawerItemAdapter.setSelectedPosition(position);
drawerLayout.closeDrawers();
break;
case 4:
supportInvalidateOptionsMenu();
setupFragment(new ExploreByFriendsLikesFragment());
setTitle(R.string.drawer_explore_by_your_friends_likes_option);
drawerItemAdapter.setSelectedPosition(position);
drawerLayout.closeDrawers();
break;
case 6:
startActivity(new Intent(this,SettingsActivity.class));
drawerLayout.closeDrawers();
break;
}
}","private void onDrawerMenuSelected(int position){
switch (position) {
case 0:
    if (user != null)     startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(getString(R.string.foursquare_user_url,user.getFoursquareId()))));
  drawerLayout.closeDrawers();
break;
case 3:
invalidateOptionsMenu();
setupFragment(new ExploreByLikesFragment());
setTitle(R.string.drawer_explore_by_your_likes_option);
drawerItemAdapter.setSelectedPosition(position);
drawerLayout.closeDrawers();
break;
case 4:
invalidateOptionsMenu();
setupFragment(new ExploreByFriendsLikesFragment());
setTitle(R.string.drawer_explore_by_your_friends_likes_option);
drawerItemAdapter.setSelectedPosition(position);
drawerLayout.closeDrawers();
break;
case 6:
startActivity(new Intent(this,SettingsActivity.class));
drawerLayout.closeDrawers();
break;
}
}"
55538,"@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,final int position){
  Context context=holder.itemView.getContext();
  holder.itemView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (listener != null)       listener.onClick(position);
    }
  }
);
  DrawerItem drawerItem=drawerItems.get(position);
switch (drawerItem.getType()) {
case HEADER:
    DrawerHeader drawerHeader=(DrawerHeader)drawerItem;
  if (drawerHeader.getUser() != null) {
    HeaderViewHolder headerViewHolder=(HeaderViewHolder)holder;
    String userFullName=drawerHeader.getUser().getLastName() == null || drawerHeader.getUser().getLastName().trim().isEmpty() ? drawerHeader.getUser().getName() : new StringBuilder().append(drawerHeader.getUser().getName()).append(""String_Node_Str"").append(drawerHeader.getUser().getLastName()).toString();
    headerViewHolder.userNameTextView.setText(userFullName);
    Picasso.with(context).load(drawerHeader.getUser().getPhotoUrl()).placeholder(R.drawable.ic_contact_picture).into(headerViewHolder.profileImageView);
  }
break;
case OPTION:
DrawerOption drawerOption=(DrawerOption)drawerItem;
OptionViewHolder optionViewHolder=(OptionViewHolder)holder;
optionViewHolder.nameTextView.setText(drawerOption.getNameRes());
if (selectedPosition != null && selectedPosition == position) {
optionViewHolder.itemView.setBackgroundColor(context.getResources().getColor(R.color.selected_background));
optionViewHolder.nameTextView.setTextColor(context.getResources().getColor(R.color.primary_selected_text));
Drawable selectedIcon=context.getDrawable(drawerOption.getSelectedIconRes());
selectedIcon.mutate().setColorFilter(context.getResources().getColor(R.color.selected_icon),PorterDuff.Mode.SRC_IN);
optionViewHolder.iconImageView.setImageDrawable(selectedIcon);
}
 else {
optionViewHolder.itemView.setBackgroundColor(context.getResources().getColor(R.color.unselected_background));
optionViewHolder.nameTextView.setTextColor(context.getResources().getColor(R.color.primary_text));
optionViewHolder.iconImageView.setImageResource(drawerOption.getUnselectedIconRes());
}
break;
case OPTION_HEADER:
DrawerOptionHeader drawerOptionHeader=(DrawerOptionHeader)drawerItem;
OptionHeaderViewHolder optionHeaderViewHolder=(OptionHeaderViewHolder)holder;
optionHeaderViewHolder.nameTextView.setText(drawerOptionHeader.getNameRes());
break;
}
}","@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,final int position){
  Context context=holder.itemView.getContext();
  holder.itemView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      if (listener != null)       listener.onClick(position);
    }
  }
);
  DrawerItem drawerItem=drawerItems.get(position);
switch (drawerItem.getType()) {
case HEADER:
    DrawerHeader drawerHeader=(DrawerHeader)drawerItem;
  if (drawerHeader.getUser() != null) {
    HeaderViewHolder headerViewHolder=(HeaderViewHolder)holder;
    String userFullName=drawerHeader.getUser().getLastName() == null || drawerHeader.getUser().getLastName().trim().isEmpty() ? drawerHeader.getUser().getName() : new StringBuilder().append(drawerHeader.getUser().getName()).append(""String_Node_Str"").append(drawerHeader.getUser().getLastName()).toString();
    headerViewHolder.userNameTextView.setText(userFullName);
    Picasso.with(context).load(drawerHeader.getUser().getPhotoUrl()).placeholder(R.drawable.ic_contact_picture).into(headerViewHolder.profileImageView);
  }
break;
case OPTION:
DrawerOption drawerOption=(DrawerOption)drawerItem;
OptionViewHolder optionViewHolder=(OptionViewHolder)holder;
optionViewHolder.nameTextView.setText(drawerOption.getNameRes());
if (selectedPosition != null && selectedPosition == position) {
optionViewHolder.itemView.setBackgroundColor(context.getResources().getColor(R.color.selected_background));
optionViewHolder.nameTextView.setTextColor(context.getResources().getColor(R.color.primary_selected_text));
Drawable selectedIcon=context.getResources().getDrawable(drawerOption.getSelectedIconRes());
selectedIcon.mutate().setColorFilter(context.getResources().getColor(R.color.selected_icon),PorterDuff.Mode.SRC_IN);
optionViewHolder.iconImageView.setImageDrawable(selectedIcon);
}
 else {
optionViewHolder.itemView.setBackgroundColor(context.getResources().getColor(R.color.unselected_background));
optionViewHolder.nameTextView.setTextColor(context.getResources().getColor(R.color.primary_text));
optionViewHolder.iconImageView.setImageResource(drawerOption.getUnselectedIconRes());
}
break;
case OPTION_HEADER:
DrawerOptionHeader drawerOptionHeader=(DrawerOptionHeader)drawerItem;
OptionHeaderViewHolder optionHeaderViewHolder=(OptionHeaderViewHolder)holder;
optionHeaderViewHolder.nameTextView.setText(drawerOptionHeader.getNameRes());
break;
}
}"
55539,"@Override protected void onChildRestoreInstanceState(){
  if (searchTask != null && searchTask.isActive())   onPreSearchRecommendations();
 else   if (getLastRecommendations() != null) {
    onRecommendationsAcquired(getLastRecommendations());
    onSearchRecommendationsFinally();
  }
}","@Override protected void onChildRestoreInstanceState(){
  if (searchTask != null && searchTask.isActive())   onPreSearchRecommendations();
 else   if (getLastRecommendations() != null) {
    onRecommendationsAcquired(getLastRecommendations());
    onSearchRecommendationsFinally();
  }
 else   onPrepareForSearch();
}"
55540,"@Override protected void onChildRestoreInstanceState(){
  if (searchTask != null && searchTask.isActive())   onPreSearchRecommendations();
 else   if (getLastRecommendations() != null) {
    onRecommendationsAcquired(getLastRecommendations());
    onSearchRecommendationsFinally();
  }
}","@Override protected void onChildRestoreInstanceState(){
  if (searchTask != null && searchTask.isActive())   onPreSearchRecommendations();
 else   if (getLastRecommendations() != null) {
    onRecommendationsAcquired(getLastRecommendations());
    onSearchRecommendationsFinally();
  }
 else   onPrepareForSearch();
}"
55541,"@Override public void onMapReady(GoogleMap googleMap){
  if (recommendation.getPoiSequence().length > 0) {
    for (    Poi poi : recommendation.getPoiSequence()) {
      Marker marker=googleMap.addMarker(new MarkerOptions().position(new LatLng(poi.getLocation().getLatitude(),poi.getLocation().getLongitude())).title(poi.getName()));
      Picasso.with(this).load(poi.getCategories()[0].getIconUrl()).placeholder(R.drawable.ic_generic_category).into(new PicassoMarker(marker,this));
    }
  }
  if (recommendation.getRoutePoints().length > 0) {
    PolylineOptions pathOptions=new PolylineOptions().color(Color.RED);
    for (int index=0; index < recommendation.getRoutePoints().length; index++) {
      pathOptions.add(new LatLng(recommendation.getRoutePoints()[index].getLatitude(),recommendation.getRoutePoints()[index].getLongitude()));
    }
    googleMap.addPolyline(pathOptions);
  }
  LatLng latLngOrigin=new LatLng(origin.getLatitude(),origin.getLongitude());
  googleMap.addMarker(new MarkerOptions().position(latLngOrigin).title(getString(R.string.your_location)).icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_CYAN)));
  googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLngOrigin,13f));
}","@Override public void onMapReady(GoogleMap googleMap){
  if (recommendation.getPoiSequence().length > 0) {
    for (    Poi poi : recommendation.getPoiSequence()) {
      Marker marker=googleMap.addMarker(new MarkerOptions().position(new LatLng(poi.getLocation().getLatitude(),poi.getLocation().getLongitude())).title(poi.getName()));
      Picasso.with(this).load(poi.getCategories()[0].getIconUrl()).placeholder(R.drawable.ic_generic_category).into(new PicassoMarker(marker,this));
    }
  }
  if (recommendation.getRoutePoints().length > 0) {
    PolylineOptions pathOptions=new PolylineOptions().color(Color.RED);
    for (int index=0; index < recommendation.getRoutePoints().length; index++) {
      pathOptions.add(new LatLng(recommendation.getRoutePoints()[index].getLatitude(),recommendation.getRoutePoints()[index].getLongitude()));
    }
    googleMap.addPolyline(pathOptions);
  }
  LatLng latLngOrigin=new LatLng(origin.getLatitude(),origin.getLongitude());
  googleMap.addMarker(new MarkerOptions().position(latLngOrigin).title(getString(R.string.current_location)).icon(BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_CYAN)));
  googleMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLngOrigin,13f));
}"
55542,"protected void onLocateUser(){
  locationRequester.requestSingle(this);
}","protected void onLocateUser(){
  if (isConnected())   locationRequester.requestSingle(this);
 else   onNetworkDisabled();
}"
55543,"protected void onRecommendationsAcquired(Recommendation[] recommendations){
  this.lastRecommendations=recommendations;
  viewPager.setVisibility(View.VISIBLE);
  pagerStrip.setVisibility(View.VISIBLE);
  if (recommendations != null) {
    swipeRouteDetailFragmentsAdapter.clearFragments();
    for (    Recommendation recommendation : recommendations) {
      RouteDetailFragment fragment=RouteDetailFragment.newInstance(lastLocation,recommendation);
      swipeRouteDetailFragmentsAdapter.addFragment(fragment);
    }
    viewPager.setCurrentItem(0);
  }
}","protected void onRecommendationsAcquired(Recommendation[] recommendations){
  this.lastRecommendations=recommendations;
  viewPager.setVisibility(View.VISIBLE);
  pagerStrip.setVisibility(View.VISIBLE);
  if (recommendations != null) {
    swipeRouteDetailFragmentsAdapter.clearFragments();
    for (    Recommendation recommendation : recommendations) {
      RouteDetailFragment fragment=RouteDetailFragment.newInstance(lastLocation,lastAddress,recommendation);
      swipeRouteDetailFragmentsAdapter.addFragment(fragment);
    }
    viewPager.setCurrentItem(0);
  }
}"
55544,"@Override public void onLocationAcquired(android.location.Location location){
  Location myLocation=new Location();
  myLocation.setLatitude(location.getLatitude());
  myLocation.setLongitude(location.getLongitude());
  lastLocation=myLocation;
}","@Override public void onLocationAcquired(android.location.Location location){
  Location myLocation=new Location();
  myLocation.setLatitude(location.getLatitude());
  myLocation.setLongitude(location.getLongitude());
  lastLocation=myLocation;
  lastAddress=LocationGeocoder.getAddress(getActivity().getApplicationContext(),location);
}"
55545,"public static RouteDetailFragment newInstance(Location origin,Recommendation recommendation){
  RouteDetailFragment fragment=new RouteDetailFragment();
  Bundle args=new Bundle();
  args.putSerializable(ORIGIN_LOCATION_ARG,origin);
  args.putSerializable(RECOMMENDATION_ARG,recommendation);
  fragment.setArguments(args);
  return fragment;
}","public static RouteDetailFragment newInstance(Location originLocation,String originAddress,Recommendation recommendation){
  RouteDetailFragment fragment=new RouteDetailFragment();
  Bundle args=new Bundle();
  args.putSerializable(ORIGIN_LOCATION_ARG,originLocation);
  args.putString(ORIGIN_ADDRESS_ARG,originAddress);
  args.putSerializable(RECOMMENDATION_ARG,recommendation);
  fragment.setArguments(args);
  return fragment;
}"
55546,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  recommendationReasonView.setText(getRecommendation().getReason());
  poiListView.setHasFixedSize(true);
  poiListView.setLayoutManager(new LinearLayoutManager(getActivity()));
  poiListView.setAdapter(new RecommendationAdapter(getOriginLocation(),getRecommendation()));
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  recommendationReasonView.setVisibility(View.GONE);
  poiListView.setHasFixedSize(true);
  poiListView.setLayoutManager(new LinearLayoutManager(getActivity()));
  poiListView.setAdapter(new RecommendationAdapter(getOriginAddress(),getRecommendation()));
}"
55547,"public RecommendationAdapter(Location origin,Recommendation recommendation){
  this.origin=origin;
  this.recommendation=recommendation;
}","public RecommendationAdapter(String originAddress,Recommendation recommendation){
  this.originAddress=originAddress;
  this.recommendation=recommendation;
}"
55548,"@Override public void onBindViewHolder(ViewHolder holder,int position){
  if (position == 0) {
    holder.categoryImageView.setImageResource(R.drawable.ic_generic_category);
    holder.categoryNameView.setText(LocationGeocoder.getAddress(holder.poiNameView.getContext(),origin));
    holder.poiNameView.setText(R.string.your_location);
  }
 else {
    Picasso.with(holder.categoryImageView.getContext()).load(recommendation.getPoiSequence()[position - 1].getCategories()[0].getIconUrl()).placeholder(R.drawable.ic_generic_category).into(holder.categoryImageView);
    holder.categoryNameView.setText(recommendation.getPoiSequence()[position - 1].getCategories()[0].getName());
    holder.poiNameView.setText(recommendation.getPoiSequence()[position - 1].getName());
  }
}","@Override public void onBindViewHolder(ViewHolder holder,int position){
  if (position == 0) {
    holder.categoryImageView.setImageResource(R.drawable.ic_generic_category);
    holder.categoryNameView.setText(originAddress);
    holder.poiNameView.setText(R.string.current_location);
  }
 else {
    Picasso.with(holder.categoryImageView.getContext()).load(recommendation.getPoiSequence()[position - 1].getCategories()[0].getIconUrl()).placeholder(R.drawable.ic_generic_category).into(holder.categoryImageView);
    holder.categoryNameView.setText(recommendation.getPoiSequence()[position - 1].getCategories()[0].getName());
    holder.poiNameView.setText(recommendation.getPoiSequence()[position - 1].getName());
  }
}"
55549,"private void handleStart(){
  windowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  LayoutInflater inflater=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
  removeView=(RelativeLayout)inflater.inflate(R.layout.remove,null);
  WindowManager.LayoutParams paramRemove=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  paramRemove.gravity=Gravity.TOP | Gravity.LEFT;
  removeView.setVisibility(View.GONE);
  removeImg=(ImageView)removeView.findViewById(R.id.remove_img);
  windowManager.addView(removeView,paramRemove);
  chatheadView=(RelativeLayout)inflater.inflate(R.layout.chathead,null);
  chatheadImg=(ImageView)chatheadView.findViewById(R.id.chathead_img);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    windowManager.getDefaultDisplay().getSize(szWindow);
  }
 else {
    int w=windowManager.getDefaultDisplay().getWidth();
    int h=windowManager.getDefaultDisplay().getHeight();
    szWindow.set(w,h);
  }
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  params.gravity=Gravity.TOP | Gravity.LEFT;
  params.x=0;
  params.y=100;
  windowManager.addView(chatheadView,params);
  chatheadView.setOnTouchListener(new View.OnTouchListener(){
    long time_start=0, time_end=0;
    boolean isLongclick=false, inBounded=false;
    int remove_img_width=0, remove_img_height=0;
    Handler handler_longClick=new Handler();
    Runnable runnable_longClick=new Runnable(){
      @Override public void run(){
        Log.d(Utils.LogTag,""String_Node_Str"");
        isLongclick=true;
        removeView.setVisibility(View.VISIBLE);
        chathead_longclick();
      }
    }
;
    @Override public boolean onTouch(    View v,    MotionEvent event){
      WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
      int x_cord=(int)event.getRawX();
      int y_cord=(int)event.getRawY();
      int x_cord_Destination, y_cord_Destination;
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
        time_start=System.currentTimeMillis();
      handler_longClick.postDelayed(runnable_longClick,600);
    remove_img_width=removeImg.getLayoutParams().width;
  remove_img_height=removeImg.getLayoutParams().height;
x_init_cord=x_cord;
y_init_cord=y_cord;
x_init_margin=layoutParams.x;
y_init_margin=layoutParams.y;
if (txtView != null) {
txtView.setVisibility(View.GONE);
myHandler.removeCallbacks(myRunnable);
}
break;
case MotionEvent.ACTION_MOVE:
int x_diff_move=x_cord - x_init_cord;
int y_diff_move=y_cord - y_init_cord;
x_cord_Destination=x_init_margin + x_diff_move;
y_cord_Destination=y_init_margin + y_diff_move;
if (isLongclick) {
int x_bound_left=szWindow.x / 2 - (int)(remove_img_width * 1.5);
int x_bound_right=szWindow.x / 2 + (int)(remove_img_width * 1.5);
int y_bound_top=szWindow.y - (int)(remove_img_height * 1.5);
if ((x_cord >= x_bound_left && x_cord <= x_bound_right) && y_cord >= y_bound_top) {
inBounded=true;
int x_cord_remove=(int)((szWindow.x - (remove_img_height * 1.5)) / 2);
int y_cord_remove=(int)(szWindow.y - ((remove_img_width * 1.5) + getStatusBarHeight()));
if (removeImg.getLayoutParams().height == remove_img_height) {
removeImg.getLayoutParams().height=(int)(remove_img_height * 1.5);
removeImg.getLayoutParams().width=(int)(remove_img_width * 1.5);
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
layoutParams.x=x_cord_remove + (Math.abs(removeView.getWidth() - chatheadView.getWidth())) / 2;
layoutParams.y=y_cord_remove + (Math.abs(removeView.getHeight() - chatheadView.getHeight())) / 2;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
}
 else {
inBounded=false;
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(szWindow.x - removeView.getWidth()) / 2;
int y_cord_remove=szWindow.y - (removeView.getHeight() + getStatusBarHeight());
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
}
layoutParams.x=x_cord_Destination;
layoutParams.y=y_cord_Destination;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
case MotionEvent.ACTION_UP:
isLongclick=false;
removeView.setVisibility(View.GONE);
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
handler_longClick.removeCallbacks(runnable_longClick);
if (inBounded) {
if (MyDialog.active) {
MyDialog.myDialog.finish();
}
stopService(new Intent(ChatHeadService.this,ChatHeadService.class));
inBounded=false;
break;
}
int x_diff=x_cord - x_init_cord;
int y_diff=y_cord - y_init_cord;
if (Math.abs(x_diff) < 5 && Math.abs(y_diff) < 5) {
time_end=System.currentTimeMillis();
if ((time_end - time_start) < 300) {
chathead_click();
}
}
y_cord_Destination=y_init_margin + y_diff;
int BarHeight=getStatusBarHeight();
if (y_cord_Destination < 0) {
y_cord_Destination=0;
}
 else if (y_cord_Destination + (chatheadView.getHeight() + BarHeight) > szWindow.y) {
y_cord_Destination=szWindow.y - (chatheadView.getHeight() + BarHeight);
}
layoutParams.y=y_cord_Destination;
inBounded=false;
resetPosition(x_cord);
break;
default :
Log.d(Utils.LogTag,""String_Node_Str"");
break;
}
return true;
}
}
);
txtView=(LinearLayout)inflater.inflate(R.layout.txt,null);
txt1=(TextView)txtView.findViewById(R.id.txt1);
txt_linearlayout=(LinearLayout)txtView.findViewById(R.id.txt_linearlayout);
WindowManager.LayoutParams paramsTxt=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
paramsTxt.gravity=Gravity.TOP | Gravity.LEFT;
txtView.setVisibility(View.GONE);
windowManager.addView(txtView,paramsTxt);
}","@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2) private void handleStart(){
  windowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  LayoutInflater inflater=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
  removeView=(RelativeLayout)inflater.inflate(R.layout.remove,null);
  WindowManager.LayoutParams paramRemove=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  paramRemove.gravity=Gravity.TOP | Gravity.LEFT;
  removeView.setVisibility(View.GONE);
  removeImg=(ImageView)removeView.findViewById(R.id.remove_img);
  windowManager.addView(removeView,paramRemove);
  chatheadView=(RelativeLayout)inflater.inflate(R.layout.chathead,null);
  chatheadImg=(ImageView)chatheadView.findViewById(R.id.chathead_img);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    windowManager.getDefaultDisplay().getSize(szWindow);
  }
 else {
    int w=windowManager.getDefaultDisplay().getWidth();
    int h=windowManager.getDefaultDisplay().getHeight();
    szWindow.set(w,h);
  }
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  params.gravity=Gravity.TOP | Gravity.LEFT;
  params.x=0;
  params.y=100;
  windowManager.addView(chatheadView,params);
  chatheadView.setOnTouchListener(new View.OnTouchListener(){
    long time_start=0, time_end=0;
    boolean isLongclick=false, inBounded=false;
    int remove_img_width=0, remove_img_height=0;
    Handler handler_longClick=new Handler();
    Runnable runnable_longClick=new Runnable(){
      @Override public void run(){
        Log.d(Utils.LogTag,""String_Node_Str"");
        isLongclick=true;
        removeView.setVisibility(View.VISIBLE);
        chathead_longclick();
      }
    }
;
    @Override public boolean onTouch(    View v,    MotionEvent event){
      WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
      int x_cord=(int)event.getRawX();
      int y_cord=(int)event.getRawY();
      int x_cord_Destination, y_cord_Destination;
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
        time_start=System.currentTimeMillis();
      handler_longClick.postDelayed(runnable_longClick,600);
    remove_img_width=removeImg.getLayoutParams().width;
  remove_img_height=removeImg.getLayoutParams().height;
x_init_cord=x_cord;
y_init_cord=y_cord;
x_init_margin=layoutParams.x;
y_init_margin=layoutParams.y;
if (txtView != null) {
txtView.setVisibility(View.GONE);
myHandler.removeCallbacks(myRunnable);
}
break;
case MotionEvent.ACTION_MOVE:
int x_diff_move=x_cord - x_init_cord;
int y_diff_move=y_cord - y_init_cord;
x_cord_Destination=x_init_margin + x_diff_move;
y_cord_Destination=y_init_margin + y_diff_move;
if (isLongclick) {
int x_bound_left=szWindow.x / 2 - (int)(remove_img_width * 1.5);
int x_bound_right=szWindow.x / 2 + (int)(remove_img_width * 1.5);
int y_bound_top=szWindow.y - (int)(remove_img_height * 1.5);
if ((x_cord >= x_bound_left && x_cord <= x_bound_right) && y_cord >= y_bound_top) {
inBounded=true;
int x_cord_remove=(int)((szWindow.x - (remove_img_height * 1.5)) / 2);
int y_cord_remove=(int)(szWindow.y - ((remove_img_width * 1.5) + getStatusBarHeight()));
if (removeImg.getLayoutParams().height == remove_img_height) {
removeImg.getLayoutParams().height=(int)(remove_img_height * 1.5);
removeImg.getLayoutParams().width=(int)(remove_img_width * 1.5);
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
layoutParams.x=x_cord_remove + (Math.abs(removeView.getWidth() - chatheadView.getWidth())) / 2;
layoutParams.y=y_cord_remove + (Math.abs(removeView.getHeight() - chatheadView.getHeight())) / 2;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
}
 else {
inBounded=false;
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(szWindow.x - removeView.getWidth()) / 2;
int y_cord_remove=szWindow.y - (removeView.getHeight() + getStatusBarHeight());
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
}
layoutParams.x=x_cord_Destination;
layoutParams.y=y_cord_Destination;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
case MotionEvent.ACTION_UP:
isLongclick=false;
removeView.setVisibility(View.GONE);
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
handler_longClick.removeCallbacks(runnable_longClick);
if (inBounded) {
if (MyDialog.active) {
MyDialog.myDialog.finish();
}
stopService(new Intent(ChatHeadService.this,ChatHeadService.class));
inBounded=false;
break;
}
int x_diff=x_cord - x_init_cord;
int y_diff=y_cord - y_init_cord;
if (Math.abs(x_diff) < 5 && Math.abs(y_diff) < 5) {
time_end=System.currentTimeMillis();
if ((time_end - time_start) < 300) {
chathead_click();
}
}
y_cord_Destination=y_init_margin + y_diff;
int BarHeight=getStatusBarHeight();
if (y_cord_Destination < 0) {
y_cord_Destination=0;
}
 else if (y_cord_Destination + (chatheadView.getHeight() + BarHeight) > szWindow.y) {
y_cord_Destination=szWindow.y - (chatheadView.getHeight() + BarHeight);
}
layoutParams.y=y_cord_Destination;
inBounded=false;
resetPosition(x_cord);
break;
default :
Log.d(Utils.LogTag,""String_Node_Str"");
break;
}
return true;
}
}
);
txtView=(LinearLayout)inflater.inflate(R.layout.txt,null);
txt1=(TextView)txtView.findViewById(R.id.txt1);
txt_linearlayout=(LinearLayout)txtView.findViewById(R.id.txt_linearlayout);
WindowManager.LayoutParams paramsTxt=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
paramsTxt.gravity=Gravity.TOP | Gravity.LEFT;
txtView.setVisibility(View.GONE);
windowManager.addView(txtView,paramsTxt);
}"
55550,"@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2) @Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (windowManager == null)   windowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    windowManager.getDefaultDisplay().getSize(szWindow);
  }
 else {
    int w=windowManager.getDefaultDisplay().getWidth();
    int h=windowManager.getDefaultDisplay().getHeight();
    szWindow.set(w,h);
  }
  WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
  if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
    Log.d(Utils.LogTag,""String_Node_Str"");
    if (txtView != null) {
      txtView.setVisibility(View.GONE);
    }
    if (layoutParams.y + (chatheadView.getHeight() + getStatusBarHeight()) > szWindow.y) {
      layoutParams.y=szWindow.y - (chatheadView.getHeight() + getStatusBarHeight());
      windowManager.updateViewLayout(chatheadView,layoutParams);
    }
    if (layoutParams.x != 0 && layoutParams.x < szWindow.x) {
      resetPosition(szWindow.x);
    }
  }
 else   if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) {
    Log.d(Utils.LogTag,""String_Node_Str"");
    if (txtView != null) {
      txtView.setVisibility(View.GONE);
    }
    if (layoutParams.x > szWindow.x) {
      resetPosition(szWindow.x);
    }
  }
}","@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2) @Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  if (windowManager == null)   return;
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    windowManager.getDefaultDisplay().getSize(szWindow);
  }
 else {
    int w=windowManager.getDefaultDisplay().getWidth();
    int h=windowManager.getDefaultDisplay().getHeight();
    szWindow.set(w,h);
  }
  WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
  if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
    Log.d(Utils.LogTag,""String_Node_Str"");
    if (txtView != null) {
      txtView.setVisibility(View.GONE);
    }
    if (layoutParams.y + (chatheadView.getHeight() + getStatusBarHeight()) > szWindow.y) {
      layoutParams.y=szWindow.y - (chatheadView.getHeight() + getStatusBarHeight());
      windowManager.updateViewLayout(chatheadView,layoutParams);
    }
    if (layoutParams.x != 0 && layoutParams.x < szWindow.x) {
      resetPosition(szWindow.x);
    }
  }
 else   if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT) {
    Log.d(Utils.LogTag,""String_Node_Str"");
    if (txtView != null) {
      txtView.setVisibility(View.GONE);
    }
    if (layoutParams.x > szWindow.x) {
      resetPosition(szWindow.x);
    }
  }
}"
55551,"private void handleStart(){
  windowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  LayoutInflater inflater=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
  removeView=(RelativeLayout)inflater.inflate(R.layout.remove,null);
  WindowManager.LayoutParams paramRemove=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  paramRemove.gravity=Gravity.TOP | Gravity.LEFT;
  removeView.setVisibility(View.GONE);
  removeImg=(ImageView)removeView.findViewById(R.id.remove_img);
  windowManager.addView(removeView,paramRemove);
  chatheadView=(RelativeLayout)inflater.inflate(R.layout.chathead,null);
  chatheadImg=(ImageView)chatheadView.findViewById(R.id.chathead_img);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    windowManager.getDefaultDisplay().getSize(szWindow);
  }
 else {
    int w=windowManager.getDefaultDisplay().getWidth();
    int h=windowManager.getDefaultDisplay().getHeight();
    szWindow.set(w,h);
  }
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  params.gravity=Gravity.TOP | Gravity.LEFT;
  params.x=0;
  params.y=100;
  windowManager.addView(chatheadView,params);
  chatheadView.setOnTouchListener(new View.OnTouchListener(){
    long time_start=0, time_end=0;
    boolean isLongclick=false, inBounded=false;
    int remove_img_width=0, remove_img_height=0;
    Handler handler_longClick=new Handler();
    Runnable runnable_longClick=new Runnable(){
      @Override public void run(){
        Log.d(Utils.LogTag,""String_Node_Str"");
        isLongclick=true;
        removeView.setVisibility(View.VISIBLE);
        chathead_longclick();
      }
    }
;
    @Override public boolean onTouch(    View v,    MotionEvent event){
      WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
      int x_cord=(int)event.getRawX();
      int y_cord=(int)event.getRawY();
      int x_cord_Destination, y_cord_Destination;
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
        time_start=System.currentTimeMillis();
      handler_longClick.postDelayed(runnable_longClick,600);
    remove_img_width=removeImg.getLayoutParams().width;
  remove_img_height=removeImg.getLayoutParams().height;
x_init_cord=x_cord;
y_init_cord=y_cord;
x_init_margin=layoutParams.x;
y_init_margin=layoutParams.y;
if (txtView != null) {
txtView.setVisibility(View.GONE);
myHandler.removeCallbacks(myRunnable);
}
break;
case MotionEvent.ACTION_MOVE:
int x_diff_move=x_cord - x_init_cord;
int y_diff_move=y_cord - y_init_cord;
x_cord_Destination=x_init_margin + x_diff_move;
y_cord_Destination=y_init_margin + y_diff_move;
if (isLongclick) {
int x_bound_left=(szWindow.x - removeView.getWidth()) / 2 - 250;
int x_bound_right=(szWindow.x + removeView.getWidth()) / 2 + 100;
int y_bound_top=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) - 200;
if ((x_cord_Destination >= x_bound_left && x_cord_Destination <= x_bound_right) && y_cord_Destination >= y_bound_top) {
inBounded=true;
layoutParams.x=(szWindow.x - chatheadView.getWidth()) / 2;
layoutParams.y=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) + 70;
if (removeImg.getLayoutParams().height == remove_img_height) {
removeImg.getLayoutParams().height=(int)(remove_img_height * 1.5);
removeImg.getLayoutParams().width=(int)(remove_img_width * 1.5);
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(int)((szWindow.x - (remove_img_height * 1.5)) / 2);
int y_cord_remove=(int)(szWindow.y - ((remove_img_width * 1.5) + getStatusBarHeight()));
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
}
 else {
inBounded=false;
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(szWindow.x - removeView.getWidth()) / 2;
int y_cord_remove=szWindow.y - (removeView.getHeight() + getStatusBarHeight());
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
}
layoutParams.x=x_cord_Destination;
layoutParams.y=y_cord_Destination;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
case MotionEvent.ACTION_UP:
isLongclick=false;
removeView.setVisibility(View.GONE);
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
handler_longClick.removeCallbacks(runnable_longClick);
if (inBounded) {
if (MyDialog.active) {
MyDialog.myDialog.finish();
}
stopService(new Intent(ChatHeadService.this,ChatHeadService.class));
inBounded=false;
break;
}
int x_diff=x_cord - x_init_cord;
int y_diff=y_cord - y_init_cord;
if (x_diff < 5 && y_diff < 5) {
time_end=System.currentTimeMillis();
if ((time_end - time_start) < 300) {
chathead_click();
}
}
x_cord_Destination=x_init_margin + x_diff;
y_cord_Destination=y_init_margin + y_diff;
int x_start;
x_start=x_cord_Destination;
int BarHeight=getStatusBarHeight();
if (y_cord_Destination < 0) {
y_cord_Destination=0;
}
 else if (y_cord_Destination + (chatheadView.getHeight() + BarHeight) > szWindow.y) {
y_cord_Destination=szWindow.y - (chatheadView.getHeight() + BarHeight);
}
layoutParams.y=y_cord_Destination;
inBounded=false;
resetPosition(x_start);
break;
default :
Log.d(Utils.LogTag,""String_Node_Str"");
break;
}
return true;
}
}
);
txtView=(LinearLayout)inflater.inflate(R.layout.txt,null);
txt1=(TextView)txtView.findViewById(R.id.txt1);
txt_linearlayout=(LinearLayout)txtView.findViewById(R.id.txt_linearlayout);
WindowManager.LayoutParams paramsTxt=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
paramsTxt.gravity=Gravity.TOP | Gravity.LEFT;
txtView.setVisibility(View.GONE);
windowManager.addView(txtView,paramsTxt);
}","private void handleStart(){
  windowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  LayoutInflater inflater=(LayoutInflater)getSystemService(LAYOUT_INFLATER_SERVICE);
  removeView=(RelativeLayout)inflater.inflate(R.layout.remove,null);
  WindowManager.LayoutParams paramRemove=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  paramRemove.gravity=Gravity.TOP | Gravity.LEFT;
  removeView.setVisibility(View.GONE);
  removeImg=(ImageView)removeView.findViewById(R.id.remove_img);
  windowManager.addView(removeView,paramRemove);
  chatheadView=(RelativeLayout)inflater.inflate(R.layout.chathead,null);
  chatheadImg=(ImageView)chatheadView.findViewById(R.id.chathead_img);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    windowManager.getDefaultDisplay().getSize(szWindow);
  }
 else {
    int w=windowManager.getDefaultDisplay().getWidth();
    int h=windowManager.getDefaultDisplay().getHeight();
    szWindow.set(w,h);
  }
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
  params.gravity=Gravity.TOP | Gravity.LEFT;
  params.x=0;
  params.y=100;
  windowManager.addView(chatheadView,params);
  chatheadView.setOnTouchListener(new View.OnTouchListener(){
    long time_start=0, time_end=0;
    boolean isLongclick=false, inBounded=false;
    int remove_img_width=0, remove_img_height=0;
    Handler handler_longClick=new Handler();
    Runnable runnable_longClick=new Runnable(){
      @Override public void run(){
        Log.d(Utils.LogTag,""String_Node_Str"");
        isLongclick=true;
        removeView.setVisibility(View.VISIBLE);
        chathead_longclick();
      }
    }
;
    @Override public boolean onTouch(    View v,    MotionEvent event){
      WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
      int x_cord=(int)event.getRawX();
      int y_cord=(int)event.getRawY();
      int x_cord_Destination, y_cord_Destination;
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
        time_start=System.currentTimeMillis();
      handler_longClick.postDelayed(runnable_longClick,600);
    remove_img_width=removeImg.getLayoutParams().width;
  remove_img_height=removeImg.getLayoutParams().height;
x_init_cord=x_cord;
y_init_cord=y_cord;
x_init_margin=layoutParams.x;
y_init_margin=layoutParams.y;
if (txtView != null) {
txtView.setVisibility(View.GONE);
myHandler.removeCallbacks(myRunnable);
}
break;
case MotionEvent.ACTION_MOVE:
int x_diff_move=x_cord - x_init_cord;
int y_diff_move=y_cord - y_init_cord;
x_cord_Destination=x_init_margin + x_diff_move;
y_cord_Destination=y_init_margin + y_diff_move;
if (isLongclick) {
int x_bound_left=(szWindow.x - removeView.getWidth()) / 2 - 250;
int x_bound_right=(szWindow.x + removeView.getWidth()) / 2 + 100;
int y_bound_top=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) - 200;
if ((x_cord_Destination >= x_bound_left && x_cord_Destination <= x_bound_right) && y_cord_Destination >= y_bound_top) {
inBounded=true;
layoutParams.x=(szWindow.x - chatheadView.getWidth()) / 2;
layoutParams.y=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) + 70;
if (removeImg.getLayoutParams().height == remove_img_height) {
removeImg.getLayoutParams().height=(int)(remove_img_height * 1.5);
removeImg.getLayoutParams().width=(int)(remove_img_width * 1.5);
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(int)((szWindow.x - (remove_img_height * 1.5)) / 2);
int y_cord_remove=(int)(szWindow.y - ((remove_img_width * 1.5) + getStatusBarHeight()));
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
}
 else {
inBounded=false;
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(szWindow.x - removeView.getWidth()) / 2;
int y_cord_remove=szWindow.y - (removeView.getHeight() + getStatusBarHeight());
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
}
layoutParams.x=x_cord_Destination;
layoutParams.y=y_cord_Destination;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
case MotionEvent.ACTION_UP:
isLongclick=false;
removeView.setVisibility(View.GONE);
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
handler_longClick.removeCallbacks(runnable_longClick);
if (inBounded) {
if (MyDialog.active) {
MyDialog.myDialog.finish();
}
stopService(new Intent(ChatHeadService.this,ChatHeadService.class));
inBounded=false;
break;
}
int x_diff=x_cord - x_init_cord;
int y_diff=y_cord - y_init_cord;
if (Math.abs(x_diff) < 5 && Math.abs(y_diff) < 5) {
time_end=System.currentTimeMillis();
if ((time_end - time_start) < 300) {
chathead_click();
}
}
x_cord_Destination=x_init_margin + x_diff;
y_cord_Destination=y_init_margin + y_diff;
int x_start;
x_start=x_cord_Destination;
int BarHeight=getStatusBarHeight();
if (y_cord_Destination < 0) {
y_cord_Destination=0;
}
 else if (y_cord_Destination + (chatheadView.getHeight() + BarHeight) > szWindow.y) {
y_cord_Destination=szWindow.y - (chatheadView.getHeight() + BarHeight);
}
layoutParams.y=y_cord_Destination;
inBounded=false;
resetPosition(x_start);
break;
default :
Log.d(Utils.LogTag,""String_Node_Str"");
break;
}
return true;
}
}
);
txtView=(LinearLayout)inflater.inflate(R.layout.txt,null);
txt1=(TextView)txtView.findViewById(R.id.txt1);
txt_linearlayout=(LinearLayout)txtView.findViewById(R.id.txt_linearlayout);
WindowManager.LayoutParams paramsTxt=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,PixelFormat.TRANSLUCENT);
paramsTxt.gravity=Gravity.TOP | Gravity.LEFT;
txtView.setVisibility(View.GONE);
windowManager.addView(txtView,paramsTxt);
}"
55552,"@Override public boolean onTouch(View v,MotionEvent event){
  WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
  int x_cord=(int)event.getRawX();
  int y_cord=(int)event.getRawY();
  int x_cord_Destination, y_cord_Destination;
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    time_start=System.currentTimeMillis();
  handler_longClick.postDelayed(runnable_longClick,600);
remove_img_width=removeImg.getLayoutParams().width;
remove_img_height=removeImg.getLayoutParams().height;
x_init_cord=x_cord;
y_init_cord=y_cord;
x_init_margin=layoutParams.x;
y_init_margin=layoutParams.y;
if (txtView != null) {
txtView.setVisibility(View.GONE);
myHandler.removeCallbacks(myRunnable);
}
break;
case MotionEvent.ACTION_MOVE:
int x_diff_move=x_cord - x_init_cord;
int y_diff_move=y_cord - y_init_cord;
x_cord_Destination=x_init_margin + x_diff_move;
y_cord_Destination=y_init_margin + y_diff_move;
if (isLongclick) {
int x_bound_left=(szWindow.x - removeView.getWidth()) / 2 - 250;
int x_bound_right=(szWindow.x + removeView.getWidth()) / 2 + 100;
int y_bound_top=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) - 200;
if ((x_cord_Destination >= x_bound_left && x_cord_Destination <= x_bound_right) && y_cord_Destination >= y_bound_top) {
inBounded=true;
layoutParams.x=(szWindow.x - chatheadView.getWidth()) / 2;
layoutParams.y=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) + 70;
if (removeImg.getLayoutParams().height == remove_img_height) {
removeImg.getLayoutParams().height=(int)(remove_img_height * 1.5);
removeImg.getLayoutParams().width=(int)(remove_img_width * 1.5);
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(int)((szWindow.x - (remove_img_height * 1.5)) / 2);
int y_cord_remove=(int)(szWindow.y - ((remove_img_width * 1.5) + getStatusBarHeight()));
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
}
 else {
inBounded=false;
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(szWindow.x - removeView.getWidth()) / 2;
int y_cord_remove=szWindow.y - (removeView.getHeight() + getStatusBarHeight());
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
}
layoutParams.x=x_cord_Destination;
layoutParams.y=y_cord_Destination;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
case MotionEvent.ACTION_UP:
isLongclick=false;
removeView.setVisibility(View.GONE);
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
handler_longClick.removeCallbacks(runnable_longClick);
if (inBounded) {
if (MyDialog.active) {
MyDialog.myDialog.finish();
}
stopService(new Intent(ChatHeadService.this,ChatHeadService.class));
inBounded=false;
break;
}
int x_diff=x_cord - x_init_cord;
int y_diff=y_cord - y_init_cord;
if (x_diff < 5 && y_diff < 5) {
time_end=System.currentTimeMillis();
if ((time_end - time_start) < 300) {
chathead_click();
}
}
x_cord_Destination=x_init_margin + x_diff;
y_cord_Destination=y_init_margin + y_diff;
int x_start;
x_start=x_cord_Destination;
int BarHeight=getStatusBarHeight();
if (y_cord_Destination < 0) {
y_cord_Destination=0;
}
 else if (y_cord_Destination + (chatheadView.getHeight() + BarHeight) > szWindow.y) {
y_cord_Destination=szWindow.y - (chatheadView.getHeight() + BarHeight);
}
layoutParams.y=y_cord_Destination;
inBounded=false;
resetPosition(x_start);
break;
default :
Log.d(Utils.LogTag,""String_Node_Str"");
break;
}
return true;
}","@Override public boolean onTouch(View v,MotionEvent event){
  WindowManager.LayoutParams layoutParams=(WindowManager.LayoutParams)chatheadView.getLayoutParams();
  int x_cord=(int)event.getRawX();
  int y_cord=(int)event.getRawY();
  int x_cord_Destination, y_cord_Destination;
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    time_start=System.currentTimeMillis();
  handler_longClick.postDelayed(runnable_longClick,600);
remove_img_width=removeImg.getLayoutParams().width;
remove_img_height=removeImg.getLayoutParams().height;
x_init_cord=x_cord;
y_init_cord=y_cord;
x_init_margin=layoutParams.x;
y_init_margin=layoutParams.y;
if (txtView != null) {
txtView.setVisibility(View.GONE);
myHandler.removeCallbacks(myRunnable);
}
break;
case MotionEvent.ACTION_MOVE:
int x_diff_move=x_cord - x_init_cord;
int y_diff_move=y_cord - y_init_cord;
x_cord_Destination=x_init_margin + x_diff_move;
y_cord_Destination=y_init_margin + y_diff_move;
if (isLongclick) {
int x_bound_left=(szWindow.x - removeView.getWidth()) / 2 - 250;
int x_bound_right=(szWindow.x + removeView.getWidth()) / 2 + 100;
int y_bound_top=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) - 200;
if ((x_cord_Destination >= x_bound_left && x_cord_Destination <= x_bound_right) && y_cord_Destination >= y_bound_top) {
inBounded=true;
layoutParams.x=(szWindow.x - chatheadView.getWidth()) / 2;
layoutParams.y=szWindow.y - (removeView.getHeight() + getStatusBarHeight()) + 70;
if (removeImg.getLayoutParams().height == remove_img_height) {
removeImg.getLayoutParams().height=(int)(remove_img_height * 1.5);
removeImg.getLayoutParams().width=(int)(remove_img_width * 1.5);
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(int)((szWindow.x - (remove_img_height * 1.5)) / 2);
int y_cord_remove=(int)(szWindow.y - ((remove_img_width * 1.5) + getStatusBarHeight()));
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
}
 else {
inBounded=false;
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
WindowManager.LayoutParams param_remove=(WindowManager.LayoutParams)removeView.getLayoutParams();
int x_cord_remove=(szWindow.x - removeView.getWidth()) / 2;
int y_cord_remove=szWindow.y - (removeView.getHeight() + getStatusBarHeight());
param_remove.x=x_cord_remove;
param_remove.y=y_cord_remove;
windowManager.updateViewLayout(removeView,param_remove);
}
}
layoutParams.x=x_cord_Destination;
layoutParams.y=y_cord_Destination;
windowManager.updateViewLayout(chatheadView,layoutParams);
break;
case MotionEvent.ACTION_UP:
isLongclick=false;
removeView.setVisibility(View.GONE);
removeImg.getLayoutParams().height=remove_img_height;
removeImg.getLayoutParams().width=remove_img_width;
handler_longClick.removeCallbacks(runnable_longClick);
if (inBounded) {
if (MyDialog.active) {
MyDialog.myDialog.finish();
}
stopService(new Intent(ChatHeadService.this,ChatHeadService.class));
inBounded=false;
break;
}
int x_diff=x_cord - x_init_cord;
int y_diff=y_cord - y_init_cord;
if (Math.abs(x_diff) < 5 && Math.abs(y_diff) < 5) {
time_end=System.currentTimeMillis();
if ((time_end - time_start) < 300) {
chathead_click();
}
}
x_cord_Destination=x_init_margin + x_diff;
y_cord_Destination=y_init_margin + y_diff;
int x_start;
x_start=x_cord_Destination;
int BarHeight=getStatusBarHeight();
if (y_cord_Destination < 0) {
y_cord_Destination=0;
}
 else if (y_cord_Destination + (chatheadView.getHeight() + BarHeight) > szWindow.y) {
y_cord_Destination=szWindow.y - (chatheadView.getHeight() + BarHeight);
}
layoutParams.y=y_cord_Destination;
inBounded=false;
resetPosition(x_start);
break;
default :
Log.d(Utils.LogTag,""String_Node_Str"");
break;
}
return true;
}"
55553,"@Override public Object doEvaluate(Map<String,Object> argMap,Map<String,Object> kwargMap,List<Object> varArgs){
  JinjavaInterpreter interpreter=JinjavaInterpreter.getCurrent();
  try (InterpreterScopeClosable c=interpreter.enterScope()){
    for (    Map.Entry<String,Object> scopeEntry : localContextScope.getScope().entrySet()) {
      if (scopeEntry.getValue() instanceof MacroFunction) {
        interpreter.getContext().addGlobalMacro((MacroFunction)scopeEntry.getValue());
      }
 else {
        interpreter.getContext().put(scopeEntry.getKey(),scopeEntry.getValue());
      }
    }
    for (    Map.Entry<String,Object> argEntry : argMap.entrySet()) {
      interpreter.getContext().put(argEntry.getKey(),argEntry.getValue());
    }
    interpreter.getContext().put(""String_Node_Str"",argMap);
    interpreter.getContext().put(""String_Node_Str"",varArgs);
    LengthLimitingStringBuilder result=new LengthLimitingStringBuilder(interpreter.getConfig().getMaxOutputSize());
    for (    Node node : content) {
      result.append(node.render(interpreter));
    }
    return result.toString();
  }
 }","@Override public Object doEvaluate(Map<String,Object> argMap,Map<String,Object> kwargMap,List<Object> varArgs){
  JinjavaInterpreter interpreter=JinjavaInterpreter.getCurrent();
  try (InterpreterScopeClosable c=interpreter.enterScope()){
    for (    Map.Entry<String,Object> scopeEntry : localContextScope.getScope().entrySet()) {
      if (scopeEntry.getValue() instanceof MacroFunction) {
        interpreter.getContext().addGlobalMacro((MacroFunction)scopeEntry.getValue());
      }
 else {
        interpreter.getContext().put(scopeEntry.getKey(),scopeEntry.getValue());
      }
    }
    for (    Map.Entry<String,Object> argEntry : argMap.entrySet()) {
      interpreter.getContext().put(argEntry.getKey(),argEntry.getValue());
    }
    interpreter.getContext().put(""String_Node_Str"",kwargMap);
    interpreter.getContext().put(""String_Node_Str"",varArgs);
    LengthLimitingStringBuilder result=new LengthLimitingStringBuilder(interpreter.getConfig().getMaxOutputSize());
    for (    Node node : content) {
      result.append(node.render(interpreter));
    }
    return result.toString();
  }
 }"
55554,"@Test public void itRetainsFieldNameCaseForUnknownToken(){
  interpreter.render(""String_Node_Str"");
  assertThat(interpreter.getErrors().get(0).getFieldName()).isEqualTo(""String_Node_Str"");
}","@Test public void itRetainsFieldNameCaseForUnknownToken(){
  JinjavaInterpreter interpreter=new Jinjava().newInterpreter();
  interpreter.render(""String_Node_Str"");
  assertThat(interpreter.getErrors().get(0).getFieldName()).isEqualTo(""String_Node_Str"");
}"
55555,"@Test public void itSetsFieldNameCaseForSyntaxErrorInFor(){
  RenderResult renderResult=jinjava.renderForResult(""String_Node_Str"",ImmutableMap.of());
  assertThat(renderResult.getErrors().get(0).getFieldName()).isEqualTo(""String_Node_Str"");
}","@Test public void itSetsFieldNameCaseForSyntaxErrorInFor(){
  RenderResult renderResult=new Jinjava().renderForResult(""String_Node_Str"",ImmutableMap.of());
  assertThat(renderResult.getErrors().get(0).getFieldName()).isEqualTo(""String_Node_Str"");
}"
55556,"private Token newToken(int kind){
  Token t=Token.newToken(kind,String.valueOf(is,lastStart,tokenLength),currLine);
  if (t instanceof TagToken) {
    if (config.isTrimBlocks() && is[currPost] == '\n') {
      ++currPost;
      ++tokenStart;
    }
    TagToken tt=(TagToken)t;
    if (""String_Node_Str"".equals(tt.getTagName())) {
      inRaw=1;
      return tt;
    }
 else     if (""String_Node_Str"".equals(tt.getTagName())) {
      inRaw=0;
      return tt;
    }
  }
  if (inRaw > 0 && t.getType() != TOKEN_FIXED) {
    return Token.newToken(TOKEN_FIXED,t.image,currLine);
  }
  return t;
}","private Token newToken(int kind){
  Token t=Token.newToken(kind,String.valueOf(is,lastStart,tokenLength),currLine);
  if (t instanceof TagToken) {
    if (config.isTrimBlocks() && currPost < length && is[currPost] == '\n') {
      ++currPost;
      ++tokenStart;
    }
    TagToken tt=(TagToken)t;
    if (""String_Node_Str"".equals(tt.getTagName())) {
      inRaw=1;
      return tt;
    }
 else     if (""String_Node_Str"".equals(tt.getTagName())) {
      inRaw=0;
      return tt;
    }
  }
  if (inRaw > 0 && t.getType() != TOKEN_FIXED) {
    return Token.newToken(TOKEN_FIXED,t.image,currLine);
  }
  return t;
}"
55557,"private List<Token> tokens(String fixture){
  TokenScanner t=fixture(fixture);
  List<Token> tokens=Lists.newArrayList();
  while (t.hasNext()) {
    tokens.add(t.next());
  }
  return tokens;
}","private List<Token> tokens(String fixture){
  TokenScanner t=fixture(fixture);
  return Lists.newArrayList(t);
}"
55558,"@Override public String interpret(TagNode tagNode,JinjavaInterpreter interpreter){
  HelperStringTokenizer helper=new HelperStringTokenizer(tagNode.getHelpers());
  if (!helper.hasNext()) {
    throw new InterpretException(""String_Node_Str"",tagNode.getLineNumber());
  }
  String path=StringUtils.trimToEmpty(helper.next());
  if (isPathInRenderStack(interpreter.getContext(),path)) {
    ENGINE_LOG.debug(""String_Node_Str"",path);
    return ""String_Node_Str"";
  }
  interpreter.getContext().put(INCLUDE_PATH_PROPERTY,path);
  String templateFile=interpreter.resolveString(path,tagNode.getLineNumber());
  try {
    String template=interpreter.getResource(templateFile);
    Node node=interpreter.parse(template);
    JinjavaInterpreter child=new JinjavaInterpreter(interpreter);
    interpreter.getContext().put(JinjavaInterpreter.INSERT_FLAG,true);
    return child.render(node);
  }
 catch (  IOException e) {
    throw new InterpretException(e.getMessage(),e,tagNode.getLineNumber());
  }
}","@Override public String interpret(TagNode tagNode,JinjavaInterpreter interpreter){
  HelperStringTokenizer helper=new HelperStringTokenizer(tagNode.getHelpers());
  if (!helper.hasNext()) {
    throw new InterpretException(""String_Node_Str"",tagNode.getLineNumber());
  }
  String path=StringUtils.trimToEmpty(helper.next());
  if (isPathInRenderStack(interpreter.getContext(),path)) {
    ENGINE_LOG.debug(""String_Node_Str"",path);
    return ""String_Node_Str"";
  }
  String templateFile=interpreter.resolveString(path,tagNode.getLineNumber());
  try {
    String template=interpreter.getResource(templateFile);
    Node node=interpreter.parse(template);
    JinjavaInterpreter child=new JinjavaInterpreter(interpreter);
    child.getContext().put(INCLUDE_PATH_PROPERTY,path);
    interpreter.getContext().put(JinjavaInterpreter.INSERT_FLAG,true);
    return child.render(node);
  }
 catch (  IOException e) {
    throw new InterpretException(e.getMessage(),e,tagNode.getLineNumber());
  }
}"
55559,"@Test public void itAvoidsNestedIncludeCycles() throws IOException {
  String result=jinjava.render(Resources.toString(Resources.getResource(""String_Node_Str""),StandardCharsets.UTF_8),new HashMap<String,Object>());
  System.out.println(result);
  assertThat(result).containsSequence(""String_Node_Str"",""String_Node_Str"");
}","@Test public void itAvoidsNestedIncludeCycles() throws IOException {
  String result=jinjava.render(Resources.toString(Resources.getResource(""String_Node_Str""),StandardCharsets.UTF_8),new HashMap<String,Object>());
  assertThat(result).containsSequence(""String_Node_Str"",""String_Node_Str"");
}"
55560,"@Override public Object filter(Object var,JinjavaInterpreter interpreter,String... args){
  if (var == null) {
    return var;
  }
  boolean reverse=false;
  if (args.length > 0) {
    reverse=BooleanUtils.toBoolean(args[0]);
  }
  boolean caseSensitive=false;
  if (args.length > 1) {
    caseSensitive=BooleanUtils.toBoolean(args[1]);
  }
  String attr=null;
  if (args.length > 2) {
    attr=args[2];
  }
  List<?> result=Lists.newArrayList(ObjectIterator.getLoop(var));
  Collections.sort(result,new ObjectComparator(reverse,caseSensitive,attr));
  return result;
}","@Override public Object filter(Object var,JinjavaInterpreter interpreter,String... args){
  if (var == null) {
    return var;
  }
  boolean reverse=false;
  if (args.length > 0) {
    reverse=BooleanUtils.toBoolean(args[0]);
  }
  boolean caseSensitive=false;
  if (args.length > 1) {
    caseSensitive=BooleanUtils.toBoolean(args[1]);
  }
  String attr=null;
  if (args.length > 2) {
    attr=args[2];
  }
  List<?> result=Lists.newArrayList(ObjectIterator.getLoop(var));
  Collections.sort(result,new ObjectComparator(interpreter,reverse,caseSensitive,attr));
  return result;
}"
55561,"@SuppressWarnings(""String_Node_Str"") @Override public int compare(Object o1,Object o2){
  int result=0;
  if (attr != null) {
    o1=new VariableChain(Lists.newArrayList(attr),o1).resolve();
    o2=new VariableChain(Lists.newArrayList(attr),o2).resolve();
  }
  if (o1 instanceof String && !caseSensitive) {
    result=((String)o1).compareToIgnoreCase((String)o2);
  }
 else   if (Comparable.class.isAssignableFrom(o1.getClass()) && Comparable.class.isAssignableFrom(o2.getClass())) {
    result=((Comparable<Object>)o1).compareTo(o2);
  }
  if (reverse) {
    result=-1 * result;
  }
  return result;
}","@SuppressWarnings(""String_Node_Str"") @Override public int compare(Object o1,Object o2){
  int result=0;
  if (variable != null) {
    o1=variable.resolve(o1);
    o2=variable.resolve(o2);
  }
  if (o1 instanceof String && !caseSensitive) {
    result=((String)o1).compareToIgnoreCase((String)o2);
  }
 else   if (Comparable.class.isAssignableFrom(o1.getClass()) && Comparable.class.isAssignableFrom(o2.getClass())) {
    result=((Comparable<Object>)o1).compareTo(o2);
  }
  if (reverse) {
    result=-1 * result;
  }
  return result;
}"
55562,"public ObjectComparator(boolean reverse,boolean caseSensitive,String attr){
  this.reverse=reverse;
  this.caseSensitive=caseSensitive;
  this.attr=attr;
}","public ObjectComparator(JinjavaInterpreter interpreter,boolean reverse,boolean caseSensitive,String attr){
  this.reverse=reverse;
  this.caseSensitive=caseSensitive;
  if (attr != null) {
    this.variable=new Variable(interpreter,""String_Node_Str"" + attr);
  }
 else {
    this.variable=null;
  }
}"
55563,"@Override public String toString(){
  return ""String_Node_Str"" + date.getTime();
}","@Override public String toString(){
  return foo.toString();
}"
55564,"/** 
 * Parses a string in python strftime format, returning the equivalent string in java date time format.
 * @param strftime
 * @return date formatted as string
 */
private static String toJavaDateTimeFormat(String strftime){
  if (!StringUtils.contains(strftime,'%')) {
    return replaceL(strftime);
  }
  StringBuilder result=new StringBuilder();
  for (int i=0; i < strftime.length(); i++) {
    char c=strftime.charAt(i);
    if (c == '%') {
      c=strftime.charAt(++i);
      boolean stripLeadingZero=false;
      if (c == '-') {
        stripLeadingZero=true;
        c=strftime.charAt(++i);
      }
      if (stripLeadingZero) {
        result.append(CONVERSIONS.get(c).substring(1));
      }
 else {
        result.append(CONVERSIONS.get(c));
      }
    }
 else     if (Character.isLetter(c)) {
      result.append(""String_Node_Str"");
      while (Character.isLetter(c)) {
        result.append(c);
        c=strftime.charAt(++i);
      }
      result.append(""String_Node_Str"");
      --i;
    }
 else {
      result.append(c);
    }
  }
  return replaceL(result.toString());
}","/** 
 * Parses a string in python strftime format, returning the equivalent string in java date time format.
 * @param strftime
 * @return date formatted as string
 */
private static String toJavaDateTimeFormat(String strftime){
  if (!StringUtils.contains(strftime,'%')) {
    return replaceL(strftime);
  }
  StringBuilder result=new StringBuilder();
  for (int i=0; i < strftime.length(); i++) {
    char c=strftime.charAt(i);
    if (c == '%') {
      c=strftime.charAt(++i);
      boolean stripLeadingZero=false;
      if (c == '-') {
        stripLeadingZero=true;
        c=strftime.charAt(++i);
      }
      if (stripLeadingZero) {
        result.append(CONVERSIONS.get(c).substring(1));
      }
 else {
        result.append(CONVERSIONS.get(c));
      }
    }
 else     if (Character.isLetter(c)) {
      result.append(""String_Node_Str"");
      while (Character.isLetter(c)) {
        result.append(c);
        if (++i < strftime.length()) {
          c=strftime.charAt(i);
        }
 else {
          c=0;
        }
      }
      result.append(""String_Node_Str"");
      --i;
    }
 else {
      result.append(c);
    }
  }
  return replaceL(result.toString());
}"
55565,"public void setWaypoint(EWaypointType waypointType,ShortPoint2D position){
  if (waypointType != EWaypointType.DESTINATION && !isTargetSet()) {
    waypointType=EWaypointType.DESTINATION;
  }
  if (isSelected()) {
    drawWaypointLine(false);
  }
  if (waypointType == EWaypointType.DESTINATION) {
    Arrays.fill(waypoints,null);
  }
  ShortPoint2D closeReachableLocation=findClosestReachablePosition(waypointType,position);
  if (closeReachableLocation != null && !isWaypointFulfillingPreconditions(waypointType,closeReachableLocation)) {
    return;
  }
  waypoints[waypointType.ordinal()]=closeReachableLocation;
  if (isSelected()) {
    drawWaypointLine(true);
  }
}","public void setWaypoint(EWaypointType waypointType,ShortPoint2D position){
  if (waypointType != EWaypointType.DESTINATION && !isTargetSet()) {
    waypointType=EWaypointType.DESTINATION;
  }
  if (isSelected()) {
    drawWaypointLine(false);
  }
  if (waypointType == EWaypointType.DESTINATION) {
    Arrays.fill(waypoints,null);
  }
  ShortPoint2D closestReachableLocation=findClosestReachablePosition(waypointType,position);
  if (closestReachableLocation == null || !isWaypointFulfillingPreconditions(waypointType,closestReachableLocation)) {
    return;
  }
  waypoints[waypointType.ordinal()]=closestReachableLocation;
  if (isSelected()) {
    drawWaypointLine(true);
  }
}"
55566,"@Override public boolean isCoastReachable(ShortPoint2D position){
  return !HexGridArea.stream(position.x,position.y,0,2).filterBounds(width,height).filter((x,y) -> !landscapeGrid.getLandscapeTypeAt(x,y).isWater).isEmpty();
}","@Override public boolean isCoastReachable(ShortPoint2D position){
  return !HexGridArea.stream(position.x,position.y,0,3).filterBounds(width,height).filter((x,y) -> !landscapeGrid.getLandscapeTypeAt(x,y).isWater).isEmpty();
}"
55567,"private Set<Integer> occupyMilitaryBuildings(){
  Set<Integer> soldiersWithOrders=new HashSet<>();
  for (  ShortPoint2D militaryBuildingPosition : aiStatistics.getBuildingPositionsOfTypesForPlayer(EBuildingType.MILITARY_BUILDINGS,playerId)) {
    OccupyingBuilding militaryBuilding=(OccupyingBuilding)aiStatistics.getBuildingAt(militaryBuildingPosition);
    if (!militaryBuilding.isOccupied()) {
      ShortPoint2D door=militaryBuilding.getDoor();
      IMovable soldier=aiStatistics.getNearestSwordsmanOf(door,playerId);
      if (soldier != null && militaryBuilding.getPosition().getOnGridDistTo(soldier.getPosition()) > TOWER_SEARCH_RADIUS) {
        soldiersWithOrders.add(soldier.getID());
        sendMovableTo(soldier,door);
      }
    }
  }
  return soldiersWithOrders;
}","private Set<Integer> occupyMilitaryBuildings(){
  Set<Integer> soldiersWithOrders=new HashSet<>();
  for (  ShortPoint2D militaryBuildingPosition : aiStatistics.getBuildingPositionsOfTypesForPlayer(EBuildingType.MILITARY_BUILDINGS,playerId)) {
    OccupyingBuilding militaryBuilding=(OccupyingBuilding)aiStatistics.getBuildingAt(militaryBuildingPosition);
    if (!militaryBuilding.isOccupied()) {
      ShortPoint2D door=militaryBuilding.getDoor();
      IMovable soldier=aiStatistics.getNearestSwordsmanOf(door,playerId);
      if (soldier != null && militaryBuilding.getPosition().getOnGridDistTo(soldier.getPosition()) > TOWER_SEARCH_SOLDIERS_RADIUS) {
        soldiersWithOrders.add(soldier.getID());
        sendMovableTo(soldier,door);
      }
    }
  }
  return soldiersWithOrders;
}"
55568,"private void changeTowerSoldiers(ChangeTowerSoldiersGuiTask soldierTask){
  ShortPoint2D buildingPosition=soldierTask.getBuildingPos();
  OccupyingBuilding occupyingBuilding=(OccupyingBuilding)grid.getBuildingAt(buildingPosition.x,buildingPosition.y);
switch (soldierTask.getTaskType()) {
case FULL:
    occupyingBuilding.requestFullSoldiers();
  break;
case MORE:
occupyingBuilding.requestSoldier(soldierTask.getSoldierType());
break;
case ONE:
occupyingBuilding.releaseSoldiers();
break;
case LESS:
occupyingBuilding.releaseSoldier(soldierTask.getSoldierType());
break;
}
}","private void changeTowerSoldiers(ChangeTowerSoldiersGuiTask soldierTask){
  ShortPoint2D buildingPosition=soldierTask.getBuildingPos();
  OccupyingBuilding occupyingBuilding=(OccupyingBuilding)grid.getBuildingAt(buildingPosition.x,buildingPosition.y);
  if (occupyingBuilding == null) {
    return;
  }
switch (soldierTask.getTaskType()) {
case FULL:
    occupyingBuilding.requestFullSoldiers();
  break;
case MORE:
occupyingBuilding.requestSoldier(soldierTask.getSoldierType());
break;
case ONE:
occupyingBuilding.releaseSoldiers();
break;
case LESS:
occupyingBuilding.releaseSoldier(soldierTask.getSoldierType());
break;
}
}"
55569,"private void searchSoldiersIfNeeded(){
  if (!searchedSoldiers.isEmpty()) {
    if (dijkstraRequest == null) {
      dijkstraRequest=new DijkstraContinuableRequest(this,super.pos.x,super.pos.y,(short)1,Constants.TOWER_SEARCH_RADIUS);
    }
    dijkstraRequest.setSearchTypes(searchedSoldiers.getRequestedSearchTypes());
    Path path=super.grid.getDijkstra().find(dijkstraRequest);
    if (path != null) {
      ILogicMovable soldier=super.grid.getMovable(path.getTargetPosition());
      if (soldier != null) {
        IBuildingOccupyableMovable occupier=soldier.setOccupyableBuilding(this);
        if (occupier != null) {
          SoldierRequest soldierRequest=searchedSoldiers.removeOne(occupier.getMovableType().getSoldierType());
          comingSoldiers.put(occupier,soldierRequest);
          dijkstraRequest.reset();
        }
      }
    }
  }
}","private void searchSoldiersIfNeeded(){
  if (!searchedSoldiers.isEmpty()) {
    if (dijkstraRequest == null) {
      dijkstraRequest=new DijkstraContinuableRequest(this,super.pos.x,super.pos.y,(short)1,Constants.TOWER_SEARCH_SOLDIERS_RADIUS);
    }
    dijkstraRequest.setSearchTypes(searchedSoldiers.getRequestedSearchTypes());
    Path path=super.grid.getDijkstra().find(dijkstraRequest);
    if (path != null) {
      ILogicMovable soldier=super.grid.getMovable(path.getTargetPosition());
      if (soldier != null) {
        IBuildingOccupyableMovable occupier=soldier.setOccupyableBuilding(this);
        if (occupier != null) {
          SoldierRequest soldierRequest=searchedSoldiers.removeOne(occupier.getMovableType().getSoldierType());
          comingSoldiers.put(occupier,soldierRequest);
          dijkstraRequest.reset();
        }
      }
    }
  }
}"
55570,"/** 
 * Informs towers of the attackable in their search radius..
 * @param position The new position of the movable.
 * @param attackable The attackable that moved to the given position.
 * @param informFullArea if true, the full area is informed<br> if false, only the border of the area is informed.
 * @param informAttackable
 */
public void informObjectsAboutAttackable(ShortPoint2D position,IAttackable attackable,boolean informFullArea,boolean informAttackable){
  CoordinateStream area;
  if (informFullArea) {
    area=HexGridArea.stream(position.x,position.y,1,Constants.TOWER_SEARCH_RADIUS);
  }
 else {
    area=HexGridArea.streamBorder(position.x,position.y,Constants.TOWER_SEARCH_RADIUS - 1);
  }
  byte movableTeam=attackable.getPlayer().getTeamId();
  area.filterBounds(width,height).forEach((x,y) -> {
    IAttackable currTower=(IAttackable)getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
    if (currTower != null && currTower.getPlayer().getTeamId() != movableTeam) {
      currTower.informAboutAttackable(attackable);
      if (informAttackable) {
        attackable.informAboutAttackable(currTower);
      }
    }
    IInformable currInformable=(IInformable)getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT);
    if (currInformable != null) {
      currInformable.informAboutAttackable(attackable);
    }
  }
);
}","/** 
 * Informs towers of the attackable in their search radius..
 * @param position The new position of the movable.
 * @param attackable The attackable that moved to the given position.
 * @param informFullArea if true, the full area is informed<br> if false, only the border of the area is informed.
 * @param informAttackable
 */
public void informObjectsAboutAttackable(ShortPoint2D position,IAttackable attackable,boolean informFullArea,boolean informAttackable){
  CoordinateStream area;
  if (informFullArea) {
    area=HexGridArea.stream(position.x,position.y,1,Constants.TOWER_ATTACKABLE_SEARCH_RADIUS);
  }
 else {
    area=HexGridArea.streamBorder(position.x,position.y,Constants.TOWER_ATTACKABLE_SEARCH_RADIUS - 1);
  }
  byte movableTeam=attackable.getPlayer().getTeamId();
  area.filterBounds(width,height).forEach((x,y) -> {
    IAttackable currTower=(IAttackable)getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
    if (currTower != null && currTower.getPlayer().getTeamId() != movableTeam) {
      currTower.informAboutAttackable(attackable);
      if (informAttackable) {
        attackable.informAboutAttackable(currTower);
      }
    }
    IInformable currInformable=(IInformable)getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT);
    if (currInformable != null) {
      currInformable.informAboutAttackable(attackable);
    }
  }
);
}"
55571,"@Override protected short getMaxSearchDistance(boolean isInTower){
  return isInTower ? Constants.TOWER_SEARCH_RADIUS : Constants.SOLDIER_SEARCH_RADIUS;
}","@Override protected short getMaxSearchDistance(boolean isInTower){
  return isInTower ? Constants.TOWER_ATTACKABLE_SEARCH_RADIUS : Constants.SOLDIER_SEARCH_RADIUS;
}"
55572,"private JSettlersGame.GameRunner createStartingGame(PlayerSetting[] playerSettings) throws MapLoadException {
  byte playerId=0;
  for (byte i=0; i < playerSettings.length; i++) {
    if (playerSettings[i].isAvailable()) {
      playerId=i;
      break;
    }
  }
  MapLoader mapCreator=MapUtils.getSpezialSumpf();
  JSettlersGame game=new JSettlersGame(mapCreator,2L,new OfflineNetworkConnector(),playerId,playerSettings);
  return (JSettlersGame.GameRunner)game.start();
}","private JSettlersGame.GameRunner createStartingGame(PlayerSetting[] playerSettings) throws MapLoadException {
  byte playerId=0;
  for (byte i=0; i < playerSettings.length; i++) {
    if (playerSettings[i].isAvailable()) {
      playerId=i;
      break;
    }
  }
  MapLoader mapCreator=MapUtils.getSpezialSumpf();
  JSettlersGame game=new JSettlersGame(mapCreator,1L,new OfflineNetworkConnector(),playerId,playerSettings);
  return (JSettlersGame.GameRunner)game.start();
}"
55573,void onDirectorySelected();,void onDirectorySelected(File resourceDirectory);
55574,"@NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState){
  LayoutInflater layoutInflater=LayoutInflater.from(getActivity());
  View view=layoutInflater.inflate(R.layout.dialog_directory_picker,null);
  ProgressBar progressBar=view.findViewById(R.id.progressBar);
  ListView listView=view.findViewById(R.id.listView);
  listView.setAdapter(directoryAdapter);
  listView.setOnItemClickListener((arg0,arg1,position,arg3) -> {
    directoryAdapter.positionSelected(position);
    setButtonState();
  }
);
  AlertDialog alertDialog=new AlertDialog.Builder(getActivity()).setTitle(R.string.resource_selection_dialog_title).setView(view).setPositiveButton(R.string.ok,null).create();
  alertDialog.setOnShowListener(dialog -> {
    Button button=alertDialog.getButton(DialogInterface.BUTTON_POSITIVE);
    button.setOnClickListener(v -> {
      button.setEnabled(false);
      progressBar.setVisibility(View.VISIBLE);
      setDirectoryTask=new SetResourcesTask(getActivity().getApplication()).execute(directoryAdapter.getCurrentDirectory());
    }
);
  }
);
  return alertDialog;
}","@NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState){
  LayoutInflater layoutInflater=LayoutInflater.from(getActivity());
  View view=layoutInflater.inflate(R.layout.dialog_directory_picker,null);
  ProgressBar progressBar=view.findViewById(R.id.progressBar);
  ListView listView=view.findViewById(R.id.listView);
  listView.setAdapter(directoryAdapter);
  listView.setOnItemClickListener((arg0,arg1,position,arg3) -> {
    directoryAdapter.positionSelected(position);
    setButtonState();
  }
);
  AlertDialog alertDialog=new AlertDialog.Builder(getActivity()).setTitle(R.string.resource_selection_dialog_title).setView(view).setPositiveButton(R.string.ok,null).create();
  alertDialog.setOnShowListener(dialog -> {
    Button button=alertDialog.getButton(DialogInterface.BUTTON_POSITIVE);
    button.setOnClickListener(v -> {
      setCancelable(false);
      listView.setEnabled(false);
      button.setEnabled(false);
      progressBar.setVisibility(View.VISIBLE);
      ((Listener)getParentFragment()).onDirectorySelected(directoryAdapter.getCurrentDirectory());
    }
);
  }
);
  return alertDialog;
}"
55575,"/** 
 * DirectoryPickerDialog.Listener implementation
 */
@Override public void onDirectorySelected(){
  viewModel.resourceDirectoryChosen();
}","/** 
 * DirectoryPickerDialog.Listener implementation
 */
@Override public void onDirectorySelected(File resourceDirectory){
  viewModel.resourceDirectoryChosen(resourceDirectory);
}"
55576,"@Override public void onActivityCreated(@Nullable Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  viewModel.getResumeState().observe(this,this::updateResumeView);
  viewModel.getAreResourcesLoaded().observe(this,this::updateResourceView);
  viewModel.getAreResourcesLoaded().observe(this,newSinglePlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,loadSinglePlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,newMultiPlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,joinMultiPlayerButton::setEnabled);
  viewModel.getShowSinglePlayer().observe(this,z -> mainMenuNavigator.showNewSinglePlayerPicker());
  viewModel.getShowLoadSinglePlayer().observe(this,z -> mainMenuNavigator.showLoadSinglePlayerPicker());
  viewModel.getShowMultiplayerPlayer().observe(this,z -> mainMenuNavigator.showNewMultiPlayerPicker());
  viewModel.getShowJoinMultiplayerPlayer().observe(this,z -> mainMenuNavigator.showJoinMultiPlayerPicker());
}","@Override public void onActivityCreated(@Nullable Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  viewModel.getResumeState().observe(this,this::updateResumeView);
  viewModel.getAreResourcesLoaded().observe(this,this::updateResourceView);
  viewModel.getAreResourcesLoaded().observe(this,newSinglePlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,loadSinglePlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,newMultiPlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,joinMultiPlayerButton::setEnabled);
  viewModel.getAreResourcesLoaded().observe(this,this::dismissResourceDialog);
  viewModel.getShowSinglePlayer().observe(this,z -> mainMenuNavigator.showNewSinglePlayerPicker());
  viewModel.getShowLoadSinglePlayer().observe(this,z -> mainMenuNavigator.showLoadSinglePlayerPicker());
  viewModel.getShowMultiplayerPlayer().observe(this,z -> mainMenuNavigator.showNewMultiPlayerPicker());
  viewModel.getShowJoinMultiplayerPlayer().observe(this,z -> mainMenuNavigator.showJoinMultiPlayerPicker());
}"
55577,"@Click(R.id.button_resources) void showDirectoryPicker(){
  if (ContextCompat.checkSelfPermission(getActivity(),Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
    requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_CODE_PERMISSION_STORAGE);
  }
 else {
    DirectoryPickerDialog.newInstance().show(getChildFragmentManager(),null);
  }
}","@Click(R.id.button_resources) void showDirectoryPicker(){
  if (ContextCompat.checkSelfPermission(getActivity(),Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
    requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},REQUEST_CODE_PERMISSION_STORAGE);
  }
 else {
    DirectoryPickerDialog.newInstance().show(getChildFragmentManager(),TAG_RESOURCE_DIALOG);
  }
}"
55578,"public void resourceDirectoryChosen(){
  boolean resourcesLoaded=androidResourcesLoader.setup();
  if (resourcesLoaded) {
    areResourcesLoaded.setValue(true);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public void resourceDirectoryChosen(File resourceDirectory){
  androidResourcesLoader.setResourcesDirectory(resourceDirectory.getAbsolutePath());
  Disposable resourceSetupSubscription=androidResourcesLoader.setupSingle().subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(() -> {
    areResourcesLoaded.postValue(true);
  }
);
}"
55579,"NewFoWThread(){
  super(""String_Node_Str"");
  super.setDaemon(true);
  this.buffer=new byte[width][height];
  drawer=new CircleDrawer();
}","NewFoWThread(){
  super(""String_Node_Str"");
  super.setDaemon(true);
}"
55580,"@Override public final void run(){
  mySleep(500);
  while (!canceled) {
    if (enabled) {
      rebuildSight();
    }
    mySleep(800);
  }
}","@Override public final void run(){
  mySleep(500L);
  while (!canceled) {
    if (enabled) {
      rebuildSight();
    }
    mySleep(800L);
  }
}"
55581,"private void mySleep(int ms){
  try {
    Thread.sleep(ms);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","private void mySleep(long ms){
  try {
    Thread.sleep(ms);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
55582,"private void rebuildSight(){
  drawer.setBuffer(buffer);
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      byte currSight=sight[x][y];
      if (currSight >= CommonConstants.FOG_OF_WAR_EXPLORED) {
        byte newSight=(byte)(currSight - DIM_DOWN_SPEED);
        if (newSight < CommonConstants.FOG_OF_WAR_EXPLORED) {
          buffer[x][y]=CommonConstants.FOG_OF_WAR_EXPLORED;
        }
 else {
          buffer[x][y]=newSight;
        }
      }
 else {
        buffer[x][y]=sight[x][y];
      }
    }
  }
  ConcurrentLinkedQueue<? extends IViewDistancable> buildings=grid.getBuildingViewDistancables();
  applyViewDistances(buildings);
  ConcurrentLinkedQueue<? extends IViewDistancable> movables=grid.getMovableViewDistancables();
  applyViewDistances(movables);
  byte[][] temp=sight;
  sight=buffer;
  buffer=temp;
}","private void rebuildSight(){
  drawer.setBuffer(buffer);
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      byte currSight=sight[x][y];
      if (currSight >= CommonConstants.FOG_OF_WAR_EXPLORED) {
        byte newSight=(byte)(currSight - DIM_DOWN_SPEED);
        if (newSight < CommonConstants.FOG_OF_WAR_EXPLORED) {
          buffer[x][y]=CommonConstants.FOG_OF_WAR_EXPLORED;
        }
 else {
          buffer[x][y]=newSight;
        }
      }
 else {
        buffer[x][y]=sight[x][y];
      }
    }
  }
  ConcurrentLinkedQueue<? extends IViewDistancable> buildings=grid.getBuildingViewDistancables();
  applyViewDistances(buildings);
  ConcurrentLinkedQueue<? extends IViewDistancable> movables=grid.getMovableViewDistancables();
  applyViewDistances(movables);
  byte[][] temp=sight;
  sight=buffer;
  buffer=temp;
}"
55583,"public static synchronized void stopAndClear(){
  if (uniIns != null) {
    if (MatchConstants.clock() != null) {
      MatchConstants.clock().remove(uniIns);
    }
    uniIns=null;
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
    }
  }
}","public static synchronized void stopAndClear(){
  if (uniIns != null) {
    if (MatchConstants.clock() != null) {
      MatchConstants.clock().remove(uniIns);
    }
    uniIns=null;
    try {
      Thread.sleep(100L);
    }
 catch (    InterruptedException e) {
    }
  }
}"
55584,"private void waitForAllPlayersStartFinished(INetworkConnector networkConnector){
  while (!networkConnector.haveAllPlayersStartFinished()) {
    try {
      Thread.sleep(5);
    }
 catch (    InterruptedException e) {
    }
  }
}","private void waitForAllPlayersStartFinished(INetworkConnector networkConnector){
  while (!networkConnector.haveAllPlayersStartFinished()) {
    try {
      Thread.sleep(5L);
    }
 catch (    InterruptedException e) {
    }
  }
}"
55585,"/** 
 * Waits until the   {@link #startingGameListener} has been set.
 */
private void waitForStartingGameListener(){
  while (startingGameListener == null) {
    try {
      Thread.sleep(5);
    }
 catch (    InterruptedException e) {
    }
  }
}","/** 
 * Waits until the   {@link #startingGameListener} has been set.
 */
private void waitForStartingGameListener(){
  while (startingGameListener == null) {
    try {
      Thread.sleep(5L);
    }
 catch (    InterruptedException e) {
    }
  }
}"
55586,"@Test public void testSpeed() throws MapLoadException, InterruptedException {
  MatchConstants.init(new NetworkTimer(true),0);
  MainGrid grid=MapUtils.getBigMap().loadMainGrid(null).getMainGrid();
  MainGridDataAccessor gridAccessor=new MainGridDataAccessor(grid);
  short width=gridAccessor.getWidth();
  short height=gridAccessor.getHeight();
  BitSet notBlockingSet=new BitSet(width * height);
  LandscapeGrid landscapeGrid=gridAccessor.getLandscapeGrid();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockingSet.set(x + y * width,!landscapeGrid.getLandscapeTypeAt(x,y).isBlocking);
    }
  }
  Thread.sleep(500);
  MilliStopWatch watch=new MilliStopWatch();
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockingSet,IBlockingProvider.DEFAULT_IMPLEMENTATION);
  partitioner.calculatePartitions();
  System.out.println(""String_Node_Str"" + partitioner.getNumberOfPartitions());
  watch.stop(""String_Node_Str"");
}","@Test public void testSpeed() throws MapLoadException, InterruptedException {
  MatchConstants.init(new NetworkTimer(true),0);
  MainGrid grid=MapUtils.getBigMap().loadMainGrid(null).getMainGrid();
  MainGridDataAccessor gridAccessor=new MainGridDataAccessor(grid);
  short width=gridAccessor.getWidth();
  short height=gridAccessor.getHeight();
  BitSet notBlockingSet=new BitSet(width * height);
  LandscapeGrid landscapeGrid=gridAccessor.getLandscapeGrid();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockingSet.set(x + y * width,!landscapeGrid.getLandscapeTypeAt(x,y).isBlocking);
    }
  }
  Thread.sleep(500L);
  MilliStopWatch watch=new MilliStopWatch();
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockingSet,IBlockingProvider.DEFAULT_IMPLEMENTATION);
  partitioner.calculatePartitions();
  System.out.println(""String_Node_Str"" + partitioner.getNumberOfPartitions());
  watch.stop(""String_Node_Str"");
}"
55587,"@Test public void testIfSavegameOfSavegameEqualsSavegame() throws IOException, MapLoadException, ClassNotFoundException, InterruptedException {
  final byte playerId=0;
  final int targetTimeMinutes=30;
  MapLoader map=MapUtils.getMountainlake();
  ReplayUtils.PlayMapResult directSavegameReplay=ReplayUtils.playMapToTargetTimes(map,playerId,targetTimeMinutes);
  assertDirectSavegameReplay(1,directSavegameReplay);
  MapLoader savegame=directSavegameReplay.getSavegames()[0];
  Thread.sleep(2000);
  System.out.println(""String_Node_Str"");
  MatchConstants.init(new NetworkTimer(true),0L);
  MainGridWithUiSettings loadedMap=savegame.loadMainGrid(PlayerSetting.createDefaultSettings(playerId,(byte)savegame.getMaxPlayers()));
  MainGrid mainGrid=loadedMap.getMainGrid();
  PlayerState playerState=loadedMap.getPlayerState(playerId);
  mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
  MapLoader savegameOfSavegame;
  try {
    System.out.println(""String_Node_Str"");
    savegameOfSavegame=MapUtils.saveMainGrid(mainGrid,playerId,playerState.getUiState());
    assertNotNull(savegameOfSavegame);
  }
  finally {
    mainGrid.stopThreads();
    JSettlersGame.clearState();
  }
  MapUtils.compareMapFiles(savegame,savegameOfSavegame);
}","@Test public void testIfSavegameOfSavegameEqualsSavegame() throws IOException, MapLoadException, ClassNotFoundException, InterruptedException {
  final byte playerId=0;
  final int targetTimeMinutes=30;
  MapLoader map=MapUtils.getMountainlake();
  ReplayUtils.PlayMapResult directSavegameReplay=ReplayUtils.playMapToTargetTimes(map,playerId,targetTimeMinutes);
  assertDirectSavegameReplay(1,directSavegameReplay);
  MapLoader savegame=directSavegameReplay.getSavegames()[0];
  Thread.sleep(2000L);
  System.out.println(""String_Node_Str"");
  MatchConstants.init(new NetworkTimer(true),0L);
  MainGridWithUiSettings loadedMap=savegame.loadMainGrid(PlayerSetting.createDefaultSettings(playerId,(byte)savegame.getMaxPlayers()));
  MainGrid mainGrid=loadedMap.getMainGrid();
  PlayerState playerState=loadedMap.getPlayerState(playerId);
  mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
  MapLoader savegameOfSavegame;
  try {
    System.out.println(""String_Node_Str"");
    savegameOfSavegame=MapUtils.saveMainGrid(mainGrid,playerId,playerState.getUiState());
    assertNotNull(savegameOfSavegame);
  }
  finally {
    mainGrid.stopThreads();
    JSettlersGame.clearState();
  }
  MapUtils.compareMapFiles(savegame,savegameOfSavegame);
}"
55588,"public static void main(String[] args) throws IOException, InterruptedException, MapLoadException, SwingResourceLoader.ResourceSetupException {
  CommonConstants.ENABLE_CONSOLE_LOGGING=true;
  OptionableProperties options=MainUtils.loadOptions(args);
  SwingManagedJSettlers.loadOptionalSettings(options);
  SwingResourceLoader.setup(options);
  int targetGameTimeMinutes=Integer.valueOf(options.getProperty(""String_Node_Str""));
  String replayFileString=options.getProperty(""String_Node_Str"");
  if (replayFileString == null)   throw new IllegalArgumentException(""String_Node_Str"");
  File replayFile=new File(replayFileString);
  if (!replayFile.exists())   throw new FileNotFoundException(""String_Node_Str"" + replayFile);
  ReplayUtils.replayAndCreateSavegame(new ReplayUtils.ReplayFile(replayFile),targetGameTimeMinutes,""String_Node_Str"");
  Thread.sleep(2000);
  System.exit(0);
}","public static void main(String[] args) throws IOException, InterruptedException, MapLoadException, SwingResourceLoader.ResourceSetupException {
  CommonConstants.ENABLE_CONSOLE_LOGGING=true;
  OptionableProperties options=MainUtils.loadOptions(args);
  SwingManagedJSettlers.loadOptionalSettings(options);
  SwingResourceLoader.setup(options);
  int targetGameTimeMinutes=Integer.valueOf(options.getProperty(""String_Node_Str""));
  String replayFileString=options.getProperty(""String_Node_Str"");
  if (replayFileString == null)   throw new IllegalArgumentException(""String_Node_Str"");
  File replayFile=new File(replayFileString);
  if (!replayFile.exists())   throw new FileNotFoundException(""String_Node_Str"" + replayFile);
  ReplayUtils.replayAndCreateSavegame(new ReplayUtils.ReplayFile(replayFile),targetGameTimeMinutes,""String_Node_Str"");
  Thread.sleep(2000L);
  System.exit(0);
}"
55589,"private static void handleStartOptions(OptionableProperties options,JSettlersFrame settlersFrame) throws IOException, MapLoadException {
  long randomSeed=0;
  ReplayUtils.ReplayFile loadableReplayFile=null;
  int targetGameTime=0;
  String mapFile=options.getProperty(""String_Node_Str"");
  if (options.containsKey(""String_Node_Str"")) {
    randomSeed=Long.parseLong(options.getProperty(""String_Node_Str""));
  }
  if (options.containsKey(""String_Node_Str"")) {
    String loadableReplayFileString=options.getProperty(""String_Node_Str"");
    File replayFile=new File(loadableReplayFileString);
    if (replayFile.exists()) {
      loadableReplayFile=new ReplayUtils.ReplayFile(replayFile);
      System.out.println(""String_Node_Str"" + loadableReplayFile);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  if (options.containsKey(""String_Node_Str"")) {
    targetGameTime=Integer.valueOf(options.getProperty(""String_Node_Str"")) * 60 * 1000;
  }
  if (mapFile != null || loadableReplayFile != null) {
    IStartingGame game;
    if (loadableReplayFile == null) {
      MapLoader mapLoader=MapLoader.getLoaderForListedMap(new DirectoryMapLister.ListedMapFile(new File(mapFile)));
      if (mapLoader.getFileHeader().getType() == MapFileHeader.MapType.NORMAL) {
        byte playerId=0;
        PlayerSetting[] playerSettings=PlayerSetting.createDefaultSettings(playerId,(byte)mapLoader.getMaxPlayers());
        game=new JSettlersGame(mapLoader,randomSeed,playerId,playerSettings).start();
      }
 else {
        MapFileHeader header=mapLoader.getFileHeader();
        game=new JSettlersGame(mapLoader,randomSeed,header.getPlayerId(),header.getPlayerSettings()).start();
      }
    }
 else     if (options.isOptionSet(""String_Node_Str"")) {
      game=JSettlersGame.loadFromReplayFileAllAi(loadableReplayFile,new OfflineNetworkConnector(),new ReplayStartInformation()).start();
    }
 else {
      game=JSettlersGame.loadFromReplayFile(loadableReplayFile,new OfflineNetworkConnector(),new ReplayStartInformation()).start();
    }
    settlersFrame.showStartingGamePanel(game);
    if (targetGameTime > 0) {
      while (!game.isStartupFinished()) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
        }
      }
      MatchConstants.clock().fastForwardTo(targetGameTime);
    }
  }
}","private static void handleStartOptions(OptionableProperties options,JSettlersFrame settlersFrame) throws IOException, MapLoadException {
  long randomSeed=0;
  ReplayUtils.ReplayFile loadableReplayFile=null;
  int targetGameTime=0;
  String mapFile=options.getProperty(""String_Node_Str"");
  if (options.containsKey(""String_Node_Str"")) {
    randomSeed=Long.parseLong(options.getProperty(""String_Node_Str""));
  }
  if (options.containsKey(""String_Node_Str"")) {
    String loadableReplayFileString=options.getProperty(""String_Node_Str"");
    File replayFile=new File(loadableReplayFileString);
    if (replayFile.exists()) {
      loadableReplayFile=new ReplayUtils.ReplayFile(replayFile);
      System.out.println(""String_Node_Str"" + loadableReplayFile);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  if (options.containsKey(""String_Node_Str"")) {
    targetGameTime=Integer.valueOf(options.getProperty(""String_Node_Str"")) * 60 * 1000;
  }
  if (mapFile != null || loadableReplayFile != null) {
    IStartingGame game;
    if (loadableReplayFile == null) {
      MapLoader mapLoader=MapLoader.getLoaderForListedMap(new DirectoryMapLister.ListedMapFile(new File(mapFile)));
      if (mapLoader.getFileHeader().getType() == MapFileHeader.MapType.NORMAL) {
        byte playerId=0;
        PlayerSetting[] playerSettings=PlayerSetting.createDefaultSettings(playerId,(byte)mapLoader.getMaxPlayers());
        game=new JSettlersGame(mapLoader,randomSeed,playerId,playerSettings).start();
      }
 else {
        MapFileHeader header=mapLoader.getFileHeader();
        game=new JSettlersGame(mapLoader,randomSeed,header.getPlayerId(),header.getPlayerSettings()).start();
      }
    }
 else     if (options.isOptionSet(""String_Node_Str"")) {
      game=JSettlersGame.loadFromReplayFileAllAi(loadableReplayFile,new OfflineNetworkConnector(),new ReplayStartInformation()).start();
    }
 else {
      game=JSettlersGame.loadFromReplayFile(loadableReplayFile,new OfflineNetworkConnector(),new ReplayStartInformation()).start();
    }
    settlersFrame.showStartingGamePanel(game);
    if (targetGameTime > 0) {
      while (!game.isStartupFinished()) {
        try {
          Thread.sleep(100L);
        }
 catch (        InterruptedException e) {
        }
      }
      MatchConstants.clock().fastForwardTo(targetGameTime);
    }
  }
}"
55590,"@Override public void run(){
  while (!closed) {
    currWriteSlot=(currWriteSlot + 1) % BUFFER_LENGTH;
    int currDist=(BUFFER_LENGTH + currWriteSlot - currReadSlot) % BUFFER_LENGTH;
    int targetDistance=Math.min(MAX_DELAY,Math.max(MIN_DELAY,(int)(currDist + Math.random() * MAX_DELAY_STEP * 2 - MAX_DELAY_STEP)));
    if (targetDistance >= currDist) {
      currReadSlot=(BUFFER_LENGTH + currReadSlot - (targetDistance - currDist)) % BUFFER_LENGTH;
    }
 else {
      for (int i=targetDistance; i < currDist; i++) {
        writeNextSlot();
      }
    }
    try {
      Thread.sleep(1);
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void run(){
  while (!closed) {
    currWriteSlot=(currWriteSlot + 1) % BUFFER_LENGTH;
    int currDist=(BUFFER_LENGTH + currWriteSlot - currReadSlot) % BUFFER_LENGTH;
    int targetDistance=Math.min(MAX_DELAY,Math.max(MIN_DELAY,(int)(currDist + Math.random() * MAX_DELAY_STEP * 2 - MAX_DELAY_STEP)));
    if (targetDistance >= currDist) {
      currReadSlot=(BUFFER_LENGTH + currReadSlot - (targetDistance - currDist)) % BUFFER_LENGTH;
    }
 else {
      for (int i=targetDistance; i < currDist; i++) {
        writeNextSlot();
      }
    }
    try {
      Thread.sleep(1L);
    }
 catch (    InterruptedException e) {
    }
  }
}"
55591,"/** 
 * NOTE: THIS METHOD IS BLOCKING for the given time
 * @param seconds block at maximum the given number of seconds to find the address
 * @return
 */
public static String retrieveLanServerAddress(int seconds){
  LanServerAddressBroadcastListener serverAddressReceiver=new LanServerAddressBroadcastListener();
  try {
    serverAddressReceiver.start();
    for (int i=0; i < 2 * seconds && !serverAddressReceiver.hasFoundServer(); i++) {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    if (serverAddressReceiver.hasFoundServer()) {
      System.out.println(""String_Node_Str"");
      return serverAddressReceiver.getServerAddress().getHostAddress();
    }
 else {
      return null;
    }
  }
  finally {
    serverAddressReceiver.shutdown();
  }
}","/** 
 * NOTE: THIS METHOD IS BLOCKING for the given time
 * @param seconds block at maximum the given number of seconds to find the address
 * @return
 */
public static String retrieveLanServerAddress(int seconds){
  LanServerAddressBroadcastListener serverAddressReceiver=new LanServerAddressBroadcastListener();
  try {
    serverAddressReceiver.start();
    for (int i=0; i < 2 * seconds && !serverAddressReceiver.hasFoundServer(); i++) {
      try {
        Thread.sleep(500L);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    if (serverAddressReceiver.hasFoundServer()) {
      System.out.println(""String_Node_Str"");
      return serverAddressReceiver.getServerAddress().getHostAddress();
    }
 else {
      return null;
    }
  }
  finally {
    serverAddressReceiver.shutdown();
  }
}"
55592,"@Override public void run(){
  try {
    socket=new DatagramSocket();
    while (!canceled) {
      try {
        Thread.sleep(500);
        byte[] data=NetworkConstants.Server.BROADCAST_MESSAGE.getBytes();
        broadcast(NetworkConstants.Server.BROADCAST_PORT,socket,data);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
      }
    }
  }
 catch (  SocketException e) {
    e.printStackTrace();
  }
 finally {
    if (socket != null)     socket.close();
  }
}","@Override public void run(){
  try {
    socket=new DatagramSocket();
    while (!canceled) {
      try {
        Thread.sleep(500L);
        byte[] data=NetworkConstants.Server.BROADCAST_MESSAGE.getBytes();
        broadcast(NetworkConstants.Server.BROADCAST_PORT,socket,data);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
catch (      InterruptedException e) {
      }
    }
  }
 catch (  SocketException e) {
    e.printStackTrace();
  }
 finally {
    if (socket != null)     socket.close();
  }
}"
55593,"@Test public void testCloseFromServerSide() throws IllegalStateException, InterruptedException {
  logIn(client1,""String_Node_Str"",""String_Node_Str"");
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,db.getNumberOfPlayers());
  server1Channel.close();
  Thread.sleep(10);
  assertEquals(1,db.getNumberOfPlayers());
  assertEquals(EPlayerState.DISCONNECTED,client1.getState());
}","@Test public void testCloseFromServerSide() throws IllegalStateException, InterruptedException {
  logIn(client1,""String_Node_Str"",""String_Node_Str"");
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,db.getNumberOfPlayers());
  server1Channel.close();
  Thread.sleep(10L);
  assertEquals(1,db.getNumberOfPlayers());
  assertEquals(EPlayerState.DISCONNECTED,client1.getState());
}"
55594,"@Test public void testOpenAndStartNewMatch() throws IllegalStateException, InterruptedException {
  openMatch(""String_Node_Str"",""String_Node_Str"",client1);
  client1.startMatch();
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
}","@Test public void testOpenAndStartNewMatch() throws IllegalStateException, InterruptedException {
  openMatch(""String_Node_Str"",""String_Node_Str"",client1);
  client1.startMatch();
  Thread.sleep(50L);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
}"
55595,"@Test public void testConnection() throws InterruptedException {
  TestPacketListener listener=new TestPacketListener(NetworkConstants.ENetworkKey.TEST_PACKET);
  client1Channel.registerListener(listener);
  TestPacket testPacket=new TestPacket(""String_Node_Str"",2324);
  server1Channel.sendPacket(NetworkConstants.ENetworkKey.TEST_PACKET,testPacket);
  Thread.sleep(10);
  assertEquals(1,listener.packets.size());
  assertEquals(testPacket,listener.packets.get(0));
}","@Test public void testConnection() throws InterruptedException {
  TestPacketListener listener=new TestPacketListener(NetworkConstants.ENetworkKey.TEST_PACKET);
  client1Channel.registerListener(listener);
  TestPacket testPacket=new TestPacket(""String_Node_Str"",2324);
  server1Channel.sendPacket(NetworkConstants.ENetworkKey.TEST_PACKET,testPacket);
  Thread.sleep(10L);
  assertEquals(1,listener.packets.size());
  assertEquals(testPacket,listener.packets.get(0));
}"
55596,"@Test public void testSyncTasksDistribution() throws IllegalStateException, InterruptedException {
  logIn(client1,""String_Node_Str"",""String_Node_Str"");
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  client1.openNewMatch(""String_Node_Str"",4,new MapInfoPacket(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4),34L,null,null,null);
  Thread.sleep(150);
  assertEquals(EPlayerState.IN_MATCH,client1.getState());
  MatchInfoPacket matchInfo=client1.getMatchInfo();
  client2.joinMatch(matchInfo.getId(),null,null,null);
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_MATCH,client2.getState());
  client1.setReadyState(true);
  client2.setReadyState(true);
  Thread.sleep(30);
  client2.startMatch();
  Thread.sleep(30 + NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client2.getState());
  Thread.sleep(2 * NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock1.getAllowedLockstep());
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock2.getAllowedLockstep());
  Thread.sleep((2 + NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS) * NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock1.getAllowedLockstep());
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock2.getAllowedLockstep());
  TestTaskPacket testTask=new TestTaskPacket(""String_Node_Str"",2342,(byte)-23);
  client2.scheduleTask(testTask);
  Thread.sleep(2 * NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL);
  assertEquals(0,clock1.popBufferedTasks().size());
  assertEquals(0,clock2.popBufferedTasks().size());
  clock1.setTime(NetworkConstants.Client.LOCKSTEP_PERIOD + NetworkConstants.Client.TIME_SYNC_TOLERATED_DIFFERENCE + 10);
  Thread.sleep(NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 40);
  List<TaskPacket> packets1=clock1.popBufferedTasks();
  assertEquals(1,packets1.size());
  assertEquals(testTask,packets1.get(0));
  List<TaskPacket> packets2=clock2.popBufferedTasks();
  assertEquals(1,packets2.size());
  assertEquals(testTask,packets2.get(0));
  Thread.sleep(2 * NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS + 1,clock1.getAllowedLockstep());
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS + 1,clock2.getAllowedLockstep());
}","@Test public void testSyncTasksDistribution() throws IllegalStateException, InterruptedException {
  logIn(client1,""String_Node_Str"",""String_Node_Str"");
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  client1.openNewMatch(""String_Node_Str"",4,new MapInfoPacket(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",4),34L,null,null,null);
  Thread.sleep(150L);
  assertEquals(EPlayerState.IN_MATCH,client1.getState());
  MatchInfoPacket matchInfo=client1.getMatchInfo();
  client2.joinMatch(matchInfo.getId(),null,null,null);
  Thread.sleep(50L);
  assertEquals(EPlayerState.IN_MATCH,client2.getState());
  client1.setReadyState(true);
  client2.setReadyState(true);
  Thread.sleep(30L);
  client2.startMatch();
  Thread.sleep(30 + NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client2.getState());
  Thread.sleep(2 * NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock1.getAllowedLockstep());
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock2.getAllowedLockstep());
  Thread.sleep((2 + NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS) * NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock1.getAllowedLockstep());
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS,clock2.getAllowedLockstep());
  TestTaskPacket testTask=new TestTaskPacket(""String_Node_Str"",2342,(byte)-23);
  client2.scheduleTask(testTask);
  Thread.sleep(2L * NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL);
  assertEquals(0,clock1.popBufferedTasks().size());
  assertEquals(0,clock2.popBufferedTasks().size());
  clock1.setTime(NetworkConstants.Client.LOCKSTEP_PERIOD + NetworkConstants.Client.TIME_SYNC_TOLERATED_DIFFERENCE + 10);
  Thread.sleep(NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 40L);
  List<TaskPacket> packets1=clock1.popBufferedTasks();
  assertEquals(1,packets1.size());
  assertEquals(testTask,packets1.get(0));
  List<TaskPacket> packets2=clock2.popBufferedTasks();
  assertEquals(1,packets2.size());
  assertEquals(testTask,packets2.get(0));
  Thread.sleep(2 * NetworkConstants.Client.LOCKSTEP_PERIOD);
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS + 1,clock1.getAllowedLockstep());
  assertEquals(NetworkConstants.Client.LOCKSTEP_DEFAULT_LEAD_STEPS + 1,clock2.getAllowedLockstep());
}"
55597,"@Test public void testStartMatchWithUnreadyPlayers() throws IllegalStateException, InterruptedException {
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  openMatch(""String_Node_Str"",""String_Node_Str"",client1);
  client2.joinMatch(client1.getMatchInfo().getId(),null,null,null);
  BufferingPacketReceiver<RejectPacket> rejectReceiver2=new BufferingPacketReceiver<>();
  client2.registerRejectReceiver(rejectReceiver2);
  Thread.sleep(50);
  assertEquals(0,rejectReceiver2.popBufferedPackets().size());
  client2.startMatch();
  Thread.sleep(50);
  assertSingleRejectPacket(rejectReceiver2,ENetworkKey.REQUEST_START_MATCH,ENetworkMessage.NOT_ALL_PLAYERS_READY);
  client2.setReadyState(true);
  Thread.sleep(20);
  client1.setReadyState(false);
  Thread.sleep(20);
  client2.startMatch();
  Thread.sleep(50);
  assertSingleRejectPacket(rejectReceiver2,ENetworkKey.REQUEST_START_MATCH,ENetworkMessage.NOT_ALL_PLAYERS_READY);
  client1.setReadyState(true);
  Thread.sleep(20);
  client2.startMatch();
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client2.getState());
}","@Test public void testStartMatchWithUnreadyPlayers() throws IllegalStateException, InterruptedException {
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  openMatch(""String_Node_Str"",""String_Node_Str"",client1);
  client2.joinMatch(client1.getMatchInfo().getId(),null,null,null);
  BufferingPacketReceiver<RejectPacket> rejectReceiver2=new BufferingPacketReceiver<>();
  client2.registerRejectReceiver(rejectReceiver2);
  Thread.sleep(50L);
  assertEquals(0,rejectReceiver2.popBufferedPackets().size());
  client2.startMatch();
  Thread.sleep(50L);
  assertSingleRejectPacket(rejectReceiver2,ENetworkKey.REQUEST_START_MATCH,ENetworkMessage.NOT_ALL_PLAYERS_READY);
  client2.setReadyState(true);
  Thread.sleep(20L);
  client1.setReadyState(false);
  Thread.sleep(20L);
  client2.startMatch();
  Thread.sleep(50L);
  assertSingleRejectPacket(rejectReceiver2,ENetworkKey.REQUEST_START_MATCH,ENetworkMessage.NOT_ALL_PLAYERS_READY);
  client1.setReadyState(true);
  Thread.sleep(20L);
  client2.startMatch();
  Thread.sleep(50L);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client2.getState());
}"
55598,"private void logIn(NetworkClient client,String playerId,String playerName) throws IllegalStateException, InterruptedException {
  int currentNumberOfPlayers=db.getNumberOfPlayers();
  client.logIn(playerId,playerName,null);
  Thread.sleep(40);
  assertEquals(EPlayerState.LOGGED_IN,client.getState());
  assertEquals(currentNumberOfPlayers + 1,db.getNumberOfPlayers());
  Player p=db.getPlayer(playerId);
  assertEquals(playerId,p.getId());
  assertEquals(playerName,p.getPlayerInfo().getName());
}","private void logIn(NetworkClient client,String playerId,String playerName) throws IllegalStateException, InterruptedException {
  int currentNumberOfPlayers=db.getNumberOfPlayers();
  client.logIn(playerId,playerName,null);
  Thread.sleep(40L);
  assertEquals(EPlayerState.LOGGED_IN,client.getState());
  assertEquals(currentNumberOfPlayers + 1,db.getNumberOfPlayers());
  Player p=db.getPlayer(playerId);
  assertEquals(playerId,p.getId());
  assertEquals(playerName,p.getPlayerInfo().getName());
}"
55599,"@Test public void testChatMessaging() throws IllegalStateException, InterruptedException {
  testLogIn();
  BufferingPacketReceiver<ChatMessagePacket> chatReceiver=new BufferingPacketReceiver<>();
  client1.openNewMatch(""String_Node_Str"",4,new MapInfoPacket(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9),923409340394293842L,null,null,chatReceiver);
  Thread.sleep(80);
  assertEquals(EPlayerState.IN_MATCH,client1.getState());
  testSendAndReceiveChatMessage(chatReceiver);
  client1.setReadyState(true);
  Thread.sleep(50);
  testSendAndReceiveChatMessage(chatReceiver);
  client1.startMatch();
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  testSendAndReceiveChatMessage(chatReceiver);
}","@Test public void testChatMessaging() throws IllegalStateException, InterruptedException {
  testLogIn();
  BufferingPacketReceiver<ChatMessagePacket> chatReceiver=new BufferingPacketReceiver<>();
  client1.openNewMatch(""String_Node_Str"",4,new MapInfoPacket(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",9),923409340394293842L,null,null,chatReceiver);
  Thread.sleep(80L);
  assertEquals(EPlayerState.IN_MATCH,client1.getState());
  testSendAndReceiveChatMessage(chatReceiver);
  client1.setReadyState(true);
  Thread.sleep(50L);
  testSendAndReceiveChatMessage(chatReceiver);
  client1.startMatch();
  Thread.sleep(50L);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  testSendAndReceiveChatMessage(chatReceiver);
}"
55600,"private void testSendAndReceiveChatMessage(BufferingPacketReceiver<ChatMessagePacket> chatReceiver) throws IllegalStateException, InterruptedException {
  final String testMessage=""String_Node_Str"";
  client1.sendChatMessage(testMessage);
  assertEquals(0,chatReceiver.popBufferedPackets().size());
  Thread.sleep(50);
  List<ChatMessagePacket> chatMessages=chatReceiver.popBufferedPackets();
  assertEquals(1,chatMessages.size());
  assertEquals(TEST_PLAYER_ID,chatMessages.get(0).getAuthorId());
  assertEquals(testMessage,chatMessages.get(0).getMessage());
}","private void testSendAndReceiveChatMessage(BufferingPacketReceiver<ChatMessagePacket> chatReceiver) throws IllegalStateException, InterruptedException {
  final String testMessage=""String_Node_Str"";
  client1.sendChatMessage(testMessage);
  assertEquals(0,chatReceiver.popBufferedPackets().size());
  Thread.sleep(50L);
  List<ChatMessagePacket> chatMessages=chatReceiver.popBufferedPackets();
  assertEquals(1,chatMessages.size());
  assertEquals(TEST_PLAYER_ID,chatMessages.get(0).getAuthorId());
  assertEquals(testMessage,chatMessages.get(0).getMessage());
}"
55601,"@Test public void testTimeSynchronization() throws IllegalStateException, InterruptedException {
  testOpenStartAndJoinNewMatch();
  clock1.setTime(200);
  clock2.setTime(210);
  Thread.sleep(NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 20);
  assertEquals(0,clock1.popAdjustmentEvents().size());
  assertEquals(0,clock2.popAdjustmentEvents().size());
  clock1.setTime(2056);
  Thread.sleep(3 * NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 20);
  int diff=Math.abs(clock1.getTime() - clock2.getTime());
  assertTrue(""String_Node_Str"" + diff,diff < NetworkConstants.Client.TIME_SYNC_TOLERATED_DIFFERENCE);
  assertTrue(clock1.popAdjustmentEvents().size() > 0);
  assertEquals(0,clock2.popAdjustmentEvents().size());
  clock2.setTime(423423);
  Thread.sleep(6 * NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 20);
  diff=Math.abs(clock2.getTime() - clock1.getTime());
  assertTrue(""String_Node_Str"" + diff,diff < NetworkConstants.Client.TIME_SYNC_TOLERATED_DIFFERENCE);
  assertTrue(clock2.popAdjustmentEvents().size() > 0);
  assertEquals(0,clock1.popAdjustmentEvents().size());
}","@Test public void testTimeSynchronization() throws IllegalStateException, InterruptedException {
  testOpenStartAndJoinNewMatch();
  clock1.setTime(200);
  clock2.setTime(210);
  Thread.sleep(NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 20L);
  assertEquals(0,clock1.popAdjustmentEvents().size());
  assertEquals(0,clock2.popAdjustmentEvents().size());
  clock1.setTime(2056);
  Thread.sleep(3L * NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 20L);
  int diff=Math.abs(clock1.getTime() - clock2.getTime());
  assertTrue(""String_Node_Str"" + diff,diff < NetworkConstants.Client.TIME_SYNC_TOLERATED_DIFFERENCE);
  assertTrue(clock1.popAdjustmentEvents().size() > 0);
  assertEquals(0,clock2.popAdjustmentEvents().size());
  clock2.setTime(423423);
  Thread.sleep(6L * NetworkConstants.Client.TIME_SYNC_SEND_INTERVALL + 20L);
  diff=Math.abs(clock2.getTime() - clock1.getTime());
  assertTrue(""String_Node_Str"" + diff,diff < NetworkConstants.Client.TIME_SYNC_TOLERATED_DIFFERENCE);
  assertTrue(clock2.popAdjustmentEvents().size() > 0);
  assertEquals(0,clock1.popAdjustmentEvents().size());
}"
55602,"@Test public void testLogInAndClose() throws IllegalStateException, InterruptedException {
  testLogIn();
  client1.close();
  Thread.sleep(10);
  assertEquals(0,db.getNumberOfPlayers());
  assertEquals(EPlayerState.DISCONNECTED,client1.getState());
}","@Test public void testLogInAndClose() throws IllegalStateException, InterruptedException {
  testLogIn();
  client1.close();
  Thread.sleep(10L);
  assertEquals(0,db.getNumberOfPlayers());
  assertEquals(EPlayerState.DISCONNECTED,client1.getState());
}"
55603,"@Test public void testOpenStartAndJoinNewMatch() throws IllegalStateException, InterruptedException {
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  openMatch(""String_Node_Str"",""String_Node_Str"",client1);
  MatchInfoPacket dbMatchInfo=new MatchInfoPacket(db.getJoinableMatches().get(0));
  assertEquals(dbMatchInfo,client1.getMatchInfo());
  assertEquals(1,client1.getMatchInfo().getPlayers().length);
  client2.joinMatch(dbMatchInfo.getId(),null,null,null);
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_MATCH,client2.getState());
  dbMatchInfo=new MatchInfoPacket(db.getJoinableMatches().get(0));
  assertEquals(dbMatchInfo,client1.getMatchInfo());
  assertEquals(2,client1.getMatchInfo().getPlayers().length);
  client2.setReadyState(true);
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_MATCH,client2.getState());
  dbMatchInfo=new MatchInfoPacket(db.getJoinableMatches().get(0));
  assertEquals(dbMatchInfo,client1.getMatchInfo());
  assertEquals(2,client1.getMatchInfo().getPlayers().length);
  assertTrue(client1.getMatchInfo().getPlayers()[1].isReady());
  client1.startMatch();
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client2.getState());
}","@Test public void testOpenStartAndJoinNewMatch() throws IllegalStateException, InterruptedException {
  logIn(client2,""String_Node_Str"",""String_Node_Str"");
  openMatch(""String_Node_Str"",""String_Node_Str"",client1);
  MatchInfoPacket dbMatchInfo=new MatchInfoPacket(db.getJoinableMatches().get(0));
  assertEquals(dbMatchInfo,client1.getMatchInfo());
  assertEquals(1,client1.getMatchInfo().getPlayers().length);
  client2.joinMatch(dbMatchInfo.getId(),null,null,null);
  Thread.sleep(50L);
  assertEquals(EPlayerState.IN_MATCH,client2.getState());
  dbMatchInfo=new MatchInfoPacket(db.getJoinableMatches().get(0));
  assertEquals(dbMatchInfo,client1.getMatchInfo());
  assertEquals(2,client1.getMatchInfo().getPlayers().length);
  client2.setReadyState(true);
  Thread.sleep(50L);
  assertEquals(EPlayerState.IN_MATCH,client2.getState());
  dbMatchInfo=new MatchInfoPacket(db.getJoinableMatches().get(0));
  assertEquals(dbMatchInfo,client1.getMatchInfo());
  assertEquals(2,client1.getMatchInfo().getPlayers().length);
  assertTrue(client1.getMatchInfo().getPlayers()[1].isReady());
  client1.startMatch();
  Thread.sleep(50);
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client1.getState());
  assertEquals(EPlayerState.IN_RUNNING_MATCH,client2.getState());
}"
55604,"private void openMatch(String id,String name,NetworkClient client) throws IllegalStateException, InterruptedException {
  BufferingPacketReceiver<ArrayOfMatchInfosPacket> matchesReceiver=new BufferingPacketReceiver<>();
  assertEquals(0,matchesReceiver.popBufferedPackets().size());
  client.logIn(id,name,matchesReceiver);
  Thread.sleep(50);
  List<ArrayOfMatchInfosPacket> arrayOfMatches=matchesReceiver.popBufferedPackets();
  assertEquals(1,arrayOfMatches.size());
  assertEquals(0,arrayOfMatches.get(0).getMatches().length);
  BufferingPacketReceiver<MatchInfoUpdatePacket> matchUpdateListener=new BufferingPacketReceiver<>();
  final String matchName=""String_Node_Str"";
  final byte maxPlayers=(byte)5;
  final MapInfoPacket mapInfo=new MapInfoPacket(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5);
  client.openNewMatch(matchName,maxPlayers,mapInfo,-4712L,null,matchUpdateListener,null);
  Thread.sleep(100);
  List<MatchInfoUpdatePacket> matches=matchUpdateListener.popBufferedPackets();
  assertEquals(1,matches.size());
  MatchInfoPacket match=matches.get(0).getMatchInfo();
  assertEquals(matchName,match.getMatchName());
  assertEquals(maxPlayers,match.getMaxPlayers());
  assertEquals(mapInfo,match.getMapInfo());
  assertFalse(match.getPlayers()[0].isReady());
  client.setReadyState(true);
  Thread.sleep(150);
  matches=matchUpdateListener.popBufferedPackets();
  assertEquals(1,matches.size());
  match=matches.get(0).getMatchInfo();
  assertEquals(matchName,match.getMatchName());
  assertEquals(maxPlayers,match.getMaxPlayers());
  assertEquals(mapInfo,match.getMapInfo());
  assertTrue(match.getPlayers()[0].isReady());
}","private void openMatch(String id,String name,NetworkClient client) throws IllegalStateException, InterruptedException {
  BufferingPacketReceiver<ArrayOfMatchInfosPacket> matchesReceiver=new BufferingPacketReceiver<>();
  assertEquals(0,matchesReceiver.popBufferedPackets().size());
  client.logIn(id,name,matchesReceiver);
  Thread.sleep(50L);
  List<ArrayOfMatchInfosPacket> arrayOfMatches=matchesReceiver.popBufferedPackets();
  assertEquals(1,arrayOfMatches.size());
  assertEquals(0,arrayOfMatches.get(0).getMatches().length);
  BufferingPacketReceiver<MatchInfoUpdatePacket> matchUpdateListener=new BufferingPacketReceiver<>();
  final String matchName=""String_Node_Str"";
  final byte maxPlayers=(byte)5;
  final MapInfoPacket mapInfo=new MapInfoPacket(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",5);
  client.openNewMatch(matchName,maxPlayers,mapInfo,-4712L,null,matchUpdateListener,null);
  Thread.sleep(100L);
  List<MatchInfoUpdatePacket> matches=matchUpdateListener.popBufferedPackets();
  assertEquals(1,matches.size());
  MatchInfoPacket match=matches.get(0).getMatchInfo();
  assertEquals(matchName,match.getMatchName());
  assertEquals(maxPlayers,match.getMaxPlayers());
  assertEquals(mapInfo,match.getMapInfo());
  assertFalse(match.getPlayers()[0].isReady());
  client.setReadyState(true);
  Thread.sleep(150L);
  matches=matchUpdateListener.popBufferedPackets();
  assertEquals(1,matches.size());
  match=matches.get(0).getMatchInfo();
  assertEquals(matchName,match.getMatchName());
  assertEquals(maxPlayers,match.getMaxPlayers());
  assertEquals(mapInfo,match.getMapInfo());
  assertTrue(match.getPlayers()[0].isReady());
}"
55605,"@Test public void testSendAndReceive() throws InterruptedException {
  SyncTasksPacketSchedulerMock taskReceiver=new SyncTasksPacketSchedulerMock();
  TaskPacketListener listener=new TaskPacketListener(taskReceiver);
  c1.registerListener(listener);
  TaskPacket testPacket1=new TestTaskPacket(""String_Node_Str"",23424,(byte)-2);
  TaskPacket testPacket2=new TestTaskPacket(""String_Node_Str"",-2342342,(byte)-67);
  int lockstep=23;
  SyncTasksPacket syncTasksPacket=new SyncTasksPacket(lockstep,Arrays.asList(testPacket1,testPacket2));
  c2.sendPacket(NetworkConstants.ENetworkKey.SYNCHRONOUS_TASK,syncTasksPacket);
  Thread.sleep(30);
  List<SyncTasksPacket> packets=taskReceiver.popBufferedPackets();
  assertEquals(1,packets.size());
  assertEquals(lockstep,packets.get(0).getLockstepNumber());
  List<TaskPacket> tasks=packets.get(0).getTasks();
  assertEquals(2,tasks.size());
  assertEquals(testPacket1,tasks.get(0));
  assertEquals(testPacket2,tasks.get(1));
}","@Test public void testSendAndReceive() throws InterruptedException {
  SyncTasksPacketSchedulerMock taskReceiver=new SyncTasksPacketSchedulerMock();
  TaskPacketListener listener=new TaskPacketListener(taskReceiver);
  c1.registerListener(listener);
  TaskPacket testPacket1=new TestTaskPacket(""String_Node_Str"",23424,(byte)-2);
  TaskPacket testPacket2=new TestTaskPacket(""String_Node_Str"",-2342342,(byte)-67);
  int lockstep=23;
  SyncTasksPacket syncTasksPacket=new SyncTasksPacket(lockstep,Arrays.asList(testPacket1,testPacket2));
  c2.sendPacket(NetworkConstants.ENetworkKey.SYNCHRONOUS_TASK,syncTasksPacket);
  Thread.sleep(30L);
  List<SyncTasksPacket> packets=taskReceiver.popBufferedPackets();
  assertEquals(1,packets.size());
  assertEquals(lockstep,packets.get(0).getLockstepNumber());
  List<TaskPacket> tasks=packets.get(0).getTasks();
  assertEquals(2,tasks.size());
  assertEquals(testPacket1,tasks.get(0));
  assertEquals(testPacket2,tasks.get(1));
}"
55606,"@Test public void testSerializationAndDeserialization() throws InterruptedException {
  c2.registerListener(listener);
  c1.sendPacket(NetworkConstants.ENetworkKey.TEST_PACKET,packet);
  Thread.sleep(150);
  List<? extends Packet> bufferedPackets=listener.popBufferedPackets();
  assertEquals(1,bufferedPackets.size());
  assertEquals(packet,bufferedPackets.get(0));
  assertEquals(packet.hashCode(),bufferedPackets.get(0).hashCode());
}","@Test public void testSerializationAndDeserialization() throws InterruptedException {
  c2.registerListener(listener);
  c1.sendPacket(NetworkConstants.ENetworkKey.TEST_PACKET,packet);
  Thread.sleep(150L);
  List<? extends Packet> bufferedPackets=listener.popBufferedPackets();
  assertEquals(1,bufferedPackets.size());
  assertEquals(packet,bufferedPackets.get(0));
  assertEquals(packet.hashCode(),bufferedPackets.get(0).hashCode());
}"
55607,"@Override public void commandTroops(Set<Integer> soldiersWithOrders){
  SoldierPositions soldierPositions=calculateSituation(player.playerId);
  if (aiStatistics.getEnemiesInTownOf(player.playerId).size() > 0) {
    defend(soldierPositions,soldiersWithOrders);
  }
 else   if (existsAliveEnemy()) {
    IPlayer weakestEnemy=getWeakestEnemy();
    SoldierPositions enemySoldierPositions=calculateSituation(weakestEnemy.getPlayerId());
    boolean infantryWouldDie=wouldInfantryDie(enemySoldierPositions);
    if (attackIsPossible(soldierPositions,enemySoldierPositions,infantryWouldDie)) {
      attack(soldierPositions,infantryWouldDie,soldiersWithOrders);
    }
  }
}","@Override public void commandTroops(Set<Integer> soldiersWithOrders){
  ensureAllTowersFullyMounted();
  SoldierPositions soldierPositions=calculateSituation(player.playerId);
  if (aiStatistics.getEnemiesInTownOf(player.playerId).size() > 0) {
    defend(soldierPositions,soldiersWithOrders);
  }
 else   if (existsAliveEnemy()) {
    IPlayer weakestEnemy=getWeakestEnemy();
    SoldierPositions enemySoldierPositions=calculateSituation(weakestEnemy.getPlayerId());
    boolean infantryWouldDie=wouldInfantryDie(enemySoldierPositions);
    if (attackIsPossible(soldierPositions,enemySoldierPositions,infantryWouldDie)) {
      attack(soldierPositions,infantryWouldDie,soldiersWithOrders);
    }
  }
}"
55608,"public ConfigurableGeneral(AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler,float attackerCountFactor){
  this.aiStatistics=aiStatistics;
  this.player=player;
  this.taskScheduler=taskScheduler;
  this.movableGrid=movableGrid;
  this.attackerCountFactor=attackerCountFactor;
}","public ConfigurableGeneral(AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler,EPlayerType playerType){
  this.aiStatistics=aiStatistics;
  this.player=player;
  this.taskScheduler=taskScheduler;
  this.movableGrid=movableGrid;
  this.attackerCountFactor=ATTACKER_COUNT_FACTOR_BY_PLAYER_TYPE[playerType.ordinal()];
}"
55609,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId)) {
      int resourceAmount=0;
      LandscapeGrid landscapeGrid=aiStatistics.getMainGrid().getLandscapeGrid();
      for (      RelativePoint relativePoint : buildingType.getBlockedTiles()) {
        int x=point.x + relativePoint.getDx();
        int y=point.y + relativePoint.getDy();
        if (landscapeGrid.getResourceTypeAt(x,y) == resourceType) {
          resourceAmount-=landscapeGrid.getResourceAmountAt(x,y);
        }
      }
      if (resourceAmount != 0) {
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,resourceAmount));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId)) {
      int resourceAmount=0;
      LandscapeGrid landscapeGrid=aiStatistics.getMainGrid().getLandscapeGrid();
      for (      RelativePoint relativePoint : buildingType.getBlockedTiles()) {
        int x=point.x + relativePoint.getDx();
        int y=point.y + relativePoint.getDy();
        if (landscapeGrid.getResourceTypeAt(x,y) == resourceType) {
          resourceAmount+=landscapeGrid.getResourceAmountAt(x,y);
        }
      }
      if (resourceAmount != 0) {
        int distanceToCenter=aiStatistics.getPositionOfPartition(playerId).getOnGridDistTo(point);
        int score=resourceAmount - (int)(distanceToCenter * DISTANCE_PENALTY_FACTOR);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,-score));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
55610,"private ArmyGeneral determineArmyGeneral(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler){
  return new ConfigurableGeneral(aiStatistics,player,movableGrid,taskScheduler,ATTACKER_COUNT_FACTOR[type.ordinal()]);
}","private ArmyGeneral determineArmyGeneral(EPlayerType playerType,ECivilisation civilisation,AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler){
  return new ConfigurableGeneral(aiStatistics,player,movableGrid,taskScheduler,playerType);
}"
55611,"private EconomyMinister determineMinister(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player){
switch (type) {
case AI_VERY_EASY:
    return new BuildingListEconomyMinister(aiStatistics,player,1F / 8F,1F / 4F,true);
case AI_EASY:
  return new BuildingListEconomyMinister(aiStatistics,player,1F / 4F,1F / 2F,false);
case AI_HARD:
return new BuildingListEconomyMinister(aiStatistics,player,1F / 2F,3F / 4F,false);
default :
return new BuildingListEconomyMinister(aiStatistics,player,1F,1F,false);
}
}","private EconomyMinister determineMinister(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player){
switch (type) {
case AI_VERY_EASY:
    return new BuildingListEconomyMinister(aiStatistics,player,1F / 10F,1F / 5F,true);
case AI_EASY:
  return new BuildingListEconomyMinister(aiStatistics,player,1F / 4F,1F / 2F,false);
case AI_HARD:
return new BuildingListEconomyMinister(aiStatistics,player,1F / 2F,3F / 4F,false);
default :
return new BuildingListEconomyMinister(aiStatistics,player,1F,1F,false);
}
}"
55612,"private void changeTowerSoldiers(ChangeTowerSoldiersGuiTask soldierTask){
  ShortPoint2D buildingPosition=soldierTask.getBuildingPos();
  OccupyingBuilding occupyingBuilding=(OccupyingBuilding)grid.getBuildingAt(buildingPosition.x,buildingPosition.y);
switch (soldierTask.getTaskType()) {
case FULL:
    occupyingBuilding.requestSoldiers();
  break;
case MORE:
occupyingBuilding.requestSoldier(soldierTask.getSoldierType());
break;
case ONE:
occupyingBuilding.releaseSoldiers();
break;
case LESS:
occupyingBuilding.releaseSoldier(soldierTask.getSoldierType());
break;
}
}","private void changeTowerSoldiers(ChangeTowerSoldiersGuiTask soldierTask){
  ShortPoint2D buildingPosition=soldierTask.getBuildingPos();
  OccupyingBuilding occupyingBuilding=(OccupyingBuilding)grid.getBuildingAt(buildingPosition.x,buildingPosition.y);
switch (soldierTask.getTaskType()) {
case FULL:
    occupyingBuilding.requestFullSoldiers();
  break;
case MORE:
occupyingBuilding.requestSoldier(soldierTask.getSoldierType());
break;
case ONE:
occupyingBuilding.releaseSoldiers();
break;
case LESS:
occupyingBuilding.releaseSoldier(soldierTask.getSoldierType());
break;
}
}"
55613,"private void initSoldierRequests(){
  final OccupierPlace[] occupierPlaces=super.getBuildingType().getOccupierPlaces();
  if (occupierPlaces.length > 0) {
    emptyPlaces.addAll(Arrays.asList(occupierPlaces));
    requestSoldiers();
  }
}","private void initSoldierRequests(){
  final OccupierPlace[] occupierPlaces=super.getBuildingType().getOccupierPlaces();
  if (occupierPlaces.length > 0) {
    emptyPlaces.addAll(Arrays.asList(occupierPlaces));
    requestSoldier(ESoldierClass.INFANTRY);
  }
}"
55614,"@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,65 * MINUTES);
}","@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,75 * MINUTES);
}"
55615,"public T getFront(){
  return head.next;
}","/** 
 * gets the first item in the list without removing it from the list.
 * @return
 */
public T getFront(){
  return head.next;
}"
55616,"public void remove(DoubleLinkedListItem<T> item){
  item.prev.next=item.next;
  item.next.prev=item.prev;
  size--;
}","public void remove(DoubleLinkedListItem<T> item){
  item.prev.next=item.next;
  item.next.prev=item.prev;
  size--;
  item.next=null;
  item.prev=null;
}"
55617,"@Test public void testRemoveByHandle(){
  DoubleLinkedIntListItem handles[]=new DoubleLinkedIntListItem[TEST_NUMBERS];
  for (int i=0; i < TEST_NUMBERS; i++) {
    handles[i]=new DoubleLinkedIntListItem(i);
    list.pushFront(handles[i]);
  }
  list.remove(handles[4]);
  list.remove(handles[7]);
  assertEquals(TEST_NUMBERS - 2,list.size());
  for (int i=TEST_NUMBERS - 1; i >= 0; i--) {
    if (i == 4 || i == 7) {
      continue;
    }
    assertEquals(i,list.popFront().value);
  }
  assertEquals(0,list.size());
}","@Test public void testRemoveByHandle(){
  DoubleLinkedIntListItem handles[]=new DoubleLinkedIntListItem[TEST_NUMBERS];
  for (int i=0; i < TEST_NUMBERS; i++) {
    handles[i]=new DoubleLinkedIntListItem(i);
    list.pushFront(handles[i]);
  }
  list.remove(handles[4]);
  list.remove(handles[7]);
  assertEquals(""String_Node_Str"",TEST_NUMBERS - 2,list.size());
  assertNull(""String_Node_Str"",handles[4].next);
  assertNull(""String_Node_Str"",handles[4].prev);
  assertNull(""String_Node_Str"",handles[7].next);
  assertNull(""String_Node_Str"",handles[7].prev);
  for (int i=TEST_NUMBERS - 1; i >= 0; i--) {
    if (i == 4 || i == 7) {
      continue;
    }
    assertEquals(i,list.popFront().value);
  }
  assertEquals(""String_Node_Str"",0,list.size());
}"
55618,"@Override public void commandTroops(Set<Integer> soldiersWithOrders){
  SoldierPositions soldierPositions=calculateSituation(player.playerId);
  if (aiStatistics.getEnemiesInTownOf(player.playerId).size() > 0) {
    defend(soldierPositions,soldiersWithOrders);
  }
 else   if (existsAliveEnemy()) {
    IPlayer weakestEnemy=getWeakestEnemy();
    SoldierPositions enemySoldierPositions=calculateSituation(weakestEnemy.getPlayerId());
    boolean infantryWouldDie=wouldInfantryDie(enemySoldierPositions);
    if (attackIsPossible(soldierPositions,enemySoldierPositions,infantryWouldDie)) {
      attack(soldierPositions,infantryWouldDie,soldiersWithOrders);
    }
  }
}","@Override public void commandTroops(Set<Integer> soldiersWithOrders){
  ensureAllTowersFullyMounted();
  SoldierPositions soldierPositions=calculateSituation(player.playerId);
  if (aiStatistics.getEnemiesInTownOf(player.playerId).size() > 0) {
    defend(soldierPositions,soldiersWithOrders);
  }
 else   if (existsAliveEnemy()) {
    IPlayer weakestEnemy=getWeakestEnemy();
    SoldierPositions enemySoldierPositions=calculateSituation(weakestEnemy.getPlayerId());
    boolean infantryWouldDie=wouldInfantryDie(enemySoldierPositions);
    if (attackIsPossible(soldierPositions,enemySoldierPositions,infantryWouldDie)) {
      attack(soldierPositions,infantryWouldDie,soldiersWithOrders);
    }
  }
}"
55619,"public ConfigurableGeneral(AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler,float attackerCountFactor){
  this.aiStatistics=aiStatistics;
  this.player=player;
  this.taskScheduler=taskScheduler;
  this.movableGrid=movableGrid;
  this.attackerCountFactor=attackerCountFactor;
}","public ConfigurableGeneral(AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler,EPlayerType playerType){
  this.aiStatistics=aiStatistics;
  this.player=player;
  this.taskScheduler=taskScheduler;
  this.movableGrid=movableGrid;
  this.attackerCountFactor=ATTACKER_COUNT_FACTOR_BY_PLAYER_TYPE[playerType.ordinal()];
}"
55620,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId)) {
      int resourceAmount=0;
      LandscapeGrid landscapeGrid=aiStatistics.getMainGrid().getLandscapeGrid();
      for (      RelativePoint relativePoint : buildingType.getBlockedTiles()) {
        int x=point.x + relativePoint.getDx();
        int y=point.y + relativePoint.getDy();
        if (landscapeGrid.getResourceTypeAt(x,y) == resourceType) {
          resourceAmount-=landscapeGrid.getResourceAmountAt(x,y);
        }
      }
      if (resourceAmount != 0) {
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,resourceAmount));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId)) {
      int resourceAmount=0;
      LandscapeGrid landscapeGrid=aiStatistics.getMainGrid().getLandscapeGrid();
      for (      RelativePoint relativePoint : buildingType.getBlockedTiles()) {
        int x=point.x + relativePoint.getDx();
        int y=point.y + relativePoint.getDy();
        if (landscapeGrid.getResourceTypeAt(x,y) == resourceType) {
          resourceAmount+=landscapeGrid.getResourceAmountAt(x,y);
        }
      }
      if (resourceAmount != 0) {
        int distanceToCenter=aiStatistics.getPositionOfPartition(playerId).getOnGridDistTo(point);
        int score=resourceAmount - (int)(distanceToCenter * DISTANCE_PENALTY_FACTOR);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,-score));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
55621,"private ArmyGeneral determineArmyGeneral(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler){
  return new ConfigurableGeneral(aiStatistics,player,movableGrid,taskScheduler,ATTACKER_COUNT_FACTOR[type.ordinal()]);
}","private ArmyGeneral determineArmyGeneral(EPlayerType playerType,ECivilisation civilisation,AiStatistics aiStatistics,Player player,MovableGrid movableGrid,ITaskScheduler taskScheduler){
  return new ConfigurableGeneral(aiStatistics,player,movableGrid,taskScheduler,playerType);
}"
55622,"private EconomyMinister determineMinister(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player){
switch (type) {
case AI_VERY_EASY:
    return new BuildingListEconomyMinister(aiStatistics,player,1F / 8F,1F / 4F,true);
case AI_EASY:
  return new BuildingListEconomyMinister(aiStatistics,player,1F / 4F,1F / 2F,false);
case AI_HARD:
return new BuildingListEconomyMinister(aiStatistics,player,1F / 2F,3F / 4F,false);
default :
return new BuildingListEconomyMinister(aiStatistics,player,1F,1F,false);
}
}","private EconomyMinister determineMinister(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player){
switch (type) {
case AI_VERY_EASY:
    return new BuildingListEconomyMinister(aiStatistics,player,1F / 10F,1F / 5F,true);
case AI_EASY:
  return new BuildingListEconomyMinister(aiStatistics,player,1F / 4F,1F / 2F,false);
case AI_HARD:
return new BuildingListEconomyMinister(aiStatistics,player,1F / 2F,3F / 4F,false);
default :
return new BuildingListEconomyMinister(aiStatistics,player,1F,1F,false);
}
}"
55623,"public BooleanMovingAverage(int numberOfValues,boolean defaultValue){
  values=new boolean[numberOfValues];
  if (defaultValue) {
    for (int i=0; i < numberOfValues; i++) {
      values[i]=defaultValue;
    }
    count=numberOfValues;
  }
}","/** 
 * Creates a fix sized boolean array filled with the default value.
 * @param numberOfValues the length of the array
 * @param defaultValue the default value to fill all entries of the array
 */
public BooleanMovingAverage(int numberOfValues,boolean defaultValue){
  values=new boolean[numberOfValues];
  if (defaultValue) {
    Arrays.fill(values,defaultValue);
    countTrue=numberOfValues;
  }
}"
55624,"public float getAverage(){
  return ((float)count) / values.length;
}","public float getAverage(){
  return ((float)countTrue) / values.length;
}"
55625,"NewFoWThread(){
  super(""String_Node_Str"");
  super.setDaemon(true);
  this.buffer=new byte[width][height];
  drawer=new CircleDrawer();
}","NewFoWThread(){
  super(""String_Node_Str"");
  super.setDaemon(true);
}"
55626,"@Override public final void run(){
  mySleep(500);
  while (!canceled) {
    if (enabled) {
      rebuildSight();
    }
    mySleep(800);
  }
}","@Override public final void run(){
  mySleep(500L);
  while (!canceled) {
    if (enabled) {
      rebuildSight();
    }
    mySleep(800L);
  }
}"
55627,"private void mySleep(int ms){
  try {
    Thread.sleep(ms);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","private void mySleep(long ms){
  try {
    Thread.sleep(ms);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
55628,"private void rebuildSight(){
  drawer.setBuffer(buffer);
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      byte currSight=sight[x][y];
      if (currSight >= CommonConstants.FOG_OF_WAR_EXPLORED) {
        byte newSight=(byte)(currSight - DIM_DOWN_SPEED);
        if (newSight < CommonConstants.FOG_OF_WAR_EXPLORED) {
          buffer[x][y]=CommonConstants.FOG_OF_WAR_EXPLORED;
        }
 else {
          buffer[x][y]=newSight;
        }
      }
 else {
        buffer[x][y]=sight[x][y];
      }
    }
  }
  ConcurrentLinkedQueue<? extends IViewDistancable> buildings=grid.getBuildingViewDistancables();
  applyViewDistances(buildings);
  ConcurrentLinkedQueue<? extends IViewDistancable> movables=grid.getMovableViewDistancables();
  applyViewDistances(movables);
  byte[][] temp=sight;
  sight=buffer;
  buffer=temp;
}","private void rebuildSight(){
  drawer.setBuffer(buffer);
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      byte currSight=sight[x][y];
      if (currSight >= CommonConstants.FOG_OF_WAR_EXPLORED) {
        byte newSight=(byte)(currSight - DIM_DOWN_SPEED);
        if (newSight < CommonConstants.FOG_OF_WAR_EXPLORED) {
          buffer[x][y]=CommonConstants.FOG_OF_WAR_EXPLORED;
        }
 else {
          buffer[x][y]=newSight;
        }
      }
 else {
        buffer[x][y]=sight[x][y];
      }
    }
  }
  ConcurrentLinkedQueue<? extends IViewDistancable> buildings=grid.getBuildingViewDistancables();
  applyViewDistances(buildings);
  ConcurrentLinkedQueue<? extends IViewDistancable> movables=grid.getMovableViewDistancables();
  applyViewDistances(movables);
  byte[][] temp=sight;
  sight=buffer;
  buffer=temp;
}"
55629,"private void changeTowerSoldiers(ChangeTowerSoldiersGuiTask soldierTask){
  ShortPoint2D buildingPosition=soldierTask.getBuildingPos();
  OccupyingBuilding occupyingBuilding=(OccupyingBuilding)grid.getBuildingAt(buildingPosition.x,buildingPosition.y);
switch (soldierTask.getTaskType()) {
case FULL:
    occupyingBuilding.requestSoldiers();
  break;
case MORE:
occupyingBuilding.requestSoldier(soldierTask.getSoldierType());
break;
case ONE:
occupyingBuilding.releaseSoldiers();
break;
case LESS:
occupyingBuilding.releaseSoldier(soldierTask.getSoldierType());
break;
}
}","private void changeTowerSoldiers(ChangeTowerSoldiersGuiTask soldierTask){
  ShortPoint2D buildingPosition=soldierTask.getBuildingPos();
  OccupyingBuilding occupyingBuilding=(OccupyingBuilding)grid.getBuildingAt(buildingPosition.x,buildingPosition.y);
switch (soldierTask.getTaskType()) {
case FULL:
    occupyingBuilding.requestFullSoldiers();
  break;
case MORE:
occupyingBuilding.requestSoldier(soldierTask.getSoldierType());
break;
case ONE:
occupyingBuilding.releaseSoldiers();
break;
case LESS:
occupyingBuilding.releaseSoldier(soldierTask.getSoldierType());
break;
}
}"
55630,"private void initSoldierRequests(){
  final OccupierPlace[] occupierPlaces=super.getBuildingType().getOccupierPlaces();
  if (occupierPlaces.length > 0) {
    emptyPlaces.addAll(Arrays.asList(occupierPlaces));
    requestSoldiers();
  }
}","private void initSoldierRequests(){
  final OccupierPlace[] occupierPlaces=super.getBuildingType().getOccupierPlaces();
  if (occupierPlaces.length > 0) {
    emptyPlaces.addAll(Arrays.asList(occupierPlaces));
    requestSoldier(ESoldierClass.INFANTRY);
  }
}"
55631,"public BooleanMovingAverage(int numberOfValues,boolean defaultValue){
  values=new boolean[numberOfValues];
  if (defaultValue) {
    for (int i=0; i < numberOfValues; i++) {
      values[i]=defaultValue;
    }
    count=numberOfValues;
  }
}","/** 
 * Creates a fix sized boolean array filled with the default value.
 * @param numberOfValues the length of the array
 * @param defaultValue the default value to fill all entries of the array
 */
public BooleanMovingAverage(int numberOfValues,boolean defaultValue){
  values=new boolean[numberOfValues];
  if (defaultValue) {
    Arrays.fill(values,defaultValue);
    countTrue=numberOfValues;
  }
}"
55632,"public float getAverage(){
  return ((float)count) / values.length;
}","public float getAverage(){
  return ((float)countTrue) / values.length;
}"
55633,"protected void productivityActionExecuted(boolean successfully){
  movingAverage.inserValue(successfully);
}","protected void productivityActionExecuted(boolean successfully){
  movingAverage.insertValue(successfully);
}"
55634,"void addStartTowerMaterialsAndSettlers(EMapStartResources startResources){
  if (hasBuildings) {
    return;
  }
  int playerCount=mapData.getPlayerCount();
  for (byte playerId=0; playerId < playerCount; playerId++) {
    ShortPoint2D startPoint=mapData.getStartPoint(playerId);
    mapData.setMapObject(startPoint.x,startPoint.y,new BuildingMapDataObject(EBuildingType.TOWER,playerId));
    List<MapDataObject> mapObjects=EMapStartResources.generateStackObjects(startResources);
    mapObjects.addAll(EMapStartResources.generateMovableObjects(startResources,playerId));
    List<RelativePoint> towerTiles=Arrays.asList(EBuildingType.TOWER.getProtectedTiles());
    RelativePoint relativeMapObjectPoint=new RelativePoint(-3,3);
    for (    MapDataObject currentMapObject : mapObjects) {
      do {
        relativeMapObjectPoint=nextPointOnSpiral(relativeMapObjectPoint);
        if (towerTiles.contains(relativeMapObjectPoint)) {
          continue;
        }
        int x=relativeMapObjectPoint.calculateX(startPoint.x);
        int y=relativeMapObjectPoint.calculateY(startPoint.y);
        if (mapData.getMapObject(x,y) == null) {
          mapData.setMapObject(x,y,currentMapObject);
          break;
        }
      }
 while (true);
    }
  }
}","public void addStartTowerMaterialsAndSettlers(EMapStartResources startResources,PlayerSetting[] playerSettings){
  if (hasBuildings) {
    return;
  }
  int playerCount=mapData.getPlayerCount();
  for (byte playerId=0; playerId < playerCount; playerId++) {
    if (playerSettings != null && !playerSettings[playerId].isAvailable())     continue;
    ShortPoint2D startPoint=mapData.getStartPoint(playerId);
    mapData.setMapObject(startPoint.x,startPoint.y,new BuildingMapDataObject(EBuildingType.TOWER,playerId));
    List<MapDataObject> mapObjects=EMapStartResources.generateStackObjects(startResources);
    mapObjects.addAll(EMapStartResources.generateMovableObjects(startResources,playerId));
    List<RelativePoint> towerTiles=Arrays.asList(EBuildingType.TOWER.getProtectedTiles());
    RelativePoint relativeMapObjectPoint=new RelativePoint(-3,3);
    for (    MapDataObject currentMapObject : mapObjects) {
      do {
        relativeMapObjectPoint=nextPointOnSpiral(relativeMapObjectPoint);
        if (towerTiles.contains(relativeMapObjectPoint)) {
          continue;
        }
        int x=relativeMapObjectPoint.calculateX(startPoint.x);
        int y=relativeMapObjectPoint.calculateY(startPoint.y);
        if (mapData.getMapObject(x,y) == null) {
          mapData.setMapObject(x,y,currentMapObject);
          break;
        }
      }
 while (true);
    }
  }
}"
55635,"@Override public IMapData getMapData() throws MapLoadException {
  loadMapContent(EMapStartResources.HIGH_GOODS);
  OriginalMapFileContent mapData=mapContent.mapData;
  mapData.calculateBlockedPartitions();
  return mapData;
}","@Override public IMapData getMapData() throws MapLoadException {
  loadMapContent(EMapStartResources.HIGH_GOODS,null);
  OriginalMapFileContent mapData=mapContent.mapData;
  mapData.calculateBlockedPartitions();
  return mapData;
}"
55636,"@Override public MainGridWithUiSettings loadMainGrid(PlayerSetting[] playerSettings,EMapStartResources startResources) throws MapLoadException {
  MilliStopWatch watch=new MilliStopWatch();
  loadMapContent(startResources);
  OriginalMapFileContent mapData=mapContent.mapData;
  mapData.calculateBlockedPartitions();
  watch.stop(""String_Node_Str"");
  byte numberOfPlayers=(byte)getMaxPlayers();
  if (playerSettings == null || CommonConstants.ACTIVATE_ALL_PLAYERS) {
    playerSettings=new PlayerSetting[numberOfPlayers];
    for (int i=0; i < numberOfPlayers; i++) {
      playerSettings[i]=new PlayerSetting((byte)i);
    }
  }
  MainGrid mainGrid=new MainGrid(getMapId(),getMapName(),mapData,playerSettings);
  PlayerState[] playerStates=new PlayerState[numberOfPlayers];
  for (byte playerId=0; playerId < numberOfPlayers; playerId++) {
    playerStates[playerId]=new PlayerState(playerId,new UIState(mapData.getStartPoint(playerId)));
  }
  return new MainGridWithUiSettings(mainGrid,playerStates);
}","@Override public MainGridWithUiSettings loadMainGrid(PlayerSetting[] playerSettings,EMapStartResources startResources) throws MapLoadException {
  MilliStopWatch watch=new MilliStopWatch();
  loadMapContent(startResources,playerSettings);
  OriginalMapFileContent mapData=mapContent.mapData;
  mapData.calculateBlockedPartitions();
  watch.stop(""String_Node_Str"");
  byte numberOfPlayers=(byte)getMaxPlayers();
  if (playerSettings == null || CommonConstants.ACTIVATE_ALL_PLAYERS) {
    playerSettings=new PlayerSetting[numberOfPlayers];
    for (int i=0; i < numberOfPlayers; i++) {
      playerSettings[i]=new PlayerSetting((byte)i);
    }
  }
  MainGrid mainGrid=new MainGrid(getMapId(),getMapName(),mapData,playerSettings);
  PlayerState[] playerStates=new PlayerState[numberOfPlayers];
  for (byte playerId=0; playerId < numberOfPlayers; playerId++) {
    playerStates[playerId]=new PlayerState(playerId,new UIState(mapData.getStartPoint(playerId)));
  }
  return new MainGridWithUiSettings(mainGrid,playerStates);
}"
55637,"private void loadMapContent(EMapStartResources startResources) throws MapLoadException {
  try {
    mapContent.reOpen(this.listedMap.getInputStream());
  }
 catch (  Exception e) {
    throw new MapLoadException(e);
  }
  mapContent.loadMapResources();
  mapContent.readBasicMapInformation();
  mapContent.readMapData();
  mapContent.readStacks();
  mapContent.readSettlers();
  mapContent.readBuildings();
  mapContent.addStartTowerMaterialsAndSettlers(startResources);
}","private void loadMapContent(EMapStartResources startResources,PlayerSetting[] playerSettings) throws MapLoadException {
  try {
    mapContent.reOpen(this.listedMap.getInputStream());
  }
 catch (  Exception e) {
    throw new MapLoadException(e);
  }
  mapContent.loadMapResources();
  mapContent.readBasicMapInformation();
  mapContent.readMapData();
  mapContent.readStacks();
  mapContent.readSettlers();
  mapContent.readBuildings();
  mapContent.addStartTowerMaterialsAndSettlers(startResources,playerSettings);
}"
55638,"private JSettlersGame.GameRunner createStartingGame(PlayerSetting[] playerSettings) throws MapLoadException {
  byte playerId=0;
  for (byte i=0; i < playerSettings.length; i++) {
    if (playerSettings[i].isAvailable()) {
      playerId=i;
      break;
    }
  }
  MapLoader mapCreator=MapUtils.getSpezialSumpf();
  JSettlersGame game=new JSettlersGame(mapCreator,2L,new OfflineNetworkConnector(),playerId,playerSettings);
  return (JSettlersGame.GameRunner)game.start();
}","private JSettlersGame.GameRunner createStartingGame(PlayerSetting[] playerSettings) throws MapLoadException {
  byte playerId=0;
  for (byte i=0; i < playerSettings.length; i++) {
    if (playerSettings[i].isAvailable()) {
      playerId=i;
      break;
    }
  }
  MapLoader mapCreator=MapUtils.getSpezialSumpf();
  JSettlersGame game=new JSettlersGame(mapCreator,0L,new OfflineNetworkConnector(),playerId,playerSettings);
  return (JSettlersGame.GameRunner)game.start();
}"
55639,"@Test public void veryHardShouldProduceCertainAmountOfSoldiersWithin90Minutes() throws MapLoadException {
  byte playerId=(byte)0;
  PlayerSetting[] playerSettings=getDefaultPlayerSettings(12);
  playerSettings[playerId]=new PlayerSetting(EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,playerId);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(90 * MINUTES);
  short expectedMinimalProducedSoldiers=1000;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    stopAndFail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str"",startedGame,startingGame.getMainGrid(),playerId);
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),200,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),100,2500);
}","@Test public void veryHardShouldProduceCertainAmountOfSoldiersWithin90Minutes() throws MapLoadException {
  byte playerId=(byte)0;
  PlayerSetting[] playerSettings=getDefaultPlayerSettings(12);
  playerSettings[playerId]=new PlayerSetting(EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,playerId);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(90 * MINUTES);
  short expectedMinimalProducedSoldiers=920;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    stopAndFail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str"",startedGame,startingGame.getMainGrid(),playerId);
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),200,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),100,2500);
}"
55640,"@Test public void hardShouldConquerEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_HARD,EPlayerType.AI_EASY,65 * MINUTES);
}","@Test public void hardShouldConquerEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_HARD,EPlayerType.AI_EASY,75 * MINUTES);
}"
55641,"@Override public void setMapViewport(MapRectangle screenArea){
  int centerX=screenArea.getLineStartX(screenArea.getLines() / 2) + screenArea.getLineLength() / 2;
  int centerY=screenArea.getLineY(screenArea.getLines() / 2);
  ShortPoint2D displayCenter=new ShortPoint2D(centerX,centerY);
  controlsAdapter.onPositionChanged(screenArea,displayCenter);
}","@Override public void setMapViewport(MapRectangle screenArea){
  int centerX=screenArea.getLineStartX(screenArea.getHeight() / 2) + screenArea.getWidth() / 2;
  int centerY=screenArea.getLineY(screenArea.getHeight() / 2);
  ShortPoint2D displayCenter=new ShortPoint2D(centerX,centerY);
  controlsAdapter.onPositionChanged(screenArea,displayCenter);
}"
55642,"@Test public void testStacksAreNotBlockedButProtected(){
  for (  RelativeStack stack : buildingType.getConstructionStacks()) {
    assertFalse(isBlocked(stack));
    assertTrue(isProtected(stack));
  }
  for (  RelativeStack stack : buildingType.getRequestStacks()) {
    assertFalse(isBlocked(stack));
    assertTrue(isProtected(stack));
  }
  for (  RelativeStack stack : buildingType.getOfferStacks()) {
    assertFalse(isBlocked(stack));
    assertTrue(isProtected(stack));
  }
}","@Test public void testStacksAreNotBlockedButProtected(){
  for (  RelativeStack stack : buildingType.getConstructionStacks()) {
    assertFalse(buildingType + ""String_Node_Str"",isBlocked(stack));
    assertTrue(buildingType + ""String_Node_Str"",isProtected(stack));
  }
  for (  RelativeStack stack : buildingType.getRequestStacks()) {
    assertFalse(buildingType + ""String_Node_Str"",isBlocked(stack));
    assertTrue(buildingType + ""String_Node_Str"",isProtected(stack));
  }
  for (  RelativeStack stack : buildingType.getOfferStacks()) {
    assertFalse(buildingType + ""String_Node_Str"",isBlocked(stack));
    assertTrue(buildingType + ""String_Node_Str"",isProtected(stack));
  }
}"
55643,"protected void notifyListeners(){
synchronized (listeners) {
    stream(listeners).forEach(listeners -> listeners.update(currentData));
  }
}","protected void notifyListeners(){
  if (currentData == null) {
    return;
  }
synchronized (listeners) {
    stream(listeners).forEach(listeners -> listeners.update(currentData));
  }
}"
55644,"public Movable(AbstractMovableGrid grid,EMovableType movableType,ShortPoint2D position,Player player){
  this.grid=grid;
  this.position=position;
  this.player=player;
  this.strategy=MovableStrategy.getStrategy(this,movableType);
  this.movableType=movableType;
  this.health=movableType.getHealth();
  this.direction=EDirection.VALUES[MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS)];
  RescheduleTimer.add(this,Constants.MOVABLE_INTERRUPT_PERIOD);
  this.id=nextID++;
  movablesByID.put(this.id,this);
  allMovables.offer(this);
  if (isShip()) {
    BuildingFile file=new BuildingFile(this.movableType.toString());
    this.images=file.getImages();
    for (int i=0; i < this.cargoStacks; i++) {
      this.cargoType[i]=null;
      this.cargoCount[i]=0;
    }
  }
  grid.enterPosition(position,this,true);
}","public Movable(AbstractMovableGrid grid,EMovableType movableType,ShortPoint2D position,Player player){
  this.grid=grid;
  this.position=position;
  this.player=player;
  this.strategy=MovableStrategy.getStrategy(this,movableType);
  this.movableType=movableType;
  this.health=movableType.getHealth();
  this.direction=EDirection.VALUES[MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS)];
  RescheduleTimer.add(this,Constants.MOVABLE_INTERRUPT_PERIOD);
  this.id=nextID++;
  movablesByID.put(this.id,this);
  allMovables.offer(this);
  if (isShip()) {
    for (int i=0; i < this.cargoStacks; i++) {
      this.cargoType[i]=null;
      this.cargoCount[i]=0;
    }
  }
  grid.enterPosition(position,this,true);
}"
55645,"private IPathCalculatable getPathable(final short x,final short y){
  return new IPathCalculatable(){
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(x,y);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
    @Override public boolean isShip(){
      return false;
    }
  }
;
}","private IPathCalculatable getPathable(final short x,final short y){
  return new IPathCalculatable(){
    @Override public ShortPoint2D getPosition(){
      return new ShortPoint2D(x,y);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
    @Override public boolean isShip(){
      return false;
    }
  }
;
}"
55646,"@Override public IManagerBearer removeJoblessCloseTo(ShortPoint2D position){
  int closestDist=Integer.MAX_VALUE;
  IManagerBearer closest=null;
  for (  IManagerBearer curr : jobless) {
    int currDist=ShortPoint2D.getOnGridDist(curr.getPos().x - position.x,curr.getPos().y - position.y);
    if (closestDist > currDist) {
      closest=curr;
      closestDist=currDist;
    }
  }
  return closest;
}","@Override public IManagerBearer removeJoblessCloseTo(ShortPoint2D position){
  int closestDist=Integer.MAX_VALUE;
  IManagerBearer closest=null;
  for (  IManagerBearer curr : jobless) {
    int currDist=ShortPoint2D.getOnGridDist(curr.getPosition().x - position.x,curr.getPosition().y - position.y);
    if (closestDist > currDist) {
      closest=curr;
      closestDist=currDist;
    }
  }
  return closest;
}"
55647,"public void addJoblessAt(final ShortPoint2D pos){
  jobless.add(new IManagerBearer(){
    private static final long serialVersionUID=3833820381369081344L;
    @Override public ShortPoint2D getPos(){
      return pos;
    }
    @Override public void deliver(    EMaterialType materialType,    IMaterialOffer offer,    IMaterialRequest request){
      offer.distributionAccepted();
      offer.offerTaken();
      request.deliveryAccepted();
      request.deliveryFulfilled();
    }
  }
);
}","public void addJoblessAt(final ShortPoint2D position){
  jobless.add(new IManagerBearer(){
    private static final long serialVersionUID=3833820381369081344L;
    @Override public ShortPoint2D getPosition(){
      return position;
    }
    @Override public void deliver(    EMaterialType materialType,    IMaterialOffer offer,    IMaterialRequest request){
      offer.distributionAccepted();
      offer.offerTaken();
      request.deliveryAccepted();
      request.deliveryFulfilled();
    }
  }
);
}"
55648,"private IPathCalculatable getPathable(final short x,final short y){
  return new IPathCalculatable(){
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(x,y);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
    @Override public boolean isShip(){
      return false;
    }
  }
;
}","private IPathCalculatable getPathable(final short x,final short y){
  return new IPathCalculatable(){
    @Override public ShortPoint2D getPosition(){
      return new ShortPoint2D(x,y);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
    @Override public boolean isShip(){
      return false;
    }
  }
;
}"
55649,"@Override public IManagerBearer removeJoblessCloseTo(ShortPoint2D position){
  int closestDist=Integer.MAX_VALUE;
  IManagerBearer closest=null;
  for (  IManagerBearer curr : jobless) {
    int currDist=ShortPoint2D.getOnGridDist(curr.getPos().x - position.x,curr.getPos().y - position.y);
    if (closestDist > currDist) {
      closest=curr;
      closestDist=currDist;
    }
  }
  return closest;
}","@Override public IManagerBearer removeJoblessCloseTo(ShortPoint2D position){
  int closestDist=Integer.MAX_VALUE;
  IManagerBearer closest=null;
  for (  IManagerBearer curr : jobless) {
    int currDist=ShortPoint2D.getOnGridDist(curr.getPosition().x - position.x,curr.getPosition().y - position.y);
    if (closestDist > currDist) {
      closest=curr;
      closestDist=currDist;
    }
  }
  return closest;
}"
55650,"public void addJoblessAt(final ShortPoint2D pos){
  jobless.add(new IManagerBearer(){
    private static final long serialVersionUID=3833820381369081344L;
    @Override public ShortPoint2D getPos(){
      return pos;
    }
    @Override public void deliver(    EMaterialType materialType,    IMaterialOffer offer,    IMaterialRequest request){
      offer.distributionAccepted();
      offer.offerTaken();
      request.deliveryAccepted();
      request.deliveryFulfilled();
    }
  }
);
}","public void addJoblessAt(final ShortPoint2D pos){
  jobless.add(new IManagerBearer(){
    private static final long serialVersionUID=3833820381369081344L;
    @Override public ShortPoint2D getPosition(){
      return pos;
    }
    @Override public void deliver(    EMaterialType materialType,    IMaterialOffer offer,    IMaterialRequest request){
      offer.distributionAccepted();
      offer.offerTaken();
      request.deliveryAccepted();
      request.deliveryFulfilled();
    }
  }
);
}"
55651,"public static void main(String args[]){
  IDijkstraPathMap map=new IDijkstraPathMap(){
    @Override public boolean fitsSearchType(    int x,    int y,    ESearchType type,    IPathCalculatable requester){
      if (x == 120 && y == 100)       return true;
      if (x == 110 && y == 110)       return true;
      return x == 118 && y == 115;
    }
    @Override public boolean fitsSearchType(    int x,    int y,    Set<ESearchType> types,    IPathCalculatable requester){
      return false;
    }
    @Override public void setDijkstraSearched(    int x,    int y){
    }
  }
;
  DummyEmptyAStarMap aStarMap=new DummyEmptyAStarMap(WIDTH,HEIGHT);
  aStarMap.setBlocked(120,100,true);
  DijkstraAlgorithm dijkstra=new DijkstraAlgorithm(map,new BucketQueueAStar(aStarMap,WIDTH,HEIGHT),WIDTH,HEIGHT);
  IPathCalculatable requester=new IPathCalculatable(){
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(100,100);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
  }
;
  Path path=dijkstra.find(requester,(short)100,(short)100,(short)1,(short)30,null);
  System.out.println(""String_Node_Str"" + path);
}","public static void main(String args[]){
  IDijkstraPathMap map=new IDijkstraPathMap(){
    @Override public boolean fitsSearchType(    int x,    int y,    ESearchType type,    IPathCalculatable requester){
      if (x == 120 && y == 100)       return true;
      if (x == 110 && y == 110)       return true;
      return x == 118 && y == 115;
    }
    @Override public boolean fitsSearchType(    int x,    int y,    Set<ESearchType> types,    IPathCalculatable requester){
      return false;
    }
    @Override public void setDijkstraSearched(    int x,    int y){
    }
  }
;
  DummyEmptyAStarMap aStarMap=new DummyEmptyAStarMap(WIDTH,HEIGHT);
  aStarMap.setBlocked(120,100,true);
  DijkstraAlgorithm dijkstra=new DijkstraAlgorithm(map,new BucketQueueAStar(aStarMap,WIDTH,HEIGHT),WIDTH,HEIGHT);
  IPathCalculatable requester=new IPathCalculatable(){
    @Override public ShortPoint2D getPosition(){
      return new ShortPoint2D(100,100);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
    @Override public boolean isShip(){
      return false;
    }
  }
;
  Path path=dijkstra.find(requester,(short)100,(short)100,(short)1,(short)30,null);
  System.out.println(""String_Node_Str"" + path);
}"
55652,"public void moveStep(){
  for (  TestSettler settler : this.settlers) {
    settler.increaseProgress();
    if (settler.moveOn()) {
      TestTile newPosition=this.getTile(settler.getDirection().getNextHexPoint(settler.getPos()));
      if (newPosition == null) {
        EDirection direction=getRandomDirection();
        settler.setDirection(direction);
      }
 else {
        TestTile nextPosition=this.getTile(settler.getDirection().getNextHexPoint(newPosition.getPos()));
        this.getTile(settler.getPos()).setMovable(null);
        newPosition.setMovable(settler);
        settler.setPosition(newPosition);
        if (nextPosition == null || nextPosition.getMovable() != null || nextPosition.getLandscapeType() == ELandscapeType.WATER1) {
          EDirection direction=getRandomDirection();
          settler.setDirection(direction);
        }
      }
    }
  }
  for (  TestBuilding bulding : this.buildings) {
    bulding.increaseConstructed();
  }
}","public void moveStep(){
  for (  TestSettler settler : this.settlers) {
    settler.increaseProgress();
    if (settler.moveOn()) {
      TestTile newPosition=this.getTile(settler.getDirection().getNextHexPoint(settler.getPosition()));
      if (newPosition == null) {
        EDirection direction=getRandomDirection();
        settler.setDirection(direction);
      }
 else {
        TestTile nextPosition=this.getTile(settler.getDirection().getNextHexPoint(newPosition.getPos()));
        this.getTile(settler.getPosition()).setMovable(null);
        newPosition.setMovable(settler);
        settler.setPosition(newPosition);
        if (nextPosition == null || nextPosition.getMovable() != null || nextPosition.getLandscapeType() == ELandscapeType.WATER1) {
          EDirection direction=getRandomDirection();
          settler.setDirection(direction);
        }
      }
    }
  }
  for (  TestBuilding bulding : this.buildings) {
    bulding.increaseConstructed();
  }
}"
55653,"public T drawRandom(){
  float random=MatchConstants.random().nextFloat() * sum;
  if (sum == 0) {
    return null;
  }
  float prefixSum=0;
  for (int index=0; index < userValues.length; index++) {
    prefixSum+=userValues[index];
    if (random <= prefixSum) {
      if (decreaseOnDraw) {
        changeUserValue(index,-1);
      }
      return ordinalToTypeMapper.map(index);
    }
  }
  return null;
}","public T drawRandom(){
  float random=MatchConstants.random().nextFloat() * sum;
  if (sum == 0) {
    return null;
  }
  float prefixSum=0;
  for (int index=0; index < userValues.length; index++) {
    prefixSum+=userValues[index];
    if (random < prefixSum) {
      if (decreaseOnDraw) {
        changeUserValue(index,-1);
      }
      return ordinalToTypeMapper.map(index);
    }
  }
  return null;
}"
55654,"public void finish(){
  drawControls.removeDrawListener(this);
}","public void finish(){
  drawControls.removeInfrequentDrawListener(this);
}"
55655,"private int[] calculateBuildingCounts(int numberOfWeaponSmiths,int maxFishermen,int maxGoldMelts,int maxWineGrower,int maxBigTemples,long grassTiles){
  int[] buildingCounts=new int[EBuildingType.NUMBER_OF_BUILDINGS];
  for (int i=0; i < buildingCounts.length; i++) {
    buildingCounts[i]=0;
  }
  buildingCounts[EBuildingType.COALMINE.ordinal]=numberOfWeaponSmiths;
  buildingCounts[EBuildingType.IRONMINE.ordinal]=Math.round(numberOfWeaponSmiths / COAL_MINE_TO_IRON_MINE_RATIO + 1);
  buildingCounts[EBuildingType.IRONMELT.ordinal]=numberOfWeaponSmiths;
  buildingCounts[EBuildingType.WEAPONSMITH.ordinal]=numberOfWeaponSmiths;
  buildingCounts[EBuildingType.BARRACK.ordinal]=(int)Math.ceil((double)numberOfWeaponSmiths / WEAPON_SMITH_TO_BARRACKS_RATIO);
  buildingCounts[EBuildingType.TOOLSMITH.ordinal]=1;
  int numberOfFisher=Math.min((int)(numberOfWeaponSmiths / WEAPON_SMITH_TO_FISHER_HUT_RATIO),maxFishermen);
  buildingCounts[EBuildingType.FISHER.ordinal]=numberOfFisher;
  int numberOfRemainingWeaponSmiths=Math.max(0,numberOfWeaponSmiths - (int)(numberOfFisher * WEAPON_SMITH_TO_FISHER_HUT_RATIO));
  int numberOfFarms=(int)Math.ceil(numberOfRemainingWeaponSmiths / WEAPON_SMITH_TO_FARM_RATIO);
  buildingCounts[EBuildingType.FARM.ordinal]=numberOfFarms;
  buildingCounts[EBuildingType.BAKER.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_BAKER_RATIO);
  buildingCounts[EBuildingType.MILL.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_MILL_RATIO);
  buildingCounts[EBuildingType.WATERWORKS.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_WATERWORKS_RATIO);
  buildingCounts[EBuildingType.SLAUGHTERHOUSE.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_SLAUGHTER_RATIO);
  buildingCounts[EBuildingType.PIG_FARM.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_PIG_FARM_RATIO);
  int lumberJacksForWeaponSmiths=Math.max(8,(int)(numberOfWeaponSmiths / WEAPON_SMITH_TO_LUMBERJACK_RATIO));
  int maxLumberJacksForMap=Math.round((float)grassTiles / GRASS_TO_LUMBERJACK_RATIO);
  int numberOfLumberJacks=Math.max(MIN_LUMBERJACK_COUNT,Math.min(maxLumberJacksForMap,lumberJacksForWeaponSmiths));
  buildingCounts[EBuildingType.LUMBERJACK.ordinal]=numberOfLumberJacks;
  buildingCounts[EBuildingType.FORESTER.ordinal]=Math.max((int)(numberOfLumberJacks / LUMBERJACK_TO_FORESTER_RATIO),1);
  buildingCounts[EBuildingType.SAWMILL.ordinal]=Math.max((int)(numberOfLumberJacks / LUMBERJACK_TO_SAWMILL_RATIO),1);
  buildingCounts[EBuildingType.STONECUTTER.ordinal]=Math.max((int)(numberOfLumberJacks / LUMBERJACK_TO_STONE_CUTTER_RATIO),1);
  if (maxGoldMelts > 0) {
    buildingCounts[EBuildingType.GOLDMELT.ordinal]=maxGoldMelts;
    buildingCounts[EBuildingType.GOLDMINE.ordinal]=1;
  }
  if (maxBigTemples > 0) {
    buildingCounts[EBuildingType.BIG_TEMPLE.ordinal]=maxBigTemples;
  }
  if (maxWineGrower > 0) {
    buildingCounts[EBuildingType.WINEGROWER.ordinal]=maxWineGrower;
    buildingCounts[EBuildingType.TEMPLE.ordinal]=maxWineGrower;
  }
  if (isEnoughSpace(buildingCounts,grassTiles)) {
    return buildingCounts;
  }
 else   if (numberOfWeaponSmiths > MIN_SMITHS_BEFORE_WINE_AND_GOLD_REDUCTION) {
    return calculateBuildingCounts(numberOfWeaponSmiths - 1,maxFishermen,maxGoldMelts,maxWineGrower,maxBigTemples,grassTiles);
  }
 else   if (maxWineGrower > MIN_WINE_GROWER_BEFORE_GOLD_REDUCTION) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrower - 1,maxBigTemples,grassTiles);
  }
 else   if (maxGoldMelts > 1) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts - 1,maxWineGrower,maxBigTemples,grassTiles);
  }
 else   if (maxWineGrower > 1) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrower - 1,maxBigTemples,grassTiles);
  }
 else   if (maxBigTemples == 1) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrower,0,grassTiles);
  }
 else {
    return calculateBuildingCounts(numberOfWeaponSmiths - 1,maxFishermen,maxGoldMelts,maxWineGrower,0,grassTiles);
  }
}","private int[] calculateBuildingCounts(int numberOfWeaponSmiths,int maxFishermen,int maxGoldMelts,int maxWineGrowers,int maxBigTemples,long grassTiles){
  int[] buildingCounts=new int[EBuildingType.NUMBER_OF_BUILDINGS];
  for (int i=0; i < buildingCounts.length; i++) {
    buildingCounts[i]=0;
  }
  buildingCounts[EBuildingType.COALMINE.ordinal]=numberOfWeaponSmiths;
  buildingCounts[EBuildingType.IRONMINE.ordinal]=Math.round(numberOfWeaponSmiths / COAL_MINE_TO_IRON_MINE_RATIO + 1);
  buildingCounts[EBuildingType.IRONMELT.ordinal]=numberOfWeaponSmiths;
  buildingCounts[EBuildingType.WEAPONSMITH.ordinal]=numberOfWeaponSmiths;
  buildingCounts[EBuildingType.BARRACK.ordinal]=(int)Math.ceil((double)numberOfWeaponSmiths / WEAPON_SMITH_TO_BARRACKS_RATIO);
  buildingCounts[EBuildingType.TOOLSMITH.ordinal]=1;
  int numberOfFisher=Math.min((int)(numberOfWeaponSmiths / WEAPON_SMITH_TO_FISHER_HUT_RATIO),maxFishermen);
  buildingCounts[EBuildingType.FISHER.ordinal]=numberOfFisher;
  int numberOfRemainingWeaponSmiths=Math.max(0,numberOfWeaponSmiths - (int)(numberOfFisher * WEAPON_SMITH_TO_FISHER_HUT_RATIO));
  int numberOfFarms=(int)Math.ceil(numberOfRemainingWeaponSmiths / WEAPON_SMITH_TO_FARM_RATIO);
  buildingCounts[EBuildingType.FARM.ordinal]=numberOfFarms;
  buildingCounts[EBuildingType.BAKER.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_BAKER_RATIO);
  buildingCounts[EBuildingType.MILL.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_MILL_RATIO);
  buildingCounts[EBuildingType.WATERWORKS.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_WATERWORKS_RATIO);
  buildingCounts[EBuildingType.SLAUGHTERHOUSE.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_SLAUGHTER_RATIO);
  buildingCounts[EBuildingType.PIG_FARM.ordinal]=(int)Math.ceil(numberOfFarms / FARM_TO_PIG_FARM_RATIO);
  int lumberJacksForWeaponSmiths=Math.max(8,(int)(numberOfWeaponSmiths / WEAPON_SMITH_TO_LUMBERJACK_RATIO));
  int maxLumberJacksForMap=Math.round((float)grassTiles / GRASS_TO_LUMBERJACK_RATIO);
  int numberOfLumberJacks=Math.max(MIN_LUMBERJACK_COUNT,Math.min(maxLumberJacksForMap,lumberJacksForWeaponSmiths));
  buildingCounts[EBuildingType.LUMBERJACK.ordinal]=numberOfLumberJacks;
  buildingCounts[EBuildingType.FORESTER.ordinal]=Math.max((int)(numberOfLumberJacks / LUMBERJACK_TO_FORESTER_RATIO),1);
  buildingCounts[EBuildingType.SAWMILL.ordinal]=Math.max((int)(numberOfLumberJacks / LUMBERJACK_TO_SAWMILL_RATIO),1);
  buildingCounts[EBuildingType.STONECUTTER.ordinal]=Math.max((int)(numberOfLumberJacks / LUMBERJACK_TO_STONE_CUTTER_RATIO),1);
  if (maxGoldMelts > 0) {
    buildingCounts[EBuildingType.GOLDMELT.ordinal]=maxGoldMelts;
    buildingCounts[EBuildingType.GOLDMINE.ordinal]=1;
  }
  if (maxBigTemples > 0) {
    buildingCounts[EBuildingType.BIG_TEMPLE.ordinal]=maxBigTemples;
  }
  if (maxWineGrowers > 0) {
    buildingCounts[EBuildingType.WINEGROWER.ordinal]=maxWineGrowers;
    buildingCounts[EBuildingType.TEMPLE.ordinal]=maxWineGrowers;
  }
  if (isEnoughSpace(buildingCounts,grassTiles)) {
    return buildingCounts;
  }
 else   if (numberOfWeaponSmiths > MIN_SMITHS_BEFORE_WINE_AND_GOLD_REDUCTION) {
    return calculateBuildingCounts(numberOfWeaponSmiths - 1,maxFishermen,maxGoldMelts,maxWineGrowers,maxBigTemples,grassTiles);
  }
 else   if (maxWineGrowers > MIN_WINE_GROWER_BEFORE_GOLD_REDUCTION) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrowers - 1,maxBigTemples,grassTiles);
  }
 else   if (maxGoldMelts > 1) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts - 1,maxWineGrowers,maxBigTemples,grassTiles);
  }
 else   if (maxWineGrowers > 1) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrowers - 1,maxBigTemples,grassTiles);
  }
 else   if (maxBigTemples > 1) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrowers,0,grassTiles);
  }
 else   if (maxWineGrowers > 0) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen,maxGoldMelts,maxWineGrowers - 1,0,grassTiles);
  }
 else   if (maxFishermen > 0) {
    return calculateBuildingCounts(numberOfWeaponSmiths,maxFishermen - 1,maxGoldMelts,maxWineGrowers,0,grassTiles);
  }
 else   if (numberOfWeaponSmiths > 0) {
    return calculateBuildingCounts(numberOfWeaponSmiths - 1,maxFishermen,maxGoldMelts,maxWineGrowers,0,grassTiles);
  }
 else {
    return new int[EBuildingType.NUMBER_OF_BUILDINGS];
  }
}"
55656,"private boolean isEnoughSpace(int[] buildingCounts,long grasTiles){
  long grasTilesWithoutBuffer=Math.round(grasTiles / 3F);
  for (int i=0; i < buildingCounts.length; i++) {
    EBuildingType buildingType=EBuildingType.VALUES[i];
    if (!buildingType.isMine()) {
      grasTilesWithoutBuffer-=EBuildingType.VALUES[i].getProtectedTiles().length * buildingCounts[i];
      if (grasTilesWithoutBuffer < 0) {
        return false;
      }
    }
  }
  return true;
}","private boolean isEnoughSpace(int[] buildingCounts,long grassTiles){
  long grassTilesWithoutBuffer=Math.round(grassTiles / 3F);
  for (int i=0; i < buildingCounts.length; i++) {
    EBuildingType buildingType=EBuildingType.VALUES[i];
    if (!buildingType.isMine()) {
      grassTilesWithoutBuffer-=EBuildingType.VALUES[i].getProtectedTiles().length * buildingCounts[i];
      if (grassTilesWithoutBuffer < 0) {
        return false;
      }
    }
  }
  return true;
}"
55657,"private boolean isIngestibleByPioneersOf(int x,int y,Player player){
  Player otherPlayer=partitionsGrid.getPlayerAt(x,y);
  return !player.hasSameTeam(otherPlayer) && !landscapeGrid.getLandscapeTypeAt(x,y).isBlocking && !partitionsGrid.isEnforcedByTower(x,y);
}","private boolean isIngestibleByPioneersOf(int x,int y,Player player){
  Player otherPlayer=partitionsGrid.getPlayerAt(x,y);
  return !player.hasSameTeam(otherPlayer) && !flagsGrid.isBlocked(x,y) && !partitionsGrid.isEnforcedByTower(x,y);
}"
55658,"public void addStartTowerMaterialsAndSettlers(EMapStartResources startResources){
  if (hasBuildings)   return;
  int playerCount=mapData.getPlayerCount();
  for (byte playerId=0; playerId < playerCount; playerId++) {
    ShortPoint2D startPoint=mapData.getStartPoint(playerId);
    mapData.setMapObject(startPoint.x,startPoint.y,new BuildingObject(EBuildingType.TOWER,playerId));
    List<MapObject> mapObjects=EMapStartResources.generateStackObjects(startResources);
    mapObjects.addAll(EMapStartResources.generateMovableObjects(startResources,playerId));
    List<RelativePoint> towerTiles=Arrays.asList(EBuildingType.TOWER.getProtectedTiles());
    RelativePoint relativeMapObjectPoint=new RelativePoint(-3,3);
    for (    MapObject currentMapObject : mapObjects) {
      do {
        relativeMapObjectPoint=nextPointOnSpiral(relativeMapObjectPoint);
        if (towerTiles.contains(relativeMapObjectPoint))         continue;
        int x=relativeMapObjectPoint.calculateX(startPoint.x);
        int y=relativeMapObjectPoint.calculateY(startPoint.y);
        if (mapData.getMapObject(x,y) == null) {
          mapData.setMapObject(x,y,currentMapObject);
          break;
        }
      }
 while (true);
    }
  }
}","public void addStartTowerMaterialsAndSettlers(EMapStartResources startResources,PlayerSetting[] playerSettings){
  if (hasBuildings)   return;
  int playerCount=mapData.getPlayerCount();
  for (byte playerId=0; playerId < playerCount; playerId++) {
    if (playerSettings != null && !playerSettings[playerId].isAvailable())     continue;
    ShortPoint2D startPoint=mapData.getStartPoint(playerId);
    mapData.setMapObject(startPoint.x,startPoint.y,new BuildingObject(EBuildingType.TOWER,playerId));
    List<MapObject> mapObjects=EMapStartResources.generateStackObjects(startResources);
    mapObjects.addAll(EMapStartResources.generateMovableObjects(startResources,playerId));
    List<RelativePoint> towerTiles=Arrays.asList(EBuildingType.TOWER.getProtectedTiles());
    RelativePoint relativeMapObjectPoint=new RelativePoint(-3,3);
    for (    MapObject currentMapObject : mapObjects) {
      do {
        relativeMapObjectPoint=nextPointOnSpiral(relativeMapObjectPoint);
        if (towerTiles.contains(relativeMapObjectPoint))         continue;
        int x=relativeMapObjectPoint.calculateX(startPoint.x);
        int y=relativeMapObjectPoint.calculateY(startPoint.y);
        if (mapData.getMapObject(x,y) == null) {
          mapData.setMapObject(x,y,currentMapObject);
          break;
        }
      }
 while (true);
    }
  }
}"
55659,"@Override public MainGridWithUiSettings loadMainGrid(PlayerSetting[] playerSettings,EMapStartResources startResources) throws MapLoadException {
  MilliStopWatch watch=new MilliStopWatch();
  try {
    mapContent.reOpen(this.listedMap.getInputStream());
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
  if (!mapContent.loadMapResources()) {
    System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return null;
  }
  mapContent.readBasicMapInformation();
  mapContent.readMapData();
  mapContent.readStacks();
  mapContent.readSettlers();
  mapContent.readBuildings();
  mapContent.addStartTowerMaterialsAndSettlers(startResources);
  OriginalMapFileContent mapData=mapContent.mapData;
  mapData.calculateBlockedPartitions();
  watch.stop(""String_Node_Str"");
  byte numberOfPlayers=(byte)getMaxPlayers();
  if (playerSettings == null || CommonConstants.ACTIVATE_ALL_PLAYERS) {
    playerSettings=new PlayerSetting[numberOfPlayers];
    for (int i=0; i < numberOfPlayers; i++) {
      playerSettings[i]=new PlayerSetting((byte)i);
    }
  }
  MainGrid mainGrid=new MainGrid(getMapId(),getMapName(),mapData,playerSettings);
  PlayerState[] playerStates=new PlayerState[numberOfPlayers];
  for (byte playerId=0; playerId < numberOfPlayers; playerId++) {
    playerStates[playerId]=new PlayerState(playerId,new UIState(mapData.getStartPoint(playerId)));
  }
  return new MainGridWithUiSettings(mainGrid,playerStates);
}","@Override public MainGridWithUiSettings loadMainGrid(PlayerSetting[] playerSettings,EMapStartResources startResources) throws MapLoadException {
  MilliStopWatch watch=new MilliStopWatch();
  try {
    mapContent.reOpen(this.listedMap.getInputStream());
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
  if (!mapContent.loadMapResources()) {
    System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str"");
    return null;
  }
  mapContent.readBasicMapInformation();
  mapContent.readMapData();
  mapContent.readStacks();
  mapContent.readSettlers();
  mapContent.readBuildings();
  mapContent.addStartTowerMaterialsAndSettlers(startResources,playerSettings);
  OriginalMapFileContent mapData=mapContent.mapData;
  mapData.calculateBlockedPartitions();
  watch.stop(""String_Node_Str"");
  byte numberOfPlayers=(byte)getMaxPlayers();
  if (playerSettings == null || CommonConstants.ACTIVATE_ALL_PLAYERS) {
    playerSettings=new PlayerSetting[numberOfPlayers];
    for (int i=0; i < numberOfPlayers; i++) {
      playerSettings[i]=new PlayerSetting((byte)i);
    }
  }
  MainGrid mainGrid=new MainGrid(getMapId(),getMapName(),mapData,playerSettings);
  PlayerState[] playerStates=new PlayerState[numberOfPlayers];
  for (byte playerId=0; playerId < numberOfPlayers; playerId++) {
    playerStates[playerId]=new PlayerState(playerId,new UIState(mapData.getStartPoint(playerId)));
  }
  return new MainGridWithUiSettings(mainGrid,playerStates);
}"
55660,"@Override public byte getTeamId(){
  return 0;
}","@Override public byte getTeamId(){
  return playerAndTeamid;
}"
55661,"@Override public byte getPlayerId(){
  return 0;
}","@Override public byte getPlayerId(){
  return playerAndTeamid;
}"
55662,"private IPathCalculatable getPathable(final short x,final short y){
  return new IPathCalculatable(){
    private static final long serialVersionUID=-7744309931981354171L;
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(x,y);
    }
    @Override public byte getPlayerId(){
      return 0;
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
  }
;
}","private IPathCalculatable getPathable(final short x,final short y){
  return new IPathCalculatable(){
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(x,y);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
  }
;
}"
55663,"public BuildingContainer(BuildingMapDataObject buildingObject,ShortPoint2D position){
  this.buildingObject=buildingObject;
  this.position=position;
}","public BuildingContainer(BuildingMapDataObject buildingObject,ShortPoint2D position){
  this.buildingObject=buildingObject;
  this.position=position;
  this.player=new IPlayer.DummyPlayer(buildingObject.getPlayerId());
}"
55664,"public MovableObjectContainer(MovableObject movableObject,int x,int y){
  this.movableObject=movableObject;
  this.pos=new ShortPoint2D(x,y);
}","public MovableObjectContainer(MovableObject movableObject,int x,int y){
  this.movableObject=movableObject;
  this.pos=new ShortPoint2D(x,y);
  this.player=new IPlayer.DummyPlayer(movableObject.getPlayerId());
}"
55665,"@Override public void doTest(){
  int playerCount=header.getMaxPlayers();
  addHeader(""String_Node_Str"",fix);
  for (int x=0; x < data.getWidth(); x++) {
    for (int y=0; y < data.getHeight(); y++) {
      MapDataObject mapObject=data.getMapObject(x,y);
      if (mapObject instanceof IPlayerable) {
        int p=((IPlayerable)mapObject).getPlayerId();
        if (p >= playerCount) {
          fix.addInvalidObject(new ShortPoint2D(x,y));
          addErrorMessage(""String_Node_Str"",new ShortPoint2D(x,y));
        }
      }
    }
  }
}","@Override public void doTest(){
  int playerCount=header.getMaxPlayers();
  addHeader(""String_Node_Str"",fix);
  for (int x=0; x < data.getWidth(); x++) {
    for (int y=0; y < data.getHeight(); y++) {
      MapDataObject mapObject=data.getMapObject(x,y);
      if (mapObject instanceof IPlayerIdProvider) {
        int p=((IPlayerIdProvider)mapObject).getPlayerId();
        if (p >= playerCount) {
          fix.addInvalidObject(new ShortPoint2D(x,y));
          addErrorMessage(""String_Node_Str"",new ShortPoint2D(x,y));
        }
      }
    }
  }
}"
55666,"public static void main(String args[]){
  IDijkstraPathMap map=new IDijkstraPathMap(){
    @Override public boolean fitsSearchType(    int x,    int y,    ESearchType type,    IPathCalculatable requester){
      if (x == 120 && y == 100)       return true;
      if (x == 110 && y == 110)       return true;
      return x == 118 && y == 115;
    }
    @Override public boolean fitsSearchType(    int x,    int y,    Set<ESearchType> types,    IPathCalculatable requester){
      return false;
    }
    @Override public void setDijkstraSearched(    int x,    int y){
    }
  }
;
  DummyEmptyAStarMap aStarMap=new DummyEmptyAStarMap(WIDTH,HEIGHT);
  aStarMap.setBlocked(120,100,true);
  DijkstraAlgorithm dijkstra=new DijkstraAlgorithm(map,new BucketQueueAStar(aStarMap,WIDTH,HEIGHT),WIDTH,HEIGHT);
  IPathCalculatable requester=new IPathCalculatable(){
    private static final long serialVersionUID=8994674255605105284L;
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(100,100);
    }
    @Override public byte getPlayerId(){
      return 0;
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
  }
;
  Path path=dijkstra.find(requester,(short)100,(short)100,(short)1,(short)30,null);
  System.out.println(""String_Node_Str"" + path);
}","public static void main(String args[]){
  IDijkstraPathMap map=new IDijkstraPathMap(){
    @Override public boolean fitsSearchType(    int x,    int y,    ESearchType type,    IPathCalculatable requester){
      if (x == 120 && y == 100)       return true;
      if (x == 110 && y == 110)       return true;
      return x == 118 && y == 115;
    }
    @Override public boolean fitsSearchType(    int x,    int y,    Set<ESearchType> types,    IPathCalculatable requester){
      return false;
    }
    @Override public void setDijkstraSearched(    int x,    int y){
    }
  }
;
  DummyEmptyAStarMap aStarMap=new DummyEmptyAStarMap(WIDTH,HEIGHT);
  aStarMap.setBlocked(120,100,true);
  DijkstraAlgorithm dijkstra=new DijkstraAlgorithm(map,new BucketQueueAStar(aStarMap,WIDTH,HEIGHT),WIDTH,HEIGHT);
  IPathCalculatable requester=new IPathCalculatable(){
    @Override public ShortPoint2D getPos(){
      return new ShortPoint2D(100,100);
    }
    @Override public IPlayer getPlayer(){
      return new IPlayer.DummyPlayer();
    }
    @Override public boolean needsPlayersGround(){
      return false;
    }
  }
;
  Path path=dijkstra.find(requester,(short)100,(short)100,(short)1,(short)30,null);
  System.out.println(""String_Node_Str"" + path);
}"
55667,"public TestSettler(EDirection direction,EMovableType type,TestTile tile,byte player){
  this.type=type;
  this.setDirection(direction);
  this.setPosition(tile);
  this.player=player;
}","public TestSettler(EDirection direction,EMovableType type,TestTile tile,byte player){
  this.type=type;
  this.setDirection(direction);
  this.setPosition(tile);
  this.player=new IPlayer.DummyPlayer(player);
}"
55668,"@Override public boolean isValidPosition(IPathCalculatable pathCalculatable,int x,int y){
  return isInBounds(x,y) && !isBlocked(x,y) && (!pathCalculatable.needsPlayersGround() || pathCalculatable.getPlayerId() == getPlayerIdAt(x,y));
}","@Override public boolean isValidPosition(IPathCalculatable pathCalculatable,int x,int y){
  return isInBounds(x,y) && !isBlocked(x,y) && (!pathCalculatable.needsPlayersGround() || pathCalculatable.getPlayer().getPlayerId() == getPlayerIdAt(x,y));
}"
55669,"@Override public void freeAreaOccupiedByTower(ShortPoint2D towerPosition){
  CoordinateStream positions=partitionsGrid.removeTowerAndFreeOccupiedArea(towerPosition);
  checkAllPositionsForEnclosedBlockedAreas(positions);
}","@Override public void freeAreaOccupiedByTower(ShortPoint2D towerPosition){
  partitionsGrid.removeTowerAndFreeOccupiedArea(towerPosition);
}"
55670,"private void destroyBuildingOrTakeOver(int x,int y,byte player){
  if (flagsGrid.isBlocked(x,y)) {
    partitionsGrid.changePlayerAt(x,y,player);
  }
  Building building=objectsGrid.getBuildingAt(x,y);
  if (building != null) {
    building.kill();
  }
}","private void destroyBuildingOrTakeOver(int x,int y,byte playerId){
  if (flagsGrid.isBlocked(x,y)) {
    partitionsGrid.changePlayerAt(x,y,playerId);
  }
  Building building=objectsGrid.getBuildingAt(x,y);
  if (building != null && building.getPlayerId() != playerId) {
    building.kill();
  }
}"
55671,"/** 
 * Removes the tower at the given position from the grid.
 * @param pos The position of the tower.
 * @return
 */
public CoordinateStream removeTowerAndFreeOccupiedArea(ShortPoint2D pos){
  PartitionOccupyingTower tower=occupyingTowers.removeAt(pos);
  if (tower == null) {
    return CoordinateStream.EMPTY;
  }
  CoordinateStream towerStream=tower.area.stream();
  changeTowerCounter(tower.playerId,towerStream,-1);
  checkOtherTowersInArea(tower);
  return towerStream;
}","/** 
 * Removes the tower at the given position from the grid.
 * @param pos The position of the tower.
 */
public void removeTowerAndFreeOccupiedArea(ShortPoint2D pos){
  PartitionOccupyingTower tower=occupyingTowers.removeAt(pos);
  if (tower == null) {
    return;
  }
  changeTowerCounter(tower.playerId,tower.area.stream(),-1);
  checkOtherTowersInArea(tower);
}"
55672,"/** 
 * Gets the number of tiles a movable must at least walk to get from (0|0) to (dx|dy).
 * @param dx
 * @param dy
 * @return
 */
public static int getOnGridDist(final int dx,final int dy){
  final int absDx=Math.abs(dx);
  final int absDy=Math.abs(dy);
  if (dx * dy > 0) {
    if (absDx > absDy) {
      return absDx;
    }
 else {
      return absDy;
    }
  }
 else {
    return absDx + absDy;
  }
}","public static int getOnGridDist(int startX,int startY,int endX,int endY){
  return getOnGridDist(endX - startX,endY - startY);
}"
55673,"public abstract boolean canConstructAt(short x,short y,EBuildingType type,byte playerId);","public abstract boolean canConstructAt(int x,int y,EBuildingType type,byte playerId);"
55674,"private final List<Integer> getIDsOfSelected(){
  return getIDsOfIterable(currentSelection);
}","private List<Integer> getIDsOfSelected(){
  return getIDsOfIterable(currentSelection);
}"
55675,"private void selectPointType(PointAction action){
  final ShortPoint2D actionPosition=action.getPosition();
  final IGuiMovable selectedMovable=getSelectableMovable(actionPosition.x,actionPosition.y);
  if (selectedMovable == null) {
    setSelection(new SelectionSet());
    return;
  }
  EMovableType selectedType=selectedMovable.getMovableType();
  byte selectedPlayerId=selectedMovable.getPlayerId();
  Set<EMovableType> selectableTypes;
  if (selectedType.isSwordsman()) {
    selectableTypes=EMovableType.swordsmen;
  }
 else   if (selectedType.isPikeman()) {
    selectableTypes=EMovableType.pikemen;
  }
 else   if (selectedType.isBowman()) {
    selectableTypes=EMovableType.bowmen;
  }
 else {
    selectableTypes=EnumSet.of(selectedType);
  }
  final List<ISelectable> selected=new LinkedList<>();
  MapCircle.stream(actionPosition,SELECT_BY_TYPE_RADIUS).forEach((x,y) -> {
    final IGuiMovable movable=grid.getMovable(x,y);
    if (movable != null && selectableTypes.contains(movable.getMovableType()) && selectedPlayerId == movable.getPlayerId()) {
      selected.add(movable);
    }
  }
);
  setSelection(new SelectionSet(selected));
}","private void selectPointType(PointAction action){
  final ShortPoint2D actionPosition=action.getPosition();
  final IGuiMovable selectedMovable=getSelectableMovable(actionPosition.x,actionPosition.y);
  if (selectedMovable == null) {
    setSelection(new SelectionSet());
    return;
  }
  EMovableType selectedType=selectedMovable.getMovableType();
  byte selectedPlayerId=selectedMovable.getPlayerId();
  Set<EMovableType> selectableTypes;
  if (selectedType.isSwordsman()) {
    selectableTypes=EMovableType.swordsmen;
  }
 else   if (selectedType.isPikeman()) {
    selectableTypes=EMovableType.pikemen;
  }
 else   if (selectedType.isBowman()) {
    selectableTypes=EMovableType.bowmen;
  }
 else {
    selectableTypes=EnumSet.of(selectedType);
  }
  final List<ISelectable> selected=new LinkedList<>();
  MapCircle.stream(actionPosition,SELECT_BY_TYPE_RADIUS).filterBounds(grid.getWidth(),grid.getHeight()).forEach((x,y) -> {
    final IGuiMovable movable=grid.getMovable(x,y);
    if (movable != null && selectableTypes.contains(movable.getMovableType()) && selectedPlayerId == movable.getPlayerId()) {
      selected.add(movable);
    }
  }
);
  setSelection(new SelectionSet(selected));
}"
55676,"@Override public void action(IAction action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str""+ MatchConstants.clock().getTime());
  }
switch (action.getActionType()) {
case BUILD:
    this.setSelection(new SelectionSet());
  final BuildAction buildAction=(BuildAction)action;
EBuildingType buildingType=buildAction.getBuildingType();
final ShortPoint2D pos2=grid.getConstructablePosition(buildAction.getPosition(),buildingType,playerId,InputSettings.USE_NEIGHBOR_POSITIONS_FOR_CONSTRUCTION);
if (pos2 != null) {
scheduleTask(new ConstructBuildingTask(EGuiAction.BUILD,playerId,pos2,buildingType));
}
System.out.println(""String_Node_Str"" + buildingType);
break;
case SHOW_CONSTRUCTION_MARK:
{
buildingType=((ShowConstructionMarksAction)action).getBuildingType();
constructionMarksCalculator.setBuildingType(buildingType);
break;
}
case DEBUG_ACTION:
for (final ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
clock.invertPausing();
break;
case SPEED_SET_PAUSE:
clock.setPausing(true);
break;
case SPEED_UNSET_PAUSE:
clock.setPausing(false);
break;
case SPEED_SLOW:
if (!multiplayer) {
clock.setGameSpeed(0.5f);
}
break;
case SPEED_FAST:
if (!multiplayer) {
clock.setGameSpeed(2.0f);
}
break;
case SPEED_FASTER:
if (!multiplayer) {
clock.multiplyGameSpeed(1.2f);
}
break;
case SPEED_SLOWER:
if (!multiplayer) {
clock.multiplyGameSpeed(1 / 1.2f);
}
break;
case SPEED_NORMAL:
if (!multiplayer) {
clock.setGameSpeed(1.0f);
}
break;
case FAST_FORWARD:
if (!multiplayer) {
clock.fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((PointAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case DESELECT:
deselect();
break;
case SELECT_POINT_TYPE:
selectPointType((PointAction)action);
break;
case MOVE_TO:
{
final PointAction moveToAction=(PointAction)action;
if (currentSelection.getSelectionType() == ESelectionType.BUILDING && currentSelection.getSize() == 1) {
setBuildingWorkArea(moveToAction.getPosition());
}
 else {
moveTo(moveToAction.getPosition());
}
break;
}
case SHOW_MESSAGE:
{
break;
}
case SET_WORK_AREA:
setBuildingWorkArea(((PointAction)action).getPosition());
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
if (MatchConstants.ENABLE_FOG_OF_WAR_DISABLING) {
grid.toggleFogOfWar();
}
break;
case SAVE:
taskScheduler.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE,playerId));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority(((SetBuildingPriorityAction)action).getNewPriority());
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
final SetMaterialDistributionSettingsAction a=(SetMaterialDistributionSettingsAction)action;
taskScheduler.scheduleTask(new SetMaterialDistributionSettingsGuiTask(playerId,a.getManagerPosition(),a.getMaterialType(),a.getProbabilities()));
break;
}
case SET_MATERIAL_PRIORITIES:
{
final SetMaterialPrioritiesAction a=(SetMaterialPrioritiesAction)action;
taskScheduler.scheduleTask(new SetMaterialPrioritiesGuiTask(playerId,a.getPosition(),a.getMaterialTypeForPriority()));
break;
}
case SET_MATERIAL_STOCK_ACCEPTED:
{
final SetAcceptedStockMaterialAction a=(SetAcceptedStockMaterialAction)action;
taskScheduler.scheduleTask(new SetAcceptedStockMaterialGuiTask(playerId,a.getPosition(),a.getMaterial(),a.shouldAccept(),a.isLocalSetting()));
break;
}
case SET_MATERIAL_PRODUCTION:
{
final SetMaterialProductionAction a=(SetMaterialProductionAction)action;
taskScheduler.scheduleTask(new SetMaterialProductionGuiTask(playerId,a.getPosition(),a.getMaterialType(),a.getProductionType(),a.getRatio()));
break;
}
case NEXT_OF_TYPE:
selectNextOfType();
break;
case UPGRADE_SOLDIERS:
{
final SoldierAction a=(SoldierAction)action;
taskScheduler.scheduleTask(new UpgradeSoldiersGuiTask(playerId,a.getSoldierType()));
break;
}
case CHANGE_TRADING_REQUEST:
{
final ISelectable selected=currentSelection.getSingle();
if (selected instanceof Building) {
final ChangeTradingRequestAction a=(ChangeTradingRequestAction)action;
scheduleTask(new ChangeTradingRequestGuiTask(EGuiAction.CHANGE_TRADING,playerId,((Building)selected).getPos(),a.getMaterial(),a.getAmount(),a.isRelative()));
}
break;
}
case SET_TRADING_WAYPOINT:
{
final ISelectable selected=currentSelection.getSingle();
if (selected instanceof Building) {
final SetTradingWaypointAction a=(SetTradingWaypointAction)action;
scheduleTask(new SetTradingWaypointGuiTask(EGuiAction.SET_TRADING_WAYPOINT,playerId,((Building)selected).getPos(),a.getWaypointType(),a.getPosition()));
}
}
case SOLDIERS_ALL:
requestSoldiers(EChangeTowerSoldierTaskType.FULL,null);
break;
case SOLDIERS_ONE:
requestSoldiers(EChangeTowerSoldierTaskType.ONE,null);
break;
case SOLDIERS_LESS:
requestSoldiers(EChangeTowerSoldierTaskType.LESS,((SoldierAction)action).getSoldierType());
break;
case SOLDIERS_MORE:
requestSoldiers(EChangeTowerSoldierTaskType.MORE,((SoldierAction)action).getSoldierType());
break;
case ABORT:
break;
case EXIT:
gameStoppable.stopGame();
break;
default :
System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}","@Override public void action(IAction action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str""+ MatchConstants.clock().getTime());
  }
switch (action.getActionType()) {
case BUILD:
    handleBuildAction((BuildAction)action);
  break;
case SHOW_CONSTRUCTION_MARK:
constructionMarksCalculator.setBuildingType(((ShowConstructionMarksAction)action).getBuildingType());
break;
case DEBUG_ACTION:
for (final ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
clock.invertPausing();
break;
case SPEED_SET_PAUSE:
clock.setPausing(true);
break;
case SPEED_UNSET_PAUSE:
clock.setPausing(false);
break;
case SPEED_SLOW:
if (!multiplayer) {
clock.setGameSpeed(0.5f);
}
break;
case SPEED_FAST:
if (!multiplayer) {
clock.setGameSpeed(5.0f);
}
break;
case SPEED_FASTER:
if (!multiplayer) {
clock.multiplyGameSpeed(1.2f);
}
break;
case SPEED_SLOWER:
if (!multiplayer) {
clock.multiplyGameSpeed(1 / 1.2f);
}
break;
case SPEED_NORMAL:
if (!multiplayer) {
clock.setGameSpeed(1.0f);
}
break;
case FAST_FORWARD:
if (!multiplayer) {
clock.fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((PointAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case DESELECT:
deselect();
break;
case SELECT_POINT_TYPE:
selectPointType((PointAction)action);
break;
case MOVE_TO:
{
final PointAction moveToAction=(PointAction)action;
if (currentSelection.getSelectionType() == ESelectionType.BUILDING && currentSelection.getSize() == 1) {
setBuildingWorkArea(moveToAction.getPosition());
}
 else {
moveTo(moveToAction.getPosition());
}
break;
}
case SHOW_MESSAGE:
{
break;
}
case SET_WORK_AREA:
setBuildingWorkArea(((PointAction)action).getPosition());
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
if (MatchConstants.ENABLE_FOG_OF_WAR_DISABLING) {
grid.toggleFogOfWar();
}
break;
case SAVE:
taskScheduler.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE,playerId));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority(((SetBuildingPriorityAction)action).getNewPriority());
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
final SetMaterialDistributionSettingsAction a=(SetMaterialDistributionSettingsAction)action;
taskScheduler.scheduleTask(new SetMaterialDistributionSettingsGuiTask(playerId,a.getManagerPosition(),a.getMaterialType(),a.getProbabilities()));
break;
}
case SET_MATERIAL_PRIORITIES:
{
final SetMaterialPrioritiesAction a=(SetMaterialPrioritiesAction)action;
taskScheduler.scheduleTask(new SetMaterialPrioritiesGuiTask(playerId,a.getPosition(),a.getMaterialTypeForPriority()));
break;
}
case SET_MATERIAL_STOCK_ACCEPTED:
{
final SetAcceptedStockMaterialAction a=(SetAcceptedStockMaterialAction)action;
taskScheduler.scheduleTask(new SetAcceptedStockMaterialGuiTask(playerId,a.getPosition(),a.getMaterial(),a.shouldAccept(),a.isLocalSetting()));
break;
}
case SET_MATERIAL_PRODUCTION:
{
final SetMaterialProductionAction a=(SetMaterialProductionAction)action;
taskScheduler.scheduleTask(new SetMaterialProductionGuiTask(playerId,a.getPosition(),a.getMaterialType(),a.getProductionType(),a.getRatio()));
break;
}
case NEXT_OF_TYPE:
selectNextOfType();
break;
case UPGRADE_SOLDIERS:
{
final SoldierAction a=(SoldierAction)action;
taskScheduler.scheduleTask(new UpgradeSoldiersGuiTask(playerId,a.getSoldierType()));
break;
}
case CHANGE_TRADING_REQUEST:
{
final ISelectable selected=currentSelection.getSingle();
if (selected instanceof Building) {
final ChangeTradingRequestAction a=(ChangeTradingRequestAction)action;
scheduleTask(new ChangeTradingRequestGuiTask(EGuiAction.CHANGE_TRADING,playerId,((Building)selected).getPos(),a.getMaterial(),a.getAmount(),a.isRelative()));
}
break;
}
case SET_TRADING_WAYPOINT:
{
final ISelectable selected=currentSelection.getSingle();
if (selected instanceof Building) {
final SetTradingWaypointAction a=(SetTradingWaypointAction)action;
scheduleTask(new SetTradingWaypointGuiTask(EGuiAction.SET_TRADING_WAYPOINT,playerId,((Building)selected).getPos(),a.getWaypointType(),a.getPosition()));
}
}
case SOLDIERS_ALL:
requestSoldiers(EChangeTowerSoldierTaskType.FULL,null);
break;
case SOLDIERS_ONE:
requestSoldiers(EChangeTowerSoldierTaskType.ONE,null);
break;
case SOLDIERS_LESS:
requestSoldiers(EChangeTowerSoldierTaskType.LESS,((SoldierAction)action).getSoldierType());
break;
case SOLDIERS_MORE:
requestSoldiers(EChangeTowerSoldierTaskType.MORE,((SoldierAction)action).getSoldierType());
break;
case ABORT:
break;
case EXIT:
gameStoppable.stopGame();
break;
default :
System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}"
55677,"private final static List<Integer> getIDsOfIterable(Iterable<? extends ISelectable> iterable){
  final List<Integer> selectedIds=new LinkedList<>();
  for (  final ISelectable curr : iterable) {
    if (curr instanceof IIDable) {
      selectedIds.add(((IIDable)curr).getID());
    }
  }
  return selectedIds;
}","private static List<Integer> getIDsOfIterable(Iterable<? extends ISelectable> iterable){
  final List<Integer> selectedIds=new LinkedList<>();
  for (  final ISelectable curr : iterable) {
    if (curr instanceof IIDable) {
      selectedIds.add(((IIDable)curr).getID());
    }
  }
  return selectedIds;
}"
55678,"/** 
 * Gets a position where the building can be constructed some points around pos.
 * @param position THe position
 * @param type The type of the building
 * @param player The player that wants to construct the building.
 * @param useNeighbors If this is true, not only the given position is checked, if it can be used to construct a building, but also the neighbors.<br> If this is false, only the given position will be checked.
 * @return <code>null</code> if no position was found, the position otherwise.
 */
ShortPoint2D getConstructablePosition(ShortPoint2D position,EBuildingType type,byte player,boolean useNeighbors);","/** 
 * Gets a position where the building can be constructed some points around pos.
 * @param position THe position
 * @param type The type of the building
 * @param player The player that wants to construct the building.
 * @return <code>null</code> if no position was found, the position otherwise.
 */
Optional<ShortPoint2D> getConstructablePosition(ShortPoint2D position,EBuildingType type,byte player);"
55679,"@Override public final ShortPoint2D getConstructablePosition(ShortPoint2D pos,EBuildingType type,byte playerId,boolean useNeighbors){
  if (constructionMarksGrid.canConstructAt(pos.x,pos.y,type,playerId)) {
    return pos;
  }
 else   if (useNeighbors) {
    for (    ShortPoint2D neighbour : new MapNeighboursArea(pos)) {
      if (constructionMarksGrid.canConstructAt(neighbour.x,neighbour.y,type,playerId)) {
        return neighbour;
      }
    }
    return null;
  }
 else {
    return null;
  }
}","@Override public final Optional<ShortPoint2D> getConstructablePosition(ShortPoint2D pos,EBuildingType type,byte playerId){
  return MapCircle.stream(pos,Constants.BUILDING_PLACEMENT_MAX_SEARCH_RADIUS).filterBounds(width,height).filter((x,y) -> constructionMarksGrid.canConstructAt(x,y,type,playerId)).min((x,y) -> ShortPoint2D.getOnGridDist(pos.x,pos.y,x,y));
}"
55680,"@Override public boolean canConstructAt(short x,short y,EBuildingType type,byte playerId){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public boolean canConstructAt(int x,int y,EBuildingType type,byte playerId){
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
55681,"private void onPlayersChanges(ChangingList<? extends IMultiplayerPlayer> changingPlayers,IJoinPhaseMultiplayerGameConnector joinMultiPlayerMap){
  SwingUtilities.invokeLater(() -> {
    List<? extends IMultiplayerPlayer> players=changingPlayers.getItems();
    String myId=SettingsManager.getInstance().get(SettingsManager.SETTING_UUID);
    for (int i=0; i < players.size(); i++) {
      PlayerSlot playerSlot=playerSlots.get(i);
      IMultiplayerPlayer player=players.get(i);
      playerSlot.setPlayerName(player.getName());
      playerSlot.setReady(player.isReady());
      if (player.getId().equals(myId)) {
        playerSlot.setReadyButtonEnabled(true);
        playerSlot.informGameAboutReady(joinMultiPlayerMap);
      }
 else {
        playerSlot.setReadyButtonEnabled(false);
      }
    }
    for (int i=players.size(); i < playerSlots.size(); i++) {
      playerSlots.get(i).setPlayerType(EPlayerType.AI_VERY_HARD,false);
    }
    setCancelButtonActionListener(e -> {
      joinMultiPlayerMap.abort();
      settlersFrame.showMainMenu();
    }
);
  }
);
}","private void onPlayersChanges(ChangingList<? extends IMultiplayerPlayer> changingPlayers,IJoinPhaseMultiplayerGameConnector joinMultiPlayerMap){
  SwingUtilities.invokeLater(() -> {
    List<? extends IMultiplayerPlayer> players=changingPlayers.getItems();
    String myId=SettingsManager.getInstance().get(SettingsManager.SETTING_UUID);
    for (int i=0; i < players.size(); i++) {
      PlayerSlot playerSlot=playerSlots.get(i);
      IMultiplayerPlayer player=players.get(i);
      playerSlot.setPlayerName(player.getName());
      playerSlot.setReady(player.isReady());
      playerSlot.setPlayerType(EPlayerType.HUMAN,false);
      if (player.getId().equals(myId)) {
        playerSlot.setReadyButtonEnabled(true);
        playerSlot.informGameAboutReady(joinMultiPlayerMap);
      }
 else {
        playerSlot.setReadyButtonEnabled(false);
      }
    }
    for (int i=players.size(); i < playerSlots.size(); i++) {
      playerSlots.get(i).setPlayerType(EPlayerType.AI_VERY_HARD,false);
    }
    setCancelButtonActionListener(e -> {
      joinMultiPlayerMap.abort();
      settlersFrame.showMainMenu();
    }
);
  }
);
}"
55682,"@Override public void drawWorkAreaCircle(ShortPoint2D buildingPosition,ShortPoint2D workAreaCenter,short radius,boolean draw){
  short buildingPartition=partitionsGrid.getPartitionIdAt(buildingPosition.x,buildingPosition.y);
  final int numCircles=4;
  for (int circle=1; circle <= 4; circle++) {
    float circleRadius=radius * circle / (float)numCircles;
    float mapObjectProgress=(circle - 1) / (float)(numCircles - 1);
    MapCircle.streamBorder(workAreaCenter.x,workAreaCenter.y,circleRadius).forEach((x,y) -> addOrRemoveMarkObject(buildingPartition,draw,new ShortPoint2D(x,y),mapObjectProgress));
  }
}","@Override public void drawWorkAreaCircle(ShortPoint2D buildingPosition,ShortPoint2D workAreaCenter,short radius,boolean draw){
  short buildingPartition=partitionsGrid.getPartitionIdAt(buildingPosition.x,buildingPosition.y);
  final int numCircles=4;
  for (int circle=1; circle <= 4; circle++) {
    float circleRadius=radius * circle / (float)numCircles;
    float mapObjectProgress=(circle - 1) / (float)(numCircles - 1);
    MapCircle.streamBorder(workAreaCenter.x,workAreaCenter.y,circleRadius).filterBounds(width,height).forEach((x,y) -> addOrRemoveMarkObject(buildingPartition,draw,x,y,mapObjectProgress));
  }
}"
55683,"private void addOrRemoveMarkObject(short buildingPartition,boolean draw,ShortPoint2D pos,float progress){
  if (draw) {
    if (partitionsGrid.getPartitionIdAt(pos.x,pos.y) == buildingPartition) {
      mapObjectsManager.addBuildingWorkAreaObject(pos.x,pos.y,progress);
    }
  }
 else {
    mapObjectsManager.removeMapObjectType(pos.x,pos.y,EMapObjectType.WORKAREA_MARK);
  }
}","private void addOrRemoveMarkObject(short buildingPartition,boolean draw,int x,int y,float progress){
  if (draw) {
    if (partitionsGrid.getPartitionIdAt(x,y) == buildingPartition) {
      mapObjectsManager.addBuildingWorkAreaObject(x,y,progress);
    }
  }
 else {
    mapObjectsManager.removeMapObjectType(x,y,EMapObjectType.WORKAREA_MARK);
  }
}"
55684,"public void onTouchEvent(MotionEvent e){
  boolean isPan=panStarted() || e.getPointerCount() > 1 || (e.getSource() & InputDevice.SOURCE_CLASS_MASK) == InputDevice.SOURCE_CLASS_TRACKBALL;
  if (isPan) {
    if (drawStarted()) {
      abortDraw();
    }
    if (!panStarted()) {
      endedPansX=0;
      endedPansY=0;
      panStart=getStartedPanAverage();
      startPan(panStart);
      zoomStartDistance=getPointerDistance(e);
      lastZoomFactor=1;
    }
    if (e.getAction() == MotionEvent.ACTION_POINTER_DOWN) {
      int index=getPointerIndex(e);
      Integer id=Integer.valueOf(e.getPointerId(index));
      UIPoint point=new UIPoint(e.getX(index),e.getY(index));
      panPointerStarts.put(id,point);
    }
 else     if (e.getAction() == MotionEvent.ACTION_POINTER_UP) {
      int index=getPointerIndex(e);
      Integer id=Integer.valueOf(e.getPointerId(index));
      UIPoint start=panPointerStarts.remove(id);
      if (start != null) {
        endedPansX+=(e.getX(index) - start.getX()) / e.getPointerCount();
        endedPansY-=(e.getY(index) - start.getY()) / e.getPointerCount();
      }
    }
 else {
      float factor=computeZoomFactor(e);
      if (e.getAction() == MotionEvent.ACTION_MOVE) {
        UIPoint point=computePanPoint(e);
        updatePanPosition(point);
        if (e.getPointerCount() > 1 && (factor < 1 / ZOOMSTART || factor > ZOOMSTART) && getPointerDistance(e) > ZOOM_MIN_POINTERDISTANCE) {
          doZoom=true;
          startZoom();
        }
        if (doZoom) {
          updateZoomFactor(factor);
        }
      }
 else       if (e.getAction() == MotionEvent.ACTION_UP) {
        endPan(computePanPoint(e));
        if (doZoom) {
          endZoomEvent(factor);
        }
      }
    }
  }
 else {
    if (e.getAction() == MotionEvent.ACTION_DOWN) {
      startDraw(convertToLocal(e,0));
      panPointerStarts.clear();
      for (int i=0; i < e.getPointerCount(); i++) {
        Integer index=e.getPointerId(i);
        panPointerStarts.put(index,new UIPoint(e.getX(i),e.getY(i)));
      }
    }
 else     if (e.getAction() == MotionEvent.ACTION_MOVE) {
      updateDrawPosition(convertToLocal(e,0));
    }
 else     if (e.getAction() == MotionEvent.ACTION_UP) {
      endDraw(convertToLocal(e,0));
    }
  }
}","public void onTouchEvent(MotionEvent e){
  boolean isPan=panStarted() || e.getPointerCount() > 1 || (e.getSource() & InputDevice.SOURCE_CLASS_MASK) == InputDevice.SOURCE_CLASS_TRACKBALL;
  if (isPan) {
    if (drawStarted()) {
      abortDraw();
    }
    if (!panStarted()) {
      endedPansX=0;
      endedPansY=0;
      panStart=getStartedPanAverage();
      startPan(panStart);
      zoomStartDistance=getPointerDistance(e);
      lastZoomFactor=1;
    }
    if (e.getAction() == MotionEvent.ACTION_POINTER_DOWN) {
      int index=getPointerIndex(e);
      Integer id=Integer.valueOf(e.getPointerId(index));
      UIPoint point=new UIPoint(e.getX(index),e.getY(index));
      panPointerStarts.put(id,point);
    }
 else     if (e.getAction() == MotionEvent.ACTION_POINTER_UP) {
      int index=getPointerIndex(e);
      Integer id=Integer.valueOf(e.getPointerId(index));
      UIPoint start=panPointerStarts.remove(id);
      if (start != null) {
        endedPansX+=(e.getX(index) - start.getX()) / e.getPointerCount();
        endedPansY-=(e.getY(index) - start.getY()) / e.getPointerCount();
      }
    }
 else {
      float factor=computeZoomFactor(e);
      if (e.getAction() == MotionEvent.ACTION_MOVE) {
        UIPoint point=computePanPoint(e);
        updatePanPosition(point);
        if (e.getPointerCount() > 1 && (factor < 1 / ZOOMSTART || factor > ZOOMSTART) && getPointerDistance(e) > ZOOM_MIN_POINTERDISTANCE) {
          doZoom=true;
          startZoom();
        }
        if (doZoom) {
          updateZoomFactor(factor);
        }
      }
 else       if (e.getAction() == MotionEvent.ACTION_UP) {
        endPan(computePanPoint(e));
        if (doZoom) {
          endZoomEvent(factor,null);
        }
      }
    }
  }
 else {
    if (e.getAction() == MotionEvent.ACTION_DOWN) {
      startDraw(convertToLocal(e,0));
      panPointerStarts.clear();
      for (int i=0; i < e.getPointerCount(); i++) {
        Integer index=e.getPointerId(i);
        panPointerStarts.put(index,new UIPoint(e.getX(i),e.getY(i)));
      }
    }
 else     if (e.getAction() == MotionEvent.ACTION_MOVE) {
      updateDrawPosition(convertToLocal(e,0));
    }
 else     if (e.getAction() == MotionEvent.ACTION_UP) {
      endDraw(convertToLocal(e,0));
    }
  }
}"
55685,"@Background void positionSelected(int position){
  String item=getItem(position);
  if (item != null) {
    try {
      File newDirectory=new File(currentDirectory,item).getCanonicalFile();
      if (newDirectory.exists()) {
        currentDirectory=newDirectory;
        updateList();
      }
    }
 catch (    IOException e) {
    }
  }
}","void positionSelected(int position){
  String item=getItem(position);
  if (item != null) {
    try {
      File newDirectory=new File(currentDirectory,item).getCanonicalFile();
      if (newDirectory.exists()) {
        currentDirectory=newDirectory;
        updateList();
      }
    }
 catch (    IOException e) {
    }
  }
}"
55686,"void offer(ShortPoint2D position,EMaterialType materialType,EOfferPriority priority);","void offer(ShortPoint2D position,EMaterialType materialType,EOfferPriority priority,IOfferEmptiedListener offerListener);"
55687,"protected void deliveryFulFilled(EMaterialType materialType){
  grid.offer(position,materialType,EOfferPriority.LOWEST);
}","protected void deliveryFulFilled(EMaterialType materialType){
  grid.offer(position,materialType,EOfferPriority.LOWEST,this);
}"
55688,"private void checkIfCurrentMaterialShouldBeReset(){
  if (currentMaterialType != null && materialRequests[currentMaterialType.ordinal].getInDelivery() <= 0 && getStackSize() == 0) {
    sharedData.unregisterHandlingStack(currentMaterialType,this);
    currentMaterialType=null;
  }
}","protected void checkIfCurrentMaterialShouldBeReset(){
  if (currentMaterialType != null && materialRequests[currentMaterialType.ordinal].getInDelivery() <= 0 && getStackSize() == 0) {
    sharedData.unregisterHandlingStack(currentMaterialType,this);
    currentMaterialType=null;
  }
}"
55689,"@Override public void offer(ShortPoint2D position,EMaterialType materialType,EOfferPriority priority){
  partitionsGrid.getPartitionAt(position.x,position.y).addOffer(position,materialType,priority);
}","@Override public void offer(ShortPoint2D position,EMaterialType materialType,EOfferPriority priority,IOfferEmptiedListener offerListener){
  partitionsGrid.getPartitionAt(position.x,position.y).addOffer(position,materialType,priority,offerListener);
}"
55690,"public void addOffer(ShortPoint2D position,EMaterialType materialType,EOfferPriority offerPriority){
  materialOffers.addOffer(position,materialType,offerPriority);
}","public void addOffer(ShortPoint2D position,EMaterialType materialType,EOfferPriority offerPriority,IOfferEmptiedListener offerListener){
  materialOffers.addOffer(position,materialType,offerPriority,offerListener);
}"
55691,"/** 
 * Insert an offered material at the given position.
 * @param position The position the offered material is located.
 * @param material The material that is offered at the given position.
 */
public void addOffer(ShortPoint2D position,EMaterialType material,EOfferPriority offerPriority){
  PrioritizedPositionableList<EOfferPriority,MaterialOffer> list=offersLists[material.ordinal];
  MaterialOffer existingOffer=list.getObjectAt(position,offerPriority);
  if (existingOffer != null) {
    existingOffer.incrementAmount();
  }
 else {
    list.insert(new MaterialOffer(position,material,materialCounts,offerPriority,(byte)1));
  }
}","/** 
 * Insert an offered material at the given position.
 * @param position The position the offered material is located.
 * @param material The material that is offered at the given position.
 * @param offerPriority The priority of the offer
 * @param offerListener A listener that will be set to the offer
 */
public void addOffer(ShortPoint2D position,EMaterialType material,EOfferPriority offerPriority,IOfferEmptiedListener offerListener){
  PrioritizedPositionableList<EOfferPriority,MaterialOffer> list=offersLists[material.ordinal];
  MaterialOffer existingOffer=list.getObjectAt(position,offerPriority);
  if (existingOffer != null && existingOffer instanceof ListenableMaterialOffer) {
    existingOffer.incrementAmount();
  }
 else {
    list.insert(new ListenableMaterialOffer(position,material,materialCounts,offerPriority,(byte)1,offerListener));
  }
}"
55692,"/** 
 * Calculates the partitions. <br> The results can be accessed with the supplied getter methods.
 */
public void calculatePartitions(){
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      int index=x + y * width;
      if (containing.get(index)) {
        if (blockingProvider.isBlocked(minX + x,minY + y)) {
          partitionsGrid[index]=BLOCKED_PARTITION;
          continue;
        }
        int westX=x + neighborX[0];
        int westY=y + neighborY[0];
        int northWestX=x + neighborX[1];
        int northWestY=y + neighborY[1];
        int northEastX=x + neighborX[2];
        int northEastY=y + neighborY[2];
        int partition=-1;
        int westPartition=-1;
        int northEastPartition=-1;
        if (containing.get(westX + westY * width)) {
          short currPartition=partitionsGrid[westX + westY * width];
          if (currPartition != BLOCKED_PARTITION) {
            westPartition=currPartition;
            partition=currPartition;
          }
        }
        if (containing.get(northWestX + northWestY * width)) {
          short currPartition=partitionsGrid[northWestX + northWestY * width];
          if (currPartition != BLOCKED_PARTITION) {
            partition=currPartition;
          }
        }
        if (containing.get(northEastX + northEastY * width)) {
          short currPartition=partitionsGrid[northEastX + northEastY * width];
          if (currPartition != BLOCKED_PARTITION) {
            northEastPartition=currPartition;
            partition=currPartition;
          }
        }
        if (westPartition != -1 && northEastPartition != -1 && partitions[westPartition] != partitions[northEastPartition]) {
          short newPartition=(short)Math.min(partitions[westPartition],partitions[northEastPartition]);
          partitions[westPartition]=newPartition;
          partitions[northEastPartition]=newPartition;
          partitionsGrid[index]=newPartition;
        }
 else         if (partition != -1) {
          partitionsGrid[index]=partitions[partition];
        }
 else {
          partitionsGrid[index]=createNewPartition(y,x);
        }
      }
    }
  }
  normalizePartitions();
}","/** 
 * Calculates the partitions. <br> The results can be accessed with the supplied getter methods.
 */
public void calculatePartitions(){
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      int index=x + y * width;
      if (containing.get(index)) {
        if (blockingProvider.isBlocked(minX + x,minY + y)) {
          partitionsGrid[index]=BLOCKED_PARTITION;
          continue;
        }
        int westX=x + neighborX[0];
        int westY=y + neighborY[0];
        int northWestX=x + neighborX[1];
        int northWestY=y + neighborY[1];
        int northEastX=x + neighborX[2];
        int northEastY=y + neighborY[2];
        int partition=-1;
        int westPartition=-1;
        int northEastPartition=-1;
        if (containing.get(westX + westY * width)) {
          short currPartition=partitions[partitionsGrid[westX + westY * width]];
          if (currPartition != BLOCKED_PARTITION) {
            westPartition=currPartition;
            partition=currPartition;
          }
        }
        if (containing.get(northWestX + northWestY * width)) {
          short currPartition=partitions[partitionsGrid[northWestX + northWestY * width]];
          if (currPartition != BLOCKED_PARTITION) {
            partition=currPartition;
          }
        }
        if (containing.get(northEastX + northEastY * width)) {
          short currPartition=partitions[partitionsGrid[northEastX + northEastY * width]];
          if (currPartition != BLOCKED_PARTITION) {
            northEastPartition=currPartition;
            partition=currPartition;
          }
        }
        if (westPartition != -1 && northEastPartition != -1 && partitions[westPartition] != partitions[northEastPartition]) {
          short newPartition=(short)Math.min(partitions[westPartition],partitions[northEastPartition]);
          partitions[westPartition]=newPartition;
          partitions[northEastPartition]=newPartition;
          partitionsGrid[index]=newPartition;
        }
 else         if (partition != -1) {
          partitionsGrid[index]=partitions[partition];
        }
 else {
          partitionsGrid[index]=createNewPartition(y,x);
        }
      }
    }
  }
  normalizePartitions();
}"
55693,"/** 
 * Creates a new   {@link PartitionCalculatorAlgorithm}. The given   {@link BitSet} defines the positions that need to be in the partitions and theones that mustn't.
 * @param minX The x offset of the  {@link BitSet}.
 * @param minY The y offset of the  {@link BitSet}.
 * @param width The width of the grid defined by the  {@link BitSet}.
 * @param height The height of the grid defined by the  {@link BitSet}.
 * @param containing The  {@link BitSet} defining the positions in the partitions and the ones not. <br>NOTE: The  {@link BitSet} must be indexed with x + y * width
 * @param blockingProvider Provides the information if a position is blocked or not.
 */
public PartitionCalculatorAlgorithm(int minX,int minY,int width,int height,BitSet containing,IBlockingProvider blockingProvider){
  this.minX=minX;
  this.minY=minY;
  this.width=width;
  this.height=height;
  this.containing=containing;
  this.blockingProvider=blockingProvider;
  this.partitionsGrid=new short[width * height];
}","/** 
 * Creates a new   {@link PartitionCalculatorAlgorithm}. The given   {@link BitSet} defines the positions that need to be in the partitions and theones that mustn't.
 * @param minX The x offset of the  {@link BitSet}.
 * @param minY The y offset of the  {@link BitSet}.
 * @param width The width of the grid defined by the  {@link BitSet}.
 * @param height The height of the grid defined by the  {@link BitSet}.
 * @param containing The  {@link BitSet} defining the positions in the partitions and the ones not. <br>NOTE: The  {@link BitSet} must be indexed with x + y * width
 * @param blockingProvider Provides the information if a position is blocked or not.
 */
public PartitionCalculatorAlgorithm(int minX,int minY,int width,int height,BitSet containing,IBlockingProvider blockingProvider){
  this.minX=minX;
  this.minY=minY;
  this.width=width;
  this.height=height;
  this.containing=containing;
  this.blockingProvider=blockingProvider;
  this.partitionsGrid=new short[width * height];
  this.partitions[BLOCKED_PARTITION]=BLOCKED_PARTITION;
}"
55694,"private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (workerCreationRequest != null) {
    workerRequester.workerCreationRequestFailed(workerCreationRequest);
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case DROPPING:
if (request != null) {
boolean offerMaterial=droppingMaterial();
super.setMaterial(EMaterialType.NO_MATERIAL);
super.getGrid().dropMaterial(super.getPos(),materialType,offerMaterial,false);
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(workerCreationRequest);
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getGrid().dropMaterial(movable.getPos(),materialType,true,false);
}
offer=null;
request=null;
materialType=null;
workerCreationRequest=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportJobless();
}
}","private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
case TAKING:
    if (super.movable.getMaterial() == EMaterialType.NO_MATERIAL) {
      reoffer();
    }
  if (workerCreationRequest != null) {
    workerRequester.workerCreationRequestFailed(workerCreationRequest);
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case DROPPING:
if (request != null) {
boolean offerMaterial=droppingMaterial();
super.setMaterial(EMaterialType.NO_MATERIAL);
super.getGrid().dropMaterial(super.getPos(),materialType,offerMaterial,false);
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(workerCreationRequest);
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getGrid().dropMaterial(movable.getPos(),materialType,true,false);
}
offer=null;
request=null;
materialType=null;
workerCreationRequest=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportJobless();
}
}"
55695,"public CoordinateStream stream(){
  return new CoordinateStream(){
    @Override public boolean iterate(    IBooleanCoordinateFunction function){
      int width=base.getWidth();
      int lastRelativeYWithPoint=0;
      for (int relativeY=0; relativeY < MIN_SEARCH_LINES || relativeY - lastRelativeYWithPoint <= 2; relativeY++) {
        int lineStartX=base.getLineStartX(relativeY);
        for (int relativeX=0; relativeX < width; relativeX++) {
          int x=lineStartX + relativeX;
          int y=base.getLineY(relativeY);
          if (contains(x,y)) {
            lastRelativeYWithPoint=relativeY;
            if (!function.apply(x,y)) {
              return false;
            }
          }
        }
      }
      return true;
    }
  }
;
}","public CoordinateStream stream(){
  return new CoordinateStream(){
    @Override public boolean iterate(    IBooleanCoordinateFunction function){
      int width=base.getWidth();
      int lastRelativeYWithPoint=0;
      for (int relativeY=0; relativeY < MIN_SEARCH_LINES || relativeY - lastRelativeYWithPoint <= 2; relativeY++) {
        int lineStartX=base.getLineStartX(relativeY);
        for (int relativeX=0; relativeX < width; relativeX++) {
          int x=lineStartX + relativeX;
          int y=base.getLineY(relativeY);
          if (HeightedMapRectangle.this.contains(x,y)) {
            lastRelativeYWithPoint=relativeY;
            if (!function.apply(x,y)) {
              return false;
            }
          }
        }
      }
      return true;
    }
  }
;
}"
55696,"@Override public boolean iterate(IBooleanCoordinateFunction function){
  int width=base.getWidth();
  int lastRelativeYWithPoint=0;
  for (int relativeY=0; relativeY < MIN_SEARCH_LINES || relativeY - lastRelativeYWithPoint <= 2; relativeY++) {
    int lineStartX=base.getLineStartX(relativeY);
    for (int relativeX=0; relativeX < width; relativeX++) {
      int x=lineStartX + relativeX;
      int y=base.getLineY(relativeY);
      if (contains(x,y)) {
        lastRelativeYWithPoint=relativeY;
        if (!function.apply(x,y)) {
          return false;
        }
      }
    }
  }
  return true;
}","@Override public boolean iterate(IBooleanCoordinateFunction function){
  int width=base.getWidth();
  int lastRelativeYWithPoint=0;
  for (int relativeY=0; relativeY < MIN_SEARCH_LINES || relativeY - lastRelativeYWithPoint <= 2; relativeY++) {
    int lineStartX=base.getLineStartX(relativeY);
    for (int relativeX=0; relativeX < width; relativeX++) {
      int x=lineStartX + relativeX;
      int y=base.getLineY(relativeY);
      if (HeightedMapRectangle.this.contains(x,y)) {
        lastRelativeYWithPoint=relativeY;
        if (!function.apply(x,y)) {
          return false;
        }
      }
    }
  }
  return true;
}"
55697,"@Override public void releaseRequests(){
  for (  RequestOfMultiRequestStack materialRequest : materialRequests) {
    materialRequest.updatePriority(EPriority.STOPPED);
    grid.updateOfferPriorities(position,materialRequest.materialType,EOfferPriority.OFFER_TO_ALL);
  }
  released=true;
}","@Override public void releaseRequests(){
  for (  RequestOfMultiRequestStack materialRequest : materialRequests) {
    materialRequest.updatePriority(EPriority.STOPPED);
  }
  if (currentMaterialType != null) {
    grid.updateOfferPriorities(position,currentMaterialType,EOfferPriority.OFFER_TO_ALL);
  }
  released=true;
}"
55698,"public short getStillNeededIfNoOthersHandleIt(EMaterialType materialType){
  Set<MultiRequestStack> stacksHandlingThisMaterial=handlingStacks[materialType.ordinal];
  for (  MultiRequestStack stack : stacksHandlingThisMaterial) {
    if (stack.canAcceptMoreDeliveries()) {
      return 0;
    }
  }
  return getStillNeeded(materialType);
}","public short getStillNeededIfNoOthersHandleIt(EMaterialType materialType){
  Set<MultiRequestStack> stacksHandlingThisMaterial=handlingStacks[materialType.ordinal];
  for (  MultiRequestStack stack : stacksHandlingThisMaterial) {
    if (stack.canAcceptMoreDeliveriesOf(materialType)) {
      return 0;
    }
  }
  return getStillNeeded(materialType);
}"
55699,"public void insert(P priority,T object){
  lists[priority.ordinal()].insert(object);
}","public void insert(T object){
  lists[object.getPriority().ordinal()].insert(object);
}"
55700,"public void updatePriorityAt(ShortPoint2D position,P newPriority){
  int newPriorityIndex=newPriority.ordinal();
  for (int i=0; i < lists.length; i++) {
    if (i != newPriorityIndex) {
      T foundObject=lists[i].removeObjectAt(position);
      if (foundObject != null) {
        lists[newPriorityIndex].insert(foundObject);
      }
    }
  }
}","public void updatePriorityAt(ShortPoint2D position,P newPriority){
  int newPriorityIndex=newPriority.ordinal();
  for (int i=0; i < lists.length; i++) {
    if (i != newPriorityIndex) {
      T foundObject=lists[i].removeObjectAt(position);
      if (foundObject != null) {
        foundObject.updatePriority(newPriority);
        lists[newPriorityIndex].insert(foundObject);
      }
    }
  }
}"
55701,"public void remove(T offer){
  for (int i=lists.length - 1; i >= 0; i--) {
    lists[i].remove(offer);
  }
}","public void remove(T offer){
  lists[offer.getPriority().ordinal()].remove(offer);
}"
55702,"public EOfferPriority getPriority(){
  return priority;
}","@Override public EOfferPriority getPriority(){
  return priority;
}"
55703,"/** 
 * @param materialType {@link EMaterialType} of the offer.
 * @param position     The position to be used for the search.
 * @return Returns an offer of the given {@link EMaterialType} that's close to the given position or <br>null if no offer for the given  {@link EMaterialType} exists.
 */
public MaterialOffer removeOfferCloseTo(EMaterialType materialType,EOfferPriority minimumIncludedPriority,ShortPoint2D position){
  PrioritizedPositionableList<EOfferPriority,MaterialOffer> offerSlot=offersLists[materialType.ordinal];
  MaterialOffer offer=offerSlot.getObjectCloseTo(position,minimumIncludedPriority);
  decrementOfferAmount(offerSlot,materialType,offer);
  return offer;
}","/** 
 * @param materialType {@link EMaterialType} of the offer.
 * @param position The position to be used for the search.
 * @return Returns an offer of the given {@link EMaterialType} that's close to the given position or <br>null if no offer for the given  {@link EMaterialType} exists.
 */
public MaterialOffer removeOfferCloseTo(EMaterialType materialType,EOfferPriority minimumIncludedPriority,ShortPoint2D position){
  PrioritizedPositionableList<EOfferPriority,MaterialOffer> offerSlot=offersLists[materialType.ordinal];
  MaterialOffer offer=offerSlot.getObjectCloseTo(position,minimumIncludedPriority);
  decrementOfferAmount(offerSlot,materialType,offer);
  return offer;
}"
55704,"/** 
 * Insert an offered material at the given position.
 * @param position The position the offered material is located.
 * @param material The material that is offered at the given position.
 */
public void addOffer(ShortPoint2D position,EMaterialType material,EOfferPriority offerPriority){
  PrioritizedPositionableList<EOfferPriority,MaterialOffer> list=offersLists[material.ordinal];
  MaterialOffer existingOffer=list.getObjectAt(position,offerPriority);
  if (existingOffer != null) {
    existingOffer.incAmount();
  }
 else {
    list.insert(offerPriority,new MaterialOffer(position,offerPriority,(byte)1));
  }
  numberOfOffers[material.ordinal]++;
  countListener.offersCountChanged(material,+1);
}","/** 
 * Insert an offered material at the given position.
 * @param position The position the offered material is located.
 * @param material The material that is offered at the given position.
 */
public void addOffer(ShortPoint2D position,EMaterialType material,EOfferPriority offerPriority){
  PrioritizedPositionableList<EOfferPriority,MaterialOffer> list=offersLists[material.ordinal];
  MaterialOffer existingOffer=list.getObjectAt(position,offerPriority);
  if (existingOffer != null) {
    existingOffer.incAmount();
  }
 else {
    list.insert(new MaterialOffer(position,offerPriority,(byte)1));
  }
  numberOfOffers[material.ordinal]++;
  countListener.offersCountChanged(material,+1);
}"
55705,"/** 
 * Checks if there are any offers for the given   {@link EMaterialType}.
 * @param materialType The {@link EMaterialType} to be checked.
 * @param minimumIncludedPriority The lowest priority to be included in
 * @return Returns true if there are no offers for the given {@link EMaterialType},<br> false otherwise.
 */
public boolean isEmpty(EMaterialType materialType,EOfferPriority minimumIncludedPriority){
  return offersLists[materialType.ordinal].isEmpty(minimumIncludedPriority);
}","/** 
 * Checks if there are any offers for the given   {@link EMaterialType}.
 * @param materialType The  {@link EMaterialType} to be checked.
 * @param minimumIncludedPriority The lowest priority to be included in
 * @return Returns true if there are no offers for the given {@link EMaterialType},<br> false otherwise.
 */
public boolean isEmpty(EMaterialType materialType,EOfferPriority minimumIncludedPriority){
  return offersLists[materialType.ordinal].isEmpty(minimumIncludedPriority);
}"
55706,"private BitSet calculatePositionsInDistanceTrivial(int width,int height,IBooleanCoordinateValueProvider provider,int maxDistance){
  BitSet inDistance=new BitSet();
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      if (provider.getValue(x,y)) {
        HexGridArea.iterate(x,y,0,maxDistance,VisitorConsumerUtils.filterBounds(width,height,(currX,currY,radius) -> {
          inDistance.set(currY * width + currX);
          return null;
        }
));
      }
    }
  }
  return inDistance;
}","private BitSet calculatePositionsInDistanceTrivial(int width,int height,IBooleanCoordinateValueProvider provider,int maxDistance){
  BitSet inDistance=new BitSet();
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      if (provider.getValue(x,y)) {
        HexGridArea.iterate(x,y,0,maxDistance,VisitorConsumerUtils.filterBounds(width,height,(currX,currY,radius) -> {
          inDistance.set(currY * width + currX);
          return Optional.empty();
        }
));
      }
    }
  }
  return inDistance;
}"
55707,"public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isBlocked(startX,startY)) {
    return;
  }
  short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}","public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isPioneerBlocked(startX,startY)) {
    return;
  }
  final IContainingProvider containingProvider=grid::isPioneerBlocked;
  final short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isPioneerBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}"
55708,"/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param grid
 * @param containingProvider
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,new IBorderVisitor(){
    @Override public boolean visit(    int insideX,    int insideY,    int outsideX,    int outsideY){
      return grid.getPartitionAt((short)outsideX,(short)outsideY) == partition;
    }
  }
,true);
}","/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param grid
 * @param containingProvider
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,(insideX,insideY,outsideX,outsideY) -> grid.getPartitionAt((short)outsideX,(short)outsideY) == partition,true);
}"
55709,"private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  IAreaVisitor visitor=new IAreaVisitor(){
    @Override public boolean visit(    int x,    int y){
      grid.setPartitionAt(x,y,newPartition);
      return true;
    }
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}","private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  IAreaVisitor visitor=(x,y) -> {
    grid.setPartitionAt(x,y,newPartition);
    return true;
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}"
55710,"final void checkPositionThatChangedPlayer(ShortPoint2D position){
  if (!isInBounds(position.x,position.y)) {
    return;
  }
  EnclosedBlockedAreaFinderAlgorithm.checkLandmark(enclosedBlockedAreaFinderGrid,flagsGrid.getBlockedContainingProvider(),position);
  Movable movable=movableGrid.getMovableAt(position.x,position.y);
  if (movable != null) {
    movable.checkPlayerOfPosition(partitionsGrid.getPlayerAt(position.x,position.y));
  }
}","final void checkPositionThatChangedPlayer(ShortPoint2D position){
  if (!isInBounds(position.x,position.y)) {
    return;
  }
  EnclosedBlockedAreaFinderAlgorithm.checkLandmark(enclosedBlockedAreaFinderGrid,position);
  Movable movable=movableGrid.getMovableAt(position.x,position.y);
  if (movable != null) {
    movable.checkPlayerOfPosition(partitionsGrid.getPlayerAt(position.x,position.y));
  }
}"
55711,"public FlagsGrid(final short width,final short height){
  this.width=width;
  this.blockedGrid=new BitSet(width * height);
  this.protectedGrid=new BitSet(width * height);
  this.markedGrid=new BitSet(width * height);
  initAdditional();
}","public FlagsGrid(final short width,final short height){
  this.width=width;
  this.blockedGrid=new BitSet(width * height);
  this.protectedGrid=new BitSet(width * height);
  this.markedGrid=new BitSet(width * height);
}"
55712,"@Test public void veryHardShouldProduceCertainAmountOfSoldiersWithin85Minutes() throws MapLoadException {
  PlayerSetting[] playerSettings=getDefaultPlayerSettings(12);
  playerSettings[0]=new PlayerSetting(EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,(byte)0);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(85 * MINUTES);
  ReplayUtils.awaitShutdown(startedGame);
  short expectedMinimalProducedSoldiers=1000;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    fail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),200,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),100,2500);
}","@Test public void veryHardShouldProduceCertainAmountOfSoldiersWithin85Minutes() throws MapLoadException {
  PlayerSetting[] playerSettings=getDefaultPlayerSettings(12);
  playerSettings[0]=new PlayerSetting(EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,(byte)0);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(86 * MINUTES);
  ReplayUtils.awaitShutdown(startedGame);
  short expectedMinimalProducedSoldiers=1000;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    fail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),200,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),100,2500);
}"
55713,"public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isBlocked(startX,startY)) {
    return;
  }
  short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}","public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isPioneerBlocked(startX,startY)) {
    return;
  }
  final IContainingProvider containingProvider=grid::isPioneerBlocked;
  final short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isPioneerBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}"
55714,"/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param grid
 * @param containingProvider
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,new IBorderVisitor(){
    @Override public boolean visit(    int insideX,    int insideY,    int outsideX,    int outsideY){
      return grid.getPartitionAt((short)outsideX,(short)outsideY) == partition;
    }
  }
,true);
}","/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param grid
 * @param containingProvider
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,(insideX,insideY,outsideX,outsideY) -> grid.getPartitionAt((short)outsideX,(short)outsideY) == partition,true);
}"
55715,"private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  IAreaVisitor visitor=new IAreaVisitor(){
    @Override public boolean visit(    int x,    int y){
      grid.setPartitionAt(x,y,newPartition);
      return true;
    }
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}","private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  IAreaVisitor visitor=(x,y) -> {
    grid.setPartitionAt(x,y,newPartition);
    return true;
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}"
55716,"final void checkPositionThatChangedPlayer(ShortPoint2D position){
  if (!isInBounds(position.x,position.y)) {
    return;
  }
  EnclosedBlockedAreaFinderAlgorithm.checkLandmark(enclosedBlockedAreaFinderGrid,flagsGrid.getBlockedContainingProvider(),position);
  Movable movable=movableGrid.getMovableAt(position.x,position.y);
  if (movable != null) {
    movable.checkPlayerOfPosition(partitionsGrid.getPlayerAt(position.x,position.y));
  }
}","final void checkPositionThatChangedPlayer(ShortPoint2D position){
  if (!isInBounds(position.x,position.y)) {
    return;
  }
  EnclosedBlockedAreaFinderAlgorithm.checkLandmark(enclosedBlockedAreaFinderGrid,position);
  Movable movable=movableGrid.getMovableAt(position.x,position.y);
  if (movable != null) {
    movable.checkPlayerOfPosition(partitionsGrid.getPlayerAt(position.x,position.y));
  }
}"
55717,"public FlagsGrid(final short width,final short height){
  this.width=width;
  this.blockedGrid=new BitSet(width * height);
  this.protectedGrid=new BitSet(width * height);
  this.markedGrid=new BitSet(width * height);
  initAdditional();
}","public FlagsGrid(final short width,final short height){
  this.width=width;
  this.blockedGrid=new BitSet(width * height);
  this.protectedGrid=new BitSet(width * height);
  this.markedGrid=new BitSet(width * height);
}"
55718,"@Test public void veryHardShouldProduceCertainAmountOfSoldiersWithin85Minutes() throws MapLoadException {
  PlayerSetting[] playerSettings=getDefaultPlayerSettings(12);
  playerSettings[0]=new PlayerSetting(EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,(byte)0);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(85 * MINUTES);
  ReplayUtils.awaitShutdown(startedGame);
  short expectedMinimalProducedSoldiers=1000;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    fail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),200,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),100,2500);
}","@Test public void veryHardShouldProduceCertainAmountOfSoldiersWithin85Minutes() throws MapLoadException {
  PlayerSetting[] playerSettings=getDefaultPlayerSettings(12);
  playerSettings[0]=new PlayerSetting(EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,(byte)0);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(86 * MINUTES);
  ReplayUtils.awaitShutdown(startedGame);
  short expectedMinimalProducedSoldiers=1000;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    fail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),200,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),100,2500);
}"
55719,"public void endTask(){
  if (taskAction != null) {
switch (taskAction.getActionType()) {
case SHOW_CONSTRUCTION_MARK:
      actionFireable.fireAction(new ShowConstructionMarksAction(null));
  }
  taskAction=null;
}
}","public void endTask(){
  if (taskAction != null) {
switch (taskAction.getActionType()) {
case SHOW_CONSTRUCTION_MARK:
      actionFireable.fireAction(new ShowConstructionMarksAction(null));
    break;
case MOVE_TO:
  break;
}
taskAction=null;
}
}"
55720,"public void progressChanged(String status,int progress){
  statusTextView.setText(status);
  progressBar.setProgress(progress);
}","public void progressChanged(String status,int progress){
  this.status=status;
  this.progress=progress;
  if (this.getView() != null) {
    setProgress();
  }
}"
55721,"@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  gameStarter=(GameStarter)getActivity();
  map=gameStarter.getSelectedMap();
}","@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
}"
55722,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_new_single_player,container,false);
  FragmentUtil.setActionBar(this,view);
  TextView textViewName=(TextView)view.findViewById(R.id.text_view_name);
  textViewName.setText(map.getMapName());
  Button startGameButton=(Button)view.findViewById(R.id.button_start_game);
  startGameButton.setOnClickListener(startGameClickListener);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View view=inflater.inflate(R.layout.fragment_new_single_player,container,false);
  FragmentUtil.setActionBar(this,view);
  Button startGameButton=(Button)view.findViewById(R.id.button_start_game);
  startGameButton.setOnClickListener(startGameClickListener);
  return view;
}"
55723,"private ShortPoint2D getNearestPointInDefaultPartitionOutOfSortedMap(ShortPoint2D point,AiPositions sortedPoints,final byte playerId,int searchDistance){
  return sortedPoints.getNearestPoint(point,searchDistance,new AiPositionFilter(){
    @Override public boolean contains(    int x,    int y){
      return partitionsGrid.getPartitionAt(x,y).getPlayerId() == playerId;
    }
  }
);
}","private ShortPoint2D getNearestPointInDefaultPartitionOutOfSortedMap(ShortPoint2D point,AiPositions sortedPoints,final byte playerId,int searchDistance,final AiPositionFilter filter){
  return sortedPoints.getNearestPoint(point,searchDistance,new AiPositionFilter(){
    @Override public boolean contains(    int x,    int y){
      return partitionsGrid.getPartitionAt(x,y).getPlayerId() == playerId && (filter == null || filter.contains(x,y));
    }
  }
);
}"
55724,"public ShortPoint2D getNearestRiverPointInDefaultPartitionFor(ShortPoint2D referencePoint,int searchDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(referencePoint,sortedRiversInDefaultPartition,(byte)-1,searchDistance);
}","public ShortPoint2D getNearestRiverPointInDefaultPartitionFor(ShortPoint2D referencePoint,int searchDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(referencePoint,sortedRiversInDefaultPartition,(byte)-1,searchDistance,null);
}"
55725,"@Override public boolean contains(int x,int y){
  return partitionsGrid.getPartitionAt(x,y).getPlayerId() == playerId;
}","@Override public boolean contains(int x,int y){
  return partitionsGrid.getPartitionAt(x,y).getPlayerId() == playerId && (filter == null || filter.contains(x,y));
}"
55726,"public ShortPoint2D getNearestCuttableObjectPointForPlayer(ShortPoint2D point,EMapObjectType cuttableObject,int searchDistance,byte playerId){
  AiPositions sortedResourcePoints=sortedCuttableObjectsInDefaultPartition.get(cuttableObject);
  if (sortedResourcePoints == null) {
    return null;
  }
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,playerId,searchDistance);
}","public ShortPoint2D getNearestCuttableObjectPointForPlayer(ShortPoint2D point,EMapObjectType cuttableObject,int searchDistance,byte playerId){
  AiPositions sortedResourcePoints=sortedCuttableObjectsInDefaultPartition.get(cuttableObject);
  if (sortedResourcePoints == null) {
    return null;
  }
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,playerId,searchDistance,null);
}"
55727,"public ShortPoint2D getNearestResourcePointForPlayer(ShortPoint2D point,EResourceType resourceType,byte playerId,int searchDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourceTypes[resourceType.ordinal],playerId,searchDistance);
}","public ShortPoint2D getNearestResourcePointForPlayer(ShortPoint2D point,EResourceType resourceType,byte playerId,int searchDistance,AiPositionFilter filter){
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourceTypes[resourceType.ordinal],playerId,searchDistance,filter);
}"
55728,"public ShortPoint2D getNearestResourcePointInDefaultPartitionFor(ShortPoint2D point,EResourceType resourceType,int currentNearestPointDistance){
  return getNearestResourcePointForPlayer(point,resourceType,(byte)-1,currentNearestPointDistance);
}","public ShortPoint2D getNearestResourcePointInDefaultPartitionFor(ShortPoint2D point,EResourceType resourceType,int currentNearestPointDistance,AiPositionFilter filter){
  return getNearestResourcePointForPlayer(point,resourceType,(byte)-1,currentNearestPointDistance,filter);
}"
55729,"private void sendGeologistToNearest(Movable geologist,EResourceType resourceType){
  ShortPoint2D resourcePoint=aiStatistics.getNearestResourcePointForPlayer(aiStatistics.getPositionOfPartition(playerId),resourceType,playerId,Integer.MAX_VALUE);
  if (resourcePoint == null) {
    resourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(aiStatistics.getPositionOfPartition(playerId),resourceType,Integer.MAX_VALUE);
  }
  if (resourcePoint != null) {
    sendMovableTo(geologist,resourcePoint);
  }
}","private void sendGeologistToNearest(Movable geologist,EResourceType resourceType){
  ShortPoint2D resourcePoint=aiStatistics.getNearestResourcePointForPlayer(aiStatistics.getPositionOfPartition(playerId),resourceType,playerId,Integer.MAX_VALUE,geologistFilters[resourceType.ordinal]);
  if (resourcePoint == null) {
    resourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(aiStatistics.getPositionOfPartition(playerId),resourceType,Integer.MAX_VALUE,geologistFilters[resourceType.ordinal]);
  }
  if (resourcePoint != null) {
    sendMovableTo(geologist,resourcePoint);
  }
}"
55730,"public WhatToDoAi(byte playerId,AiStatistics aiStatistics,EconomyMinister economyMinister,ArmyGeneral armyGeneral,MainGrid mainGrid,ITaskScheduler taskScheduler){
  this.playerId=playerId;
  this.mainGrid=mainGrid;
  this.taskScheduler=taskScheduler;
  this.aiStatistics=aiStatistics;
  this.armyGeneral=armyGeneral;
  this.economyMinister=economyMinister;
  this.pioneerAi=new PioneerAi(aiStatistics,playerId);
  bestConstructionPositionFinderFactory=new BestConstructionPositionFinderFactory();
  resourcePioneers=new PioneerGroup(RESOURCE_PIONEER_GROUP_COUNT);
  broadenerPioneers=new PioneerGroup(BROADEN_PIONEER_GROUP_COUNT);
}","public WhatToDoAi(byte playerId,AiStatistics aiStatistics,EconomyMinister economyMinister,ArmyGeneral armyGeneral,MainGrid mainGrid,ITaskScheduler taskScheduler){
  this.playerId=playerId;
  this.mainGrid=mainGrid;
  this.taskScheduler=taskScheduler;
  this.aiStatistics=aiStatistics;
  this.armyGeneral=armyGeneral;
  this.economyMinister=economyMinister;
  this.pioneerAi=new PioneerAi(aiStatistics,playerId);
  bestConstructionPositionFinderFactory=new BestConstructionPositionFinderFactory();
  resourcePioneers=new PioneerGroup(RESOURCE_PIONEER_GROUP_COUNT);
  broadenerPioneers=new PioneerGroup(BROADEN_PIONEER_GROUP_COUNT);
  for (  EResourceType resourceType : EResourceType.VALUES) {
    geologistFilters[resourceType.ordinal]=new SurroundedByResourcesFilter(mainGrid,mainGrid.getLandscapeGrid(),resourceType);
  }
}"
55731,"@Override public ShortPoint2D findTarget(AiPositions playerBorder,ShortPoint2D center){
  if (aiStatistics.resourceCountInDefaultPartition(resourceType) == 0)   return null;
  int factor=aiStatistics.getTotalNumberOfBuildingTypeForPlayer(mineBuildingType,playerId) + 1;
  int tiles=mineBuildingType.getProtectedTiles().length * 2;
  if (aiStatistics.resourceCountOfPlayer(resourceType,playerId) > tiles * factor)   return null;
  ShortPoint2D nearestResourceAbroad=aiStatistics.getNearestResourcePointInDefaultPartitionFor(center,resourceType,searchDistance);
  if (nearestResourceAbroad == null)   return null;
  ShortPoint2D target=playerBorder.getNearestPoint(nearestResourceAbroad,searchDistance);
  return target;
}","@Override public ShortPoint2D findTarget(AiPositions playerBorder,ShortPoint2D center){
  if (aiStatistics.resourceCountInDefaultPartition(resourceType) == 0)   return null;
  int factor=aiStatistics.getTotalNumberOfBuildingTypeForPlayer(mineBuildingType,playerId) + 1;
  int tiles=mineBuildingType.getProtectedTiles().length * 2;
  if (aiStatistics.resourceCountOfPlayer(resourceType,playerId) > tiles * factor)   return null;
  ShortPoint2D nearestResourceAbroad=aiStatistics.getNearestResourcePointInDefaultPartitionFor(center,resourceType,searchDistance,sourroundedByResourceFilter);
  if (nearestResourceAbroad == null)   return null;
  return playerBorder.getNearestPoint(nearestResourceAbroad,searchDistance);
}"
55732,"public MineTargetFinder(AiStatistics aiStatistics,byte playerId,int searchDistance,EResourceType resourceType,EBuildingType mineBuildingType){
  super(aiStatistics,playerId,searchDistance);
  this.resourceType=resourceType;
  this.mineBuildingType=mineBuildingType;
}","public MineTargetFinder(final AiStatistics aiStatistics,final byte playerId,final int searchDistance,final EResourceType resourceType,final EBuildingType mineBuildingType){
  super(aiStatistics,playerId,searchDistance);
  this.resourceType=resourceType;
  this.mineBuildingType=mineBuildingType;
  sourroundedByResourceFilter=new SurroundedByResourcesFilter(aiStatistics.getMainGrid(),aiStatistics.getMainGrid().getLandscapeGrid(),resourceType);
}"
55733,"public static PlayerSetting readFromStream(DataInputStream dis) throws IOException {
  dis.readShort();
  boolean available=dis.readBoolean();
  if (available) {
    byte readTeamId=dis.readByte();
    Byte teamId=readTeamId == -1 ? null : readTeamId;
    String civilizationName=dis.readUTF();
    ECivilisation civilisation=civilizationName.isEmpty() ? null : ECivilisation.valueOf(civilizationName);
    String playerTypeName=dis.readUTF();
    EPlayerType playerType=playerTypeName.isEmpty() ? null : EPlayerType.valueOf(playerTypeName);
    return new PlayerSetting(playerType,civilisation,teamId);
  }
 else {
    return new PlayerSetting();
  }
}","public static PlayerSetting readFromStream(DataInputStream dis) throws IOException {
  dis.readShort();
  boolean available=dis.readBoolean();
  if (available) {
    byte readTeamId=dis.readByte();
    Byte teamId=readTeamId == -1 ? null : readTeamId;
    String civilizationName=dis.readUTF();
    ECivilisation civilisation=civilizationName.isEmpty() ? null : ECivilisation.valueOf(civilizationName);
    String playerTypeName=dis.readUTF();
    EPlayerType playerType=playerTypeName.isEmpty() ? null : EPlayerType.valueOf(playerTypeName);
    return new PlayerSetting(true,playerType,civilisation,teamId);
  }
 else {
    return new PlayerSetting();
  }
}"
55734,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  int fishDistance=Integer.MAX_VALUE;
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point,playerId,buildingType)) {
      ShortPoint2D fishPosition=aiStatistics.getNearestResourcePointForPlayer(point,FISH,playerId,fishDistance);
      if (fishPosition != null) {
        fishDistance=point.getOnGridDistTo(fishPosition);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,fishDistance));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  int fishDistance=buildingType.getWorkRadius();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point,playerId,buildingType)) {
      ShortPoint2D fishPosition=aiStatistics.getNearestResourcePointForPlayer(point,FISH,playerId,fishDistance);
      if (fishPosition != null) {
        fishDistance=point.getOnGridDistTo(fishPosition);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,fishDistance));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
55735,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  AiPositions rivers=aiStatistics.getRiversForPlayer(playerId);
  if (rivers.size() == 0) {
    return null;
  }
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point,playerId,buildingType)) {
      ShortPoint2D nearestRiverPosition=rivers.getNearestPoint(point);
      int riverDistance=point.getOnGridDistTo(nearestRiverPosition);
      scoredConstructionPositions.add(new ScoredConstructionPosition(point,riverDistance));
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  AiPositions rivers=aiStatistics.getRiversForPlayer(playerId);
  if (rivers.size() == 0) {
    return null;
  }
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point,playerId,buildingType)) {
      ShortPoint2D nearestRiverPosition=rivers.getNearestPoint(point,buildingType.getWorkRadius(),null);
      if (nearestRiverPosition != null) {
        int riverDistance=point.getOnGridDistTo(nearestRiverPosition);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,riverDistance));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
55736,"private ShortPoint2D getNearestPointInDefaultPartitionOutOfSortedMap(ShortPoint2D point,AiPositions sortedPoints,final byte playerId,int currentNearestPointDistance){
  return sortedPoints.getNearestPoint(point,currentNearestPointDistance,new AiPositionFilter(){
    @Override public boolean contains(    int x,    int y){
      return partitionsGrid.getPartitionAt(x,y).getPlayerId() == playerId;
    }
  }
);
}","private ShortPoint2D getNearestPointInDefaultPartitionOutOfSortedMap(ShortPoint2D point,AiPositions sortedPoints,final byte playerId,int searchDistance){
  return sortedPoints.getNearestPoint(point,searchDistance,new AiPositionFilter(){
    @Override public boolean contains(    int x,    int y){
      return partitionsGrid.getPartitionAt(x,y).getPlayerId() == playerId;
    }
  }
);
}"
55737,"public ShortPoint2D getNearestRiverPointInDefaultPartitionFor(ShortPoint2D referencePoint,int currentNearestPointDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(referencePoint,sortedRiversInDefaultPartition,(byte)-1,currentNearestPointDistance);
}","public ShortPoint2D getNearestRiverPointInDefaultPartitionFor(ShortPoint2D referencePoint,int searchDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(referencePoint,sortedRiversInDefaultPartition,(byte)-1,searchDistance);
}"
55738,"public ShortPoint2D getNearestCuttableObjectPointInDefaultPartitionFor(ShortPoint2D point,EMapObjectType cuttableObject,int currentNearestPointDistance){
  return getNearestCuttableObjectPointForPlayer(point,cuttableObject,currentNearestPointDistance,(byte)-1);
}","public ShortPoint2D getNearestCuttableObjectPointInDefaultPartitionFor(ShortPoint2D point,EMapObjectType cuttableObject,int searchDistance){
  return getNearestCuttableObjectPointForPlayer(point,cuttableObject,searchDistance,(byte)-1);
}"
55739,"public ShortPoint2D getNearestCuttableObjectPointForPlayer(ShortPoint2D point,EMapObjectType cuttableObject,int currentNearestPointDistance,byte playerId){
  AiPositions sortedResourcePoints=sortedCuttableObjectsInDefaultPartition.get(cuttableObject);
  if (sortedResourcePoints == null) {
    return null;
  }
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,playerId,currentNearestPointDistance);
}","public ShortPoint2D getNearestCuttableObjectPointForPlayer(ShortPoint2D point,EMapObjectType cuttableObject,int searchDistance,byte playerId){
  AiPositions sortedResourcePoints=sortedCuttableObjectsInDefaultPartition.get(cuttableObject);
  if (sortedResourcePoints == null) {
    return null;
  }
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,playerId,searchDistance);
}"
55740,"public ShortPoint2D getNearestResourcePointForPlayer(ShortPoint2D point,EResourceType resourceType,byte playerId,int currentNearestPointDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourceTypes[resourceType.ordinal],playerId,currentNearestPointDistance);
}","public ShortPoint2D getNearestResourcePointForPlayer(ShortPoint2D point,EResourceType resourceType,byte playerId,int searchDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourceTypes[resourceType.ordinal],playerId,searchDistance);
}"
55741,"private void destroyBuildings(){
  for (  ShortPoint2D stoneCutterPosition : aiStatistics.getBuildingPositionsOfTypeForPlayer(STONECUTTER,playerId)) {
    if (aiStatistics.getBuildingAt(stoneCutterPosition).cannotWork()) {
      int numberOfStoneCutters=aiStatistics.getNumberOfBuildingTypeForPlayer(STONECUTTER,playerId);
      if (numberOfStoneCutters == 1) {
        ShortPoint2D nearestStone=aiStatistics.getStonesForPlayer(playerId).getNearestPoint(stoneCutterPosition);
        if (nearestStone != null) {
          taskScheduler.scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,playerId,nearestStone,stoneCutterPosition));
        }
      }
 else {
        ShortPoint2D nearestStone=aiStatistics.getStonesForPlayer(playerId).getNearestPoint(stoneCutterPosition,STONECUTTER.getWorkRadius() * MAXIMUM_STONECUTTER_WORK_RADIUS_FACTOR,null);
        if (nearestStone != null && numberOfStoneCutters < economyMinister.getMidGameNumberOfStoneCutters()) {
          taskScheduler.scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,playerId,nearestStone,stoneCutterPosition));
        }
 else {
          taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,stoneCutterPosition));
          break;
        }
      }
    }
  }
  if (economyMinister.automaticLivingHousesEnabled()) {
    int numberOfFreeBeds=aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.SMALL_LIVINGHOUSE,playerId) * NUMBER_OF_SMALL_LIVINGHOUSE_BEDS + aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.MEDIUM_LIVINGHOUSE,playerId) * NUMBER_OF_MEDIUM_LIVINGHOUSE_BEDS + aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.BIG_LIVINGHOUSE,playerId) * NUMBER_OF_BIG_LIVINGHOUSE_BEDS - aiStatistics.getMovablePositionsByTypeForPlayer(EMovableType.BEARER,playerId).size();
    if (numberOfFreeBeds >= NUMBER_OF_SMALL_LIVINGHOUSE_BEDS + 1 && !destroyLivingHouse(SMALL_LIVINGHOUSE)) {
      if (numberOfFreeBeds >= NUMBER_OF_MEDIUM_LIVINGHOUSE_BEDS + 1 && !destroyLivingHouse(MEDIUM_LIVINGHOUSE)) {
        if (numberOfFreeBeds >= NUMBER_OF_BIG_LIVINGHOUSE_BEDS + 1) {
          destroyLivingHouse(BIG_LIVINGHOUSE);
        }
      }
    }
  }
  if (isEndGame && isWoodJam()) {
    List<ShortPoint2D> forresters=aiStatistics.getBuildingPositionsOfTypeForPlayer(FORESTER,playerId);
    if (forresters.size() > 1) {
      for (int i=1; i < forresters.size(); i++) {
        taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,forresters.get(i)));
      }
    }
    for (    ShortPoint2D lumberJackPosition : aiStatistics.getBuildingPositionsOfTypeForPlayer(LUMBERJACK,playerId)) {
      if (aiStatistics.getBuildingAt(lumberJackPosition).cannotWork()) {
        taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,lumberJackPosition));
      }
    }
    if ((aiStatistics.getNumberOfBuildingTypeForPlayer(SAWMILL,playerId) * 3 - 2) > aiStatistics.getNumberOfBuildingTypeForPlayer(LUMBERJACK,playerId)) {
      taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,aiStatistics.getBuildingPositionsOfTypeForPlayer(SAWMILL,playerId).get(0)));
    }
    for (    ShortPoint2D bigTemple : aiStatistics.getBuildingPositionsOfTypeForPlayer(BIG_TEMPLE,playerId)) {
      taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,bigTemple));
    }
  }
}","private void destroyBuildings(){
  for (  ShortPoint2D stoneCutterPosition : aiStatistics.getBuildingPositionsOfTypeForPlayer(STONECUTTER,playerId)) {
    if (aiStatistics.getBuildingAt(stoneCutterPosition).cannotWork()) {
      int numberOfStoneCutters=aiStatistics.getNumberOfBuildingTypeForPlayer(STONECUTTER,playerId);
      ShortPoint2D nearestStone=aiStatistics.getStonesForPlayer(playerId).getNearestPoint(stoneCutterPosition,STONECUTTER.getWorkRadius() * MAXIMUM_STONECUTTER_WORK_RADIUS_FACTOR,null);
      if (nearestStone != null && numberOfStoneCutters < economyMinister.getMidGameNumberOfStoneCutters()) {
        taskScheduler.scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,playerId,nearestStone,stoneCutterPosition));
      }
 else {
        taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,stoneCutterPosition));
        break;
      }
    }
  }
  if (economyMinister.automaticLivingHousesEnabled()) {
    int numberOfFreeBeds=aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.SMALL_LIVINGHOUSE,playerId) * NUMBER_OF_SMALL_LIVINGHOUSE_BEDS + aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.MEDIUM_LIVINGHOUSE,playerId) * NUMBER_OF_MEDIUM_LIVINGHOUSE_BEDS + aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.BIG_LIVINGHOUSE,playerId) * NUMBER_OF_BIG_LIVINGHOUSE_BEDS - aiStatistics.getMovablePositionsByTypeForPlayer(EMovableType.BEARER,playerId).size();
    if (numberOfFreeBeds >= NUMBER_OF_SMALL_LIVINGHOUSE_BEDS + 1 && !destroyLivingHouse(SMALL_LIVINGHOUSE)) {
      if (numberOfFreeBeds >= NUMBER_OF_MEDIUM_LIVINGHOUSE_BEDS + 1 && !destroyLivingHouse(MEDIUM_LIVINGHOUSE)) {
        if (numberOfFreeBeds >= NUMBER_OF_BIG_LIVINGHOUSE_BEDS + 1) {
          destroyLivingHouse(BIG_LIVINGHOUSE);
        }
      }
    }
  }
  if (isEndGame && isWoodJam()) {
    List<ShortPoint2D> forresters=aiStatistics.getBuildingPositionsOfTypeForPlayer(FORESTER,playerId);
    if (forresters.size() > 1) {
      for (int i=1; i < forresters.size(); i++) {
        taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,forresters.get(i)));
      }
    }
    for (    ShortPoint2D lumberJackPosition : aiStatistics.getBuildingPositionsOfTypeForPlayer(LUMBERJACK,playerId)) {
      if (aiStatistics.getBuildingAt(lumberJackPosition).cannotWork()) {
        taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,lumberJackPosition));
      }
    }
    if ((aiStatistics.getNumberOfBuildingTypeForPlayer(SAWMILL,playerId) * 3 - 2) > aiStatistics.getNumberOfBuildingTypeForPlayer(LUMBERJACK,playerId)) {
      taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,aiStatistics.getBuildingPositionsOfTypeForPlayer(SAWMILL,playerId).get(0)));
    }
    for (    ShortPoint2D bigTemple : aiStatistics.getBuildingPositionsOfTypeForPlayer(BIG_TEMPLE,playerId)) {
      taskScheduler.scheduleTask(new DestroyBuildingGuiTask(playerId,bigTemple));
    }
  }
}"
55742,"/** 
 * @param weaponSmithFactor influences the power of the AI. Use 1 for full power. Use < 1 for weaker AIs. The factor is used to determine the maximum amount of weapon smiths build on the map and shifts the point of time when the weapon smiths are build.
 * @param buildingIndustryFactor influences the amount of lumberjacks, sawmills, foresters and stone cutters to slow down the AI.
 */
public BuildingListEconomyMinister(AiStatistics aiStatistics,Player player,float weaponSmithFactor,float buildingIndustryFactor){
  this.aiStatistics=aiStatistics;
  this.buildingIndustryFactor=buildingIndustryFactor;
  this.playerId=player.playerId;
  this.weaponSmithFactor=weaponSmithFactor;
  this.buildingsToBuild=new ArrayList<>();
  this.isHighGoodsGame=isHighGoodsGame();
  this.isMiddleGoodsGame=isMiddleGoodsGame();
}","/** 
 * @param weaponSmithFactor influences the power of the AI. Use 1 for full power. Use < 1 for weaker AIs. The factor is used to determine the maximum amount of weapon smiths build on the map and shifts the point of time when the weapon smiths are build.
 * @param buildingIndustryFactor influences the power of the AI. Use 1 for full power. Use < 1 for weaker AIs. The factor is used to determine the maximum amount of building industry buildings. If the AI e.g. builds less lumberjacks it is slower.
 * @param limitByWeakestEnemy when set limits the AI in all amounts of buildings by the average building count of all alive enemies.
 */
public BuildingListEconomyMinister(AiStatistics aiStatistics,Player player,float weaponSmithFactor,float buildingIndustryFactor,boolean limitByWeakestEnemy){
  this.aiStatistics=aiStatistics;
  this.buildingIndustryFactor=buildingIndustryFactor;
  this.limitByWeakestEnemy=limitByWeakestEnemy;
  this.playerId=player.playerId;
  this.weaponSmithFactor=weaponSmithFactor;
  this.buildingsToBuild=new ArrayList<>();
  this.isHighGoodsGame=isHighGoodsGame();
  this.isMiddleGoodsGame=isMiddleGoodsGame();
}"
55743,"protected void addIfPossible(EBuildingType buildingType){
  float factor=1F;
  if (BUILDING_INDUSTRY.contains(buildingType)) {
    factor=buildingIndustryFactor;
  }
  if (currentCountOf(buildingType) < Math.ceil(mapBuildingCounts[buildingType.ordinal] * factor)) {
    buildingsToBuild.add(buildingType);
  }
}","protected void addIfPossible(EBuildingType buildingType){
  float factor=1F;
  if (BUILDING_INDUSTRY.contains(buildingType)) {
    factor=buildingIndustryFactor;
  }
  double currentCount=currentCountOf(buildingType);
  if (currentCount < Math.ceil(mapBuildingCounts[buildingType.ordinal] * factor) && currentCount < maximumAllowedCount(buildingType)) {
    buildingsToBuild.add(buildingType);
  }
}"
55744,"private EconomyMinister determineMinister(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player){
switch (type) {
case AI_VERY_EASY:
    return new AdaptableEconomyMinister(aiStatistics,player);
case AI_EASY:
  return new BuildingListEconomyMinister(aiStatistics,player,1F / 4F,1F / 2F);
case AI_HARD:
return new BuildingListEconomyMinister(aiStatistics,player,1F / 2F,3F / 4F);
default :
return new BuildingListEconomyMinister(aiStatistics,player,1F,1F);
}
}","private EconomyMinister determineMinister(EPlayerType type,ECivilisation civilisation,AiStatistics aiStatistics,Player player){
switch (type) {
case AI_VERY_EASY:
    return new BuildingListEconomyMinister(aiStatistics,player,1F / 8F,1F / 4F,true);
case AI_EASY:
  return new BuildingListEconomyMinister(aiStatistics,player,1F / 4F,1F / 2F,false);
case AI_HARD:
return new BuildingListEconomyMinister(aiStatistics,player,1F / 2F,3F / 4F,false);
default :
return new BuildingListEconomyMinister(aiStatistics,player,1F,1F,false);
}
}"
55745,"@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,125 * MINUTES);
}","@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,100 * MINUTES);
}"
55746,"public BuildingDefinition(EBuildingType type){
  this.type=type;
  for (  RelativePoint pos : type.getBlockedTiles()) {
    blocked.add(pos);
  }
  for (  RelativePoint pos : type.getProtectedTiles()) {
    if (!blocked.contains(pos)) {
      justProtected.add(pos);
    }
  }
  buildmarks.addAll(Arrays.asList(type.getBuildmarks()));
  bricklayers.addAll(Arrays.asList(type.getBricklayers()));
  door=type.getDoorTile();
  flag=type.getFlag();
  constructionStacks.addAll(Arrays.asList(type.getConstructionStacks()));
  requestStacks.addAll(Arrays.asList(type.getRequestStacks()));
  offerStacks.addAll(Arrays.asList(type.getOfferStacks()));
}","public BuildingDefinition(EBuildingType type){
  this.type=type;
  for (  RelativePoint pos : type.getBlockedTiles()) {
    blocked.add(pos);
  }
  for (  RelativePoint pos : type.getProtectedTiles()) {
    if (!blocked.contains(pos)) {
      justProtected.add(pos);
    }
  }
  buildmarks.addAll(Arrays.asList(type.getBuildMarks()));
  bricklayers.addAll(Arrays.asList(type.getBricklayers()));
  door=type.getDoorTile();
  flag=type.getFlag();
  constructionStacks.addAll(Arrays.asList(type.getConstructionStacks()));
  requestStacks.addAll(Arrays.asList(type.getRequestStacks()));
  offerStacks.addAll(Arrays.asList(type.getOfferStacks()));
}"
55747,"@Override public void towerDefended(IBuildingOccupyableMovable soldier){
  inFight=false;
  if (attackableTowerObject.currDefender == null) {
    System.err.println(""String_Node_Str"");
  }
 else {
    addOccupier(new TowerOccupier(attackableTowerObject.currDefender.place,soldier));
    attackableTowerObject.currDefender=null;
  }
  doorHealth=0.1f;
}","@Override public void towerDefended(IBuildingOccupyableMovable soldier){
  inFight=false;
  if (attackableTowerObject.currDefender == null) {
    System.err.println(""String_Node_Str"");
  }
 else {
    TowerOccupier towerOccupier=new TowerOccupier(attackableTowerObject.currDefender.place,soldier);
    addOccupier(towerOccupier);
    attackableTowerObject.currDefender=null;
    addInformableMapObject(towerOccupier,true);
  }
  doorHealth=0.1f;
}"
55748,"@Override public OutputStream getOutputStream(MapFileHeader header) throws IOException {
  String name=header.getName().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  Date date=header.getCreationDate();
  if (date != null) {
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    name+=format.format(date);
  }
  String mapFileExtension=MapList.getMapExtension();
  String actualName=name;
  File file=new File(directory,actualName + mapFileExtension);
  int i=1;
  while (file.exists()) {
    actualName=name + ""String_Node_Str"" + i;
    file=new File(directory,actualName + mapFileExtension);
    i++;
  }
  if (!directory.exists()) {
    directory.mkdirs();
  }
  if (!directory.isDirectory()) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    OutputStream outputStream=new BufferedOutputStream(new FileOutputStream(file));
    if (CommonConstants.USE_SAVEGAME_COMPRESSION) {
      System.out.println(""String_Node_Str"");
      ZipOutputStream zipOutputStream=new ZipOutputStream(outputStream);
      ZipEntry zipEntry=new ZipEntry(actualName + MapLoader.MAP_EXTENSION);
      zipOutputStream.putNextEntry(zipEntry);
      return zipOutputStream;
    }
 else {
      System.out.println(""String_Node_Str"");
      return outputStream;
    }
  }
 catch (  FileNotFoundException e) {
    throw new IOException(e);
  }
}","@Override public OutputStream getOutputStream(MapFileHeader header) throws IOException {
  String name=header.getName().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  Date date=header.getCreationDate();
  if (date != null) {
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    name+=format.format(date);
  }
  String mapFileExtension=MapList.getMapExtension();
  String actualName=name;
  File file=new File(directory,actualName + mapFileExtension);
  int i=1;
  while (file.exists()) {
    actualName=name + ""String_Node_Str"" + i;
    file=new File(directory,actualName + mapFileExtension);
    i++;
  }
  if (!directory.exists()) {
    directory.mkdirs();
  }
  if (!directory.isDirectory()) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    OutputStream outputStream=new BufferedOutputStream(new FileOutputStream(file));
    if (CommonConstants.USE_SAVEGAME_COMPRESSION) {
      System.out.println(""String_Node_Str"");
      ZipOutputStream zipOutputStream=new ZipOutputStream(outputStream);
      ZipEntry zipEntry=new ZipEntry(actualName + MapLoader.MAP_EXTENSION);
      zipOutputStream.putNextEntry(zipEntry);
      return zipOutputStream;
    }
 else {
      System.out.println(""String_Node_Str"");
      return outputStream;
    }
  }
 catch (  FileNotFoundException e) {
    throw new IOException(e);
  }
}"
55749,"/** 
 * Set the maximum player count
 * @param maxPlayer Min: 1, Max: CommonConstants.MAX_PLAYERS
 */
public void setMaxPlayers(short maxPlayer){
  if (maxPlayer <= 0 || maxPlayer > CommonConstants.MAX_PLAYERS) {
    throw new IllegalArgumentException(""String_Node_Str"" + CommonConstants.MAX_PLAYERS);
  }
  ShortPoint2D[] newPlayerStarts=new ShortPoint2D[maxPlayer];
  for (int i=0; i < maxPlayer; i++) {
    newPlayerStarts[i]=i < playercount ? playerStarts[i] : new ShortPoint2D(width / 2,height / 2);
  }
  this.playercount=maxPlayer;
  this.playerStarts=newPlayerStarts;
}","/** 
 * Set the maximum player count
 * @param maxPlayer Min: 1, Max: CommonConstants.MAX_PLAYERS
 */
public void setMaxPlayers(short maxPlayer){
  if (maxPlayer <= 0 || maxPlayer > CommonConstants.MAX_PLAYERS) {
    throw new IllegalArgumentException(""String_Node_Str"" + CommonConstants.MAX_PLAYERS);
  }
  ShortPoint2D[] newPlayerStarts=new ShortPoint2D[maxPlayer];
  for (int i=0; i < maxPlayer; i++) {
    newPlayerStarts[i]=i < playerCount ? playerStarts[i] : new ShortPoint2D(width / 2,height / 2);
  }
  this.playerCount=maxPlayer;
  this.playerStarts=newPlayerStarts;
}"
55750,"@Override public int getPlayerCount(){
  return playercount;
}","@Override public int getPlayerCount(){
  return playerCount;
}"
55751,"public void deleteObject(int x,int y){
  ObjectContainer obj=objects[x][y];
  if (obj instanceof ProtectContainer) {
    return;
  }
 else   if (obj != null) {
    undoDelta.addObject(x,y,obj);
    objects[x][y]=null;
    ShortPoint2D start=new ShortPoint2D(x,y);
    RelativePoint[] area=obj.getProtectedArea();
    for (    RelativePoint point : area) {
      ShortPoint2D pos=point.calculatePoint(start);
      if (contains(pos.x,pos.y)) {
        undoDelta.addObject(pos.x,pos.y,objects[pos.x][pos.y]);
        objects[pos.x][pos.y]=null;
      }
    }
  }
}","public void deleteObject(int x,int y){
  ObjectContainer obj=objects[x][y];
  if (obj instanceof ProtectContainer) {
  }
 else   if (obj != null) {
    undoDelta.addObject(x,y,obj);
    objects[x][y]=null;
    ShortPoint2D start=new ShortPoint2D(x,y);
    RelativePoint[] area=obj.getProtectedArea();
    for (    RelativePoint point : area) {
      ShortPoint2D pos=point.calculatePoint(start);
      if (contains(pos.x,pos.y)) {
        undoDelta.addObject(pos.x,pos.y,objects[pos.x][pos.y]);
        objects[pos.x][pos.y]=null;
      }
    }
  }
}"
55752,"@Override public void setDimension(int width,int height,int playercount){
  data=new MapData(width,height,playercount,ELandscapeType.GRASS);
}","@Override public void setDimension(int width,int height,int playerCount){
  data=new MapData(width,height,playerCount,ELandscapeType.GRASS);
}"
55753,"public void placeObject(MapObject object,int x,int y){
  ObjectContainer container=null;
  ProtectContainer protector=ProtectContainer.getInstance();
  Set<ELandscapeType> landscapes=null;
  if (object instanceof MapTreeObject) {
    container=TreeObjectContainer.getInstance();
  }
 else   if (object instanceof MapStoneObject) {
    container=new StoneObjectContainer((MapStoneObject)object);
  }
 else   if (object instanceof MovableObject) {
    container=new MovableObjectContainer((MovableObject)object,x,y);
  }
 else   if (object instanceof StackObject) {
    container=new StackContainer((StackObject)object);
  }
 else   if (object instanceof BuildingObject) {
    container=new BuildingContainer((BuildingObject)object,new ShortPoint2D(x,y));
    landscapes=((BuildingObject)object).getType().getGroundTypes();
    protector=new ProtectLandscapeConstraint(((BuildingObject)object).getType());
  }
 else   if (object instanceof MapDecorationObject) {
    container=new MapObjectContainer((MapDecorationObject)object);
  }
 else {
    return;
  }
  boolean allowed=true;
  ShortPoint2D start=new ShortPoint2D(x,y);
  for (  RelativePoint p : container.getProtectedArea()) {
    ShortPoint2D abs=p.calculatePoint(start);
    if (!contains(abs.x,abs.y) || objects[abs.x][abs.y] != null || !landscapeAllowsObjects(getLandscape(abs.x,abs.y)) || !landscapes.contains(getLandscape(abs.x,abs.y))) {
      allowed=false;
    }
  }
  if (allowed) {
    for (    RelativePoint p : container.getProtectedArea()) {
      ShortPoint2D abs=p.calculatePoint(start);
      objects[abs.x][abs.y]=protector;
      undoDelta.removeObject(abs.x,abs.y);
    }
    objects[x][y]=container;
    undoDelta.removeObject(x,y);
  }
}","public void placeObject(MapObject object,int x,int y){
  ObjectContainer container;
  ProtectContainer protector=ProtectContainer.getInstance();
  Set<ELandscapeType> landscapes=null;
  if (object instanceof MapTreeObject) {
    container=TreeObjectContainer.getInstance();
  }
 else   if (object instanceof MapStoneObject) {
    container=new StoneObjectContainer((MapStoneObject)object);
  }
 else   if (object instanceof MovableObject) {
    container=new MovableObjectContainer((MovableObject)object,x,y);
  }
 else   if (object instanceof StackObject) {
    container=new StackContainer((StackObject)object);
  }
 else   if (object instanceof BuildingObject) {
    container=new BuildingContainer((BuildingObject)object,new ShortPoint2D(x,y));
    landscapes=((BuildingObject)object).getType().getGroundTypes();
    protector=new ProtectLandscapeConstraint(((BuildingObject)object).getType());
  }
 else   if (object instanceof MapDecorationObject) {
    container=new MapObjectContainer((MapDecorationObject)object);
  }
 else {
    return;
  }
  boolean allowed=true;
  ShortPoint2D start=new ShortPoint2D(x,y);
  for (  RelativePoint p : container.getProtectedArea()) {
    ShortPoint2D abs=p.calculatePoint(start);
    if (!contains(abs.x,abs.y) || objects[abs.x][abs.y] != null || !landscapeAllowsObjects(getLandscape(abs.x,abs.y)) || (landscapes != null && !landscapes.contains(getLandscape(abs.x,abs.y)))) {
      allowed=false;
    }
  }
  if (allowed) {
    for (    RelativePoint p : container.getProtectedArea()) {
      ShortPoint2D abs=p.calculatePoint(start);
      objects[abs.x][abs.y]=protector;
      undoDelta.removeObject(abs.x,abs.y);
    }
    objects[x][y]=container;
    undoDelta.removeObject(x,y);
  }
}"
55754,"public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isBlocked(startX,startY))   return;
  short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}","public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isBlocked(startX,startY)) {
    return;
  }
  short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}"
55755,"/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param containingProvider2
 * @param grid2
 * @param blockedX
 * @param blockedY
 * @param partition
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,new ITraversingVisitor(){
    @Override public boolean visit(    int x,    int y){
      return grid.getPartitionAt((short)x,(short)y) == partition;
    }
  }
,true);
}","/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param grid
 * @param containingProvider
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,new IBorderVisitor(){
    @Override public boolean visit(    int insideX,    int insideY,    int outsideX,    int outsideY){
      return grid.getPartitionAt((short)outsideX,(short)outsideY) == partition;
    }
  }
,true);
}"
55756,"@Override public boolean visit(int x,int y){
  return grid.getPartitionAt((short)x,(short)y) == partition;
}","@Override public boolean visit(int insideX,int insideY,int outsideX,int outsideY){
  return grid.getPartitionAt((short)outsideX,(short)outsideY) == partition;
}"
55757,"private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  ITraversingVisitor visitor=new ITraversingVisitor(){
    @Override public boolean visit(    int x,    int y){
      grid.setPartitionAt(x,y,newPartition);
      return true;
    }
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}","private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  IAreaVisitor visitor=new IAreaVisitor(){
    @Override public boolean visit(    int x,    int y){
      grid.setPartitionAt(x,y,newPartition);
      return true;
    }
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}"
55758,"/** 
 * Traverses a connected area and calls the given visitor for every position.
 * @param containingProvider {@link IContainingProvider} defining what's part of the area and what isn't.
 * @param visitor The visitor that will be called on every position in the connected area reachable from the given start position.
 * @param startPos A start position somewhere in the area.
 * @param width The width of the area. So the maximum x value may be width - 1;
 * @param height The height of the area. So the maximum y value may be height - 1;
 * @return true if the traversing finished<br>false if the visitor returned false at any position and therefore caused the traversing to be canceled.
 */
public static boolean traverseArea(IContainingProvider containingProvider,ITraversingVisitor visitor,ShortPoint2D startPos,int width,int height){
  LinkedList<ShortPoint2D> stack=new LinkedList<ShortPoint2D>();
  stack.push(startPos);
  BitSet touched=new BitSet(width * height);
  touched.set(startPos.x + startPos.y * width);
  while (!stack.isEmpty()) {
    ShortPoint2D currPos=stack.poll();
    if (!visitor.visit(currPos.x,currPos.y)) {
      return false;
    }
    for (    EDirection dir : EDirection.VALUES) {
      int nextX=dir.gridDeltaX + currPos.x;
      int nextY=dir.gridDeltaY + currPos.y;
      if (0 <= nextX && nextX <= width && 0 <= nextY && nextY <= height) {
        int nextIdx=nextX + nextY * width;
        if (!touched.get(nextIdx) && containingProvider.contains(nextX,nextY)) {
          stack.push(new ShortPoint2D(nextX,nextY));
          touched.set(nextIdx);
        }
      }
    }
  }
  return true;
}","/** 
 * Traverses a connected area and calls the given visitor for every position.
 * @param containingProvider {@link IContainingProvider} defining what's part of the area and what isn't.
 * @param visitor The visitor that will be called on every position in the connected area reachable from the given start position.
 * @param startPos A start position somewhere in the area.
 * @param width The width of the area. So the maximum x value may be width - 1;
 * @param height The height of the area. So the maximum y value may be height - 1;
 * @return true if the traversing finished<br>false if the visitor returned false at any position and therefore caused the traversing to be canceled.
 */
public static boolean traverseArea(IContainingProvider containingProvider,IAreaVisitor visitor,ShortPoint2D startPos,int width,int height){
  LinkedList<ShortPoint2D> stack=new LinkedList<ShortPoint2D>();
  stack.push(startPos);
  BitSet touched=new BitSet(width * height);
  touched.set(startPos.x + startPos.y * width);
  while (!stack.isEmpty()) {
    ShortPoint2D currPos=stack.poll();
    if (!visitor.visit(currPos.x,currPos.y)) {
      return false;
    }
    for (    EDirection dir : EDirection.VALUES) {
      int nextX=dir.gridDeltaX + currPos.x;
      int nextY=dir.gridDeltaY + currPos.y;
      if (0 <= nextX && nextX <= width && 0 <= nextY && nextY <= height) {
        int nextIdx=nextX + nextY * width;
        if (!touched.get(nextIdx) && containingProvider.contains(nextX,nextY)) {
          stack.push(new ShortPoint2D(nextX,nextY));
          touched.set(nextIdx);
        }
      }
    }
  }
  return true;
}"
55759,"public static boolean traverseBorder(final IContainingProvider containingProvider,final ShortPoint2D startPos,final ITraversingVisitor visitor,boolean visitOutside){
  return traverseBorder(containingProvider,startPos,visitor,visitOutside,new MutableInt());
}","/** 
 * Traverses the border of an area defined by the given   {@link IContainingProvider} starting at the two neighbors insideStartPosition andoutsideStartPosition. The given visitor is called for every position on the outside of the area.<br>
 * @param containingProvider {@link IContainingProvider} defining the position that are in and the ones that are outside the area.
 * @param insideStartPosition The inside start position for the traversing. This position must be in the area but at the border!
 * @param outsideStartPosition The outside start position for the traversing. This position must be outside the area but at the border and a direct neighbor of insideStartPosition
 * @param visitor The visitor that will be called for every border position (a border position is a position outside the border!).
 * @param visitOutside If true the positions on the outside will be visited.<br> If false the inside positions will be visited.
 * @param traversedPositions This object will contain the number of traversed positions after the call.
 * @return true if the whole border has been traversed.<br>false if the traversing has been canceled by the  {@link IBorderVisitor}'s visit() method.
 */
public static boolean traverseBorder(IContainingProvider containingProvider,ShortPoint2D insideStartPosition,ShortPoint2D outsideStartPosition,final IBorderVisitor visitor,boolean visitOutside,MutableInt traversedPositions){
  final int startInsideX=insideStartPosition.x;
  final int startInsideY=insideStartPosition.y;
  final int startOutsideX=outsideStartPosition.x;
  final int startOutsideY=outsideStartPosition.y;
  if (!visitor.visit(startInsideX,startInsideY,startOutsideX,startOutsideY)) {
    traversedPositions.value=1;
    return false;
  }
  int insideX=startInsideX;
  int insideY=startInsideY;
  int outsideX=startOutsideX;
  int outsideY=startOutsideY;
  int traversedPositionsCounter=1;
  do {
    traversedPositionsCounter++;
    EDirection outInDir=EDirection.getDirection(insideX - outsideX,insideY - outsideY);
    EDirection neighborDir=outInDir.getNeighbor(-1);
    int neighborX=neighborDir.gridDeltaX + outsideX;
    int neighborY=neighborDir.gridDeltaY + outsideY;
    if (containingProvider.contains(neighborX,neighborY)) {
      insideX=neighborX;
      insideY=neighborY;
      if (!visitOutside && !visitor.visit(insideX,insideY,outsideX,outsideY)) {
        traversedPositions.value=traversedPositionsCounter;
        return false;
      }
    }
 else {
      outsideX=neighborX;
      outsideY=neighborY;
      if (visitOutside && !visitor.visit(insideX,insideY,outsideX,outsideY)) {
        traversedPositions.value=traversedPositionsCounter;
        return false;
      }
    }
  }
 while (insideX != startInsideX || insideY != startInsideY || outsideX != startOutsideX || outsideY != startOutsideY);
  traversedPositions.value=traversedPositionsCounter;
  return true;
}"
55760,"protected Path findWayAroundObstacle(ShortPoint2D position,Path path){
  if (!path.hasOverNextStep()) {
    return path;
  }
  EDirection direction=EDirection.getApproxDirection(position,path.getOverNextPos());
  AbstractMovableGrid grid=movable.grid;
  EDirection leftDir=direction.getNeighbor(-1);
  EDirection rightDir=direction.getNeighbor(1);
  ShortPoint2D straightPos=direction.getNextHexPoint(position);
  ShortPoint2D twoStraightPos=direction.getNextHexPoint(position,2);
  ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
  ShortPoint2D leftStraightPos=direction.getNextHexPoint(leftPos);
  ShortPoint2D straightLeftPos=leftDir.getNextHexPoint(straightPos);
  ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
  ShortPoint2D rightStraightPos=direction.getNextHexPoint(rightPos);
  ShortPoint2D straightRightPos=rightDir.getNextHexPoint(straightPos);
  ShortPoint2D overNextPos=path.getOverNextPos();
  LinkedList<ShortPoint2D[]> possiblePaths=new LinkedList<ShortPoint2D[]>();
  if (twoStraightPos.equals(overNextPos)) {
    if (isValidPosition(leftPos) && isValidPosition(leftStraightPos)) {
      possiblePaths.add(new ShortPoint2D[]{leftPos,leftStraightPos});
    }
 else     if (isValidPosition(rightPos) && isValidPosition(rightStraightPos)) {
      possiblePaths.add(new ShortPoint2D[]{rightPos,rightStraightPos});
    }
 else {
    }
  }
  if (leftStraightPos.equals(overNextPos) && isValidPosition(leftPos)) {
    possiblePaths.add(new ShortPoint2D[]{leftPos});
  }
  if (rightStraightPos.equals(overNextPos) && isValidPosition(rightPos)) {
    possiblePaths.add(new ShortPoint2D[]{rightPos});
  }
  if ((straightLeftPos.equals(overNextPos) || straightRightPos.equals(overNextPos)) && isValidPosition(straightPos) && grid.hasNoMovableAt(straightPos.x,straightPos.y)) {
    possiblePaths.add(new ShortPoint2D[]{straightPos});
  }
 else {
  }
  for (  ShortPoint2D[] pathPrefix : possiblePaths) {
    ShortPoint2D firstPosition=pathPrefix[0];
    Movable movable=grid.getMovableAt(firstPosition.x,firstPosition.y);
    if (movable == null || movable.isProbablyPushable(this.movable)) {
      path.goToNextStep();
      return new Path(path,pathPrefix);
    }
  }
  return path;
}","protected Path findWayAroundObstacle(ShortPoint2D position,Path path){
  if (!path.hasOverNextStep()) {
    return path;
  }
  EDirection direction=EDirection.getApproxDirection(position,path.getOverNextPos());
  AbstractMovableGrid grid=movable.grid;
  EDirection rightDir=direction.getNeighbor(-1);
  EDirection leftDir=direction.getNeighbor(1);
  ShortPoint2D straightPos=direction.getNextHexPoint(position);
  ShortPoint2D twoStraightPos=direction.getNextHexPoint(position,2);
  ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
  ShortPoint2D rightStraightPos=direction.getNextHexPoint(rightPos);
  ShortPoint2D straightRightPos=rightDir.getNextHexPoint(straightPos);
  ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
  ShortPoint2D leftStraightPos=direction.getNextHexPoint(leftPos);
  ShortPoint2D straightLeftPos=leftDir.getNextHexPoint(straightPos);
  ShortPoint2D overNextPos=path.getOverNextPos();
  LinkedList<ShortPoint2D[]> possiblePaths=new LinkedList<ShortPoint2D[]>();
  if (twoStraightPos.equals(overNextPos)) {
    if (isValidPosition(rightPos) && isValidPosition(rightStraightPos)) {
      possiblePaths.add(new ShortPoint2D[]{rightPos,rightStraightPos});
    }
 else     if (isValidPosition(leftPos) && isValidPosition(leftStraightPos)) {
      possiblePaths.add(new ShortPoint2D[]{leftPos,leftStraightPos});
    }
 else {
    }
  }
  if (rightStraightPos.equals(overNextPos) && isValidPosition(rightPos)) {
    possiblePaths.add(new ShortPoint2D[]{rightPos});
  }
  if (leftStraightPos.equals(overNextPos) && isValidPosition(leftPos)) {
    possiblePaths.add(new ShortPoint2D[]{leftPos});
  }
  if ((straightRightPos.equals(overNextPos) || straightLeftPos.equals(overNextPos)) && isValidPosition(straightPos) && grid.hasNoMovableAt(straightPos.x,straightPos.y)) {
    possiblePaths.add(new ShortPoint2D[]{straightPos});
  }
 else {
  }
  for (  ShortPoint2D[] pathPrefix : possiblePaths) {
    ShortPoint2D firstPosition=pathPrefix[0];
    Movable movable=grid.getMovableAt(firstPosition.x,firstPosition.y);
    if (movable == null || movable.isProbablyPushable(this.movable)) {
      path.goToNextStep();
      return new Path(path,pathPrefix);
    }
  }
  return path;
}"
55761,"@Override protected Path findWayAroundObstacle(ShortPoint2D position,Path path){
  if (state == ESoldierState.SEARCH_FOR_ENEMIES) {
    EDirection direction=EDirection.getDirection(position,path.getNextPos());
    AbstractMovableGrid grid=super.getGrid();
    EDirection leftDir=direction.getNeighbor(-1);
    ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
    EDirection rightDir=direction.getNeighbor(1);
    ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
    if (grid.isFreePosition(leftPos)) {
      return new Path(leftPos);
    }
 else     if (grid.isFreePosition(rightPos)) {
      return new Path(rightPos);
    }
 else {
      EDirection twoLeftDir=direction.getNeighbor(-2);
      ShortPoint2D twoLeftPos=twoLeftDir.getNextHexPoint(position);
      EDirection twoRightDir=direction.getNeighbor(2);
      ShortPoint2D twoRightPos=twoRightDir.getNextHexPoint(position);
      if (grid.isFreePosition(twoLeftPos)) {
        return new Path(twoLeftPos);
      }
 else       if (grid.isFreePosition(twoRightPos)) {
        return new Path(twoRightPos);
      }
 else {
        return path;
      }
    }
  }
 else {
    return super.findWayAroundObstacle(position,path);
  }
}","@Override protected Path findWayAroundObstacle(ShortPoint2D position,Path path){
  if (state == ESoldierState.SEARCH_FOR_ENEMIES) {
    EDirection direction=EDirection.getDirection(position,path.getNextPos());
    EDirection rightDir=direction.getNeighbor(-1);
    ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
    EDirection leftDir=direction.getNeighbor(1);
    ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
    ShortPoint2D freePosition=getRandomFreePosition(rightPos,leftPos);
    if (freePosition != null) {
      return new Path(freePosition);
    }
 else {
      EDirection twoRightDir=direction.getNeighbor(-2);
      ShortPoint2D twoRightPos=twoRightDir.getNextHexPoint(position);
      EDirection twoLeftDir=direction.getNeighbor(2);
      ShortPoint2D twoLeftPos=twoLeftDir.getNextHexPoint(position);
      freePosition=getRandomFreePosition(twoRightPos,twoLeftPos);
      if (freePosition != null) {
        return new Path(freePosition);
      }
 else {
        return path;
      }
    }
  }
 else {
    return super.findWayAroundObstacle(position,path);
  }
}"
55762,"@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  Movable attacker=grid.getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.grid.getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pullNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      requestSoldier(currDefender.place.getSoldierClass());
      pullNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}","@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  if (!OccupyingBuilding.this.isNotDestroyed()) {
    return;
  }
  Movable attacker=grid.getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.grid.getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pullNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      requestSoldier(currDefender.place.getSoldierClass());
      pullNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}"
55763,"@Override public void materialDelivered(RequestStack stack){
  super.grid.requestSoldierable(Barrack.this);
}","@Override public void materialDelivered(RequestStack stack){
  super.grid.requestSoldierable(this);
}"
55764,"public static boolean traverseBorder(final IContainingProvider containingProvider,final ShortPoint2D startPos,final IBorderVisitor visitor,boolean visitOutside){
  return traverseBorder(containingProvider,startPos,visitor,visitOutside,new MutableInt());
}","/** 
 * Traverses the border of an area defined by the given  {@link IContainingProvider} starting at {@link startPos}. The given visitor is called for every position on the outside of the area.<br> If the   {@link startPos} is not surrounded by any position that is not inthe area (meaning startPos is not on the border), the traversing can't be started and the visitor is never called.
 * @param containingProvider {@link IContainingProvider} defining the position that are inand the ones that are outside the area.
 * @param insideStartPosition The inside start position for the traversing. This position must be in the area but at the border!
 * @param outsideStartPosition The outside start position for the traversing. This position must be outside the area but at the border and a neighbor of insideStartPosition
 * @param visitor The visitor that will be called for every border position (a border position is a position outside the border!).
 * @param visitOutside If true the positions on the outside will be visited.<br> If false the inside positions will be visited.
 * @param traversedPositions This object will contain the number of traversed positions after the call.
 * @return true if the whole border has been traversed.<br>false if the traversing has been canceled by the {@link IBorderVisitor}'s visit() method.
 */
public static boolean traverseBorder(IContainingProvider containingProvider,ShortPoint2D insideStartPosition,ShortPoint2D outsideStartPosition,final IBorderVisitor visitor,boolean visitOutside,MutableInt traversedPositions){
  final int startInsideX=insideStartPosition.x;
  final int startInsideY=insideStartPosition.y;
  final int startOutsideX=outsideStartPosition.x;
  final int startOutsideY=outsideStartPosition.y;
  if (!visitor.visit(startInsideX,startInsideY,startOutsideX,startOutsideY)) {
    traversedPositions.value=1;
    return false;
  }
  int insideX=startInsideX;
  int insideY=startInsideY;
  int outsideX=startOutsideX;
  int outsideY=startOutsideY;
  int traversedPositionsCounter=1;
  do {
    traversedPositionsCounter++;
    EDirection outInDir=EDirection.getDirection(insideX - outsideX,insideY - outsideY);
    EDirection neighborDir=outInDir.getNeighbor(-1);
    int neighborX=neighborDir.gridDeltaX + outsideX;
    int neighborY=neighborDir.gridDeltaY + outsideY;
    if (containingProvider.contains(neighborX,neighborY)) {
      insideX=neighborX;
      insideY=neighborY;
      if (!visitOutside && !visitor.visit(insideX,insideY,outsideX,outsideY)) {
        traversedPositions.value=traversedPositionsCounter;
        return false;
      }
    }
 else {
      outsideX=neighborX;
      outsideY=neighborY;
      if (visitOutside && !visitor.visit(insideX,insideY,outsideX,outsideY)) {
        traversedPositions.value=traversedPositionsCounter;
        return false;
      }
    }
  }
 while (insideX != startInsideX || insideY != startInsideY || outsideX != startOutsideX || outsideY != startOutsideY);
  traversedPositions.value=traversedPositionsCounter;
  return true;
}"
55765,"@Override public boolean contains(int x,int y){
  return partitionObjects[partitions[x + y * width]].partitionId == partition;
}","@Override public boolean contains(int x,int y){
  return partitionObjects[partitions[x + y * width]].partitionId == partitionId;
}"
55766,"/** 
 * NOTE: The call to this method is different if the given positions are swapped!
 * @param debugColorSetable
 * @param partitionObjects
 * @param partitions
 * @param width
 * @param startPosition
 * @param checkPosition
 * @param partition
 * @return
 */
private static boolean posNotOnBorder(final Partition[] partitionObjects,final short[] partitions,final short width,final ShortPoint2D startPosition,final ShortPoint2D checkPosition,final short partition,MutableInt partitionSize){
  final short checkPositionX=checkPosition.x;
  final short checkPositionY=checkPosition.y;
  boolean pos2NotOnBorder=BorderTraversingAlgorithm.traverseBorder(new IContainingProvider(){
    @Override public boolean contains(    int x,    int y){
      return partitionObjects[partitions[x + y * width]].partitionId == partition;
    }
  }
,startPosition,new IBorderVisitor(){
    @Override public boolean visit(    int insideX,    int insideY,    int outsideX,    int outsideY){
      return checkPositionX != insideX || checkPositionY != insideY;
    }
  }
,false,partitionSize);
  return pos2NotOnBorder;
}","/** 
 * NOTE: The call to this method is different if the given positions are swapped!
 * @param debugColorSetable
 * @param partitionObjects
 * @param partitions
 * @param width
 * @param insideStartPosition
 * @param checkPosition
 * @param partitionSize
 * @param partition
 * @return
 */
private static boolean posNotOnBorder(final Partition[] partitionObjects,final short[] partitions,final short width,final ShortPoint2D insideStartPosition,final ShortPoint2D outsideStartPosition,final ShortPoint2D checkPosition,final short partitionId,MutableInt partitionSize){
  final short checkPositionX=checkPosition.x;
  final short checkPositionY=checkPosition.y;
  boolean pos2NotOnBorder=BorderTraversingAlgorithm.traverseBorder(new IContainingProvider(){
    @Override public boolean contains(    int x,    int y){
      return partitionObjects[partitions[x + y * width]].partitionId == partitionId;
    }
  }
,insideStartPosition,outsideStartPosition,new IBorderVisitor(){
    @Override public boolean visit(    int insideX,    int insideY,    int outsideX,    int outsideY){
      return checkPositionX != insideX || checkPositionY != insideY;
    }
  }
,false,partitionSize);
  return pos2NotOnBorder;
}"
55767,"/** 
 * Tests if the given positions (that need to lie on the border of the given partition) are connected by the given partition.
 * @param debugColorSetable
 * @param partitionObjects
 * @param partitions
 * @param width
 * @param pos1 The first position.
 * @param pos2 The second position.
 * @param partition The partition of both positions.
 * @return true if both positions are connected by the given partition.<br>false if the positions are not connected.
 */
public static boolean isPartitionDivided(Partition[] partitionObjects,short[] partitions,short width,ShortPoint2D pos1,MutableInt partition1Size,ShortPoint2D pos2,MutableInt partition2Size,short partition){
  return posNotOnBorder(partitionObjects,partitions,width,pos1,pos2,partition,partition1Size) && posNotOnBorder(partitionObjects,partitions,width,pos2,pos1,partition,partition2Size);
}","/** 
 * Tests if the given positions (that need to lie on the border of the given partition) are connected by the given partition.
 * @param debugColorSetable
 * @param partitionObjects
 * @param partitions
 * @param width
 * @param partition1
 * @param partition1Size
 * @param partition2
 * @param partition2Size
 * @return true if both positions are connected by the given partition.<br>false if the positions are not connected.
 */
public static boolean isPartitionDivided(Partition[] partitionObjects,short[] partitions,short width,BorderPartitionInfo partition1,MutableInt partition1Size,BorderPartitionInfo partition2,MutableInt partition2Size){
}"
55768,"public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isBlocked(startX,startY))   return;
  short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}","public static final void checkLandmark(IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D startPos){
  final short startX=startPos.x;
  final short startY=startPos.y;
  if (grid.isBlocked(startX,startY)) {
    return;
  }
  short startPartition=grid.getPartitionAt(startPos.x,startPos.y);
  for (  EDirection currDir : EDirection.VALUES) {
    ShortPoint2D currPos=currDir.getNextHexPoint(startX,startY);
    if (grid.isBlocked(currPos.x,currPos.y)) {
      if (needsRelabel(grid,containingProvider,currPos,startPartition)) {
        relabel(grid,containingProvider,currPos,startPartition);
      }
    }
  }
}"
55769,"/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param containingProvider2
 * @param grid2
 * @param blockedX
 * @param blockedY
 * @param partition
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,new ITraversingVisitor(){
    @Override public boolean visit(    int x,    int y){
      return grid.getPartitionAt((short)x,(short)y) == partition;
    }
  }
,true);
}","/** 
 * Checks if the blocked partition given by the coordinates blockedX and blockedY is surrounded by the given partition.
 * @param grid
 * @param containingProvider
 * @param blockedStartPos
 * @return
 */
private static boolean needsRelabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short partition){
  return BorderTraversingAlgorithm.traverseBorder(containingProvider,blockedStartPos,new IBorderVisitor(){
    @Override public boolean visit(    int insideX,    int insideY,    int outsideX,    int outsideY){
      return grid.getPartitionAt((short)outsideX,(short)outsideY) == partition;
    }
  }
,true);
}"
55770,"@Override public boolean visit(int x,int y){
  return grid.getPartitionAt((short)x,(short)y) == partition;
}","@Override public boolean visit(int insideX,int insideY,int outsideX,int outsideY){
  return grid.getPartitionAt((short)outsideX,(short)outsideY) == partition;
}"
55771,"private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  ITraversingVisitor visitor=new ITraversingVisitor(){
    @Override public boolean visit(    int x,    int y){
      grid.setPartitionAt(x,y,newPartition);
      return true;
    }
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}","private static void relabel(final IEnclosedBlockedAreaFinderGrid grid,IContainingProvider containingProvider,ShortPoint2D blockedStartPos,final short newPartition){
  IAreaVisitor visitor=new IAreaVisitor(){
    @Override public boolean visit(    int x,    int y){
      grid.setPartitionAt(x,y,newPartition);
      return true;
    }
  }
;
  AreaTraversingAlgorithm.traverseArea(containingProvider,visitor,blockedStartPos,grid.getWidth(),grid.getHeight());
}"
55772,"/** 
 * Traverses a connected area and calls the given visitor for every position.
 * @param containingProvider {@link IContainingProvider} defining what's part of the area and what isn't.
 * @param visitor The visitor that will be called on every position in the connected area reachable from the given start position.
 * @param startPos A start position somewhere in the area.
 * @param width The width of the area. So the maximum x value may be width - 1;
 * @param height The height of the area. So the maximum y value may be height - 1;
 * @return true if the traversing finished<br>false if the visitor returned false at any position and therefore caused the traversing to be canceled.
 */
public static boolean traverseArea(IContainingProvider containingProvider,ITraversingVisitor visitor,ShortPoint2D startPos,int width,int height){
  LinkedList<ShortPoint2D> stack=new LinkedList<ShortPoint2D>();
  stack.push(startPos);
  BitSet touched=new BitSet(width * height);
  touched.set(startPos.x + startPos.y * width);
  while (!stack.isEmpty()) {
    ShortPoint2D currPos=stack.poll();
    if (!visitor.visit(currPos.x,currPos.y)) {
      return false;
    }
    for (    EDirection dir : EDirection.VALUES) {
      int nextX=dir.gridDeltaX + currPos.x;
      int nextY=dir.gridDeltaY + currPos.y;
      if (0 <= nextX && nextX <= width && 0 <= nextY && nextY <= height) {
        int nextIdx=nextX + nextY * width;
        if (!touched.get(nextIdx) && containingProvider.contains(nextX,nextY)) {
          stack.push(new ShortPoint2D(nextX,nextY));
          touched.set(nextIdx);
        }
      }
    }
  }
  return true;
}","/** 
 * Traverses a connected area and calls the given visitor for every position.
 * @param containingProvider {@link IContainingProvider} defining what's part of the area and what isn't.
 * @param visitor The visitor that will be called on every position in the connected area reachable from the given start position.
 * @param startPos A start position somewhere in the area.
 * @param width The width of the area. So the maximum x value may be width - 1;
 * @param height The height of the area. So the maximum y value may be height - 1;
 * @return true if the traversing finished<br>false if the visitor returned false at any position and therefore caused the traversing to be canceled.
 */
public static boolean traverseArea(IContainingProvider containingProvider,IAreaVisitor visitor,ShortPoint2D startPos,int width,int height){
  LinkedList<ShortPoint2D> stack=new LinkedList<ShortPoint2D>();
  stack.push(startPos);
  BitSet touched=new BitSet(width * height);
  touched.set(startPos.x + startPos.y * width);
  while (!stack.isEmpty()) {
    ShortPoint2D currPos=stack.poll();
    if (!visitor.visit(currPos.x,currPos.y)) {
      return false;
    }
    for (    EDirection dir : EDirection.VALUES) {
      int nextX=dir.gridDeltaX + currPos.x;
      int nextY=dir.gridDeltaY + currPos.y;
      if (0 <= nextX && nextX <= width && 0 <= nextY && nextY <= height) {
        int nextIdx=nextX + nextY * width;
        if (!touched.get(nextIdx) && containingProvider.contains(nextX,nextY)) {
          stack.push(new ShortPoint2D(nextX,nextY));
          touched.set(nextIdx);
        }
      }
    }
  }
  return true;
}"
55773,"public static boolean traverseBorder(final IContainingProvider containingProvider,final ShortPoint2D startPos,final ITraversingVisitor visitor,boolean visitOutside){
  return traverseBorder(containingProvider,startPos,visitor,visitOutside,new MutableInt());
}","/** 
 * Traverses the border of an area defined by the given   {@link IContainingProvider} starting at the two neighbors insideStartPosition andoutsideStartPosition. The given visitor is called for every position on the outside of the area.<br>
 * @param containingProvider {@link IContainingProvider} defining the position that are in and the ones that are outside the area.
 * @param insideStartPosition The inside start position for the traversing. This position must be in the area but at the border!
 * @param outsideStartPosition The outside start position for the traversing. This position must be outside the area but at the border and a direct neighbor of insideStartPosition
 * @param visitor The visitor that will be called for every border position (a border position is a position outside the border!).
 * @param visitOutside If true the positions on the outside will be visited.<br> If false the inside positions will be visited.
 * @param traversedPositions This object will contain the number of traversed positions after the call.
 * @return true if the whole border has been traversed.<br>false if the traversing has been canceled by the  {@link IBorderVisitor}'s visit() method.
 */
public static boolean traverseBorder(IContainingProvider containingProvider,ShortPoint2D insideStartPosition,ShortPoint2D outsideStartPosition,final IBorderVisitor visitor,boolean visitOutside,MutableInt traversedPositions){
  final int startInsideX=insideStartPosition.x;
  final int startInsideY=insideStartPosition.y;
  final int startOutsideX=outsideStartPosition.x;
  final int startOutsideY=outsideStartPosition.y;
  if (!visitor.visit(startInsideX,startInsideY,startOutsideX,startOutsideY)) {
    traversedPositions.value=1;
    return false;
  }
  int insideX=startInsideX;
  int insideY=startInsideY;
  int outsideX=startOutsideX;
  int outsideY=startOutsideY;
  int traversedPositionsCounter=1;
  do {
    traversedPositionsCounter++;
    EDirection outInDir=EDirection.getDirection(insideX - outsideX,insideY - outsideY);
    EDirection neighborDir=outInDir.getNeighbor(-1);
    int neighborX=neighborDir.gridDeltaX + outsideX;
    int neighborY=neighborDir.gridDeltaY + outsideY;
    if (containingProvider.contains(neighborX,neighborY)) {
      insideX=neighborX;
      insideY=neighborY;
      if (!visitOutside && !visitor.visit(insideX,insideY,outsideX,outsideY)) {
        traversedPositions.value=traversedPositionsCounter;
        return false;
      }
    }
 else {
      outsideX=neighborX;
      outsideY=neighborY;
      if (visitOutside && !visitor.visit(insideX,insideY,outsideX,outsideY)) {
        traversedPositions.value=traversedPositionsCounter;
        return false;
      }
    }
  }
 while (insideX != startInsideX || insideY != startInsideY || outsideX != startOutsideX || outsideY != startOutsideY);
  traversedPositions.value=traversedPositionsCounter;
  return true;
}"
55774,"@Override public void enterPosition(ShortPoint2D position,Movable movable,boolean informFullArea){
  movableGrid.movableEntered(position,movable);
  if (movable.isAttackable()) {
    movableGrid.informMovables(movable,position.x,position.y,informFullArea);
    objectsGrid.informObjectsAboutAttackble(position,movable,informFullArea,!movable.getMovableType().isBowman());
  }
}","@Override public void enterPosition(ShortPoint2D position,Movable movable,boolean informFullArea){
  movableGrid.movableEntered(position,movable);
  notifyAttackers(position,movable,informFullArea);
}"
55775,"private void setStrategy(MovableStrategy newStrategy){
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  this.strategy=newStrategy;
  this.movableAction=EMovableAction.NO_ACTION;
  setState(EMovableState.DOING_NOTHING);
}","private void setStrategy(MovableStrategy newStrategy){
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  this.strategy=newStrategy;
  this.movableAction=EMovableAction.NO_ACTION;
  setState(EMovableState.DOING_NOTHING);
  grid.notifyAttackers(position,this,true);
}"
55776,"/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public abstract void enterPosition(ShortPoint2D position,Movable movable,boolean informFullArea);","/** 
 * Lets the given movable enter the given position.
 * @param position       Position to be entered.
 * @param movable        Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br>If false, only a circle is informed if the given movable is attackable.
 */
public abstract void enterPosition(ShortPoint2D position,Movable movable,boolean informFullArea);"
55777,"/** 
 * Adds a map object to the grid that deletes itself after the given duration.
 * @param position The position to add the map object.
 * @param mapObjectType The  {@link EMapObjectType} of the map object that will be added.
 * @param duration The time (in seconds) the map object will stay on the grid.
 * @param player The  {@link Player} of the map object.
 */
public abstract void addSelfDeletingMapObject(ShortPoint2D position,EMapObjectType mapObjectType,float duration,Player player);","/** 
 * Adds a map object to the grid that deletes itself after the given duration.
 * @param position      The position to add the map object.
 * @param mapObjectType The {@link EMapObjectType} of the map object that will be added.
 * @param duration      The time (in seconds) the map object will stay on the grid.
 * @param player        The {@link Player} of the map object.
 */
public abstract void addSelfDeletingMapObject(ShortPoint2D position,EMapObjectType mapObjectType,float duration,Player player);"
55778,"@Test public void veryHardShouldConquerHard() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_VERY_HARD,EPlayerType.AI_HARD,100 * MINUTES);
}","@Test public void veryHardShouldConquerHard() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_VERY_HARD,EPlayerType.AI_HARD,120 * MINUTES);
}"
55779,"@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  Movable attacker=grid.getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.grid.getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pullNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      requestSoldier(currDefender.place.getSoldierClass());
      pullNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}","@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  if (!OccupyingBuilding.this.isNotDestroyed()) {
    return;
  }
  Movable attacker=grid.getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.grid.getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pullNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      requestSoldier(currDefender.place.getSoldierClass());
      pullNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}"
55780,"@Override public void materialDelivered(RequestStack stack){
  super.grid.requestSoilderable(Barrack.this);
}","@Override public void materialDelivered(RequestStack stack){
  super.grid.requestSoldierable(Barrack.this);
}"
55781,"@Override public void bearerRequestFailed(){
  super.grid.requestSoilderable(this);
}","@Override public void bearerRequestFailed(){
  super.grid.requestSoldierable(this);
}"
55782,"private void handleSoldierCreationRequest(){
  SoilderCreationRequest soilderRequest=soilderCreationRequests.poll();
  if (soilderRequest != null) {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(soilderRequest.getPos());
    if (manageableBearer != null) {
      manageableBearer.becomeSoldier(soilderRequest.getBarrack());
    }
 else {
      soilderCreationRequests.addLast(soilderRequest);
    }
  }
}","private void handleSoldierCreationRequest(){
  SoldierCreationRequest soilderRequest=soldierCreationRequests.poll();
  if (soilderRequest != null) {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(soilderRequest.getPos());
    if (manageableBearer == null || !manageableBearer.becomeSoldier(soilderRequest.getBarrack())) {
      soldierCreationRequests.addLast(soilderRequest);
    }
  }
}"
55783,"private boolean tryToCreateWorker(WorkerCreationRequest workerCreationRequest){
  EMovableType movableType=workerCreationRequest.requestedMovableType();
  EMaterialType tool=movableType.getTool();
  if (tool != EMaterialType.NO_MATERIAL) {
    MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerCreationRequest.getPos());
    if (offer != null) {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(offer.getPos());
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerCreationRequest,offer.getPos());
        return true;
      }
 else {
        materialOffers.addOffer(offer.getPos(),tool);
        return false;
      }
    }
 else {
      workerCreationRequest.setToolProductionRequired(true);
      return false;
    }
  }
 else {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerCreationRequest.getPos());
    if (manageableBearer != null) {
      manageableBearer.becomeWorker(this,workerCreationRequest);
      return true;
    }
 else {
      return false;
    }
  }
}","private boolean tryToCreateWorker(WorkerCreationRequest workerCreationRequest){
  EMovableType movableType=workerCreationRequest.requestedMovableType();
  EMaterialType tool=movableType.getTool();
  if (tool != EMaterialType.NO_MATERIAL) {
    MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerCreationRequest.getPos());
    if (offer != null) {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(offer.getPos());
      if (manageableBearer != null) {
        return manageableBearer.becomeWorker(this,workerCreationRequest,offer.getPos());
      }
 else {
        materialOffers.addOffer(offer.getPos(),tool);
        return false;
      }
    }
 else {
      workerCreationRequest.setToolProductionRequired(true);
      return false;
    }
  }
 else {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerCreationRequest.getPos());
    if (manageableBearer != null) {
      return manageableBearer.becomeWorker(this,workerCreationRequest);
    }
 else {
      return false;
    }
  }
}"
55784,"public final void mergeInto(PartitionManager newManager){
  newManager.bricklayerRequests.addAll(this.bricklayerRequests);
  newManager.diggerRequests.addAll(this.diggerRequests);
  newManager.joblessBearer.addAll(this.joblessBearer);
  newManager.joblessBricklayers.addAll(this.joblessBricklayers);
  newManager.joblessDiggers.addAll(this.joblessDiggers);
  newManager.joblessWorkers.addAll(this.joblessWorkers);
  newManager.materialOffers.addAll(this.materialOffers);
  this.materialsManager.mergeInto(newManager.materialsManager);
  newManager.soilderCreationRequests.addAll(this.soilderCreationRequests);
  newManager.workerCreationRequests.addAll(this.workerCreationRequests);
  newManager.workerRequests.addAll(this.workerRequests);
}","public final void mergeInto(PartitionManager newManager){
  newManager.bricklayerRequests.addAll(this.bricklayerRequests);
  newManager.diggerRequests.addAll(this.diggerRequests);
  newManager.joblessBearer.addAll(this.joblessBearer);
  newManager.joblessBricklayers.addAll(this.joblessBricklayers);
  newManager.joblessDiggers.addAll(this.joblessDiggers);
  newManager.joblessWorkers.addAll(this.joblessWorkers);
  newManager.materialOffers.addAll(this.materialOffers);
  this.materialsManager.mergeInto(newManager.materialsManager);
  newManager.soldierCreationRequests.addAll(this.soldierCreationRequests);
  newManager.workerCreationRequests.addAll(this.workerCreationRequests);
  newManager.workerRequests.addAll(this.workerRequests);
}"
55785,void becomeSoldier(IBarrack barrack);,boolean becomeSoldier(IBarrack barrack);
55786,"void becomeWorker(IWorkerRequester requester,WorkerCreationRequest request,ShortPoint2D offer);","boolean becomeWorker(IWorkerRequester requester,WorkerCreationRequest request,ShortPoint2D offer);"
55787,"boolean isProbablyPushable(Movable pushingMovable){
switch (state) {
case DOING_NOTHING:
    return true;
case PATHING:
  return pushingMovable.path != null && pushingMovable.path.hasNextStep();
default :
return false;
}
}","boolean isProbablyPushable(Movable pushingMovable){
switch (state) {
case DOING_NOTHING:
    return true;
case PATHING:
  return path != null && pushingMovable.path != null && pushingMovable.path.hasNextStep();
default :
return false;
}
}"
55788,"@Override public void becomeSoldier(IBarrack barrack){
  this.barrack=barrack;
  this.state=EBearerState.INIT_BECOME_SOLDIER_JOB;
}","@Override public boolean becomeSoldier(IBarrack barrack){
  if (state == EBearerState.JOBLESS) {
    this.barrack=barrack;
    this.state=EBearerState.INIT_BECOME_SOLDIER_JOB;
    return true;
  }
 else {
    return false;
  }
}"
55789,"@Override public void becomeWorker(IWorkerRequester requester,WorkerCreationRequest workerCreationRequest,ShortPoint2D offer){
  this.workerRequester=requester;
  this.workerCreationRequest=workerCreationRequest;
  this.offer=offer;
  this.state=EBearerState.INIT_CONVERT_WITH_TOOL_JOB;
  this.materialType=workerCreationRequest.requestedMovableType().getTool();
}","@Override public boolean becomeWorker(IWorkerRequester requester,WorkerCreationRequest workerCreationRequest,ShortPoint2D offer){
  if (state == EBearerState.JOBLESS) {
    this.workerRequester=requester;
    this.workerCreationRequest=workerCreationRequest;
    this.offer=offer;
    this.state=EBearerState.INIT_CONVERT_WITH_TOOL_JOB;
    this.materialType=workerCreationRequest.requestedMovableType().getTool();
    return true;
  }
 else {
    return false;
  }
}"
55790,"private static void createReplayOfRemainingTasks(MapLoader newSavegame,ReplayStartInformation replayStartInformation,String newReplayFile,IGameClock gameClock) throws IOException {
  System.out.println(""String_Node_Str"" + newReplayFile + ""String_Node_Str"");
  ReplayStartInformation replayInfo=new ReplayStartInformation(0,newSavegame.getMapName(),newSavegame.getMapId(),replayStartInformation.getPlayerId(),replayStartInformation.getPlayerSettings());
  DataOutputStream dos=new DataOutputStream(ResourceManager.writeConfigurationFile(newReplayFile));
  replayInfo.serialize(dos);
  gameClock.saveRemainingTasks(dos);
  dos.close();
  System.out.println(""String_Node_Str"");
}","private static void createReplayOfRemainingTasks(MapLoader newSavegame,ReplayStartInformation replayStartInformation,String newReplayFile,IGameClock gameClock) throws IOException {
  System.out.println(""String_Node_Str"" + newReplayFile + ""String_Node_Str"");
  ReplayStartInformation replayInfo=new ReplayStartInformation(0,newSavegame.getMapName(),newSavegame.getMapId(),replayStartInformation.getPlayerId(),replayStartInformation.getPlayerSettings());
  DataOutputStream dos=new DataOutputStream(ResourceManager.writeUserFile(newReplayFile));
  replayInfo.serialize(dos);
  gameClock.saveRemainingTasks(dos);
  dos.close();
  System.out.println(""String_Node_Str"");
}"
55791,"boolean isProbablyPushable(Movable pushingMovable){
switch (state) {
case DOING_NOTHING:
    return true;
case PATHING:
  return pushingMovable.path != null && pushingMovable.path.hasNextStep();
default :
return false;
}
}","boolean isProbablyPushable(Movable pushingMovable){
switch (state) {
case DOING_NOTHING:
    return true;
case PATHING:
  return path != null && pushingMovable.path != null && pushingMovable.path.hasNextStep();
default :
return false;
}
}"
55792,"public ELandscapeType[] getGroundtypes(){
  return groundtypes.toArray(new ELandscapeType[groundtypes.size()]);
}","public List<ELandscapeType> getGroundtypes(){
  return groundtypes;
}"
55793,"/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId);","/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,Set<ELandscapeType> landscapeTypes,short partitionId);"
55794,"@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!pausingSupplier.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          EBuildingType buildingType=this.buildingType;
          if (buildingType != null && mapArea != null) {
            algorithm.calculateConstructMarks(mapArea,buildingType.getBuildingAreaBitSet(),buildingType.getGroundtypes(),buildingType.getBlockedTiles(),buildingType.isMine());
          }
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      algorithm.removeConstructionMarks();
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}","@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!pausingSupplier.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          EBuildingType buildingType=this.buildingType;
          if (buildingType != null && mapArea != null) {
            algorithm.calculateConstructMarks(mapArea,buildingType.getBuildingAreaBitSet(),buildingType.getGroundTypes(),buildingType.getBuildingArea(),!buildingType.needsFlattenedGround());
          }
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      algorithm.removeConstructionMarks();
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}"
55795,"public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions,boolean binaryConstructionMarkValues){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,binaryConstructionMarkValues,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,binaryConstructionMarkValues,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,binaryConstructionMarkValues,flattenPositions);
    }
  }
  lastArea=mapArea;
}","public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final Set<ELandscapeType> landscapeTypes,RelativePoint[] flattenPositions,boolean binaryConstructionMarkValues){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,binaryConstructionMarkValues,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,binaryConstructionMarkValues,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,binaryConstructionMarkValues,flattenPositions);
    }
  }
  lastArea=mapArea;
}"
55796,"@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId){
  return isInBounds(x,y) && !flagsGrid.isProtected(x,y) && partitionsGrid.getPartitionIdAt(x,y) == partitionId && isAllowedLandscape(x,y,landscapeTypes);
}","@Override public boolean canUsePositionForConstruction(int x,int y,Set<ELandscapeType> allowedBuildingTypes,short partitionId){
  return isInBounds(x,y) && !flagsGrid.isProtected(x,y) && partitionsGrid.getPartitionIdAt(x,y) == partitionId && allowedBuildingTypes.contains(landscapeGrid.getLandscapeTypeAt(x,y));
}"
55797,"private final void writeObject(ObjectOutputStream oos) throws IOException {
  oos.defaultWriteObject();
  SerializationUtils.writeSparseArray(oos,buildingsGrid);
  int length=objectsGrid.length;
  oos.writeInt(length);
  for (int idx=0; idx < length; idx++) {
    AbstractHexMapObject currObject=objectsGrid[idx];
    if (currObject != null) {
      oos.writeInt(idx);
      while (currObject != null) {
        if (currObject.getObjectType() != EMapObjectType.WORKAREA_MARK) {
          oos.writeObject(currObject);
        }
        currObject=currObject.getNextObject();
      }
      oos.writeObject(null);
    }
  }
  oos.writeInt(-1);
}","private final void writeObject(ObjectOutputStream oos) throws IOException {
  oos.defaultWriteObject();
  SerializationUtils.writeSparseArray(oos,buildingsGrid);
  int length=objectsGrid.length;
  oos.writeInt(length);
  for (int idx=0; idx < length; idx++) {
    AbstractHexMapObject currObject=objectsGrid[idx];
    if (currObject != null) {
      oos.writeInt(idx);
      while (currObject != null) {
        if (currObject.getObjectType().persistent) {
          oos.writeObject(currObject);
        }
        currObject=currObject.getNextObject();
      }
      oos.writeObject(null);
    }
  }
  oos.writeInt(-1);
}"
55798,"@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId){
  return isInBounds(x,y) && !blockedSet.get(x + y * width);
}","@Override public boolean canUsePositionForConstruction(int x,int y,Set<ELandscapeType> landscapeTypes,short partitionId){
  return isInBounds(x,y) && !blockedSet.get(x + y * width);
}"
55799,"@Test public void veryHardShouldConquerHard() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_VERY_HARD,EPlayerType.AI_HARD,82 * MINUTES);
}","@Test public void veryHardShouldConquerHard() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_VERY_HARD,EPlayerType.AI_HARD,95 * MINUTES);
}"
55800,"@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,70 * MINUTES);
}","@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,80 * MINUTES);
}"
55801,public ELandscapeType[] getAllowedLandscapes();,Set<ELandscapeType> getAllowedLandscapes();
55802,"public ELandscapeType[] getGroundtypes(){
  return groundtypes.toArray(new ELandscapeType[groundtypes.size()]);
}","public List<ELandscapeType> getGroundtypes(){
  return groundtypes;
}"
55803,"/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId);","/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,Set<ELandscapeType> landscapeTypes,short partitionId);"
55804,"@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!pausingSupplier.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          EBuildingType buildingType=this.buildingType;
          if (buildingType != null && mapArea != null) {
            algorithm.calculateConstructMarks(mapArea,buildingType.getBuildingAreaBitSet(),buildingType.getGroundtypes(),buildingType.getBlockedTiles(),buildingType.isMine());
          }
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      algorithm.removeConstructionMarks();
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}","@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!pausingSupplier.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          EBuildingType buildingType=this.buildingType;
          if (buildingType != null && mapArea != null) {
            algorithm.calculateConstructMarks(mapArea,buildingType.getBuildingAreaBitSet(),buildingType.getGroundTypes(),buildingType.getBuildingArea(),!buildingType.needsFlattenedGround());
          }
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      algorithm.removeConstructionMarks();
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}"
55805,"public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions,boolean binaryConstructionMarkValues){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,binaryConstructionMarkValues,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,binaryConstructionMarkValues,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,binaryConstructionMarkValues,flattenPositions);
    }
  }
  lastArea=mapArea;
}","public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final Set<ELandscapeType> landscapeTypes,RelativePoint[] flattenPositions,boolean binaryConstructionMarkValues){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,binaryConstructionMarkValues,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,binaryConstructionMarkValues,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,binaryConstructionMarkValues,flattenPositions);
    }
  }
  lastArea=mapArea;
}"
55806,"@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId){
  return isInBounds(x,y) && !flagsGrid.isProtected(x,y) && partitionsGrid.getPartitionIdAt(x,y) == partitionId && isAllowedLandscape(x,y,landscapeTypes);
}","@Override public boolean canUsePositionForConstruction(int x,int y,Set<ELandscapeType> allowedBuildingTypes,short partitionId){
  return isInBounds(x,y) && !flagsGrid.isProtected(x,y) && partitionsGrid.getPartitionIdAt(x,y) == partitionId && allowedBuildingTypes.contains(landscapeGrid.getLandscapeTypeAt(x,y));
}"
55807,"private final void writeObject(ObjectOutputStream oos) throws IOException {
  oos.defaultWriteObject();
  SerializationUtils.writeSparseArray(oos,buildingsGrid);
  int length=objectsGrid.length;
  oos.writeInt(length);
  for (int idx=0; idx < length; idx++) {
    AbstractHexMapObject currObject=objectsGrid[idx];
    if (currObject != null) {
      oos.writeInt(idx);
      while (currObject != null) {
        if (currObject.getObjectType() != EMapObjectType.WORKAREA_MARK) {
          oos.writeObject(currObject);
        }
        currObject=currObject.getNextObject();
      }
      oos.writeObject(null);
    }
  }
  oos.writeInt(-1);
}","private final void writeObject(ObjectOutputStream oos) throws IOException {
  oos.defaultWriteObject();
  SerializationUtils.writeSparseArray(oos,buildingsGrid);
  int length=objectsGrid.length;
  oos.writeInt(length);
  for (int idx=0; idx < length; idx++) {
    AbstractHexMapObject currObject=objectsGrid[idx];
    if (currObject != null) {
      oos.writeInt(idx);
      while (currObject != null) {
        if (currObject.getObjectType().persistent) {
          oos.writeObject(currObject);
        }
        currObject=currObject.getNextObject();
      }
      oos.writeObject(null);
    }
  }
  oos.writeInt(-1);
}"
55808,"@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId){
  return isInBounds(x,y) && !blockedSet.get(x + y * width);
}","@Override public boolean canUsePositionForConstruction(int x,int y,Set<ELandscapeType> landscapeTypes,short partitionId){
  return isInBounds(x,y) && !blockedSet.get(x + y * width);
}"
55809,"@Test public void veryHardShouldConquerHard() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_VERY_HARD,EPlayerType.AI_HARD,82 * MINUTES);
}","@Test public void veryHardShouldConquerHard() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_VERY_HARD,EPlayerType.AI_HARD,95 * MINUTES);
}"
55810,"@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,70 * MINUTES);
}","@Test public void easyShouldConquerVeryEasy() throws MapLoadException {
  holdBattleBetween(EPlayerType.AI_EASY,EPlayerType.AI_VERY_EASY,80 * MINUTES);
}"
55811,public ELandscapeType[] getAllowedLandscapes();,Set<ELandscapeType> getAllowedLandscapes();
55812,"/** 
 * Gives the id of the player of this object.
 * @return -1 if this component has no player (for example a non occupied tile)<br>otherwise: the id of the player of the component.
 */
public byte getPlayerId();","/** 
 * Gives the id of the player of this object.
 * @return -1 if this component has no player (for example a non occupied tile)<br>otherwise: the id of the player of the component.
 */
byte getPlayerId();"
55813,"/** 
 * Sets the content of the main panel.
 * @param content The content to change to.
 */
public void setContent(AbstractContentProvider content){
  activeContent.contentHiding(actionFireable,content);
  ESecondaryTabType tabs=content.getTabs();
  showSecondaryTabs(tabs);
  if (tabs != null) {
switch (tabs) {
case BUILD:
      setButtonsActive(buildButtons,content);
    break;
case GOODS:
  setButtonsActive(goodsButtons,content);
break;
case SETTLERS:
setButtonsActive(settlerButtons,content);
break;
case NONE:
default :
break;
}
}
contentContainer.removeAll();
contentContainer.addChild(content.getPanel(),0,0,1,1);
activeContent=content;
sendMapPositionChange();
activeContent.contentShowing(actionFireable);
}","/** 
 * Sets the content of the main panel.
 * @param content The content to change to.
 */
public synchronized void setContent(AbstractContentProvider content){
  activeContent.contentHiding(actionFireable,content);
  ESecondaryTabType tabs=content.getTabs();
  showSecondaryTabs(tabs);
  if (tabs != null) {
switch (tabs) {
case BUILD:
      setButtonsActive(buildButtons,content);
    break;
case GOODS:
  setButtonsActive(goodsButtons,content);
break;
case SETTLERS:
setButtonsActive(settlerButtons,content);
break;
case NONE:
default :
break;
}
}
contentContainer.removeAll();
contentContainer.addChild(content.getPanel(),0,0,1,1);
activeContent=content;
sendMapPositionChange();
activeContent.contentShowing(actionFireable);
}"
55814,"public IAction catchAction(IAction action){
  action=activeContent.catchAction(action);
  EActionType type=action.getActionType();
switch (type) {
case MOVE_TO:
case SET_DOCK:
case SET_TRADING_WAYPOINT:
case SET_WORK_AREA:
    if (activeContent instanceof SelectPointMessage) {
      goBack();
    }
  return action;
case ASK_SET_DOCK:
goBackContent=activeContent;
setContent(new SelectPointMessage(Labels.getString(""String_Node_Str"")){
@Override public PointAction getSelectAction(ShortPoint2D position){
  return new PointAction(EActionType.SET_DOCK,position);
}
}
);
return null;
case ASK_SET_WORK_AREA:
goBackContent=activeContent;
setContent(new SelectPointMessage(Labels.getString(""String_Node_Str"")){
@Override public PointAction getSelectAction(ShortPoint2D position){
return new PointAction(EActionType.SET_WORK_AREA,position);
}
}
);
return null;
case ASK_SET_TRADING_WAYPOINT:
goBackContent=activeContent;
final EWaypointType wp=((AskSetTradingWaypointAction)action).getWaypoint();
setContent(new SelectPointMessage(Labels.getString(""String_Node_Str"" + wp)){
@Override public PointAction getSelectAction(ShortPoint2D position){
return new SetTradingWaypointAction(wp,position);
}
}
);
return null;
case ASK_DESTROY:
goBackContent=activeContent;
setContent(new MessageContent(Labels.getString(""String_Node_Str""),Labels.getName(EActionType.DESTROY),new Action(EActionType.DESTROY),Labels.getString(""String_Node_Str""),new Action(EActionType.ABORT)){
@Override public boolean isForSelection(){
return true;
}
}
);
return null;
case ABORT:
goBack();
return action;
case EXECUTABLE:
((ExecutableAction)action).execute();
return null;
default :
return action;
}
}","public synchronized IAction catchAction(IAction action){
  action=activeContent.catchAction(action);
  EActionType type=action.getActionType();
switch (type) {
case MOVE_TO:
case SET_DOCK:
case SET_TRADING_WAYPOINT:
case SET_WORK_AREA:
    if (activeContent instanceof SelectPointMessage) {
      goBack();
    }
  return action;
case ASK_SET_DOCK:
goBackContent=activeContent;
setContent(new SelectPointMessage(Labels.getString(""String_Node_Str"")){
@Override public PointAction getSelectAction(ShortPoint2D position){
  return new PointAction(EActionType.SET_DOCK,position);
}
}
);
return null;
case ASK_SET_WORK_AREA:
goBackContent=activeContent;
setContent(new SelectPointMessage(Labels.getString(""String_Node_Str"")){
@Override public PointAction getSelectAction(ShortPoint2D position){
return new PointAction(EActionType.SET_WORK_AREA,position);
}
}
);
return null;
case ASK_SET_TRADING_WAYPOINT:
goBackContent=activeContent;
final EWaypointType wp=((AskSetTradingWaypointAction)action).getWaypoint();
setContent(new SelectPointMessage(Labels.getString(""String_Node_Str"" + wp)){
@Override public PointAction getSelectAction(ShortPoint2D position){
return new SetTradingWaypointAction(wp,position);
}
}
);
return null;
case ASK_DESTROY:
goBackContent=activeContent;
setContent(new MessageContent(Labels.getString(""String_Node_Str""),Labels.getName(EActionType.DESTROY),new Action(EActionType.DESTROY),Labels.getString(""String_Node_Str""),new Action(EActionType.ABORT)){
@Override public boolean isForSelection(){
return true;
}
}
);
return null;
case ABORT:
goBack();
return action;
case EXECUTABLE:
((ExecutableAction)action).execute();
return null;
default :
return action;
}
}"
55815,"@Override public void refreshSelection(){
  connector.setSelection(null);
  connector.setSelection(currentSelection);
}","@Override public void refreshSelection(){
  if (!currentSelection.isEmpty()) {
    SelectionSet newSelection=new SelectionSet();
    for (    ISelectable selected : currentSelection) {
      if (selected.isSelected() && canSelectPlayer(selected.getPlayerId())) {
        newSelection.add(selected);
      }
    }
    if (currentSelection.getSize() != newSelection.getSize() || currentSelection.getSelectionType() != newSelection.getSelectionType()) {
      setSelection(newSelection);
    }
  }
}"
55816,"public GuiInterface(IMapInterfaceConnector connector,IGameClock clock,ITaskScheduler taskScheduler,IGuiInputGrid grid,IGameStoppable gameStoppable,byte player,boolean multiplayer){
  this.connector=connector;
  this.clock=clock;
  this.taskScheduler=taskScheduler;
  this.grid=grid;
  this.gameStoppable=gameStoppable;
  this.playerId=player;
  this.multiplayer=multiplayer;
  this.constructionMarksCalculator=new ConstructionMarksThread(grid.getConstructionMarksGrid(),clock,player);
  grid.getPlayer(player).setMessenger(connector);
  clock.setTaskExecutor(new GuiTaskExecutor(grid,this,playerId));
  connector.addListener(this);
}","public GuiInterface(IMapInterfaceConnector connector,IGameClock clock,ITaskScheduler taskScheduler,IGuiInputGrid grid,IGameStoppable gameStoppable,byte player,boolean multiplayer){
  this.connector=connector;
  this.clock=clock;
  this.taskScheduler=taskScheduler;
  this.grid=grid;
  this.gameStoppable=gameStoppable;
  this.playerId=player;
  this.multiplayer=multiplayer;
  this.constructionMarksCalculator=new ConstructionMarksThread(grid.getConstructionMarksGrid(),clock,player);
  this.refreshSelectionTimer=new Timer(""String_Node_Str"");
  this.refreshSelectionTimer.schedule(new TimerTask(){
    @Override public void run(){
      refreshSelection();
    }
  }
,1000,1000);
  grid.getPlayer(player).setMessenger(connector);
  clock.setTaskExecutor(new GuiTaskExecutor(grid,this,playerId));
  connector.addListener(this);
}"
55817,"/** 
 * Sets the selection.
 * @param selection The selected items. Not null!
 */
private void setSelection(SelectionSet selection){
  currentSelection.clear();
  selection.setSelected(true);
  this.connector.setSelection(selection);
  this.currentSelection=selection;
}","/** 
 * Sets the selection.
 * @param selection The selected items. Not null!
 */
private void setSelection(SelectionSet selection){
  currentSelection.setSelected(false);
  selection.setSelected(true);
  connector.setSelection(selection);
  currentSelection=selection;
}"
55818,"/** 
 * Shuts down used threads.
 */
public void stop(){
  constructionMarksCalculator.cancel();
  connector.removeListener(this);
}","/** 
 * Shuts down used threads.
 */
public void stop(){
  constructionMarksCalculator.cancel();
  connector.removeListener(this);
  refreshSelectionTimer.cancel();
}"
55819,"private void selectPointType(PointAction action){
  final ShortPoint2D actionPosition=action.getPosition();
  final IGuiMovable selectedMovable=getSelectableMovable(actionPosition.x,actionPosition.y);
  if (selectedMovable == null) {
    setSelection(new SelectionSet());
    return;
  }
  EMovableType selectedType=selectedMovable.getMovableType();
  Set<EMovableType> selectableTypes;
  if (selectedType.isSwordsman()) {
    selectableTypes=EMovableType.swordsmen;
  }
 else   if (selectedType.isPikeman()) {
    selectableTypes=EMovableType.pikemen;
  }
 else   if (selectedType.isBowman()) {
    selectableTypes=EMovableType.bowmen;
  }
 else {
    selectableTypes=EnumSet.of(selectedType);
  }
  final List<ISelectable> selected=new LinkedList<>();
  for (  final ShortPoint2D pos : new MapCircle(actionPosition,SELECT_BY_TYPE_RADIUS)) {
    final IGuiMovable movable=grid.getMovable(pos.x,pos.y);
    if (movable != null && selectableTypes.contains(movable.getMovableType()) && canSelectPlayer(movable.getPlayerId())) {
      selected.add(movable);
    }
  }
  setSelection(new SelectionSet(selected));
}","private void selectPointType(PointAction action){
  final ShortPoint2D actionPosition=action.getPosition();
  final IGuiMovable selectedMovable=getSelectableMovable(actionPosition.x,actionPosition.y);
  if (selectedMovable == null) {
    setSelection(new SelectionSet());
    return;
  }
  EMovableType selectedType=selectedMovable.getMovableType();
  byte selectedPlayerId=selectedMovable.getPlayerId();
  Set<EMovableType> selectableTypes;
  if (selectedType.isSwordsman()) {
    selectableTypes=EMovableType.swordsmen;
  }
 else   if (selectedType.isPikeman()) {
    selectableTypes=EMovableType.pikemen;
  }
 else   if (selectedType.isBowman()) {
    selectableTypes=EMovableType.bowmen;
  }
 else {
    selectableTypes=EnumSet.of(selectedType);
  }
  final List<ISelectable> selected=new LinkedList<>();
  for (  final ShortPoint2D pos : new MapCircle(actionPosition,SELECT_BY_TYPE_RADIUS)) {
    final IGuiMovable movable=grid.getMovable(pos.x,pos.y);
    if (movable != null && selectableTypes.contains(movable.getMovableType()) && selectedPlayerId == movable.getPlayerId()) {
      selected.add(movable);
    }
  }
  setSelection(new SelectionSet(selected));
}"
55820,"/** 
 * This methods decides if the given   {@link ISelectable} can be added to this selection set or not.
 * @param selectable
 */
public synchronized void add(ISelectable selectable){
  ESelectionType selectionType=selectable.getSelectionType();
  if (selectionType.priority < this.selectionType.priority) {
    return;
  }
 else   if (selectionType.priority > this.selectionType.priority) {
    clear();
    this.selectionType=selectionType;
  }
  if (selectionType.maxSelected > set.size()) {
    set.add(selectable);
  }
}","/** 
 * This methods decides if the given   {@link ISelectable} can be added to this selection set or not.
 * @param selectable
 */
public synchronized void add(ISelectable selectable){
  ESelectionType selectionType=selectable.getSelectionType();
  if (selectionType.priority < this.selectionType.priority) {
    return;
  }
 else   if (selectionType.priority > this.selectionType.priority) {
    setSelected(false);
    this.set.clear();
    this.selectionType=selectionType;
  }
  if (selectionType.maxSelected > set.size()) {
    set.add(selectable);
  }
}"
55821,"@Override public void kill(){
  if (this.state == EBuildingState.DESTROYED) {
    return;
  }
  System.out.println(""String_Node_Str"");
  if (grid != null) {
    grid.removeBuildingAt(pos);
    grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.BUILDING_DECONSTRUCTION_SMOKE,BUILDING_DESTRUCTION_SMOKE_DURATION,player);
    placeAdditionalMapObjects(grid,pos,false);
    showFlag(false);
    placeReusableMaterials();
    killedEvent();
  }
  releaseRequestStacks();
  allBuildings.remove(this);
  this.state=EBuildingState.DESTROYED;
}","@Override public void kill(){
  if (this.state == EBuildingState.DESTROYED) {
    return;
  }
  System.out.println(""String_Node_Str"");
  if (grid != null) {
    grid.removeBuildingAt(pos);
    grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.BUILDING_DECONSTRUCTION_SMOKE,BUILDING_DESTRUCTION_SMOKE_DURATION,player);
    placeAdditionalMapObjects(grid,pos,false);
    showFlag(false);
    placeReusableMaterials();
    killedEvent();
  }
  releaseRequestStacks();
  allBuildings.remove(this);
  this.state=EBuildingState.DESTROYED;
  this.selected=false;
}"
55822,"/** 
 * kills this movable.
 */
@Override public final void kill(){
  if (state == EMovableState.DEAD) {
    return;
  }
  grid.leavePosition(this.position,this);
  this.health=-200;
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  this.state=EMovableState.DEAD;
  movablesByID.remove(this.getID());
  allMovables.remove(this);
  grid.addSelfDeletingMapObject(position,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,player);
}","/** 
 * kills this movable.
 */
@Override public final void kill(){
  if (state == EMovableState.DEAD) {
    return;
  }
  grid.leavePosition(this.position,this);
  this.health=-200;
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  this.state=EMovableState.DEAD;
  this.selected=false;
  movablesByID.remove(this.getID());
  allMovables.remove(this);
  grid.addSelfDeletingMapObject(position,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,player);
}"
55823,"private void dropCurrentMaterial(){
  EMaterialType material=movable.getMaterial();
  if (material.isDroppable()) {
    super.getGrid().dropMaterial(movable.getPos(),material,true,false);
    super.setMaterial(EMaterialType.NO_MATERIAL);
  }
}","private void dropCurrentMaterial(){
  EMaterialType material=movable.getMaterial();
  if (material.isDroppable()) {
    super.getGrid().dropMaterial(movable.getPos(),material,true,false);
  }
  super.setMaterial(EMaterialType.NO_MATERIAL);
}"
55824,"@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  return building != null;
}","@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  return isJobless() || building != null;
}"
55825,"@Override public void buildingDestroyed(){
  super.setVisible(true);
  reportAsJobless();
  dropCurrentMaterial();
  clearMark();
}","@Override public void buildingDestroyed(){
  super.setVisible(true);
  super.abortPath();
  reportAsJobless();
  dropCurrentMaterial();
  clearMark();
}"
55826,"public LinkedList<Tuple<Short,ShortPoint2D>> getPartitionsList(){
  LinkedList<Tuple<Short,ShortPoint2D>> resultList=new LinkedList<Tuple<Short,ShortPoint2D>>();
  resultList.addAll(partitionsList);
  if (resultList.size() >= 2 && resultList.getFirst().e1.equals(resultList.getLast().e1)) {
    resultList.removeFirst();
  }
  return resultList;
}","public LinkedList<Tuple<Short,ShortPoint2D>> getPartitionsList(){
  LinkedList<Tuple<Short,ShortPoint2D>> resultList=new LinkedList<Tuple<Short,ShortPoint2D>>();
  resultList.addAll(partitionsList);
  if (resultList.size() >= 2 && resultList.getFirst().e1.equals(resultList.getLast().e1) && lastPartititon != -1) {
    resultList.removeFirst();
  }
  return resultList;
}"
55827,"private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (workerCreationRequest != null) {
    workerRequester.workerCreationRequestFailed(workerCreationRequest);
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case DROPPING:
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(workerCreationRequest);
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getGrid().dropMaterial(movable.getPos(),materialType,true,false);
}
offer=null;
request=null;
materialType=null;
workerCreationRequest=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportJobless();
}
}","private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (workerCreationRequest != null) {
    workerRequester.workerCreationRequestFailed(workerCreationRequest);
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case DROPPING:
if (request != null) {
boolean offerMaterial=droppingMaterial();
super.setMaterial(EMaterialType.NO_MATERIAL);
super.getGrid().dropMaterial(super.getPos(),materialType,offerMaterial,false);
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(workerCreationRequest);
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getGrid().dropMaterial(movable.getPos(),materialType,true,false);
}
offer=null;
request=null;
materialType=null;
workerCreationRequest=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportJobless();
}
}"
55828,"@Override public boolean droppingMaterial(){
  if (request != null) {
    if (request.isActive() && request.getPos().equals(movable.getPos())) {
      request.deliveryFulfilled();
      return false;
    }
 else {
      request.deliveryAborted();
      request=null;
    }
  }
  return true;
}","@Override public boolean droppingMaterial(){
  if (request != null) {
    if (request.isActive() && request.getPos().equals(movable.getPos())) {
      request.deliveryFulfilled();
      request=null;
      return false;
    }
 else {
      request.deliveryAborted();
      request=null;
    }
  }
  return true;
}"
55829,"private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (workerCreationRequest != null) {
    workerRequester.workerCreationRequestFailed(workerCreationRequest);
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case DROPPING:
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(workerCreationRequest);
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getGrid().dropMaterial(movable.getPos(),materialType,true,false);
}
offer=null;
request=null;
materialType=null;
workerCreationRequest=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportJobless();
}
}","private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (workerCreationRequest != null) {
    workerRequester.workerCreationRequestFailed(workerCreationRequest);
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case DROPPING:
if (request != null) {
boolean offerMaterial=droppingMaterial();
super.setMaterial(EMaterialType.NO_MATERIAL);
super.getGrid().dropMaterial(super.getPos(),materialType,offerMaterial,false);
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(workerCreationRequest);
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getGrid().dropMaterial(movable.getPos(),materialType,true,false);
}
offer=null;
request=null;
materialType=null;
workerCreationRequest=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportJobless();
}
}"
55830,"@Override public boolean droppingMaterial(){
  if (request != null) {
    if (request.isActive() && request.getPos().equals(movable.getPos())) {
      request.deliveryFulfilled();
      return false;
    }
 else {
      request.deliveryAborted();
      request=null;
    }
  }
  return true;
}","@Override public boolean droppingMaterial(){
  if (request != null) {
    if (request.isActive() && request.getPos().equals(movable.getPos())) {
      request.deliveryFulfilled();
      request=null;
      return false;
    }
 else {
      request.deliveryAborted();
      request=null;
    }
  }
  return true;
}"
55831,"private void selectPointType(PointAction action){
  final ShortPoint2D actionPosition=action.getPosition();
  final IGuiMovable centerSelectable=getSelectableMovable(actionPosition.x,actionPosition.y);
  if (centerSelectable == null) {
    setSelection(new SelectionSet());
    return;
  }
  final List<ISelectable> selected=new LinkedList<ISelectable>();
  selected.add(centerSelectable);
  for (  final ShortPoint2D pos : new MapCircle(actionPosition,SELECT_BY_TYPE_RADIUS)) {
    final IGuiMovable movable=grid.getMovable(pos.x,pos.y);
    if (movable != null && movable.getMovableType() == centerSelectable.getMovableType() && canSelectPlayer(movable.getPlayerId())) {
      selected.add(movable);
    }
  }
  setSelection(new SelectionSet(selected));
}","private void selectPointType(PointAction action){
  final ShortPoint2D actionPosition=action.getPosition();
  final IGuiMovable centerSelectable=getSelectableMovable(actionPosition.x,actionPosition.y);
  if (centerSelectable == null) {
    setSelection(new SelectionSet());
    return;
  }
  final List<ISelectable> selected=new LinkedList<ISelectable>();
  for (  final ShortPoint2D pos : new MapCircle(actionPosition,SELECT_BY_TYPE_RADIUS)) {
    final IGuiMovable movable=grid.getMovable(pos.x,pos.y);
    if (movable != null && movable.getMovableType() == centerSelectable.getMovableType() && canSelectPlayer(movable.getPlayerId())) {
      selected.add(movable);
    }
  }
  setSelection(new SelectionSet(selected));
}"
55832,"private void goToDiggablePosition(){
  super.getGrid().setMarked(movable.getPos(),false);
  ShortPoint2D diggablePos=getDiggablePosition();
  if (diggablePos != null) {
    if (super.goToPos(diggablePos)) {
      state=EDiggerState.GOING_TO_POS;
      super.getGrid().setMarked(diggablePos,true);
    }
 else {
      reportJobless();
    }
  }
 else {
    reportJobless();
  }
}","private void goToDiggablePosition(){
  super.getGrid().setMarked(movable.getPos(),false);
  ShortPoint2D diggablePos=getDiggablePosition();
  if (diggablePos != null) {
    if (super.goToPos(diggablePos)) {
      state=EDiggerState.GOING_TO_POS;
      super.getGrid().setMarked(diggablePos,true);
    }
 else {
      reportJobless();
    }
  }
 else   if (allPositionsFlattened()) {
    reportJobless();
  }
}"
55833,"public void releaseSoldier(ESoldierType soldierType){
  Iterator<SoldierRequest> searchedSoldiersIterator=searchedSoldiers.iterator();
  while (searchedSoldiersIterator.hasNext()) {
    if (searchedSoldiersIterator.next().soldierType == soldierType) {
      searchedSoldiersIterator.remove();
    }
  }
  for (  Entry<IBuildingOccupyableMovable,SoldierRequest> commingSoldierEntry : commingSoldiers.entrySet()) {
    if (commingSoldierEntry.getValue().soldierType == soldierType) {
      commingSoldierEntry.getKey().leaveOccupyableBuilding(super.getDoor());
      emptyPlaces.add(commingSoldierEntry.getValue().place);
      commingSoldiers.remove(commingSoldierEntry.getKey());
      return;
    }
  }
  for (  TowerOccupier occupier : sortedOccupiers) {
    if (occupier.soldier.getMovableType().getSoldierType() == soldierType && !toBeReleasedOccupiers.contains(occupier)) {
      toBeReleasedOccupiers.add(occupier);
      return;
    }
  }
}","public void releaseSoldier(ESoldierType soldierType){
  Iterator<SoldierRequest> searchedSoldiersIterator=searchedSoldiers.iterator();
  while (searchedSoldiersIterator.hasNext()) {
    SoldierRequest soldierRequest=searchedSoldiersIterator.next();
    if (soldierRequest.soldierType == soldierType) {
      searchedSoldiersIterator.remove();
      emptyPlaces.add(soldierRequest.place);
    }
  }
  for (  Entry<IBuildingOccupyableMovable,SoldierRequest> commingSoldierEntry : commingSoldiers.entrySet()) {
    if (commingSoldierEntry.getValue().isOfTypeOrClass(soldierType)) {
      commingSoldierEntry.getKey().leaveOccupyableBuilding(super.getDoor());
      emptyPlaces.add(commingSoldierEntry.getValue().place);
      commingSoldiers.remove(commingSoldierEntry.getKey());
      return;
    }
  }
  for (  TowerOccupier occupier : sortedOccupiers) {
    if (occupier.soldier.getMovableType().getSoldierType() == soldierType && !toBeReleasedOccupiers.contains(occupier)) {
      toBeReleasedOccupiers.add(occupier);
      return;
    }
  }
}"
55834,"/** 
 * Draws the main content (buildings, settlers, ...), assuming the context is set up.
 */
private void drawMain(FloatRectangle screen){
  short height=map.getHeight();
  short width=map.getWidth();
  MapRectangle area=this.context.getConverter().getMapForScreen(screen);
  double bottomdrawy=screen.getMinY() - OVERDRAW_BOTTOM_PX;
  boolean linePartuallyVisible=true;
  for (int line=0; line < area.getLines() + 50 && linePartuallyVisible; line++) {
    int y=area.getLineY(line);
    if (y < 0) {
      continue;
    }
    if (y >= height) {
      break;
    }
    linePartuallyVisible=false;
    int endX=Math.min(area.getLineEndX(line),width - 1);
    int startX=Math.max(area.getLineStartX(line),0);
    for (int x=startX; x <= endX; x=map.nextDrawableX(x,y,endX)) {
      drawTile(x,y);
      if (!linePartuallyVisible) {
        double drawspacey=this.context.getConverter().getViewY(x,y,this.context.getHeight(x,y));
        if (drawspacey > bottomdrawy) {
          linePartuallyVisible=true;
        }
      }
    }
  }
  if (placementBuilding != null) {
    ShortPoint2D underMouse=this.context.getPositionOnScreen((float)mousePosition.getX(),(float)mousePosition.getY());
    IMapObject mapObject=context.getMap().getMapObjectsAt(underMouse.x,underMouse.y);
    if (mapObject != null && mapObject.getMapObject(EMapObjectType.CONSTRUCTION_MARK) != null) {
      this.objectDrawer.drawMapObject(underMouse.x,underMouse.y,placementBuilding);
    }
  }
  if (debugColorMode != EDebugColorModes.NONE) {
    drawDebugColors();
  }
  context.getDrawBuffer().flush();
}","/** 
 * Draws the main content (buildings, settlers, ...), assuming the context is set up.
 */
private void drawMain(FloatRectangle screen){
  short height=map.getHeight();
  short width=map.getWidth();
  MapRectangle area=this.context.getConverter().getMapForScreen(screen);
  double bottomdrawy=screen.getMinY() - OVERDRAW_BOTTOM_PX;
  boolean linePartuallyVisible=true;
  for (int line=0; line < area.getLines() + 50 && linePartuallyVisible; line++) {
    int y=area.getLineY(line);
    if (y < 0) {
      continue;
    }
    if (y >= height) {
      break;
    }
    linePartuallyVisible=false;
    int endX=Math.min(area.getLineEndX(line),width - 1);
    int startX=Math.max(area.getLineStartX(line),0);
    for (int x=startX; x <= endX; x=map.nextDrawableX(x,y,endX)) {
      drawTile(x,y);
      if (!linePartuallyVisible) {
        double drawspacey=this.context.getConverter().getViewY(x,y,this.context.getHeight(x,y));
        if (drawspacey > bottomdrawy) {
          linePartuallyVisible=true;
        }
      }
    }
  }
  if (placementBuilding != null) {
    ShortPoint2D underMouse=this.context.getPositionOnScreen((float)mousePosition.getX(),(float)mousePosition.getY());
    if (0 <= underMouse.x && underMouse.x < width && 0 <= underMouse.y && underMouse.y < height) {
      IMapObject mapObject=map.getMapObjectsAt(underMouse.x,underMouse.y);
      if (mapObject != null && mapObject.getMapObject(EMapObjectType.CONSTRUCTION_MARK) != null) {
        this.objectDrawer.drawMapObject(underMouse.x,underMouse.y,placementBuilding);
      }
    }
  }
  if (debugColorMode != EDebugColorModes.NONE) {
    drawDebugColors();
  }
  context.getDrawBuffer().flush();
}"
55835,"private void drawStones(int x,int y,IMapObject object,float color){
  Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(OBJECTS_FILE,STONE);
  int stones=(int)(seq.length() - object.getStateProgress() - 1);
  draw(seq.getImageSafe(stones),x,y,color);
}","private void drawStones(int x,int y,int availableStones,float color){
  Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(OBJECTS_FILE,STONE);
  int stones=seq.length() - availableStones - 1;
  draw(seq.getImageSafe(stones),x,y,color);
}"
55836,"private void drawObject(int x,int y,IMapObject object,float color){
  EMapObjectType type=object.getObjectType();
  float progress=object.getStateProgress();
switch (type) {
case ARROW:
    drawArrow(context,(IArrowMapObject)object,color);
  break;
case TREE_ADULT:
if (context.ENABLE_ORIGINAL) {
  drawTree(x,y,color);
}
 else {
  drawTreeTest(x,y,color);
}
break;
case TREE_DEAD:
playSound(object,SOUND_FALLING_TREE);
drawFallingTree(x,y,progress,color);
break;
case TREE_GROWING:
drawGrowingTree(x,y,progress,color);
break;
case CORN_GROWING:
drawGrowingCorn(x,y,object,color);
break;
case CORN_ADULT:
drawCorn(x,y,color);
break;
case CORN_DEAD:
drawDeadCorn(x,y,color);
break;
case WINE_GROWING:
drawGrowingWine(x,y,object,color);
break;
case WINE_HARVESTABLE:
drawHarvestableWine(x,y,color);
break;
case WINE_DEAD:
drawDeadWine(x,y,color);
break;
case WINE_BOWL:
drawWineBowl(x,y,object,color);
break;
case WAVES:
drawWaves(x,y,color);
break;
case STONE:
drawStones(x,y,object,color);
break;
case GHOST:
drawPlayerableByProgress(x,y,12,27,object,color);
playSound(object,SOUND_SETTLER_KILLED);
break;
case BUILDING_DECONSTRUCTION_SMOKE:
drawByProgress(x,y,13,38,object.getStateProgress(),color);
playSound(object,SOUND_BUILDING_DESTROYED);
break;
case FOUND_COAL:
drawByProgress(x,y,OBJECTS_FILE,94,object.getStateProgress(),color);
break;
case FOUND_GEMSTONE:
drawByProgress(x,y,OBJECTS_FILE,95,object.getStateProgress(),color);
break;
case FOUND_GOLD:
drawByProgress(x,y,OBJECTS_FILE,96,object.getStateProgress(),color);
break;
case FOUND_IRON:
drawByProgress(x,y,OBJECTS_FILE,97,object.getStateProgress(),color);
break;
case FOUND_BRIMSTONE:
drawByProgress(x,y,OBJECTS_FILE,98,object.getStateProgress(),color);
break;
case FOUND_NOTHING:
drawByProgress(x,y,OBJECTS_FILE,99,object.getStateProgress(),color);
break;
case BUILDINGSITE_SIGN:
drawByProgress(x,y,OBJECTS_FILE,93,object.getStateProgress(),color);
break;
case BUILDINGSITE_POST:
drawByProgress(x,y,OBJECTS_FILE,92,object.getStateProgress(),color);
break;
case WORKAREA_MARK:
drawByProgress(x,y,OBJECTS_FILE,91,object.getStateProgress(),color);
break;
case FLAG_DOOR:
drawPlayerableWaving(x,y,13,63,object,color);
break;
case CONSTRUCTION_MARK:
drawConstructionMark(x,y,object,color);
break;
case FLAG_ROOF:
drawRoofFlag(x,y,object,color);
break;
case BUILDING:
drawBuilding(x,y,(IBuilding)object,color);
break;
case PLACEMENT_BUILDING:
drawPlacementBuilding(x,y,object,color);
break;
case STACK_OBJECT:
drawStack(x,y,(IStackMapObject)object,color);
break;
case SMOKE:
drawByProgress(x,y,13,42,progress,color);
break;
case WINE:
drawByProgress(x,y,1,25,progress,color);
break;
case PLANT_DECORATION:
drawPlantDecoration(x,y,color);
break;
case DESERT_DECORATION:
drawDesertDecoration(x,y,color);
break;
case PIG:
drawPig(x,y,color);
break;
case DONKEY:
drawDonkey(x,y,object,color);
break;
case FISH_DECORATION:
drawDecorativeFish(x,y,color);
break;
case ATTACKABLE_TOWER:
drawAttackableTower(x,y,object);
break;
default :
break;
}
}","private void drawObject(int x,int y,IMapObject object,float color){
  EMapObjectType type=object.getObjectType();
  float progress=object.getStateProgress();
switch (type) {
case ARROW:
    drawArrow(context,(IArrowMapObject)object,color);
  break;
case TREE_ADULT:
if (context.ENABLE_ORIGINAL) {
  drawTree(x,y,color);
}
 else {
  drawTreeTest(x,y,color);
}
break;
case TREE_DEAD:
playSound(object,SOUND_FALLING_TREE);
drawFallingTree(x,y,progress,color);
break;
case TREE_GROWING:
drawGrowingTree(x,y,progress,color);
break;
case CORN_GROWING:
drawGrowingCorn(x,y,object,color);
break;
case CORN_ADULT:
drawCorn(x,y,color);
break;
case CORN_DEAD:
drawDeadCorn(x,y,color);
break;
case WINE_GROWING:
drawGrowingWine(x,y,object,color);
break;
case WINE_HARVESTABLE:
drawHarvestableWine(x,y,color);
break;
case WINE_DEAD:
drawDeadWine(x,y,color);
break;
case WINE_BOWL:
drawWineBowl(x,y,object,color);
break;
case WAVES:
drawWaves(x,y,color);
break;
case STONE:
drawStones(x,y,(int)object.getStateProgress(),color);
break;
case CUT_OFF_STONE:
drawStones(x,y,0,color);
break;
case GHOST:
drawPlayerableByProgress(x,y,12,27,object,color);
playSound(object,SOUND_SETTLER_KILLED);
break;
case BUILDING_DECONSTRUCTION_SMOKE:
drawByProgress(x,y,13,38,object.getStateProgress(),color);
playSound(object,SOUND_BUILDING_DESTROYED);
break;
case FOUND_COAL:
drawByProgress(x,y,OBJECTS_FILE,94,object.getStateProgress(),color);
break;
case FOUND_GEMSTONE:
drawByProgress(x,y,OBJECTS_FILE,95,object.getStateProgress(),color);
break;
case FOUND_GOLD:
drawByProgress(x,y,OBJECTS_FILE,96,object.getStateProgress(),color);
break;
case FOUND_IRON:
drawByProgress(x,y,OBJECTS_FILE,97,object.getStateProgress(),color);
break;
case FOUND_BRIMSTONE:
drawByProgress(x,y,OBJECTS_FILE,98,object.getStateProgress(),color);
break;
case FOUND_NOTHING:
drawByProgress(x,y,OBJECTS_FILE,99,object.getStateProgress(),color);
break;
case BUILDINGSITE_SIGN:
drawByProgress(x,y,OBJECTS_FILE,93,object.getStateProgress(),color);
break;
case BUILDINGSITE_POST:
drawByProgress(x,y,OBJECTS_FILE,92,object.getStateProgress(),color);
break;
case WORKAREA_MARK:
drawByProgress(x,y,OBJECTS_FILE,91,object.getStateProgress(),color);
break;
case FLAG_DOOR:
drawPlayerableWaving(x,y,13,63,object,color);
break;
case CONSTRUCTION_MARK:
drawConstructionMark(x,y,object,color);
break;
case FLAG_ROOF:
drawRoofFlag(x,y,object,color);
break;
case BUILDING:
drawBuilding(x,y,(IBuilding)object,color);
break;
case PLACEMENT_BUILDING:
drawPlacementBuilding(x,y,object,color);
break;
case STACK_OBJECT:
drawStack(x,y,(IStackMapObject)object,color);
break;
case SMOKE:
drawByProgress(x,y,13,42,progress,color);
break;
case PLANT_DECORATION:
drawPlantDecoration(x,y,color);
break;
case DESERT_DECORATION:
drawDesertDecoration(x,y,color);
break;
case PIG:
drawPig(x,y,color);
break;
case DONKEY:
drawDonkey(x,y,object,color);
break;
case FISH_DECORATION:
drawDecorativeFish(x,y,color);
break;
case ATTACKABLE_TOWER:
drawAttackableTower(x,y,object);
break;
default :
break;
}
}"
55837,"@Override public void changeHeightTowards(short x,short y,byte targetHeight){
  landscapeGrid.flattenAndChangeHeightTowards(x,y,targetHeight);
  objectsGrid.removeMapObjectType(x,y,EMapObjectType.CORN_ADULT);
  objectsGrid.removeMapObjectType(x,y,EMapObjectType.CORN_DEAD);
  objectsGrid.removeMapObjectType(x,y,EMapObjectType.CORN_GROWING);
}","@Override public void changeHeightTowards(short x,short y,byte targetHeight){
  landscapeGrid.flattenAndChangeHeightTowards(x,y,targetHeight);
  objectsGrid.removeMapObjectTypes(x,y,EMapObjectType.TO_BE_REMOVED_WHEN_FLATTENED);
}"
55838,"private void cutStone(ShortPoint2D pos){
  short x=(short)(pos.x - 1);
  short y=(short)(pos.y + 1);
  AbstractHexMapObject stone=grid.getMapObject(x,y,EMapObjectType.STONE);
  if (stone != null) {
    stone.cutOff();
    if (!stone.canBeCut()) {
      addSelfDeletingMapObject(pos,EMapObjectType.CUT_OFF_STONE,Stone.DECOMPOSE_DELAY,null);
      removeMapObjectType(x,y,EMapObjectType.STONE);
    }
  }
}","private void cutStone(ShortPoint2D pos){
  short x=(short)(pos.x - 1);
  short y=(short)(pos.y + 1);
  AbstractHexMapObject stone=grid.getMapObject(x,y,EMapObjectType.STONE);
  if (stone != null) {
    stone.cutOff();
    if (!stone.canBeCut()) {
      addSelfDeletingMapObject(new ShortPoint2D(x,y),EMapObjectType.CUT_OFF_STONE,Stone.DECOMPOSE_DELAY,null);
      removeMapObjectType(x,y,EMapObjectType.STONE);
    }
  }
}"
55839,"public void addStone(ShortPoint2D pos,int capacity){
  addMapObject(pos,new Stone(capacity));
}","public void addStone(ShortPoint2D pos,int capacity){
  if (capacity > 0) {
    addMapObject(pos,new Stone(capacity));
  }
 else {
    addSelfDeletingMapObject(pos,EMapObjectType.CUT_OFF_STONE,Stone.DECOMPOSE_DELAY,null);
  }
}"
55840,"@Override public boolean tryToTakeMaterial(){
  if (state != EBuildingState.BRICKLAYERS_REQUESTED) {
    return false;
  }
  remainingMaterialActions--;
  constructionProgress+=1f / (Constants.BRICKLAYER_ACTIONS_PER_MATERIAL * getBuildingType().getNumberOfConstructionMaterials());
  if (remainingMaterialActions > 0) {
    return true;
  }
 else {
    IRequestStack stack=getStackWithMaterial();
    if (priority != EPriority.STOPPED && stack != null) {
      stack.pop();
      remainingMaterialActions=Constants.BRICKLAYER_ACTIONS_PER_MATERIAL;
      return true;
    }
 else {
      if (areAllStacksFullfilled()) {
        finishConstruction();
      }
 else {
        state=EBuildingState.WAITING_FOR_MATERIAL;
        RescheduleTimer.add(this,WAITING_FOR_MATERIAL_PERIOD);
      }
      return false;
    }
  }
}","@Override public boolean tryToTakeMaterial(){
  if (state != EBuildingState.BRICKLAYERS_REQUESTED) {
    return false;
  }
  remainingMaterialActions--;
  constructionProgress+=1f / (Constants.BRICKLAYER_ACTIONS_PER_MATERIAL * getBuildingType().getNumberOfConstructionMaterials());
  if (remainingMaterialActions > 0) {
    return true;
  }
 else {
    IRequestStack stack=getStackWithMaterial();
    if (stack != null) {
      stack.pop();
      remainingMaterialActions=Constants.BRICKLAYER_ACTIONS_PER_MATERIAL;
      return true;
    }
 else {
      if (areAllStacksFullfilled()) {
        finishConstruction();
      }
 else {
        state=EBuildingState.WAITING_FOR_MATERIAL;
        RescheduleTimer.add(this,WAITING_FOR_MATERIAL_PERIOD);
      }
      return false;
    }
  }
}"
55841,"public void setPriority(EPriority newPriority){
  this.priority=newPriority;
  if (stacks != null) {
    for (    IRequestStack curr : stacks) {
      curr.setPriority(newPriority);
    }
  }
}","public void setPriority(EPriority newPriority){
  this.priority=newPriority;
  if (stacks != null) {
    for (    IRequestStack curr : stacks) {
      curr.setPriority(newPriority);
    }
  }
  if (newPriority == EPriority.STOPPED) {
switch (state) {
case IN_FLATTERNING:
      state=EBuildingState.CREATED;
    break;
case BRICKLAYERS_REQUESTED:
  state=EBuildingState.WAITING_FOR_MATERIAL;
RescheduleTimer.add(this,WAITING_FOR_MATERIAL_PERIOD);
break;
}
}
}"
55842,"private void initConstruction(){
  stacks=createConstructionStacks();
  placeAdditionalMapObjects(grid,pos,true);
  this.state=EBuildingState.IN_FLATTERNING;
  RescheduleTimer.add(this,IS_FLATTENED_RECHECK_PERIOD);
  requestDiggers();
}","private void initConstruction(){
  stacks=createConstructionStacks();
  placeAdditionalMapObjects(grid,pos,true);
  this.state=EBuildingState.CREATED;
  RescheduleTimer.add(this,IS_UNSTOPPED_RECHECK_PERIOD);
}"
55843,"private void tryToBuild(){
  if (constructionSite.tryToTakeMaterial()) {
    super.playAction(EMovableAction.ACTION1,BRICKLAYER_ACTION_DURATION);
  }
 else {
    jobFinished();
  }
}","private void tryToBuild(){
  if (constructionSite.isBricklayerRequestActive() && constructionSite.tryToTakeMaterial()) {
    super.playAction(EMovableAction.ACTION1,BRICKLAYER_ACTION_DURATION);
  }
 else {
    jobFinished();
  }
}"
55844,"private final boolean isValidPosition(IPathCalculatable requester,int x,int y,short blockedAtStartPartition){
  return isInBounds(x,y) && (blockedAtStartPartition >= 0 && map.getBlockedPartition(x,y) == blockedAtStartPartition || !isBlocked(requester,x,y));
}","private final boolean isValidPosition(IPathCalculatable requester,int fromX,int fromY,int toX,int toY,short blockedAtStartPartition){
  return isInBounds(toX,toY) && (!isBlocked(requester,toX,toY) || (blockedAtStartPartition >= 0 && map.getBlockedPartition(toX,toY) == blockedAtStartPartition && isBlocked(requester,fromX,fromY)));
}"
55845,"@Override public final Path findPath(IPathCalculatable requester,final short sx,final short sy,final short tx,final short ty){
  final short blockedAtStartPartition;
  if (!isInBounds(sx,sy)) {
    throw new InvalidStartPositionException(""String_Node_Str"",sx,sy);
  }
 else   if (!isInBounds(tx,ty) || isBlocked(requester,tx,ty) || map.getBlockedPartition(sx,sy) != map.getBlockedPartition(tx,ty)) {
    return null;
  }
 else   if (sx == tx && sy == ty) {
    return null;
  }
 else   if (isBlocked(requester,sx,sy)) {
    blockedAtStartPartition=map.getBlockedPartition(sx,sy);
  }
 else {
    blockedAtStartPartition=-1;
  }
  final int targetFlatIdx=getFlatIdx(tx,ty);
  closedBitSet.clear();
  openBitSet.clear();
  open.clear();
  boolean found=false;
  initStartNode(sx,sy,tx,ty);
  while (!open.isEmpty()) {
    int currFlatIdx=open.deleteMin();
    final int x=getX(currFlatIdx);
    final int y=getY(currFlatIdx);
    setClosed(x,y);
    if (targetFlatIdx == currFlatIdx) {
      found=true;
      break;
    }
    final float currPositionCosts=costs[currFlatIdx];
    for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      final int neighborX=x + xDeltaArray[i];
      final int neighborY=y + yDeltaArray[i];
      if (isValidPosition(requester,neighborX,neighborY,blockedAtStartPartition)) {
        final int flatNeighborIdx=getFlatIdx(neighborX,neighborY);
        if (!closedBitSet.get(flatNeighborIdx)) {
          final float newCosts=currPositionCosts + map.getCost(x,y,neighborX,neighborY);
          if (openBitSet.get(flatNeighborIdx)) {
            final float oldCosts=costs[flatNeighborIdx];
            if (oldCosts > newCosts) {
              costs[flatNeighborIdx]=newCosts;
              depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
              depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
              int heuristicCosts=getHeuristicCost(neighborX,neighborY,tx,ty);
              open.increasedPriority(flatNeighborIdx,oldCosts + heuristicCosts,newCosts + heuristicCosts);
            }
          }
 else {
            costs[flatNeighborIdx]=newCosts;
            depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
            depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
            openBitSet.set(flatNeighborIdx);
            open.insert(flatNeighborIdx,newCosts + getHeuristicCost(neighborX,neighborY,tx,ty));
            map.markAsOpen(neighborX,neighborY);
          }
        }
      }
    }
  }
  if (found) {
    int pathlength=depthParentHeap[getDepthIdx(getFlatIdx(tx,ty))];
    Path path=new Path(pathlength);
    int idx=pathlength;
    int parentFlatIdx=targetFlatIdx;
    while (idx > 0) {
      idx--;
      path.insertAt(idx,(short)getX(parentFlatIdx),(short)getY(parentFlatIdx));
      parentFlatIdx=depthParentHeap[getParentIdx(parentFlatIdx)];
    }
    return path;
  }
  return null;
}","@Override public final Path findPath(IPathCalculatable requester,final short sx,final short sy,final short tx,final short ty){
  final short blockedAtStartPartition;
  if (!isInBounds(sx,sy)) {
    throw new InvalidStartPositionException(""String_Node_Str"",sx,sy);
  }
 else   if (!isInBounds(tx,ty) || isBlocked(requester,tx,ty) || map.getBlockedPartition(sx,sy) != map.getBlockedPartition(tx,ty)) {
    return null;
  }
 else   if (sx == tx && sy == ty) {
    return null;
  }
 else   if (isBlocked(requester,sx,sy)) {
    blockedAtStartPartition=map.getBlockedPartition(sx,sy);
  }
 else {
    blockedAtStartPartition=-1;
  }
  final int targetFlatIdx=getFlatIdx(tx,ty);
  closedBitSet.clear();
  openBitSet.clear();
  open.clear();
  boolean found=false;
  initStartNode(sx,sy,tx,ty);
  while (!open.isEmpty()) {
    int currFlatIdx=open.deleteMin();
    final int x=getX(currFlatIdx);
    final int y=getY(currFlatIdx);
    setClosed(x,y);
    if (targetFlatIdx == currFlatIdx) {
      found=true;
      break;
    }
    final float currPositionCosts=costs[currFlatIdx];
    for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      final int neighborX=x + xDeltaArray[i];
      final int neighborY=y + yDeltaArray[i];
      if (isValidPosition(requester,x,y,neighborX,neighborY,blockedAtStartPartition)) {
        final int flatNeighborIdx=getFlatIdx(neighborX,neighborY);
        if (!closedBitSet.get(flatNeighborIdx)) {
          final float newCosts=currPositionCosts + map.getCost(x,y,neighborX,neighborY);
          if (openBitSet.get(flatNeighborIdx)) {
            final float oldCosts=costs[flatNeighborIdx];
            if (oldCosts > newCosts) {
              costs[flatNeighborIdx]=newCosts;
              depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
              depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
              int heuristicCosts=getHeuristicCost(neighborX,neighborY,tx,ty);
              open.increasedPriority(flatNeighborIdx,oldCosts + heuristicCosts,newCosts + heuristicCosts);
            }
          }
 else {
            costs[flatNeighborIdx]=newCosts;
            depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
            depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
            openBitSet.set(flatNeighborIdx);
            open.insert(flatNeighborIdx,newCosts + getHeuristicCost(neighborX,neighborY,tx,ty));
            map.markAsOpen(neighborX,neighborY);
          }
        }
      }
    }
  }
  if (found) {
    int pathlength=depthParentHeap[getDepthIdx(getFlatIdx(tx,ty))];
    Path path=new Path(pathlength);
    int idx=pathlength;
    int parentFlatIdx=targetFlatIdx;
    while (idx > 0) {
      idx--;
      path.insertAt(idx,(short)getX(parentFlatIdx),(short)getY(parentFlatIdx));
      parentFlatIdx=depthParentHeap[getParentIdx(parentFlatIdx)];
    }
    return path;
  }
  return null;
}"
55846,"@Override public void debug(){
  System.out.println(""String_Node_Str"");
}","@Override public void debug(){
  System.out.println(""String_Node_Str"" + pos);
}"
55847,"public void leavePosition(){
  if (!enableNothingToDo) {
    return;
  }
  int offset=MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.VALUES[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir,EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE)) {
      break;
    }
 else {
      Movable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.x),currDir.getNextTileY(position.y));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}","public void leavePosition(){
  if (state != EMovableState.DOING_NOTHING || !enableNothingToDo) {
    return;
  }
  int offset=MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.VALUES[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir,EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE)) {
      break;
    }
 else {
      Movable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.x),currDir.getNextTileY(position.y));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}"
55848,"private void stopOrStartWorking(List<Integer> selectedMovables,boolean stop){
  for (  Integer currID : selectedMovables) {
    Movable.getMovableByID(currID).stopOrStartWorking(stop);
  }
}","private void stopOrStartWorking(List<Integer> selectedMovables,boolean stop){
  for (  Integer currID : selectedMovables) {
    Movable movable=Movable.getMovableByID(currID);
    if (movable != null) {
      movable.stopOrStartWorking(stop);
    }
  }
}"
55849,"private void killSelectedMovables(List<Integer> selectedMovables){
  for (  Integer currID : selectedMovables) {
    Movable curr=Movable.getMovableByID(currID);
    if (curr != null)     curr.kill();
  }
}","private void killSelectedMovables(List<Integer> selectedMovables){
  for (  Integer currID : selectedMovables) {
    Movable curr=Movable.getMovableByID(currID);
    if (curr != null) {
      curr.kill();
    }
  }
}"
55850,"private boolean goToRandomDirection(Movable pushingMovable){
  int offset=MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS);
  EDirection pushedFromDir=EDirection.getDirection(this.getPos(),pushingMovable.getPos());
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.VALUES[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (currDir != pushedFromDir && goInDirection(currDir,false)) {
      return true;
    }
  }
  return false;
}","private boolean goToRandomDirection(Movable pushingMovable){
  int offset=MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS);
  EDirection pushedFromDir=EDirection.getDirection(this.getPos(),pushingMovable.getPos());
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.VALUES[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (currDir != pushedFromDir && goInDirection(currDir,EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE)) {
      return true;
    }
  }
  return false;
}"
55851,"/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @param force If true, the step will be forced and the method will always return true.
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
final boolean goInDirection(EDirection direction,boolean force){
  ShortPoint2D targetPosition=direction.getNextHexPoint(position);
  if (force) {
    this.direction=direction;
    setState(EMovableState.PATHING);
    this.followPath(new Path(targetPosition));
    return true;
  }
 else   if ((grid.isValidPosition(this,targetPosition) && grid.hasNoMovableAt(targetPosition.x,targetPosition.y))) {
    initGoingSingleStep(targetPosition);
    setState(EMovableState.GOING_SINGLE_STEP);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @param mode Use the given mode to go.<br>
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
final boolean goInDirection(EDirection direction,EGoInDirectionMode mode){
  ShortPoint2D targetPosition=direction.getNextHexPoint(position);
switch (mode) {
case GO_IF_ALLOWED_WAIT_TILL_FREE:
{
      this.direction=direction;
      setState(EMovableState.PATHING);
      this.followPath(new Path(targetPosition));
      return true;
    }
case GO_IF_ALLOWED_AND_FREE:
  if ((grid.isValidPosition(this,targetPosition) && grid.hasNoMovableAt(targetPosition.x,targetPosition.y))) {
    initGoingSingleStep(targetPosition);
    setState(EMovableState.GOING_SINGLE_STEP);
    return true;
  }
 else {
    break;
  }
case GO_IF_FREE:
if (grid.isFreePosition(targetPosition)) {
  initGoingSingleStep(targetPosition);
  setState(EMovableState.GOING_SINGLE_STEP);
  return true;
}
 else {
  break;
}
}
return false;
}"
55852,"public void leavePosition(){
  if (!enableNothingToDo) {
    return;
  }
  int offset=MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.VALUES[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir,false)) {
      break;
    }
 else {
      Movable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.x),currDir.getNextTileY(position.y));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}","public void leavePosition(){
  if (!enableNothingToDo) {
    return;
  }
  int offset=MatchConstants.random().nextInt(EDirection.NUMBER_OF_DIRECTIONS);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.VALUES[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir,EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE)) {
      break;
    }
 else {
      Movable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.x),currDir.getNextTileY(position.y));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}"
55853,"/** 
 * Tries to walk the movable into a position where it has a minimum distance to others.
 * @return true if the movable moves to flock, false if no flocking is required.
 */
private boolean flockToDecentralize(){
  ShortPoint2D decentVector=grid.calcDecentralizeVector(position.x,position.y);
  EDirection randomDirection=direction.getNeighbor(MatchConstants.random().nextInt(-1,1));
  int dx=randomDirection.gridDeltaX + decentVector.x;
  int dy=randomDirection.gridDeltaY + decentVector.y;
  if (ShortPoint2D.getOnGridDist(dx,dy) >= 2) {
    flockDelay=Math.max(flockDelay - 100,500);
    if (this.goInDirection(EDirection.getApproxDirection(0,0,dx,dy),false)) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    flockDelay=Math.min(flockDelay + 100,1000);
    return false;
  }
}","/** 
 * Tries to walk the movable into a position where it has a minimum distance to others.
 * @return true if the movable moves to flock, false if no flocking is required.
 */
private boolean flockToDecentralize(){
  ShortPoint2D decentVector=grid.calcDecentralizeVector(position.x,position.y);
  EDirection randomDirection=direction.getNeighbor(MatchConstants.random().nextInt(-1,1));
  int dx=randomDirection.gridDeltaX + decentVector.x;
  int dy=randomDirection.gridDeltaY + decentVector.y;
  if (ShortPoint2D.getOnGridDist(dx,dy) >= 2) {
    flockDelay=Math.max(flockDelay - 100,500);
    return this.goInDirection(EDirection.getApproxDirection(0,0,dx,dy),EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE);
  }
 else {
    flockDelay=Math.min(flockDelay + 100,1000);
    return false;
  }
}"
55854,"/** 
 * @param dijkstra if true, dijkstra algorithm is used<br> if false, in area finder is used.
 * @param centerX
 * @param centerY
 * @param radius
 * @param searchType
 * @return true if a path has been found.
 */
final boolean preSearchPath(boolean dikjstra,short centerX,short centerY,short radius,ESearchType searchType){
}","/** 
 * @param dijkstra if true, dijkstra algorithm is used<br> if false, in area finder is used.
 * @param centerX
 * @param centerY
 * @param radius
 * @param searchType
 * @return true if a path has been found.
 */
final boolean preSearchPath(boolean dijkstra,short centerX,short centerY,short radius,ESearchType searchType){
}"
55855,"/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @param force If true, the step will be forced and the method will always return true.
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
protected final boolean goInDirection(EDirection direction,boolean force){
  return movable.goInDirection(direction,force);
}","/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @param mode The mode used for this operation
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
protected final boolean goInDirection(EDirection direction,EGoInDirectionMode mode){
  return movable.goInDirection(direction,mode);
}"
55856,"@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case TRY_TAKING_RESOURCE:
if (tryTakingResource()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case TRY_TAKING_FOOD:
if (building.tryTakingFoood(currentJob.getFoodOrder())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case WAIT:
{
short waitTime=(short)(currentJob.getTime() * 1000);
super.sleep(waitTime);
jobFinished();
break;
}
case WALK:
IBuildingJob job=currentJob;
super.goInDirection(currentJob.getDirection(),true);
if (currentJob == job) {
jobFinished();
}
break;
case SHOW:
{
if (building.getPriority() == EPriority.STOPPED) {
break;
}
ShortPoint2D pos=getCurrentJobPos();
if (currentJob.getDirection() != null) {
super.lookInDirection(currentJob.getDirection());
}
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
}
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EMovableAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EMovableAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getGrid().canTakeMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
building.addMapObjectCleanupPosition(getCurrentJobPos(),EMapObjectType.SMOKE);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
case POP_WEAPON:
popWeaponRequestAction();
break;
case GROW_DONKEY:
growDonkeyAction();
break;
}
}","@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case TRY_TAKING_RESOURCE:
if (tryTakingResource()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case TRY_TAKING_FOOD:
if (building.tryTakingFoood(currentJob.getFoodOrder())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case WAIT:
{
short waitTime=(short)(currentJob.getTime() * 1000);
super.sleep(waitTime);
jobFinished();
break;
}
case WALK:
IBuildingJob job=currentJob;
super.goInDirection(currentJob.getDirection(),EGoInDirectionMode.GO_IF_ALLOWED_WAIT_TILL_FREE);
if (currentJob == job) {
jobFinished();
}
break;
case SHOW:
{
if (building.getPriority() == EPriority.STOPPED) {
break;
}
ShortPoint2D pos=getCurrentJobPos();
if (currentJob.getDirection() != null) {
super.lookInDirection(currentJob.getDirection());
}
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
}
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EMovableAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EMovableAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getGrid().canTakeMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
building.addMapObjectCleanupPosition(getCurrentJobPos(),EMapObjectType.SMOKE);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
case POP_WEAPON:
popWeaponRequestAction();
break;
case GROW_DONKEY:
growDonkeyAction();
break;
}
}"
55857,"@Override protected void action(){
  ShortPoint2D position=movable.getPos();
  if (!super.isValidPosition(position)) {
    if (searchesCounter > 120) {
      movable.kill();
      return;
    }
    if (super.preSearchPath(true,position.x,position.y,Constants.MOVABLE_FLEEING_DIJKSTRA_RADIUS,ESearchType.VALID_FREE_POSITION) || super.preSearchPath(false,position.x,position.y,Constants.MOVABLE_FLEEING_MAX_RADIUS,ESearchType.VALID_FREE_POSITION)) {
      lastCheckedPathStep=Integer.MIN_VALUE;
      super.followPresearchedPath();
    }
 else {
      EDirection currentDirection=movable.getDirection();
      EDirection newDirection;
      if (turnNextTime || MatchConstants.random().nextFloat() < 0.10) {
        turnNextTime=false;
        newDirection=currentDirection.getNeighbor(MatchConstants.random().nextInt(-1,1));
      }
 else {
        newDirection=currentDirection;
      }
      ShortPoint2D newPos=newDirection.getNextHexPoint(position);
      if (super.getGrid().isFreePosition(newPos)) {
        super.goInDirection(newDirection,true);
        turnNextTime=MatchConstants.random().nextInt(7) == 0;
      }
 else {
        super.lookInDirection(newDirection);
        turnNextTime=true;
      }
    }
    searchesCounter++;
  }
 else {
    movable.convertTo(movable.getMovableType());
  }
}","@Override protected void action(){
  ShortPoint2D position=movable.getPos();
  if (!super.isValidPosition(position)) {
    if (searchesCounter > 120) {
      movable.kill();
      return;
    }
    if (super.preSearchPath(true,position.x,position.y,Constants.MOVABLE_FLEEING_DIJKSTRA_RADIUS,ESearchType.VALID_FREE_POSITION) || super.preSearchPath(false,position.x,position.y,Constants.MOVABLE_FLEEING_MAX_RADIUS,ESearchType.VALID_FREE_POSITION)) {
      lastCheckedPathStep=Integer.MIN_VALUE;
      super.followPresearchedPath();
    }
 else {
      EDirection currentDirection=movable.getDirection();
      EDirection newDirection;
      if (turnNextTime || MatchConstants.random().nextFloat() < 0.10) {
        turnNextTime=false;
        newDirection=currentDirection.getNeighbor(MatchConstants.random().nextInt(-1,1));
      }
 else {
        newDirection=currentDirection;
      }
      ShortPoint2D newPos=newDirection.getNextHexPoint(position);
      if (super.goInDirection(newDirection,EGoInDirectionMode.GO_IF_FREE)) {
        turnNextTime=MatchConstants.random().nextInt(7) == 0;
      }
 else {
        super.lookInDirection(newDirection);
        turnNextTime=true;
      }
    }
    searchesCounter++;
  }
 else {
    movable.convertTo(movable.getMovableType());
  }
}"
55858,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  if (!isEnemyAttackable(enemy,isInTower)) {
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  }
 else {
    hitEnemy(enemy);
    if (state != ESoldierState.HITTING) {
      break;
    }
    if (enemy.getHealth() <= 0) {
      enemy=null;
      changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
      break;
    }
  }
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
case SEARCH_FOR_ENEMIES:
final short minSearchDistance=getMinSearchDistance();
IAttackable oldEnemy=enemy;
enemy=super.getGrid().getEnemyInSearchArea(getAttackPosition(),movable,minSearchDistance,getMaxSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (minSearchDistance > 0) {
IAttackable toCloseEnemy=super.getGrid().getEnemyInSearchArea(getAttackPosition(),movable,(short)0,minSearchDistance,!defending);
if (toCloseEnemy != null) {
if (!isInTower) {
EDirection escapeDirection=EDirection.getApproxDirection(toCloseEnemy.getPos(),movable.getPos());
super.goInDirection(escapeDirection,false);
movable.moveTo(null);
}
break;
}
}
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
}
 else if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(movable.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
changeStateTo(ESoldierState.GOING_TO_TOWER);
if (!movable.getPos().equals(building.getDoor()) && !super.goToPos(building.getDoor())) {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == movable.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  if (!isEnemyAttackable(enemy,isInTower)) {
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  }
 else {
    hitEnemy(enemy);
    if (state != ESoldierState.HITTING) {
      break;
    }
    if (enemy.getHealth() <= 0) {
      enemy=null;
      changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
      break;
    }
  }
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
case SEARCH_FOR_ENEMIES:
final short minSearchDistance=getMinSearchDistance();
IAttackable oldEnemy=enemy;
enemy=super.getGrid().getEnemyInSearchArea(getAttackPosition(),movable,minSearchDistance,getMaxSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (minSearchDistance > 0) {
IAttackable toCloseEnemy=super.getGrid().getEnemyInSearchArea(getAttackPosition(),movable,(short)0,minSearchDistance,!defending);
if (toCloseEnemy != null) {
if (!isInTower) {
EDirection escapeDirection=EDirection.getApproxDirection(toCloseEnemy.getPos(),movable.getPos());
super.goInDirection(escapeDirection,EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE);
movable.moveTo(null);
}
break;
}
}
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
}
 else if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(movable.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
changeStateTo(ESoldierState.GOING_TO_TOWER);
if (!movable.getPos().equals(building.getDoor()) && !super.goToPos(building.getDoor())) {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == movable.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}"
55859,"private void goToEnemy(IAttackable enemy){
  if (inSaveGotoMode) {
    goToSavely(enemy);
  }
 else {
    ShortPoint2D pos=movable.getPos();
    EDirection dir=EDirection.getApproxDirection(pos,enemy.getPos());
    if (super.goInDirection(dir,false)) {
      return;
    }
 else {
      inSaveGotoMode=true;
      goToSavely(enemy);
    }
  }
}","private void goToEnemy(IAttackable enemy){
  if (inSaveGotoMode) {
    goToSavely(enemy);
  }
 else {
    ShortPoint2D pos=movable.getPos();
    EDirection dir=EDirection.getApproxDirection(pos,enemy.getPos());
    if (super.goInDirection(dir,EGoInDirectionMode.GO_IF_ALLOWED_AND_FREE)) {
      return;
    }
 else {
      inSaveGotoMode=true;
      goToSavely(enemy);
    }
  }
}"
55860,"@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  Movable attacker=grid.getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pullNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      searchedSoldiers.add(getSearchType(currDefender.getSoldier().getMovableType()));
      pullNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}","@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  Movable attacker=grid.getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.grid.getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pullNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      searchedSoldiers.add(getSearchType(currDefender.getSoldier().getMovableType()));
      pullNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}"
55861,"private void pullNewDefender(ShortPoint2D attackerPos){
  if (sortedOccupiers.isEmpty()) {
    currDefender=null;
    changePlayerTo(attackerPos);
  }
 else {
    currDefender=removeSoldier();
    currDefender.getSoldier().setDefendingAt(pos);
  }
}","private void pullNewDefender(ShortPoint2D attackerPos){
  if (sortedOccupiers.isEmpty()) {
    currDefender=null;
    changePlayerTo(attackerPos);
  }
 else {
    currDefender=removeSoldier();
    currDefender.getSoldier().setDefendingAt(getPos());
  }
}"
55862,"@Override public int compareTo(MapLoader o){
  MapFileHeader myHeader=header;
  MapFileHeader otherHeader=o.header;
  if (myHeader.getType() == MapType.SAVED_SINGLE) {
    return -myHeader.getCreationDate().compareTo(otherHeader.getCreationDate());
  }
 else {
    return myHeader.getName().compareTo(otherHeader.getName());
  }
}","@Override public int compareTo(MapLoader other){
  MapFileHeader myHeader=this.getFileHeader();
  MapFileHeader otherHeader=other.getFileHeader();
  if (myHeader.getType() == otherHeader.getType() && myHeader.getType() == MapType.SAVED_SINGLE) {
    return -this.getCreationDate().compareTo(other.getCreationDate());
  }
 else {
    return this.getMapName().compareToIgnoreCase(other.getMapName());
  }
}"
55863,"public MainMenuPanel(JSettlersFrame settlersFrame,IMultiplayerConnector multiPlayerConnector){
  this.settlersFrame=settlersFrame;
  openSinglePlayerPanel=new OpenPanel(MapList.getDefaultList().getFreshMaps().getItems(),this::showdNewSingleplayerGamePanel);
  openSaveGamePanel=new OpenPanel(transformRemakeMapLoadersToMapLoaders(MapList.getDefaultList().getSavedMaps().getItems()),this::loadSavegame);
  newMultiPlayerGamePanel=new OpenPanel(MapList.getDefaultList().getFreshMaps().getItems(),this::showNewMultiplayerGamePanel);
  joinMultiPlayerGamePanel=new OpenPanel(new Vector<MapLoader>(),this::showJoinMultiplayerGamePanel);
  settingsPanel=new SettingsMenuPanel(this);
  createStructure();
  setStyle();
  localize();
  addListener(multiPlayerConnector);
}","public MainMenuPanel(JSettlersFrame settlersFrame,IMultiplayerConnector multiPlayerConnector){
  this.settlersFrame=settlersFrame;
  openSinglePlayerPanel=new OpenPanel(MapList.getDefaultList().getFreshMaps().getItems(),this::showdNewSingleplayerGamePanel);
  openSaveGamePanel=new OpenPanel(MapList.getDefaultList().getSavedMaps(),this::loadSavegame);
  newMultiPlayerGamePanel=new OpenPanel(MapList.getDefaultList().getFreshMaps().getItems(),this::showNewMultiplayerGamePanel);
  joinMultiPlayerGamePanel=new OpenPanel(new Vector<MapLoader>(),this::showJoinMultiplayerGamePanel);
  settingsPanel=new SettingsMenuPanel(this);
  createStructure();
  setStyle();
  localize();
  addListener(multiPlayerConnector);
}"
55864,"public void setMapLoaders(final List<MapLoader> maps){
  setMapLoadersWithoutSearchChanged(maps);
  searchChanged();
}","public void setMapLoaders(final List<? extends MapLoader> maps){
  setMapLoadersWithoutSearchChanged(maps);
  searchChanged();
}"
55865,"/** 
 * @return true if there are no maps in the list
 */
public boolean isEmpty(){
  return maps.isEmpty();
}","/** 
 * @return true if there are no maps in the list
 */
public boolean isEmpty(){
  return availableMaps.length == 0;
}"
55866,"private void setMapLoadersWithoutSearchChanged(final List<MapLoader> maps){
  this.maps=maps;
  this.mapsAvailable=maps.toArray(new MapLoader[maps.size()]);
  sortMaps();
}","private void setMapLoadersWithoutSearchChanged(final List<? extends MapLoader> maps){
  availableMaps=maps.toArray(new MapLoader[maps.size()]);
  Arrays.sort(availableMaps);
}"
55867,"/** 
 * Search has changed, update the list
 */
protected void searchChanged(){
  String search=searchTextField.getText().toLowerCase();
  listModelFiltered.clear();
  for (  MapLoader m : mapsAvailable) {
    if (matchesSearch(m,search) && currentFilter.filter(m)) {
      listModelFiltered.addElement(m);
    }
  }
}","/** 
 * Search has changed, update the list
 */
protected void searchChanged(){
  String search=searchTextField.getText().toLowerCase();
  listModelFiltered.clear();
  Arrays.stream(availableMaps).filter(currentFilter::filter).filter(mapLoader -> matchesSearch(mapLoader,search)).forEach(listModelFiltered::addElement);
}"
55868,"/** 
 * Constructor
 * @param maps Maps to display
 * @param doubleclickListener Gets called when an entry is double clicked, can be <code>null</code>
 * @param cellRenderer Cell renderer to use
 */
public OpenPanel(final List<MapLoader> maps,final IMapSelectedListener mapSelectedListener,final ListCellRenderer<MapLoader> cellRenderer){
  setMapLoadersWithoutSearchChanged(maps);
  setLayout(new BorderLayout());
  initFilter();
  this.searchTextField=new SearchTextField();
  searchTextField.putClientProperty(ELFStyle.KEY,ELFStyle.TEXT_DEFAULT);
  Box box=Box.createVerticalBox();
  box.add(filterPanel);
  box.add(searchTextField);
  add(box,BorderLayout.NORTH);
  searchTextField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void removeUpdate(    DocumentEvent e){
      searchChanged();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      searchChanged();
    }
    @Override public void changedUpdate(    DocumentEvent e){
      searchChanged();
    }
  }
);
  this.mapList=new JList<MapLoader>(listModelFiltered);
  mapList.setCellRenderer(cellRenderer);
  mapList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        if (mapSelectedListener != null) {
          mapSelectedListener.mapSelected(getSelectedMap());
        }
      }
    }
  }
);
  mapList.setOpaque(false);
  add(new JScrollPane(mapList),BorderLayout.CENTER);
  searchChanged();
  if (maps.size() > 0) {
    mapList.setSelectedIndex(0);
  }
}","/** 
 * Constructor
 * @param maps Maps to display
 * @param doubleclickListener Gets called when an entry is double clicked, can be <code>null</code>
 * @param cellRenderer Cell renderer to use
 */
public OpenPanel(final List<? extends MapLoader> maps,final IMapSelectedListener mapSelectedListener,final ListCellRenderer<MapLoader> cellRenderer){
  setMapLoadersWithoutSearchChanged(maps);
  setLayout(new BorderLayout());
  initFilter();
  searchTextField=new SearchTextField();
  searchTextField.putClientProperty(ELFStyle.KEY,ELFStyle.TEXT_DEFAULT);
  Box box=Box.createVerticalBox();
  box.add(filterPanel);
  box.add(searchTextField);
  add(box,BorderLayout.NORTH);
  searchTextField.getDocument().addDocumentListener(new DocumentListener(){
    @Override public void removeUpdate(    DocumentEvent e){
      searchChanged();
    }
    @Override public void insertUpdate(    DocumentEvent e){
      searchChanged();
    }
    @Override public void changedUpdate(    DocumentEvent e){
      searchChanged();
    }
  }
);
  mapList=new JList<MapLoader>(listModelFiltered);
  mapList.setCellRenderer(cellRenderer);
  mapList.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      if (e.getClickCount() == 2) {
        if (mapSelectedListener != null) {
          mapSelectedListener.mapSelected(getSelectedMap());
        }
      }
    }
  }
);
  mapList.setOpaque(false);
  add(new JScrollPane(mapList),BorderLayout.CENTER);
  searchChanged();
  if (maps.size() > 0) {
    mapList.setSelectedIndex(0);
  }
}"
55869,"@Override public synchronized void drawAt(GLDrawContext gl){
  super.drawAt(gl);
  TextDrawer drawer=gl.getTextDrawer(size);
  if (Double.isNaN(spaceWidth)) {
    spaceWidth=drawer.getWidth(""String_Node_Str"");
    lineHeight=drawer.getHeight(""String_Node_Str"");
    lineBottom=drawer.getHeight(""String_Node_Str"");
  }
  double maxwidth=getPosition().getWidth();
  StringBuilder lineText=new StringBuilder();
  double linewidth=-spaceWidth;
  ArrayList<Line> lines=new ArrayList<>();
  boolean firstWord=true;
  for (  Word word : words) {
    double newlinewidth=linewidth + spaceWidth + word.getWidth(drawer);
    if (!firstWord && (word.lineBreakBefore || newlinewidth > maxwidth)) {
      lines.add(new Line(lineText.toString(),linewidth));
      lineText=new StringBuilder(word.word);
      linewidth=word.getWidth(drawer);
    }
 else {
      if (!firstWord) {
        lineText.append(""String_Node_Str"");
      }
      lineText.append(word.word);
      linewidth=newlinewidth;
    }
    firstWord=false;
  }
  lines.add(new Line(lineText.toString(),linewidth));
  double totalHeight=lines.size() * lineHeight;
  float y;
  y=getTextBoxTop(totalHeight);
  y-=lineBottom;
  for (  Line line : lines) {
    drawLine(drawer,line,y);
    y-=lineHeight;
  }
}","@Override public synchronized void drawAt(GLDrawContext gl){
  super.drawAt(gl);
  TextDrawer drawer=gl.getTextDrawer(size);
  drawer.setColor(1,1,1,1);
  if (Double.isNaN(spaceWidth)) {
    spaceWidth=drawer.getWidth(""String_Node_Str"");
    lineHeight=drawer.getHeight(""String_Node_Str"");
    lineBottom=drawer.getHeight(""String_Node_Str"");
  }
  double maxwidth=getPosition().getWidth();
  StringBuilder lineText=new StringBuilder();
  double linewidth=-spaceWidth;
  ArrayList<Line> lines=new ArrayList<>();
  boolean firstWord=true;
  for (  Word word : words) {
    double newlinewidth=linewidth + spaceWidth + word.getWidth(drawer);
    if (!firstWord && (word.lineBreakBefore || newlinewidth > maxwidth)) {
      lines.add(new Line(lineText.toString(),linewidth));
      lineText=new StringBuilder(word.word);
      linewidth=word.getWidth(drawer);
    }
 else {
      if (!firstWord) {
        lineText.append(""String_Node_Str"");
      }
      lineText.append(word.word);
      linewidth=newlinewidth;
    }
    firstWord=false;
  }
  lines.add(new Line(lineText.toString(),linewidth));
  double totalHeight=lines.size() * lineHeight;
  float y;
  y=getTextBoxTop(totalHeight);
  y-=lineBottom;
  for (  Line line : lines) {
    drawLine(drawer,line,y);
    y-=lineHeight;
  }
}"
55870,"@Override public ShortPoint2D next(){
  return waypoints[i++];
}","@Override public ShortPoint2D next(){
  return hasNext() ? waypoints[i++] : null;
}"
55871,"private String getKeyName(KeyEvent e){
  String text=KeyEvent.getKeyText(e.getKeyCode());
  if (text == null || text.length() != 1) {
switch (e.getKeyCode()) {
case KeyEvent.VK_LEFT:
      text=""String_Node_Str"";
    break;
case KeyEvent.VK_RIGHT:
  text=""String_Node_Str"";
break;
case KeyEvent.VK_DOWN:
text=""String_Node_Str"";
break;
case KeyEvent.VK_UP:
text=""String_Node_Str"";
break;
case KeyEvent.VK_PAUSE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F1:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F2:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F3:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F4:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F5:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F6:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F7:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F8:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F9:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F10:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F11:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F12:
text=""String_Node_Str"";
break;
case KeyEvent.VK_PLUS:
text=""String_Node_Str"";
break;
case KeyEvent.VK_MINUS:
text=""String_Node_Str"";
break;
case KeyEvent.VK_DELETE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_SPACE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_ESCAPE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_BACK_SPACE:
text=""String_Node_Str"";
break;
default :
text=""String_Node_Str"";
}
}
return text;
}","private String getKeyName(KeyEvent e){
  String text=KeyEvent.getKeyText(e.getKeyCode());
  if (text == null || text.length() != 1) {
switch (e.getKeyCode()) {
case KeyEvent.VK_LEFT:
      text=""String_Node_Str"";
    break;
case KeyEvent.VK_RIGHT:
  text=""String_Node_Str"";
break;
case KeyEvent.VK_DOWN:
text=""String_Node_Str"";
break;
case KeyEvent.VK_UP:
text=""String_Node_Str"";
break;
case KeyEvent.VK_PAUSE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F1:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F2:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F3:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F4:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F5:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F6:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F7:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F8:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F9:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F10:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F11:
text=""String_Node_Str"";
break;
case KeyEvent.VK_F12:
text=""String_Node_Str"";
break;
case KeyEvent.VK_PLUS:
text=""String_Node_Str"";
break;
case KeyEvent.VK_MINUS:
text=""String_Node_Str"";
break;
case KeyEvent.VK_DELETE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_SPACE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_ESCAPE:
text=""String_Node_Str"";
break;
case KeyEvent.VK_BACK_SPACE:
text=""String_Node_Str"";
break;
default :
text=""String_Node_Str"" + e.getKeyChar();
}
}
return text;
}"
55872,"@Override public void drawAt(GLDrawContext gl){
  super.drawAt(gl);
  TextDrawer drawer=gl.getTextDrawer(size);
  drawer.renderCentered(getPosition().getCenterX(),getPosition().getCenterY(),text);
}","@Override public void drawAt(GLDrawContext gl){
  super.drawAt(gl);
  TextDrawer drawer=gl.getTextDrawer(size);
  drawer.setColor(1,1,1,1);
  drawer.renderCentered(getPosition().getCenterX(),getPosition().getCenterY(),text);
}"
55873,"@Override public PlayerSlot createPlayerSlot(byte slot,MapLoader mapLoader){
  PlayerSlot playerSlot=new PlayerSlot();
  if (slot == 0) {
    SettingsManager settingsManager=SettingsManager.getInstance();
    playerSlot.setPlayerName(settingsManager.getPlayer().getName());
    playerSlot.setPossibleTypes(new EPlayerType[]{EPlayerType.HUMAN});
    playerSlot.setReadyButtonEnabled(true);
  }
 else {
    playerSlot.setPossibleTypes(new EPlayerType[]{EPlayerType.HUMAN,EPlayerType.AI_VERY_HARD});
    playerSlot.setTypeComboBox(EPlayerType.AI_VERY_HARD);
    playerSlot.setReadyButtonEnabled(false);
  }
  playerSlot.setReady(false);
  playerSlot.setSlotAndTeams((byte)mapLoader.getMaxPlayers());
  playerSlot.disableAllInputs();
  return playerSlot;
}","@Override public PlayerSlot createPlayerSlot(byte slot,MapLoader mapLoader){
  PlayerSlot playerSlot=new PlayerSlot();
  if (slot == 0) {
    SettingsManager settingsManager=SettingsManager.getInstance();
    playerSlot.setPlayerName(settingsManager.getPlayer().getName());
    playerSlot.setPossibleTypes(new EPlayerType[]{EPlayerType.HUMAN});
    playerSlot.setReadyButtonEnabled(true);
    playerSlot.setReady(false);
  }
 else {
    playerSlot.setPossibleTypes(new EPlayerType[]{EPlayerType.HUMAN,EPlayerType.AI_VERY_HARD});
    playerSlot.setPlayerType(EPlayerType.AI_VERY_HARD);
    playerSlot.setReadyButtonEnabled(false);
    playerSlot.setReady(true);
  }
  playerSlot.setSlotAndTeams((byte)mapLoader.getMaxPlayers());
  playerSlot.disableAllInputs();
  return playerSlot;
}"
55874,"private void onPlayersChanges(ChangingList<? extends IMultiplayerPlayer> changingPlayers,IJoinPhaseMultiplayerGameConnector joinMultiPlayerMap){
  SwingUtilities.invokeLater(() -> {
    List<? extends IMultiplayerPlayer> players=changingPlayers.getItems();
    String myId=SettingsManager.getInstance().get(SettingsManager.SETTING_UUID);
    for (int i=0; i < players.size(); i++) {
      PlayerSlot playerSlot=playerSlots.get(i);
      IMultiplayerPlayer player=players.get(i);
      playerSlot.setPlayerName(player.getName());
      playerSlot.setReady(player.isReady());
      if (player.getId().equals(myId)) {
        playerSlot.setReadyButtonEnabled(true);
        playerSlot.informGameAboutReady(joinMultiPlayerMap);
      }
 else {
        playerSlot.setReadyButtonEnabled(false);
      }
    }
    for (int i=players.size(); i < playerSlots.size(); i++) {
      playerSlots.get(i).setTypeComboBox(EPlayerType.AI_VERY_HARD);
    }
    setCancelButtonActionListener(e -> {
      joinMultiPlayerMap.abort();
      settlersFrame.showMainMenu();
    }
);
  }
);
}","private void onPlayersChanges(ChangingList<? extends IMultiplayerPlayer> changingPlayers,IJoinPhaseMultiplayerGameConnector joinMultiPlayerMap){
  SwingUtilities.invokeLater(() -> {
    List<? extends IMultiplayerPlayer> players=changingPlayers.getItems();
    String myId=SettingsManager.getInstance().get(SettingsManager.SETTING_UUID);
    for (int i=0; i < players.size(); i++) {
      PlayerSlot playerSlot=playerSlots.get(i);
      IMultiplayerPlayer player=players.get(i);
      playerSlot.setPlayerName(player.getName());
      playerSlot.setReady(player.isReady());
      if (player.getId().equals(myId)) {
        playerSlot.setReadyButtonEnabled(true);
        playerSlot.informGameAboutReady(joinMultiPlayerMap);
      }
 else {
        playerSlot.setReadyButtonEnabled(false);
      }
    }
    for (int i=players.size(); i < playerSlots.size(); i++) {
      playerSlots.get(i).setPlayerType(EPlayerType.AI_VERY_HARD);
    }
    setCancelButtonActionListener(e -> {
      joinMultiPlayerMap.abort();
      settlersFrame.showMainMenu();
    }
);
  }
);
}"
55875,"@Override public void gameJoined(IJoinPhaseMultiplayerGameConnector connector){
  SwingUtilities.invokeLater(() -> {
    initializeChatFor(connector);
    setStartButtonActionListener(e -> {
      connector.startGame();
    }
);
    connector.getPlayers().setListener(changingPlayers -> onPlayersChanges(changingPlayers,connector));
    connector.setMultiplayerListener(new IMultiplayerListener(){
      @Override public void gameIsStarting(      IStartingGame game){
        settlersFrame.showStartingGamePanel(game);
      }
      @Override public void gameAborted(){
        settlersFrame.showMainMenu();
      }
    }
);
  }
);
}","@Override public void gameJoined(IJoinPhaseMultiplayerGameConnector connector){
  SwingUtilities.invokeLater(() -> {
    initializeChatFor(connector);
    setStartButtonActionListener(e -> {
      connector.startGame();
    }
);
    connector.getPlayers().setListener(changingPlayers -> onPlayersChanges(changingPlayers,connector));
    connector.setMultiplayerListener(new IMultiplayerListener(){
      @Override public void gameIsStarting(      IStartingGame game){
        settlersFrame.showStartingGamePanel(game);
      }
      @Override public void gameAborted(){
        settlersFrame.showMainMenu();
      }
    }
);
    onPlayersChanges(connector.getPlayers(),connector);
  }
);
}"
55876,"public void setNewMultiPlayerMap(MapLoader mapLoader,IMultiplayerConnector connector){
  this.playerSlotFactory=new HostOfMultiplayerPlayerSlotFactory();
  titleLabel.setText(Labels.getString(""String_Node_Str""));
  numberOfPlayersComboBox.setEnabled(false);
  peaceTimeComboBox.setEnabled(false);
  startResourcesComboBox.setEnabled(false);
  startGameButton.setVisible(true);
  setChatVisible(true);
  setStartButtonActionListener(e -> {
  }
);
  IJoiningGame joiningGame=connector.openNewMultiplayerGame(new OpenMultiPlayerGameInfo(mapLoader));
  joiningGame.setListener(new IJoiningGameListener(){
    @Override public void joinProgressChanged(    EProgressState state,    float progress){
    }
    @Override public void gameJoined(    IJoinPhaseMultiplayerGameConnector connector){
      SwingUtilities.invokeLater(() -> {
        initializeChatFor(connector);
        setStartButtonActionListener(e -> {
          connector.startGame();
        }
);
        connector.getPlayers().setListener(changingPlayers -> onPlayersChanges(changingPlayers,connector));
        connector.setMultiplayerListener(new IMultiplayerListener(){
          @Override public void gameIsStarting(          IStartingGame game){
            settlersFrame.showStartingGamePanel(game);
          }
          @Override public void gameAborted(){
            settlersFrame.showMainMenu();
          }
        }
);
      }
);
    }
  }
);
  setCancelButtonActionListener(e -> {
    joiningGame.abort();
    settlersFrame.showMainMenu();
  }
);
  prepareUiFor(mapLoader);
}","public void setNewMultiPlayerMap(MapLoader mapLoader,IMultiplayerConnector connector){
  this.playerSlotFactory=new HostOfMultiplayerPlayerSlotFactory();
  titleLabel.setText(Labels.getString(""String_Node_Str""));
  numberOfPlayersComboBox.setEnabled(false);
  peaceTimeComboBox.setEnabled(false);
  startResourcesComboBox.setEnabled(false);
  startGameButton.setVisible(true);
  setChatVisible(true);
  setStartButtonActionListener(e -> {
  }
);
  IJoiningGame joiningGame=connector.openNewMultiplayerGame(new OpenMultiPlayerGameInfo(mapLoader));
  joiningGame.setListener(new IJoiningGameListener(){
    @Override public void joinProgressChanged(    EProgressState state,    float progress){
    }
    @Override public void gameJoined(    IJoinPhaseMultiplayerGameConnector connector){
      SwingUtilities.invokeLater(() -> {
        initializeChatFor(connector);
        setStartButtonActionListener(e -> {
          connector.startGame();
        }
);
        connector.getPlayers().setListener(changingPlayers -> onPlayersChanges(changingPlayers,connector));
        connector.setMultiplayerListener(new IMultiplayerListener(){
          @Override public void gameIsStarting(          IStartingGame game){
            settlersFrame.showStartingGamePanel(game);
          }
          @Override public void gameAborted(){
            settlersFrame.showMainMenu();
          }
        }
);
        onPlayersChanges(connector.getPlayers(),connector);
      }
);
    }
  }
);
  setCancelButtonActionListener(e -> {
    joiningGame.abort();
    settlersFrame.showMainMenu();
  }
);
  prepareUiFor(mapLoader);
}"
55877,"private void updateAiPlayerName(){
  if (typeComboBox.getSelectedItem() == null || civilisationComboBox.getSelectedItem() == null) {
    return;
  }
  if (!EPlayerType.HUMAN.equals(((PlayerTypeUiWrapper)typeComboBox.getSelectedItem()).getPlayerType())) {
    setPlayerName(Labels.getString(""String_Node_Str"" + getCivilisation().name() + ""String_Node_Str""+ ((PlayerTypeUiWrapper)typeComboBox.getSelectedItem()).getPlayerType().name()));
  }
}","private void updateAiPlayerName(){
  if (typeComboBox.getSelectedItem() == null || civilisationComboBox.getSelectedItem() == null) {
    return;
  }
  if (EPlayerType.HUMAN != (((PlayerTypeUiWrapper)typeComboBox.getSelectedItem()).getPlayerType())) {
    setPlayerName(Labels.getString(""String_Node_Str"" + getCivilisation().name() + ""String_Node_Str""+ ((PlayerTypeUiWrapper)typeComboBox.getSelectedItem()).getPlayerType().name()));
    setReady(true);
  }
 else {
    setReady(false);
  }
}"
55878,"@Override public EMaterialType tryToTakeDonkeyMaterial(){
  if (!isTargetSet()) {
    return null;
  }
  IRequestStack stack=super.getStackWithMaterial();
  if (stack != null && stack.pop()) {
    return stack.getMaterialType();
  }
 else {
    return null;
  }
}","@Override public EMaterialType tryToTakeDonkeyMaterial(){
  if (!isTargetSet()) {
    return null;
  }
  IRequestStack stack=super.getStackWithMaterial();
  if (stack != null) {
    EMaterialType materialType=stack.getMaterialType();
    if (stack.pop()) {
      return materialType;
    }
  }
  return null;
}"
55879,"@Override public boolean beforeDroppingMaterial(){
  if (request != null && request.isActive() && request.getPos().equals(super.getPos())) {
    request.deliveryFulfilled();
    return false;
  }
 else {
    return true;
  }
}","@Override public boolean beforeDroppingMaterial(){
  if (request != null) {
    if (request.isActive() && request.getPos().equals(super.getPos())) {
      request.deliveryFulfilled();
      return false;
    }
 else {
      request.deliveryAborted();
      request=null;
    }
  }
  return true;
}"
55880,"@Override public int timerEvent(){
  if (state == EMovableState.DEAD) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EMovableAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EMovableAction.NO_ACTION;
case PATHING:
case DOING_NOTHING:
if (visible) {
checkPlayerOfCurrentPosition();
}
break;
default :
break;
}
if (moveToRequest != null) {
if (strategy.isMoveToAble()) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
 else {
moveToRequest=null;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}","@Override public int timerEvent(){
  if (state == EMovableState.DEAD) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EMovableAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EMovableAction.NO_ACTION;
case PATHING:
case DOING_NOTHING:
if (visible) {
checkPlayerOfCurrentPosition();
}
break;
default :
break;
}
if (moveToRequest != null) {
if (strategy.isMoveToAble()) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
 else {
moveToRequest=null;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial.isDroppable()) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}"
55881,"@Test public void verHardShouldProduceCertainAmountOfSoldiersWithin75Minutes(){
  PlayerSetting[] playerSettings=new PlayerSetting[4];
  playerSettings[0]=new PlayerSetting(true,EPlayerType.AI_VERY_HARD);
  playerSettings[1]=new PlayerSetting(false);
  playerSettings[2]=new PlayerSetting(false);
  playerSettings[3]=new PlayerSetting(false);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(75 * MINUTES);
  ReplayUtils.awaitShutdown(startedGame);
  short expectedMinimalProducedSoldiers=250;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    fail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),50,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),50,2500);
}","@Test public void verHardShouldProduceCertainAmountOfSoldiersWithin75Minutes(){
  PlayerSetting[] playerSettings=new PlayerSetting[4];
  playerSettings[0]=new PlayerSetting(true,EPlayerType.AI_VERY_HARD,ECivilisation.ROMAN,(byte)0);
  playerSettings[1]=new PlayerSetting(false,(byte)-1);
  playerSettings[2]=new PlayerSetting(false,(byte)-1);
  playerSettings[3]=new PlayerSetting(false,(byte)-1);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  MatchConstants.clock().fastForwardTo(75 * MINUTES);
  ReplayUtils.awaitShutdown(startedGame);
  short expectedMinimalProducedSoldiers=250;
  short producedSoldiers=startingGame.getMainGrid().getPartitionsGrid().getPlayer(0).getEndgameStatistic().getAmountOfProducedSoldiers();
  if (producedSoldiers < expectedMinimalProducedSoldiers) {
    fail(""String_Node_Str"" + expectedMinimalProducedSoldiers + ""String_Node_Str""+ producedSoldiers+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),50,2500);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),50,2500);
}"
55882,"private void holdBattleBetween(EPlayerType expectedWinner,EPlayerType expectedLooser,int maximumTimeToWin){
  PlayerSetting[] playerSettings=new PlayerSetting[4];
  playerSettings[0]=new PlayerSetting(true,expectedLooser);
  playerSettings[1]=new PlayerSetting(true,expectedWinner);
  playerSettings[2]=new PlayerSetting(false);
  playerSettings[3]=new PlayerSetting(false);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  AiStatistics aiStatistics=new AiStatistics(startingGame.getMainGrid());
  int targetGameTime=0;
  do {
    targetGameTime+=JUMP_FORWARD;
    MatchConstants.clock().fastForwardTo(targetGameTime);
    aiStatistics.updateStatistics();
    if (aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.TOWER,(byte)1) == 0) {
      stopAndFail(expectedWinner + ""String_Node_Str"" + expectedLooser,startedGame);
    }
    if (MatchConstants.clock().getTime() > maximumTimeToWin) {
      MapUtils.saveMainGrid(startingGame.getMainGrid(),new PlayerState[]{new PlayerState((byte)0,null),new PlayerState((byte)1,null)});
      stopAndFail(expectedWinner + ""String_Node_Str"" + expectedLooser+ ""String_Node_Str""+ (maximumTimeToWin / 60000)+ ""String_Node_Str""+ expectedLooser+ ""String_Node_Str""+ ""String_Node_Str""+ expectedWinner+ ""String_Node_Str""+ expectedWinner+ ""String_Node_Str""+ ""String_Node_Str"",startedGame);
    }
  }
 while (aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.TOWER,(byte)0) > 0);
  System.out.println(""String_Node_Str"" + expectedWinner + ""String_Node_Str""+ expectedLooser+ ""String_Node_Str""+ (MatchConstants.clock().getTime() / 60000)+ ""String_Node_Str"");
  ReplayUtils.awaitShutdown(startedGame);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),50,3000);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),50,2500);
}","private void holdBattleBetween(EPlayerType expectedWinner,EPlayerType expectedLooser,int maximumTimeToWin){
  PlayerSetting[] playerSettings=new PlayerSetting[4];
  playerSettings[0]=new PlayerSetting(true,expectedLooser,ECivilisation.ROMAN,(byte)0);
  playerSettings[1]=new PlayerSetting(true,expectedWinner,ECivilisation.ROMAN,(byte)1);
  playerSettings[2]=new PlayerSetting(false,(byte)-1);
  playerSettings[3]=new PlayerSetting(false,(byte)-1);
  JSettlersGame.GameRunner startingGame=createStartingGame(playerSettings);
  IStartedGame startedGame=ReplayUtils.waitForGameStartup(startingGame);
  AiStatistics aiStatistics=new AiStatistics(startingGame.getMainGrid());
  int targetGameTime=0;
  do {
    targetGameTime+=JUMP_FORWARD;
    MatchConstants.clock().fastForwardTo(targetGameTime);
    aiStatistics.updateStatistics();
    if (aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.TOWER,(byte)1) == 0) {
      stopAndFail(expectedWinner + ""String_Node_Str"" + expectedLooser,startedGame);
    }
    if (MatchConstants.clock().getTime() > maximumTimeToWin) {
      MapUtils.saveMainGrid(startingGame.getMainGrid(),new PlayerState[]{new PlayerState((byte)0,null),new PlayerState((byte)1,null)});
      stopAndFail(expectedWinner + ""String_Node_Str"" + expectedLooser+ ""String_Node_Str""+ (maximumTimeToWin / 60000)+ ""String_Node_Str""+ expectedLooser+ ""String_Node_Str""+ ""String_Node_Str""+ expectedWinner+ ""String_Node_Str""+ expectedWinner+ ""String_Node_Str""+ ""String_Node_Str"",startedGame);
    }
  }
 while (aiStatistics.getNumberOfBuildingTypeForPlayer(EBuildingType.TOWER,(byte)0) > 0);
  System.out.println(""String_Node_Str"" + expectedWinner + ""String_Node_Str""+ expectedLooser+ ""String_Node_Str""+ (MatchConstants.clock().getTime() / 60000)+ ""String_Node_Str"");
  ReplayUtils.awaitShutdown(startedGame);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getApplyRulesStopWatch(),50,3000);
  ensureRuntimePerformance(""String_Node_Str"",startingGame.getAiExecutor().getUpdateStatisticsStopWatch(),50,2500);
}"
55883,"private PartitionsGridTestingWnd(){
  this.grid=new PartitionsGrid(WIDTH,HEIGHT,(byte)10,new IPartitionsGridBlockingProvider(){
    @Override public boolean isBlocked(    int x,    int y){
      return blockedGrid.get(x + y * WIDTH);
    }
    @Override public void registerBlockingChangedListener(    IBlockingChangedListener listener){
    }
  }
);
}","private PartitionsGridTestingWnd(){
  this.grid=new PartitionsGrid(WIDTH,HEIGHT,PlayerSetting.createDefaultSettings((byte)0,(byte)10),new IPartitionsGridBlockingProvider(){
    @Override public boolean isBlocked(    int x,    int y){
      return blockedGrid.get(x + y * WIDTH);
    }
    @Override public void registerBlockingChangedListener(    IBlockingChangedListener listener){
    }
  }
);
}"
55884,"@Override public void run(){
  tree.setCellRenderer(new FileTreeCellRenderer());
}","@Override public void run(){
  initHeader();
  initTree();
  add(new JScrollPane(tree),BorderLayout.CENTER);
  add(foundPanel,BorderLayout.SOUTH);
  setSize(750,640);
  setLocationRelativeTo(null);
}"
55885,"/** 
 * Constructor
 */
public SelectSettlersFolderDialog(){
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  setTitle(Labels.getString(""String_Node_Str""));
  setLayout(new BorderLayout());
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
synchronized (syncObject) {
        syncObject.notifyAll();
      }
    }
  }
);
  initHeader();
  initTree();
  add(new JScrollPane(tree),BorderLayout.CENTER);
  add(foundPanel,BorderLayout.SOUTH);
  setSize(750,640);
  setLocationRelativeTo(null);
}","/** 
 * Constructor
 */
public SelectSettlersFolderDialog(){
  setDefaultCloseOperation(DISPOSE_ON_CLOSE);
  setTitle(Labels.getString(""String_Node_Str""));
  setLayout(new BorderLayout());
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
synchronized (syncObject) {
        syncObject.notifyAll();
      }
    }
  }
);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      initHeader();
      initTree();
      add(new JScrollPane(tree),BorderLayout.CENTER);
      add(foundPanel,BorderLayout.SOUTH);
      setSize(750,640);
      setLocationRelativeTo(null);
    }
  }
);
}"
55886,"/** 
 * Initialize the Tree with the filesystem
 */
private void initTree(){
  RootTreeNode root=new RootTreeNode(executorService);
  for (  File f : File.listRoots()) {
    root.add(new FilesystemTreeNode(f));
  }
  model=new DefaultTreeModel(root);
  root.setModel(model);
  tree=new JTree(model);
  tree.addTreeSelectionListener(selectionListener);
  tree.addTreeExpansionListener(expansionListener);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  tree.expandRow(0);
  tree.setRootVisible(false);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      tree.setCellRenderer(new FileTreeCellRenderer());
    }
  }
);
}","/** 
 * Initialize the Tree with the filesystem
 */
private void initTree(){
  RootTreeNode root=new RootTreeNode(executorService);
  for (  File f : File.listRoots()) {
    root.add(new FilesystemTreeNode(f));
  }
  model=new DefaultTreeModel(root);
  root.setModel(model);
  tree=new JTree(model);
  tree.addTreeSelectionListener(selectionListener);
  tree.addTreeExpansionListener(expansionListener);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  tree.expandRow(0);
  tree.setRootVisible(false);
  tree.setCellRenderer(new FileTreeCellRenderer());
}"
55887,"/** 
 * Sets up the   {@link ResourceManager} by using a configuration file. <br>First it is checked, if the given argsMap contains a ""configFile"" parameter. If so, the path specified for this parameter is used to get the file. <br> If the parameter is not given, the defaultConfigFile is used.
 * @param argsMap
 * @param defaultConfigFileName
 * @throws FileNotFoundException
 * @throws IOException
 */
public static void setupResourceManagers(OptionableProperties options,String defaultConfigFileName) throws FileNotFoundException, IOException {
  ConfigurationPropertiesFile configFile=getConfigFile(options,defaultConfigFileName);
  SwingResourceLoader.setupResourcesManager(configFile);
  boolean firstRun=true;
  while (!configFile.isValidSettlersFolderSet() || !trySettingUpResources(configFile)) {
    if (!firstRun) {
      JOptionPane.showMessageDialog(null,Labels.getString(""String_Node_Str""));
    }
    firstRun=false;
    final SelectSettlerFolderDialog folderChooser=new SelectSettlerFolderDialog();
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        folderChooser.setVisible(true);
      }
    }
);
    File selectedFolder=folderChooser.waitForUserInput();
    if (selectedFolder == null) {
      String noFolderSelctedMessage=Labels.getString(""String_Node_Str"");
      JOptionPane.showMessageDialog(null,noFolderSelctedMessage);
      System.err.println(noFolderSelctedMessage);
      System.exit(1);
    }
    System.out.println(selectedFolder);
    try {
      configFile.setSettlersFolder(selectedFolder);
    }
 catch (    IOException ex) {
      String errorSavingSettingsMessage=Labels.getString(""String_Node_Str"");
      System.err.println(errorSavingSettingsMessage);
      JOptionPane.showMessageDialog(null,errorSavingSettingsMessage);
      ex.printStackTrace();
    }
  }
  if (!firstRun) {
    SwingResourceLoader.setupResourcesManager(configFile);
  }
}","/** 
 * Sets up the   {@link ResourceManager} by using a configuration file. <br>First it is checked, if the given argsMap contains a ""configFile"" parameter. If so, the path specified for this parameter is used to get the file. <br> If the parameter is not given, the defaultConfigFile is used.
 * @param argsMap
 * @param defaultConfigFileName
 * @throws FileNotFoundException
 * @throws IOException
 */
public static void setupResourceManagers(OptionableProperties options,String defaultConfigFileName) throws FileNotFoundException, IOException {
  ConfigurationPropertiesFile configFile=getConfigFile(options,defaultConfigFileName);
  SwingResourceLoader.setupResourcesManager(configFile);
  boolean firstRun=true;
  while (!configFile.isValidSettlersFolderSet() || !trySettingUpResources(configFile)) {
    if (!firstRun) {
      JOptionPane.showMessageDialog(null,Labels.getString(""String_Node_Str""));
    }
    firstRun=false;
    final SelectSettlersFolderDialog folderChooser=new SelectSettlersFolderDialog();
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        folderChooser.setVisible(true);
      }
    }
);
    File selectedFolder=folderChooser.waitForUserInput();
    if (selectedFolder == null) {
      String noFolderSelctedMessage=Labels.getString(""String_Node_Str"");
      JOptionPane.showMessageDialog(null,noFolderSelctedMessage);
      System.err.println(noFolderSelctedMessage);
      System.exit(1);
    }
    System.out.println(selectedFolder);
    try {
      configFile.setSettlersFolder(selectedFolder);
    }
 catch (    IOException ex) {
      String errorSavingSettingsMessage=Labels.getString(""String_Node_Str"");
      System.err.println(errorSavingSettingsMessage);
      JOptionPane.showMessageDialog(null,errorSavingSettingsMessage);
      ex.printStackTrace();
    }
  }
  if (!firstRun) {
    SwingResourceLoader.setupResourcesManager(configFile);
  }
}"
55888,"@Override public JComponent getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  super.getTreeCellRendererComponent(tree,value,selected,expanded,leaf,row,hasFocus);
  if (value instanceof FilesystemTreeNode) {
    FilesystemTreeNode node=(FilesystemTreeNode)value;
    File file=node.getFile();
    if (file == null) {
      return this;
    }
    setIcon(fileSystemView.getSystemIcon(file));
    setText(fileSystemView.getSystemDisplayName(file));
    setToolTipText(file.getPath());
    if (node.isSettlerFolder()) {
      setIcon(SETTLER_FOLDER_ICON);
    }
  }
  return this;
}","@Override public Component getTreeCellRendererComponent(JTree tree,Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){
  Component superResult=super.getTreeCellRendererComponent(tree,value,selected,expanded,leaf,row,hasFocus);
  if (value instanceof FilesystemTreeNode) {
    FilesystemTreeNode node=(FilesystemTreeNode)value;
    File file=node.getFile();
    if (file == null) {
      return superResult;
    }
    setIcon(fileSystemView.getSystemIcon(file));
    setText(fileSystemView.getSystemDisplayName(file));
    setToolTipText(file.getPath());
    if (node.isSettlerFolder()) {
      setIcon(SETTLER_FOLDER_ICON);
    }
    return this;
  }
  return superResult;
}"
55889,"/** 
 * Constructor
 * @param listener Listener for start
 */
public FolderFoundPanel(final ActionListener listener){
  setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  setLayout(new BorderLayout());
  setOpaque(true);
  add(label,BorderLayout.CENTER);
  this.btContinue=new JButton(Labels.getString(""String_Node_Str""));
  btContinue.setEnabled(false);
  btContinue.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      listener.actionPerformed(new ActionEvent(this,0,startFolder));
    }
  }
);
  add(btContinue,BorderLayout.EAST);
}","/** 
 * Constructor
 * @param listener Listener for start
 */
public FolderFoundPanel(final ActionListener listener){
  setBorder(BorderFactory.createEmptyBorder(10,10,10,10));
  setLayout(new BorderLayout());
  setOpaque(true);
  add(label,BorderLayout.CENTER);
  this.continueButton=new JButton(Labels.getString(""String_Node_Str""));
  continueButton.setEnabled(false);
  continueButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      listener.actionPerformed(new ActionEvent(this,0,startFolder));
    }
  }
);
  add(continueButton,BorderLayout.EAST);
}"
55890,"@Override public void paintComponent(Graphics g1){
  Graphics2D g=(Graphics2D)g1;
  int w=getWidth();
  int h=getHeight();
  GradientPaint gp=new GradientPaint(0,0,background1,0,h,background2);
  g.setPaint(gp);
  g.fillRect(0,0,w,h);
}","@Override public void paintComponent(Graphics g1){
  Graphics2D g=(Graphics2D)g1;
  int w=getWidth();
  int h=getHeight();
  GradientPaint gp=new GradientPaint(0,0,backgroundTop,0,h,backgroundBottom);
  g.setPaint(gp);
  g.fillRect(0,0,w,h);
}"
55891,"/** 
 * Set the folder to start with
 * @param folder Absolute path
 */
public void setFolder(String folder){
  background1=new Color(0xA4FF92);
  background2=new Color(0x4CC04E);
  label.setText(folder);
  startFolder=folder;
  btContinue.setEnabled(true);
  repaint();
}","/** 
 * Set the folder to start with
 * @param folder Absolute path
 */
public void setFolder(String folder){
  backgroundTop=FOUND_BACKGROUND_TOP;
  backgroundBottom=FOUND_BACKGROUND_BOTTOM;
  label.setText(folder);
  startFolder=folder;
  continueButton.setEnabled(true);
  repaint();
}"
55892,"public short[] getPreviewImage(int width,int height){
  if ((previewWidth == width) && (previewHeight == height) && (previewImage != null)) {
    return previewImage;
  }
  short[] outImg=new short[width * height];
  MapResourceInfo filePart=findResource(OriginalMapFileDataStructs.EMapFilePartType.PREVIEW);
  if (filePart == null)   return outImg;
  if (filePart.size < 4)   return outImg;
  if (!doDecrypt(filePart))   return outImg;
  int pos=filePart.offset;
  int wh=readBEWordFrom(pos);
  pos+=2;
  int unknown=readBEWordFrom(pos);
  pos+=2;
  float scaleX=wh / width;
  float scaleY=wh / height;
  int outIndex=0;
  int offset=pos;
  for (int y=0; y < height; y++) {
    int srcRow=offset + ((int)(Math.floor(scaleY * y)) * wh) * 2;
    for (int x=0; x < width; x++) {
      int inIndex=srcRow + ((int)Math.floor(x * scaleX)) * 2;
      int colorValue=((mapContent[inIndex] & 0xFF)) | ((mapContent[inIndex + 1] & 0xFF) << 8);
      outImg[outIndex]=(short)(1 | colorValue << 1);
      outIndex++;
    }
  }
  return outImg;
}","public short[] getPreviewImage(int width,int height){
  if ((previewWidth == width) && (previewHeight == height) && (previewImage != null)) {
    return previewImage;
  }
  short[] outImg=new short[width * height];
  MapResourceInfo filePart=findResource(OriginalMapFileDataStructs.EMapFilePartType.PREVIEW);
  if (filePart == null)   return outImg;
  if (filePart.size < 4)   return outImg;
  if (!doDecrypt(filePart))   return outImg;
  int pos=filePart.offset;
  int wh=readBEWordFrom(pos);
  pos+=2;
  @SuppressWarnings(""String_Node_Str"") int unknown=readBEWordFrom(pos);
  pos+=2;
  float scaleX=wh / width;
  float scaleY=wh / height;
  int outIndex=0;
  int offset=pos;
  for (int y=0; y < height; y++) {
    int srcRow=offset + ((int)(Math.floor(scaleY * y)) * wh) * 2;
    for (int x=0; x < width; x++) {
      int inIndex=srcRow + ((int)Math.floor(x * scaleX)) * 2;
      int colorValue=((mapContent[inIndex] & 0xFF)) | ((mapContent[inIndex + 1] & 0xFF) << 8);
      outImg[outIndex]=(short)(1 | colorValue << 1);
      outIndex++;
    }
  }
  return outImg;
}"
55893,"private void bindTexture(TextureHandle texture) throws IllegalBufferException {
  int id;
  if (texture == null) {
    id=0;
  }
 else {
    if (!texture.isValid()) {
      throw new IllegalBufferException(""String_Node_Str"" + texture);
    }
    id=texture.getInternalId();
    gl2.glBindTexture(GL.GL_TEXTURE_2D,id);
  }
}","private void bindTexture(TextureHandle texture) throws IllegalBufferException {
  int id;
  if (texture == null) {
    id=0;
  }
 else {
    if (!texture.isValid()) {
      throw new IllegalBufferException(""String_Node_Str"" + texture);
    }
    id=texture.getInternalId();
  }
  gl2.glBindTexture(GL.GL_TEXTURE_2D,id);
}"
55894,"private boolean isMilitaryBuildingInHinterland(Building militaryBuilding,byte playerId){
  for (  ShortPoint2D occupiedPosition : new MapCircle(militaryBuilding.getPos(),CommonConstants.TOWER_RADIUS)) {
    if (getBorderLandNextToFreeLandForPlayer(playerId).contains(occupiedPosition) && partitionsGrid.getTowerCountAt(occupiedPosition.x,occupiedPosition.y) == 1) {
      return false;
    }
  }
  return true;
}","private boolean isMilitaryBuildingInHinterland(Building militaryBuilding,byte playerId){
  for (  ShortPoint2D influencedPositions : new MapCircle(militaryBuilding.getPos(),CommonConstants.TOWER_RADIUS + TOWER_RADIUS_OVERLAP)) {
    if (!mainGrid.isInBounds(influencedPositions.x,influencedPositions.y)) {
      continue;
    }
    if (positionIsBorderLandAndIsProtectedOnlyFromOneTower(playerId,influencedPositions) || positionIsOtherPlayersLand(influencedPositions,playerId)) {
      return false;
    }
  }
  return true;
}"
55895,"public void readBasicMapInformation(){
  fileChecksum=0;
  widthHeight=0;
  hasBuildings=false;
  if (mapContent == null)   return;
  if (mapContent.length < 100)   return;
  fileChecksum=readBEIntFrom(0);
  readMapInfo();
  readPlayerInfo();
  readMapQuestText();
  readMapQuestTip();
  widthHeight=0;
  MapResourceInfo filePart=findResource(OriginalMapFileDataStructs.EMapFilePartType.AREA);
  if (filePart == null)   return;
  if (filePart.size < 4)   return;
  if (!doDecrypt(filePart))   return;
  int pos=filePart.offset;
  widthHeight=readBEIntFrom(pos);
}","public void readBasicMapInformation(int previewWidth,int previewHeight){
  fileChecksum=0;
  widthHeight=0;
  hasBuildings=false;
  if (mapContent == null)   return;
  if (mapContent.length < 100)   return;
  fileChecksum=readBEIntFrom(0);
  readMapInfo();
  readPlayerInfo();
  readMapQuestText();
  readMapQuestTip();
  if ((previewWidth > 0) && (previewHeight > 0)) {
    this.previewImage=getPreviewImage(previewWidth,previewHeight);
    this.previewWidth=(short)previewWidth;
    this.previewHeight=(short)previewHeight;
  }
  MapResourceInfo filePart=findResource(OriginalMapFileDataStructs.EMapFilePartType.AREA);
  if (filePart == null)   return;
  if (filePart.size < 4)   return;
  if (!doDecrypt(filePart))   return;
  int pos=filePart.offset;
  widthHeight=readBEIntFrom(pos);
}"
55896,"private boolean doDecrypt(MapResourceInfo filePart){
  if (filePart == null)   return false;
  if (mapContent == null) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  if (filePart.hasBeenDecrypted)   return true;
  int length=filePart.size;
  if (length <= 0)   return true;
  int pos=filePart.offset;
  int key=(filePart.cryptKey & 0xFF);
  for (int i=length; i > 0; i--) {
    int byt=(mapContent[pos] ^ key) & 0xFF;
    mapContent[pos]=(byte)byt;
    pos++;
    if (pos >= mapContent.length) {
      System.err.println(""String_Node_Str"");
      return false;
    }
    key=((key << 1) & 0xFF) ^ byt;
  }
  filePart.hasBeenDecrypted=true;
  return true;
}","private boolean doDecrypt(MapResourceInfo filePart){
  if (filePart == null)   return false;
  if (mapContent == null) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  if (filePart.hasBeenDecrypted)   return true;
  int length=filePart.size;
  if (length <= 0)   return true;
  int pos=filePart.offset;
  if ((pos + length) >= mapContent.length) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  int key=(filePart.cryptKey & 0xFF);
  for (int i=length; i > 0; i--) {
    int byt=(mapContent[pos] ^ key);
    key=(key << 1) ^ byt;
    mapContent[pos]=(byte)byt;
    pos++;
  }
  filePart.hasBeenDecrypted=true;
  return true;
}"
55897,"public int readBEWordFrom(int offset){
  if (mapContent == null)   return 0;
  return ((mapContent[offset] & 0xFF) << 0) | ((mapContent[offset + 1] & 0xFF) << 8);
}","public int readBEWordFrom(int offset){
  if (mapContent == null)   return 0;
  return ((mapContent[offset] & 0xFF)) | ((mapContent[offset + 1] & 0xFF) << 8);
}"
55898,"public int readBEIntFrom(int offset){
  if (mapContent == null)   return 0;
  return ((mapContent[offset] & 0xFF) << 0) | ((mapContent[offset + 1] & 0xFF) << 8) | ((mapContent[offset + 2] & 0xFF) << 16)| ((mapContent[offset + 3] & 0xFF) << 24);
}","public int readBEIntFrom(int offset){
  if (mapContent == null)   return 0;
  return ((mapContent[offset] & 0xFF)) | ((mapContent[offset + 1] & 0xFF) << 8) | ((mapContent[offset + 2] & 0xFF) << 16)| ((mapContent[offset + 3] & 0xFF) << 24);
}"
55899,"public String readCStrFrom(int offset,int length){
  if (mapContent == null)   return ""String_Node_Str"";
  if (mapContent.length <= offset + length)   return ""String_Node_Str"";
  String outStr=""String_Node_Str"";
  int pos=offset;
  for (int i=length; i > 0; i--) {
    byte b=mapContent[pos];
    pos++;
    if (b == 0)     break;
    outStr+=new String(new byte[]{b});
  }
  return outStr;
}","public String readCStrFrom(int offset,int length){
  if (mapContent == null)   return ""String_Node_Str"";
  if (mapContent.length <= offset + length)   return ""String_Node_Str"";
  int i=0;
  for (; i < length; i++) {
    if (mapContent[offset + i] == 0) {
      break;
    }
  }
  if (i == 0) {
    return ""String_Node_Str"";
  }
  return new String(mapContent,offset,i - 1,TEXT_CHARSET);
}"
55900,"boolean isChecksumValid(){
  int fileChecksum=readBEIntFrom(0);
  mapData.fileChecksum=fileChecksum;
  int count=mapContent.length & 0xFFFFFFFC;
  int currentChecksum=0;
  for (int i=8; i < count; i+=4) {
    int currentInt=readBEIntFrom(i);
    currentChecksum=((currentChecksum >>> 31) | ((currentChecksum << 1) ^ currentInt));
  }
  return (currentChecksum == fileChecksum);
}","boolean isChecksumValid(){
  int fileChecksum=readBEIntFrom(0);
  mapData.fileChecksum=fileChecksum;
  int count=mapContent.length & 0xFFFFFFFC;
  int currentChecksum=0;
  for (int i=8; i < count; i+=4) {
    int currentInt=((mapContent[i] & 0xFF)) | ((mapContent[i + 1] & 0xFF) << 8) | ((mapContent[i + 2] & 0xFF) << 16)| ((mapContent[i + 3] & 0xFF) << 24);
    currentChecksum=((currentChecksum >>> 31) | ((currentChecksum << 1) ^ currentInt));
  }
  return (currentChecksum == fileChecksum);
}"
55901,"private final boolean isValidPosition(IPathCalculatable requester,int x,int y,boolean blockedAtStart){
  return isInBounds(x,y) && (!isBlocked(requester,x,y) || blockedAtStart);
}","private final boolean isValidPosition(IPathCalculatable requester,int x,int y,short blockedAtStartPartition){
  return isInBounds(x,y) && (blockedAtStartPartition >= 0 && map.getBlockedPartition(x,y) == blockedAtStartPartition || !isBlocked(requester,x,y));
}"
55902,"@Override public final Path findPath(IPathCalculatable requester,final short sx,final short sy,final short tx,final short ty){
  final boolean blockedAtStart;
  if (!isInBounds(sx,sy)) {
    throw new InvalidStartPositionException(""String_Node_Str"",sx,sy);
  }
 else   if (!isInBounds(tx,ty) || isBlocked(requester,tx,ty) || map.getBlockedPartition(sx,sy) != map.getBlockedPartition(tx,ty)) {
    return null;
  }
 else   if (sx == tx && sy == ty) {
    return null;
  }
 else   if (isBlocked(requester,sx,sy)) {
    blockedAtStart=true;
  }
 else {
    blockedAtStart=false;
  }
  final int targetFlatIdx=getFlatIdx(tx,ty);
  closedBitSet.clear();
  openBitSet.clear();
  open.clear();
  boolean found=false;
  initStartNode(sx,sy,tx,ty);
  while (!open.isEmpty()) {
    int currFlatIdx=open.deleteMin();
    final int x=getX(currFlatIdx);
    final int y=getY(currFlatIdx);
    setClosed(x,y);
    if (targetFlatIdx == currFlatIdx) {
      found=true;
      break;
    }
    final float currPositionCosts=costs[currFlatIdx];
    for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      final int neighborX=x + xDeltaArray[i];
      final int neighborY=y + yDeltaArray[i];
      if (isValidPosition(requester,neighborX,neighborY,blockedAtStart)) {
        final int flatNeighborIdx=getFlatIdx(neighborX,neighborY);
        if (!closedBitSet.get(flatNeighborIdx)) {
          final float newCosts=currPositionCosts + map.getCost(x,y,neighborX,neighborY);
          if (openBitSet.get(flatNeighborIdx)) {
            final float oldCosts=costs[flatNeighborIdx];
            if (oldCosts > newCosts) {
              costs[flatNeighborIdx]=newCosts;
              depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
              depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
              int heuristicCosts=getHeuristicCost(neighborX,neighborY,tx,ty);
              open.increasedPriority(flatNeighborIdx,oldCosts + heuristicCosts,newCosts + heuristicCosts);
            }
          }
 else {
            costs[flatNeighborIdx]=newCosts;
            depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
            depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
            openBitSet.set(flatNeighborIdx);
            open.insert(flatNeighborIdx,newCosts + getHeuristicCost(neighborX,neighborY,tx,ty));
            map.markAsOpen(neighborX,neighborY);
          }
        }
      }
    }
  }
  if (found) {
    int pathlength=depthParentHeap[getDepthIdx(getFlatIdx(tx,ty))];
    Path path=new Path(pathlength);
    int idx=pathlength;
    int parentFlatIdx=targetFlatIdx;
    while (idx > 0) {
      idx--;
      path.insertAt(idx,(short)getX(parentFlatIdx),(short)getY(parentFlatIdx));
      parentFlatIdx=depthParentHeap[getParentIdx(parentFlatIdx)];
    }
    return path;
  }
  return null;
}","@Override public final Path findPath(IPathCalculatable requester,final short sx,final short sy,final short tx,final short ty){
  final short blockedAtStartPartition;
  if (!isInBounds(sx,sy)) {
    throw new InvalidStartPositionException(""String_Node_Str"",sx,sy);
  }
 else   if (!isInBounds(tx,ty) || isBlocked(requester,tx,ty) || map.getBlockedPartition(sx,sy) != map.getBlockedPartition(tx,ty)) {
    return null;
  }
 else   if (sx == tx && sy == ty) {
    return null;
  }
 else   if (isBlocked(requester,sx,sy)) {
    blockedAtStartPartition=map.getBlockedPartition(sx,sy);
  }
 else {
    blockedAtStartPartition=-1;
  }
  final int targetFlatIdx=getFlatIdx(tx,ty);
  closedBitSet.clear();
  openBitSet.clear();
  open.clear();
  boolean found=false;
  initStartNode(sx,sy,tx,ty);
  while (!open.isEmpty()) {
    int currFlatIdx=open.deleteMin();
    final int x=getX(currFlatIdx);
    final int y=getY(currFlatIdx);
    setClosed(x,y);
    if (targetFlatIdx == currFlatIdx) {
      found=true;
      break;
    }
    final float currPositionCosts=costs[currFlatIdx];
    for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      final int neighborX=x + xDeltaArray[i];
      final int neighborY=y + yDeltaArray[i];
      if (isValidPosition(requester,neighborX,neighborY,blockedAtStartPartition)) {
        final int flatNeighborIdx=getFlatIdx(neighborX,neighborY);
        if (!closedBitSet.get(flatNeighborIdx)) {
          final float newCosts=currPositionCosts + map.getCost(x,y,neighborX,neighborY);
          if (openBitSet.get(flatNeighborIdx)) {
            final float oldCosts=costs[flatNeighborIdx];
            if (oldCosts > newCosts) {
              costs[flatNeighborIdx]=newCosts;
              depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
              depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
              int heuristicCosts=getHeuristicCost(neighborX,neighborY,tx,ty);
              open.increasedPriority(flatNeighborIdx,oldCosts + heuristicCosts,newCosts + heuristicCosts);
            }
          }
 else {
            costs[flatNeighborIdx]=newCosts;
            depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
            depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
            openBitSet.set(flatNeighborIdx);
            open.insert(flatNeighborIdx,newCosts + getHeuristicCost(neighborX,neighborY,tx,ty));
            map.markAsOpen(neighborX,neighborY);
          }
        }
      }
    }
  }
  if (found) {
    int pathlength=depthParentHeap[getDepthIdx(getFlatIdx(tx,ty))];
    Path path=new Path(pathlength);
    int idx=pathlength;
    int parentFlatIdx=targetFlatIdx;
    while (idx > 0) {
      idx--;
      path.insertAt(idx,(short)getX(parentFlatIdx),(short)getY(parentFlatIdx));
      parentFlatIdx=depthParentHeap[getParentIdx(parentFlatIdx)];
    }
    return path;
  }
  return null;
}"
55903,"private Building determineTowerToAttack(byte enemyToAttackId){
  List<ShortPoint2D> myMilitaryBuildings=aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.TOWER,player.playerId);
  myMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.BIG_TOWER,player.playerId));
  myMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.CASTLE,player.playerId));
  ShortPoint2D myBaseAveragePoint=aiStatistics.calculateAveragePointFromList(myMilitaryBuildings);
  List<ShortPoint2D> enemyMilitaryBuildings=aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.TOWER,enemyToAttackId);
  enemyMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.BIG_TOWER,enemyToAttackId));
  enemyMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.CASTLE,enemyToAttackId));
  if (enemyMilitaryBuildings.size() == 0) {
    return null;
  }
  return aiStatistics.getBuildingAt(AiStatistics.detectNearestPointFromList(myBaseAveragePoint,enemyMilitaryBuildings));
}","private Building determineTowerToAttack(byte enemyToAttackId){
  List<ShortPoint2D> myMilitaryBuildings=new ArrayList<>();
  myMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.TOWER,player.playerId));
  myMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.BIG_TOWER,player.playerId));
  myMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.CASTLE,player.playerId));
  ShortPoint2D myBaseAveragePoint=aiStatistics.calculateAveragePointFromList(myMilitaryBuildings);
  List<ShortPoint2D> enemyMilitaryBuildings=new ArrayList<>();
  enemyMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.TOWER,enemyToAttackId));
  enemyMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.BIG_TOWER,enemyToAttackId));
  enemyMilitaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(EBuildingType.CASTLE,enemyToAttackId));
  if (enemyMilitaryBuildings.size() == 0) {
    return null;
  }
  return aiStatistics.getBuildingAt(AiStatistics.detectNearestPointFromList(myBaseAveragePoint,enemyMilitaryBuildings));
}"
55904,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (pathTarget != null) {
    super.getStrategyGrid().setMarked(pathTarget,false);
  }
  if (state == EDiggerState.JOBLESS) {
    super.getStrategyGrid().removeJobless(this);
  }
  if (requester != null) {
    abortJob();
  }
  state=EDiggerState.DEAD_OBJECT;
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (pathTarget != null) {
    super.getStrategyGrid().setMarked(pathTarget,false);
  }
switch (state) {
case JOBLESS:
    super.getStrategyGrid().removeJobless(this);
  break;
case PLAYING_ACTION:
super.getStrategyGrid().setMarked(super.getPos(),false);
break;
default :
break;
}
if (requester != null) {
abortJob();
}
state=EDiggerState.DEAD_OBJECT;
}"
55905,"/** 
 * Occupies the given area for the given player.
 * @param player
 * @param influencingArea
 */
void occupyAreaByTower(Player player,MapCircle influencingArea);","/** 
 * Occupies the given area for the given player.
 * @param player
 * @param influencingArea
 */
void occupyAreaByTower(Player player,MapCircle influencingArea,final FreeMapArea groundArea);"
55906,"private final void occupyAreaIfNeeded(){
  if (!occupiedArea) {
    MapCircle occupying=new MapCircle(super.getPos(),CommonConstants.TOWER_RADIUS);
    super.getGrid().occupyAreaByTower(super.getPlayer(),occupying);
    occupiedArea=true;
  }
}","private final void occupyAreaIfNeeded(){
  if (!occupiedArea) {
    MapCircle occupying=new MapCircle(super.getPos(),CommonConstants.TOWER_RADIUS);
    super.getGrid().occupyAreaByTower(super.getPlayer(),occupying,getGroundArea());
    occupiedArea=true;
  }
}"
55907,"@Override public void occupyAreaByTower(Player player,MapCircle influencingArea){
  partitionsGrid.addTowerAndOccupyArea(player.playerId,influencingArea);
  checkAllPositionsForEnclosedBlockedAreas(influencingArea);
}","@Override public void occupyAreaByTower(Player player,MapCircle influencingArea,FreeMapArea groundArea){
  partitionsGrid.addTowerAndOccupyArea(player.playerId,influencingArea,groundArea);
  checkAllPositionsForEnclosedBlockedAreas(influencingArea);
}"
55908,"/** 
 * Occupies the given area for the given playerId if it is not already occupied by towers of an enemy.
 * @param playerId The id of the occupying player.
 * @param influencingArea The area affected by the tower.
 */
public void addTowerAndOccupyArea(byte playerId,MapCircle influencingArea){
  IMapArea filteredArea=new FilteredMapArea(influencingArea,new ISerializablePredicate<ShortPoint2D>(){
    private static final long serialVersionUID=-6460916149912865762L;
    @Override public boolean evaluate(    ShortPoint2D pos){
      return 0 <= pos.x && pos.x < width && 0 <= pos.y && pos.y < height;
    }
  }
);
  occupyArea(playerId,filteredArea,influencingArea.getBorders());
  occupyingTowers.add(new PartitionOccupyingTower(playerId,influencingArea.getCenter(),filteredArea,influencingArea.getBorders(),(int)influencingArea.getRadius()));
}","/** 
 * Occupies the given area for the given playerId if it is not already occupied by towers of an enemy.
 * @param playerId The id of the occupying player.
 * @param influencingArea The area affected by the tower.
 * @param groundArea The ground area of the tower.
 */
public void addTowerAndOccupyArea(byte playerId,MapCircle influencingArea,FreeMapArea groundArea){
  IMapArea filteredArea=new FilteredMapArea(influencingArea,new ISerializablePredicate<ShortPoint2D>(){
    private static final long serialVersionUID=-6460916149912865762L;
    @Override public boolean evaluate(    ShortPoint2D pos){
      return 0 <= pos.x && pos.x < width && 0 <= pos.y && pos.y < height;
    }
  }
);
  PartitionOccupyingTower tower=new PartitionOccupyingTower(playerId,influencingArea.getCenter(),filteredArea,influencingArea.getBorders(),(int)influencingArea.getRadius());
  occupyAreaOfTower(groundArea,tower);
}"
55909,"private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,new FreeMapArea(pos,EBuildingType.TOWER.getProtectedTiles()));
}","private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,getGroundArea(pos));
}"
55910,"private void addTower(int playerId,int x,int y,int radius){
  grid.addTowerAndOccupyArea((byte)playerId,getTowerCircle(x,y,radius));
}","private void addTower(int playerId,int x,int y,int radius){
  grid.addTowerAndOccupyArea((byte)playerId,getTowerCircle(x,y,radius),getGroundArea(new ShortPoint2D(x,y)));
}"
55911,"private void addTower(int playerId,int x,int y,int radius){
  blockArea(getTowerBlockArea(x,y),true);
  grid.addTowerAndOccupyArea((byte)playerId,new MapCircle(new ShortPoint2D(x,y),radius));
}","private void addTower(int playerId,int x,int y,int radius){
  blockArea(getTowerBlockArea(x,y),true);
  grid.addTowerAndOccupyArea((byte)playerId,new MapCircle(new ShortPoint2D(x,y),radius),getGroundArea(new ShortPoint2D(x,y)));
}"
55912,"private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,new FreeMapArea(pos,EBuildingType.TOWER.getProtectedTiles()));
}","private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,getGroundArea(pos));
}"
55913,"@Override public int timerEvent(){
  if (state == EMovableState.DEAD) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EMovableAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EMovableAction.NO_ACTION;
case PATHING:
case DOING_NOTHING:
if (visible) {
checkPlayerOfCurrentPosition();
}
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}","@Override public int timerEvent(){
  if (state == EMovableState.DEAD) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EMovableAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EMovableAction.NO_ACTION;
case PATHING:
case DOING_NOTHING:
if (visible) {
checkPlayerOfCurrentPosition();
}
break;
default :
break;
}
if (moveToRequest != null) {
if (strategy.isMoveToAble()) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
 else {
moveToRequest=null;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EMovableAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EMovableAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}"
55914,"@Override protected void pathAborted(ShortPoint2D pathTarget){
  state=ESoldierState.AGGRESSIVE;
}","@Override protected void pathAborted(ShortPoint2D pathTarget){
switch (state) {
case INIT_GOTO_TOWER:
case GOING_TO_TOWER:
    notifyTowerThatRequestFailed();
  break;
default :
state=ESoldierState.AGGRESSIVE;
break;
}
}"
55915,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  if (!isEnemyAttackable(enemy,isInTower)) {
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  }
 else {
    hitEnemy(enemy);
    if (state != ESoldierState.HITTING) {
      break;
    }
    if (enemy.getHealth() <= 0) {
      enemy=null;
      changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
      break;
    }
  }
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
case SEARCH_FOR_ENEMIES:
final short minSearchDistance=getMinSearchDistance();
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),minSearchDistance,getMaxSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (minSearchDistance > 0) {
IAttackable toCloseEnemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),(short)0,minSearchDistance,!defending);
if (toCloseEnemy != null) {
if (!isInTower) {
EDirection escapeDirection=EDirection.getApproxDirection(toCloseEnemy.getPos(),getMovable().getPos());
super.goInDirection(escapeDirection,false);
super.getMovable().moveTo(null);
}
break;
}
}
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
}
 else if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  if (!isEnemyAttackable(enemy,isInTower)) {
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  }
 else {
    hitEnemy(enemy);
    if (state != ESoldierState.HITTING) {
      break;
    }
    if (enemy.getHealth() <= 0) {
      enemy=null;
      changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
      break;
    }
  }
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
case SEARCH_FOR_ENEMIES:
final short minSearchDistance=getMinSearchDistance();
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),minSearchDistance,getMaxSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (minSearchDistance > 0) {
IAttackable toCloseEnemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),(short)0,minSearchDistance,!defending);
if (toCloseEnemy != null) {
if (!isInTower) {
EDirection escapeDirection=EDirection.getApproxDirection(toCloseEnemy.getPos(),getMovable().getPos());
super.goInDirection(escapeDirection,false);
super.getMovable().moveTo(null);
}
break;
}
}
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
}
 else if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
changeStateTo(ESoldierState.GOING_TO_TOWER);
if (!super.getPos().equals(building.getDoor()) && !super.goToPos(building.getDoor())) {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}"
55916,"@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  boolean result=!((state == ESoldierState.SEARCH_FOR_ENEMIES || state == ESoldierState.HITTING) && step >= 2);
  if (!result && oldPathTarget == null) {
    oldPathTarget=pathTarget;
  }
  if (state == ESoldierState.GOING_TO_TOWER && (!building.isNotDestroyed() || building.getPlayer() != super.getPlayer())) {
    result=false;
  }
  if (enemy != null && state == ESoldierState.SEARCH_FOR_ENEMIES && isEnemyAttackable(enemy,false)) {
    result=false;
  }
  return result;
}","@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  if (state == ESoldierState.INIT_GOTO_TOWER) {
    return false;
  }
  boolean result=!((state == ESoldierState.SEARCH_FOR_ENEMIES || state == ESoldierState.HITTING) && step >= 2);
  if (!result && oldPathTarget == null) {
    oldPathTarget=pathTarget;
  }
  if (state == ESoldierState.GOING_TO_TOWER && (!building.isNotDestroyed() || building.getPlayer() != super.getPlayer())) {
    result=false;
  }
  if (enemy != null && state == ESoldierState.SEARCH_FOR_ENEMIES && isEnemyAttackable(enemy,false)) {
    result=false;
  }
  return result;
}"
55917,"private PlayerSetting[] determinePlayerSettings(boolean[] availablePlayers){
  boolean aiPlayersEnabled=iAmTheHost;
  PlayerSetting[] playerSettings=new PlayerSetting[availablePlayers.length];
  for (byte i=0; i < playersList.getItems().size(); i++) {
    playerSettings[i]=new PlayerSetting(true);
  }
  for (byte i=(byte)playersList.getItems().size(); i < availablePlayers.length; i++) {
    playerSettings[i]=new PlayerSetting(CommonConstants.ENABLE_AI && aiPlayersEnabled,EWhatToDoAiType.getTypeByIndex(i));
  }
  return playerSettings;
}","private PlayerSetting[] determinePlayerSettings(boolean[] availablePlayers){
  PlayerSetting[] playerSettings=new PlayerSetting[availablePlayers.length];
  byte i=0;
  for (; i < playersList.getItems().size(); i++) {
    playerSettings[i]=new PlayerSetting(true);
  }
  EWhatToDoAiType aiType=iAmTheHost ? EWhatToDoAiType.ROMAN_VERY_HARD : null;
  for (; i < availablePlayers.length; i++) {
    playerSettings[i]=new PlayerSetting(true,aiType);
  }
  return playerSettings;
}"
55918,"private final void setPositionsToMap(boolean[][] areaMap,List<ShortPoint2D> positions){
  for (  ShortPoint2D curr : positions) {
    areaMap[getMapX(curr)][getMapY(curr)]=true;
  }
}","/** 
 * Sets the positions to the map and returns the upper left position
 * @param areaMap
 * @param positions
 * @return
 */
private final ShortPoint2D setPositionsToMap(boolean[][] areaMap,List<ShortPoint2D> positions){
  if (positions.isEmpty()) {
    return null;
  }
  ShortPoint2D upperLeft=positions.get(0);
  for (  ShortPoint2D curr : positions) {
    areaMap[getMapX(curr)][getMapY(curr)]=true;
    if (curr.y < upperLeft.y || curr.y == upperLeft.y && curr.x < upperLeft.x) {
      upperLeft=curr;
    }
  }
  return upperLeft;
}"
55919,"@Override public final boolean contains(ShortPoint2D pos){
  return isValidPos(pos) && areaMap[getMapX(pos)][getMapY(pos)];
}","public boolean contains(int x,int y){
  int dx=x - xOffset;
  int dy=y - yOffset;
  return isValidMapPos(dx,dy) && areaMap[dx][dy];
}"
55920,"/** 
 * Checks if other towers that intersect the area of the given tower can occupy free positions of the area of the given tower and lets them do so.
 * @param tower
 */
private void checkOtherTowersInArea(PartitionOccupyingTower tower){
  IPredicate<ShortPoint2D> predicate=new IPredicate<ShortPoint2D>(){
    @Override public boolean evaluate(    ShortPoint2D pos){
      final int idx=pos.x + pos.y * width;
      return towers[idx] <= 0;
    }
  }
;
  ArrayList<ShortPoint2D> freedPositions=new IteratorFilter<ShortPoint2D>(tower.area,predicate).toList();
  if (!freedPositions.isEmpty()) {
    List<Tuple<Integer,PartitionOccupyingTower>> towersInRange=occupyingTowers.getTowersInRange(tower.position,tower.radius);
    Collections.sort(towersInRange,Tuple.<Integer,PartitionOccupyingTower>getE1Comparator());
    for (    Tuple<Integer,PartitionOccupyingTower> curr : towersInRange) {
      if (curr.e2.playerId == tower.playerId) {
        continue;
      }
      PartitionOccupyingTower currTower=curr.e2;
      final IMapArea currArea=currTower.area;
      IteratorFilter<ShortPoint2D> area=new IteratorFilter<ShortPoint2D>(freedPositions,new IPredicate<ShortPoint2D>(){
        @Override public boolean evaluate(        ShortPoint2D object){
          return currArea.contains(object);
        }
      }
);
      occupyAreaByTower(currTower.playerId,area,currTower.areaBorders);
    }
  }
}","/** 
 * Checks if other towers that intersect the area of the given tower can occupy free positions of the area of the given tower and lets them do so.
 * @param tower
 */
private void checkOtherTowersInArea(PartitionOccupyingTower tower){
  IPredicate<ShortPoint2D> predicate=new IPredicate<ShortPoint2D>(){
    @Override public boolean evaluate(    ShortPoint2D pos){
      final int idx=pos.x + pos.y * width;
      return towers[idx] <= 0;
    }
  }
;
  ArrayList<ShortPoint2D> freedPositions=new IteratorFilter<ShortPoint2D>(tower.area,predicate).toList();
  if (!freedPositions.isEmpty()) {
    List<Tuple<Integer,PartitionOccupyingTower>> towersInRange=occupyingTowers.getTowersInRange(tower.position,tower.radius);
    Collections.sort(towersInRange,Tuple.<Integer,PartitionOccupyingTower>getE1Comparator());
    for (    Tuple<Integer,PartitionOccupyingTower> curr : towersInRange) {
      if (curr.e2.playerId == tower.playerId) {
        continue;
      }
      final PartitionOccupyingTower currTower=curr.e2;
      final IMapArea currArea=currTower.area;
      IteratorFilter<ShortPoint2D> area=new IteratorFilter<ShortPoint2D>(freedPositions,new IPredicate<ShortPoint2D>(){
        @Override public boolean evaluate(        ShortPoint2D object){
          return currArea.contains(object);
        }
      }
);
      occupyAreaByTower(currTower.playerId,area,currTower.areaBorders);
      PartitionsListingBorderVisitor borderVisitor=new PartitionsListingBorderVisitor(this,blockingProvider);
      final FreeMapArea groundArea=currTower.groundArea;
      ShortPoint2D upperLeftGroundAreaPosition=groundArea.getUpperLeftPosition();
      BorderTraversingAlgorithm.traverseBorder(new IContainingProvider(){
        @Override public boolean contains(        int x,        int y){
          return groundArea.contains(x,y);
        }
      }
,upperLeftGroundAreaPosition,borderVisitor,true);
      checkMergesAndDividesOnPartitionsList(currTower.playerId,getPartitionIdAt(upperLeftGroundAreaPosition.x,upperLeftGroundAreaPosition.y),borderVisitor.getPartitionsList());
    }
  }
}"
55921,"@Test public void testDividePartitionsByRemovingTower(){
  addTower(0,50,100,40);
  PartitionManager partition=grid.getPartitionAt(50,100);
  ShortPoint2D materialPos=new ShortPoint2D(75,100);
  partition.addOffer(materialPos,EMaterialType.STONE);
  partition.addOffer(materialPos,EMaterialType.STONE);
  addTower(0,150,100,40);
  assertTrue(grid.getPartitionIdAt(50,100) != grid.getPartitionIdAt(150,100));
  addTower(0,100,100,40);
  assertEquals(grid.getPartitionIdAt(50,100),grid.getPartitionIdAt(150,100));
  assertEquals(grid.getPartitionIdAt(100,100),grid.getPartitionIdAt(150,100));
  addTower(1,75,55,42);
  addTower(1,125,150,42);
  assertEquals(grid.getPartitionIdAt(50,100),grid.getPartitionIdAt(150,100));
  removeTower(100,100);
  assertTrue(grid.getPartitionIdAt(50,100) != grid.getPartitionIdAt(150,100));
  assertCircleIs(getTowerCircle(50,100,40),grid.getPartitionIdAt(50,100));
  assertCircleIs(getTowerCircle(150,100,40),grid.getPartitionIdAt(150,100));
  assertEquals(grid.getPartitionIdAt(75,55),grid.getPartitionIdAt(125,150));
  assertOfferAt(materialPos,EMaterialType.STONE,2);
}","@Test public void testDividePartitionsByRemovingTower(){
  addTower(0,50,100,40);
  PartitionManager partition=grid.getPartitionAt(50,100);
  ShortPoint2D materialPos=new ShortPoint2D(75,100);
  partition.addOffer(materialPos,EMaterialType.STONE);
  partition.addOffer(materialPos,EMaterialType.STONE);
  addTower(0,150,100,40);
  assertTrue(grid.getPartitionIdAt(50,100) != grid.getPartitionIdAt(150,100));
  addTower(0,100,100,40);
  assertEquals(grid.getPartitionIdAt(50,100),grid.getPartitionIdAt(150,100));
  assertEquals(grid.getPartitionIdAt(100,100),grid.getPartitionIdAt(150,100));
  addTower(1,75,55,42);
  addTower(1,120,145,42);
  assertEquals(grid.getPartitionIdAt(50,100),grid.getPartitionIdAt(150,100));
  removeTower(100,100);
  assertTrue(grid.getPartitionIdAt(50,100) != grid.getPartitionIdAt(150,100));
  assertCircleIs(getTowerCircle(50,100,40),grid.getPartitionIdAt(50,100));
  assertCircleIs(getTowerCircle(150,100,40),grid.getPartitionIdAt(150,100));
  assertEquals(grid.getPartitionIdAt(75,55),grid.getPartitionIdAt(120,145));
  assertEquals(grid.getPartitionIdAt(74,55),grid.getPartitionIdAt(120,145));
  assertEquals(grid.getPartitionIdAt(75,55),grid.getPartitionIdAt(121,145));
  assertOfferAt(materialPos,EMaterialType.STONE,2);
}"
55922,"private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,getGroundArea(pos));
}","private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer);
}"
55923,"@Override public int timerEvent(){
  if (health <= 0) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EAction.NO_ACTION;
checkPlayerOfCurrentPosition();
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}","@Override public int timerEvent(){
  if (state == EMovableState.DEAD) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EAction.NO_ACTION;
checkPlayerOfCurrentPosition();
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}"
55924,"/** 
 * kills this movable.
 */
@Override public final void kill(){
  if (health <= -100) {
    return;
  }
  grid.leavePosition(this.position,this);
  this.health=-200;
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  movablesByID.remove(this.getID());
  allMovables.remove(this);
  grid.addSelfDeletingMapObject(position,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,player);
}","/** 
 * kills this movable.
 */
@Override public final void kill(){
  if (state == EMovableState.DEAD) {
    return;
  }
  grid.leavePosition(this.position,this);
  this.health=-200;
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  this.state=EMovableState.DEAD;
  movablesByID.remove(this.getID());
  allMovables.remove(this);
  grid.addSelfDeletingMapObject(position,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,player);
}"
55925,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
        if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
          goSinglePathStep();
        }
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
        if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
          goSinglePathStep();
        }
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
55926,"@Override public int timerEvent(){
  if (health <= 0) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EAction.NO_ACTION;
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}","@Override public int timerEvent(){
  if (health <= 0) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EAction.NO_ACTION;
checkPlayerOfCurrentPosition();
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}"
55927,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
        if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
          goSinglePathStep();
        }
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
        if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
          goSinglePathStep();
        }
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessfully=blockingMovable.push(this);
    if (!pushedSuccessfully) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
55928,"@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  return step <= 2;
}","@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  if (lastCheckedPathStep == step) {
    pathStepCheckedCounter++;
    searchesCounter++;
  }
 else {
    pathStepCheckedCounter=0;
    lastCheckedPathStep=(short)step;
  }
  return !super.isValidPosition(super.getPos()) && pathStepCheckedCounter < 5;
}"
55929,"@Override protected void action(){
  ShortPoint2D position=super.getPos();
  if (!super.isValidPosition(position)) {
    if (searchesCounter > 120) {
      super.getMovable().kill();
      return;
    }
    if (super.preSearchPath(true,position.x,position.y,Constants.MOVABLE_FLEE_TO_VALID_POSITION_RADIUS,ESearchType.VALID_FREE_POSITION)) {
      super.followPresearchedPath();
    }
 else {
      EDirection currentDirection=super.getMovable().getDirection();
      EDirection newDirection;
      if (turnNextTime || MatchConstants.random().nextFloat() < 0.10) {
        turnNextTime=false;
        newDirection=currentDirection.getNeighbor(MatchConstants.random().nextInt(-1,1));
      }
 else {
        newDirection=currentDirection;
      }
      ShortPoint2D newPos=newDirection.getNextHexPoint(position);
      if (super.getStrategyGrid().isFreePosition(newPos)) {
        super.goInDirection(newDirection,true);
        turnNextTime=MatchConstants.random().nextInt(7) == 0;
      }
 else {
        super.lookInDirection(newDirection);
        turnNextTime=true;
      }
    }
    searchesCounter++;
  }
 else {
    super.convertTo(super.getMovable().getMovableType());
  }
}","@Override protected void action(){
  ShortPoint2D position=super.getPos();
  if (!super.isValidPosition(position)) {
    if (searchesCounter > 120) {
      super.getMovable().kill();
      return;
    }
    if (super.preSearchPath(true,position.x,position.y,Constants.MOVABLE_FLEEING_DIJKSTRA_RADIUS,ESearchType.VALID_FREE_POSITION) || super.preSearchPath(false,position.x,position.y,Constants.MOVABLE_FLEEING_MAX_RADIUS,ESearchType.VALID_FREE_POSITION)) {
      lastCheckedPathStep=Integer.MIN_VALUE;
      super.followPresearchedPath();
    }
 else {
      EDirection currentDirection=super.getMovable().getDirection();
      EDirection newDirection;
      if (turnNextTime || MatchConstants.random().nextFloat() < 0.10) {
        turnNextTime=false;
        newDirection=currentDirection.getNeighbor(MatchConstants.random().nextInt(-1,1));
      }
 else {
        newDirection=currentDirection;
      }
      ShortPoint2D newPos=newDirection.getNextHexPoint(position);
      if (super.getStrategyGrid().isFreePosition(newPos)) {
        super.goInDirection(newDirection,true);
        turnNextTime=MatchConstants.random().nextInt(7) == 0;
      }
 else {
        super.lookInDirection(newDirection);
        turnNextTime=true;
      }
    }
    searchesCounter++;
  }
 else {
    super.convertTo(super.getMovable().getMovableType());
  }
}"
55930,"private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
  ois.defaultReadObject();
  updateCombatStrengths();
}","private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
  ois.defaultReadObject();
  combatStrengthInfo=new CombatStrengthInformation();
  updateCombatStrengths();
}"
55931,"private void updateCombatStrengths(){
  int amountOfGold=getAmountOf(EMaterialType.GOLD);
  this.combatStrengthInfo=CombatStrengthCalculator.calculateCombatStrengthInformation(numberOfPlayers,amountOfGold);
}","private void updateCombatStrengths(){
  int amountOfGold=getAmountOf(EMaterialType.GOLD);
  this.combatStrengthInfo.updateGoldCombatStrength(numberOfPlayers,amountOfGold);
}"
55932,"@Override public int timerEvent(){
  if (health <= 0) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EAction.NO_ACTION;
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
grid.dropMaterial(position,takeDropMaterial,strategy.offerDroppedMaterial());
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}","@Override public int timerEvent(){
  if (health <= 0) {
    return -1;
  }
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
case TAKE:
case DROP:
case PATHING:
case WAITING:
    int remainingAnimationTime=animationStartTime + animationDuration - MatchConstants.clock().getTime();
  if (remainingAnimationTime > 0) {
    return remainingAnimationTime;
  }
break;
default :
break;
}
switch (state) {
case TAKE:
case DROP:
if (this.movableAction != EAction.RAISE_UP) {
break;
}
case WAITING:
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
state=EMovableState.DOING_NOTHING;
movableAction=EAction.NO_ACTION;
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
this.path=null;
case DOING_NOTHING:
ShortPoint2D oldTargetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,oldTargetPos,path.getTargetPos());
return animationDuration;
}
 else {
break;
}
default :
break;
}
}
switch (state) {
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
setState(EMovableState.DOING_NOTHING);
this.movableAction=EAction.NO_ACTION;
break;
case PATHING:
pathingAction();
break;
case TAKE:
grid.takeMaterial(position,takeDropMaterial);
setMaterial(takeDropMaterial);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
case DROP:
if (takeDropMaterial != null && takeDropMaterial != EMaterialType.NO_MATERIAL) {
boolean offerMaterial=strategy.beforeDroppingMaterial();
grid.dropMaterial(position,takeDropMaterial,offerMaterial);
}
setMaterial(EMaterialType.NO_MATERIAL);
playAnimation(EAction.RAISE_UP,Constants.MOVABLE_BEND_DURATION);
break;
default :
break;
}
if (state == EMovableState.DOING_NOTHING) {
strategy.action();
if (state == EMovableState.DOING_NOTHING) {
if (visible && enableNothingToDo) {
return doingNothingAction();
}
 else {
return Constants.MOVABLE_INTERRUPT_PERIOD;
}
}
}
return animationDuration;
}"
55933,"private void calculateForPosition(ShortPoint2D position){
  short x=position.x;
  short y=position.y;
  byte player=grid.getPlayerIdAt(x,y);
  boolean isBorder=false;
  if (grid.getBlockedPartition(x,y) > 0) {
    for (    EDirection currDir : EDirection.values) {
      short currNeighborX=currDir.getNextTileX(x);
      short currNeighborY=currDir.getNextTileY(y);
      if (!grid.isInBounds(currNeighborX,currNeighborY)) {
        continue;
      }
      byte neighborPlayer=grid.getPlayerIdAt(currNeighborX,currNeighborY);
      boolean neighborIsBorder=false;
      if (neighborPlayer != player) {
        isBorder=true;
      }
      if (grid.getBlockedPartition(currNeighborX,currNeighborY) <= 0) {
        continue;
      }
      if (neighborPlayer >= 0) {
        for (        EDirection currNeighborDir : EDirection.values) {
          short nextX=currNeighborDir.getNextTileX(currNeighborX);
          short nextY=currNeighborDir.getNextTileY(currNeighborY);
          if (grid.isInBounds(nextX,nextY) && grid.getPlayerIdAt(nextX,nextY) != neighborPlayer && grid.getBlockedPartition(nextX,nextY) > 0) {
            neighborIsBorder=true;
            break;
          }
        }
      }
      grid.setBorderAt(currNeighborX,currNeighborY,neighborIsBorder);
    }
  }
  grid.setBorderAt(x,y,isBorder && player >= 0);
}","private void calculateForPosition(ShortPoint2D position){
  short x=position.x;
  short y=position.y;
  byte player=grid.getPlayerIdAt(x,y);
  boolean isBorder=false;
  if (grid.getBlockedPartition(x,y) > 0) {
    for (    EDirection currDir : EDirection.values) {
      short currNeighborX=currDir.getNextTileX(x);
      short currNeighborY=currDir.getNextTileY(y);
      if (!grid.isInBounds(currNeighborX,currNeighborY)) {
        continue;
      }
      if (grid.getBlockedPartition(currNeighborX,currNeighborY) <= 0) {
        continue;
      }
      byte neighborPlayer=grid.getPlayerIdAt(currNeighborX,currNeighborY);
      boolean neighborIsBorder=false;
      if (neighborPlayer != player) {
        isBorder=true;
      }
      if (neighborPlayer >= 0) {
        for (        EDirection currNeighborDir : EDirection.values) {
          short nextX=currNeighborDir.getNextTileX(currNeighborX);
          short nextY=currNeighborDir.getNextTileY(currNeighborY);
          if (grid.isInBounds(nextX,nextY) && grid.getPlayerIdAt(nextX,nextY) != neighborPlayer && grid.getBlockedPartition(nextX,nextY) > 0) {
            neighborIsBorder=true;
            break;
          }
        }
      }
      grid.setBorderAt(currNeighborX,currNeighborY,neighborIsBorder);
    }
  }
  grid.setBorderAt(x,y,isBorder && player >= 0);
}"
55934,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
55935,"protected Path findWayAroundObstacle(EDirection direction,ShortPoint2D position,Path path){
  if (!path.hasOverNextStep()) {
    return path;
  }
  AbstractStrategyGrid grid=movable.getStrategyGrid();
  EDirection leftDir=direction.getNeighbor(-1);
  EDirection rightDir=direction.getNeighbor(1);
  ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
  ShortPoint2D leftStraightPos=direction.getNextHexPoint(leftPos);
  ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
  ShortPoint2D rightStraightPos=direction.getNextHexPoint(rightPos);
  ShortPoint2D twoStraight=direction.getNextHexPoint(position,2);
  ShortPoint2D overNextPos=path.getOverNextPos();
  if (twoStraight.equals(overNextPos)) {
    if (isValidPosition(leftPos) && grid.hasNoMovableAt(leftPos.x,leftPos.y) && isValidPosition(leftStraightPos)) {
      path.goToNextStep();
      path=new Path(path,leftPos,leftStraightPos);
    }
 else     if (isValidPosition(rightPos) && grid.hasNoMovableAt(rightPos.x,rightPos.y) && isValidPosition(rightStraightPos)) {
      path.goToNextStep();
      path=new Path(path,rightPos,rightStraightPos);
    }
 else {
    }
  }
 else   if (leftStraightPos.equals(overNextPos) && grid.hasNoMovableAt(leftPos.x,leftPos.y)) {
    path.goToNextStep();
    path=new Path(path,leftPos);
  }
 else   if (rightStraightPos.equals(overNextPos) && grid.hasNoMovableAt(rightPos.x,rightPos.y)) {
    path.goToNextStep();
    path=new Path(path,rightPos);
  }
 else {
  }
  return path;
}","protected Path findWayAroundObstacle(EDirection direction,ShortPoint2D position,Path path){
  if (!path.hasOverNextStep()) {
    return path;
  }
  AbstractStrategyGrid grid=movable.getStrategyGrid();
  EDirection leftDir=direction.getNeighbor(-1);
  EDirection rightDir=direction.getNeighbor(1);
  ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
  ShortPoint2D leftStraightPos=direction.getNextHexPoint(leftPos);
  ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
  ShortPoint2D rightStraightPos=direction.getNextHexPoint(rightPos);
  ShortPoint2D twoStraight=direction.getNextHexPoint(position,2);
  ShortPoint2D overNextPos=path.getOverNextPos();
  if (twoStraight.equals(overNextPos)) {
    if (isValidPosition(leftPos) && grid.hasNoMovableAt(leftPos.x,leftPos.y) && isValidPosition(leftStraightPos)) {
      path.goToNextStep();
      path=new Path(path,leftPos,leftStraightPos);
    }
 else     if (isValidPosition(rightPos) && grid.hasNoMovableAt(rightPos.x,rightPos.y) && isValidPosition(rightStraightPos)) {
      path.goToNextStep();
      path=new Path(path,rightPos,rightStraightPos);
    }
 else {
    }
  }
 else   if (leftStraightPos.equals(overNextPos) && isValidPosition(leftPos) && grid.hasNoMovableAt(leftPos.x,leftPos.y)) {
    path.goToNextStep();
    path=new Path(path,leftPos);
  }
 else   if (rightStraightPos.equals(overNextPos) && isValidPosition(rightPos) && grid.hasNoMovableAt(rightPos.x,rightPos.y)) {
    path.goToNextStep();
    path=new Path(path,rightPos);
  }
 else {
  }
  return path;
}"
55936,"private void handleWorkerRequest(){
  WorkerRequest workerRequest=workerRequests.poll();
  if (workerRequest != null) {
    IManageableWorker worker=joblessWorkers.removeObjectNextTo(workerRequest.getPos(),new MovableTypeAcceptor(workerRequest.movableType));
    if (worker != null) {
      worker.setWorkerJob(workerRequest.building);
    }
 else {
      if (!workerRequest.creationRequested) {
        workerRequest.creationRequested=true;
        createNewToolUser(workerRequest);
      }
      workerRequests.offerLast(workerRequest);
    }
  }
}","private void handleWorkerRequest(){
  WorkerRequest workerRequest=workerRequests.poll();
  if (workerRequest != null) {
    IManageableWorker worker=joblessWorkers.removeObjectNextTo(workerRequest.getPos(),new MovableTypeAcceptor(workerRequest.movableType));
    if (worker != null && worker.isAlive()) {
      worker.setWorkerJob(workerRequest.building);
    }
 else {
      if (!workerRequest.creationRequested) {
        workerRequest.creationRequested=true;
        createNewToolUser(workerRequest);
      }
      workerRequests.offerLast(workerRequest);
    }
  }
}"
55937,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  dropCurrentMaterial();
  if (building != null) {
    building.leaveBuilding(this);
  }
  if (isJobless()) {
    super.getStrategyGrid().removeJobless(this);
  }
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  killed=true;
  dropCurrentMaterial();
  if (isJobless()) {
    super.getStrategyGrid().removeJobless(this);
  }
 else {
    super.enableNothingToDoAction(true);
    currentJob=null;
  }
  if (building != null) {
    building.leaveBuilding(this);
  }
}"
55938,"private void calculateForPosition(ShortPoint2D position){
  short x=position.x;
  short y=position.y;
  byte player=grid.getPlayerIdAt(x,y);
  boolean isBorder=false;
  if (grid.getBlockedPartition(x,y) > 0) {
    for (    EDirection currDir : EDirection.values) {
      short currNeighborX=currDir.getNextTileX(x);
      short currNeighborY=currDir.getNextTileY(y);
      if (!grid.isInBounds(currNeighborX,currNeighborY)) {
        continue;
      }
      byte neighborPlayer=grid.getPlayerIdAt(currNeighborX,currNeighborY);
      boolean neighborIsBorder=false;
      if (neighborPlayer != player && grid.getBlockedPartition(currNeighborX,currNeighborY) > 0) {
        isBorder=true;
      }
      if (neighborPlayer >= 0) {
        for (        EDirection currNeighborDir : EDirection.values) {
          short nextX=currNeighborDir.getNextTileX(currNeighborX);
          short nextY=currNeighborDir.getNextTileY(currNeighborY);
          if (grid.isInBounds(nextX,nextY) && grid.getPlayerIdAt(nextX,nextY) != neighborPlayer && grid.getBlockedPartition(nextX,nextY) > 0) {
            neighborIsBorder=true;
            break;
          }
        }
      }
      grid.setBorderAt(currNeighborX,currNeighborY,neighborIsBorder);
    }
  }
  grid.setBorderAt(x,y,isBorder && player >= 0);
}","private void calculateForPosition(ShortPoint2D position){
  short x=position.x;
  short y=position.y;
  byte player=grid.getPlayerIdAt(x,y);
  boolean isBorder=false;
  if (grid.getBlockedPartition(x,y) > 0) {
    for (    EDirection currDir : EDirection.values) {
      short currNeighborX=currDir.getNextTileX(x);
      short currNeighborY=currDir.getNextTileY(y);
      if (!grid.isInBounds(currNeighborX,currNeighborY)) {
        continue;
      }
      byte neighborPlayer=grid.getPlayerIdAt(currNeighborX,currNeighborY);
      boolean neighborIsBorder=false;
      if (neighborPlayer != player) {
        isBorder=true;
      }
      if (grid.getBlockedPartition(currNeighborX,currNeighborY) <= 0) {
        continue;
      }
      if (neighborPlayer >= 0) {
        for (        EDirection currNeighborDir : EDirection.values) {
          short nextX=currNeighborDir.getNextTileX(currNeighborX);
          short nextY=currNeighborDir.getNextTileY(currNeighborY);
          if (grid.isInBounds(nextX,nextY) && grid.getPlayerIdAt(nextX,nextY) != neighborPlayer && grid.getBlockedPartition(nextX,nextY) > 0) {
            neighborIsBorder=true;
            break;
          }
        }
      }
      grid.setBorderAt(currNeighborX,currNeighborY,neighborIsBorder);
    }
  }
  grid.setBorderAt(x,y,isBorder && player >= 0);
}"
55939,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (!isEnemyAttackable(enemy,isInTower)) {
  changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
 else {
  if (state != ESoldierState.HITTING) {
    break;
  }
  if (enemy.getHealth() <= 0) {
    enemy=null;
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
    break;
  }
}
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
case SEARCH_FOR_ENEMIES:
final short minSearchDistance=getMinSearchDistance();
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),minSearchDistance,getMaxSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (minSearchDistance > 0) {
IAttackable toCloseEnemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),(short)0,minSearchDistance,!defending);
if (toCloseEnemy != null) {
if (!isInTower) {
EDirection escapeDirection=EDirection.getApproxDirection(toCloseEnemy.getPos(),getMovable().getPos());
super.goInDirection(escapeDirection,false);
super.getMovable().moveTo(null);
}
break;
}
}
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
}
 else if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  if (!isEnemyAttackable(enemy,isInTower)) {
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  }
 else {
    hitEnemy(enemy);
    if (state != ESoldierState.HITTING) {
      break;
    }
    if (enemy.getHealth() <= 0) {
      enemy=null;
      changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
      break;
    }
  }
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
case SEARCH_FOR_ENEMIES:
final short minSearchDistance=getMinSearchDistance();
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),minSearchDistance,getMaxSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (minSearchDistance > 0) {
IAttackable toCloseEnemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),(short)0,minSearchDistance,!defending);
if (toCloseEnemy != null) {
if (!isInTower) {
EDirection escapeDirection=EDirection.getApproxDirection(toCloseEnemy.getPos(),getMovable().getPos());
super.goInDirection(escapeDirection,false);
super.getMovable().moveTo(null);
}
break;
}
}
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
}
 else if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}"
55940,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      goSinglePathStep();
    }
 else {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
      }
 else {
        this.path=newPath;
        if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
          goSinglePathStep();
        }
      }
    }
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
55941,"@Override public void listMaps(IMapListerCallable callable){
  try {
    for (    String s : manager.list(prefix)) {
      if (s.endsWith(MapList.MAP_EXTENSION)) {
        callable.foundMap(new AndroidAssetMap(manager,prefix + ""String_Node_Str"" + s));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override public void listMaps(IMapListerCallable callable){
  try {
    for (    String s : manager.list(prefix)) {
      if (s.endsWith(MapLoader.MAP_EXTENSION)) {
        callable.foundMap(new AndroidAssetMap(manager,prefix + ""String_Node_Str"" + s));
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
55942,"@Override public boolean isCompressed(){
  return path.endsWith(MapList.COMPRESSED_MAP_EXTENSION);
}","@Override public boolean isCompressed(){
  return path.endsWith(MapLoader.MAP_EXTENSION_COMPRESSED);
}"
55943,"@Override public void write(int b) throws IOException {
  byteCounter++;
  if (byteCounter >= 4233202 && byteCounter <= 4233212) {
    System.out.println();
  }
  outputStream.write(b);
}","@Override public void write(int b) throws IOException {
  byteCounter++;
  if (byteCounter >= 4233202 && byteCounter <= 4233212) {
  }
  outputStream.write(b);
}"
55944,"private void checkMergesAndDividesOnPartitionsList(byte playerId,final short innerPartition,LinkedList<Tuple<Short,ShortPoint2D>> partitionsList){
  if (partitionsList.isEmpty()) {
    return;
  }
  HashMap<Short,ShortPoint2D> foundPartitionsSet=new HashMap<Short,ShortPoint2D>();
  for (  Tuple<Short,ShortPoint2D> currPartition : partitionsList) {
    ShortPoint2D existingPartitionPos=foundPartitionsSet.get(currPartition.e1);
    if (existingPartitionPos != null) {
      checkIfDividePartition(currPartition.e1,currPartition.e2,existingPartitionPos);
    }
 else {
      foundPartitionsSet.put(currPartition.e1,currPartition.e2);
    }
  }
  partitionsList.addLast(partitionsList.getFirst());
  for (  Tuple<Short,ShortPoint2D> currPartition : partitionsList) {
    Partition currPartitionObject=partitionObjects[currPartition.e1];
    if (currPartitionObject.playerId == playerId && partitionObjects[currPartition.e1] != partitionObjects[innerPartition]) {
      mergePartitions(currPartition.e1,innerPartition);
    }
  }
}","private void checkMergesAndDividesOnPartitionsList(byte playerId,final short innerPartition,LinkedList<Tuple<Short,ShortPoint2D>> partitionsList){
  if (partitionsList.isEmpty()) {
    return;
  }
  HashMap<Short,ShortPoint2D> foundPartitionsSet=new HashMap<Short,ShortPoint2D>();
  for (  Tuple<Short,ShortPoint2D> currPartition : partitionsList) {
    Short currPartitionId=currPartition.e1;
    ShortPoint2D existingPartitionPos=foundPartitionsSet.get(currPartitionId);
    if (existingPartitionPos != null) {
      checkIfDividePartition(currPartitionId,currPartition.e2,existingPartitionPos);
      if (getPartitionIdAt(existingPartitionPos.x,existingPartitionPos.y) != currPartitionId) {
        foundPartitionsSet.put(currPartitionId,currPartition.e2);
      }
    }
 else {
      foundPartitionsSet.put(currPartitionId,currPartition.e2);
    }
  }
  partitionsList.addLast(partitionsList.getFirst());
  for (  Tuple<Short,ShortPoint2D> currPartition : partitionsList) {
    Partition currPartitionObject=partitionObjects[currPartition.e1];
    if (currPartitionObject.playerId == playerId && partitionObjects[currPartition.e1] != partitionObjects[innerPartition]) {
      mergePartitions(currPartition.e1,innerPartition);
    }
  }
}"
55945,"/** 
 * Converts this movable to a movable of the given   {@link EMovableType}.
 * @param newMovableType
 */
public final void convertTo(EMovableType newMovableType){
  if (newMovableType == EMovableType.BEARER && !player.equals(grid.getPlayerAt(position))) {
    return;
  }
  this.movableType=newMovableType;
  setStrategy(MovableStrategy.getStrategy(this,newMovableType));
}","/** 
 * Converts this movable to a movable of the given   {@link EMovableType}.
 * @param newMovableType
 */
public final void convertTo(EMovableType newMovableType){
  if (newMovableType == EMovableType.BEARER && !player.equals(grid.getPlayerAt(position))) {
    return;
  }
  if (newMovableType == EMovableType.PIKEMAN_L1) {
    System.out.println();
  }
  this.health=(this.health * newMovableType.getHealth()) / this.movableType.getHealth();
  this.movableType=newMovableType;
  setStrategy(MovableStrategy.getStrategy(this,newMovableType));
}"
55946,"public OriginalMapLoader(IListedMap listedMap) throws IOException {
  this.listedMap=listedMap;
  fileName=listedMap.getFileName();
  creationDate=new Date(new File(fileName).lastModified());
  mapContent=new OriginalMapFileContentReader(listedMap.getInputStream());
  if (!mapContent.isChecksumValid()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  mapContent.loadMapResources();
  mapContent.readBasicMapInformation();
}","public OriginalMapLoader(IListedMap listedMap) throws IOException {
  this.listedMap=listedMap;
  fileName=listedMap.getFileName();
  creationDate=new Date(new File(fileName).lastModified());
  mapContent=new OriginalMapFileContentReader(listedMap.getInputStream());
  if (!mapContent.isChecksumValid()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  mapContent.loadMapResources();
  mapContent.readBasicMapInformation();
  mapContent.FreeBuffer();
}"
55947,"@Override public MainGridWithUiSettings loadMainGrid(PlayerSetting[] playerSettings) throws MapLoadException {
  MilliStopWatch watch=new MilliStopWatch();
  mapContent.readMapData();
  mapContent.readStacks();
  mapContent.readSettlers();
  mapContent.readBuildings();
  mapContent.addStartTowerMaterialsAndSettlers();
  OriginalMapFileContent MapData=mapContent.mapData;
  watch.stop(""String_Node_Str"");
  byte numberOfPlayers=(byte)getMaxPlayers();
  if (playerSettings == null || CommonConstants.ACTIVATE_ALL_PLAYERS) {
    playerSettings=new PlayerSetting[numberOfPlayers];
    for (int i=0; i < numberOfPlayers; i++) {
      playerSettings[i]=new PlayerSetting(true,null);
    }
  }
  MainGrid mainGrid=new MainGrid(getMapId(),getMapName(),MapData,playerSettings);
  PlayerState[] playerStates=new PlayerState[numberOfPlayers];
  for (byte playerId=0; playerId < numberOfPlayers; playerId++) {
    playerStates[playerId]=new PlayerState(playerId,new UIState(MapData.getStartPoint(playerId)));
  }
  return new MainGridWithUiSettings(mainGrid,playerStates);
}","@Override public MainGridWithUiSettings loadMainGrid(PlayerSetting[] playerSettings) throws MapLoadException {
  MilliStopWatch watch=new MilliStopWatch();
  try {
    mapContent.reOpen(this.listedMap.getInputStream());
  }
 catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
  }
  mapContent.loadMapResources();
  mapContent.readBasicMapInformation();
  mapContent.readMapData();
  mapContent.readStacks();
  mapContent.readSettlers();
  mapContent.readBuildings();
  mapContent.addStartTowerMaterialsAndSettlers();
  OriginalMapFileContent MapData=mapContent.mapData;
  watch.stop(""String_Node_Str"");
  byte numberOfPlayers=(byte)getMaxPlayers();
  if (playerSettings == null || CommonConstants.ACTIVATE_ALL_PLAYERS) {
    playerSettings=new PlayerSetting[numberOfPlayers];
    for (int i=0; i < numberOfPlayers; i++) {
      playerSettings[i]=new PlayerSetting(true,null);
    }
  }
  MainGrid mainGrid=new MainGrid(getMapId(),getMapName(),MapData,playerSettings);
  PlayerState[] playerStates=new PlayerState[numberOfPlayers];
  for (byte playerId=0; playerId < numberOfPlayers; playerId++) {
    playerStates[playerId]=new PlayerState(playerId,new UIState(MapData.getStartPoint(playerId)));
  }
  return new MainGridWithUiSettings(mainGrid,playerStates);
}"
55948,"@Override public void executeTask(TaskPacket iTask){
  if (!(iTask instanceof SimpleGuiTask)) {
    return;
  }
  SimpleGuiTask guiTask=(SimpleGuiTask)iTask;
  System.out.println(""String_Node_Str"" + guiTask.getGuiAction());
switch (guiTask.getGuiAction()) {
case SET_WORK_AREA:
{
      WorkAreaGuiTask task=(WorkAreaGuiTask)guiTask;
      setWorkArea(task.getPosition(),task.getBuildingPos().x,task.getBuildingPos().y);
    }
  break;
case BUILD:
{
  ConstructBuildingTask task=(ConstructBuildingTask)guiTask;
  grid.constructBuildingAt(task.getPosition(),task.getType(),task.getPlayerId());
}
break;
case MOVE_TO:
{
MoveToGuiTask task=(MoveToGuiTask)guiTask;
moveSelectedTo(task.getPosition(),task.getSelection());
}
break;
case QUICK_SAVE:
System.out.println(""String_Node_Str"" + RandomSingleton.nextD());
save();
break;
case DESTROY_BUILDING:
{
ShortPoint2D buildingPos=((DestroyBuildingGuiTask)guiTask).getPosition();
Building building=((Building)grid.getBuildingAt(buildingPos.x,buildingPos.y));
if (building != null) {
building.kill();
}
}
break;
case DESTROY_MOVABLES:
killSelectedMovables(((MovableGuiTask)guiTask).getSelection());
break;
case START_WORKING:
case STOP_WORKING:
stopOrStartWorking(((MovableGuiTask)guiTask).getSelection(),guiTask.getGuiAction() == EGuiAction.STOP_WORKING);
break;
case CONVERT:
convertMovables((ConvertGuiTask)guiTask);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority((SetBuildingPriorityGuiTask)guiTask);
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
SetMaterialDistributionSettingsGuiTask task=(SetMaterialDistributionSettingsGuiTask)guiTask;
grid.setMaterialDistributionSettings(task.getManagerPosition(),task.getMaterialType(),task.getProbabilities());
}
break;
case SET_MATERIAL_PRIORITIES:
{
SetMaterialPrioritiesGuiTask task=(SetMaterialPrioritiesGuiTask)guiTask;
grid.setMaterialPrioritiesSettings(task.getManagerPosition(),task.getMaterialTypeForPriority());
}
break;
case UPGRADE_SOLDIERS:
{
UpgradeSoldiersGuiTask task=(UpgradeSoldiersGuiTask)guiTask;
grid.getPlayer(task.getPlayerId()).getManaInformation().upgrade(task.getSoldierType());
}
case SET_MATERIAL_PRODUCTION:
{
SetMaterialProductionGuiTask task=(SetMaterialProductionGuiTask)guiTask;
switch (task.getProductionType()) {
case INCREASE:
grid.getMaterialProductionAt(task.getPosition()).increaseNumberOfFutureProducedMaterial(task.getMaterialType());
break;
case DECREASE:
grid.getMaterialProductionAt(task.getPosition()).decreaseNumberOfFutureProducedMaterial(task.getMaterialType());
break;
case SET_RATIO:
grid.getMaterialProductionAt(task.getPosition()).setRatioOfMaterial(task.getMaterialType(),task.getRatio());
break;
}
break;
}
default :
break;
}
}","@Override public void executeTask(TaskPacket iTask){
  if (!(iTask instanceof SimpleGuiTask)) {
    return;
  }
  SimpleGuiTask guiTask=(SimpleGuiTask)iTask;
  System.out.println(""String_Node_Str"" + guiTask.getGuiAction());
switch (guiTask.getGuiAction()) {
case SET_WORK_AREA:
{
      WorkAreaGuiTask task=(WorkAreaGuiTask)guiTask;
      setWorkArea(task.getPosition(),task.getBuildingPos().x,task.getBuildingPos().y);
    }
  break;
case BUILD:
{
  ConstructBuildingTask task=(ConstructBuildingTask)guiTask;
  grid.constructBuildingAt(task.getPosition(),task.getType(),task.getPlayerId());
}
break;
case MOVE_TO:
{
MoveToGuiTask task=(MoveToGuiTask)guiTask;
moveSelectedTo(task.getPosition(),task.getSelection());
}
break;
case QUICK_SAVE:
System.out.println(""String_Node_Str"" + RandomSingleton.nextD());
save();
break;
case DESTROY_BUILDING:
{
ShortPoint2D buildingPos=((DestroyBuildingGuiTask)guiTask).getPosition();
Building building=((Building)grid.getBuildingAt(buildingPos.x,buildingPos.y));
if (building != null) {
building.kill();
}
}
break;
case DESTROY_MOVABLES:
killSelectedMovables(((MovableGuiTask)guiTask).getSelection());
break;
case START_WORKING:
case STOP_WORKING:
stopOrStartWorking(((MovableGuiTask)guiTask).getSelection(),guiTask.getGuiAction() == EGuiAction.STOP_WORKING);
break;
case CONVERT:
convertMovables((ConvertGuiTask)guiTask);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority((SetBuildingPriorityGuiTask)guiTask);
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
SetMaterialDistributionSettingsGuiTask task=(SetMaterialDistributionSettingsGuiTask)guiTask;
grid.setMaterialDistributionSettings(task.getManagerPosition(),task.getMaterialType(),task.getProbabilities());
}
break;
case SET_MATERIAL_PRIORITIES:
{
SetMaterialPrioritiesGuiTask task=(SetMaterialPrioritiesGuiTask)guiTask;
grid.setMaterialPrioritiesSettings(task.getManagerPosition(),task.getMaterialTypeForPriority());
}
break;
case UPGRADE_SOLDIERS:
{
UpgradeSoldiersGuiTask task=(UpgradeSoldiersGuiTask)guiTask;
grid.getPlayer(task.getPlayerId()).getManaInformation().upgrade(task.getSoldierType());
}
break;
case SET_MATERIAL_PRODUCTION:
{
SetMaterialProductionGuiTask task=(SetMaterialProductionGuiTask)guiTask;
switch (task.getProductionType()) {
case INCREASE:
grid.getMaterialProductionAt(task.getPosition()).increaseNumberOfFutureProducedMaterial(task.getMaterialType());
break;
case DECREASE:
grid.getMaterialProductionAt(task.getPosition()).decreaseNumberOfFutureProducedMaterial(task.getMaterialType());
break;
case SET_RATIO:
grid.getMaterialProductionAt(task.getPosition()).setRatioOfMaterial(task.getMaterialType(),task.getRatio());
break;
}
break;
}
default :
break;
}
}"
55949,"boolean isChecksumValid(){
  long fileChecksum=readBytesFrom(4,0);
  System.out.println(fileChecksum);
  int count=mapContent.length - 8;
  int currentChecksum=0;
  for (int i=8; i < count; i+=4) {
    long currentInt=readBytesFrom(4,i);
    currentChecksum=(int)((currentChecksum * 2) ^ currentInt);
    if (i < 40) {
      System.out.println(i + ""String_Node_Str"" + currentInt+ ""String_Node_Str""+ currentChecksum);
    }
    if (currentChecksum == fileChecksum) {
      System.out.println(""String_Node_Str"" + i);
    }
  }
  if (currentChecksum != fileChecksum) {
    return false;
  }
  return true;
}","boolean isChecksumValid(){
  long fileChecksum=readBEIntFrom(4,0);
  System.out.println(fileChecksum);
  int count=mapContent.length;
  int currentChecksum=0;
  for (int i=8; i < count; i+=4) {
    int currentInt=readBEIntFrom(4,i);
    currentChecksum=((currentChecksum >>> 31) | ((currentChecksum << 1) ^ currentInt));
  }
  if (currentChecksum != fileChecksum) {
    return false;
  }
  return true;
}"
55950,"public static void replayAndCreateSavegame(File replayFile,int targetGameTimeMs,String newReplayFile) throws IOException {
  OfflineNetworkConnector networkConnector=new OfflineNetworkConnector();
  networkConnector.getGameClock().setPausing(true);
  ReplayStartInformation replayStartInformation=new ReplayStartInformation();
  JSettlersGame game=loadGameFromReplay(replayFile,networkConnector,replayStartInformation);
  IStartingGame startingGame=game.start();
  IStartedGame startedGame=waitForGameStartup(startingGame);
  networkConnector.scheduleTaskAt(targetGameTimeMs / NetworkConstants.Client.LOCKSTEP_PERIOD,new SimpleGuiTask(EGuiAction.QUICK_SAVE,(byte)0));
  MatchConstants.clock.fastForwardTo(targetGameTimeMs);
  MapLoader newSavegame=MapList.getDefaultList().getSavedMaps().getItems().get(0);
  createReplayOfRemainingTasks(newSavegame,replayStartInformation,newReplayFile);
  awaitShutdown(startedGame);
}","public static void replayAndCreateSavegame(File replayFile,int targetGameTimeMs,String newReplayFile) throws IOException {
  OfflineNetworkConnector networkConnector=new OfflineNetworkConnector();
  networkConnector.getGameClock().setPausing(true);
  ReplayStartInformation replayStartInformation=new ReplayStartInformation();
  JSettlersGame game=loadGameFromReplay(replayFile,networkConnector,replayStartInformation);
  IStartingGame startingGame=game.start();
  IStartedGame startedGame=waitForGameStartup(startingGame);
  networkConnector.scheduleTaskAt(targetGameTimeMs / NetworkConstants.Client.LOCKSTEP_PERIOD,new SimpleGuiTask(EGuiAction.QUICK_SAVE,(byte)0));
  MatchConstants.clock.fastForwardTo(targetGameTimeMs);
  MapLoader newSavegame=getNewestSavegame();
  createReplayOfRemainingTasks(newSavegame,replayStartInformation,newReplayFile);
  awaitShutdown(startedGame);
}"
55951,"private static void createReplayOfRemainingTasks(MapLoader newSavegame,ReplayStartInformation replayStartInformation,String newReplayFile) throws IOException {
  System.out.println(""String_Node_Str"" + newReplayFile + ""String_Node_Str"");
  new File(newReplayFile).getParentFile().mkdirs();
  ReplayStartInformation replayInfo=new ReplayStartInformation(0,newSavegame.getMapName(),newSavegame.getMapId(),replayStartInformation.getPlayerId(),replayStartInformation.getPlayerSettings());
  DataOutputStream dos=new DataOutputStream(new FileOutputStream(newReplayFile));
  replayInfo.serialize(dos);
  MatchConstants.clock.saveRemainingTasks(dos);
  dos.close();
  System.out.println(""String_Node_Str"");
}","private static void createReplayOfRemainingTasks(MapLoader newSavegame,ReplayStartInformation replayStartInformation,String newReplayFile) throws IOException {
  System.out.println(""String_Node_Str"" + newReplayFile + ""String_Node_Str"");
  new File(newReplayFile).getAbsoluteFile().getParentFile().mkdirs();
  ReplayStartInformation replayInfo=new ReplayStartInformation(0,newSavegame.getMapName(),newSavegame.getMapId(),replayStartInformation.getPlayerId(),replayStartInformation.getPlayerSettings());
  DataOutputStream dos=new DataOutputStream(new FileOutputStream(newReplayFile));
  replayInfo.serialize(dos);
  MatchConstants.clock.saveRemainingTasks(dos);
  dos.close();
  System.out.println(""String_Node_Str"");
}"
55952,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  Movable blockingMovable=grid.getMovableAt(path.nextX(),path.nextY());
  if (blockingMovable == null) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=blockingMovable.push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
55953,"public static void main(String[] args) throws FileNotFoundException, IOException {
  new BuildingCreatorApp(MainUtils.createArgumentsMap(args));
}","public static void main(String[] args) throws FileNotFoundException, IOException, InvocationTargetException, InterruptedException {
  SwingUtilities.invokeAndWait(new BuildingCreatorApp(MainUtils.createArgumentsMap(args)));
}"
55954,"@Override public void action(Action action){
  if (action instanceof PointAction) {
    PointAction sAction=(PointAction)action;
    ShortPoint2D pos=sAction.getPosition();
    RelativePoint relative=absoluteToRelative(pos);
    positionDisplayer.setText(""String_Node_Str"" + (pos.x - BuildingtestMap.OFFSET) + ""String_Node_Str""+ (pos.y - BuildingtestMap.OFFSET));
switch (tool) {
case SET_BLOCKED:
      toogleUsedTile(relative);
    break;
case SET_DOOR:
  setDoor(relative);
break;
case ADD_CONSTRUCTION_STACK:
addConstructionStack(relative);
break;
case ADD_REQUEST_STACK:
case ADD_OFFER_STACK:
addStack(relative,tool == ToolType.ADD_REQUEST_STACK);
break;
case REMOVE_STACK:
removeStack(relative);
break;
case SET_FLAG:
setFlag(relative);
break;
case SET_BUILDMARK:
definition.toggleBuildmarkStatus(relative);
break;
case BRICKLAYER_NE:
definition.toggleBrickayer(relative,EDirection.NORTH_EAST);
break;
case BRICKLAYER_NW:
definition.toggleBrickayer(relative,EDirection.NORTH_WEST);
break;
}
reloadColor(pos);
}
}","@Override public void action(final Action action){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      doAction(action);
    }
  }
);
}"
55955,"private BuildingCreatorApp(HashMap<String,String> argsMap) throws FileNotFoundException, IOException {
  SwingManagedJSettlers.setupResourceManagers(argsMap,""String_Node_Str"");
  EBuildingType type=askType();
  definition=new BuildingDefinition(type);
  map=new BuildingtestMap(definition);
  for (int x=0; x < map.getWidth(); x++) {
    for (int y=0; y < map.getHeight(); y++) {
      reloadColor(new ShortPoint2D(x,y));
    }
  }
  MapInterfaceConnector connector=startMapWindow();
  connector.addListener(this);
  JPanel menu=generateMenu();
  window=new JFrame(""String_Node_Str"" + type.toString());
  window.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  window.add(menu);
  window.pack();
  window.setVisible(true);
  connector.fireAction(new Action(EActionType.TOGGLE_DEBUG));
}","private BuildingCreatorApp(HashMap<String,String> argsMap) throws FileNotFoundException, IOException {
  this.argsMap=argsMap;
  SwingManagedJSettlers.setupResourceManagers(argsMap,""String_Node_Str"");
}"
55956,"private static float getGoldCombatStrength(byte numberOfPlayers,int amountOfGold){
  amountOfGold+=START_AMOUNT[numberOfPlayers - 1];
  if (amountOfGold <= BORDER_50_PERCENT) {
    return (amountOfGold / 12f) / 100f;
  }
 else   if (amountOfGold <= BORDER_85_PERCENT) {
    for (int i=COMBAT_STRENGTH_INCREASE.length; i >= 0; i--) {
      if (amountOfGold >= COMBAT_STRENGTH_INCREASE[i]) {
        return (51f + i) / 100f;
      }
    }
    return 0.5f;
  }
 else {
    return ((1700f + amountOfGold - BORDER_85_PERCENT) / 20f) / 100f;
  }
}","private static float getGoldCombatStrength(byte numberOfPlayers,int amountOfGold){
  amountOfGold+=START_AMOUNT[numberOfPlayers - 1];
  if (amountOfGold <= BORDER_50_PERCENT) {
    return (amountOfGold / 12f) / 100f;
  }
 else   if (amountOfGold <= BORDER_85_PERCENT) {
    for (int i=COMBAT_STRENGTH_INCREASE.length - 1; i >= 0; i--) {
      if (amountOfGold >= COMBAT_STRENGTH_INCREASE[i]) {
        return (51f + i) / 100f;
      }
    }
    return 0.5f;
  }
 else {
    return ((1700f + amountOfGold - BORDER_85_PERCENT) / 20f) / 100f;
  }
}"
55957,"private static float getGoldCombatStrength(byte numberOfPlayers,int amountOfGold){
  amountOfGold+=START_AMOUNT[numberOfPlayers - 1];
  if (amountOfGold <= BORDER_50_PERCENT) {
    return (amountOfGold / 12f) / 100f;
  }
  if (amountOfGold <= BORDER_85_PERCENT) {
    for (int i=COMBAT_STRENGTH_INCREASE.length; i >= 0; i--) {
      if (amountOfGold >= COMBAT_STRENGTH_INCREASE[i]) {
        return (51f + i) / 100f;
      }
      return 0.5f;
    }
  }
  return ((1700f + amountOfGold - BORDER_85_PERCENT) / 20f) / 100f;
}","private static float getGoldCombatStrength(byte numberOfPlayers,int amountOfGold){
  amountOfGold+=START_AMOUNT[numberOfPlayers - 1];
  if (amountOfGold <= BORDER_50_PERCENT) {
    return (amountOfGold / 12f) / 100f;
  }
 else   if (amountOfGold <= BORDER_85_PERCENT) {
    for (int i=COMBAT_STRENGTH_INCREASE.length; i >= 0; i--) {
      if (amountOfGold >= COMBAT_STRENGTH_INCREASE[i]) {
        return (51f + i) / 100f;
      }
    }
    return 0.5f;
  }
 else {
    return ((1700f + amountOfGold - BORDER_85_PERCENT) / 20f) / 100f;
  }
}"
55958,"public final RelativePoint[] getFlattenTiles(){
  return type.getProtectedTiles();
}","public final RelativePoint[] getFlattenTiles(){
  if (shouldBeFlatened()) {
    return type.getProtectedTiles();
  }
 else {
    return new RelativePoint[0];
  }
}"
55959,"@Override public final int hashCode(){
  return getDy() << 16 + getDx();
}","@Override public final int hashCode(){
  return (getDy() << 16) + getDx();
}"
55960,"public static void walkFileTree(File directory,IFileVisitor fileVisitor) throws IOException {
  for (  File file : directory.listFiles()) {
    fileVisitor.visitFile(file);
    if (file.isDirectory()) {
      walkFileTree(file,fileVisitor);
    }
  }
}","public static void walkFileTree(File directory,IFileVisitor fileVisitor) throws IOException {
  if (directory == null) {
    return;
  }
  File[] files=directory.listFiles();
  if (files == null) {
    return;
  }
  for (  File file : files) {
    fileVisitor.visitFile(file);
    if (file.isDirectory()) {
      walkFileTree(file,fileVisitor);
    }
  }
}"
55961,"@Override public final void requestFailed(EMovableType movableType){
  ESearchType searchType=getSearchType(movableType);
  currentlyCommingSoldiers[getSoldierClass(searchType).ordinal]--;
  if (searchType != null)   searchedSoldiers.add(searchType);
}","@Override public final void requestFailed(EMovableType movableType){
  ESearchType searchType=getSearchType(movableType);
  currentlyCommingSoldiers[getSoldierClass(searchType).ordinal]--;
  searchedSoldiers.add(searchType);
}"
55962,"/** 
 * Reads the map data from the given stream and sets up the receiver by it.
 * @param data The receiver of the data.
 * @param in The stream to read from.
 * @throws IOException If an error occured during deserialization.
 */
public static void deserialize(IMapDataReceiver data,InputStream in) throws IOException {
  try {
    DataInputStream stream=new DataInputStream(in);
    int version=stream.readShort();
    if (!(version == VERSION || version == VERSION_WITH_RESOURCES_BLOCKED_PARTITIONS)) {
      throw new IOException(""String_Node_Str"" + version);
    }
    int width=stream.readShort();
    int height=stream.readShort();
    int players=stream.readByte();
    data.setDimension(width,height,players);
    for (int player=0; player < players; player++) {
      int x=stream.readShort();
      int y=stream.readShort();
      data.setPlayerStart((byte)player,x,y);
    }
    ELandscapeType[] types=ELandscapeType.values;
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        byte type=stream.readByte();
        data.setLandscape(x,y,types[type]);
      }
    }
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        byte h=stream.readByte();
        data.setHeight(x,y,h);
      }
    }
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        byte t=stream.readByte();
        byte amount=stream.readByte();
        data.setResources(x,y,EResourceType.values[t],amount);
      }
    }
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        data.setBlockedPartition(x,y,stream.readShort());
      }
    }
    while (stream.available() > 0) {
      int x=stream.readShort();
      int y=stream.readShort();
      int type=stream.readByte();
      String string=stream.readUTF();
      MapObject object=getObject(type,string);
      if (object != null) {
        data.setMapObject(x,y,object);
      }
    }
  }
 catch (  Throwable t) {
    throw new IOException(""String_Node_Str"",t);
  }
}","/** 
 * Reads the map data from the given stream and sets up the receiver by it.
 * @param data The receiver of the data.
 * @param in The stream to read from.
 * @throws IOException If an error occured during deserialization.
 */
public static void deserialize(IMapDataReceiver data,InputStream in) throws IOException {
  try {
    DataInputStream stream=new DataInputStream(in);
    int version=stream.readShort();
    if (version < VERSION_WITH_RESOURCES_BLOCKED_PARTITIONS) {
      throw new IOException(""String_Node_Str"" + version);
    }
    int width=stream.readShort();
    int height=stream.readShort();
    int players=stream.readByte();
    data.setDimension(width,height,players);
    for (int player=0; player < players; player++) {
      int x=stream.readShort();
      int y=stream.readShort();
      data.setPlayerStart((byte)player,x,y);
    }
    ELandscapeType[] types=ELandscapeType.values;
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        byte type=stream.readByte();
        data.setLandscape(x,y,types[type]);
      }
    }
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        byte h=stream.readByte();
        data.setHeight(x,y,h);
      }
    }
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        byte t=stream.readByte();
        byte amount=stream.readByte();
        data.setResources(x,y,EResourceType.values[t],amount);
      }
    }
    for (int x=0; x < width; x++) {
      for (int y=0; y < height; y++) {
        data.setBlockedPartition(x,y,stream.readShort());
      }
    }
    while (stream.available() > 0) {
      int x=stream.readShort();
      int y=stream.readShort();
      int type=stream.readByte();
      String string=stream.readUTF();
      MapObject object=getObject(type,string);
      if (object != null) {
        data.setMapObject(x,y,object);
      }
    }
  }
 catch (  Throwable t) {
    throw new IOException(""String_Node_Str"",t);
  }
}"
55963,"public static void stop(){
  if (uniIns != null) {
    MatchConstants.clock.remove(uniIns);
    uniIns=null;
  }
}","public static synchronized void stop(){
  if (uniIns != null) {
    MatchConstants.clock.remove(uniIns);
    uniIns=null;
  }
}"
55964,"private static String getLogFile(IGameCreator mapcreator,String suffix){
  final String dateAndMap=logDateFormat.format(new Date()) + ""String_Node_Str"" + mapcreator.getMapName().replace(""String_Node_Str"",""String_Node_Str"");
  final String logFolder=""String_Node_Str"" + dateAndMap + ""String_Node_Str"";
  final String replayFilename=logFolder + dateAndMap + suffix;
  return replayFilename;
}","private static String getLogFile(IGameCreator mapcreator,String suffix){
  final String dateAndMap=getLogDateFormatter().format(new Date()) + ""String_Node_Str"" + mapcreator.getMapName().replace(""String_Node_Str"",""String_Node_Str"");
  final String logFolder=""String_Node_Str"" + dateAndMap + ""String_Node_Str"";
  final String replayFilename=logFolder + dateAndMap + suffix;
  return replayFilename;
}"
55965,"public IStartedGame waitForGameStartup(){
  while (startedGame == null) {
synchronized (waitMutex) {
      try {
        waitMutex.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  return startedGame;
}","public IStartedGame waitForGameStartup(){
synchronized (waitMutex) {
    while (startedGame == null) {
      try {
        waitMutex.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  return startedGame;
}"
55966,"private static void awaitShutdown(IStartedGame startedGame){
  final MutableInt gameStopped=new MutableInt(0);
  startedGame.setGameExitListener(new IGameExitListener(){
    @Override public void gameExited(    IStartedGame game){
      gameStopped.value=1;
synchronized (gameStopped) {
        gameStopped.notifyAll();
      }
    }
  }
);
  ((GameRunner)startedGame).stopGame();
  try {
    while (gameStopped.value == 0) {
synchronized (gameStopped) {
        gameStopped.wait();
      }
    }
  }
 catch (  InterruptedException e) {
  }
}","private static void awaitShutdown(IStartedGame startedGame){
  final MutableInt gameStopped=new MutableInt(0);
  startedGame.setGameExitListener(new IGameExitListener(){
    @Override public void gameExited(    IStartedGame game){
      gameStopped.value=1;
synchronized (gameStopped) {
        gameStopped.notifyAll();
      }
    }
  }
);
  ((GameRunner)startedGame).stopGame();
synchronized (gameStopped) {
    while (gameStopped.value == 0) {
      try {
        gameStopped.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
}"
55967,"/** 
 * Applys a map delta. Does not do checking, so use with care!
 * @param delta
 */
public MapDataDelta apply(MapDataDelta delta){
  MapDataDelta inverse=new MapDataDelta();
  HeightChange c=delta.getHeightChanges();
  while (c != null) {
    inverse.addHeightChange(c.x,c.y,heights[c.x][c.y]);
    heights[c.x][c.y]=c.height;
    backgroundListener.backgroundChangedAt(c.x,c.y);
    c=c.next;
  }
  LandscapeChange cl=delta.getLandscapeChanges();
  while (cl != null) {
    inverse.addLandscapeChange(cl.x,cl.y,landscapes[cl.x][cl.y]);
    landscapes[cl.x][cl.y]=cl.landscape;
    backgroundListener.backgroundChangedAt(cl.x,cl.y);
    cl=cl.next;
  }
  ObjectRemover remove=delta.getRemoveObjects();
  while (remove != null) {
    inverse.addObject(remove.x,remove.y,objects[remove.x][remove.y]);
    objects[remove.x][remove.y]=null;
    remove=remove.next;
  }
  ObjectAdder adder=delta.getAddObjects();
  while (adder != null) {
    inverse.removeObject(adder.x,adder.y);
    objects[adder.x][adder.y]=adder.obj;
    adder=adder.next;
  }
  ResourceChanger res=delta.getChangeResources();
  while (res != null) {
    inverse.changeResource(res.x,res.y,resources[res.x][res.y],resourceAmount[res.x][res.y]);
    resources[res.x][res.y]=res.type;
    resourceAmount[res.x][res.y]=res.amount;
    res=res.next;
  }
  StartPointSetter start=delta.getStartPoints();
  while (start != null) {
    inverse.setStartPoint(start.player,playerStarts[start.player]);
    playerStarts[start.player]=start.pos;
  }
  return inverse;
}","/** 
 * Applys a map delta. Does not do checking, so use with care!
 * @param delta
 */
public MapDataDelta apply(MapDataDelta delta){
  MapDataDelta inverse=new MapDataDelta();
  HeightChange c=delta.getHeightChanges();
  while (c != null) {
    inverse.addHeightChange(c.x,c.y,heights[c.x][c.y]);
    heights[c.x][c.y]=c.height;
    backgroundListener.backgroundChangedAt(c.x,c.y);
    c=c.next;
  }
  LandscapeChange cl=delta.getLandscapeChanges();
  while (cl != null) {
    inverse.addLandscapeChange(cl.x,cl.y,landscapes[cl.x][cl.y]);
    landscapes[cl.x][cl.y]=cl.landscape;
    backgroundListener.backgroundChangedAt(cl.x,cl.y);
    cl=cl.next;
  }
  ObjectRemover remove=delta.getRemoveObjects();
  while (remove != null) {
    inverse.addObject(remove.x,remove.y,objects[remove.x][remove.y]);
    objects[remove.x][remove.y]=null;
    remove=remove.next;
  }
  ObjectAdder adder=delta.getAddObjects();
  while (adder != null) {
    inverse.removeObject(adder.x,adder.y);
    objects[adder.x][adder.y]=adder.obj;
    adder=adder.next;
  }
  ResourceChanger res=delta.getChangeResources();
  while (res != null) {
    inverse.changeResource(res.x,res.y,resources[res.x][res.y],resourceAmount[res.x][res.y]);
    resources[res.x][res.y]=res.type;
    resourceAmount[res.x][res.y]=res.amount;
    res=res.next;
  }
  StartPointSetter start=delta.getStartPoints();
  while (start != null) {
    inverse.setStartPoint(start.player,playerStarts[start.player]);
    playerStarts[start.player]=start.pos;
    start=start.next;
  }
  return inverse;
}"
55968,"protected void play(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    data.doPreSaveActions();
    MapList.getDefaultList().saveNewMap(generateMapHeader(),data,new FileOutputStream(temp));
    String[] args=new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),SwingManagedJSettlers.class.getName(),""String_Node_Str"" + temp.getAbsolutePath(),""String_Node_Str"",""String_Node_Str""};
    System.out.println(""String_Node_Str"");
    for (    String arg : args) {
      System.out.print(arg + ""String_Node_Str"");
    }
    System.out.println();
    ProcessBuilder builder=new ProcessBuilder(args);
    builder.redirectErrorStream(true);
    final Process process=builder.start();
    new Thread(new Runnable(){
      @Override public void run(){
        BufferedReader reader=new BufferedReader(new InputStreamReader(process.getInputStream()));
        while (true) {
          String line;
          try {
            line=reader.readLine();
          }
 catch (          IOException e) {
            break;
          }
          if (line == null) {
            break;
          }
          System.out.println(""String_Node_Str"" + line);
        }
      }
    }
,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","protected void play(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    data.doPreSaveActions();
    MapList.getDefaultList().saveNewMap(generateMapHeader(),data,new FileOutputStream(temp));
    String[] args=new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),SwingManagedJSettlers.class.getName(),""String_Node_Str"" + temp.getAbsolutePath(),""String_Node_Str"",""String_Node_Str""};
    System.out.println(""String_Node_Str"");
    for (    String arg : args) {
      System.out.print(arg + ""String_Node_Str"");
    }
    System.out.println();
    ProcessBuilder builder=new ProcessBuilder(args);
    builder.redirectErrorStream(true);
    final Process process=builder.start();
    Thread streamReader=new Thread(new Runnable(){
      @Override public void run(){
        BufferedReader reader=new BufferedReader(new InputStreamReader(process.getInputStream()));
        while (true) {
          String line;
          try {
            line=reader.readLine();
          }
 catch (          IOException e) {
            break;
          }
          if (line == null) {
            break;
          }
          System.out.println(""String_Node_Str"" + line);
        }
      }
    }
,""String_Node_Str"");
    streamReader.setDaemon(true);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
55969,"@Override public void action(Action action){
  System.out.println(""String_Node_Str"" + action.getActionType());
  if (action.getActionType() == EActionType.SELECT_AREA) {
  }
 else   if (action instanceof DrawLineAction) {
    if (tool != null) {
      DrawLineAction lineAction=(DrawLineAction)action;
      ShapeType shape=getActiveShape();
      tool.apply(data,shape,lineAction.getStart(),lineAction.getEnd(),lineAction.getUidy());
      dataTester.retest();
    }
  }
 else   if (action instanceof StartDrawingAction) {
    if (tool != null) {
      StartDrawingAction lineAction=(StartDrawingAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPos());
      dataTester.retest();
    }
  }
 else   if (action instanceof EndDrawingAction) {
    endUseStep();
    dataTester.retest();
  }
 else   if (action instanceof AbortDrawingAction) {
    MapDataDelta delta=data.getUndoDelta();
    data.apply(delta);
    data.resetUndoDelta();
    dataTester.retest();
  }
 else   if (action.getActionType() == EActionType.SELECT_POINT) {
    if (tool != null) {
      PointAction lineAction=(PointAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPosition());
      tool.apply(data,shape,lineAction.getPosition(),lineAction.getPosition(),0);
      endUseStep();
      dataTester.retest();
    }
  }
}","@Override public void action(Action action){
  System.out.println(""String_Node_Str"" + action.getActionType());
  if (action.getActionType() == EActionType.SELECT_AREA) {
  }
 else   if (action instanceof DrawLineAction) {
    if (tool != null && !(tool instanceof SetStartpointTool)) {
      DrawLineAction lineAction=(DrawLineAction)action;
      ShapeType shape=getActiveShape();
      tool.apply(data,shape,lineAction.getStart(),lineAction.getEnd(),lineAction.getUidy());
      dataTester.retest();
    }
  }
 else   if (action instanceof StartDrawingAction) {
    if (tool != null && !(tool instanceof SetStartpointTool)) {
      StartDrawingAction lineAction=(StartDrawingAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPos());
      dataTester.retest();
    }
  }
 else   if (action instanceof EndDrawingAction) {
    endUseStep();
    dataTester.retest();
  }
 else   if (action instanceof AbortDrawingAction) {
    MapDataDelta delta=data.getUndoDelta();
    data.apply(delta);
    data.resetUndoDelta();
    dataTester.retest();
  }
 else   if (action.getActionType() == EActionType.SELECT_POINT) {
    if (tool != null) {
      PointAction lineAction=(PointAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPosition());
      tool.apply(data,shape,lineAction.getPosition(),lineAction.getPosition(),0);
      endUseStep();
      dataTester.retest();
    }
  }
}"
55970,"@Override protected byte getFieldRating(int x,int y,double distance){
  if (x % 2 == 0 && y % 2 == 1) {
    return super.getFieldRating(x,y,distance);
  }
 else {
    return 0;
  }
}","@Override protected byte getFieldRating(int x,int y,double distance){
  if (x % 2 == 0 && y % 2 != 0) {
    return super.getFieldRating(x,y,distance);
  }
 else {
    return 0;
  }
}"
55971,"@Override protected boolean shouldDrawAt(ShortPoint2D current){
  return current.x % 2 == 0 && current.y % 2 == 1;
}","@Override protected boolean shouldDrawAt(ShortPoint2D current){
  return current.x % 2 == 0 && current.y % 2 != 0;
}"
55972,"private synchronized void println(String msg){
  outStream.println(Logger.DATE_FORMAT.format(new Date()) + ""String_Node_Str"" + msg);
}","private synchronized void println(String msg){
  outStream.println(DATE_FORMAT.format(new Date()) + ""String_Node_Str"" + msg);
}"
55973,"@Test public void testFilterUneven(){
  LinkedList<Integer> expected=new LinkedList<Integer>();
  for (  Integer curr : list) {
    if (curr % 2 == 1)     expected.add(curr);
  }
  assertEqualality(expected,new IteratorFilter<Integer>(list,new IPredicate<Integer>(){
    @Override public boolean evaluate(    Integer object){
      return object % 2 == 1;
    }
  }
));
}","@Test public void testFilterUneven(){
  LinkedList<Integer> expected=new LinkedList<Integer>();
  for (  Integer curr : list) {
    if (curr % 2 != 0)     expected.add(curr);
  }
  assertEqualality(expected,new IteratorFilter<Integer>(list,new IPredicate<Integer>(){
    @Override public boolean evaluate(    Integer object){
      return object % 2 != 0;
    }
  }
));
}"
55974,"public static void main(String[] args) throws IOException, MapLoadException {
  System.out.println(""String_Node_Str"");
  for (  Object[] replaySet : replaySets()) {
    String folderName=(String)replaySet[0];
    int targetTimeMinutes=(Integer)replaySet[1];
    AutoReplayIT replayIT=new AutoReplayIT(folderName,targetTimeMinutes);
    Path newSavegame=AutoReplayIT.replayAndGetSavegame(replayIT.getReplayPath(),targetTimeMinutes);
    Path expectedSavegamePath=replayIT.getSavegamePath();
    try {
      compareMapFiles(expectedSavegamePath,newSavegame);
      System.out.println(""String_Node_Str"");
      Files.delete(newSavegame);
    }
 catch (    AssertionError|NoSuchFileException ex) {
      Files.move(newSavegame,expectedSavegamePath,StandardCopyOption.REPLACE_EXISTING);
      System.out.println(""String_Node_Str"" + expectedSavegamePath + ""String_Node_Str""+ newSavegame+ ""String_Node_Str"");
    }
  }
}","public static void main(String[] args) throws IOException, MapLoadException {
  System.out.println(""String_Node_Str"");
  for (  Object[] replaySet : replaySets()) {
    String folderName=(String)replaySet[0];
    int targetTimeMinutes=(Integer)replaySet[1];
    AutoReplayIT replayIT=new AutoReplayIT(folderName,targetTimeMinutes);
    Path newSavegame=AutoReplayIT.replayAndGetSavegame(replayIT.getReplayPath(),targetTimeMinutes);
    Path expectedSavegamePath=replayIT.getSavegamePath();
    try {
      compareMapFiles(expectedSavegamePath,newSavegame);
      System.out.println(""String_Node_Str"");
      Files.delete(newSavegame);
    }
 catch (    AssertionError|NoSuchFileException|FileNotFoundException ex) {
      Files.move(newSavegame,expectedSavegamePath,StandardCopyOption.REPLACE_EXISTING);
      System.out.println(""String_Node_Str"" + expectedSavegamePath + ""String_Node_Str""+ newSavegame+ ""String_Node_Str"");
    }
  }
}"
55975,"/** 
 * Gets the productivity of this mine.
 * @return The productivity in range 0..1
 */
float getProductivity();","/** 
 * Gets the productivity of this   {@link IResourceBuilding}.
 * @return The productivity in the interval [0,1].
 */
float getProductivity();"
55976,"@Override public final boolean executeSearchType(ShortPoint2D position,ESearchType searchType){
  return mapObjectsManager.executeSearchType(position,searchType);
}","@Override public final boolean executeSearchType(IPathCalculatable pathCalculable,ShortPoint2D position,ESearchType searchType){
  if (fitsSearchType(pathCalculable,position,searchType)) {
    return mapObjectsManager.executeSearchType(position,searchType);
  }
 else {
    return false;
  }
}"
55977,"@Override public boolean fitsSearchType(IPathCalculatable pathCalculable,ShortPoint2D pos,ESearchType searchType){
  return pathfinderGrid.fitsSearchType(pos.x,pos.y,searchType,pathCalculable);
}","@Override public boolean fitsSearchType(IPathCalculatable pathCalculable,ShortPoint2D position,ESearchType searchType){
  return pathfinderGrid.fitsSearchType(position.x,position.y,searchType,pathCalculable);
}"
55978,"/** 
 * @param pos
 * @param searchType
 * @return true if the given position can be used to execute the search type.<br>false if it can not
 */
public abstract boolean executeSearchType(ShortPoint2D pos,ESearchType searchType);","/** 
 * @param pathCalculatable requester
 * @param position Position to execute the given  {@link ESearchType}.
 * @param searchType
 * @return true if the given position can be used to execute the search type.<br>false if it can not
 */
public abstract boolean executeSearchType(IPathCalculatable pathCalculatable,ShortPoint2D position,ESearchType searchType);"
55979,"/** 
 * Checks if the given position fits the given search type.
 * @param pathCalculateable path requester
 * @param pos position
 * @param searchType search type to be checked
 * @return true if the search type fits the given position.
 */
public abstract boolean fitsSearchType(IPathCalculatable pathCalculateable,ShortPoint2D pos,ESearchType searchType);","/** 
 * Checks if the given position fits the given search type.
 * @param pathCalculateable path requester
 * @param position position to check the given  {@link ESearchType}.
 * @param searchType search type to be checked
 * @return true if the search type fits the given position.
 */
public abstract boolean fitsSearchType(IPathCalculatable pathCalculateable,ShortPoint2D position,ESearchType searchType);"
55980,"private void executeAction(){
  if (super.getStrategyGrid().executeSearchType(super.getPos(),currentJob.getSearchType())) {
    jobFinished();
  }
 else {
    jobFailed();
  }
}","private void executeAction(){
  if (super.getStrategyGrid().executeSearchType(super.getMovable(),super.getPos(),currentJob.getSearchType())) {
    jobFinished();
  }
 else {
    jobFailed();
  }
}"
55981,"private void executeAction(ShortPoint2D pos){
  super.getStrategyGrid().executeSearchType(pos,ESearchType.RESOURCE_SIGNABLE);
}","private void executeAction(ShortPoint2D pos){
  super.getStrategyGrid().executeSearchType(super.getMovable(),pos,ESearchType.RESOURCE_SIGNABLE);
}"
55982,"@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  goToDiggablePosition();
break;
case PLAYING_ACTION:
executeDigg();
if (!requester.isDiggerRequestActive()) {
reportJobless();
break;
}
case GOING_TO_POS:
if (needsToBeWorkedOn(super.getPos())) {
super.playAction(EAction.ACTION1,1f);
this.state=EDiggerState.PLAYING_ACTION;
}
 else {
goToDiggablePosition();
}
break;
case DEAD_OBJECT:
break;
}
}","@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  goToDiggablePosition();
break;
case PLAYING_ACTION:
executeDigg();
if (!requester.isDiggerRequestActive()) {
super.getStrategyGrid().setMarked(super.getPos(),false);
reportJobless();
break;
}
case GOING_TO_POS:
if (needsToBeWorkedOn(super.getPos())) {
super.playAction(EAction.ACTION1,1f);
this.state=EDiggerState.PLAYING_ACTION;
}
 else {
goToDiggablePosition();
}
break;
case DEAD_OBJECT:
break;
}
}"
55983,"private void createNewToolUser(IWorkerCreationRequest workerCreationRequest){
  workerCreationRequests.offer(workerCreationRequest);
}","private void createNewToolUser(WorkerCreationRequest workerCreationRequest){
  workerCreationRequests.offer(workerCreationRequest);
}"
55984,"private boolean tryToCreateWorker(IWorkerCreationRequest workerCreationRequest){
  EMovableType movableType=workerCreationRequest.requestedMovableType();
  EMaterialType tool=movableType.getTool();
  if (tool != EMaterialType.NO_MATERIAL) {
    MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerCreationRequest.getPos());
    if (offer != null) {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(offer.getPos());
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerCreationRequest,offer.getPos());
        return true;
      }
 else {
        materialOffers.addOffer(offer.getPos(),tool);
        return false;
      }
    }
 else {
      return false;
    }
  }
 else {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerCreationRequest.getPos());
    if (manageableBearer != null) {
      manageableBearer.becomeWorker(this,workerCreationRequest);
      return true;
    }
 else {
      return false;
    }
  }
}","private boolean tryToCreateWorker(WorkerCreationRequest workerCreationRequest){
  EMovableType movableType=workerCreationRequest.requestedMovableType();
  EMaterialType tool=movableType.getTool();
  if (tool != EMaterialType.NO_MATERIAL) {
    MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerCreationRequest.getPos());
    if (offer != null) {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(offer.getPos());
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerCreationRequest,offer.getPos());
        return true;
      }
 else {
        materialOffers.addOffer(offer.getPos(),tool);
        return false;
      }
    }
 else {
      workerCreationRequest.setToolProductionRequired(true);
      return false;
    }
  }
 else {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerCreationRequest.getPos());
    if (manageableBearer != null) {
      manageableBearer.becomeWorker(this,workerCreationRequest);
      return true;
    }
 else {
      return false;
    }
  }
}"
55985,"@Override public final int timerEvent(){
  if (stopped) {
    return -1;
  }
  materialsManager.distributeJobs();
  handleWorkerCreationRequests();
  handleSoldierCreationRequest();
  handleDiggerRequest();
  handleBricklayerRequest();
  handleWorkerRequest();
  return SCHEDULING_PERIOD;
}","@Override public final int timerEvent(){
  if (stopped) {
    return -1;
  }
  materialsManager.distributeJobs();
  handleDiggerRequest();
  handleBricklayerRequest();
  handleWorkerRequest();
  handleWorkerCreationRequests();
  handleSoldierCreationRequest();
  return SCHEDULING_PERIOD;
}"
55986,"public final EMaterialType popToolProduction(ShortPoint2D closeTo){
  byte bestPrio=0;
  EMaterialType bestTool=null;
  for (  IWorkerCreationRequest request : workerCreationRequests) {
    if (!request.isRequestAlive())     continue;
    EMaterialType tool=request.requestedMovableType().getTool();
    byte prio=priorityForTool[tool.ordinal];
    if (prio > bestPrio) {
      bestPrio=prio;
      bestTool=tool;
    }
  }
  return bestTool;
}","public final EMaterialType popToolProduction(ShortPoint2D closeTo){
  byte bestPrio=0;
  EMaterialType bestTool=null;
  for (  WorkerCreationRequest request : workerCreationRequests) {
    if (!request.isRequestAlive() || !request.isToolProductionRequired())     continue;
    request.setToolProductionRequired(false);
    EMaterialType tool=request.requestedMovableType().getTool();
    byte prio=priorityForTool[tool.ordinal];
    if (prio > bestPrio) {
      bestPrio=prio;
      bestTool=tool;
    }
  }
  return bestTool;
}"
55987,"@Override public void workerCreationRequestFailed(IWorkerCreationRequest failedRequest){
  workerCreationRequests.offer(failedRequest);
}","@Override public void workerCreationRequestFailed(WorkerCreationRequest failedRequest){
  workerCreationRequests.offer(failedRequest);
}"
55988,"private void handleWorkerCreationRequests(){
  for (Iterator<IWorkerCreationRequest> iterator=workerCreationRequests.iterator(); iterator.hasNext(); ) {
    IWorkerCreationRequest workerCreationRequest=iterator.next();
    if (!workerCreationRequest.isRequestAlive() || tryToCreateWorker(workerCreationRequest)) {
      iterator.remove();
    }
  }
}","private void handleWorkerCreationRequests(){
  for (Iterator<WorkerCreationRequest> iterator=workerCreationRequests.iterator(); iterator.hasNext() && !joblessBearer.isEmpty(); ) {
    WorkerCreationRequest workerCreationRequest=iterator.next();
    if (!workerCreationRequest.isRequestAlive() || tryToCreateWorker(workerCreationRequest)) {
      iterator.remove();
    }
  }
}"
55989,void workerCreationRequestFailed(IWorkerCreationRequest failedRequest);,void workerCreationRequestFailed(WorkerCreationRequest failedRequest);
55990,"void becomeWorker(IWorkerRequester requester,IWorkerCreationRequest request,ShortPoint2D offer);","void becomeWorker(IWorkerRequester requester,WorkerCreationRequest request,ShortPoint2D offer);"
55991,"@Override public void becomeWorker(IWorkerRequester requester,IWorkerCreationRequest workerCreationRequest,ShortPoint2D offer){
  this.workerRequester=requester;
  this.workerCreationRequest=workerCreationRequest;
  this.offer=offer;
  this.state=EBearerState.INIT_CONVERT_WITH_TOOL_JOB;
  this.materialType=workerCreationRequest.requestedMovableType().getTool();
}","@Override public void becomeWorker(IWorkerRequester requester,WorkerCreationRequest workerCreationRequest,ShortPoint2D offer){
  this.workerRequester=requester;
  this.workerCreationRequest=workerCreationRequest;
  this.offer=offer;
  this.state=EBearerState.INIT_CONVERT_WITH_TOOL_JOB;
  this.materialType=workerCreationRequest.requestedMovableType().getTool();
}"
55992,"private void createNewToolUser(IWorkerCreationRequest workerCreationRequest){
  workerCreationRequests.offer(workerCreationRequest);
}","private void createNewToolUser(WorkerCreationRequest workerCreationRequest){
  workerCreationRequests.offer(workerCreationRequest);
}"
55993,"private boolean tryToCreateWorker(IWorkerCreationRequest workerCreationRequest){
  EMovableType movableType=workerCreationRequest.requestedMovableType();
  EMaterialType tool=movableType.getTool();
  if (tool != EMaterialType.NO_MATERIAL) {
    MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerCreationRequest.getPos());
    if (offer != null) {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(offer.getPos());
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerCreationRequest,offer.getPos());
        return true;
      }
 else {
        materialOffers.addOffer(offer.getPos(),tool);
        return false;
      }
    }
 else {
      return false;
    }
  }
 else {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerCreationRequest.getPos());
    if (manageableBearer != null) {
      manageableBearer.becomeWorker(this,workerCreationRequest);
      return true;
    }
 else {
      return false;
    }
  }
}","private boolean tryToCreateWorker(WorkerCreationRequest workerCreationRequest){
  EMovableType movableType=workerCreationRequest.requestedMovableType();
  EMaterialType tool=movableType.getTool();
  if (tool != EMaterialType.NO_MATERIAL) {
    MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerCreationRequest.getPos());
    if (offer != null) {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(offer.getPos());
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerCreationRequest,offer.getPos());
        return true;
      }
 else {
        materialOffers.addOffer(offer.getPos(),tool);
        return false;
      }
    }
 else {
      workerCreationRequest.setToolProductionRequired(true);
      return false;
    }
  }
 else {
    IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerCreationRequest.getPos());
    if (manageableBearer != null) {
      manageableBearer.becomeWorker(this,workerCreationRequest);
      return true;
    }
 else {
      return false;
    }
  }
}"
55994,"@Override public final int timerEvent(){
  if (stopped) {
    return -1;
  }
  materialsManager.distributeJobs();
  handleWorkerCreationRequests();
  handleSoldierCreationRequest();
  handleDiggerRequest();
  handleBricklayerRequest();
  handleWorkerRequest();
  return SCHEDULING_PERIOD;
}","@Override public final int timerEvent(){
  if (stopped) {
    return -1;
  }
  materialsManager.distributeJobs();
  handleDiggerRequest();
  handleBricklayerRequest();
  handleWorkerRequest();
  handleWorkerCreationRequests();
  handleSoldierCreationRequest();
  return SCHEDULING_PERIOD;
}"
55995,"public final EMaterialType popToolProduction(ShortPoint2D closeTo){
  byte bestPrio=0;
  EMaterialType bestTool=null;
  for (  IWorkerCreationRequest request : workerCreationRequests) {
    if (!request.isRequestAlive())     continue;
    EMaterialType tool=request.requestedMovableType().getTool();
    byte prio=priorityForTool[tool.ordinal];
    if (prio > bestPrio) {
      bestPrio=prio;
      bestTool=tool;
    }
  }
  return bestTool;
}","public final EMaterialType popToolProduction(ShortPoint2D closeTo){
  byte bestPrio=0;
  EMaterialType bestTool=null;
  for (  WorkerCreationRequest request : workerCreationRequests) {
    if (!request.isRequestAlive() || !request.isToolProductionRequired())     continue;
    request.setToolProductionRequired(false);
    EMaterialType tool=request.requestedMovableType().getTool();
    byte prio=priorityForTool[tool.ordinal];
    if (prio > bestPrio) {
      bestPrio=prio;
      bestTool=tool;
    }
  }
  return bestTool;
}"
55996,"@Override public void workerCreationRequestFailed(IWorkerCreationRequest failedRequest){
  workerCreationRequests.offer(failedRequest);
}","@Override public void workerCreationRequestFailed(WorkerCreationRequest failedRequest){
  workerCreationRequests.offer(failedRequest);
}"
55997,"private void handleWorkerCreationRequests(){
  for (Iterator<IWorkerCreationRequest> iterator=workerCreationRequests.iterator(); iterator.hasNext(); ) {
    IWorkerCreationRequest workerCreationRequest=iterator.next();
    if (!workerCreationRequest.isRequestAlive() || tryToCreateWorker(workerCreationRequest)) {
      iterator.remove();
    }
  }
}","private void handleWorkerCreationRequests(){
  for (Iterator<WorkerCreationRequest> iterator=workerCreationRequests.iterator(); iterator.hasNext() && !joblessBearer.isEmpty(); ) {
    WorkerCreationRequest workerCreationRequest=iterator.next();
    if (!workerCreationRequest.isRequestAlive() || tryToCreateWorker(workerCreationRequest)) {
      iterator.remove();
    }
  }
}"
55998,void workerCreationRequestFailed(IWorkerCreationRequest failedRequest);,void workerCreationRequestFailed(WorkerCreationRequest failedRequest);
55999,"void becomeWorker(IWorkerRequester requester,IWorkerCreationRequest request,ShortPoint2D offer);","void becomeWorker(IWorkerRequester requester,WorkerCreationRequest request,ShortPoint2D offer);"
56000,"@Override public void becomeWorker(IWorkerRequester requester,IWorkerCreationRequest workerCreationRequest,ShortPoint2D offer){
  this.workerRequester=requester;
  this.workerCreationRequest=workerCreationRequest;
  this.offer=offer;
  this.state=EBearerState.INIT_CONVERT_WITH_TOOL_JOB;
  this.materialType=workerCreationRequest.requestedMovableType().getTool();
}","@Override public void becomeWorker(IWorkerRequester requester,WorkerCreationRequest workerCreationRequest,ShortPoint2D offer){
  this.workerRequester=requester;
  this.workerCreationRequest=workerCreationRequest;
  this.offer=offer;
  this.state=EBearerState.INIT_CONVERT_WITH_TOOL_JOB;
  this.materialType=workerCreationRequest.requestedMovableType().getTool();
}"
