record_number,buggy_code,fixed_code
27001,"/** 
 * Appends the   {@link SQLCondition} with an {@link Condition.Operation#AND}
 * @param sqlCondition The condition to append.
 * @return This instance.
 */
public ConditionGroup and(SQLCondition sqlCondition){
  return operator(Condition.Operation.AND,sqlCondition);
}","/** 
 * Appends the   {@link SQLCondition} with an {@link Operation#AND}
 * @param sqlCondition The condition to append.
 * @return This instance.
 */
public ConditionGroup and(SQLCondition sqlCondition){
  return operator(Operation.AND,sqlCondition);
}"
27002,"/** 
 * @return The first result of this query. It forces a {@link Where#limit(Object)} of 1 for more efficient querying.
 */
@Override public ModelClass querySingle(){
  return where().querySingle();
}","/** 
 * @return The first result of this query. It forces a {@link Where#limit(int)} of 1 for more efficient querying.
 */
@Override public ModelClass querySingle(){
  return where().querySingle();
}"
27003,"/** 
 * Begins an INDEXED BY piece of this query with the specified name.
 * @param indexName The name of the index.
 * @return An INDEXED BY piece of this statement
 */
public IndexedBy<ModelClass> indexedBy(String indexName){
  return new IndexedBy<>(indexName,this);
}","/** 
 * Begins an INDEXED BY piece of this query with the specified name.
 * @param indexProperty The index property generated.
 * @return An INDEXED BY piece of this statement
 */
public IndexedBy<ModelClass> indexedBy(IndexProperty<ModelClass> indexProperty){
  return new IndexedBy<>(indexProperty,this);
}"
27004,"public ContentUriDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  ContentUri contentUri=typeElement.getAnnotation(ContentUri.class);
  path=contentUri.path();
  type=contentUri.type();
  name=typeElement.getEnclosingElement().getSimpleName().toString() + ""String_Node_Str"" + typeElement.getSimpleName().toString();
  queryEnabled=contentUri.queryEnabled();
  insertEnabled=contentUri.insertEnabled();
  deleteEnabled=contentUri.deleteEnabled();
  updateEnabled=contentUri.updateEnabled();
  segments=contentUri.segments();
  if (typeElement instanceof VariableElement) {
    TypeMirror typeMirror=typeElement.asType();
    if (!ClassNames.URI.equals(typeMirror.toString())) {
      processorManager.logError(""String_Node_Str"");
    }
  }
 else   if (typeElement instanceof ExecutableElement) {
    TypeMirror typeMirror=((ExecutableElement)typeElement).getReturnType();
    if (!ClassNames.URI.equals(typeMirror.toString())) {
      processorManager.logError(""String_Node_Str"");
    }
  }
}","public ContentUriDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  ContentUri contentUri=typeElement.getAnnotation(ContentUri.class);
  path=contentUri.path();
  type=contentUri.type();
  name=typeElement.getEnclosingElement().getSimpleName().toString() + ""String_Node_Str"" + typeElement.getSimpleName().toString();
  queryEnabled=contentUri.queryEnabled();
  insertEnabled=contentUri.insertEnabled();
  deleteEnabled=contentUri.deleteEnabled();
  updateEnabled=contentUri.updateEnabled();
  segments=contentUri.segments();
  if (typeElement instanceof VariableElement) {
    if (!ClassNames.URI.equals(elementTypeName)) {
      processorManager.logError(""String_Node_Str"");
    }
  }
 else   if (typeElement instanceof ExecutableElement) {
    if (!ClassNames.URI.equals(elementTypeName)) {
      processorManager.logError(""String_Node_Str"");
    }
  }
}"
27005,"public String getQuery(boolean useCastIfApplicable){
  AdapterQueryBuilder contentValue=new AdapterQueryBuilder();
  if (!requiresTypeConverter) {
    if (castedClass != null && useCastIfApplicable) {
      contentValue.appendCast(isABlob ? ""String_Node_Str"" : castedClass);
    }
 else {
      contentValue.append(""String_Node_Str"");
    }
  }
  contentValue.appendVariable(isModelContainerAdapter).append(""String_Node_Str"");
  if (isModelContainerAdapter) {
    contentValue.appendGetValue(containerKeyName);
  }
 else   if (fieldIsAModelContainer) {
    contentValue.append(columnName).append(""String_Node_Str"").appendGetValue(referencedColumnFieldName);
  }
 else {
    if (isForeignKeyField) {
      ColumnAccessModel columnAccessModel=new ColumnAccessModel(parentColumnDefinition.getManager(),parentColumnDefinition,isModelContainerAdapter);
      contentValue.append(columnAccessModel.getReferencedColumnFieldName()).append(""String_Node_Str"");
    }
    contentValue.append(getReferencedColumnFieldName());
  }
  if (isABlob) {
    contentValue.append(""String_Node_Str"");
  }
  if (!requiresTypeConverter) {
    contentValue.append(""String_Node_Str"");
  }
  return contentValue.getQuery();
}","public String getQuery(boolean useCastIfApplicable){
  AdapterQueryBuilder contentValue=new AdapterQueryBuilder();
  if (!requiresTypeConverter) {
    if (castedClass != null && useCastIfApplicable) {
      contentValue.appendCast(isABlob ? ""String_Node_Str"" : castedClass);
    }
 else {
      contentValue.append(""String_Node_Str"");
    }
  }
  contentValue.appendVariable(isModelContainerAdapter).append(""String_Node_Str"");
  if (isModelContainerAdapter) {
    contentValue.appendGetValue(containerKeyName);
  }
 else   if (fieldIsAModelContainer) {
    contentValue.append(columnName).append(""String_Node_Str"").appendGetValue(referencedColumnFieldName);
  }
 else {
    if (isForeignKeyField) {
      ColumnAccessModel columnAccessModel=new ColumnAccessModel(parentColumnDefinition.getManager(),parentColumnDefinition,isModelContainerAdapter);
      contentValue.append(columnAccessModel.getReferencedColumnFieldName()).append(""String_Node_Str"");
    }
    contentValue.append(getReferencedColumnFieldName());
  }
  if (isABlob && !isModelContainerAdapter) {
    contentValue.append(""String_Node_Str"");
  }
  if (!requiresTypeConverter) {
    contentValue.append(""String_Node_Str"");
  }
  return contentValue.getQuery();
}"
27006,"@Override public void write(JavaWriter javaWriter) throws IOException {
  AdapterQueryBuilder contentValue=new AdapterQueryBuilder();
  boolean nullCheck;
  if (!isContentValues) {
    String statement=StatementMap.getStatement(SQLiteType.get(accessModel.castedClass));
    if (accessModel.isEnum) {
      statement=StatementMap.getStatement(SQLiteType.TEXT);
    }
    if (statement == null) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",accessModel.castedClass));
    }
    nullCheck=(statement.equals(""String_Node_Str"") || statement.equals(""String_Node_Str"") || accessModel.columnFieldBoxedType.equals(Boolean.class.getName())|| !accessModel.isPrimitive|| accessModel.isModelContainerAdapter);
  }
 else {
    nullCheck=accessModel.columnFieldBoxedType.equals(Boolean.class.getName()) || !accessModel.isPrimitive || accessModel.isModelContainerAdapter;
  }
  String accessStatement=accessModel.getQuery();
  boolean separateVariableForNullCheck=accessModel.requiresTypeConverter || accessModel.isModelContainerAdapter;
  if (nullCheck) {
    if (separateVariableForNullCheck) {
      AdapterQueryBuilder nullQueryBuilder=new AdapterQueryBuilder().append(""String_Node_Str"");
      if (accessModel.requiresTypeConverter && !accessModel.isEnum) {
        nullQueryBuilder.appendTypeConverter(null,databaseTypeName,false);
      }
      nullQueryBuilder.append(accessStatement);
      if (accessModel.requiresTypeConverter && !accessModel.isEnum) {
        nullQueryBuilder.append(""String_Node_Str"");
      }
      javaWriter.emitStatement(nullQueryBuilder.getQuery(),accessModel.columnFieldName);
    }
    javaWriter.beginControlFlow(""String_Node_Str"",separateVariableForNullCheck ? (""String_Node_Str"" + accessModel.columnFieldName) : accessStatement);
  }
  if (!isContentValues) {
    String bindTypeLookup=accessModel.castedClass;
    if (accessModel.isEnum) {
      bindTypeLookup=String.class.getName();
    }
    contentValue.appendBindSQLiteStatement(index,bindTypeLookup);
  }
 else {
    contentValue.appendContentValues();
    contentValue.appendPut(putValue);
  }
  if (separateVariableForNullCheck) {
    contentValue.appendCast(accessModel.castedClass).append((""String_Node_Str"" + accessModel.columnFieldName));
  }
 else {
    contentValue.append(accessStatement);
  }
  QueryBuilder query=contentValue.append(""String_Node_Str"");
  if (accessModel.isEnum) {
    contentValue.append(""String_Node_Str"");
  }
  query.append(separateVariableForNullCheck ? ""String_Node_Str"" : ""String_Node_Str"").getQuery();
  javaWriter.emitStatement(query.getQuery());
  if (nullCheck) {
    javaWriter.nextControlFlow(""String_Node_Str"");
    if (!isContentValues) {
      javaWriter.emitStatement(""String_Node_Str"",index);
    }
 else {
      javaWriter.emitStatement(""String_Node_Str"",putValue);
    }
    javaWriter.endControlFlow();
  }
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  AdapterQueryBuilder contentValue=new AdapterQueryBuilder();
  boolean nullCheck;
  if (!isContentValues) {
    String statement=StatementMap.getStatement(SQLiteType.get(accessModel.castedClass));
    if (accessModel.isEnum) {
      statement=StatementMap.getStatement(SQLiteType.TEXT);
    }
    if (statement == null) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",accessModel.castedClass));
    }
    nullCheck=(statement.equals(""String_Node_Str"") || statement.equals(""String_Node_Str"") || accessModel.columnFieldBoxedType.equals(Boolean.class.getName())|| !accessModel.isPrimitive|| accessModel.isModelContainerAdapter);
  }
 else {
    nullCheck=accessModel.columnFieldBoxedType.equals(Boolean.class.getName()) || !accessModel.isPrimitive || accessModel.isModelContainerAdapter;
  }
  String accessStatement=accessModel.getQuery();
  boolean separateVariableForNullCheck=accessModel.requiresTypeConverter || accessModel.isModelContainerAdapter;
  if (nullCheck) {
    if (separateVariableForNullCheck) {
      AdapterQueryBuilder nullQueryBuilder=new AdapterQueryBuilder().append(""String_Node_Str"");
      if (accessModel.requiresTypeConverter && !accessModel.isEnum) {
        nullQueryBuilder.appendTypeConverter(null,databaseTypeName,false);
      }
      nullQueryBuilder.append(accessStatement);
      if (accessModel.requiresTypeConverter && !accessModel.isEnum) {
        nullQueryBuilder.append(""String_Node_Str"");
      }
      javaWriter.emitStatement(nullQueryBuilder.getQuery(),accessModel.columnFieldName);
    }
    javaWriter.beginControlFlow(""String_Node_Str"",separateVariableForNullCheck ? (""String_Node_Str"" + accessModel.columnFieldName) : accessStatement);
  }
  if (!isContentValues) {
    String bindTypeLookup=accessModel.castedClass;
    if (accessModel.isEnum) {
      bindTypeLookup=String.class.getName();
    }
    contentValue.appendBindSQLiteStatement(index,bindTypeLookup);
  }
 else {
    contentValue.appendContentValues();
    contentValue.appendPut(putValue);
  }
  if (separateVariableForNullCheck) {
    contentValue.appendCast(accessModel.castedClass).append((""String_Node_Str"" + accessModel.columnFieldName));
  }
 else {
    contentValue.append(accessStatement);
  }
  QueryBuilder query=contentValue.append(""String_Node_Str"");
  if (accessModel.isEnum) {
    contentValue.append(""String_Node_Str"");
  }
 else   if (accessModel.isABlob && accessModel.isModelContainerAdapter) {
    contentValue.append(""String_Node_Str"");
  }
  query.append(separateVariableForNullCheck ? ""String_Node_Str"" : ""String_Node_Str"").getQuery();
  javaWriter.emitStatement(query.getQuery());
  if (nullCheck) {
    javaWriter.nextControlFlow(""String_Node_Str"");
    if (!isContentValues) {
      javaWriter.emitStatement(""String_Node_Str"",index);
    }
 else {
      javaWriter.emitStatement(""String_Node_Str"",putValue);
    }
    javaWriter.endControlFlow();
  }
}"
27007,"private void emitColumnAssignment(JavaWriter javaWriter,String valueStatement) throws IOException {
  boolean isContainerFieldDefinition=accessModel.isModelContainerAdapter;
  boolean fieldIsAModelContainer=accessModel.fieldIsAModelContainer;
  boolean isNull=valueStatement.equals(""String_Node_Str"");
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  if (isModelContainerAdapter) {
    if (accessModel.isForeignKeyField) {
      queryBuilder.append(modelContainerName);
    }
 else {
      queryBuilder.append(ModelUtils.getVariable(true));
    }
  }
 else {
    queryBuilder.appendVariable(isContainerFieldDefinition);
  }
  if (fieldIsAModelContainer && isModelContainerAdapter) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
 else   if (fieldIsAModelContainer) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.columnFieldName).appendPut(accessModel.getReferencedColumnFieldName());
  }
 else   if (isModelContainerAdapter && accessModel.isForeignKeyField) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
  if (isContainerFieldDefinition) {
    queryBuilder.appendPut(accessModel.containerKeyName);
  }
 else   if (!fieldIsAModelContainer && !isModelContainerAdapter) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.getSetterReferenceColumnFieldName());
    if (!accessModel.isPrivate) {
      queryBuilder.appendSpaceSeparated(""String_Node_Str"");
    }
  }
  if (accessModel.isEnum) {
    if (!isNull) {
      queryBuilder.append(accessModel.castedClass).append(""String_Node_Str"");
    }
  }
 else {
    if (accessModel.requiresTypeConverter && !isNull) {
      queryBuilder.appendTypeConverter(accessModel.columnFieldBoxedType,accessModel.columnFieldBoxedType,true);
    }
 else     if (accessModel.isABlob) {
      queryBuilder.append(String.format(""String_Node_Str"",Blob.class.getName()));
    }
  }
  queryBuilder.append(valueStatement);
  if (accessModel.requiresTypeConverter && !isNull && !accessModel.isEnum || (accessModel.isEnum && isContainerFieldDefinition && !isNull)) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isModelContainerAdapter || isContainerFieldDefinition || fieldIsAModelContainer|| accessModel.isABlob|| (accessModel.isEnum && !isNull)) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.isPrivate && !isContainerFieldDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.requiresTypeConverter && !accessModel.isEnum() && isModelContainerAdapter&& !isNull) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.toString());
}","private void emitColumnAssignment(JavaWriter javaWriter,String valueStatement) throws IOException {
  boolean isContainerFieldDefinition=accessModel.isModelContainerAdapter;
  boolean fieldIsAModelContainer=accessModel.fieldIsAModelContainer;
  boolean isNull=valueStatement.equals(""String_Node_Str"");
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  if (isModelContainerAdapter) {
    if (accessModel.isForeignKeyField) {
      queryBuilder.append(modelContainerName);
    }
 else {
      queryBuilder.append(ModelUtils.getVariable(true));
    }
  }
 else {
    queryBuilder.appendVariable(isContainerFieldDefinition);
  }
  if (fieldIsAModelContainer && isModelContainerAdapter) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
 else   if (fieldIsAModelContainer) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.columnFieldName).appendPut(accessModel.getReferencedColumnFieldName());
  }
 else   if (isModelContainerAdapter && accessModel.isForeignKeyField) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
  if (isContainerFieldDefinition) {
    queryBuilder.appendPut(accessModel.containerKeyName);
  }
 else   if (!fieldIsAModelContainer && !isModelContainerAdapter) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.getSetterReferenceColumnFieldName());
    if (!accessModel.isPrivate) {
      queryBuilder.appendSpaceSeparated(""String_Node_Str"");
    }
  }
  if (accessModel.isEnum) {
    if (!isNull) {
      queryBuilder.append(accessModel.castedClass).append(""String_Node_Str"");
    }
  }
 else {
    if (accessModel.requiresTypeConverter && !isNull) {
      queryBuilder.appendTypeConverter(accessModel.columnFieldBoxedType,accessModel.columnFieldBoxedType,true);
    }
 else     if (accessModel.isABlob) {
      queryBuilder.append(String.format(""String_Node_Str"",Blob.class.getName()));
    }
  }
  queryBuilder.append(valueStatement);
  if (accessModel.requiresTypeConverter && !isNull && !accessModel.isEnum || (accessModel.isEnum && isContainerFieldDefinition && !isNull)) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isModelContainerAdapter || isContainerFieldDefinition || fieldIsAModelContainer|| accessModel.isABlob|| (accessModel.isEnum && !isNull)) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.isPrivate && !isContainerFieldDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
  if ((accessModel.requiresTypeConverter) && !accessModel.isEnum() && isModelContainerAdapter&& !isNull || isModelContainerAdapter && accessModel.isABlob) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.toString());
}"
27008,"/** 
 * @param functionName  The name of the function to call as the {@link Condition#column(ColumnAlias)}
 * @param columnAliases The alias' of columns to use as parameters to the specified function.
 * @return Creates a new instance with function name that quotes the specified columns.EX: date(`myColumn`) -&gt; ColumnAlias.columnsWithFunction(""date"", ColumnAlias.column(""myColumn""))
 */
public static ColumnAlias columnsWithFunction(String functionName,ColumnAlias... columnAliases){
  return columnRaw(functionName + ""String_Node_Str"" + QueryBuilder.join(""String_Node_Str"",columnAliases)+ ""String_Node_Str"");
}","/** 
 * @param functionName  The name of the function to call as the {@link Condition#column(ColumnAlias)}
 * @param columnAliases The alias' of columns to use as parameters to the specified function.
 * @return Creates a new instance with function name that quotes the specified columns.EX: date(`myColumn`) -&gt; ColumnAlias.columnsWithFunction(""date"", ColumnAlias.column(""myColumn""))
 */
public static ColumnAlias columnsWithFunction(String functionName,ColumnAlias... columnAliases){
  QueryBuilder queryBuilder=new QueryBuilder<>(functionName).append(""String_Node_Str"");
  for (int i=0; i < columnAliases.length; i++) {
    if (i > 0) {
      queryBuilder.append(""String_Node_Str"");
    }
    queryBuilder.appendQuoted(columnAliases[i].getAliasName());
  }
  queryBuilder.append(""String_Node_Str"");
  return columnRaw(queryBuilder.getQuery());
}"
27009,"/** 
 * @param functionName  The name of the function to call as the {@link Condition#column(ColumnAlias)}
 * @param columnAliases The alias' of columns to use as parameters to the specified function.
 * @return Creates a new instance with function name that quotes the specified columns.EX: date(`myColumn`) -&gt; ColumnAlias.columnsWithFunction(""date"", ColumnAlias.column(""myColumn""))
 */
public static ColumnAlias columnsWithFunction(String functionName,ColumnAlias... columnAliases){
  QueryBuilder queryBuilder=new QueryBuilder<>(functionName).append(""String_Node_Str"");
  for (int i=0; i < columnAliases.length; i++) {
    if (i > 0) {
      queryBuilder.append(""String_Node_Str"");
    }
    queryBuilder.appendQuoted(columnAliases[i].getAliasName());
  }
  queryBuilder.append(""String_Node_Str"");
  return columnRaw(queryBuilder.getQuery());
}","/** 
 * @param functionName  The name of the function to call as the {@link Condition#column(ColumnAlias)}
 * @param columnAliases The alias' of columns to use as parameters to the specified function.
 * @return Creates a new instance with function name that quotes the specified columns.EX: date(`myColumn`) -&gt; ColumnAlias.columnsWithFunction(""date"", ColumnAlias.column(""myColumn""))
 */
public static ColumnAlias columnsWithFunction(String functionName,ColumnAlias... columnAliases){
  QueryBuilder queryBuilder=new QueryBuilder<>(functionName).append(""String_Node_Str"");
  for (int i=0; i < columnAliases.length; i++) {
    if (i > 0) {
      queryBuilder.append(""String_Node_Str"");
    }
    queryBuilder.append(columnAliases[i].getAliasName());
  }
  queryBuilder.append(""String_Node_Str"");
  return columnRaw(queryBuilder.getQuery());
}"
27010,"public void writeToModelDefinition(JavaWriter javaWriter) throws IOException {
  if (!isModel) {
    AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder(""String_Node_Str"");
    adapterQueryBuilder.append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    javaWriter.emitStatement(adapterQueryBuilder.getQuery());
    javaWriter.beginControlFlow(""String_Node_Str"",columnFieldName);
  }
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  queryBuilder.appendVariable(false).append(""String_Node_Str"").append(columnFieldName);
  queryBuilder.appendSpaceSeparated(""String_Node_Str"");
  String getType=columnFieldType;
  if (element.asType().getKind().isPrimitive()) {
    getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
  }
  queryBuilder.appendCast(fieldIsModelContainer ? modelContainerType : getType);
  if (isModel) {
    queryBuilder.appendVariable(true).append(""String_Node_Str"");
    queryBuilder.appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    queryBuilder.append(""String_Node_Str"").append(ModelUtils.getFieldClass(columnFieldType)).append(""String_Node_Str"").append(""String_Node_Str"");
  }
 else {
    queryBuilder.append(String.format(""String_Node_Str"",columnFieldName));
  }
  javaWriter.emitStatement(queryBuilder.getQuery());
  if (!isModel) {
    javaWriter.endControlFlow();
  }
}","public void writeToModelDefinition(JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (!isModel) {
    AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder(""String_Node_Str"");
    adapterQueryBuilder.append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    javaWriter.emitStatement(adapterQueryBuilder.getQuery());
    javaWriter.beginControlFlow(""String_Node_Str"",columnFieldName);
  }
  ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  queryBuilder.appendVariable(false).append(""String_Node_Str"").append(columnFieldName);
  queryBuilder.appendSpaceSeparated(""String_Node_Str"");
  String getType=columnFieldType;
  if (element.asType().getKind().isPrimitive()) {
    getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
  }
  queryBuilder.appendCast(fieldIsModelContainer ? modelContainerType : getType);
  if (isModel) {
    queryBuilder.appendVariable(true).append(""String_Node_Str"");
    queryBuilder.appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    queryBuilder.append(""String_Node_Str"").append(ModelUtils.getFieldClass(columnFieldType)).append(""String_Node_Str"").append(""String_Node_Str"");
  }
 else {
    queryBuilder.append(String.format(""String_Node_Str"",columnFieldName));
  }
  javaWriter.emitStatement(queryBuilder.getQuery());
  if (!isModel) {
    javaWriter.endControlFlow();
  }
}"
27011,"private void emitColumnAssignment(JavaWriter javaWriter,String valueStatement) throws IOException {
  boolean isContainerFieldDefinition=accessModel.isModelContainerAdapter;
  boolean isWritingForContainers=accessModel.fieldIsAModelContainer;
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().appendVariable(isContainerFieldDefinition);
  if (isWritingForContainers) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.columnName);
  }
  if (isContainerFieldDefinition) {
    queryBuilder.appendPut(accessModel.containerKeyName);
  }
 else   if (isWritingForContainers) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
 else {
    queryBuilder.append(""String_Node_Str"").append(accessModel.getSetterReferenceColumnFieldName());
    if (!accessModel.isPrivate) {
      queryBuilder.appendSpaceSeparated(""String_Node_Str"");
    }
  }
  if (accessModel.isEnum) {
    if (!valueStatement.equals(""String_Node_Str"")) {
      queryBuilder.append(accessModel.castedClass).append(""String_Node_Str"");
    }
  }
 else {
    if (accessModel.requiresTypeConverter && !isContainerFieldDefinition) {
      queryBuilder.appendTypeConverter(accessModel.columnFieldBoxedType,accessModel.columnFieldBoxedType,true);
    }
 else     if (accessModel.isABlob) {
      queryBuilder.append(String.format(""String_Node_Str"",Blob.class.getName()));
    }
  }
  queryBuilder.append(valueStatement);
  if (accessModel.requiresTypeConverter && !isContainerFieldDefinition && !accessModel.isEnum || (accessModel.isEnum && isContainerFieldDefinition && !valueStatement.equals(""String_Node_Str""))) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isContainerFieldDefinition || isWritingForContainers || accessModel.isABlob|| (accessModel.isEnum && !valueStatement.equals(""String_Node_Str""))) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.isPrivate) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.toString());
}","private void emitColumnAssignment(JavaWriter javaWriter,String valueStatement) throws IOException {
  boolean isContainerFieldDefinition=accessModel.isModelContainerAdapter;
  boolean isWritingForContainers=accessModel.fieldIsAModelContainer;
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().appendVariable(isContainerFieldDefinition);
  if (isWritingForContainers) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.columnName);
  }
  if (isContainerFieldDefinition) {
    queryBuilder.appendPut(accessModel.containerKeyName);
  }
 else   if (isWritingForContainers) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
 else {
    queryBuilder.append(""String_Node_Str"").append(accessModel.getSetterReferenceColumnFieldName());
    if (!accessModel.isPrivate) {
      queryBuilder.appendSpaceSeparated(""String_Node_Str"");
    }
  }
  if (accessModel.isEnum) {
    if (!valueStatement.equals(""String_Node_Str"")) {
      queryBuilder.append(accessModel.castedClass).append(""String_Node_Str"");
    }
  }
 else {
    if (accessModel.requiresTypeConverter && !isContainerFieldDefinition) {
      queryBuilder.appendTypeConverter(accessModel.columnFieldBoxedType,accessModel.columnFieldBoxedType,true);
    }
 else     if (accessModel.isABlob) {
      queryBuilder.append(String.format(""String_Node_Str"",Blob.class.getName()));
    }
  }
  queryBuilder.append(valueStatement);
  if (accessModel.requiresTypeConverter && !isContainerFieldDefinition && !accessModel.isEnum || (accessModel.isEnum && isContainerFieldDefinition && !valueStatement.equals(""String_Node_Str""))) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isContainerFieldDefinition || isWritingForContainers || accessModel.isABlob|| (accessModel.isEnum && !valueStatement.equals(""String_Node_Str""))) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.isPrivate && !isContainerFieldDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.toString());
}"
27012,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitStatement(tableDefinition.getModelClassName() + ""String_Node_Str"" + ModelUtils.getVariable(false)+ ""String_Node_Str""+ tableDefinition.getModelClassName()+ ""String_Node_Str"");
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    columnDefinition.writeToModelDefinition(javaWriter);
  }
  javaWriter.emitStatement(""String_Node_Str"" + ModelUtils.getVariable(false));
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitStatement(tableDefinition.getModelClassName() + ""String_Node_Str"" + ModelUtils.getVariable(false)+ ""String_Node_Str""+ tableDefinition.getModelClassName()+ ""String_Node_Str"");
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    columnDefinition.writeToModelDefinition(javaWriter,isModelContainerDefinition);
  }
  javaWriter.emitStatement(""String_Node_Str"" + ModelUtils.getVariable(false));
}"
27013,"public void writeToModelDefinition(JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (!isModel) {
    AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder(""String_Node_Str"");
    adapterQueryBuilder.append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    javaWriter.emitStatement(adapterQueryBuilder.getQuery());
    javaWriter.beginControlFlow(""String_Node_Str"",columnFieldName);
  }
  ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  queryBuilder.appendVariable(false).append(""String_Node_Str"").append(columnFieldName);
  queryBuilder.appendSpaceSeparated(""String_Node_Str"");
  String getType=columnFieldType;
  if (element.asType().getKind().isPrimitive()) {
    getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
  }
  queryBuilder.appendCast(fieldIsModelContainer ? modelContainerType : getType);
  if (isModel) {
    queryBuilder.appendVariable(true).append(""String_Node_Str"");
    queryBuilder.appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    queryBuilder.append(""String_Node_Str"").append(ModelUtils.getFieldClass(columnFieldType)).append(""String_Node_Str"").append(""String_Node_Str"");
  }
 else {
    queryBuilder.append(String.format(""String_Node_Str"",columnFieldName));
  }
  javaWriter.emitStatement(queryBuilder.getQuery());
  if (!isModel) {
    javaWriter.endControlFlow();
  }
}","public void writeToModelDefinition(JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (!isModel) {
    AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder(""String_Node_Str"");
    adapterQueryBuilder.append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    javaWriter.emitStatement(adapterQueryBuilder.getQuery());
    javaWriter.beginControlFlow(""String_Node_Str"",columnFieldName);
  }
  ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  queryBuilder.appendVariable(false).append(""String_Node_Str"").append(columnAccessModel.getSetterReferenceColumnFieldName());
  if (!columnAccessModel.isPrivate()) {
    queryBuilder.appendSpaceSeparated(""String_Node_Str"");
  }
  String getType=columnFieldType;
  if (element.asType().getKind().isPrimitive()) {
    getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
  }
  queryBuilder.appendCast(fieldIsModelContainer ? modelContainerType : getType);
  if (isModel) {
    queryBuilder.appendVariable(true).append(""String_Node_Str"");
    queryBuilder.appendVariable(true).append(""String_Node_Str"").appendGetValue(containerKeyName);
    queryBuilder.append(""String_Node_Str"").append(ModelUtils.getFieldClass(columnFieldType)).append(""String_Node_Str"").append(""String_Node_Str"");
  }
 else {
    if (columnAccessModel.isRequiresTypeConverter() && !columnAccessModel.isEnum()) {
      queryBuilder.appendTypeConverter(null,getType,true);
    }
    queryBuilder.append(String.format(""String_Node_Str"",columnFieldName));
  }
  if (columnAccessModel.isRequiresTypeConverter() && !columnAccessModel.isEnum()) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (columnAccessModel.isPrivate()) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.getQuery());
  if (!isModel) {
    javaWriter.endControlFlow();
  }
}"
27014,"public void writeLoadFromCursorDefinition(BaseTableDefinition tableDefinition,JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (isForeignKey) {
    javaWriter.emitEmptyLine();
    javaWriter.emitSingleLineComment(""String_Node_Str"",columnFieldName);
    if (!fieldIsModelContainer && !isModelContainerAdapter && isModel) {
      ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder().appendForeignKeyReferences(columnFieldType + tableDefinition.databaseWriter.classSeparator + TableDefinition.DBFLOW_TABLE_TAG,columnName,foreignKeyReferences);
      String rawConditionStatement=String.format(""String_Node_Str"",ModelUtils.getFieldClass(columnFieldType),conditionQueryBuilder);
      AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder().appendVariable(false);
      adapterQueryBuilder.append(""String_Node_Str"").append(columnAccessModel.getSetterReferenceColumnFieldName());
      if (!columnAccessModel.isPrivate()) {
        adapterQueryBuilder.appendSpaceSeparated(""String_Node_Str"");
      }
      adapterQueryBuilder.append(rawConditionStatement);
      if (columnAccessModel.isPrivate()) {
        adapterQueryBuilder.append(""String_Node_Str"");
      }
      javaWriter.emitStatement(adapterQueryBuilder.getQuery());
      javaWriter.endControlFlow();
    }
 else {
      if (isModelContainerAdapter) {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
 else {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      String modelContainerName=""String_Node_Str"";
      if (isModelContainerAdapter) {
        if (isModel) {
          modelContainerName=ModelUtils.getVariable(isModelContainerAdapter) + columnFieldName;
          javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),foreignKeyTableClassName);
        }
 else {
          modelContainerName=ModelUtils.getVariable(isModelContainerAdapter);
        }
      }
 else       if (fieldIsModelContainer) {
        AdapterQueryBuilder containerBuilder=new AdapterQueryBuilder().appendVariable(isModelContainerAdapter).append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").append(columnFieldActualType).appendParenthesisEnclosed(ModelUtils.getFieldClass(columnFieldType));
        javaWriter.emitStatement(containerBuilder.getQuery());
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        ColumnAccessModel columnAccessModel=new ColumnAccessModel(this,foreignKeyReference);
        LoadFromCursorModel loadFromCursorModel=new LoadFromCursorModel(columnAccessModel);
        loadFromCursorModel.setIsNullable(isNullable());
        loadFromCursorModel.setModelContainerName(modelContainerName);
        loadFromCursorModel.setIsModelContainerAdapter(isModelContainerAdapter);
        loadFromCursorModel.write(javaWriter);
      }
      if (isModelContainerAdapter && isModel && fieldIsModelContainer) {
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName,modelContainerName);
        javaWriter.nextControlFlow(""String_Node_Str"");
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName);
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
    LoadFromCursorModel loadFromCursorModel=new LoadFromCursorModel(columnAccessModel);
    loadFromCursorModel.setModelContainerName(columnName);
    loadFromCursorModel.setIsNullable(isNullable());
    loadFromCursorModel.writeSingleField(javaWriter);
  }
}","public void writeLoadFromCursorDefinition(BaseTableDefinition tableDefinition,JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (isForeignKey) {
    javaWriter.emitEmptyLine();
    javaWriter.emitSingleLineComment(""String_Node_Str"",columnFieldName);
    if (!fieldIsModelContainer && !isModelContainerAdapter && isModel) {
      ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder().appendForeignKeyReferences(columnFieldType + tableDefinition.databaseWriter.classSeparator + TableDefinition.DBFLOW_TABLE_TAG,columnName,foreignKeyReferences);
      String rawConditionStatement=String.format(""String_Node_Str"",ModelUtils.getFieldClass(columnFieldType),conditionQueryBuilder);
      AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder().appendVariable(false);
      adapterQueryBuilder.append(""String_Node_Str"").append(columnAccessModel.getSetterReferenceColumnFieldName());
      if (!columnAccessModel.isPrivate()) {
        adapterQueryBuilder.appendSpaceSeparated(""String_Node_Str"");
      }
      adapterQueryBuilder.append(rawConditionStatement);
      if (columnAccessModel.isPrivate()) {
        adapterQueryBuilder.append(""String_Node_Str"");
      }
      javaWriter.emitStatement(adapterQueryBuilder.getQuery());
      javaWriter.endControlFlow();
    }
 else {
      if (isModelContainerAdapter) {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
 else {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      String modelContainerName=""String_Node_Str"";
      if (isModelContainerAdapter) {
        if (isModel) {
          modelContainerName=ModelUtils.getVariable(isModelContainerAdapter) + columnFieldName;
          javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),foreignKeyTableClassName);
        }
 else {
          modelContainerName=ModelUtils.getVariable(isModelContainerAdapter);
        }
      }
 else       if (fieldIsModelContainer) {
        AdapterQueryBuilder containerBuilder=new AdapterQueryBuilder().appendVariable(isModelContainerAdapter).append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").append(columnFieldActualType).appendParenthesisEnclosed(ModelUtils.getFieldClass(columnFieldType));
        javaWriter.emitStatement(containerBuilder.getQuery());
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        ColumnAccessModel columnAccessModel=new ColumnAccessModel(this,foreignKeyReference);
        LoadFromCursorModel loadFromCursorModel=new LoadFromCursorModel(columnAccessModel);
        loadFromCursorModel.setIsNullable(isNullable());
        loadFromCursorModel.setModelContainerName(modelContainerName);
        loadFromCursorModel.setIsModelContainerAdapter(isModelContainerAdapter);
        loadFromCursorModel.write(javaWriter);
      }
      if (isModelContainerAdapter && isModel) {
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName,modelContainerName);
        javaWriter.nextControlFlow(""String_Node_Str"");
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName);
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
    LoadFromCursorModel loadFromCursorModel=new LoadFromCursorModel(columnAccessModel);
    loadFromCursorModel.setModelContainerName(columnName);
    loadFromCursorModel.setIsModelContainerAdapter(isModelContainerAdapter);
    loadFromCursorModel.setIsNullable(isNullable());
    loadFromCursorModel.writeSingleField(javaWriter);
  }
}"
27015,"private void emitColumnAssignment(JavaWriter javaWriter,String valueStatement) throws IOException {
  boolean isContainerFieldDefinition=accessModel.isModelContainerAdapter;
  boolean isWritingForContainers=accessModel.fieldIsAModelContainer;
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().appendVariable(isContainerFieldDefinition);
  if (isWritingForContainers) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.columnName);
  }
  if (isContainerFieldDefinition) {
    queryBuilder.appendPut(accessModel.containerKeyName);
  }
 else   if (isWritingForContainers) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
 else {
    queryBuilder.append(""String_Node_Str"").append(accessModel.getSetterReferenceColumnFieldName());
    if (!accessModel.isPrivate) {
      queryBuilder.appendSpaceSeparated(""String_Node_Str"");
    }
  }
  if (accessModel.isEnum) {
    if (!valueStatement.equals(""String_Node_Str"")) {
      queryBuilder.append(accessModel.castedClass).append(""String_Node_Str"");
    }
  }
 else {
    if (accessModel.requiresTypeConverter && !isContainerFieldDefinition) {
      queryBuilder.appendTypeConverter(accessModel.columnFieldBoxedType,accessModel.columnFieldBoxedType,true);
    }
 else     if (accessModel.isABlob) {
      queryBuilder.append(String.format(""String_Node_Str"",Blob.class.getName()));
    }
  }
  queryBuilder.append(valueStatement);
  if (accessModel.requiresTypeConverter && !isContainerFieldDefinition && !accessModel.isEnum || (accessModel.isEnum && isContainerFieldDefinition && !valueStatement.equals(""String_Node_Str""))) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isContainerFieldDefinition || isWritingForContainers || accessModel.isABlob|| (accessModel.isEnum && !valueStatement.equals(""String_Node_Str""))) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.isPrivate && !isContainerFieldDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.toString());
}","private void emitColumnAssignment(JavaWriter javaWriter,String valueStatement) throws IOException {
  boolean isContainerFieldDefinition=accessModel.isModelContainerAdapter;
  boolean fieldIsAModelContainer=accessModel.fieldIsAModelContainer;
  boolean isNull=valueStatement.equals(""String_Node_Str"");
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder();
  if (isModelContainerAdapter) {
    if (accessModel.isForeignKeyField) {
      queryBuilder.append(modelContainerName);
    }
 else {
      queryBuilder.append(ModelUtils.getVariable(true));
    }
  }
 else {
    queryBuilder.appendVariable(isContainerFieldDefinition);
  }
  if (fieldIsAModelContainer && isModelContainerAdapter) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
 else   if (fieldIsAModelContainer) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.columnFieldName).appendPut(accessModel.getReferencedColumnFieldName());
  }
 else   if (isModelContainerAdapter && accessModel.isForeignKeyField) {
    queryBuilder.appendPut(accessModel.getReferencedColumnFieldName());
  }
  if (isContainerFieldDefinition) {
    queryBuilder.appendPut(accessModel.containerKeyName);
  }
 else   if (!fieldIsAModelContainer && !isModelContainerAdapter) {
    queryBuilder.append(""String_Node_Str"").append(accessModel.getSetterReferenceColumnFieldName());
    if (!accessModel.isPrivate) {
      queryBuilder.appendSpaceSeparated(""String_Node_Str"");
    }
  }
  if (accessModel.isEnum) {
    if (!isNull) {
      queryBuilder.append(accessModel.castedClass).append(""String_Node_Str"");
    }
  }
 else {
    if (accessModel.requiresTypeConverter && !isNull) {
      queryBuilder.appendTypeConverter(accessModel.columnFieldBoxedType,accessModel.columnFieldBoxedType,true);
    }
 else     if (accessModel.isABlob) {
      queryBuilder.append(String.format(""String_Node_Str"",Blob.class.getName()));
    }
  }
  queryBuilder.append(valueStatement);
  if (accessModel.requiresTypeConverter && !isNull && !accessModel.isEnum || (accessModel.isEnum && isContainerFieldDefinition && !isNull)) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isModelContainerAdapter || isContainerFieldDefinition || fieldIsAModelContainer|| accessModel.isABlob|| (accessModel.isEnum && !isNull)) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.isPrivate && !isContainerFieldDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
  if (accessModel.requiresTypeConverter && !accessModel.isEnum() && isModelContainerAdapter&& !isNull) {
    queryBuilder.append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.toString());
}"
27016,"@Override public void write(JavaWriter javaWriter) throws IOException {
  if (isModelContainerAdapter) {
    AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
    adapterQueryBuilder.append(modelContainerName).appendPut(accessModel.getReferencedColumnFieldName()).append(ModelUtils.getCursorStatement(accessModel.castedClass,accessModel.foreignKeyLocalColumnName)).append(""String_Node_Str"");
    javaWriter.emitStatement(adapterQueryBuilder.getQuery());
  }
 else {
    String cursorStatementClass=accessModel.castedClass;
    if (accessModel.isEnum) {
      cursorStatementClass=String.class.getName();
    }
    String cursorStatment=ModelUtils.getCursorStatement(cursorStatementClass,accessModel.foreignKeyLocalColumnName);
    emitColumnAssignment(javaWriter,cursorStatment);
  }
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  String cursorStatementClass=accessModel.castedClass;
  if (accessModel.isEnum) {
    cursorStatementClass=String.class.getName();
  }
  String cursorStatment=ModelUtils.getCursorStatement(cursorStatementClass,accessModel.foreignKeyLocalColumnName);
  emitColumnAssignment(javaWriter,cursorStatment);
}"
27017,"/** 
 * Appends a value only if it's not empty or null
 * @param name  The name of the qualifier
 * @param value The value to append after the name
 * @return This instance
 */
public QueryClass appendQualifier(String name,String value){
  if (value != null && value.length() > 0) {
    append(name).appendSpaceSeparated(value);
  }
  return castThis();
}","/** 
 * Appends a value only if it's not empty or null
 * @param name  The name of the qualifier
 * @param value The value to append after the name
 * @return This instance
 */
public QueryClass appendQualifier(String name,String value){
  if (value != null && value.length() > 0) {
    if (name != null) {
      append(name);
    }
    appendSpaceSeparated(value);
  }
  return castThis();
}"
27018,"/** 
 * Appends the string with spaces on the front and end of the string
 * @param string The string to append
 * @return This instance
 */
@SuppressWarnings(""String_Node_Str"") public QueryClass appendSpaceSeparated(String string){
  return (QueryClass)appendSpace().append(string).appendSpace();
}","/** 
 * Appends the string with spaces on the front and end of the string
 * @param object The object to append
 * @return This instance
 */
@SuppressWarnings(""String_Node_Str"") public QueryClass appendSpaceSeparated(Object object){
  return (QueryClass)appendSpace().append(object).appendSpace();
}"
27019,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  for (int i=0; i < columnAliasList.size(); i++) {
    if (i > 0) {
      queryBuilder.append(""String_Node_Str"");
    }
    queryBuilder.append(columnAliasList.get(i).getAliasName());
  }
  queryBuilder.appendSpace().append(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (!TextUtils.isEmpty(stringOrderBy)) {
    queryBuilder.append(stringOrderBy);
  }
 else {
    for (int i=0; i < columnAliasList.size(); i++) {
      if (i > 0) {
        queryBuilder.append(""String_Node_Str"");
      }
      queryBuilder.append(columnAliasList.get(i).getAliasName());
    }
    queryBuilder.appendSpace().append(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    if (orderByCollation != null) {
      queryBuilder.appendSpace().appendSpaceSeparated(orderByCollation);
    }
  }
  return queryBuilder.getQuery();
}"
27020,"@Override public String getQuery(){
  String fromQuery=whereBase.getQuery();
  QueryBuilder queryBuilder=new QueryBuilder().append(fromQuery).appendQualifier(""String_Node_Str"",conditionQueryBuilder.getQuery()).appendQualifier(""String_Node_Str"",groupBy).appendQualifier(""String_Node_Str"",having.getQuery()).appendQualifier(""String_Node_Str"",orderBy).appendQualifier(""String_Node_Str"",limit).appendQualifier(""String_Node_Str"",offset);
  if (FlowLog.isEnabled(FlowLog.Level.V)) {
    FlowLog.log(FlowLog.Level.V,queryBuilder.getQuery());
  }
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  String fromQuery=whereBase.getQuery();
  QueryBuilder queryBuilder=new QueryBuilder().append(fromQuery).appendQualifier(""String_Node_Str"",conditionQueryBuilder.getQuery()).appendQualifier(""String_Node_Str"",groupBy).appendQualifier(""String_Node_Str"",having.getQuery()).appendQualifier(null,orderBy).appendQualifier(""String_Node_Str"",limit).appendQualifier(""String_Node_Str"",offset);
  if (FlowLog.isEnabled(FlowLog.Level.V)) {
    FlowLog.log(FlowLog.Level.V,queryBuilder.getQuery());
  }
  return queryBuilder.getQuery();
}"
27021,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (!TextUtils.isEmpty(stringOrderBy)) {
    queryBuilder.append(stringOrderBy);
  }
 else {
    for (int i=0; i < columnAliasList.size(); i++) {
      if (i > 0) {
        queryBuilder.append(""String_Node_Str"");
      }
      queryBuilder.append(columnAliasList.get(i).getAliasName());
    }
    queryBuilder.appendSpace().append(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    if (orderByCollation != null) {
      queryBuilder.appendSpace().appendSpaceSeparated(orderByCollation);
    }
  }
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (!TextUtils.isEmpty(stringOrderBy)) {
    queryBuilder.append(stringOrderBy);
  }
 else {
    for (int i=0; i < columnAliasList.size(); i++) {
      if (i > 0) {
        queryBuilder.append(""String_Node_Str"");
      }
      queryBuilder.append(columnAliasList.get(i).getAliasName());
    }
    queryBuilder.appendSpace().append(ascending ? ""String_Node_Str"" : ""String_Node_Str"");
    if (orderByCollation != null) {
      queryBuilder.appendSpace().append(""String_Node_Str"").appendSpaceSeparated(orderByCollation);
    }
  }
  return queryBuilder.getQuery();
}"
27022,"/** 
 * Ends the transaction where it finishes, and will call   {@link #onChange(boolean,Uri)} for Jelly Bean and up forevery URI called (if set), or  {@link #onChange(boolean)} once for lower than Jelly bean.
 */
public void endTransactionAndNotify(){
  if (isInTransaction) {
    isInTransaction=false;
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
      onChange(true);
    }
 else {
synchronized (notificationUris) {
        for (        Uri uri : notificationUris) {
          onChange(true,uri);
        }
        notificationUris.clear();
      }
    }
  }
}","/** 
 * Ends the transaction where it finishes, and will call   {@link #onChange(boolean,Uri)} for Jelly Bean and up forevery URI called (if set), or  {@link #onChange(boolean)} once for lower than Jelly bean.
 */
public void endTransactionAndNotify(){
  if (isInTransaction) {
    isInTransaction=false;
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
      onChange(true);
    }
 else {
synchronized (notificationUris) {
        for (        Uri uri : notificationUris) {
          onChange(true,uri);
        }
        notificationUris.clear();
      }
    }
  }
}"
27023,"@SuppressWarnings(""String_Node_Str"") @Override public List<ModelClass> onExecute(){
  if (contentObserver != null) {
    contentObserver.beginTransaction();
  }
  processModelInfo.processModels(this);
  List<ModelClass> models=processModelInfo.models;
  if (contentObserver != null) {
    contentObserver.endTransactionAndNotify();
  }
  return models;
}","@SuppressWarnings(""String_Node_Str"") @Override public List<ModelClass> onExecute(){
  if (contentObserver != null) {
    contentObserver.beginTransaction();
  }
  processModelInfo.processModels(new ProcessModel<ModelClass>(){
    @Override public void processModel(    ModelClass model){
      ProcessModelTransaction.this.processModel(model);
      count++;
      if (changeListener != null) {
        changeListener.onProcessProgressChange(count,totalCount,model);
      }
    }
  }
);
  List<ModelClass> models=processModelInfo.models;
  if (contentObserver != null) {
    contentObserver.endTransactionAndNotify();
  }
  return models;
}"
27024,"/** 
 * Constructs this transaction with a single model enabled.
 * @param modelInfo       Holds information about this process request
 * @param contentObserver The optional {@link FlowContentObserver} to wrap the process in a transaction.
 */
public ProcessModelTransaction(ProcessModelInfo<ModelClass> modelInfo,FlowContentObserver contentObserver){
  super(modelInfo.getInfo(),modelInfo.transactionListener);
  processModelInfo=modelInfo;
  this.contentObserver=contentObserver;
}","/** 
 * Constructs this transaction with a single model enabled.
 * @param modelInfo       Holds information about this process request
 * @param contentObserver The optional {@link FlowContentObserver} to wrap the process in a transaction.
 */
public ProcessModelTransaction(ProcessModelInfo<ModelClass> modelInfo,FlowContentObserver contentObserver){
  super(modelInfo.getInfo(),modelInfo.transactionListener);
  processModelInfo=modelInfo;
  this.contentObserver=contentObserver;
  totalCount=processModelInfo.models.size();
}"
27025,"@TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void onChange(boolean selfChange,Uri uri){
  String fragment=uri.getFragment();
  String tableName=uri.getAuthority();
  String columnName=null;
  String param=null;
  Set<String> queryNames=uri.getQueryParameterNames();
  if (!queryNames.isEmpty()) {
    for (    String key : queryNames) {
      param=uri.getQueryParameter(key);
      columnName=key;
      break;
    }
  }
  Class<? extends Model> table=registeredTables.get(tableName);
  if (!isInTransaction) {
    BaseModel.Action action=BaseModel.Action.valueOf(fragment);
    if (action != null) {
      for (      OnModelStateChangedListener modelChangeListener : modelChangeListeners) {
        modelChangeListener.onModelStateChanged(table,action);
      }
      if (columnName != null && param != null) {
        for (        OnSpecificModelStateChangedListener modelChangeListener : specificModelChangeListeners) {
          modelChangeListener.onModelStateChanged(table,action,columnName,param);
        }
      }
    }
  }
 else {
    if (!notifyAllUris) {
      uri=SqlUtils.getNotificationUri(table,BaseModel.Action.CHANGE);
    }
synchronized (notificationUris) {
      notificationUris.add(uri);
    }
  }
}","@TargetApi(Build.VERSION_CODES.JELLY_BEAN) @Override public void onChange(boolean selfChange,Uri uri){
  String fragment=uri.getFragment();
  String tableName=uri.getAuthority();
  String columnName=null;
  String param=null;
  Set<String> queryNames=uri.getQueryParameterNames();
  if (!queryNames.isEmpty()) {
    for (    String key : queryNames) {
      param=Uri.decode(uri.getQueryParameter(key));
      columnName=key;
      break;
    }
  }
  Class<? extends Model> table=registeredTables.get(tableName);
  if (!isInTransaction) {
    BaseModel.Action action=BaseModel.Action.valueOf(fragment);
    if (action != null) {
      for (      OnModelStateChangedListener modelChangeListener : modelChangeListeners) {
        modelChangeListener.onModelStateChanged(table,action);
      }
      if (columnName != null && param != null) {
        for (        OnSpecificModelStateChangedListener modelChangeListener : specificModelChangeListeners) {
          modelChangeListener.onModelStateChanged(table,action,columnName,param);
        }
      }
    }
  }
 else {
    if (!notifyAllUris) {
      uri=SqlUtils.getNotificationUri(table,BaseModel.Action.CHANGE);
    }
synchronized (notificationUris) {
      notificationUris.add(uri);
    }
  }
}"
27026,"/** 
 * Replaces empty parameter values such as ""columnName = ?"" with the array of values passed in. It must match the count of columns that are in this where query.
 * @param values The values of the fields we wish to replace. Must match the length of the empty params and must be in empty param mode.
 * @return A new {@link ConditionQueryBuilder} with the parameters filled in.
 */
public ConditionQueryBuilder<ModelClass> replaceEmptyParams(Object... values){
  if (!useEmptyParams) {
    throw new IllegalStateException(""String_Node_Str"" + ConditionQueryBuilder.class.getSimpleName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (conditions.size() != values.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + modelAdapter.getTableName());
  }
  ConditionQueryBuilder<ModelClass> conditionQueryBuilder=new ConditionQueryBuilder<>(modelAdapter.getModelClass());
  for (int i=0; i < values.length; i++) {
    conditionQueryBuilder.addCondition(conditions.get(i).columnName(),values[i]);
  }
  return conditionQueryBuilder;
}","/** 
 * Replaces empty parameter values such as ""columnName = ?"" with the array of values passed in. It must match the count of columns that are in this where query.
 * @param values The values of the fields we wish to replace. Must match the length of the empty params and must be in empty param mode.
 * @return A new {@link ConditionQueryBuilder} with the parameters filled in.
 */
public ConditionQueryBuilder<ModelClass> replaceEmptyParams(Object... values){
  if (!useEmptyParams) {
    throw new IllegalStateException(""String_Node_Str"" + ConditionQueryBuilder.class.getSimpleName() + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (conditions.size() != values.length) {
    throw new IllegalArgumentException(""String_Node_Str"" + modelAdapter.getTableName());
  }
  ConditionQueryBuilder<ModelClass> conditionQueryBuilder=new ConditionQueryBuilder<>(modelAdapter.getModelClass());
  for (int i=0; i < values.length; i++) {
    SQLCondition condition=conditions.get(i);
    conditionQueryBuilder.addCondition(column(ColumnAlias.columnRaw(condition.columnName())).operation(condition.operation()).value(values[i]));
  }
  return conditionQueryBuilder;
}"
27027,"/** 
 * Appends a column to this class. It will append the correct string value based on the   {@link com.raizlabs.android.dbflow.processor.definition.ColumnDefinition}
 * @param column
 * @return
 */
public QueryBuilder appendColumn(ColumnDefinition column){
  if (column.length > -1) {
    query.append(""String_Node_Str"");
    query.append(column.length);
    query.append(""String_Node_Str"");
  }
  if (column.isPrimaryKeyAutoIncrement) {
    append(""String_Node_Str"");
  }
  if (column.notNull) {
    appendSpaceSeparated(""String_Node_Str"").append(column.onNullConflict.toString());
  }
  if (column.unique) {
    appendSpaceSeparated(""String_Node_Str"").append(column.onUniqueConflict.toString());
  }
  if (column.collate != null && !column.collate.isEmpty()) {
    appendSpaceSeparated(""String_Node_Str"").append(column.collate);
  }
  if (column.defaultValue != null && !column.defaultValue.isEmpty()) {
    appendSpaceSeparated(""String_Node_Str"").append(column.defaultValue);
  }
  return this;
}","/** 
 * Appends a column to this class. It will append the correct string value based on the   {@link com.raizlabs.android.dbflow.processor.definition.ColumnDefinition}
 * @param column
 * @return
 */
public QueryBuilder appendColumn(ColumnDefinition column){
  if (column.length > -1 && !column.isPrimaryKeyAutoIncrement) {
    query.append(""String_Node_Str"");
    query.append(column.length);
    query.append(""String_Node_Str"");
  }
  if (column.isPrimaryKeyAutoIncrement) {
    append(""String_Node_Str"");
  }
  if (column.notNull) {
    appendSpaceSeparated(""String_Node_Str"").append(column.onNullConflict.toString());
  }
  if (column.unique) {
    appendSpaceSeparated(""String_Node_Str"").append(column.onUniqueConflict.toString());
  }
  if (column.collate != null && !column.collate.isEmpty()) {
    appendSpaceSeparated(""String_Node_Str"").append(column.collate);
  }
  if (column.defaultValue != null && !column.defaultValue.isEmpty()) {
    appendSpaceSeparated(""String_Node_Str"").append(column.defaultValue);
  }
  return this;
}"
27028,"private String getPrivateGetterMethodName(){
  if (getterName == null || getterName.length() > 0) {
    String newName=referencedColumnFieldName.substring(0,1).toUpperCase() + (referencedColumnFieldName.length() > 1 ? referencedColumnFieldName.substring(1) : ""String_Node_Str"");
    return ""String_Node_Str"" + newName + ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + getterName + ""String_Node_Str"";
  }
}","private String getPrivateGetterMethodName(){
  if (getterName == null || getterName.length() == 0) {
    String newName=referencedColumnFieldName.substring(0,1).toUpperCase() + (referencedColumnFieldName.length() > 1 ? referencedColumnFieldName.substring(1) : ""String_Node_Str"");
    return ""String_Node_Str"" + newName + ""String_Node_Str"";
  }
 else {
    if (getterName.startsWith(""String_Node_Str"")) {
      return getterName + ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"" + getterName + ""String_Node_Str"";
    }
  }
}"
27029,"private String getPrivateSetterMethodName(){
  if (setterName == null || setterName.length() > 0) {
    String newName=referencedColumnFieldName.substring(0,1).toUpperCase() + (referencedColumnFieldName.length() > 1 ? referencedColumnFieldName.substring(1) : ""String_Node_Str"");
    return ""String_Node_Str"" + newName + ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"" + setterName + ""String_Node_Str"";
  }
}","private String getPrivateSetterMethodName(){
  if (setterName == null || setterName.length() == 0) {
    String newName=referencedColumnFieldName.substring(0,1).toUpperCase() + (referencedColumnFieldName.length() > 1 ? referencedColumnFieldName.substring(1) : ""String_Node_Str"");
    return ""String_Node_Str"" + newName + ""String_Node_Str"";
  }
 else {
    if (setterName.startsWith(""String_Node_Str"")) {
      return setterName + ""String_Node_Str"";
    }
 else {
      return ""String_Node_Str"" + setterName + ""String_Node_Str"";
    }
  }
}"
27030,"public ColumnAccessModel(ColumnDefinition columnDefinition,ForeignKeyReference foreignKeyReference){
  this.fieldIsAModelContainer=columnDefinition.fieldIsModelContainer;
  columnName=columnDefinition.columnName;
  columnFieldActualType=columnDefinition.columnFieldActualType;
  columnFieldName=columnDefinition.columnFieldName;
  columnFieldType=columnDefinition.columnFieldType;
  isPrivate=foreignKeyReference.fieldIsPrivate();
  foreignKeyLocalColumnName=foreignKeyReference.columnName();
  referencedColumnFieldName=columnDefinition.isModel ? foreignKeyReference.foreignColumnName() : columnDefinition.columnFieldName;
  containerKeyName=foreignKeyReference.foreignColumnName();
  isForeignKeyField=true;
  requiresTypeConverter=false;
  TypeMirror castClass=ModelUtils.getTypeMirrorFromAnnotation(foreignKeyReference);
  castedClass=castClass.toString();
  isABlob=false;
  isPrimitive=castClass.getKind().isPrimitive();
  columnFieldBoxedType=columnFieldActualType;
}","public ColumnAccessModel(ColumnDefinition columnDefinition,ForeignKeyReference foreignKeyReference){
  this.fieldIsAModelContainer=columnDefinition.fieldIsModelContainer;
  columnName=columnDefinition.columnName;
  setterName=columnDefinition.setterName;
  getterName=columnDefinition.getterName;
  columnFieldActualType=columnDefinition.columnFieldActualType;
  columnFieldName=columnDefinition.columnFieldName;
  columnFieldType=columnDefinition.columnFieldType;
  isPrivate=foreignKeyReference.fieldIsPrivate();
  foreignKeyLocalColumnName=foreignKeyReference.columnName();
  referencedColumnFieldName=columnDefinition.isModel ? foreignKeyReference.foreignColumnName() : columnDefinition.columnFieldName;
  containerKeyName=foreignKeyReference.foreignColumnName();
  isForeignKeyField=true;
  requiresTypeConverter=false;
  TypeMirror castClass=ModelUtils.getTypeMirrorFromAnnotation(foreignKeyReference);
  castedClass=castClass.toString();
  isABlob=false;
  isPrimitive=castClass.getKind().isPrimitive();
  columnFieldBoxedType=columnFieldActualType;
}"
27031,"@Override public synchronized void init(ProcessingEnvironment processingEnv){
  super.init(processingEnv);
  manager=new ProcessorManager(processingEnv);
  manager.addHandlers(new MigrationHandler(),new TypeConverterHandler(),new DatabaseHandler(),new TableHandler(),new ModelContainerHandler(),new ModelViewHandler(),new ContentProviderHandler(),new TableEndpointHandler());
}","@Override public synchronized void init(ProcessingEnvironment processingEnv){
  super.init(processingEnv);
  manager=new ProcessorManager(processingEnv);
  manager.addHandlers(new MigrationHandler(),new TypeConverterHandler(),new DatabaseHandler(),new TableHandler(),new QueryModelHandler(),new ModelContainerHandler(),new ModelViewHandler(),new ContentProviderHandler(),new TableEndpointHandler());
}"
27032,"@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){
  Set<? extends Element> elements=roundEnv.getElementsAnnotatedWith(Database.class);
  for (  Element element : elements) {
    Database database=element.getAnnotation(Database.class);
    if (database != null) {
      DEFAULT_DB_NAME=database.name();
      break;
    }
  }
  manager.handle(manager,roundEnv);
  return true;
}","@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){
  manager.handle(manager,roundEnv);
  return true;
}"
27033,"/** 
 * If the processor class is annotated with   {@link javax.annotation.processing.SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
@Override public Set<String> getSupportedAnnotationTypes(){
  Set<String> supportedTypes=new LinkedHashSet<>();
  supportedTypes.add(Table.class.getName());
  supportedTypes.add(Column.class.getName());
  supportedTypes.add(TypeConverter.class.getName());
  supportedTypes.add(ModelContainer.class.getName());
  supportedTypes.add(ModelView.class.getName());
  supportedTypes.add(Migration.class.getName());
  supportedTypes.add(ContentProvider.class.getName());
  supportedTypes.add(TableEndpoint.class.getName());
  return supportedTypes;
}","/** 
 * If the processor class is annotated with   {@link javax.annotation.processing.SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
@Override public Set<String> getSupportedAnnotationTypes(){
  Set<String> supportedTypes=new LinkedHashSet<>();
  supportedTypes.add(Table.class.getName());
  supportedTypes.add(Column.class.getName());
  supportedTypes.add(TypeConverter.class.getName());
  supportedTypes.add(ModelContainer.class.getName());
  supportedTypes.add(ModelView.class.getName());
  supportedTypes.add(Migration.class.getName());
  supportedTypes.add(ContentProvider.class.getName());
  supportedTypes.add(TableEndpoint.class.getName());
  supportedTypes.add(QueryModel.class.getName());
  return supportedTypes;
}"
27034,"public ContentProviderDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  ContentProvider provider=element.getAnnotation(ContentProvider.class);
  databaseName=provider.databaseName();
  if (databaseName == null || databaseName.isEmpty()) {
    databaseName=DBFlowProcessor.DEFAULT_DB_NAME;
  }
  DatabaseWriter databaseWriter=manager.getDatabaseWriter(databaseName);
  setDefinitionClassName(databaseWriter.classSeparator + DEFINITION_NAME);
  authority=provider.authority();
  TableEndpointValidator validator=new TableEndpointValidator();
  List<? extends Element> elements=manager.getElements().getAllMembers((TypeElement)typeElement);
  for (  Element innerElement : elements) {
    if (innerElement.getAnnotation(TableEndpoint.class) != null) {
      TableEndpointDefinition endpointDefinition=new TableEndpointDefinition(innerElement,manager);
      if (validator.validate(processorManager,endpointDefinition)) {
        endpointDefinitions.add(endpointDefinition);
      }
    }
  }
  mWriters=new FlowWriter[]{new QueryWriter(this,manager),new InsertWriter(this),new DeleteWriter(this,manager),new UpdateWriter(this,manager)};
}","public ContentProviderDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  ContentProvider provider=element.getAnnotation(ContentProvider.class);
  databaseName=provider.databaseName();
  DatabaseWriter databaseWriter=manager.getDatabaseWriter(databaseName);
  setDefinitionClassName(databaseWriter.classSeparator + DEFINITION_NAME);
  authority=provider.authority();
  TableEndpointValidator validator=new TableEndpointValidator();
  List<? extends Element> elements=manager.getElements().getAllMembers((TypeElement)typeElement);
  for (  Element innerElement : elements) {
    if (innerElement.getAnnotation(TableEndpoint.class) != null) {
      TableEndpointDefinition endpointDefinition=new TableEndpointDefinition(innerElement,manager);
      if (validator.validate(processorManager,endpointDefinition)) {
        endpointDefinitions.add(endpointDefinition);
      }
    }
  }
  mWriters=new FlowWriter[]{new QueryWriter(this,manager),new InsertWriter(this),new DeleteWriter(this,manager),new UpdateWriter(this,manager)};
}"
27035,"public MigrationDefinition(ProcessorManager processorManager,TypeElement typeElement){
  super(typeElement,processorManager);
  setDefinitionClassName(""String_Node_Str"");
  Migration migration=typeElement.getAnnotation(Migration.class);
  this.databaseName=migration.databaseName();
  if (databaseName == null || databaseName.isEmpty()) {
    databaseName=DBFlowProcessor.DEFAULT_DB_NAME;
  }
  version=migration.version();
}","public MigrationDefinition(ProcessorManager processorManager,TypeElement typeElement){
  super(typeElement,processorManager);
  setDefinitionClassName(""String_Node_Str"");
  Migration migration=typeElement.getAnnotation(Migration.class);
  this.databaseName=migration.databaseName();
  version=migration.version();
}"
27036,"public ModelViewDefinition(ProcessorManager manager,Element element){
  super(element,manager);
  ModelView modelView=element.getAnnotation(ModelView.class);
  this.query=modelView.query();
  this.databaseName=modelView.databaseName();
  if (databaseName == null || databaseName.isEmpty()) {
    databaseName=DBFlowProcessor.DEFAULT_DB_NAME;
  }
  databaseWriter=manager.getDatabaseWriter(databaseName);
  this.viewTableName=getModelClassName() + databaseWriter.classSeparator + TABLE_VIEW_TAG;
  setDefinitionClassName(databaseWriter.classSeparator + DBFLOW_MODEL_VIEW_TAG);
  this.name=modelView.name();
  if (name == null || name.isEmpty()) {
    name=getModelClassName();
  }
  DeclaredType typeAdapterInterface=null;
  final DeclaredType modelViewType=manager.getTypeUtils().getDeclaredType(manager.getElements().getTypeElement(Classes.MODEL_VIEW),manager.getTypeUtils().getWildcardType(manager.getElements().getTypeElement(Classes.MODEL).asType(),null));
  for (  TypeMirror superType : manager.getTypeUtils().directSupertypes(element.asType())) {
    if (manager.getTypeUtils().isAssignable(superType,modelViewType)) {
      typeAdapterInterface=(DeclaredType)superType;
      break;
    }
  }
  if (typeAdapterInterface != null) {
    final List<? extends TypeMirror> typeArguments=typeAdapterInterface.getTypeArguments();
    modelReferenceClass=manager.getElements().getTypeElement(typeArguments.get(0).toString());
  }
  createColumnDefinitions((TypeElement)element);
  implementsLoadFromCursorListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.LOAD_FROM_CURSOR_LISTENER,(TypeElement)element);
  mMethodWriters=new FlowWriter[]{new LoadCursorWriter(this,false,implementsLoadFromCursorListener),new ExistenceWriter(this,false),new WhereQueryWriter(this,false)};
}","public ModelViewDefinition(ProcessorManager manager,Element element){
  super(element,manager);
  ModelView modelView=element.getAnnotation(ModelView.class);
  this.query=modelView.query();
  this.databaseName=modelView.databaseName();
  databaseWriter=manager.getDatabaseWriter(databaseName);
  this.viewTableName=getModelClassName() + databaseWriter.classSeparator + TABLE_VIEW_TAG;
  setDefinitionClassName(databaseWriter.classSeparator + DBFLOW_MODEL_VIEW_TAG);
  this.name=modelView.name();
  if (name == null || name.isEmpty()) {
    name=getModelClassName();
  }
  DeclaredType typeAdapterInterface=null;
  final DeclaredType modelViewType=manager.getTypeUtils().getDeclaredType(manager.getElements().getTypeElement(Classes.MODEL_VIEW),manager.getTypeUtils().getWildcardType(manager.getElements().getTypeElement(Classes.MODEL).asType(),null));
  for (  TypeMirror superType : manager.getTypeUtils().directSupertypes(element.asType())) {
    if (manager.getTypeUtils().isAssignable(superType,modelViewType)) {
      typeAdapterInterface=(DeclaredType)superType;
      break;
    }
  }
  if (typeAdapterInterface != null) {
    final List<? extends TypeMirror> typeArguments=typeAdapterInterface.getTypeArguments();
    modelReferenceClass=manager.getElements().getTypeElement(typeArguments.get(0).toString());
  }
  createColumnDefinitions((TypeElement)element);
  implementsLoadFromCursorListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.LOAD_FROM_CURSOR_LISTENER,(TypeElement)element);
  mMethodWriters=new FlowWriter[]{new LoadCursorWriter(this,false,implementsLoadFromCursorListener),new ExistenceWriter(this,false),new WhereQueryWriter(this,false)};
}"
27037,"public TableDefinition(ProcessorManager manager,Element element){
  super(element,manager);
  Table table=element.getAnnotation(Table.class);
  this.tableName=table.value();
  databaseName=table.databaseName();
  if (databaseName == null || databaseName.isEmpty()) {
    databaseName=DBFlowProcessor.DEFAULT_DB_NAME;
  }
  databaseWriter=manager.getDatabaseWriter(databaseName);
  if (databaseWriter == null) {
    manager.logError(""String_Node_Str"" + tableName);
  }
  setDefinitionClassName(databaseWriter.classSeparator + DBFLOW_TABLE_TAG);
  this.adapterName=getModelClassName() + databaseWriter.classSeparator + DBFLOW_TABLE_ADAPTER;
  ConflictAction insertConflict=table.insertConflict();
  if (insertConflict.equals(ConflictAction.NONE) && !databaseWriter.insertConflict.equals(ConflictAction.NONE)) {
    insertConflict=databaseWriter.insertConflict;
  }
  ConflictAction updateConflict=table.updateConflict();
  if (updateConflict.equals(ConflictAction.NONE) && !databaseWriter.updateConflict.equals(ConflictAction.NONE)) {
    updateConflict=databaseWriter.updateConflict;
  }
  insertConflictActionName=insertConflict.equals(ConflictAction.NONE) ? ""String_Node_Str"" : insertConflict.name();
  updateConflicationActionName=updateConflict.equals(ConflictAction.NONE) ? ""String_Node_Str"" : updateConflict.name();
  allFields=table.allFields();
  manager.addModelToDatabase(getModelClassName(),databaseName);
  if (tableName == null || tableName.isEmpty()) {
    tableName=element.getSimpleName().toString();
  }
  primaryColumnDefinitions=new ArrayList<>();
  foreignKeyDefinitions=new ArrayList<>();
  createColumnDefinitions((TypeElement)element);
  UniqueGroup[] groups=table.uniqueColumnGroups();
  for (  UniqueGroup uniqueGroup : groups) {
    if (mUniqueGroupMap.containsKey(uniqueGroup.groupNumber())) {
      manager.logError(""String_Node_Str"",uniqueGroup.groupNumber(),tableName);
    }
    mUniqueGroupMap.put(uniqueGroup.groupNumber(),uniqueGroup);
  }
  implementsLoadFromCursorListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.LOAD_FROM_CURSOR_LISTENER,(TypeElement)element);
  implementsContentValuesListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.CONTENT_VALUES_LISTENER,(TypeElement)element);
  implementsSqlStatementListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.SQLITE_STATEMENT_LISTENER,((TypeElement)element));
  mMethodWriters=new FlowWriter[]{new SQLiteStatementWriter(this,false,implementsSqlStatementListener,implementsContentValuesListener),new ExistenceWriter(this,false),new LoadCursorWriter(this,false,implementsLoadFromCursorListener),new WhereQueryWriter(this,false),new CreationQueryWriter(manager,this)};
  if (getPrimaryColumnDefinitions().size() == 1) {
    ColumnDefinition columnDefinition=getColumnDefinitions().get(0);
    if (columnDefinition.isPrimaryKey) {
      if (!columnDefinition.hasTypeConverter) {
        hasCachingId=int.class.getCanonicalName().equals(columnDefinition.columnFieldType) || long.class.getCanonicalName().equals(columnDefinition.columnFieldType);
      }
    }
  }
}","public TableDefinition(ProcessorManager manager,Element element){
  super(element,manager);
  Table table=element.getAnnotation(Table.class);
  this.tableName=table.tableName();
  databaseName=table.databaseName();
  databaseWriter=manager.getDatabaseWriter(databaseName);
  if (databaseWriter == null) {
    manager.logError(""String_Node_Str"" + tableName);
  }
  setDefinitionClassName(databaseWriter.classSeparator + DBFLOW_TABLE_TAG);
  this.adapterName=getModelClassName() + databaseWriter.classSeparator + DBFLOW_TABLE_ADAPTER;
  ConflictAction insertConflict=table.insertConflict();
  if (insertConflict.equals(ConflictAction.NONE) && !databaseWriter.insertConflict.equals(ConflictAction.NONE)) {
    insertConflict=databaseWriter.insertConflict;
  }
  ConflictAction updateConflict=table.updateConflict();
  if (updateConflict.equals(ConflictAction.NONE) && !databaseWriter.updateConflict.equals(ConflictAction.NONE)) {
    updateConflict=databaseWriter.updateConflict;
  }
  insertConflictActionName=insertConflict.equals(ConflictAction.NONE) ? ""String_Node_Str"" : insertConflict.name();
  updateConflicationActionName=updateConflict.equals(ConflictAction.NONE) ? ""String_Node_Str"" : updateConflict.name();
  allFields=table.allFields();
  manager.addModelToDatabase(getModelClassName(),databaseName);
  if (tableName == null || tableName.isEmpty()) {
    tableName=element.getSimpleName().toString();
  }
  primaryColumnDefinitions=new ArrayList<>();
  foreignKeyDefinitions=new ArrayList<>();
  createColumnDefinitions((TypeElement)element);
  UniqueGroup[] groups=table.uniqueColumnGroups();
  for (  UniqueGroup uniqueGroup : groups) {
    if (mUniqueGroupMap.containsKey(uniqueGroup.groupNumber())) {
      manager.logError(""String_Node_Str"",uniqueGroup.groupNumber(),tableName);
    }
    mUniqueGroupMap.put(uniqueGroup.groupNumber(),uniqueGroup);
  }
  implementsLoadFromCursorListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.LOAD_FROM_CURSOR_LISTENER,(TypeElement)element);
  implementsContentValuesListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.CONTENT_VALUES_LISTENER,(TypeElement)element);
  implementsSqlStatementListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.SQLITE_STATEMENT_LISTENER,((TypeElement)element));
  mMethodWriters=new FlowWriter[]{new SQLiteStatementWriter(this,false,implementsSqlStatementListener,implementsContentValuesListener),new ExistenceWriter(this,false),new LoadCursorWriter(this,false,implementsLoadFromCursorListener),new WhereQueryWriter(this,false),new CreationQueryWriter(manager,this)};
  if (getPrimaryColumnDefinitions().size() == 1) {
    ColumnDefinition columnDefinition=getColumnDefinitions().get(0);
    if (columnDefinition.isPrimaryKey) {
      if (!columnDefinition.hasTypeConverter) {
        hasCachingId=int.class.getCanonicalName().equals(columnDefinition.columnFieldType) || long.class.getCanonicalName().equals(columnDefinition.columnFieldType);
      }
    }
  }
}"
27038,"public void writeSaveDefinition(JavaWriter javaWriter,boolean isModelContainerAdapter,boolean isContentValues,AtomicInteger columnCount) throws IOException {
  if (isForeignKey && isModel) {
    if (fieldIsModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    if (isModelContainerAdapter) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    String modelDefinition=isModelContainerAdapter ? (ModelUtils.getVariable(true) + columnFieldName) : ModelUtils.getModelStatement(columnFieldName);
    if (isModelContainerAdapter) {
      javaWriter.emitStatement(""String_Node_Str"",modelDefinition,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldName,columnFieldType);
    }
 else {
      javaWriter.beginControlFlow(""String_Node_Str"",modelDefinition);
    }
    if (saveModelForeignKey) {
      javaWriter.emitStatement(""String_Node_Str"",modelDefinition);
    }
    List<AdapterQueryBuilder> elseNullPuts=new ArrayList<>();
    for (    ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
      ColumnAccessModel columnAccessModel=new ColumnAccessModel(this,foreignKeyReference);
      ForeignKeyContainerModel foreignKeyContainerModel=new ForeignKeyContainerModel(columnAccessModel,isContentValues);
      foreignKeyContainerModel.setModelContainerName(modelDefinition);
      foreignKeyContainerModel.setIndex(columnCount.intValue());
      foreignKeyContainerModel.setIsModelContainerDefinition(isModelContainerAdapter);
      foreignKeyContainerModel.setPutValue(foreignKeyReference.columnName());
      foreignKeyContainerModel.write(javaWriter);
      if (!isModelContainerAdapter) {
        elseNullPuts.add(foreignKeyContainerModel.getNullStatement());
      }
      columnCount.incrementAndGet();
    }
    if (!isModelContainerAdapter) {
      javaWriter.nextControlFlow(""String_Node_Str"");
      for (      AdapterQueryBuilder queryBuilder : elseNullPuts) {
        javaWriter.emitStatement(queryBuilder.getQuery());
      }
      javaWriter.endControlFlow();
    }
  }
 else {
    String getType=columnFieldType;
    boolean isPrimitive=element.asType().getKind().isPrimitive();
    if (isPrimitive) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
    ContentValueModel contentValueModel=new ContentValueModel(columnAccessModel,isContentValues);
    contentValueModel.setPutValue(columnName);
    contentValueModel.setIndex(columnCount.intValue());
    contentValueModel.setDatabaseTypeName(getType);
    contentValueModel.write(javaWriter);
    columnCount.incrementAndGet();
  }
}","public void writeSaveDefinition(JavaWriter javaWriter,boolean isModelContainerAdapter,boolean isContentValues,AtomicInteger columnCount) throws IOException {
  if (isForeignKey && isModel) {
    if (fieldIsModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    if (isModelContainerAdapter) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    String modelDefinition=isModelContainerAdapter ? (ModelUtils.getVariable(true) + columnFieldName) : ModelUtils.getModelStatement(columnFieldName);
    if (isModelContainerAdapter) {
      javaWriter.emitStatement(""String_Node_Str"",modelDefinition,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldName,foreignKeyTableClassName);
    }
 else {
      javaWriter.beginControlFlow(""String_Node_Str"",modelDefinition);
    }
    if (saveModelForeignKey) {
      javaWriter.emitStatement(""String_Node_Str"",modelDefinition);
    }
    List<AdapterQueryBuilder> elseNullPuts=new ArrayList<>();
    for (    ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
      ColumnAccessModel columnAccessModel=new ColumnAccessModel(this,foreignKeyReference);
      ForeignKeyContainerModel foreignKeyContainerModel=new ForeignKeyContainerModel(columnAccessModel,isContentValues);
      foreignKeyContainerModel.setModelContainerName(modelDefinition);
      foreignKeyContainerModel.setIndex(columnCount.intValue());
      foreignKeyContainerModel.setIsModelContainerDefinition(isModelContainerAdapter);
      foreignKeyContainerModel.setPutValue(foreignKeyReference.columnName());
      foreignKeyContainerModel.write(javaWriter);
      if (!isModelContainerAdapter) {
        elseNullPuts.add(foreignKeyContainerModel.getNullStatement());
      }
      columnCount.incrementAndGet();
    }
    if (!isModelContainerAdapter) {
      javaWriter.nextControlFlow(""String_Node_Str"");
      for (      AdapterQueryBuilder queryBuilder : elseNullPuts) {
        javaWriter.emitStatement(queryBuilder.getQuery());
      }
      javaWriter.endControlFlow();
    }
  }
 else {
    String getType=columnFieldType;
    boolean isPrimitive=element.asType().getKind().isPrimitive();
    if (isPrimitive) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    ColumnAccessModel columnAccessModel=new ColumnAccessModel(manager,this,isModelContainerAdapter);
    ContentValueModel contentValueModel=new ContentValueModel(columnAccessModel,isContentValues);
    contentValueModel.setPutValue(columnName);
    contentValueModel.setIndex(columnCount.intValue());
    contentValueModel.setDatabaseTypeName(getType);
    contentValueModel.write(javaWriter);
    columnCount.incrementAndGet();
  }
}"
27039,"public void writeLoadFromCursorDefinition(BaseTableDefinition tableDefinition,JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (isForeignKey) {
    javaWriter.emitEmptyLine();
    javaWriter.emitSingleLineComment(""String_Node_Str"",columnFieldName);
    if (!fieldIsModelContainer && !isModelContainerAdapter && isModel) {
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder().appendForeignKeyReferences(columnFieldType + tableDefinition.databaseWriter.classSeparator + TableDefinition.DBFLOW_TABLE_TAG,columnName,foreignKeyReferences);
      String rawConditionStatement=String.format(""String_Node_Str"",ModelUtils.getFieldClass(columnFieldType),conditionQueryBuilder);
      AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder().appendVariable(false);
      adapterQueryBuilder.append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"");
      adapterQueryBuilder.append(rawConditionStatement);
      javaWriter.emitStatement(adapterQueryBuilder.getQuery());
      javaWriter.endControlFlow();
    }
 else {
      if (isModelContainerAdapter) {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
 else {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      String modelContainerName=""String_Node_Str"";
      if (isModelContainerAdapter) {
        modelContainerName=ModelUtils.getVariable(isModelContainerAdapter) + columnFieldName;
        javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldType);
      }
 else       if (fieldIsModelContainer) {
        AdapterQueryBuilder containerBuilder=new AdapterQueryBuilder().appendVariable(isModelContainerAdapter).append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").append(columnFieldActualType).appendParenthesisEnclosed(ModelUtils.getFieldClass(columnFieldType));
        javaWriter.emitStatement(containerBuilder.getQuery());
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        ColumnAccessModel columnAccessModel=new ColumnAccessModel(this,foreignKeyReference);
        LoadFromCursorModel loadFromCursorModel=new LoadFromCursorModel(columnAccessModel);
        loadFromCursorModel.setIsNullable(isNullable());
        loadFromCursorModel.setModelContainerName(modelContainerName);
        loadFromCursorModel.setIsModelContainerAdapter(isModelContainerAdapter);
        loadFromCursorModel.write(javaWriter);
      }
      if (isModelContainerAdapter) {
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName,modelContainerName);
        javaWriter.nextControlFlow(""String_Node_Str"");
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName);
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String getType=columnFieldType;
    if (element.asType().getKind().isPrimitive()) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    ModelUtils.writeLoadFromCursorDefinitionField(javaWriter,manager,getType,columnFieldName,columnName,""String_Node_Str"",containerKeyName,modelType,hasTypeConverter,isModelContainerAdapter,this.fieldIsModelContainer,isNullable(),isBlob);
  }
}","public void writeLoadFromCursorDefinition(BaseTableDefinition tableDefinition,JavaWriter javaWriter,boolean isModelContainerAdapter) throws IOException {
  if (isForeignKey) {
    javaWriter.emitEmptyLine();
    javaWriter.emitSingleLineComment(""String_Node_Str"",columnFieldName);
    if (!fieldIsModelContainer && !isModelContainerAdapter && isModel) {
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder().appendForeignKeyReferences(columnFieldType + tableDefinition.databaseWriter.classSeparator + TableDefinition.DBFLOW_TABLE_TAG,columnName,foreignKeyReferences);
      String rawConditionStatement=String.format(""String_Node_Str"",ModelUtils.getFieldClass(columnFieldType),conditionQueryBuilder);
      AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder().appendVariable(false);
      adapterQueryBuilder.append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"");
      adapterQueryBuilder.append(rawConditionStatement);
      javaWriter.emitStatement(adapterQueryBuilder.getQuery());
      javaWriter.endControlFlow();
    }
 else {
      if (isModelContainerAdapter) {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
 else {
        javaWriter.emitSingleLineComment(""String_Node_Str"");
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getColumnIndex(foreignKeyReference.columnName()));
      }
      ModelUtils.writeColumnIndexCheckers(javaWriter,foreignKeyReferences);
      String modelContainerName=""String_Node_Str"";
      if (isModelContainerAdapter) {
        if (isModel) {
          modelContainerName=ModelUtils.getVariable(isModelContainerAdapter) + columnFieldName;
          javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),foreignKeyTableClassName);
        }
 else {
          modelContainerName=ModelUtils.getVariable(isModelContainerAdapter);
        }
      }
 else       if (fieldIsModelContainer) {
        AdapterQueryBuilder containerBuilder=new AdapterQueryBuilder().appendVariable(isModelContainerAdapter).append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").append(columnFieldActualType).appendParenthesisEnclosed(ModelUtils.getFieldClass(columnFieldType));
        javaWriter.emitStatement(containerBuilder.getQuery());
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        ColumnAccessModel columnAccessModel=new ColumnAccessModel(this,foreignKeyReference);
        LoadFromCursorModel loadFromCursorModel=new LoadFromCursorModel(columnAccessModel);
        loadFromCursorModel.setIsNullable(isNullable());
        loadFromCursorModel.setModelContainerName(modelContainerName);
        loadFromCursorModel.setIsModelContainerAdapter(isModelContainerAdapter);
        loadFromCursorModel.write(javaWriter);
      }
      if (isModelContainerAdapter && isModel && fieldIsModelContainer) {
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName,modelContainerName);
        javaWriter.nextControlFlow(""String_Node_Str"");
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName);
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String getType=columnFieldType;
    if (element.asType().getKind().isPrimitive()) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    ModelUtils.writeLoadFromCursorDefinitionField(javaWriter,manager,getType,columnFieldName,columnName,""String_Node_Str"",containerKeyName,modelType,hasTypeConverter,isModelContainerAdapter,this.fieldIsModelContainer,isNullable(),isBlob);
  }
}"
27040,"public ColumnDefinition(ProcessorManager processorManager,VariableElement element){
  super(element,processorManager);
  column=element.getAnnotation(Column.class);
  ForeignKey foreignKey=element.getAnnotation(ForeignKey.class);
  if (foreignKey != null) {
    isForeignKey=true;
  }
  PrimaryKey primaryKey=element.getAnnotation(PrimaryKey.class);
  if (primaryKey != null) {
    if (primaryKey.autoincrement()) {
      isPrimaryKeyAutoIncrement=true;
    }
 else {
      isPrimaryKey=true;
    }
  }
  Unique uniqueColumn=element.getAnnotation(Unique.class);
  if (uniqueColumn != null && uniqueColumn.unique()) {
    unique=true;
  }
  if (column != null) {
    this.columnName=column.name().equals(""String_Node_Str"") ? element.getSimpleName().toString() : column.name();
    this.saveModelForeignKey=foreignKey == null || foreignKey.saveForeignKeyModel();
    length=column.length();
    int[] groups=uniqueColumn == null ? new int[0] : uniqueColumn.uniqueGroups();
    for (    int group : groups) {
      uniqueGroups.add(group);
    }
    onUniqueConflict=column.onUniqueConflict();
    notNull=column.notNull();
    onNullConflict=column.onNullConflict();
    collate=column.collate();
    defaultValue=column.defaultValue();
  }
 else {
    this.columnName=element.getSimpleName().toString();
  }
  this.columnFieldName=element.getSimpleName().toString();
  this.columnFieldType=element.asType().toString();
  this.columnFieldActualType=columnFieldType;
  ContainerKey containerKey=element.getAnnotation(ContainerKey.class);
  if (containerKey != null) {
    containerKeyName=containerKey.value();
  }
 else {
    containerKeyName=columnName;
  }
  this.columnFieldIsPrimitive=element.asType().getKind().isPrimitive();
  if (columnFieldIsPrimitive) {
    this.modelType=processorManager.getTypeUtils().boxedClass((PrimitiveType)element.asType());
  }
 else {
    boolean isAModelContainer=false;
    DeclaredType declaredType=null;
    if (element.asType() instanceof DeclaredType) {
      declaredType=(DeclaredType)element.asType();
      isAModelContainer=!declaredType.getTypeArguments().isEmpty();
    }
 else     if (element.asType() instanceof ArrayType) {
      processorManager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
    }
    if (isAModelContainer) {
      fieldIsModelContainer=true;
      modelContainerType=columnFieldType;
      this.modelType=(TypeElement)processorManager.getTypeUtils().asElement(declaredType.getTypeArguments().get(0));
      columnFieldType=modelType.asType().toString();
    }
 else {
      this.modelType=processorManager.getElements().getTypeElement(element.asType().toString());
    }
  }
  if (isForeignKey) {
    foreignKeyReferences=foreignKey.references();
  }
  isModel=ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL,modelType);
  final TypeConverterDefinition typeConverterDefinition=processorManager.getTypeConverterDefinition(modelType);
  if (typeConverterDefinition != null) {
    hasTypeConverter=true;
  }
  if (""String_Node_Str"".equals(modelType.getQualifiedName().toString())) {
    isBoolean=true;
  }
  if (!hasTypeConverter && !isModel) {
    hasTypeConverter=!SQLiteType.containsClass(columnFieldType);
  }
  if (columnFieldType.equals(Blob.class.getName())) {
    isBlob=true;
  }
}","public ColumnDefinition(ProcessorManager processorManager,VariableElement element){
  super(element,processorManager);
  column=element.getAnnotation(Column.class);
  PrimaryKey primaryKey=element.getAnnotation(PrimaryKey.class);
  if (primaryKey != null) {
    if (primaryKey.autoincrement()) {
      isPrimaryKeyAutoIncrement=true;
    }
 else {
      isPrimaryKey=true;
    }
  }
  Unique uniqueColumn=element.getAnnotation(Unique.class);
  if (uniqueColumn != null && uniqueColumn.unique()) {
    unique=true;
  }
  if (column != null) {
    this.columnName=column.name().equals(""String_Node_Str"") ? element.getSimpleName().toString() : column.name();
    length=column.length();
    int[] groups=uniqueColumn == null ? new int[0] : uniqueColumn.uniqueGroups();
    for (    int group : groups) {
      uniqueGroups.add(group);
    }
    onUniqueConflict=column.onUniqueConflict();
    notNull=column.notNull();
    onNullConflict=column.onNullConflict();
    collate=column.collate();
    defaultValue=column.defaultValue();
  }
 else {
    this.columnName=element.getSimpleName().toString();
  }
  this.columnFieldName=element.getSimpleName().toString();
  this.columnFieldType=element.asType().toString();
  this.columnFieldActualType=columnFieldType;
  ContainerKey containerKey=element.getAnnotation(ContainerKey.class);
  if (containerKey != null) {
    containerKeyName=containerKey.value();
  }
 else {
    containerKeyName=columnName;
  }
  this.columnFieldIsPrimitive=element.asType().getKind().isPrimitive();
  if (columnFieldIsPrimitive) {
    this.modelType=processorManager.getTypeUtils().boxedClass((PrimitiveType)element.asType());
  }
 else {
    boolean isAModelContainer=false;
    DeclaredType declaredType=null;
    if (element.asType() instanceof DeclaredType) {
      declaredType=(DeclaredType)element.asType();
      isAModelContainer=!declaredType.getTypeArguments().isEmpty();
    }
 else     if (element.asType() instanceof ArrayType) {
      processorManager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
    }
    if (isAModelContainer) {
      fieldIsModelContainer=true;
      modelContainerType=columnFieldType;
      this.modelType=(TypeElement)processorManager.getTypeUtils().asElement(declaredType.getTypeArguments().get(0));
      columnFieldType=modelType.asType().toString();
    }
 else {
      this.modelType=processorManager.getElements().getTypeElement(element.asType().toString());
    }
  }
  ForeignKey foreignKey=element.getAnnotation(ForeignKey.class);
  if (foreignKey != null) {
    isForeignKey=true;
    foreignKeyTableClassName=ModelUtils.getClassFromAnnotation(foreignKey);
    this.saveModelForeignKey=foreignKey.saveForeignKeyModel();
    if (foreignKeyTableClassName.equals(Void.class.getName())) {
      foreignKeyTableClassName=columnFieldType;
    }
    foreignKeyReferences=foreignKey.references();
  }
  isModel=ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL,modelType);
  final TypeConverterDefinition typeConverterDefinition=processorManager.getTypeConverterDefinition(modelType);
  if (typeConverterDefinition != null) {
    hasTypeConverter=true;
  }
  if (""String_Node_Str"".equals(modelType.getQualifiedName().toString())) {
    isBoolean=true;
  }
  if (!hasTypeConverter && !isModel) {
    hasTypeConverter=!SQLiteType.containsClass(columnFieldType);
  }
  if (columnFieldType.equals(Blob.class.getName())) {
    isBlob=true;
  }
}"
27041,"public static String getClassFromAnnotation(ForeignKeyReference annotation){
  String clazz=null;
  if (annotation != null) {
    try {
      annotation.columnType();
    }
 catch (    MirroredTypeException mte) {
      clazz=mte.getTypeMirror().toString();
    }
  }
  return clazz;
}","public static String getClassFromAnnotation(ForeignKey annotation){
  String clazz=null;
  if (annotation != null) {
    try {
      annotation.tableClass();
    }
 catch (    MirroredTypeException mte) {
      clazz=mte.getTypeMirror().toString();
    }
  }
  return clazz;
}"
27042,"@Override public boolean validate(ProcessorManager processorManager,ColumnDefinition columnDefinition){
  boolean success=true;
  if (columnDefinition.columnName == null || columnDefinition.columnName.isEmpty()) {
    success=false;
    processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
  }
  if (columnDefinition.isForeignKey) {
    if (columnDefinition.foreignKeyReferences == null || columnDefinition.foreignKeyReferences.length == 0) {
      success=false;
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (columnDefinition.column.name().length() > 0) {
      success=false;
      processorManager.logError(""String_Node_Str"" + ""String_Node_Str"",columnDefinition.columnFieldName);
    }
  }
 else   if (!columnDefinition.isForeignKey && !columnDefinition.isPrimaryKey && !columnDefinition.isPrimaryKeyAutoIncrement) {
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
  }
 else   if (columnDefinition.isPrimaryKey || columnDefinition.isPrimaryKeyAutoIncrement) {
    if (autoIncrementingPrimaryKey != null && columnDefinition.isPrimaryKey) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
 else     if (columnDefinition.isModel) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.isPrimaryKeyAutoIncrement) {
      if (autoIncrementingPrimaryKey == null) {
        autoIncrementingPrimaryKey=columnDefinition;
      }
 else       if (!autoIncrementingPrimaryKey.equals(columnDefinition)) {
        processorManager.logError(""String_Node_Str"");
        success=false;
      }
    }
  }
  if (!columnDefinition.isForeignKey && (columnDefinition.isModel || columnDefinition.fieldIsModelContainer)) {
    processorManager.logError(""String_Node_Str"");
  }
  return success;
}","@Override public boolean validate(ProcessorManager processorManager,ColumnDefinition columnDefinition){
  boolean success=true;
  if (columnDefinition.columnName == null || columnDefinition.columnName.isEmpty()) {
    success=false;
    processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
  }
  if (columnDefinition.isForeignKey) {
    ForeignKeyReference[] references=columnDefinition.foreignKeyReferences;
    if (references == null || references.length == 0) {
      success=false;
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (columnDefinition.column.name().length() > 0) {
      success=false;
      processorManager.logError(""String_Node_Str"" + ""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (references != null && references.length > 1 && (!columnDefinition.isModel || !columnDefinition.fieldIsModelContainer)) {
      success=false;
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
  }
 else   if (!columnDefinition.isForeignKey && !columnDefinition.isPrimaryKey && !columnDefinition.isPrimaryKeyAutoIncrement) {
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
  }
 else   if (columnDefinition.isPrimaryKey || columnDefinition.isPrimaryKeyAutoIncrement) {
    if (autoIncrementingPrimaryKey != null && columnDefinition.isPrimaryKey) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
 else     if (columnDefinition.isModel) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.isPrimaryKeyAutoIncrement) {
      if (autoIncrementingPrimaryKey == null) {
        autoIncrementingPrimaryKey=columnDefinition;
      }
 else       if (!autoIncrementingPrimaryKey.equals(columnDefinition)) {
        processorManager.logError(""String_Node_Str"");
        success=false;
      }
    }
  }
  if (!columnDefinition.isForeignKey && (columnDefinition.isModel || columnDefinition.fieldIsModelContainer)) {
    processorManager.logError(""String_Node_Str"");
  }
  return success;
}"
27043,"@Override public void write(JavaWriter javaWriter) throws IOException {
  TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
  tableCreationQuery.appendCreateTableIfNotExists(tableDefinition.tableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<>();
  List<String> foreignColumnClasses=Lists.newArrayList();
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    TableCreationQueryBuilder queryBuilder=new TableCreationQueryBuilder();
    if (columnDefinition.isForeignKey) {
      queryBuilder.appendSpace().appendForeignKeys(columnDefinition.foreignKeyReferences);
    }
 else {
      queryBuilder.appendQuoted(columnDefinition.columnName).appendSpace();
      if (columnDefinition.hasTypeConverter) {
        TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(columnDefinition.modelType);
        if (typeConverterDefinition != null) {
          queryBuilder.appendType(typeConverterDefinition.getDbElement().asType().toString());
        }
 else {
          manager.logError(""String_Node_Str"" + columnDefinition.columnFieldType);
          queryBuilder.append(""String_Node_Str"");
        }
      }
 else       if (SQLiteType.containsClass(columnDefinition.columnFieldType)) {
        queryBuilder.appendType(columnDefinition.columnFieldType);
      }
 else       if (ProcessorUtils.isSubclassOf(columnDefinition.columnFieldType,Enum.class)) {
        queryBuilder.appendSQLiteType(SQLiteType.TEXT);
      }
    }
    mColumnDefinitions.add(queryBuilder.appendColumn(columnDefinition));
  }
  boolean isModelView=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),tableDefinition.packageName + ""String_Node_Str"" + tableDefinition.getModelClassName(),manager.getElements().getTypeElement(Classes.MODEL_VIEW));
  if (!isModelView) {
    Map<Integer,List<ColumnDefinition>> uniqueGroups=tableDefinition.mColumnUniqueMap;
    if (!uniqueGroups.isEmpty()) {
      Set<Integer> groupSet=uniqueGroups.keySet();
      for (      Integer group : groupSet) {
        List<ColumnDefinition> columnDefinitions=uniqueGroups.get(group);
        ConflictAction conflictAction=ConflictAction.FAIL;
        boolean hasGroup=false;
        if (tableDefinition.mUniqueGroupMap.containsKey(group)) {
          conflictAction=tableDefinition.mUniqueGroupMap.get(group).uniqueConflict();
          hasGroup=true;
        }
        List<String> columnNames=Lists.newArrayList();
        for (        ColumnDefinition columnDefinition : columnDefinitions) {
          columnNames.add(columnDefinition.columnName);
          if (!columnDefinition.onUniqueConflict.equals(ConflictAction.FAIL) && !hasGroup) {
            conflictAction=columnDefinition.onUniqueConflict;
          }
        }
        QueryBuilder uniqueColumnQueryBuilder=new QueryBuilder(""String_Node_Str"");
        uniqueColumnQueryBuilder.appendQuotedList(columnNames).append(""String_Node_Str"").append(conflictAction.toString());
        mColumnDefinitions.add(uniqueColumnQueryBuilder);
      }
    }
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    int count=0;
    int index=0;
    for (    ColumnDefinition field : tableDefinition.primaryColumnDefinitions) {
      if (field.isPrimaryKey) {
        count++;
        primaryKeyQueryBuilder.appendQuoted(field.columnName);
        if (index < tableDefinition.primaryColumnDefinitions.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    for (    ColumnDefinition foreignKeyField : tableDefinition.foreignKeyDefinitions) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      String[] foreignColumns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=foreignKeyField.foreignKeyReferences[i].foreignColumnName();
      }
      String[] columns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < columns.length; i++) {
        columns[i]=foreignKeyField.foreignKeyReferences[i].columnName();
      }
      foreignKeyQueryBuilder.appendQuotedArray(columns).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").appendQuotedArray(foreignColumns).append(""String_Node_Str"").appendSpace().append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onUpdate().name().replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onDelete().name().replace(""String_Node_Str"",""String_Node_Str""));
      foreignColumnClasses.add(""String_Node_Str"" + ModelUtils.getFieldClass(foreignKeyField.columnFieldType) + ""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!tableDefinition.primaryColumnDefinitions.isEmpty() || !tableDefinition.foreignKeyDefinitions.isEmpty()) {
    manager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
  }
  tableCreationQuery.appendList(mColumnDefinitions).append(""String_Node_Str"");
  QueryBuilder returnQuery=new QueryBuilder();
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
  }
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
    returnQuery.appendList(foreignColumnClasses).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(returnQuery.getQuery(),tableCreationQuery.getQuery());
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
  tableCreationQuery.appendCreateTableIfNotExists(tableDefinition.tableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<>();
  List<String> foreignColumnClasses=Lists.newArrayList();
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    TableCreationQueryBuilder queryBuilder=new TableCreationQueryBuilder();
    if (columnDefinition.isForeignKey) {
      queryBuilder.appendSpace().appendForeignKeys(columnDefinition.foreignKeyReferences);
    }
 else {
      queryBuilder.appendQuoted(columnDefinition.columnName).appendSpace();
      if (columnDefinition.hasTypeConverter) {
        TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(columnDefinition.modelType);
        if (typeConverterDefinition != null) {
          queryBuilder.appendType(typeConverterDefinition.getDbElement().asType().toString());
        }
 else {
          manager.logError(""String_Node_Str"" + columnDefinition.columnFieldType);
          queryBuilder.append(""String_Node_Str"");
        }
      }
 else       if (SQLiteType.containsClass(columnDefinition.columnFieldType)) {
        queryBuilder.appendType(columnDefinition.columnFieldType);
      }
 else       if (ProcessorUtils.isSubclassOf(columnDefinition.columnFieldType,Enum.class)) {
        queryBuilder.appendSQLiteType(SQLiteType.TEXT);
      }
    }
    mColumnDefinitions.add(queryBuilder.appendColumn(columnDefinition));
  }
  boolean isModelView=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),tableDefinition.packageName + ""String_Node_Str"" + tableDefinition.getModelClassName(),manager.getElements().getTypeElement(Classes.MODEL_VIEW));
  if (!isModelView) {
    Map<Integer,List<ColumnDefinition>> uniqueGroups=tableDefinition.mColumnUniqueMap;
    if (!uniqueGroups.isEmpty()) {
      Set<Integer> groupSet=uniqueGroups.keySet();
      for (      Integer group : groupSet) {
        List<ColumnDefinition> columnDefinitions=uniqueGroups.get(group);
        ConflictAction conflictAction=ConflictAction.FAIL;
        boolean hasGroup=false;
        if (tableDefinition.mUniqueGroupMap.containsKey(group)) {
          conflictAction=tableDefinition.mUniqueGroupMap.get(group).uniqueConflict();
          hasGroup=true;
        }
        List<String> columnNames=Lists.newArrayList();
        for (        ColumnDefinition columnDefinition : columnDefinitions) {
          columnNames.add(columnDefinition.columnName);
          if (!columnDefinition.onUniqueConflict.equals(ConflictAction.FAIL) && !hasGroup) {
            conflictAction=columnDefinition.onUniqueConflict;
          }
        }
        QueryBuilder uniqueColumnQueryBuilder=new QueryBuilder(""String_Node_Str"");
        uniqueColumnQueryBuilder.appendQuotedList(columnNames).append(""String_Node_Str"").append(conflictAction.toString());
        mColumnDefinitions.add(uniqueColumnQueryBuilder);
      }
    }
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    int count=0;
    int index=0;
    for (    ColumnDefinition field : tableDefinition.primaryColumnDefinitions) {
      if (field.isPrimaryKey) {
        count++;
        primaryKeyQueryBuilder.appendQuoted(field.columnName);
        if (index < tableDefinition.primaryColumnDefinitions.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    for (    ColumnDefinition foreignKeyField : tableDefinition.foreignKeyDefinitions) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      String[] foreignColumns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=foreignKeyField.foreignKeyReferences[i].foreignColumnName();
      }
      String[] columns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < columns.length; i++) {
        columns[i]=foreignKeyField.foreignKeyReferences[i].columnName();
      }
      foreignKeyQueryBuilder.appendQuotedArray(columns).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").appendQuotedArray(foreignColumns).append(""String_Node_Str"").appendSpace().append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onUpdate().name().replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onDelete().name().replace(""String_Node_Str"",""String_Node_Str""));
      foreignColumnClasses.add(""String_Node_Str"" + ModelUtils.getFieldClass(foreignKeyField.foreignKeyTableClassName) + ""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!tableDefinition.primaryColumnDefinitions.isEmpty() || !tableDefinition.foreignKeyDefinitions.isEmpty()) {
    manager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
  }
  tableCreationQuery.appendList(mColumnDefinitions).append(""String_Node_Str"");
  QueryBuilder returnQuery=new QueryBuilder();
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
  }
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
    returnQuery.appendList(foreignColumnClasses).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(returnQuery.getQuery(),tableCreationQuery.getQuery());
}"
27044,"public void testNullForeignKey() throws JSONException {
  Delete.tables(TestModelContainerClass.class,ParentModel.class);
  JSONObject jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JSONModel<TestModelContainerClass> jsonModel=new JSONModel<>(jsonObject,TestModelContainerClass.class);
  jsonModel.save(false);
}","public void testNullForeignKey() throws JSONException {
  Delete.tables(TestModelContainerClass.class,ParentModel.class);
  JSONObject jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  JSONModel<TestModelContainerClass> jsonModel=new JSONModel<>(jsonObject,TestModelContainerClass.class);
  jsonModel.save();
}"
27045,"public void testBlob(){
  BlobModel blobModel=new BlobModel();
  blobModel.blob=new Blob(TEST_BLOB.getBytes());
  blobModel.save(false);
  assertTrue(blobModel.exists());
  BlobModel model=new Select().from(BlobModel.class).where(Condition.column(BlobModel$Table.KEY).is(blobModel.key)).querySingle();
  assertNotNull(model);
  assertNotNull(model.blob);
  assertEquals(new String(model.blob.getBlob()),TEST_BLOB);
}","public void testBlob(){
  BlobModel blobModel=new BlobModel();
  blobModel.blob=new Blob(TEST_BLOB.getBytes());
  blobModel.save();
  assertTrue(blobModel.exists());
  BlobModel model=new Select().from(BlobModel.class).where(Condition.column(BlobModel$Table.KEY).is(blobModel.key)).querySingle();
  assertNotNull(model);
  assertNotNull(model.blob);
  assertEquals(new String(model.blob.getBlob()),TEST_BLOB);
}"
27046,"@Override public void onWriteDefinition(JavaWriter javaWriter) throws IOException {
  javaWriter.emitField(""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PRIVATE,Modifier.FINAL),""String_Node_Str"");
  javaWriter.emitEmptyLine();
  javaWriter.beginConstructor(Sets.newHashSet(Modifier.PUBLIC));
  for (  ColumnDefinition columnDefinition : tableDefinition.columnDefinitions) {
    javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",columnDefinition.columnName,columnDefinition.columnFieldType);
  }
  javaWriter.endConstructor();
  javaWriter.emitEmptyLine();
  javaWriter.emitAnnotation(Override.class);
  WriterUtils.emitMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
  }
,""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"",""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,getModelClassQualifiedName());
  InternalAdapterHelper.writeGetTableName(javaWriter,elementClassName + tableDefinition.databaseWriter.classSeparator + TableDefinition.DBFLOW_TABLE_TAG);
  for (  FlowWriter writer : mMethodWriters) {
    writer.write(javaWriter);
  }
}","@Override public void onWriteDefinition(JavaWriter javaWriter) throws IOException {
  javaWriter.emitField(""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PRIVATE,Modifier.FINAL),""String_Node_Str"");
  javaWriter.emitEmptyLine();
  javaWriter.beginConstructor(Sets.newHashSet(Modifier.PUBLIC));
  for (  ColumnDefinition columnDefinition : tableDefinition.columnDefinitions) {
    javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",columnDefinition.columnName,columnDefinition.columnFieldType);
  }
  javaWriter.endConstructor();
  javaWriter.emitEmptyLine();
  javaWriter.emitAnnotation(Override.class);
  WriterUtils.emitMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
  }
,""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"",""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,getModelClassQualifiedName());
  InternalAdapterHelper.writeGetTableName(javaWriter,elementClassName + tableDefinition.databaseWriter.classSeparator + TableDefinition.DBFLOW_TABLE_TAG);
  for (  FlowWriter writer : methodWriters) {
    writer.write(javaWriter);
  }
}"
27047,"public ModelContainerDefinition(TypeElement classElement,ProcessorManager manager){
  super(classElement,manager);
  tableDefinition=manager.getTableDefinition(manager.getDatabase(classElement.getSimpleName().toString()),classElement);
  setDefinitionClassName(tableDefinition.databaseWriter.classSeparator + DBFLOW_MODEL_CONTAINER_TAG);
  mMethodWriters=new FlowWriter[]{new SQLiteStatementWriter(tableDefinition,true,tableDefinition.implementsSqlStatementListener,tableDefinition.implementsContentValuesListener),new ExistenceWriter(tableDefinition,true),new WhereQueryWriter(tableDefinition,true),new ToModelWriter(tableDefinition,true),new LoadCursorWriter(tableDefinition,true,tableDefinition.implementsLoadFromCursorListener)};
}","public ModelContainerDefinition(TypeElement classElement,ProcessorManager manager){
  super(classElement,manager);
  tableDefinition=manager.getTableDefinition(manager.getDatabase(classElement.getSimpleName().toString()),classElement);
  setDefinitionClassName(tableDefinition.databaseWriter.classSeparator + DBFLOW_MODEL_CONTAINER_TAG);
  methodWriters=new FlowWriter[]{new SQLiteStatementWriter(tableDefinition,true,tableDefinition.implementsSqlStatementListener,tableDefinition.implementsContentValuesListener),new ExistenceWriter(tableDefinition,true),new WhereQueryWriter(tableDefinition,true),new ToModelWriter(tableDefinition,true),new LoadCursorWriter(tableDefinition,true,tableDefinition.implementsLoadFromCursorListener)};
}"
27048,"public QueryModelDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  QueryModel queryModel=typeElement.getAnnotation(QueryModel.class);
  databaseName=queryModel.databaseName();
  databaseWriter=manager.getDatabaseWriter(databaseName);
  allFields=queryModel.allFields();
  adapterName=getModelClassName() + databaseWriter.classSeparator + DBFLOW_TABLE_ADAPTER;
  implementsLoadFromCursorListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.LOAD_FROM_CURSOR_LISTENER,(TypeElement)element);
  setDefinitionClassName(databaseWriter.classSeparator + DBFLOW_QUERY_MODEL_TAG);
  mMethodWriters=new FlowWriter[]{new LoadCursorWriter(this,false,implementsLoadFromCursorListener)};
  createColumnDefinitions(((TypeElement)typeElement));
}","public QueryModelDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  QueryModel queryModel=typeElement.getAnnotation(QueryModel.class);
  databaseName=queryModel.databaseName();
  databaseWriter=manager.getDatabaseWriter(databaseName);
  allFields=queryModel.allFields();
  adapterName=getModelClassName() + databaseWriter.classSeparator + DBFLOW_TABLE_ADAPTER;
  processorManager.addModelToDatabase(getQualifiedModelClassName(),databaseName);
  implementsLoadFromCursorListener=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),Classes.LOAD_FROM_CURSOR_LISTENER,(TypeElement)element);
  setDefinitionClassName(databaseWriter.classSeparator + DBFLOW_QUERY_MODEL_TAG);
  mMethodWriters=new FlowWriter[]{new LoadCursorWriter(this,false,implementsLoadFromCursorListener)};
  createColumnDefinitions(((TypeElement)typeElement));
}"
27049,"public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(packageName + ""String_Node_Str"" + adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.QUERY_MODEL_ADAPTER,Classes.CURSOR);
  javaWriter.emitSingleLineComment(""String_Node_Str"",databaseName);
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  for (  FlowWriter writer : mMethodWriters) {
    writer.write(javaWriter);
  }
  WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      javaWriter.emitStatement(""String_Node_Str"",getQualifiedModelClassName());
    }
  }
,getQualifiedModelClassName(),""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  javaWriter.endType();
  javaWriter.close();
}","public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(getQualifiedAdapterName()).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.QUERY_MODEL_ADAPTER,Classes.CURSOR);
  javaWriter.emitSingleLineComment(""String_Node_Str"",databaseName);
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  for (  FlowWriter writer : mMethodWriters) {
    writer.write(javaWriter);
  }
  WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      javaWriter.emitStatement(""String_Node_Str"",getQualifiedModelClassName());
    }
  }
,getQualifiedModelClassName(),""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  javaWriter.endType();
  javaWriter.close();
}"
27050,"@Override protected void onProcessElement(ProcessorManager processorManager,Element element){
  QueryModelDefinition queryModelDefinition=new QueryModelDefinition(element,processorManager);
  WriterUtils.writeBaseDefinition(queryModelDefinition,processorManager);
  try {
    queryModelDefinition.writeAdapter(processorManager.getProcessingEnvironment());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Override protected void onProcessElement(ProcessorManager processorManager,Element element){
  QueryModelDefinition queryModelDefinition=new QueryModelDefinition(element,processorManager);
  processorManager.addQueryModelDefinition(queryModelDefinition);
  WriterUtils.writeBaseDefinition(queryModelDefinition,processorManager);
  try {
    queryModelDefinition.writeAdapter(processorManager.getProcessingEnvironment());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
27051,"@Override public boolean validate(ProcessorManager processorManager,ColumnDefinition columnDefinition){
  boolean success=true;
  if (columnDefinition.columnName == null || columnDefinition.columnName.isEmpty()) {
    success=false;
    processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
  }
  if (columnDefinition.isForeignKey) {
    ForeignKeyReference[] references=columnDefinition.foreignKeyReferences;
    if (references == null || references.length == 0) {
      success=false;
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (columnDefinition.column.name().length() > 0) {
      success=false;
      processorManager.logError(""String_Node_Str"" + ""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (references != null && references.length > 1 && (!columnDefinition.isModel || !columnDefinition.fieldIsModelContainer)) {
      success=false;
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
  }
 else   if (!columnDefinition.isForeignKey && !columnDefinition.isPrimaryKey && !columnDefinition.isPrimaryKeyAutoIncrement) {
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
  }
 else   if (columnDefinition.isPrimaryKey || columnDefinition.isPrimaryKeyAutoIncrement) {
    if (autoIncrementingPrimaryKey != null && columnDefinition.isPrimaryKey) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
 else     if (columnDefinition.isModel) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.isPrimaryKeyAutoIncrement) {
      if (autoIncrementingPrimaryKey == null) {
        autoIncrementingPrimaryKey=columnDefinition;
      }
 else       if (!autoIncrementingPrimaryKey.equals(columnDefinition)) {
        processorManager.logError(""String_Node_Str"");
        success=false;
      }
    }
  }
  if (!columnDefinition.isForeignKey && (columnDefinition.isModel || columnDefinition.fieldIsModelContainer)) {
    processorManager.logError(""String_Node_Str"");
  }
  return success;
}","@Override public boolean validate(ProcessorManager processorManager,ColumnDefinition columnDefinition){
  boolean success=true;
  if (columnDefinition.columnName == null || columnDefinition.columnName.isEmpty()) {
    success=false;
    processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
  }
  if (columnDefinition.isForeignKey) {
    ForeignKeyReference[] references=columnDefinition.foreignKeyReferences;
    if (references == null || references.length == 0) {
      success=false;
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (columnDefinition.column.name().length() > 0) {
      success=false;
      processorManager.logError(""String_Node_Str"" + ""String_Node_Str"",columnDefinition.columnFieldName);
    }
    if (references != null && references.length > 1 && (!columnDefinition.isModel && !columnDefinition.fieldIsModelContainer)) {
      success=false;
      processorManager.logError(""String_Node_Str"" + columnDefinition.isModel + ""String_Node_Str""+ columnDefinition.fieldIsModelContainer);
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
    }
  }
 else   if (!columnDefinition.isPrimaryKey && !columnDefinition.isPrimaryKeyAutoIncrement) {
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
  }
 else {
    if (autoIncrementingPrimaryKey != null && columnDefinition.isPrimaryKey) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.foreignKeyReferences != null) {
      processorManager.logError(""String_Node_Str"",columnDefinition.columnFieldName);
      success=false;
    }
 else     if (columnDefinition.isModel) {
      processorManager.logError(""String_Node_Str"");
      success=false;
    }
    if (columnDefinition.isPrimaryKeyAutoIncrement) {
      if (autoIncrementingPrimaryKey == null) {
        autoIncrementingPrimaryKey=columnDefinition;
      }
 else       if (!autoIncrementingPrimaryKey.equals(columnDefinition)) {
        processorManager.logError(""String_Node_Str"");
        success=false;
      }
    }
  }
  if (!columnDefinition.isForeignKey && (columnDefinition.isModel || columnDefinition.fieldIsModelContainer)) {
    processorManager.logError(""String_Node_Str"");
  }
  return success;
}"
27052,"public void testCacheableModel2(){
  Delete.table(CacheableModel2.class);
  CacheableModel2 model=new CacheableModel2();
  ModelCache<CacheableModel2,?> modelCache=BaseCacheableModel.getCache((Class<CacheableModel2>)model.getClass());
  for (int i=0; i < 100; i++) {
    model.id=i;
    model.save();
    long id=model.id;
    CacheableModel2 cacheableModel=modelCache.get(id);
    assertNotNull(cacheableModel);
    assertEquals(new Select().from(CacheableModel2.class).where(Condition.column(CacheableModel$Table.NAME).is(id)).querySingle(),cacheableModel);
    model.delete();
    assertNull(modelCache.get(id));
  }
  Delete.table(CacheableModel2.class);
}","public void testCacheableModel2(){
  Delete.table(CacheableModel2.class);
  CacheableModel2 model=new CacheableModel2();
  ModelCache<CacheableModel2,?> modelCache=BaseCacheableModel.getCache((Class<CacheableModel2>)model.getClass());
  for (int i=0; i < 100; i++) {
    model.id=i;
    model.save();
    long id=model.id;
    CacheableModel2 cacheableModel=modelCache.get(id);
    assertNotNull(cacheableModel);
    assertEquals(new Select().from(CacheableModel2.class).where(Condition.column(CacheableModel2$Table.ID).is(id)).querySingle(),cacheableModel);
    model.delete();
    assertNull(modelCache.get(id));
  }
  Delete.table(CacheableModel2.class);
}"
27053,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (mConflictAction != null && !mConflictAction.equals(ConflictAction.NONE)) {
    queryBuilder.append(""String_Node_Str"").appendSpaceSeparated(mConflictAction.name());
  }
  queryBuilder.append(FlowManager.getTableName(mTable)).appendSpace();
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (mConflictAction != null && !mConflictAction.equals(ConflictAction.NONE)) {
    queryBuilder.append(""String_Node_Str"").appendSpaceSeparated(mConflictAction.name());
  }
  queryBuilder.appendQuoted(FlowManager.getTableName(mTable)).appendSpace();
  return queryBuilder.getQuery();
}"
27054,"@Override public boolean exists(){
  return mModelAdapter.exists(toModel());
}","@Override public boolean exists(){
  ModelClass model=toModel();
  return model != null && mModelAdapter.exists(model);
}"
27055,"public void testIsOperators(){
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class);
  conditionQueryBuilder.putCondition(Condition.column(ConditionModel$Table.NAME).is(""String_Node_Str"")).or(Condition.column(ConditionModel$Table.FRACTION).isNotNull());
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}","public void testIsOperators(){
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class);
  conditionQueryBuilder.addCondition(Condition.column(ConditionModel$Table.NAME).is(""String_Node_Str"")).or(Condition.column(ConditionModel$Table.FRACTION).isNotNull());
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}"
27056,"public void testChainingConditions(){
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class);
  conditionQueryBuilder.putCondition(Condition.column(ConditionModel$Table.NAME).is(""String_Node_Str"").separator(""String_Node_Str"")).putCondition(Condition.column(ConditionModel$Table.NUMBER).is(6).separator(""String_Node_Str"")).putCondition(Condition.column(ConditionModel$Table.FRACTION).is(4.5d));
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}","public void testChainingConditions(){
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class);
  conditionQueryBuilder.addCondition(Condition.column(ConditionModel$Table.NAME).is(""String_Node_Str"").separator(""String_Node_Str"")).addCondition(Condition.column(ConditionModel$Table.NUMBER).is(6).separator(""String_Node_Str"")).addCondition(Condition.column(ConditionModel$Table.FRACTION).is(4.5d));
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}"
27057,"/** 
 * This test will ensure that all column values are converted appropriately
 */
public void testConditions(){
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class);
  conditionQueryBuilder.putConditions(Condition.column(""String_Node_Str"").is(5L),Condition.column(""String_Node_Str"").is(5),Condition.column(""String_Node_Str"").is(6.5d));
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery());
  conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class).putCondition(Condition.column(ConditionModel$Table.NUMBER).between(5L).and(10L));
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}","/** 
 * This test will ensure that all column values are converted appropriately
 */
public void testConditions(){
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class);
  conditionQueryBuilder.addConditions(Condition.column(""String_Node_Str"").is(5L),Condition.column(""String_Node_Str"").is(5),Condition.column(""String_Node_Str"").is(6.5d));
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery());
  conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class).addCondition(Condition.column(ConditionModel$Table.NUMBER).between(5L).and(10L));
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}"
27058,"public void testInsert(){
  Delete.table(InsertModel.class);
  Insert<InsertModel> insert=new Insert<>(InsertModel.class).orFail().columns(InsertModel$Table.NAME,InsertModel$Table.VALUE).values(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",insert.getQuery());
  FlowManager.getDatabase(TestDatabase.NAME).getWritableDatabase().execSQL(insert.getQuery());
  InsertModel model=new Select().from(InsertModel.class).where(Condition.column(InsertModel$Table.NAME).is(""String_Node_Str"")).querySingle();
  assertNotNull(model);
  insert=new Insert<>(InsertModel.class).orAbort().values(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",insert.getQuery());
  FlowManager.getDatabase(TestDatabase.NAME).getWritableDatabase().execSQL(insert.getQuery());
  model=new Select().from(InsertModel.class).where(Condition.column(InsertModel$Table.NAME).is(""String_Node_Str"")).querySingle();
  assertNotNull(model);
}","public void testInsert(){
  Delete.table(InsertModel.class);
  Insert<InsertModel> insert=Insert.into(InsertModel.class).orFail().columns(InsertModel$Table.NAME,InsertModel$Table.VALUE).values(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",insert.getQuery());
  FlowManager.getDatabase(TestDatabase.NAME).getWritableDatabase().execSQL(insert.getQuery());
  InsertModel model=new Select().from(InsertModel.class).where(Condition.column(InsertModel$Table.NAME).is(""String_Node_Str"")).querySingle();
  assertNotNull(model);
  insert=Insert.into(InsertModel.class).orAbort().values(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",insert.getQuery());
  FlowManager.getDatabase(TestDatabase.NAME).getWritableDatabase().execSQL(insert.getQuery());
  model=new Select().from(InsertModel.class).where(Condition.column(InsertModel$Table.NAME).is(""String_Node_Str"")).querySingle();
  assertNotNull(model);
}"
27059,"public void testSubquery(){
  String query=new Select().from(BoxedModel.class).where().exists().subQuery().from(BoxedModel.class).where(Condition.columnRaw(BoxedModel$Table.INTEGERFIELD).eq(BoxedModel$Table.INTEGERFIELDNOTNULL)).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
}","public void testSubquery(){
  String query=new Select().from(BoxedModel.class).where().exists(new Select().from(BoxedModel.class).where(Condition.columnRaw(BoxedModel$Table.INTEGERFIELD).eq(BoxedModel$Table.INTEGERFIELDNOTNULL))).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
}"
27060,"public void writeSaveDefinition(JavaWriter javaWriter,boolean isModelContainerDefinition,boolean isContentValues,AtomicInteger columnCount) throws IOException {
  if (columnType == Column.FOREIGN_KEY && isModel) {
    if (isModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    if (isModelContainerDefinition) {
      String modelContainerName=ModelUtils.getVariable(true) + columnFieldName;
      javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldName,columnFieldType);
      if (saveModelForeignKey) {
        javaWriter.emitStatement(""String_Node_Str"",modelContainerName);
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
        if (!isContentValues) {
          adapterQueryBuilder.appendBindSQLiteStatement(columnCount.intValue(),ModelUtils.getClassFromAnnotation(foreignKeyReference));
        }
 else {
          adapterQueryBuilder.appendContentValues().appendPut(foreignKeyReference.columnName());
        }
        adapterQueryBuilder.appendCast(ModelUtils.getClassFromAnnotation(foreignKeyReference)).append(modelContainerName).append(""String_Node_Str"").appendGetValue(foreignKeyReference.foreignColumnName()).append(""String_Node_Str"");
        javaWriter.emitStatement(adapterQueryBuilder.getQuery());
        columnCount.incrementAndGet();
      }
    }
 else {
      String modelStatement=ModelUtils.getModelStatement(columnFieldName);
      javaWriter.beginControlFlow(""String_Node_Str"",modelStatement);
      if (saveModelForeignKey) {
        javaWriter.emitStatement(""String_Node_Str"",modelStatement);
      }
      List<AdapterQueryBuilder> elseNullPuts=new ArrayList<>();
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        TypeMirror castedClass=ModelUtils.getTypeMirrorFromAnnotation(foreignKeyReference);
        ModelUtils.writeContentValueStatement(javaWriter,isContentValues,columnCount.intValue(),foreignKeyReference.columnName(),columnName,castedClass.toString(),foreignKeyReference.foreignColumnName(),foreignKeyReference.foreignColumnName(),false,isModelContainer,true,false,columnFieldType,castedClass.getKind().isPrimitive(),false);
        AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
        if (isContentValues) {
          adapterQueryBuilder.appendContentValues();
          adapterQueryBuilder.append(""String_Node_Str"").appendParenthesisEnclosed(""String_Node_Str"" + foreignKeyReference.columnName() + ""String_Node_Str"");
        }
 else {
          adapterQueryBuilder.append(""String_Node_Str"");
          adapterQueryBuilder.append(""String_Node_Str"").appendParenthesisEnclosed(columnCount);
        }
        elseNullPuts.add(adapterQueryBuilder);
        columnCount.incrementAndGet();
      }
      javaWriter.nextControlFlow(""String_Node_Str"");
      for (      AdapterQueryBuilder queryBuilder : elseNullPuts) {
        javaWriter.emitStatement(queryBuilder.getQuery());
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String newFieldType=null;
    if (hasTypeConverter) {
      TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(modelType);
      if (typeConverterDefinition == null) {
        manager.getMessager().printMessage(Diagnostic.Kind.ERROR,String.format(""String_Node_Str"",modelType));
      }
 else {
        newFieldType=typeConverterDefinition.getDbElement().asType().toString();
      }
    }
 else {
      newFieldType=columnFieldType;
    }
    String getType=columnFieldType;
    boolean isPrimitive=element.asType().getKind().isPrimitive();
    if (isPrimitive) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    if (isModelContainerDefinition) {
      if (element.asType().getKind().isPrimitive() && !hasTypeConverter) {
        newFieldType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
      }
    }
    ModelUtils.writeContentValueStatement(javaWriter,isContentValues,columnCount.intValue(),columnName,columnName,newFieldType,columnFieldName,containerKeyName,isModelContainerDefinition,isModelContainer,false,hasTypeConverter,getType,isPrimitive,isBlob);
    columnCount.incrementAndGet();
  }
}","public void writeSaveDefinition(JavaWriter javaWriter,boolean isModelContainerDefinition,boolean isContentValues,AtomicInteger columnCount) throws IOException {
  if (columnType == Column.FOREIGN_KEY && isModel) {
    if (isModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    if (isModelContainerDefinition) {
      String modelContainerName=ModelUtils.getVariable(true) + columnFieldName;
      javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldName,columnFieldType);
      if (saveModelForeignKey) {
        javaWriter.emitStatement(""String_Node_Str"",modelContainerName);
      }
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
        AdapterQueryBuilder ifBuilder=new AdapterQueryBuilder().append(modelContainerName).append(""String_Node_Str"").appendGetValue(foreignKeyReference.foreignColumnName());
        javaWriter.beginControlFlow(""String_Node_Str"",ifBuilder.getQuery());
        if (!isContentValues) {
          adapterQueryBuilder.appendBindSQLiteStatement(columnCount.intValue(),ModelUtils.getClassFromAnnotation(foreignKeyReference));
        }
 else {
          adapterQueryBuilder.appendContentValues().appendPut(foreignKeyReference.columnName());
        }
        adapterQueryBuilder.appendCast(ModelUtils.getClassFromAnnotation(foreignKeyReference)).append(modelContainerName).append(""String_Node_Str"").appendGetValue(foreignKeyReference.foreignColumnName()).append(""String_Node_Str"");
        javaWriter.emitStatement(adapterQueryBuilder.getQuery());
        javaWriter.nextControlFlow(""String_Node_Str"");
        AdapterQueryBuilder elseNull=new AdapterQueryBuilder();
        if (isContentValues) {
          elseNull.appendContentValues();
          elseNull.append(""String_Node_Str"").appendParenthesisEnclosed(""String_Node_Str"" + foreignKeyReference.columnName() + ""String_Node_Str"");
        }
 else {
          elseNull.append(""String_Node_Str"");
          elseNull.append(""String_Node_Str"").appendParenthesisEnclosed(columnCount);
        }
        javaWriter.emitStatement(elseNull.getQuery());
        javaWriter.endControlFlow();
        columnCount.incrementAndGet();
      }
    }
 else {
      String modelStatement=ModelUtils.getModelStatement(columnFieldName);
      javaWriter.beginControlFlow(""String_Node_Str"",modelStatement);
      if (saveModelForeignKey) {
        javaWriter.emitStatement(""String_Node_Str"",modelStatement);
      }
      List<AdapterQueryBuilder> elseNullPuts=new ArrayList<>();
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        TypeMirror castedClass=ModelUtils.getTypeMirrorFromAnnotation(foreignKeyReference);
        ModelUtils.writeContentValueStatement(javaWriter,isContentValues,columnCount.intValue(),foreignKeyReference.columnName(),columnName,castedClass.toString(),foreignKeyReference.foreignColumnName(),foreignKeyReference.foreignColumnName(),false,isModelContainer,true,false,columnFieldType,castedClass.getKind().isPrimitive(),false);
        AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
        if (isContentValues) {
          adapterQueryBuilder.appendContentValues();
          adapterQueryBuilder.append(""String_Node_Str"").appendParenthesisEnclosed(""String_Node_Str"" + foreignKeyReference.columnName() + ""String_Node_Str"");
        }
 else {
          adapterQueryBuilder.append(""String_Node_Str"");
          adapterQueryBuilder.append(""String_Node_Str"").appendParenthesisEnclosed(columnCount);
        }
        elseNullPuts.add(adapterQueryBuilder);
        columnCount.incrementAndGet();
      }
      javaWriter.nextControlFlow(""String_Node_Str"");
      for (      AdapterQueryBuilder queryBuilder : elseNullPuts) {
        javaWriter.emitStatement(queryBuilder.getQuery());
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String newFieldType=null;
    if (hasTypeConverter) {
      TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(modelType);
      if (typeConverterDefinition == null) {
        manager.getMessager().printMessage(Diagnostic.Kind.ERROR,String.format(""String_Node_Str"",modelType));
      }
 else {
        newFieldType=typeConverterDefinition.getDbElement().asType().toString();
      }
    }
 else {
      newFieldType=columnFieldType;
    }
    String getType=columnFieldType;
    boolean isPrimitive=element.asType().getKind().isPrimitive();
    if (isPrimitive) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    if (isModelContainerDefinition) {
      if (element.asType().getKind().isPrimitive() && !hasTypeConverter) {
        newFieldType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
      }
    }
    ModelUtils.writeContentValueStatement(javaWriter,isContentValues,columnCount.intValue(),columnName,columnName,newFieldType,columnFieldName,containerKeyName,isModelContainerDefinition,isModelContainer,false,hasTypeConverter,getType,isPrimitive,isBlob);
    columnCount.incrementAndGet();
  }
}"
27061,"@Override public void write(JavaWriter javaWriter) throws IOException {
  AtomicInteger columnCounter=new AtomicInteger(1);
  for (int i=0; i < tableDefinition.getColumnDefinitions().size(); i++) {
    ColumnDefinition columnDefinition=tableDefinition.getColumnDefinitions().get(i);
    if (columnDefinition.columnType != Column.PRIMARY_KEY_AUTO_INCREMENT) {
      columnDefinition.writeSaveDefinition(javaWriter,isModelContainer,true,columnCounter);
    }
    if (implementsContentValuesListener) {
      javaWriter.emitStatement(""String_Node_Str"",args[3],args[1]);
    }
  }
  javaWriter.emitEmptyLine();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  AtomicInteger columnCounter=new AtomicInteger(1);
  for (int i=0; i < tableDefinition.getColumnDefinitions().size(); i++) {
    ColumnDefinition columnDefinition=tableDefinition.getColumnDefinitions().get(i);
    columnDefinition.writeSaveDefinition(javaWriter,isModelContainer,true,columnCounter);
    if (implementsContentValuesListener) {
      javaWriter.emitStatement(""String_Node_Str"",args[3],args[1]);
    }
  }
  javaWriter.emitEmptyLine();
}"
27062,"public void testModelAutoIncrement(){
  TestModelAI testModelAI=new TestModelAI();
  testModelAI.name=""String_Node_Str"";
  testModelAI.save(false);
  assertTrue(testModelAI.exists());
  testModelAI.delete(false);
  assertTrue(!testModelAI.exists());
}","public void testModelAutoIncrement(){
  TestModelAI testModelAI=new TestModelAI();
  testModelAI.name=""String_Node_Str"";
  testModelAI.insert(false);
  assertTrue(testModelAI.exists());
  TestModelAI testModelAI2=new TestModelAI();
  testModelAI2.id=testModelAI.id;
  testModelAI2.name=""String_Node_Str"";
  testModelAI2.update(false);
  TestModelAI testModelAI3=Select.byId(TestModelAI.class,testModelAI.id);
  assertEquals(testModelAI3.name,testModelAI2.name);
  testModelAI.delete(false);
  assertTrue(!testModelAI.exists());
}"
27063,"/** 
 * @return The autoincrement column name for the {@link com.raizlabs.android.dbflow.annotation.Column#PRIMARY_KEY_AUTO_INCREMENT}if it has the field. This method is overridden when its specified for the   {@link ModelClass}
 */
public String getAutoIncrementingColumnName(){
  return ""String_Node_Str"";
}","/** 
 * @return The autoincrement column name for the {@link com.raizlabs.android.dbflow.annotation.Column#PRIMARY_KEY_AUTO_INCREMENT}if it has the field. This method is overridden when its specified for the   {@link ModelClass}
 */
public String getAutoIncrementingColumnName(){
  throw new InvalidDBConfiguration(String.format(""String_Node_Str"" + ""String_Node_Str"",getModelClass()));
}"
27064,"/** 
 * @return The value for the {@link com.raizlabs.android.dbflow.annotation.Column#PRIMARY_KEY_AUTO_INCREMENT}if it has the field. This method is overridden when its specified for the   {@link ModelClass}
 */
@Override public long getAutoIncrementingId(ModelClass model){
  return 0;
}","/** 
 * @return The value for the {@link com.raizlabs.android.dbflow.annotation.Column#PRIMARY_KEY_AUTO_INCREMENT}if it has the field. This method is overridden when its specified for the   {@link ModelClass}
 */
@Override public long getAutoIncrementingId(ModelClass model){
  throw new InvalidDBConfiguration(String.format(""String_Node_Str"" + ""String_Node_Str"",getModelClass()));
}"
27065,"@SuppressWarnings(""String_Node_Str"") protected void addToCache(){
  long id=getModelAdapter().getCachingId(this);
  if (id == 0) {
    throw new InvalidDBConfiguration(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",getClass()));
  }
 else {
    mCache.addModel(id,this);
  }
}","@SuppressWarnings(""String_Node_Str"") protected void addToCache(){
  mCache.addModel(getModelAdapter().getCachingId(this),this);
}"
27066,"@Override @SuppressWarnings(""String_Node_Str"") public void delete(boolean async){
  long id=getModelAdapter().getAutoIncrementingId(this);
  super.delete(async);
  if (!async) {
    mCache.removeModel(id);
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public void delete(boolean async){
  long id=getModelAdapter().getCachingId(this);
  super.delete(async);
  if (!async) {
    mCache.removeModel(id);
  }
}"
27067,"public ContentProviderDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  setDefinitionClassName(DEFINITION_NAME);
  ContentProvider provider=element.getAnnotation(ContentProvider.class);
  databaseName=provider.databaseName();
  if (databaseName == null || databaseName.isEmpty()) {
    databaseName=DBFlowProcessor.DEFAULT_DB_NAME;
  }
  authority=provider.authority();
  TableEndpointValidator validator=new TableEndpointValidator();
  List<? extends Element> elements=manager.getElements().getAllMembers((TypeElement)typeElement);
  for (  Element innerElement : elements) {
    if (innerElement.getAnnotation(TableEndpoint.class) != null) {
      TableEndpointDefinition endpointDefinition=new TableEndpointDefinition(innerElement,manager);
      if (validator.validate(processorManager,endpointDefinition)) {
        endpointDefinitions.add(endpointDefinition);
      }
    }
  }
  mWriters=new FlowWriter[]{new QueryWriter(this),new InsertWriter(this),new DeleteWriter(this),new UpdateWriter(this)};
}","public ContentProviderDefinition(Element typeElement,ProcessorManager processorManager){
  super(typeElement,processorManager);
  setDefinitionClassName(DEFINITION_NAME);
  ContentProvider provider=element.getAnnotation(ContentProvider.class);
  databaseName=provider.databaseName();
  if (databaseName == null || databaseName.isEmpty()) {
    databaseName=DBFlowProcessor.DEFAULT_DB_NAME;
  }
  authority=provider.authority();
  TableEndpointValidator validator=new TableEndpointValidator();
  List<? extends Element> elements=manager.getElements().getAllMembers((TypeElement)typeElement);
  for (  Element innerElement : elements) {
    if (innerElement.getAnnotation(TableEndpoint.class) != null) {
      TableEndpointDefinition endpointDefinition=new TableEndpointDefinition(innerElement,manager);
      if (validator.validate(processorManager,endpointDefinition)) {
        endpointDefinitions.add(endpointDefinition);
      }
    }
  }
  mWriters=new FlowWriter[]{new QueryWriter(this,manager),new InsertWriter(this),new DeleteWriter(this,manager),new UpdateWriter(this,manager)};
}"
27068,"@Override protected void createColumnDefinitions(TypeElement element){
  List<? extends Element> variableElements=manager.getElements().getAllMembers(element);
  ColumnValidator columnValidator=new ColumnValidator();
  for (  Element variableElement : variableElements) {
    boolean isValidColumn=allFields && (variableElement.getKind().isField() && !variableElement.getModifiers().contains(Modifier.STATIC) && !variableElement.getModifiers().contains(Modifier.PRIVATE)&& !variableElement.getModifiers().contains(Modifier.FINAL));
    if (variableElement.getAnnotation(Column.class) != null || isValidColumn) {
      ColumnDefinition columnDefinition=new ColumnDefinition(manager,(VariableElement)variableElement);
      if (columnValidator.validate(manager,columnDefinition)) {
        columnDefinitions.add(columnDefinition);
        if (columnDefinition.columnType == Column.PRIMARY_KEY) {
          primaryColumnDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.FOREIGN_KEY) {
          foreignKeyDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.PRIMARY_KEY_AUTO_INCREMENT) {
          autoIncrementDefinition=columnDefinition;
          hasAutoIncrement=true;
        }
      }
    }
  }
}","@Override protected void createColumnDefinitions(TypeElement element){
  List<? extends Element> variableElements=manager.getElements().getAllMembers(element);
  ColumnValidator columnValidator=new ColumnValidator();
  for (  Element variableElement : variableElements) {
    boolean isValidColumn=allFields && (variableElement.getKind().isField() && !variableElement.getModifiers().contains(Modifier.STATIC) && !variableElement.getModifiers().contains(Modifier.PRIVATE)&& !variableElement.getModifiers().contains(Modifier.FINAL));
    if (variableElement.getAnnotation(Column.class) != null || isValidColumn) {
      ColumnDefinition columnDefinition=new ColumnDefinition(manager,(VariableElement)variableElement);
      if (columnValidator.validate(manager,columnDefinition)) {
        columnDefinitions.add(columnDefinition);
        mColumnMap.put(columnDefinition.columnName,columnDefinition);
        if (columnDefinition.columnType == Column.PRIMARY_KEY) {
          primaryColumnDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.FOREIGN_KEY) {
          foreignKeyDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.PRIMARY_KEY_AUTO_INCREMENT) {
          autoIncrementDefinition=columnDefinition;
          hasAutoIncrement=true;
        }
      }
    }
  }
}"
27069,"public TableDefinition getTableDefinition(String databaseName,TypeElement typeElement){
  return mTableDefinitions.get(databaseName).get(typeElement.getQualifiedName().toString());
}","public TableDefinition getTableDefinition(String databaseName,String tableName){
  return mTableNameDefinitionMap.get(databaseName).get(tableName);
}"
27070,"public void addTableDefinition(TableDefinition modelContainerDefinition){
  Map<String,TableDefinition> tableDefinitionMap=mTableDefinitions.get(modelContainerDefinition.databaseName);
  if (tableDefinitionMap == null) {
    tableDefinitionMap=Maps.newHashMap();
    mTableDefinitions.put(modelContainerDefinition.databaseName,tableDefinitionMap);
  }
  tableDefinitionMap.put(modelContainerDefinition.element.asType().toString(),modelContainerDefinition);
}","public void addTableDefinition(TableDefinition tableDefinition){
  Map<String,TableDefinition> tableDefinitionMap=mTableDefinitions.get(tableDefinition.databaseName);
  if (tableDefinitionMap == null) {
    tableDefinitionMap=Maps.newHashMap();
    mTableDefinitions.put(tableDefinition.databaseName,tableDefinitionMap);
  }
  Map<String,TableDefinition> tableNameMap=mTableNameDefinitionMap.get(tableDefinition.databaseName);
  if (tableNameMap == null) {
    tableNameMap=Maps.newHashMap();
    mTableNameDefinitionMap.put(tableDefinition.databaseName,tableNameMap);
  }
  tableDefinitionMap.put(tableDefinition.element.asType().toString(),tableDefinition);
  tableNameMap.put(tableDefinition.tableName,tableDefinition);
}"
27071,"public SqlQueryBuilder appendPathSegments(ContentUri.PathSegment[] pathSegments){
  for (  ContentUri.PathSegment pathSegment : pathSegments) {
    append(String.format(""String_Node_Str"",pathSegment.column(),pathSegment.segment()));
  }
  return this;
}","public SqlQueryBuilder appendPathSegments(ProcessorManager processorManager,String databaseName,String tableName,ContentUri.PathSegment[] pathSegments){
  TableDefinition tableDefinition=processorManager.getTableDefinition(databaseName,tableName);
  if (tableDefinition == null) {
    processorManager.logError(""String_Node_Str"",tableName,databaseName);
  }
  for (  ContentUri.PathSegment pathSegment : pathSegments) {
    ColumnDefinition columnDefinition=tableDefinition.mColumnMap.get(pathSegment.column());
    if (columnDefinition == null) {
      processorManager.logError(""String_Node_Str"",pathSegment.column(),tableDefinition.tableName);
    }
 else {
      append(String.format(""String_Node_Str"",pathSegment.column()));
      if (columnDefinition.element.asType().getKind().isPrimitive()) {
        String name=columnDefinition.element.asType().toString();
        name=name.substring(0,1).toUpperCase() + name.substring(1);
        append(String.format(""String_Node_Str"",name,pathSegment.segment()));
      }
 else {
        append(String.format(""String_Node_Str"",pathSegment.segment()));
      }
    }
  }
  return this;
}"
27072,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.beginControlFlow(""String_Node_Str"");
  for (  TableEndpointDefinition tableEndpointDefinition : contentProviderDefinition.endpointDefinitions) {
    for (    ContentUriDefinition uriDefinition : tableEndpointDefinition.contentUriDefinitions) {
      if (uriDefinition.deleteEnabled) {
        javaWriter.beginControlFlow(""String_Node_Str"",uriDefinition.name);
        SqlQueryBuilder queryBuilder=new SqlQueryBuilder(""String_Node_Str"").appendDelete().appendFromTable(contentProviderDefinition.databaseName,tableEndpointDefinition.tableName).appendWhere().appendPathSegments(uriDefinition.segments).appendCount();
        javaWriter.emitStatement(queryBuilder.getQuery());
        new NotifyWriter(tableEndpointDefinition,uriDefinition,Notify.Method.DELETE).write(javaWriter);
        javaWriter.emitStatement(""String_Node_Str"");
        javaWriter.endControlFlow();
      }
    }
  }
  javaWriter.beginControlFlow(""String_Node_Str"").emitStatement(""String_Node_Str"").endControlFlow();
  javaWriter.endControlFlow();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.beginControlFlow(""String_Node_Str"");
  for (  TableEndpointDefinition tableEndpointDefinition : contentProviderDefinition.endpointDefinitions) {
    for (    ContentUriDefinition uriDefinition : tableEndpointDefinition.contentUriDefinitions) {
      if (uriDefinition.deleteEnabled) {
        javaWriter.beginControlFlow(""String_Node_Str"",uriDefinition.name);
        SqlQueryBuilder queryBuilder=new SqlQueryBuilder(""String_Node_Str"").appendDelete().appendFromTable(contentProviderDefinition.databaseName,tableEndpointDefinition.tableName).appendWhere().appendPathSegments(manager,contentProviderDefinition.databaseName,tableEndpointDefinition.tableName,uriDefinition.segments).appendCount();
        javaWriter.emitStatement(queryBuilder.getQuery());
        new NotifyWriter(tableEndpointDefinition,uriDefinition,Notify.Method.DELETE).write(javaWriter);
        javaWriter.emitStatement(""String_Node_Str"");
        javaWriter.endControlFlow();
      }
    }
  }
  javaWriter.beginControlFlow(""String_Node_Str"").emitStatement(""String_Node_Str"").endControlFlow();
  javaWriter.endControlFlow();
}"
27073,"public DeleteWriter(ContentProviderDefinition contentProviderDefinition){
  this.contentProviderDefinition=contentProviderDefinition;
}","public DeleteWriter(ContentProviderDefinition contentProviderDefinition,ProcessorManager manager){
  this.contentProviderDefinition=contentProviderDefinition;
  this.manager=manager;
}"
27074,"public QueryWriter(ContentProviderDefinition contentProviderDefinition){
  this.contentProviderDefinition=contentProviderDefinition;
}","public QueryWriter(ContentProviderDefinition contentProviderDefinition,ProcessorManager manager){
  this.contentProviderDefinition=contentProviderDefinition;
  this.manager=manager;
}"
27075,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitStatement(""String_Node_Str"");
  javaWriter.beginControlFlow(""String_Node_Str"",ContentProviderDefinition.URI_MATCHER);
  for (  TableEndpointDefinition tableEndpointDefinition : contentProviderDefinition.endpointDefinitions) {
    for (    ContentUriDefinition uriDefinition : tableEndpointDefinition.contentUriDefinitions) {
      if (uriDefinition.queryEnabled) {
        javaWriter.beginControlFlow(""String_Node_Str"",uriDefinition.name);
        SqlQueryBuilder select=new SqlQueryBuilder(""String_Node_Str"").appendSelect().appendFromTable(contentProviderDefinition.databaseName,tableEndpointDefinition.tableName).appendWhere().appendPathSegments(uriDefinition.segments).appendQuery();
        javaWriter.emitStatement(select.getQuery());
        javaWriter.emitStatement(""String_Node_Str"");
        javaWriter.endControlFlow();
      }
    }
  }
  javaWriter.endControlFlow();
  javaWriter.beginControlFlow(""String_Node_Str"");
  javaWriter.emitStatement(""String_Node_Str"");
  javaWriter.endControlFlow();
  javaWriter.emitEmptyLine();
  javaWriter.emitStatement(""String_Node_Str"");
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitStatement(""String_Node_Str"");
  javaWriter.beginControlFlow(""String_Node_Str"",ContentProviderDefinition.URI_MATCHER);
  for (  TableEndpointDefinition tableEndpointDefinition : contentProviderDefinition.endpointDefinitions) {
    for (    ContentUriDefinition uriDefinition : tableEndpointDefinition.contentUriDefinitions) {
      if (uriDefinition.queryEnabled) {
        javaWriter.beginControlFlow(""String_Node_Str"",uriDefinition.name);
        SqlQueryBuilder select=new SqlQueryBuilder(""String_Node_Str"").appendSelect().appendFromTable(contentProviderDefinition.databaseName,tableEndpointDefinition.tableName).appendWhere().appendPathSegments(manager,contentProviderDefinition.databaseName,tableEndpointDefinition.tableName,uriDefinition.segments).appendQuery();
        javaWriter.emitStatement(select.getQuery());
        javaWriter.emitStatement(""String_Node_Str"");
        javaWriter.endControlFlow();
      }
    }
  }
  javaWriter.endControlFlow();
  javaWriter.beginControlFlow(""String_Node_Str"");
  javaWriter.emitStatement(""String_Node_Str"");
  javaWriter.endControlFlow();
  javaWriter.emitEmptyLine();
  javaWriter.emitStatement(""String_Node_Str"");
}"
27076,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.beginControlFlow(""String_Node_Str"");
  for (  TableEndpointDefinition tableEndpointDefinition : contentProviderDefinition.endpointDefinitions) {
    for (    ContentUriDefinition uriDefinition : tableEndpointDefinition.contentUriDefinitions) {
      if (uriDefinition.updateEnabled) {
        javaWriter.beginControlFlow(""String_Node_Str"",uriDefinition.name);
        javaWriter.emitStatement(""String_Node_Str"",contentProviderDefinition.databaseName,tableEndpointDefinition.tableName);
        SqlQueryBuilder sqlQueryBuilder=new SqlQueryBuilder(""String_Node_Str"").appendUpdate().appendUpdateConflictAction().appendTable(contentProviderDefinition.databaseName,tableEndpointDefinition.tableName).appendSet().appendWhere().appendPathSegments(uriDefinition.segments).appendCount();
        javaWriter.emitStatement(sqlQueryBuilder.getQuery());
        new NotifyWriter(tableEndpointDefinition,uriDefinition,Notify.Method.UPDATE).write(javaWriter);
        javaWriter.emitStatement(""String_Node_Str"");
        javaWriter.endControlFlow();
      }
    }
  }
  javaWriter.beginControlFlow(""String_Node_Str"").emitStatement(""String_Node_Str"").endControlFlow();
  javaWriter.endControlFlow();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.beginControlFlow(""String_Node_Str"");
  for (  TableEndpointDefinition tableEndpointDefinition : contentProviderDefinition.endpointDefinitions) {
    for (    ContentUriDefinition uriDefinition : tableEndpointDefinition.contentUriDefinitions) {
      if (uriDefinition.updateEnabled) {
        javaWriter.beginControlFlow(""String_Node_Str"",uriDefinition.name);
        javaWriter.emitStatement(""String_Node_Str"",contentProviderDefinition.databaseName,tableEndpointDefinition.tableName);
        SqlQueryBuilder sqlQueryBuilder=new SqlQueryBuilder(""String_Node_Str"").appendUpdate().appendUpdateConflictAction().appendTable(contentProviderDefinition.databaseName,tableEndpointDefinition.tableName).appendSet().appendWhere().appendPathSegments(manager,contentProviderDefinition.databaseName,tableEndpointDefinition.tableName,uriDefinition.segments).appendCount();
        javaWriter.emitStatement(sqlQueryBuilder.getQuery());
        new NotifyWriter(tableEndpointDefinition,uriDefinition,Notify.Method.UPDATE).write(javaWriter);
        javaWriter.emitStatement(""String_Node_Str"");
        javaWriter.endControlFlow();
      }
    }
  }
  javaWriter.beginControlFlow(""String_Node_Str"").emitStatement(""String_Node_Str"").endControlFlow();
  javaWriter.endControlFlow();
}"
27077,"public UpdateWriter(ContentProviderDefinition contentProviderDefinition){
  this.contentProviderDefinition=contentProviderDefinition;
}","public UpdateWriter(ContentProviderDefinition contentProviderDefinition,ProcessorManager manager){
  this.contentProviderDefinition=contentProviderDefinition;
  this.manager=manager;
}"
27078,"@ContentUri(path=ENDPOINT + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",type=ContentUri.ContentType.VND_SINGLE + ContentProviderModel.ENDPOINT,segments={@ContentUri.PathSegment(column=""String_Node_Str"",segment=1)}) public static Uri fromList(long id){
  return buildUri(ENDPOINT,""String_Node_Str"",String.valueOf(id));
}","@ContentUri(path=ENDPOINT + ""String_Node_Str"",type=ContentUri.ContentType.VND_SINGLE + ContentProviderModel.ENDPOINT,segments={@ContentUri.PathSegment(column=""String_Node_Str"",segment=2)}) public static Uri fromList(long id){
  return buildUri(ENDPOINT,""String_Node_Str"",String.valueOf(id));
}"
27079,"public void testUpdateStatement(){
  Update update=new Update();
  assertUpdateSuffix(""String_Node_Str"",update.orRollback());
  assertUpdateSuffix(""String_Node_Str"",update.orAbort());
  assertUpdateSuffix(""String_Node_Str"",update.orReplace());
  assertUpdateSuffix(""String_Node_Str"",update.orFail());
  assertUpdateSuffix(""String_Node_Str"",update.orIgnore());
  From<TestModel1> from=new Update().table(TestModel1.class);
  assertEquals(""String_Node_Str"",from.getQuery().trim());
  Where<TestModel1> where=from.set(Condition.column(""String_Node_Str"").is(""String_Node_Str"")).where(Condition.column(""String_Node_Str"").is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where.getQuery().trim());
  where.query();
  String query=new Update().table(BoxedModel.class).set(Condition.columnRaw(BoxedModel$Table.RBLNUMBER).is(BoxedModel$Table.RBLNUMBER + ""String_Node_Str"")).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
  query=new Update().table(BoxedModel.class).set(Condition.column(BoxedModel$Table.RBLNUMBER).concatenateToColumn(1)).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
  query=new Update().table(BoxedModel.class).set(Condition.column(BoxedModel$Table.NAME).concatenateToColumn(""String_Node_Str"")).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
}","public void testUpdateStatement(){
  Update update=new Update();
  assertUpdateSuffix(""String_Node_Str"",update.orRollback());
  assertUpdateSuffix(""String_Node_Str"",update.orAbort());
  assertUpdateSuffix(""String_Node_Str"",update.orReplace());
  assertUpdateSuffix(""String_Node_Str"",update.orFail());
  assertUpdateSuffix(""String_Node_Str"",update.orIgnore());
  From<TestModel1> from=new Update().table(TestModel1.class);
  assertEquals(""String_Node_Str"",from.getQuery().trim());
  Where<TestModel1> where=from.set(Condition.column(""String_Node_Str"").is(""String_Node_Str"")).where(Condition.column(""String_Node_Str"").is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where.getQuery().trim());
  where.query();
  String query=new Update().table(BoxedModel.class).set(Condition.columnRaw(BoxedModel$Table.RBLNUMBER).is(BoxedModel$Table.RBLNUMBER + ""String_Node_Str"")).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
  query=new Update().table(BoxedModel.class).set(Condition.column(BoxedModel$Table.RBLNUMBER).concatenateToColumn(1)).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
  query=new Update().table(BoxedModel.class).set(Condition.column(BoxedModel$Table.NAME).concatenateToColumn(""String_Node_Str"")).getQuery();
  assertEquals(""String_Node_Str"",query.trim());
  Uri uri=TestContentProvider.NoteModel.fromList(1);
  ContentValues contentValues=new ContentValues();
  contentValues.put(NoteModel$Table.NOTE,""String_Node_Str"");
  contentValues.put(NoteModel$Table.ID,1);
  contentValues.put(NoteModel$Table.CONTENTPROVIDERMODEL_PROVIDERMODEL,1);
  query=new Update().conflictAction(ConflictAction.ABORT).table(FlowManager.getTableClassForName(""String_Node_Str"",""String_Node_Str"")).set().conditionValues(contentValues).where(""String_Node_Str"",""String_Node_Str"").and(Condition.column(""String_Node_Str"").is(uri.getPathSegments().get(2))).getQuery();
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",query.trim());
}"
27080,"public void testSelectStatement(){
  Where<TestModel1> where=new Select(""String_Node_Str"").from(TestModel1.class).where(Condition.column(""String_Node_Str"").is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where.getQuery().trim());
  where.query();
  Where<TestModel3> where1=new Select(""String_Node_Str"",""String_Node_Str"").from(TestModel3.class).where(Condition.column(""String_Node_Str"").is(""String_Node_Str""),Condition.column(""String_Node_Str"").is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where1.getQuery().trim());
  Where<TestModel3> where2=new Select().distinct().from(TestModel3.class).where();
  assertEquals(""String_Node_Str"",where2.getQuery().trim());
  where2.query();
  Where<TestModel3> where3=new Select().count().from(TestModel3.class).where();
  assertEquals(""String_Node_Str"",where3.getQuery().trim());
  where3.query();
}","public void testSelectStatement(){
  Where<TestModel1> where=new Select(""String_Node_Str"").from(TestModel1.class).where(Condition.column(""String_Node_Str"").is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where.getQuery().trim());
  where.query();
  Where<TestModel3> where1=new Select(""String_Node_Str"",""String_Node_Str"").from(TestModel3.class).where(Condition.column(""String_Node_Str"").is(""String_Node_Str""),Condition.column(""String_Node_Str"").is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where1.getQuery().trim());
  Where<TestModel3> where2=new Select().distinct().from(TestModel3.class).where();
  assertEquals(""String_Node_Str"",where2.getQuery().trim());
  where2.query();
  Where<TestModel3> where3=new Select().count().from(TestModel3.class).where();
  assertEquals(""String_Node_Str"",where3.getQuery().trim());
  where3.query();
  Where<TestModel3> where4=new Select().from(TestModel3.class).where(""String_Node_Str"",""String_Node_Str"").and(Condition.column(TestModel3$Table.TYPE).is(""String_Node_Str""));
  assertEquals(""String_Node_Str"",where4.getQuery().trim());
}"
27081,"/** 
 * Sets the last condition to use the separator specified
 * @param separator AND, OR, etc.
 */
protected void setPreviousSeparator(String separator){
  if (mParams.size() > 0) {
    mParams.get(mParams.size() - 1).separator(separator);
  }
}","/** 
 * Sets the last condition to use the separator specified
 * @param separator AND, OR, etc.
 */
protected void setPreviousSeparator(String separator){
  if (mParams.size() > 0) {
    mParams.get(mParams.size() - 1).separator(separator);
  }
 else   if (mWhereRaw != null && mWhereRaw.length() > 0) {
    mWhereRaw=new QueryBuilder<>(mWhereRaw).appendSpaceSeparated(separator).getQuery();
  }
}"
27082,"/** 
 * Adds a param to the WHERE clause with the custom   {@link com.raizlabs.android.dbflow.sql.builder.Condition}
 * @param condition The {@link com.raizlabs.android.dbflow.sql.builder.Condition} to use
 * @return
 */
public Where<ModelClass> and(Condition condition){
  mConditionQueryBuilder.putCondition(condition);
  return this;
}","/** 
 * Adds a param to the WHERE clause with the custom   {@link com.raizlabs.android.dbflow.sql.builder.Condition}
 * @param condition The {@link com.raizlabs.android.dbflow.sql.builder.Condition} to use
 * @return
 */
public Where<ModelClass> and(Condition condition){
  mConditionQueryBuilder.and(condition);
  return this;
}"
27083,"/** 
 * Specifies a set of content values to append to this SET as Conditions
 * @param contentValues The set of values to append.
 * @return This instance.
 */
public Set<ModelClass> conditionValues(ContentValues contentValues){
  java.util.Set<String> contentKeys=contentValues.keySet();
  for (  String key : contentKeys) {
    mConditionQueryBuilder.putCondition(Condition.columnRaw(key).is(contentValues.get(key)));
  }
  return this;
}","/** 
 * Specifies a set of content values to append to this SET as Conditions
 * @param contentValues The set of values to append.
 * @return This instance.
 */
public Set<ModelClass> conditionValues(ContentValues contentValues){
  java.util.Set<String> contentKeys=contentValues.keySet();
  for (  String key : contentKeys) {
    mConditionQueryBuilder.putCondition(Condition.column(key).is(contentValues.get(key)));
  }
  return this;
}"
27084,"protected ModelAdapter getModelAdapter(){
  return mModelAdapter;
}","public ModelAdapter getModelAdapter(){
  return mModelAdapter;
}"
27085,"@Override @SuppressWarnings(""String_Node_Str"") public void load(ConditionQueryBuilder<TableClass> whereConditions,String orderBy,String... columns){
  Cursor cursor=ContentUtils.query(FlowManager.getContext().getContentResolver(),getQueryUri(),(Class<TableClass>)getClass(),whereConditions,orderBy,columns);
  getModelAdapter().loadFromCursor(cursor,this);
}","@Override @SuppressWarnings(""String_Node_Str"") public void load(){
  load(getModelAdapter().getPrimaryModelWhere(this),""String_Node_Str"");
}"
27086,"@Override @SuppressWarnings(""String_Node_Str"") public void load(ConditionQueryBuilder<TableClass> whereConditions,String orderBy,String... columns){
  Cursor cursor=ContentUtils.query(FlowManager.getContext().getContentResolver(),getQueryUri(),(Class<TableClass>)getClass(),whereConditions,orderBy,columns);
  getModelAdapter().loadFromCursor(cursor,this);
}","@Override @SuppressWarnings(""String_Node_Str"") public void load(){
  load(getModelAdapter().getPrimaryModelWhere(this),""String_Node_Str"");
}"
27087,"/** 
 * Queries the   {@link android.content.ContentResolver} of the app based on the passed parameters andpopulates this object with the first row from the returned data.
 * @param whereConditions The set of {@link com.raizlabs.android.dbflow.sql.builder.Condition} to filter the query by.
 * @param orderBy         The order by without the ORDER BY
 * @param columns         The list of columns to select. Leave blank for 
 */
public void load(ConditionQueryBuilder<TableClass> whereConditions,String orderBy,String... columns);","/** 
 * Queries the   {@link android.content.ContentResolver} of the app based on the primary keys of the object and populatesthis object with the first row from the returned data.
 */
public void load();"
27088,"/** 
 * Replaces a query string with the specified params as part of this query. Note: appending any extra condition will invalidate this statement.
 * @param selection     The string query to select with ? bindings
 * @param selectionArgs The arguments that correspond to it. Will be type-converted into proper string values.
 * @return This builder.
 */
public ConditionQueryBuilder<ModelClass> append(String selection,Object... selectionArgs){
  String toAppend=selection;
  if (selection != null && selectionArgs != null) {
    for (    Object o : selectionArgs) {
      toAppend=toAppend.replaceFirst(""String_Node_Str"",convertValueToString(o));
    }
  }
  mWhereRaw=toAppend;
  return super.append(toAppend);
}","/** 
 * Replaces a query string with the specified params as part of this query. Note: appending any extra condition will invalidate this statement.
 * @param selection     The string query to select with ? bindings
 * @param selectionArgs The arguments that correspond to it. Will be type-converted into proper string values.
 * @return This builder.
 */
public ConditionQueryBuilder<ModelClass> append(String selection,Object... selectionArgs){
  if (selection != null) {
    String toAppend=selection;
    if (selectionArgs != null) {
      for (      Object o : selectionArgs) {
        toAppend=toAppend.replaceFirst(""String_Node_Str"",convertValueToString(o));
      }
    }
    mWhereRaw=toAppend;
    return super.append(toAppend);
  }
 else {
    return this;
  }
}"
27089,"/** 
 * Executes a SQL statement that retrieves the count of results in the DB.
 * @return The number of rows this query returns
 */
public long count(){
  long count;
  if (mWhereBase.getQueryBuilderBase() instanceof Update || mWhereBase.getQueryBuilderBase() instanceof Delete) {
    SQLiteStatement sqLiteStatement=mManager.getWritableDatabase().compileStatement(getQuery());
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      count=sqLiteStatement.executeUpdateDelete();
    }
 else {
      count=sqLiteStatement.executeUpdateDelete();
    }
  }
 else {
    count=DatabaseUtils.longForQuery(mManager.getWritableDatabase(),getQuery(),null);
  }
  return count;
}","/** 
 * Executes a SQL statement that retrieves the count of results in the DB.
 * @return The number of rows this query returns
 */
public long count(){
  long count;
  if (((mWhereBase.getQueryBuilderBase() instanceof From) && (((From)mWhereBase.getQueryBuilderBase()).getQueryBuilderBase()) instanceof Update) || mWhereBase.getQueryBuilderBase() instanceof Delete) {
    SQLiteStatement sqLiteStatement=mManager.getWritableDatabase().compileStatement(getQuery());
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
      count=sqLiteStatement.executeUpdateDelete();
    }
 else {
      count=sqLiteStatement.executeUpdateDelete();
    }
  }
 else {
    count=DatabaseUtils.longForQuery(mManager.getWritableDatabase(),getQuery(),null);
  }
  return count;
}"
27090,"@Override public void update(boolean async){
  ContentUtils.update(getUpdateUri(),this);
}","@Override public void update(boolean async){
  int count=ContentUtils.update(getUpdateUri(),this);
  if (count == 0) {
    FlowLog.log(FlowLog.Level.W,""String_Node_Str"" + getClass());
  }
}"
27091,"/** 
 * Updates the model through the   {@link android.content.ContentResolver}. Uses the updateUri to resolve the reference and the model to convert its data in   {@link android.content.ContentValues}
 * @param contentResolver The content resolver to use (if different from {@link com.raizlabs.android.dbflow.config.FlowManager#getContext()})
 * @param updateUri       A {@link android.net.Uri} from the {@link com.raizlabs.android.dbflow.annotation.provider.ContentProvider}
 * @param model           The model to update
 * @param < TableClass >    The class that implements {@link com.raizlabs.android.dbflow.structure.Model}
 * @return The number of rows updated.
 */
@SuppressWarnings(""String_Node_Str"") public static <TableClass extends Model>int update(ContentResolver contentResolver,Uri updateUri,TableClass model){
  ModelAdapter<TableClass> adapter=(ModelAdapter<TableClass>)FlowManager.getModelAdapter(model.getClass());
  checkModel(model,adapter);
  ContentValues contentValues=new ContentValues();
  adapter.bindToContentValues(contentValues,model);
  return contentResolver.update(updateUri,contentValues,null,null);
}","/** 
 * Updates the model through the   {@link android.content.ContentResolver}. Uses the updateUri to resolve the reference and the model to convert its data in   {@link android.content.ContentValues}
 * @param contentResolver The content resolver to use (if different from {@link com.raizlabs.android.dbflow.config.FlowManager#getContext()})
 * @param updateUri       A {@link android.net.Uri} from the {@link com.raizlabs.android.dbflow.annotation.provider.ContentProvider}
 * @param model           The model to update
 * @param < TableClass >    The class that implements {@link com.raizlabs.android.dbflow.structure.Model}
 * @return The number of rows updated.
 */
@SuppressWarnings(""String_Node_Str"") public static <TableClass extends Model>int update(ContentResolver contentResolver,Uri updateUri,TableClass model){
  ModelAdapter<TableClass> adapter=(ModelAdapter<TableClass>)FlowManager.getModelAdapter(model.getClass());
  checkModel(model,adapter);
  ContentValues contentValues=new ContentValues();
  adapter.bindToContentValues(contentValues,model);
  return contentResolver.update(updateUri,contentValues,adapter.getPrimaryModelWhere(model).getQuery(),null);
}"
27092,"@Override public Long getDBValue(Calendar model){
  return model.getTimeInMillis();
}","@Override public Long getDBValue(Calendar model){
  return model == null ? null : model.getTimeInMillis();
}"
27093,"@Override public Calendar getModelValue(Long data){
  Calendar calendar=Calendar.getInstance();
  calendar.setTimeInMillis(data);
  return calendar;
}","@Override public Calendar getModelValue(Long data){
  if (data != null) {
    Calendar calendar=Calendar.getInstance();
    calendar.setTimeInMillis(data);
    return calendar;
  }
 else {
    return null;
  }
}"
27094,"@Override public Long getDBValue(Date model){
  return model.getTime();
}","@Override public Long getDBValue(Date model){
  return model == null ? null : model.getTime();
}"
27095,"@Override public Date getModelValue(Long data){
  return new Date(data);
}","@Override public Date getModelValue(Long data){
  return data == null ? null : new Date(data);
}"
27096,"@Override public Long getDBValue(Date model){
  return model.getTime();
}","@Override public Long getDBValue(Date model){
  return model == null ? null : model.getTime();
}"
27097,"@Override public Date getModelValue(Long data){
  return new Date(data);
}","@Override public Date getModelValue(Long data){
  return data == null ? null : new Date(data);
}"
27098,"@Override @SuppressWarnings(""String_Node_Str"") public String getQuery(){
  return new QueryBuilder(""String_Node_Str"").append(isUnique ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").appendQuoted(mIndex).append(""String_Node_Str"").appendQuoted(FlowManager.getTableName(mTable)).append(""String_Node_Str"").appendList(mColumns).append(""String_Node_Str"").getQuery();
}","@Override @SuppressWarnings(""String_Node_Str"") public String getQuery(){
  return new QueryBuilder(""String_Node_Str"").append(isUnique ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").appendQuoted(mIndex).append(""String_Node_Str"").appendQuoted(FlowManager.getTableName(mTable)).append(""String_Node_Str"").appendQuotedList(mColumns).append(""String_Node_Str"").getQuery();
}"
27099,"/** 
 * Adds a column to the underlying INDEX
 * @param columnName The name of the column to add to the Index
 * @return This migration
 */
public IndexMigration<ModelClass> addColumn(String columnName){
  mIndex.and(columnName);
  return this;
}","/** 
 * Adds a column to the underlying INDEX
 * @param columnName The name of the column to add to the Index
 * @return This migration
 */
public IndexMigration<ModelClass> addColumn(String columnName){
  getIndex().and(columnName);
  return this;
}"
27100,"/** 
 * @return The index object based on the contents of this migration.
 */
public Index<ModelClass> getIndex(){
  return mIndex;
}","/** 
 * @return The index object based on the contents of this migration.
 */
public Index<ModelClass> getIndex(){
  if (mIndex == null) {
    mIndex=new Index<ModelClass>(mName).on(mOnTable);
  }
  return mIndex;
}"
27101,"/** 
 * Sets the INDEX to UNIQUE
 * @return This migration.
 */
public IndexMigration<ModelClass> unique(){
  mIndex.unique(true);
  return this;
}","/** 
 * Sets the INDEX to UNIQUE
 * @return This migration.
 */
public IndexMigration<ModelClass> unique(){
  getIndex().unique(true);
  return this;
}"
27102,"@Override public void onPreMigrate(){
  super.onPreMigrate();
  mIndex=new Index<ModelClass>(mName).on(mOnTable);
}","@Override public void onPreMigrate(){
  super.onPreMigrate();
  mIndex=getIndex();
}"
27103,"@Override public void write(JavaWriter javaWriter) throws IOException {
  ColumnDefinition columnDefinition=((TableDefinition)tableDefinition).autoIncrementDefinition;
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().append(ModelUtils.getVariable(isModelContainerDefinition));
  if (!isModelContainerDefinition) {
    queryBuilder.append(""String_Node_Str"").append(columnDefinition.columnFieldName).append(""String_Node_Str"").appendCast(columnDefinition.columnFieldType).append(params[3]).append(""String_Node_Str"");
  }
 else {
    queryBuilder.appendPut(columnDefinition.columnFieldName).append(params[3]).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.getQuery());
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  ColumnDefinition columnDefinition=((TableDefinition)tableDefinition).autoIncrementDefinition;
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().append(ModelUtils.getVariable(isModelContainerDefinition));
  if (!isModelContainerDefinition) {
    queryBuilder.append(""String_Node_Str"").append(columnDefinition.columnFieldName).append(""String_Node_Str"").appendCast(columnDefinition.columnFieldType).append(params[3]).append(""String_Node_Str"");
  }
 else {
    String containerKeyName=columnDefinition.columnFieldName;
    if (columnDefinition.containerKeyName != null) {
      containerKeyName=columnDefinition.containerKeyName;
    }
    queryBuilder.appendPut(containerKeyName).append(params[3]).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(queryBuilder.getQuery());
}"
27104,"public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(packageName + ""String_Node_Str"" + adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.MODEL_ADAPTER,Classes.FLOW_MANAGER,Classes.CONDITION_QUERY_BUILDER,Classes.CURSOR,Classes.CONTENT_VALUES,Classes.SQL_UTILS,Classes.SELECT,Classes.CONDITION);
  javaWriter.emitSingleLineComment(""String_Node_Str"",databaseName);
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,getModelClassName());
  InternalAdapterHelper.writeGetTableName(javaWriter,getSourceFileName());
  WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      String insertConflictName=insertConflictActionName;
      if (!insertConflictName.isEmpty()) {
        insertConflictName=String.format(""String_Node_Str"",insertConflictName);
      }
      QueryBuilder stringBuilder=new QueryBuilder(""String_Node_Str"");
      List<String> columnNames=new ArrayList<String>();
      List<String> bindings=new ArrayList<String>();
      for (int i=0; i < getColumnDefinitions().size(); i++) {
        ColumnDefinition columnDefinition=getColumnDefinitions().get(i);
        if (columnDefinition.columnType == Column.FOREIGN_KEY) {
          for (          ForeignKeyReference reference : columnDefinition.foreignKeyReferences) {
            columnNames.add(reference.columnName());
            bindings.add(""String_Node_Str"");
          }
        }
 else         if (columnDefinition.columnType != Column.PRIMARY_KEY_AUTO_INCREMENT) {
          columnNames.add(columnDefinition.columnName.toUpperCase());
          bindings.add(""String_Node_Str"");
        }
      }
      stringBuilder.appendList(columnNames).append(""String_Node_Str"");
      stringBuilder.appendList(bindings).append(""String_Node_Str"");
      javaWriter.emitStatement(stringBuilder.toString(),insertConflictName,tableName);
    }
  }
,""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PROTECTED,Modifier.FINAL));
  for (  FlowWriter writer : mMethodWriters) {
    writer.write(javaWriter);
  }
  WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      javaWriter.emitStatement(""String_Node_Str"",getQualifiedModelClassName());
    }
  }
,getQualifiedModelClassName(),""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  if (!updateConflicationActionName.isEmpty()) {
    WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
      @Override public void write(      JavaWriter javaWriter) throws IOException {
        javaWriter.emitStatement(""String_Node_Str"",Classes.CONFLICT_ACTION,updateConflicationActionName);
      }
    }
,Classes.CONFLICT_ACTION,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  }
  if (!insertConflictActionName.isEmpty()) {
    WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
      @Override public void write(      JavaWriter javaWriter) throws IOException {
        javaWriter.emitStatement(""String_Node_Str"",Classes.CONFLICT_ACTION,insertConflictActionName);
      }
    }
,Classes.CONFLICT_ACTION,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  }
  javaWriter.endType();
  javaWriter.close();
}","public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(packageName + ""String_Node_Str"" + adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.MODEL_ADAPTER,Classes.FLOW_MANAGER,Classes.CONDITION_QUERY_BUILDER,Classes.CURSOR,Classes.CONTENT_VALUES,Classes.SQL_UTILS,Classes.SELECT,Classes.CONDITION);
  javaWriter.emitSingleLineComment(""String_Node_Str"",databaseName);
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,getModelClassName());
  InternalAdapterHelper.writeGetTableName(javaWriter,getSourceFileName());
  WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      String insertConflictName=insertConflictActionName;
      if (!insertConflictName.isEmpty()) {
        insertConflictName=String.format(""String_Node_Str"",insertConflictName);
      }
      QueryBuilder stringBuilder=new QueryBuilder(""String_Node_Str"");
      List<String> columnNames=new ArrayList<String>();
      List<String> bindings=new ArrayList<String>();
      for (int i=0; i < getColumnDefinitions().size(); i++) {
        ColumnDefinition columnDefinition=getColumnDefinitions().get(i);
        if (columnDefinition.columnType == Column.FOREIGN_KEY) {
          for (          ForeignKeyReference reference : columnDefinition.foreignKeyReferences) {
            columnNames.add(QueryBuilder.quote(reference.columnName()));
            bindings.add(""String_Node_Str"");
          }
        }
 else         if (columnDefinition.columnType != Column.PRIMARY_KEY_AUTO_INCREMENT) {
          columnNames.add(QueryBuilder.quote(columnDefinition.columnName.toUpperCase()));
          bindings.add(""String_Node_Str"");
        }
      }
      stringBuilder.appendList(columnNames).append(""String_Node_Str"");
      stringBuilder.appendList(bindings).append(""String_Node_Str"");
      javaWriter.emitStatement(stringBuilder.toString(),insertConflictName,QueryBuilder.quote(tableName));
    }
  }
,""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PROTECTED,Modifier.FINAL));
  for (  FlowWriter writer : mMethodWriters) {
    writer.write(javaWriter);
  }
  WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
    @Override public void write(    JavaWriter javaWriter) throws IOException {
      javaWriter.emitStatement(""String_Node_Str"",getQualifiedModelClassName());
    }
  }
,getQualifiedModelClassName(),""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  if (!updateConflicationActionName.isEmpty()) {
    WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
      @Override public void write(      JavaWriter javaWriter) throws IOException {
        javaWriter.emitStatement(""String_Node_Str"",Classes.CONFLICT_ACTION,updateConflicationActionName);
      }
    }
,Classes.CONFLICT_ACTION,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  }
  if (!insertConflictActionName.isEmpty()) {
    WriterUtils.emitOverriddenMethod(javaWriter,new FlowWriter(){
      @Override public void write(      JavaWriter javaWriter) throws IOException {
        javaWriter.emitStatement(""String_Node_Str"",Classes.CONFLICT_ACTION,insertConflictActionName);
      }
    }
,Classes.CONFLICT_ACTION,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  }
  javaWriter.endType();
  javaWriter.close();
}"
27105,"public void appendForeignKeys(ForeignKeyReference[] references){
  QueryBuilder queryBuilder;
  List<QueryBuilder> queryBuilders=new ArrayList<QueryBuilder>();
  for (  ForeignKeyReference foreignKeyReference : references) {
    queryBuilder=new QueryBuilder().append(foreignKeyReference.columnName()).appendSpace().appendType(ModelUtils.getClassFromAnnotation(foreignKeyReference));
    queryBuilders.add(queryBuilder);
  }
  appendList(queryBuilders);
}","public void appendForeignKeys(ForeignKeyReference[] references){
  QueryBuilder queryBuilder;
  List<QueryBuilder> queryBuilders=new ArrayList<QueryBuilder>();
  for (  ForeignKeyReference foreignKeyReference : references) {
    queryBuilder=new QueryBuilder().appendQuoted(foreignKeyReference.columnName()).appendSpace().appendType(ModelUtils.getClassFromAnnotation(foreignKeyReference));
    queryBuilders.add(queryBuilder);
  }
  appendList(queryBuilders);
}"
27106,"@Override public void write(JavaWriter javaWriter) throws IOException {
  TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
  tableCreationQuery.appendCreateTableIfNotExists(tableDefinition.tableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<QueryBuilder>();
  List<String> foreignColumnClasses=Lists.newArrayList();
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    TableCreationQueryBuilder queryBuilder=new TableCreationQueryBuilder();
    if (columnDefinition.columnType == Column.FOREIGN_KEY) {
      queryBuilder.appendSpace().appendForeignKeys(columnDefinition.foreignKeyReferences);
    }
 else {
      queryBuilder.append(columnDefinition.columnName).appendSpace();
      if (columnDefinition.hasTypeConverter) {
        TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(columnDefinition.modelType);
        if (typeConverterDefinition != null) {
          queryBuilder.appendType(typeConverterDefinition.getDbElement().asType().toString());
        }
 else {
          manager.logError(""String_Node_Str"" + columnDefinition.columnFieldType);
          queryBuilder.append(""String_Node_Str"");
        }
      }
 else       if (SQLiteType.containsClass(columnDefinition.columnFieldType)) {
        queryBuilder.appendType(columnDefinition.columnFieldType);
      }
 else       if (ProcessorUtils.isSubclassOf(columnDefinition.columnFieldType,Enum.class)) {
        queryBuilder.appendSQLiteType(SQLiteType.TEXT);
      }
    }
    mColumnDefinitions.add(queryBuilder.appendColumn(columnDefinition.column));
  }
  boolean isModelView=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),tableDefinition.packageName + ""String_Node_Str"" + tableDefinition.getModelClassName(),manager.getElements().getTypeElement(Classes.MODEL_VIEW));
  if (!isModelView) {
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    int count=0;
    int index=0;
    for (    ColumnDefinition field : tableDefinition.primaryColumnDefinitions) {
      if (field.columnType == Column.PRIMARY_KEY) {
        count++;
        primaryKeyQueryBuilder.append(field.columnName);
        if (index < tableDefinition.primaryColumnDefinitions.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    for (    ColumnDefinition foreignKeyField : tableDefinition.foreignKeyDefinitions) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      String[] foreignColumns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=foreignKeyField.foreignKeyReferences[i].foreignColumnName();
      }
      String[] columns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < columns.length; i++) {
        columns[i]=foreignKeyField.foreignKeyReferences[i].columnName();
      }
      foreignKeyQueryBuilder.appendArray(columns).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onUpdate().name().replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onDelete().name().replace(""String_Node_Str"",""String_Node_Str""));
      foreignColumnClasses.add(""String_Node_Str"" + ModelUtils.getFieldClass(foreignKeyField.columnFieldType) + ""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!tableDefinition.primaryColumnDefinitions.isEmpty() || !tableDefinition.foreignKeyDefinitions.isEmpty()) {
    manager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
  }
  tableCreationQuery.appendList(mColumnDefinitions).append(""String_Node_Str"");
  QueryBuilder returnQuery=new QueryBuilder();
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
  }
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
    returnQuery.appendList(foreignColumnClasses).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(returnQuery.getQuery(),tableCreationQuery.getQuery());
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
  tableCreationQuery.appendCreateTableIfNotExists(tableDefinition.tableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<QueryBuilder>();
  List<String> foreignColumnClasses=Lists.newArrayList();
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    TableCreationQueryBuilder queryBuilder=new TableCreationQueryBuilder();
    if (columnDefinition.columnType == Column.FOREIGN_KEY) {
      queryBuilder.appendSpace().appendForeignKeys(columnDefinition.foreignKeyReferences);
    }
 else {
      queryBuilder.appendQuoted(columnDefinition.columnName).appendSpace();
      if (columnDefinition.hasTypeConverter) {
        TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(columnDefinition.modelType);
        if (typeConverterDefinition != null) {
          queryBuilder.appendType(typeConverterDefinition.getDbElement().asType().toString());
        }
 else {
          manager.logError(""String_Node_Str"" + columnDefinition.columnFieldType);
          queryBuilder.append(""String_Node_Str"");
        }
      }
 else       if (SQLiteType.containsClass(columnDefinition.columnFieldType)) {
        queryBuilder.appendType(columnDefinition.columnFieldType);
      }
 else       if (ProcessorUtils.isSubclassOf(columnDefinition.columnFieldType,Enum.class)) {
        queryBuilder.appendSQLiteType(SQLiteType.TEXT);
      }
    }
    mColumnDefinitions.add(queryBuilder.appendColumn(columnDefinition.column));
  }
  boolean isModelView=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),tableDefinition.packageName + ""String_Node_Str"" + tableDefinition.getModelClassName(),manager.getElements().getTypeElement(Classes.MODEL_VIEW));
  if (!isModelView) {
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    int count=0;
    int index=0;
    for (    ColumnDefinition field : tableDefinition.primaryColumnDefinitions) {
      if (field.columnType == Column.PRIMARY_KEY) {
        count++;
        primaryKeyQueryBuilder.appendQuoted(field.columnName);
        if (index < tableDefinition.primaryColumnDefinitions.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    for (    ColumnDefinition foreignKeyField : tableDefinition.foreignKeyDefinitions) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      String[] foreignColumns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=QueryBuilder.quote(foreignKeyField.foreignKeyReferences[i].foreignColumnName());
      }
      String[] columns=new String[foreignKeyField.foreignKeyReferences.length];
      String[] foreignColumnNames=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < columns.length; i++) {
        columns[i]=QueryBuilder.quote(foreignKeyField.foreignKeyReferences[i].columnName());
        foreignColumnNames[i]=QueryBuilder.quote(foreignKeyField.foreignKeyReferences[i].foreignColumnName());
      }
      foreignKeyQueryBuilder.appendArray(columns).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"").append(""String_Node_Str"").appendArray(foreignColumnNames).append(""String_Node_Str"").appendSpace().append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onUpdate().name().replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"").appendSpaceSeparated(foreignKeyField.column.onDelete().name().replace(""String_Node_Str"",""String_Node_Str""));
      foreignColumnClasses.add(""String_Node_Str"" + ModelUtils.getFieldClass(foreignKeyField.columnFieldType) + ""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!tableDefinition.primaryColumnDefinitions.isEmpty() || !tableDefinition.foreignKeyDefinitions.isEmpty()) {
    manager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
  }
  tableCreationQuery.appendList(mColumnDefinitions).append(""String_Node_Str"");
  QueryBuilder returnQuery=new QueryBuilder();
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
  }
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
    returnQuery.appendList(foreignColumnClasses).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(returnQuery.getQuery(),tableCreationQuery.getQuery());
}"
27107,"public void testInOperators(){
  Condition.In in=Condition.column(ConditionModel$Table.NAME).in(""String_Node_Str"").and(""String_Node_Str"").and(""String_Node_Str"");
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class,in);
  assertEquals(conditionQueryBuilder.getQuery().trim(),""String_Node_Str"");
  Condition.In notIn=Condition.column(ConditionModel$Table.NAME).notIn(""String_Node_Str"").and(""String_Node_Str"").and(""String_Node_Str"");
  conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class,notIn);
  assertEquals(conditionQueryBuilder.getQuery().trim(),""String_Node_Str"");
}","public void testInOperators(){
  Condition.In in=Condition.column(ConditionModel$Table.NAME).in(""String_Node_Str"").and(""String_Node_Str"").and(""String_Node_Str"");
  ConditionQueryBuilder<ConditionModel> conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class,in);
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
  Condition.In notIn=Condition.column(ConditionModel$Table.NAME).notIn(""String_Node_Str"").and(""String_Node_Str"").and(""String_Node_Str"");
  conditionQueryBuilder=new ConditionQueryBuilder<>(ConditionModel.class,notIn);
  assertEquals(""String_Node_Str"",conditionQueryBuilder.getQuery().trim());
}"
27108,"public void testMigration(){
  List<String> columnNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AlterTableMigration<MigrationModel> renameMigration=new AlterTableMigration<>(MigrationModel.class).renameFrom(""String_Node_Str"");
  renameMigration.onPreMigrate();
  assertEquals(""String_Node_Str"",renameMigration.getRenameQuery());
  renameMigration.onPostMigrate();
  AlterTableMigration<MigrationModel> alterTableMigration=new AlterTableMigration<>(MigrationModel.class);
  alterTableMigration.addColumn(float.class,""String_Node_Str"").addColumn(long.class,""String_Node_Str"").addColumn(String.class,""String_Node_Str"").addColumn(int.class,""String_Node_Str"").addColumn(byte[].class,""String_Node_Str"");
  alterTableMigration.onPreMigrate();
  List<String> columnDefinitions=alterTableMigration.getColumnDefinitions();
  for (int i=0; i < columnDefinitions.size(); i++) {
    assertEquals(""String_Node_Str"" + columnNames.get(i),columnDefinitions.get(i));
  }
  alterTableMigration.migrate(FlowManager.getDatabaseForTable(MigrationModel.class).getWritableDatabase());
  Cursor cursor=new Select().from(MigrationModel.class).where().query();
  String[] columns=cursor.getColumnNames();
  assertTrue(columns.length == columnNames.size() + 2);
  for (int i=0; i < columnNames.size(); i++) {
    assertTrue(cursor.getColumnIndex(columnNames.get(i).split(""String_Node_Str"")[0]) != -1);
  }
  alterTableMigration.onPostMigrate();
}","public void testMigration(){
  List<String> columnNames=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  List<String> columns=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  AlterTableMigration<MigrationModel> renameMigration=new AlterTableMigration<>(MigrationModel.class).renameFrom(""String_Node_Str"");
  renameMigration.onPreMigrate();
  assertEquals(""String_Node_Str"",renameMigration.getRenameQuery());
  renameMigration.onPostMigrate();
  AlterTableMigration<MigrationModel> alterTableMigration=new AlterTableMigration<>(MigrationModel.class);
  alterTableMigration.addColumn(float.class,""String_Node_Str"").addColumn(long.class,""String_Node_Str"").addColumn(String.class,""String_Node_Str"").addColumn(int.class,""String_Node_Str"").addColumn(byte[].class,""String_Node_Str"");
  alterTableMigration.onPreMigrate();
  List<String> columnDefinitions=alterTableMigration.getColumnDefinitions();
  for (int i=0; i < columnDefinitions.size(); i++) {
    assertEquals(""String_Node_Str"" + columnNames.get(i),columnDefinitions.get(i));
  }
  alterTableMigration.migrate(FlowManager.getDatabaseForTable(MigrationModel.class).getWritableDatabase());
  Cursor cursor=new Select().from(MigrationModel.class).where().query();
  assertTrue(cursor.getColumnNames().length == columnNames.size() + 2);
  for (int i=0; i < columns.size(); i++) {
    assertTrue(cursor.getColumnIndex(columns.get(i)) != -1);
  }
  alterTableMigration.onPostMigrate();
}"
27109,"public void testPrimaryWhereQuery(){
  ConditionQueryBuilder<TestPrimaryWhere> primaryWhere=FlowManager.getPrimaryWhereQuery(TestPrimaryWhere.class);
  assertEquals(primaryWhere.getQuery(),""String_Node_Str"");
}","public void testPrimaryWhereQuery(){
  ConditionQueryBuilder<TestPrimaryWhere> primaryWhere=FlowManager.getPrimaryWhereQuery(TestPrimaryWhere.class);
  assertEquals(""String_Node_Str"",primaryWhere.getQuery());
}"
27110,"public void setTestModel1(TestModel1 model1){
  testModel1=new ForeignKeyContainer<TestModel1>(TestModel1.class);
  Map<String,Object> map=new HashMap<>();
  map.put(TestModel1$Table.NAME,model1.name);
  testModel1.setData(map);
}","public void setTestModel1(TestModel1 model1){
  testModel1=new ForeignKeyContainer<>(TestModel1.class);
  Map<String,Object> map=new HashMap<>();
  map.put(TestModel1$Table.NAME,model1.name);
  testModel1.setData(map);
}"
27111,"public void testForeignKeyModel(){
  ForeignInteractionModel foreignInteractionModel=new ForeignInteractionModel();
}","public void testForeignKeyModel(){
  Delete.tables(ForeignInteractionModel.class,TestModel1.class);
  ForeignInteractionModel foreignInteractionModel=new ForeignInteractionModel();
  TestModel1 testModel1=new TestModel1();
  testModel1.name=""String_Node_Str"";
  foreignInteractionModel.setTestModel1(testModel1);
  foreignInteractionModel.name=""String_Node_Str"";
  foreignInteractionModel.save(false);
  assertTrue(foreignInteractionModel.exists());
  assertTrue(foreignInteractionModel.testModel1.exists());
  Delete.tables(TestModel1.class,ForeignInteractionModel.class);
}"
27112,"/** 
 * Sets the data for this container
 * @param data The data object that backs this container
 */
@Override public void setData(DataClass data){
  mData=data;
}","/** 
 * Sets the data for this container
 * @param data The data object that backs this container
 */
@Override public void setData(DataClass data){
  mData=data;
  mModel=null;
}"
27113,"public BaseModelContainer(Class<ModelClass> table,DataClass data){
  mModelAdapter=FlowManager.getModelAdapter(table);
  mContainerAdapter=FlowManager.getContainerAdapter(table);
  mData=data;
  if (mContainerAdapter == null) {
    throw new InvalidDBConfiguration(""String_Node_Str"" + FlowManager.getTableName(table) + ""String_Node_Str""+ ""String_Node_Str"");
  }
}","public BaseModelContainer(Class<ModelClass> table,DataClass data){
  this(table);
  mData=data;
}"
27114,"public void testForeignKeyModel(){
  Delete.tables(ForeignInteractionModel.class,TestModel1.class);
  ForeignInteractionModel foreignInteractionModel=new ForeignInteractionModel();
  TestModel1 testModel1=new TestModel1();
  testModel1.name=""String_Node_Str"";
  foreignInteractionModel.setTestModel1(testModel1);
  foreignInteractionModel.name=""String_Node_Str"";
  foreignInteractionModel.save(false);
  assertTrue(foreignInteractionModel.exists());
  assertTrue(foreignInteractionModel.testModel1.exists());
  Delete.tables(TestModel1.class,ForeignInteractionModel.class);
}","public void testForeignKeyModel(){
  Delete.tables(TestModel1.class,ForeignInteractionModel.class);
  ForeignInteractionModel foreignInteractionModel=new ForeignInteractionModel();
  TestModel1 testModel1=new TestModel1();
  testModel1.name=""String_Node_Str"";
  testModel1.save(false);
  foreignInteractionModel.setTestModel1(testModel1);
  foreignInteractionModel.name=""String_Node_Str"";
  foreignInteractionModel.save(false);
  assertTrue(foreignInteractionModel.exists());
  assertTrue(foreignInteractionModel.testModel1.exists());
  foreignInteractionModel=Select.byId(ForeignInteractionModel.class,""String_Node_Str"");
  assertNotNull(foreignInteractionModel);
  assertNotNull(foreignInteractionModel.testModel1);
  TestModel1 testModel11=foreignInteractionModel.getTestModel1();
  assertNotNull(testModel1);
  assertEquals(""String_Node_Str"",testModel11.name);
  Delete.tables(TestModel1.class,ForeignInteractionModel.class);
}"
27115,"/** 
 * Syncs the model to the database depending on it's save mode.
 * @param async
 * @param model
 * @param contentValues
 * @param mode
 * @param < ModelClass >
 */
public static <ModelClass extends Model>void sync(boolean async,ModelClass model,ModelAdapter<ModelClass> modelAdapter,@SaveMode int mode){
  if (!async) {
    BaseDatabaseDefinition flowManager=FlowManager.getDatabaseForTable(model.getClass());
    final SQLiteDatabase db=flowManager.getWritableDatabase();
    boolean exists=false;
    BaseModel.Action action=BaseModel.Action.SAVE;
    if (mode == SAVE_MODE_DEFAULT) {
      exists=modelAdapter.exists(model);
    }
 else     if (mode == SAVE_MODE_UPDATE) {
      exists=true;
      action=BaseModel.Action.UPDATE;
    }
 else {
      action=BaseModel.Action.INSERT;
    }
    if (exists) {
      exists=update(false,model,modelAdapter);
    }
    if (!exists) {
      insert(false,model,modelAdapter);
    }
    notifyModelChanged(model.getClass(),action);
  }
 else {
    TransactionManager.getInstance().save(ProcessModelInfo.withModels(model).info(DBTransactionInfo.createSave()));
  }
}","/** 
 * Syncs the model to the database depending on it's save mode.
 * @param async
 * @param model
 * @param contentValues
 * @param mode
 * @param < ModelClass >
 */
public static <ModelClass extends Model>void sync(boolean async,ModelClass model,ModelAdapter<ModelClass> modelAdapter,@SaveMode int mode){
  if (!async) {
    if (model == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + modelAdapter.getModelClass() + ""String_Node_Str"");
    }
    BaseDatabaseDefinition flowManager=FlowManager.getDatabaseForTable(model.getClass());
    final SQLiteDatabase db=flowManager.getWritableDatabase();
    boolean exists=false;
    BaseModel.Action action=BaseModel.Action.SAVE;
    if (mode == SAVE_MODE_DEFAULT) {
      exists=modelAdapter.exists(model);
    }
 else     if (mode == SAVE_MODE_UPDATE) {
      exists=true;
      action=BaseModel.Action.UPDATE;
    }
 else {
      action=BaseModel.Action.INSERT;
    }
    if (exists) {
      exists=update(false,model,modelAdapter);
    }
    if (!exists) {
      insert(false,model,modelAdapter);
    }
    notifyModelChanged(model.getClass(),action);
  }
 else {
    TransactionManager.getInstance().save(ProcessModelInfo.withModels(model).info(DBTransactionInfo.createSave()));
  }
}"
27116,"public void testContentObserver(){
  FlowContentObserver flowContentObserver=new FlowContentObserver();
  flowContentObserver.registerForContentChanges(getContext(),TestModel1.class);
  final Boolean[] methodcalled={false,false,false,false};
  FlowContentObserver.ModelChangeListener modelChangeListener=new FlowContentObserver.ModelChangeListener(){
    @Override public void onModelChanged(){
      for (int i=0; i < methodcalled.length; i++) {
        methodcalled[i]=true;
      }
    }
    @Override public void onModelSaved(){
      methodcalled[0]=true;
    }
    @Override public void onModelDeleted(){
      methodcalled[1]=true;
    }
    @Override public void onModelInserted(){
      methodcalled[2]=true;
    }
    @Override public void onModelUpdated(){
      methodcalled[3]=true;
    }
  }
;
  flowContentObserver.addModelChangeListener(modelChangeListener);
  TestModel1 testModel1=new TestModel1();
  testModel1.name=""String_Node_Str"";
  testModel1.insert(false);
  testModel1.update(false);
  testModel1.save(false);
  testModel1.delete(false);
  flowContentObserver.removeModelChangeListener(modelChangeListener);
  assertTrue(methodcalled[0]);
  assertTrue(methodcalled[1]);
  assertTrue(methodcalled[2]);
  assertTrue(methodcalled[3]);
  flowContentObserver.unregisterForContentChanges(getContext());
}","public void testContentObserver(){
  Delete.table(TestModel1.class);
  FlowContentObserver flowContentObserver=new FlowContentObserver();
  flowContentObserver.registerForContentChanges(getContext(),TestModel1.class);
  final Boolean[] methodcalled={false,false,false,false};
  FlowContentObserver.ModelChangeListener modelChangeListener=new FlowContentObserver.ModelChangeListener(){
    @Override public void onModelChanged(){
      for (int i=0; i < methodcalled.length; i++) {
        methodcalled[i]=true;
      }
    }
    @Override public void onModelSaved(){
      methodcalled[0]=true;
    }
    @Override public void onModelDeleted(){
      methodcalled[1]=true;
    }
    @Override public void onModelInserted(){
      methodcalled[2]=true;
    }
    @Override public void onModelUpdated(){
      methodcalled[3]=true;
    }
  }
;
  flowContentObserver.addModelChangeListener(modelChangeListener);
  TestModel1 testModel1=new TestModel1();
  testModel1.name=""String_Node_Str"";
  testModel1.insert(false);
  testModel1.update(false);
  testModel1.save(false);
  testModel1.delete(false);
  flowContentObserver.removeModelChangeListener(modelChangeListener);
  assertTrue(methodcalled[0]);
  assertTrue(methodcalled[1]);
  assertTrue(methodcalled[2]);
  assertTrue(methodcalled[3]);
  flowContentObserver.unregisterForContentChanges(getContext());
}"
27117,"public void testListeners(){
  ListenerModel listenerModel=new ListenerModel();
  listenerModel.name=""String_Node_Str"";
  final boolean[] called=new boolean[]{false,false,false};
  listenerModel.registerListeners(new SQLiteStatementListener(){
    @Override public void onBindToStatement(    SQLiteStatement sqLiteStatement){
      called[1]=true;
    }
  }
,new ContentValuesListener(){
    @Override public void onBindToContentValues(    ContentValues contentValues){
      called[2]=true;
    }
  }
);
  listenerModel.insert(false);
  listenerModel.update(false);
  ModelAdapter<ListenerModel> modelModelAdapter=FlowManager.getModelAdapter(ListenerModel.class);
  Cursor cursor=new Select().from(ListenerModel.class).where(Condition.column(ListenerModel$Table.NAME).is(""String_Node_Str"")).query();
  assertNotNull(cursor);
  modelModelAdapter.loadFromCursor(cursor,listenerModel);
  cursor.close();
  for (  boolean call : called) {
    assertTrue(call);
  }
}","public void testListeners(){
  Delete.table(ListenerModel.class);
  ListenerModel listenerModel=new ListenerModel();
  listenerModel.name=""String_Node_Str"";
  final boolean[] called=new boolean[]{false,false,false};
  listenerModel.registerListeners(new SQLiteStatementListener(){
    @Override public void onBindToStatement(    SQLiteStatement sqLiteStatement){
      called[1]=true;
    }
  }
,new ContentValuesListener(){
    @Override public void onBindToContentValues(    ContentValues contentValues){
      called[2]=true;
    }
  }
);
  listenerModel.registerLoadFromCursorListener(new LoadFromCursorListener(){
    @Override public void onLoadFromCursor(    Cursor cursor){
      called[0]=true;
    }
  }
);
  listenerModel.insert(false);
  listenerModel.update(false);
  ModelAdapter<ListenerModel> modelModelAdapter=FlowManager.getModelAdapter(ListenerModel.class);
  Cursor cursor=new Select().from(ListenerModel.class).where(Condition.column(ListenerModel$Table.NAME).is(""String_Node_Str"")).query();
  assertNotNull(cursor);
  assertTrue(cursor.moveToFirst());
  modelModelAdapter.loadFromCursor(cursor,listenerModel);
  listenerModel.delete(false);
  cursor.close();
  for (  boolean call : called) {
    assertTrue(call);
  }
}"
27118,"/** 
 * Called when the model has been inserted. This is only available to   {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public void onModelInserted();","@Override public void onModelInserted(){
  onModelStateChanged();
}"
27119,"/** 
 * Called when the model has changed. This is only called in versions below   {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 */
public void onModelChanged();","@Override public void onModelChanged(){
  onModelStateChanged();
}"
27120,"/** 
 * Called when the model has been saved. This is only available to   {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public void onModelSaved();","@Override public void onModelSaved(){
  onModelStateChanged();
}"
27121,"/** 
 * Called when the model has been updated. This is only available to   {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public void onModelUpdated();","@Override public void onModelUpdated(){
  onModelStateChanged();
}"
27122,"/** 
 * Called when model has been deleted. This is only available to   {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}.
 */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1) public void onModelDeleted();","@Override public void onModelDeleted(){
  onModelStateChanged();
}"
27123,"/** 
 * Takes first   {@link ModelClass} from the cursor
 * @param dontMoveToFirst If it's a list or at a specific position, do not reset the cursor
 * @param table           The model class that we convert the cursor data into.
 * @param cursor          The cursor from the DB
 * @param < ModelClass >
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>ModelClass convertToModel(boolean dontMoveToFirst,Class<ModelClass> table,Cursor cursor){
  ModelClass model=null;
  try {
    if (dontMoveToFirst || cursor.moveToFirst()) {
      ModelAdapter<ModelClass> modelAdapter=FlowManager.getModelAdapter(table);
      if (modelAdapter == null) {
        Class persistentClass=(Class)((ParameterizedType)table.getGenericSuperclass()).getActualTypeArguments()[0];
        if (persistentClass.isAssignableFrom(BaseModelView.class)) {
          model=(ModelClass)FlowManager.getModelViewAdapter((Class<? extends BaseModelView<? extends Model>>)table).loadFromCursor(cursor);
        }
      }
 else {
        model=modelAdapter.loadFromCursor(cursor);
      }
    }
  }
 catch (  Exception e) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"",e);
  }
  return model;
}","/** 
 * Takes first   {@link ModelClass} from the cursor
 * @param dontMoveToFirst If it's a list or at a specific position, do not reset the cursor
 * @param table           The model class that we convert the cursor data into.
 * @param cursor          The cursor from the DB
 * @param < ModelClass >
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>ModelClass convertToModel(boolean dontMoveToFirst,Class<ModelClass> table,Cursor cursor){
  ModelClass model=null;
  try {
    if (dontMoveToFirst || cursor.moveToFirst()) {
      ModelAdapter<ModelClass> modelAdapter=FlowManager.getModelAdapter(table);
      if (modelAdapter == null) {
        if (BaseModelView.class.isAssignableFrom(table)) {
          model=(ModelClass)FlowManager.getModelViewAdapter((Class<? extends BaseModelView<? extends Model>>)table).loadFromCursor(cursor);
        }
      }
 else {
        model=modelAdapter.loadFromCursor(cursor);
      }
    }
  }
 catch (  Exception e) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"",e);
  }
  return model;
}"
27124,"/** 
 * Takes first   {@link ModelClass} from the cursor
 * @param dontMoveToFirst If it's a list or at a specific position, do not reset the cursor
 * @param table           The model class that we convert the cursor data into.
 * @param cursor          The cursor from the DB
 * @param < ModelClass >
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>ModelClass convertToModel(boolean dontMoveToFirst,Class<ModelClass> table,Cursor cursor){
  ModelClass model=null;
  try {
    if (dontMoveToFirst || cursor.moveToFirst()) {
      ModelAdapter<ModelClass> modelAdapter=FlowManager.getModelAdapter(table);
      if (modelAdapter == null) {
        Class persistentClass=(Class)((ParameterizedType)table.getGenericSuperclass()).getActualTypeArguments()[0];
        if (persistentClass.isAssignableFrom(BaseModelView.class)) {
          model=(ModelClass)FlowManager.getModelViewAdapter((Class<? extends BaseModelView<? extends Model>>)table).loadFromCursor(cursor);
        }
      }
 else {
        model=modelAdapter.loadFromCursor(cursor);
      }
    }
  }
 catch (  Exception e) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"",e);
  }
  return model;
}","/** 
 * Takes first   {@link ModelClass} from the cursor
 * @param dontMoveToFirst If it's a list or at a specific position, do not reset the cursor
 * @param table           The model class that we convert the cursor data into.
 * @param cursor          The cursor from the DB
 * @param < ModelClass >
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>ModelClass convertToModel(boolean dontMoveToFirst,Class<ModelClass> table,Cursor cursor){
  ModelClass model=null;
  try {
    if (dontMoveToFirst || cursor.moveToFirst()) {
      ModelAdapter<ModelClass> modelAdapter=FlowManager.getModelAdapter(table);
      if (modelAdapter == null) {
        if (BaseModelView.class.isAssignableFrom(table)) {
          model=(ModelClass)FlowManager.getModelViewAdapter((Class<? extends BaseModelView<? extends Model>>)table).loadFromCursor(cursor);
        }
      }
 else {
        model=modelAdapter.loadFromCursor(cursor);
      }
    }
  }
 catch (  Exception e) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"",e);
  }
  return model;
}"
27125,"/** 
 * Appends IS NOT NULL to the end of this condition
 * @return
 */
public Condition isNotNull(){
  mOperation=""String_Node_Str"";
  mValue=""String_Node_Str"";
  return this;
}","/** 
 * Appends IS NOT NULL to the end of this condition
 * @return
 */
public Condition isNotNull(){
  mOperation=String.format(""String_Node_Str"",Operation.IS_NOT_NULL);
  return this;
}"
27126,"/** 
 * Appends the condition to the   {@link com.raizlabs.android.dbflow.sql.builder.ConditionQueryBuilder}
 * @param conditionQueryBuilder
 */
public void appendConditionToQuery(ConditionQueryBuilder conditionQueryBuilder){
  conditionQueryBuilder.append(columnName()).append(operation()).append(conditionQueryBuilder.convertValueToString(value()));
  if (postArgument() != null) {
    conditionQueryBuilder.appendSpace().append(postArgument());
  }
}","/** 
 * Appends the condition to the   {@link com.raizlabs.android.dbflow.sql.builder.ConditionQueryBuilder}
 * @param conditionQueryBuilder
 */
public void appendConditionToQuery(ConditionQueryBuilder conditionQueryBuilder){
  conditionQueryBuilder.append(columnName()).append(operation());
  if (!Operation.IS_NOT_NULL.equals(operation()) && !Operation.IS_NULL.equals(operation())) {
    conditionQueryBuilder.append(conditionQueryBuilder.convertValueToString(value()));
  }
  if (postArgument() != null) {
    conditionQueryBuilder.appendSpace().append(postArgument());
  }
}"
27127,"/** 
 * Appends IS NULL to the end of this condition
 * @return
 */
public Condition isNull(){
  mOperation=""String_Node_Str"";
  mValue=""String_Node_Str"";
  return this;
}","/** 
 * Appends IS NULL to the end of this condition
 * @return
 */
public Condition isNull(){
  mOperation=String.format(""String_Node_Str"",Operation.IS_NULL);
  return this;
}"
27128,"protected void setPreviousSeparator(String separator){
  if (mParams.size() > 0) {
    mParams.get(mParams.size()).separator(separator);
  }
}","protected void setPreviousSeparator(String separator){
  if (mParams.size() > 0) {
    mParams.get(mParams.size() - 1).separator(separator);
  }
}"
27129,"public MockConditionQueryBuilder appendCreation(String modelClassName){
  return append(""String_Node_Str"").appendSpace().append(""String_Node_Str"").append(modelClassName).append(""String_Node_Str"").append(ModelUtils.getFieldClass(modelClassName)).append(""String_Node_Str"");
}","public MockConditionQueryBuilder appendCreation(String modelClassName){
  return appendEmptyCreation(modelClassName).append(""String_Node_Str"");
}"
27130,"/** 
 * Appends a condition to this map. It will take the value and see if a   {@link com.grosner.dbflow.converter.TypeConverter}exists for the field. If so, we convert it to the database value. Also if the value is a string, we escape the string.
 * @param condition The condition to append
 * @return This instance
 */
public ConditionQueryBuilder<ModelClass> putCondition(Condition condition){
  mParams.put(condition.columnName(),condition);
  isChanged=true;
  return this;
}","/** 
 * Appends a condition to this map. It will take the value and see if a   {@link com.grosner.dbflow.converter.TypeConverter}exists for the field. If so, we convert it to the database valu  e. Also if the value is a string, we escape the string.
 * @param condition The condition to append
 * @return This instance
 */
public ConditionQueryBuilder<ModelClass> putCondition(Condition condition){
  mParams.put(condition.columnName(),condition);
  isChanged=true;
  return this;
}"
27131,public abstract ConditionQueryBuilder<ModelClass> getFullModelWhere(ModelViewClass model);,public abstract ConditionQueryBuilder<ModelViewClass> getFullModelWhere(ModelViewClass model);
27132,"/** 
 * @param table
 * @return the associated {@link com.grosner.dbflow.structure.ModelViewAdapter} for the specified table.
 */
abstract ModelViewAdapter getModelViewAdapterForTable(Class<? extends BaseModelView> table);","/** 
 * @param table the VIEW class to retrieve the ModelViewAdapter from.
 * @return the associated {@link com.grosner.dbflow.structure.ModelViewAdapter} for the specified table.
 */
abstract ModelViewAdapter getModelViewAdapterForTable(Class<? extends BaseModelView> table);"
27133,"/** 
 * Returns the associated   {@link com.grosner.dbflow.structure.ModelAdapter} within this database forthe specified table. If the Model is missing the  {@link com.grosner.dbflow.annotation.Table} annotation,this will fail.
 * @param table
 * @return
 */
abstract ModelAdapter getModelAdapterForTable(Class<? extends Model> table);","/** 
 * Returns the associated   {@link com.grosner.dbflow.structure.ModelAdapter} within this database forthe specified table. If the Model is missing the  {@link com.grosner.dbflow.annotation.Table} annotation,this will fail.
 * @param table The model that exists in this database.
 * @return The ModelAdapter for the table.
 */
abstract ModelAdapter getModelAdapterForTable(Class<? extends Model> table);"
27134,"/** 
 * Register to listen for database changes
 * @param databaseHelperListener
 */
public void setHelperListener(DatabaseHelperListener databaseHelperListener){
  mHelperListener=databaseHelperListener;
}","/** 
 * Register to listen for database changes
 * @param databaseHelperListener Listens for DB changes
 */
public void setHelperListener(DatabaseHelperListener databaseHelperListener){
  mHelperListener=databaseHelperListener;
}"
27135,"/** 
 * @return
 */
abstract Map<Integer,List<Migration>> getMigrations();","/** 
 * @return The map of migrations to DB version
 */
abstract Map<Integer,List<Migration>> getMigrations();"
27136,"/** 
 * Internal method used to create the database schema.
 * @return
 */
abstract List<ModelAdapter> getModelAdapters();","/** 
 * Internal method used to create the database schema.
 * @return List of Model Adapters
 */
abstract List<ModelAdapter> getModelAdapters();"
27137,public abstract boolean isForeignKeysSupported();,"/** 
 * @return True if the {@link com.grosner.dbflow.annotation.Database} annotation is true.
 */
public abstract boolean isForeignKeysSupported();"
27138,"public void reset(Context context){
  if (!isResetting) {
    isResetting=true;
    context.deleteDatabase(getDatabaseName());
    isResetting=false;
  }
}","/** 
 * Performs a full deletion of this database.
 * @param context Where the database resides
 */
public void reset(Context context){
  if (!isResetting) {
    isResetting=true;
    context.deleteDatabase(getDatabaseName());
    mHelper=new FlowSQLiteOpenHelper(this,mInternalHelperListener);
    isResetting=false;
  }
}"
27139,"/** 
 * Returns a list of all model classes in this database.
 * @return
 */
abstract List<Class<? extends Model>> getModelClasses();","/** 
 * @return a list of all model classes in this database.
 */
abstract List<Class<? extends Model>> getModelClasses();"
27140,public abstract boolean areConsistencyChecksEnabled();,"/** 
 * @return True if the {@link com.grosner.dbflow.annotation.Database} annotation is true.
 */
public abstract boolean areConsistencyChecksEnabled();"
27141,"/** 
 * Will throw an exception if this class is not initialized yet in   {@link #initialize(android.content.Context,DBConfiguration)}
 * @return
 */
public static Context getContext(){
  if (context == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return context;
}","/** 
 * Will throw an exception if this class is not initialized yet in   {@link #init(android.content.Context)}
 * @return
 */
public static Context getContext(){
  if (context == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return context;
}"
27142,"/** 
 * Tells the queue if this request is ready to run. The default is true. This is run on the  {@link com.grosner.dbflow.runtime.DBTransactionQueue}'s thread.
 * @return
 */
public boolean onReady(){
  return true;
}","/** 
 * Tells the queue if this request is ready to run. The default is true. This is run on the  {@link com.grosner.dbflow.runtime.DBTransactionQueue}'s thread.
 * @return True if we run the request, if false we throw it away.
 */
public boolean onReady(){
  return true;
}"
27143,"/** 
 * Assigns operation to ""<""
 * @param value The value of the column in the DB in String value
 * @return
 */
public Condition lessThan(Object value){
  mOperation=""String_Node_Str"";
  return value(value);
}","/** 
 * Assigns operation to ""<""
 * @param value The value of the column in the DB
 * @return This condition
 */
public Condition lessThan(Object value){
  mOperation=""String_Node_Str"";
  return value(value);
}"
27144,"/** 
 * Assigns the operation to ""=""
 * @param value The value of the column in the DB in String value
 * @return
 */
public Condition is(Object value){
  mOperation=""String_Node_Str"";
  return value(value);
}","/** 
 * Assigns the operation to ""=""
 * @param value The value of the column in the DB
 * @return This condition
 */
public Condition is(Object value){
  mOperation=""String_Node_Str"";
  return value(value);
}"
27145,"/** 
 * Returns the value of the arg
 * @return
 */
public Object value(){
  return mValue;
}","/** 
 * @return the value of the argument
 */
public Object value(){
  return mValue;
}"
27146,"/** 
 * Returns the operation of it
 * @return
 */
public String operation(){
  return mOperation;
}","/** 
 * @return the operator such as ""<"", ""<"", or ""=""
 */
public String operation(){
  return mOperation;
}"
27147,"/** 
 * Assigns operation to "">""
 * @param value The value of the column in the DB in String value
 * @return
 */
public Condition greaterThan(Object value){
  mOperation=""String_Node_Str"";
  return value(value);
}","/** 
 * Assigns operation to "">""
 * @param value The value of the column in the DB
 * @return This condition
 */
public Condition greaterThan(Object value){
  mOperation=""String_Node_Str"";
  return value(value);
}"
27148,"/** 
 * Returns the column name
 * @return
 */
public String columnName(){
  return mColumn;
}","/** 
 * @return the column name
 */
public String columnName(){
  return mColumn;
}"
27149,"/** 
 * Converts the given value for the column
 * @param columnName The name of the column in the DB
 * @param value      The value of the column we are looking for
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public String convertValueToString(String columnName,Object value){
  String stringVal;
  if (!useEmptyParams) {
  }
  if (value instanceof Number) {
    stringVal=String.valueOf(value);
  }
 else {
    stringVal=String.valueOf(value);
    if (!stringVal.equals(EMPTY_PARAM)) {
      stringVal=DatabaseUtils.sqlEscapeString(stringVal);
    }
  }
  return stringVal;
}","/** 
 * Converts the given value for the column
 * @param columnName The name of the column in the DB
 * @param value      The value of the column we are looking for
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public String convertValueToString(String columnName,Object value){
  String stringVal;
  if (!useEmptyParams && value != null) {
    TypeConverter typeConverter=FlowManager.getTypeConverterForClass(value.getClass());
    if (typeConverter != null) {
      value=typeConverter.getDBValue(value);
    }
  }
  if (value instanceof Number) {
    stringVal=String.valueOf(value);
  }
 else {
    stringVal=String.valueOf(value);
    if (!stringVal.equals(EMPTY_PARAM)) {
      stringVal=DatabaseUtils.sqlEscapeString(stringVal);
    }
  }
  return stringVal;
}"
27150,"/** 
 * Constructs an instance of this class and   {@link ModelClass}.
 * @param tableClass
 */
public ConditionQueryBuilder(Class<ModelClass> tableClass,Condition... conditions){
  mTableStructure=FlowManager.getModelAdapter(tableClass);
  putConditions(conditions);
}","/** 
 * Constructs an instance of this class and   {@link ModelClass}.
 * @param table      The table to use
 * @param conditions The array of conditions to add to the mapping.
 */
public ConditionQueryBuilder(Class<ModelClass> table,Condition... conditions){
  mTableStructure=FlowManager.getModelAdapter(table);
  putConditions(conditions);
}"
27151,"/** 
 * Appends all the conditions from the specified array
 * @param conditions The array of conditions to add to the mapping.
 * @return
 */
public ConditionQueryBuilder<ModelClass> putConditions(Condition... conditions){
  if (conditions.length > 0) {
    for (    Condition condition : conditions) {
      mParams.put(condition.columnName(),condition);
    }
    isChanged=true;
  }
  return this;
}","/** 
 * Appends all the conditions from the specified array
 * @param conditions The array of conditions to add to the mapping.
 * @return This instance
 */
public ConditionQueryBuilder<ModelClass> putConditions(Condition... conditions){
  if (conditions.length > 0) {
    for (    Condition condition : conditions) {
      mParams.put(condition.columnName(),condition);
    }
    isChanged=true;
  }
  return this;
}"
27152,"/** 
 * Add a column to the DB. This does not necessarily need to be reflected in the   {@link ModelClass}, but it is recommended.
 * @param columnType
 * @param columnName
 * @return
 */
public AlterTableMigration<ModelClass> addColumn(Class columnType,String columnName){
  if (mColumnDefinitions == null) {
    mColumnDefinitions=new ArrayList<QueryBuilder>();
  }
  QueryBuilder queryBuilder=new QueryBuilder().append(columnName).appendSpace().appendType(columnType.getName());
  mColumnDefinitions.add(queryBuilder);
  return this;
}","/** 
 * Add a column to the DB. This does not necessarily need to be reflected in the   {@link ModelClass}, but it is recommended.
 * @param columnType The type of column that pertains to an {@link com.grosner.dbflow.sql.SQLiteType}
 * @param columnName The name of the column to add. Use the ""$Table"" class for the specified table.
 * @return This instance
 */
public AlterTableMigration<ModelClass> addColumn(Class columnType,String columnName){
  if (mColumnDefinitions == null) {
    mColumnDefinitions=new ArrayList<QueryBuilder>();
  }
  QueryBuilder queryBuilder=new QueryBuilder().append(columnName).appendSpace().appendType(columnType.getName());
  mColumnDefinitions.add(queryBuilder);
  return this;
}"
27153,"/** 
 * Call this to rename a table to a new name, such as changing either the   {@link com.grosner.dbflow.structure.Model} class nameor by changing the name through a  {@link com.grosner.dbflow.structure.Table}
 * @param oldName The new name to call the table.
 * @return
 */
public AlterTableMigration<ModelClass> renameFrom(String oldName){
  mOldTableName=oldName;
  mRenameQuery=new QueryBuilder().append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"");
  return this;
}","/** 
 * Call this to rename a table to a new name, such as changing either the   {@link com.grosner.dbflow.structure.Model} class nameor by changing the name through a  {@link com.grosner.dbflow.structure.Table}
 * @param oldName The new name to call the table.
 * @return This instance
 */
public AlterTableMigration<ModelClass> renameFrom(String oldName){
  mOldTableName=oldName;
  mRenameQuery=new QueryBuilder().append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"");
  return this;
}"
27154,"public String getRenameQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(mQuery.getQuery()).append(mOldTableName).append(mRenameQuery).append(FlowManager.getTableName(mTable));
  return queryBuilder.getQuery();
}","/** 
 * @return The query that renames the table.
 */
public String getRenameQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(mQuery.getQuery()).append(mOldTableName).append(mRenameQuery).append(FlowManager.getTableName(mTable));
  return queryBuilder.getQuery();
}"
27155,"public List<String> getColumnDefinitions(){
  String sql=mQuery.getQuery() + FlowManager.getTableName(mTable);
  List<String> columnDefinitions=new ArrayList<String>();
  if (mColumnDefinitions != null) {
    for (    QueryBuilder columnDefinition : mColumnDefinitions) {
      QueryBuilder queryBuilder=new QueryBuilder(sql).appendSpaceSeparated(""String_Node_Str"").append(columnDefinition.getQuery());
      columnDefinitions.add(queryBuilder.getQuery());
    }
  }
  return columnDefinitions;
}","/** 
 * @return A List of column definitions that add column to a table in the DB.
 */
public List<String> getColumnDefinitions(){
  String sql=mQuery.getQuery() + FlowManager.getTableName(mTable);
  List<String> columnDefinitions=new ArrayList<String>();
  if (mColumnDefinitions != null) {
    for (    QueryBuilder columnDefinition : mColumnDefinitions) {
      QueryBuilder queryBuilder=new QueryBuilder(sql).appendSpaceSeparated(""String_Node_Str"").append(columnDefinition.getQuery());
      columnDefinitions.add(queryBuilder.getQuery());
    }
  }
  return columnDefinitions;
}"
27156,"public void writeSaveDefinition(JavaWriter javaWriter,boolean isModelContainerDefinition) throws IOException {
  if (columnType == Column.FOREIGN_KEY && isModel) {
    javaWriter.emitEmptyLine();
    if (isModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    if (isModelContainerDefinition) {
      String modelContainerName=ModelUtils.getVariable(true) + columnFieldName;
      javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldName,columnFieldType);
      javaWriter.emitStatement(""String_Node_Str"",modelContainerName);
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
        adapterQueryBuilder.appendContentValues().appendPut(foreignKeyReference.columnName()).appendCast(ModelUtils.getClassFromAnnotation(foreignKeyReference)).append(modelContainerName).append(""String_Node_Str"").appendGetValue(foreignKeyReference.foreignColumnName()).append(""String_Node_Str"");
        javaWriter.emitStatement(adapterQueryBuilder.getQuery());
      }
    }
 else {
      String modelStatement=ModelUtils.getModelStatement(columnFieldName);
      javaWriter.beginControlFlow(""String_Node_Str"",modelStatement);
      javaWriter.emitStatement(""String_Node_Str"",modelStatement);
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getContentValueStatement(foreignKeyReference.columnName(),columnName,ModelUtils.getClassFromAnnotation(foreignKeyReference),foreignKeyReference.foreignColumnName(),false,isModelContainer,true,false,columnFieldType));
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String newFieldType=null;
    if (hasTypeConverter) {
      TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(modelType);
      if (typeConverterDefinition == null) {
        manager.getMessager().printMessage(Diagnostic.Kind.ERROR,String.format(""String_Node_Str"",modelType));
      }
 else {
        newFieldType=typeConverterDefinition.getDbElement().asType().toString();
      }
    }
 else {
      newFieldType=columnFieldType;
    }
    javaWriter.emitStatement(ModelUtils.getContentValueStatement(columnName,columnName,newFieldType,columnFieldName,isModelContainerDefinition,isModelContainer,false,hasTypeConverter,columnFieldType));
  }
}","public void writeSaveDefinition(JavaWriter javaWriter,boolean isModelContainerDefinition) throws IOException {
  if (columnType == Column.FOREIGN_KEY && isModel) {
    javaWriter.emitEmptyLine();
    if (isModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    if (isModelContainerDefinition) {
      String modelContainerName=ModelUtils.getVariable(true) + columnFieldName;
      javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldName,columnFieldType);
      javaWriter.emitStatement(""String_Node_Str"",modelContainerName);
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
        adapterQueryBuilder.appendContentValues().appendPut(foreignKeyReference.columnName()).appendCast(ModelUtils.getClassFromAnnotation(foreignKeyReference)).append(modelContainerName).append(""String_Node_Str"").appendGetValue(foreignKeyReference.foreignColumnName()).append(""String_Node_Str"");
        javaWriter.emitStatement(adapterQueryBuilder.getQuery());
      }
    }
 else {
      String modelStatement=ModelUtils.getModelStatement(columnFieldName);
      javaWriter.beginControlFlow(""String_Node_Str"",modelStatement);
      javaWriter.emitStatement(""String_Node_Str"",modelStatement);
      for (      ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
        javaWriter.emitStatement(ModelUtils.getContentValueStatement(foreignKeyReference.columnName(),columnName,ModelUtils.getClassFromAnnotation(foreignKeyReference),foreignKeyReference.foreignColumnName(),false,isModelContainer,true,false,columnFieldType));
      }
      javaWriter.endControlFlow();
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String newFieldType=null;
    if (hasTypeConverter) {
      TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(modelType);
      if (typeConverterDefinition == null) {
        manager.getMessager().printMessage(Diagnostic.Kind.ERROR,String.format(""String_Node_Str"",modelType));
      }
 else {
        newFieldType=typeConverterDefinition.getDbElement().asType().toString();
      }
    }
 else {
      newFieldType=columnFieldType;
    }
    String getType=columnFieldType;
    if (element.asType().getKind().isPrimitive()) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    javaWriter.emitStatement(ModelUtils.getContentValueStatement(columnName,columnName,newFieldType,columnFieldName,isModelContainerDefinition,isModelContainer,false,hasTypeConverter,getType));
  }
}"
27157,"public void writeLoadFromCursorDefinition(JavaWriter javaWriter,boolean isModelContainerDefinition) throws IOException {
  if (columnType == Column.FOREIGN_KEY) {
    javaWriter.emitEmptyLine();
    javaWriter.emitSingleLineComment(""String_Node_Str"",columnFieldName);
    if (!isModelContainer && !isModelContainerDefinition && isModel) {
      MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder().appendForeignKeyReferences(columnFieldType + TableDefinition.DBFLOW_TABLE_TAG,columnName,foreignKeyReferences);
      String rawConditionStatement=String.format(""String_Node_Str"",ModelUtils.getFieldClass(columnFieldType),conditionQueryBuilder);
      AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder().appendVariable(false);
      adapterQueryBuilder.append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"");
      adapterQueryBuilder.append(rawConditionStatement);
      javaWriter.emitStatement(adapterQueryBuilder.getQuery());
    }
 else {
      if (isModelContainerDefinition) {
        String modelContainerName=ModelUtils.getVariable(true) + columnFieldName;
        javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldType);
        for (        ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
          AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
          adapterQueryBuilder.append(modelContainerName).appendPut(foreignKeyReference.foreignColumnName()).append(ModelUtils.getCursorStatement(ModelUtils.getClassFromAnnotation(foreignKeyReference),foreignKeyReference.columnName())).append(""String_Node_Str"");
          javaWriter.emitStatement(adapterQueryBuilder.getQuery());
        }
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName,modelContainerName);
      }
 else {
        for (        ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
          javaWriter.emitStatement(ModelUtils.getLoadFromCursorDefinitionField(manager,ModelUtils.getClassFromAnnotation(foreignKeyReference),columnFieldName,foreignKeyReference.columnName(),foreignKeyReference.foreignColumnName(),null,false,isModelContainerDefinition,isModelContainer));
        }
      }
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    javaWriter.emitStatement(ModelUtils.getLoadFromCursorDefinitionField(manager,columnFieldType,columnFieldName,columnName,""String_Node_Str"",modelType,hasTypeConverter,isModelContainerDefinition,this.isModelContainer));
  }
}","public void writeLoadFromCursorDefinition(JavaWriter javaWriter,boolean isModelContainerDefinition) throws IOException {
  if (columnType == Column.FOREIGN_KEY) {
    javaWriter.emitEmptyLine();
    javaWriter.emitSingleLineComment(""String_Node_Str"",columnFieldName);
    if (!isModelContainer && !isModelContainerDefinition && isModel) {
      MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder().appendForeignKeyReferences(columnFieldType + TableDefinition.DBFLOW_TABLE_TAG,columnName,foreignKeyReferences);
      String rawConditionStatement=String.format(""String_Node_Str"",ModelUtils.getFieldClass(columnFieldType),conditionQueryBuilder);
      AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder().appendVariable(false);
      adapterQueryBuilder.append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"");
      adapterQueryBuilder.append(rawConditionStatement);
      javaWriter.emitStatement(adapterQueryBuilder.getQuery());
    }
 else {
      if (isModelContainerDefinition) {
        String modelContainerName=ModelUtils.getVariable(true) + columnFieldName;
        javaWriter.emitStatement(""String_Node_Str"",modelContainerName,ModelUtils.getVariable(true),ModelUtils.getVariable(true),columnFieldType);
        for (        ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
          AdapterQueryBuilder adapterQueryBuilder=new AdapterQueryBuilder();
          adapterQueryBuilder.append(modelContainerName).appendPut(foreignKeyReference.foreignColumnName()).append(ModelUtils.getCursorStatement(ModelUtils.getClassFromAnnotation(foreignKeyReference),foreignKeyReference.columnName())).append(""String_Node_Str"");
          javaWriter.emitStatement(adapterQueryBuilder.getQuery());
        }
        javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getVariable(true),columnFieldName,modelContainerName);
      }
 else {
        for (        ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
          javaWriter.emitStatement(ModelUtils.getLoadFromCursorDefinitionField(manager,ModelUtils.getClassFromAnnotation(foreignKeyReference),columnFieldName,foreignKeyReference.columnName(),foreignKeyReference.foreignColumnName(),null,false,isModelContainerDefinition,isModelContainer));
        }
      }
    }
    javaWriter.emitSingleLineComment(""String_Node_Str"");
    javaWriter.emitEmptyLine();
  }
 else {
    String getType=columnFieldType;
    if (element.asType().getKind().isPrimitive()) {
      getType=manager.getTypeUtils().boxedClass((PrimitiveType)element.asType()).asType().toString();
    }
    javaWriter.emitStatement(ModelUtils.getLoadFromCursorDefinitionField(manager,getType,columnFieldName,columnName,""String_Node_Str"",modelType,hasTypeConverter,isModelContainerDefinition,this.isModelContainer));
  }
}"
27158,"@Override protected void createColumnDefinitions(TypeElement element){
  List<? extends Element> variableElements=manager.getElements().getAllMembers(element);
  ColumnValidator columnValidator=new ColumnValidator();
  for (  Element variableElement : variableElements) {
    if (variableElement.getAnnotation(Column.class) != null) {
      ColumnDefinition columnDefinition=new ColumnDefinition(manager,(VariableElement)variableElement);
      if (columnValidator.validate(manager,columnDefinition)) {
        columnDefinitions.add(columnDefinition);
        if (columnDefinition.columnType == Column.PRIMARY_KEY) {
          primaryColumnDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.FOREIGN_KEY) {
          foreignKeyDefinitions.add(columnDefinition);
        }
      }
    }
  }
}","@Override protected void createColumnDefinitions(TypeElement element){
  List<? extends Element> variableElements=manager.getElements().getAllMembers(element);
  ColumnValidator columnValidator=new ColumnValidator();
  for (  Element variableElement : variableElements) {
    if (variableElement.getAnnotation(Column.class) != null) {
      ColumnDefinition columnDefinition=new ColumnDefinition(manager,(VariableElement)variableElement);
      if (columnValidator.validate(manager,columnDefinition)) {
        columnDefinitions.add(columnDefinition);
        if (columnDefinition.columnType == Column.PRIMARY_KEY) {
          primaryColumnDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.FOREIGN_KEY) {
          foreignKeyDefinitions.add(columnDefinition);
        }
 else         if (columnDefinition.columnType == Column.PRIMARY_KEY_AUTO_INCREMENT) {
          autoIncrementDefinition=columnDefinition;
        }
      }
    }
  }
}"
27159,"public Map<Integer,List<MigrationDefinition>> getMigrationsForDatabase(String databaseName){
  if (hasOneDatabase()) {
    databaseName=""String_Node_Str"";
  }
  Map<Integer,List<MigrationDefinition>> migrationDefinitions=mMigrations.get(databaseName);
  if (migrationDefinitions != null) {
    return migrationDefinitions;
  }
 else {
    return Maps.newHashMap();
  }
}","public Map<Integer,List<MigrationDefinition>> getMigrationsForDatabase(String databaseName){
  Map<Integer,List<MigrationDefinition>> migrationDefinitions=mMigrations.get(databaseName);
  if (migrationDefinitions != null) {
    return migrationDefinitions;
  }
 else {
    return Maps.newHashMap();
  }
}"
27160,"public Set<ModelContainerDefinition> getModelContainers(String databaseName){
  if (hasOneDatabase()) {
    databaseName=""String_Node_Str"";
  }
  Map<String,ModelContainerDefinition> modelContainerDefinitionMap=mModelContainers.get(databaseName);
  if (modelContainerDefinitionMap != null) {
    return Sets.newHashSet(mModelContainers.get(databaseName).values());
  }
  return Sets.newHashSet();
}","public Set<ModelContainerDefinition> getModelContainers(String databaseName){
  Map<String,ModelContainerDefinition> modelContainerDefinitionMap=mModelContainers.get(databaseName);
  if (modelContainerDefinitionMap != null) {
    return Sets.newHashSet(mModelContainers.get(databaseName).values());
  }
  return Sets.newHashSet();
}"
27161,"public Set<TableDefinition> getTableDefinitions(String databaseName){
  if (hasOneDatabase()) {
    databaseName=""String_Node_Str"";
  }
  Map<String,TableDefinition> tableDefinitionMap=mTableDefinitions.get(databaseName);
  if (tableDefinitionMap != null) {
    return Sets.newHashSet(mTableDefinitions.get(databaseName).values());
  }
  return Sets.newHashSet();
}","public Set<TableDefinition> getTableDefinitions(String databaseName){
  Map<String,TableDefinition> tableDefinitionMap=mTableDefinitions.get(databaseName);
  if (tableDefinitionMap != null) {
    return Sets.newHashSet(mTableDefinitions.get(databaseName).values());
  }
  return Sets.newHashSet();
}"
27162,"public Set<ModelViewDefinition> getModelViewDefinitions(String databaseName){
  if (hasOneDatabase()) {
    databaseName=""String_Node_Str"";
  }
  Map<String,ModelViewDefinition> modelViewDefinitionMap=mModelViewDefinition.get(databaseName);
  if (modelViewDefinitionMap != null) {
    return Sets.newHashSet(mModelViewDefinition.get(databaseName).values());
  }
 else {
    return Sets.newHashSet();
  }
}","public Set<ModelViewDefinition> getModelViewDefinitions(String databaseName){
  Map<String,ModelViewDefinition> modelViewDefinitionMap=mModelViewDefinition.get(databaseName);
  if (modelViewDefinitionMap != null) {
    return Sets.newHashSet(mModelViewDefinition.get(databaseName).values());
  }
 else {
    return Sets.newHashSet();
  }
}"
27163,"public static boolean isSubclassOf(String columnFieldType,Class<?> enumClass){
  boolean isSubClass=false;
  try {
    Class type=Class.forName(columnFieldType);
    isSubClass=type.getSuperclass() != null && (type.getSuperclass().equals(enumClass) || isSubclassOf(type.getSuperclass().getTypeName(),enumClass));
  }
 catch (  ClassNotFoundException e) {
  }
  return isSubClass;
}","public static boolean isSubclassOf(String columnFieldType,Class<?> enumClass){
  boolean isSubClass=false;
  try {
    Class type=Class.forName(columnFieldType);
    isSubClass=type.getSuperclass() != null && (type.getSuperclass().equals(enumClass) || isSubclassOf(type.getSuperclass().getName(),enumClass));
  }
 catch (  ClassNotFoundException e) {
  }
  return isSubClass;
}"
27164,"public static String getLoadFromCursorDefinitionField(ProcessorManager processorManager,String columnFieldType,String columnFieldName,String columnName,String foreignColumnName,TypeElement modelType,boolean hasTypeConverter,boolean isModelContainerDefinition,boolean isFieldModelContainer){
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().appendVariable(isModelContainerDefinition);
  if (isFieldModelContainer) {
    queryBuilder.append(""String_Node_Str"").append(columnFieldName);
  }
  if (isModelContainerDefinition) {
    queryBuilder.appendPut(columnFieldName);
  }
 else   if (isFieldModelContainer) {
    queryBuilder.appendPut(foreignColumnName);
  }
 else {
    queryBuilder.append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"");
  }
  String newFieldType;
  if (hasTypeConverter) {
    TypeConverterDefinition typeConverterDefinition=processorManager.getTypeConverterDefinition(modelType);
    newFieldType=typeConverterDefinition.getDbElement().asType().toString();
  }
 else {
    newFieldType=columnFieldType;
  }
  String cursorStatment=ModelUtils.getCursorStatement(newFieldType,columnName);
  if (hasTypeConverter && !isModelContainerDefinition) {
    queryBuilder.appendTypeConverter(columnFieldType,columnFieldType,true);
  }
  queryBuilder.append(cursorStatment);
  if (hasTypeConverter && !isModelContainerDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isModelContainerDefinition || isFieldModelContainer) {
    queryBuilder.append(""String_Node_Str"");
  }
  return queryBuilder.getQuery();
}","public static String getLoadFromCursorDefinitionField(ProcessorManager processorManager,String columnFieldType,String columnFieldName,String columnName,String foreignColumnName,TypeElement modelType,boolean hasTypeConverter,boolean isModelContainerDefinition,boolean isFieldModelContainer){
  AdapterQueryBuilder queryBuilder=new AdapterQueryBuilder().appendVariable(isModelContainerDefinition);
  if (isFieldModelContainer) {
    queryBuilder.append(""String_Node_Str"").append(columnFieldName);
  }
  if (isModelContainerDefinition) {
    queryBuilder.appendPut(columnFieldName);
  }
 else   if (isFieldModelContainer) {
    queryBuilder.appendPut(foreignColumnName);
  }
 else {
    queryBuilder.append(""String_Node_Str"").append(columnFieldName).appendSpaceSeparated(""String_Node_Str"");
  }
  String newFieldType=null;
  if (hasTypeConverter) {
    TypeConverterDefinition typeConverterDefinition=processorManager.getTypeConverterDefinition(modelType);
    if (typeConverterDefinition != null) {
      newFieldType=typeConverterDefinition.getDbElement().asType().toString();
    }
  }
 else {
    newFieldType=columnFieldType;
  }
  String cursorStatment=ModelUtils.getCursorStatement(newFieldType,columnName);
  if (hasTypeConverter && !isModelContainerDefinition) {
    queryBuilder.appendTypeConverter(columnFieldType,columnFieldType,true);
  }
  queryBuilder.append(cursorStatment);
  if (hasTypeConverter && !isModelContainerDefinition) {
    queryBuilder.append(""String_Node_Str"");
  }
 else   if (isModelContainerDefinition || isFieldModelContainer) {
    queryBuilder.append(""String_Node_Str"");
  }
  return queryBuilder.getQuery();
}"
27165,"@Override public boolean validate(ProcessorManager processorManager,TableDefinition tableDefinition){
  boolean success=true;
  if (tableDefinition.getColumnDefinitions() == null || tableDefinition.getColumnDefinitions().isEmpty()) {
    processorManager.logError(""String_Node_Str"",tableDefinition.tableName);
    success=false;
  }
  if (tableDefinition.primaryColumnDefinitions.isEmpty()) {
    processorManager.logError(""String_Node_Str"",tableDefinition.tableName);
    success=false;
  }
  if (!ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL,(TypeElement)tableDefinition.element)) {
    processorManager.logError(""String_Node_Str"");
    success=false;
  }
  return success;
}","@Override public boolean validate(ProcessorManager processorManager,TableDefinition tableDefinition){
  boolean success=true;
  if (tableDefinition.getColumnDefinitions() == null || tableDefinition.getColumnDefinitions().isEmpty()) {
    processorManager.logError(""String_Node_Str"",tableDefinition.tableName);
    success=false;
  }
  boolean hasPrimary=(tableDefinition.autoIncrementDefinition != null && tableDefinition.primaryColumnDefinitions.isEmpty() || tableDefinition.autoIncrementDefinition == null && !tableDefinition.primaryColumnDefinitions.isEmpty());
  if (!hasPrimary) {
    processorManager.logError(""String_Node_Str"",tableDefinition.tableName);
    success=false;
  }
  if (!ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL,(TypeElement)tableDefinition.element)) {
    processorManager.logError(""String_Node_Str"");
    success=false;
  }
  return success;
}"
27166,"@Override public void write(JavaWriter javaWriter) throws IOException {
  TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
  tableCreationQuery.appendCreateTableIfNotExists(tableDefinition.tableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<QueryBuilder>();
  List<String> foreignColumnClasses=Lists.newArrayList();
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    TableCreationQueryBuilder queryBuilder=new TableCreationQueryBuilder();
    if (columnDefinition.columnType == Column.FOREIGN_KEY) {
      queryBuilder.appendSpace().appendForeignKeys(columnDefinition.foreignKeyReferences);
    }
 else {
      queryBuilder.append(columnDefinition.columnName).appendSpace();
      if (columnDefinition.hasTypeConverter) {
        TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(columnDefinition.modelType);
        queryBuilder.appendType(typeConverterDefinition.getDbElement().asType().toString());
      }
 else       if (SQLiteType.containsClass(columnDefinition.columnFieldType)) {
        queryBuilder.appendType(columnDefinition.columnFieldType);
      }
 else       if (ReflectionUtils.isSubclassOf(columnDefinition.columnFieldType,Enum.class)) {
        queryBuilder.appendSQLiteType(SQLiteType.TEXT);
      }
    }
    mColumnDefinitions.add(queryBuilder.appendColumn(columnDefinition.column));
  }
  boolean isModelView=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),tableDefinition.packageName + ""String_Node_Str"" + tableDefinition.getModelClassName(),manager.getElements().getTypeElement(Classes.MODEL_VIEW));
  if (!isModelView) {
    if (tableDefinition.primaryColumnDefinitions.isEmpty()) {
      throw new PrimaryKeyNotFoundException(""String_Node_Str"" + tableDefinition.tableName + ""String_Node_Str"");
    }
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    int count=0;
    int index=0;
    for (    ColumnDefinition field : tableDefinition.primaryColumnDefinitions) {
      if (field.columnType == Column.PRIMARY_KEY) {
        count++;
        primaryKeyQueryBuilder.append(field.columnName);
        if (index < tableDefinition.primaryColumnDefinitions.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    for (    ColumnDefinition foreignKeyField : tableDefinition.foreignKeyDefinitions) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      String[] foreignColumns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=foreignKeyField.foreignKeyReferences[i].foreignColumnName();
      }
      String[] columns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < columns.length; i++) {
        columns[i]=foreignKeyField.foreignKeyReferences[i].columnName();
      }
      foreignKeyQueryBuilder.appendArray(columns).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"");
      foreignColumnClasses.add(""String_Node_Str"" + ModelUtils.getFieldClass(foreignKeyField.columnFieldType) + ""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!tableDefinition.primaryColumnDefinitions.isEmpty() || !tableDefinition.foreignKeyDefinitions.isEmpty()) {
    manager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
  }
  tableCreationQuery.appendList(mColumnDefinitions).append(""String_Node_Str"");
  QueryBuilder returnQuery=new QueryBuilder();
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
  }
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
    returnQuery.appendList(foreignColumnClasses).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(returnQuery.getQuery(),tableCreationQuery.getQuery());
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
  tableCreationQuery.appendCreateTableIfNotExists(tableDefinition.tableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<QueryBuilder>();
  List<String> foreignColumnClasses=Lists.newArrayList();
  for (  ColumnDefinition columnDefinition : tableDefinition.getColumnDefinitions()) {
    TableCreationQueryBuilder queryBuilder=new TableCreationQueryBuilder();
    if (columnDefinition.columnType == Column.FOREIGN_KEY) {
      queryBuilder.appendSpace().appendForeignKeys(columnDefinition.foreignKeyReferences);
    }
 else {
      queryBuilder.append(columnDefinition.columnName).appendSpace();
      if (columnDefinition.hasTypeConverter) {
        TypeConverterDefinition typeConverterDefinition=manager.getTypeConverterDefinition(columnDefinition.modelType);
        if (typeConverterDefinition != null) {
          queryBuilder.appendType(typeConverterDefinition.getDbElement().asType().toString());
        }
 else {
          manager.logError(""String_Node_Str"" + columnDefinition.columnFieldType);
          queryBuilder.append(""String_Node_Str"");
        }
      }
 else       if (SQLiteType.containsClass(columnDefinition.columnFieldType)) {
        queryBuilder.appendType(columnDefinition.columnFieldType);
      }
 else       if (ReflectionUtils.isSubclassOf(columnDefinition.columnFieldType,Enum.class)) {
        queryBuilder.appendSQLiteType(SQLiteType.TEXT);
      }
    }
    mColumnDefinitions.add(queryBuilder.appendColumn(columnDefinition.column));
  }
  boolean isModelView=ProcessorUtils.implementsClass(manager.getProcessingEnvironment(),tableDefinition.packageName + ""String_Node_Str"" + tableDefinition.getModelClassName(),manager.getElements().getTypeElement(Classes.MODEL_VIEW));
  if (!isModelView) {
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    int count=0;
    int index=0;
    for (    ColumnDefinition field : tableDefinition.primaryColumnDefinitions) {
      if (field.columnType == Column.PRIMARY_KEY) {
        count++;
        primaryKeyQueryBuilder.append(field.columnName);
        if (index < tableDefinition.primaryColumnDefinitions.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    for (    ColumnDefinition foreignKeyField : tableDefinition.foreignKeyDefinitions) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      String[] foreignColumns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=foreignKeyField.foreignKeyReferences[i].foreignColumnName();
      }
      String[] columns=new String[foreignKeyField.foreignKeyReferences.length];
      for (int i=0; i < columns.length; i++) {
        columns[i]=foreignKeyField.foreignKeyReferences[i].columnName();
      }
      foreignKeyQueryBuilder.appendArray(columns).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"");
      foreignColumnClasses.add(""String_Node_Str"" + ModelUtils.getFieldClass(foreignKeyField.columnFieldType) + ""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!tableDefinition.primaryColumnDefinitions.isEmpty() || !tableDefinition.foreignKeyDefinitions.isEmpty()) {
    manager.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"");
  }
  tableCreationQuery.appendList(mColumnDefinitions).append(""String_Node_Str"");
  QueryBuilder returnQuery=new QueryBuilder();
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
  }
  returnQuery.append(""String_Node_Str"");
  if (!foreignColumnClasses.isEmpty()) {
    returnQuery.append(""String_Node_Str"");
    returnQuery.appendList(foreignColumnClasses).append(""String_Node_Str"");
  }
  javaWriter.emitStatement(returnQuery.getQuery(),tableCreationQuery.getQuery());
}"
27167,"private void writeConstructor(JavaWriter javaWriter) throws IOException {
  javaWriter.emitEmptyLine();
  javaWriter.beginConstructor(Sets.newHashSet(Modifier.PUBLIC),""String_Node_Str"",""String_Node_Str"");
  for (  TableDefinition tableDefinition : manager.getTableDefinitions(databaseName)) {
    javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getFieldClass(tableDefinition.getQualifiedModelClassName()));
  }
  for (  ModelViewDefinition modelViewDefinition : manager.getModelViewDefinitions(databaseName)) {
    javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getFieldClass(modelViewDefinition.getFullyQualifiedModelClassName()));
  }
  javaWriter.emitEmptyLine();
  javaWriter.emitSingleLineComment(""String_Node_Str"");
  Map<Integer,List<MigrationDefinition>> migrationDefinitionMap=manager.getMigrationsForDatabase(databaseName);
  if (migrationDefinitionMap != null && !migrationDefinitionMap.isEmpty()) {
    List<Integer> versionSet=new ArrayList<>(migrationDefinitionMap.keySet());
    Collections.sort(versionSet);
    for (    Integer version : versionSet) {
      List<MigrationDefinition> migrationDefinitions=migrationDefinitionMap.get(version);
      javaWriter.emitStatement(""String_Node_Str"",Classes.MIGRATION,version);
      javaWriter.emitStatement(""String_Node_Str"",FlowManagerHandler.MIGRATION_FIELD_NAME,version,""String_Node_Str"",version);
      for (      MigrationDefinition migrationDefinition : migrationDefinitions) {
        javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",version,migrationDefinition.getSourceFileName());
      }
    }
  }
  javaWriter.emitSingleLineComment(""String_Node_Str"");
  javaWriter.emitEmptyLine();
  for (  TableDefinition tableDefinition : manager.getTableDefinitions(databaseName)) {
    javaWriter.emitStatement(FlowManagerHandler.MODEL_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(tableDefinition.getQualifiedModelClassName()));
    javaWriter.emitStatement(FlowManagerHandler.MODEL_ADAPTER_MAP_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(tableDefinition.getQualifiedModelClassName()),tableDefinition.getQualifiedAdapterClassName());
  }
  for (  ModelContainerDefinition modelContainerDefinition : manager.getModelContainers(databaseName)) {
    javaWriter.emitStatement(FlowManagerHandler.MODEL_CONTAINER_ADAPTER_MAP_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(modelContainerDefinition.getModelClassQualifiedName()),modelContainerDefinition.getSourceFileName());
  }
  for (  ModelViewDefinition modelViewDefinition : manager.getModelViewDefinitions(databaseName)) {
    javaWriter.emitStatement(FlowManagerHandler.MODEL_VIEW_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(modelViewDefinition.getFullyQualifiedModelClassName()));
    javaWriter.emitStatement(FlowManagerHandler.MODEL_VIEW_ADAPTER_MAP_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(modelViewDefinition.getFullyQualifiedModelClassName()),modelViewDefinition.getSourceFileName());
  }
  javaWriter.endConstructor();
}","private void writeConstructor(JavaWriter javaWriter) throws IOException {
  javaWriter.emitEmptyLine();
  javaWriter.beginConstructor(Sets.newHashSet(Modifier.PUBLIC),""String_Node_Str"",""String_Node_Str"");
  javaWriter.emitSingleLineComment(""String_Node_Str"" + databaseName);
  for (  TableDefinition tableDefinition : manager.getTableDefinitions(databaseName)) {
    javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getFieldClass(tableDefinition.getQualifiedModelClassName()));
  }
  for (  ModelViewDefinition modelViewDefinition : manager.getModelViewDefinitions(databaseName)) {
    javaWriter.emitStatement(""String_Node_Str"",ModelUtils.getFieldClass(modelViewDefinition.getFullyQualifiedModelClassName()));
  }
  javaWriter.emitEmptyLine();
  javaWriter.emitSingleLineComment(""String_Node_Str"");
  Map<Integer,List<MigrationDefinition>> migrationDefinitionMap=manager.getMigrationsForDatabase(databaseName);
  if (migrationDefinitionMap != null && !migrationDefinitionMap.isEmpty()) {
    List<Integer> versionSet=new ArrayList<>(migrationDefinitionMap.keySet());
    Collections.sort(versionSet);
    for (    Integer version : versionSet) {
      List<MigrationDefinition> migrationDefinitions=migrationDefinitionMap.get(version);
      javaWriter.emitStatement(""String_Node_Str"",Classes.MIGRATION,version);
      javaWriter.emitStatement(""String_Node_Str"",FlowManagerHandler.MIGRATION_FIELD_NAME,version,""String_Node_Str"",version);
      for (      MigrationDefinition migrationDefinition : migrationDefinitions) {
        javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",version,migrationDefinition.getSourceFileName());
      }
    }
  }
  javaWriter.emitSingleLineComment(""String_Node_Str"");
  javaWriter.emitEmptyLine();
  for (  TableDefinition tableDefinition : manager.getTableDefinitions(databaseName)) {
    javaWriter.emitStatement(FlowManagerHandler.MODEL_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(tableDefinition.getQualifiedModelClassName()));
    javaWriter.emitStatement(FlowManagerHandler.MODEL_ADAPTER_MAP_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(tableDefinition.getQualifiedModelClassName()),tableDefinition.getQualifiedAdapterClassName());
  }
  for (  ModelContainerDefinition modelContainerDefinition : manager.getModelContainers(databaseName)) {
    javaWriter.emitStatement(FlowManagerHandler.MODEL_CONTAINER_ADAPTER_MAP_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(modelContainerDefinition.getModelClassQualifiedName()),modelContainerDefinition.getSourceFileName());
  }
  for (  ModelViewDefinition modelViewDefinition : manager.getModelViewDefinitions(databaseName)) {
    javaWriter.emitStatement(FlowManagerHandler.MODEL_VIEW_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(modelViewDefinition.getFullyQualifiedModelClassName()));
    javaWriter.emitStatement(FlowManagerHandler.MODEL_VIEW_ADAPTER_MAP_FIELD_NAME + ""String_Node_Str"",ModelUtils.getFieldClass(modelViewDefinition.getFullyQualifiedModelClassName()),modelViewDefinition.getSourceFileName());
  }
  javaWriter.endConstructor();
}"
27168,"@Override public void write(JavaWriter javaWriter) throws IOException {
  MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder(""String_Node_Str"");
  conditionQueryBuilder.appendCreation(tableDefinition.getModelClassName());
  for (int i=0; i < definition.primaryColumnDefinitions.size(); i++) {
    ColumnDefinition columnDefinition=definition.primaryColumnDefinitions.get(i);
    conditionQueryBuilder.appendMockCondition(definition.definitionClassName + ""String_Node_Str"" + columnDefinition.columnName.toUpperCase(),""String_Node_Str"");
    if (i < definition.primaryColumnDefinitions.size() - 1) {
      conditionQueryBuilder.append(""String_Node_Str"");
    }
  }
  conditionQueryBuilder.appendEndCreation();
  javaWriter.emitStatement(conditionQueryBuilder.getQuery());
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  MockConditionQueryBuilder conditionQueryBuilder=new MockConditionQueryBuilder(""String_Node_Str"");
  conditionQueryBuilder.appendCreation(tableDefinition.getModelClassName());
  int primaryColumnSize=tableDefinition.getPrimaryColumnDefinitions().size();
  if (primaryColumnSize > 0) {
    for (int i=0; i < definition.primaryColumnDefinitions.size(); i++) {
      ColumnDefinition columnDefinition=definition.primaryColumnDefinitions.get(i);
      conditionQueryBuilder.appendMockCondition(definition.definitionClassName + ""String_Node_Str"" + columnDefinition.columnName.toUpperCase(),""String_Node_Str"");
      if (i < definition.primaryColumnDefinitions.size() - 1) {
        conditionQueryBuilder.append(""String_Node_Str"");
      }
    }
  }
 else {
    ColumnDefinition autoIncrementDefinition=((TableDefinition)tableDefinition).autoIncrementDefinition;
    if (autoIncrementDefinition != null) {
      conditionQueryBuilder.appendMockCondition(definition.definitionClassName + ""String_Node_Str"" + autoIncrementDefinition.columnName.toUpperCase(),""String_Node_Str"");
    }
  }
  conditionQueryBuilder.appendEndCreation();
  javaWriter.emitStatement(conditionQueryBuilder.getQuery());
}"
27169,"/** 
 * Defines a SQL ORDER BY statement without the ORDER BY.
 * @param ascending If we should be in ascending order
 * @return
 */
public Where<ModelClass> orderBy(boolean ascending,String... columns){
  mOrderBy=new QueryBuilder().appendArray(columns).appendSpace().append(ascending ? ""String_Node_Str"" : ""String_Node_Str"").getQuery();
  return this;
}","/** 
 * Defines a SQL ORDER BY statement without the ORDER BY.
 * @param ascending If we should be in ascending order
 * @return
 */
public Where<ModelClass> orderBy(String orderby){
  mOrderBy=orderby;
  return this;
}"
27170,"public FlowSQLiteOpenHelper(BaseDatabaseDefinition flowManager){
  super(FlowManager.getContext(),flowManager.getDatabaseName(),null,flowManager.getDatabaseVersion());
  mManager=flowManager;
  movePrepackagedDB(flowManager.getDatabaseName() + ""String_Node_Str"");
}","public FlowSQLiteOpenHelper(BaseDatabaseDefinition flowManager){
  super(FlowManager.getContext(),flowManager.getDatabaseName() + ""String_Node_Str"",null,flowManager.getDatabaseVersion());
  mManager=flowManager;
  movePrepackagedDB(flowManager.getDatabaseName() + ""String_Node_Str"");
}"
27171,"/** 
 * Returns a model at the specified position. If we are using the cache and it does not contain a model at that position, we move the cursor to the specified position and construct the   {@link ModelClass}.
 * @param position The row number in the {@link android.database.Cursor} to look at
 * @return The {@link ModelClass} converted from the cursor
 */
public ModelClass getItem(int position){
  ModelClass model;
  if (cacheModels) {
    model=mModelCache.get(position);
    if (model == null && mCursor.moveToPosition(position)) {
      model=SqlUtils.convertToModel(false,mTable,mCursor);
      mModelCache.put(position,model);
    }
  }
 else {
    mCursor.moveToPosition(position);
    model=SqlUtils.convertToModel(false,mTable,mCursor);
  }
  return model;
}","/** 
 * Returns a model at the specified position. If we are using the cache and it does not contain a model at that position, we move the cursor to the specified position and construct the   {@link ModelClass}.
 * @param position The row number in the {@link android.database.Cursor} to look at
 * @return The {@link ModelClass} converted from the cursor
 */
public ModelClass getItem(int position){
  ModelClass model;
  if (cacheModels) {
    model=mModelCache.get(position);
    if (model == null && mCursor.moveToPosition(position)) {
      model=SqlUtils.convertToModel(true,mTable,mCursor);
      mModelCache.put(position,model);
    }
  }
 else {
    mCursor.moveToPosition(position);
    model=SqlUtils.convertToModel(true,mTable,mCursor);
  }
  return model;
}"
27172,"/** 
 * Takes first   {@link ModelClass} from the cursor
 * @param isList       If it's a list, do not reset the cursor
 * @param table        The model class that we convert the cursor data into.
 * @param cursor       The cursor from the DB
 * @param < ModelClass >
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>ModelClass convertToModel(boolean isList,Class<ModelClass> table,Cursor cursor){
  ModelClass model=null;
  try {
    if (isList || cursor.moveToFirst()) {
      ModelAdapter<ModelClass> modelAdapter=FlowManager.getModelAdapter(table);
      if (modelAdapter == null) {
        Class persistentClass=(Class)((ParameterizedType)table.getGenericSuperclass()).getActualTypeArguments()[0];
        if (persistentClass.isAssignableFrom(BaseModelView.class)) {
          model=(ModelClass)FlowManager.getModelViewAdapter((Class<? extends BaseModelView<? extends Model>>)table).loadFromCursor(cursor);
        }
      }
 else {
        model=modelAdapter.loadFromCursor(cursor);
      }
    }
  }
 catch (  Exception e) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"",e);
  }
  return model;
}","/** 
 * Takes first   {@link ModelClass} from the cursor
 * @param dontMoveToFirst If it's a list or at a specific position, do not reset the cursor
 * @param table           The model class that we convert the cursor data into.
 * @param cursor          The cursor from the DB
 * @param < ModelClass >
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>ModelClass convertToModel(boolean dontMoveToFirst,Class<ModelClass> table,Cursor cursor){
  ModelClass model=null;
  try {
    if (dontMoveToFirst || cursor.moveToFirst()) {
      ModelAdapter<ModelClass> modelAdapter=FlowManager.getModelAdapter(table);
      if (modelAdapter == null) {
        Class persistentClass=(Class)((ParameterizedType)table.getGenericSuperclass()).getActualTypeArguments()[0];
        if (persistentClass.isAssignableFrom(BaseModelView.class)) {
          model=(ModelClass)FlowManager.getModelViewAdapter((Class<? extends BaseModelView<? extends Model>>)table).loadFromCursor(cursor);
        }
      }
 else {
        model=modelAdapter.loadFromCursor(cursor);
      }
    }
  }
 catch (  Exception e) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"",e);
  }
  return model;
}"
27173,"@SuppressWarnings(""String_Node_Str"") public static void putField(ContentValues values,FlowManager flowManager,Field field,String fieldName,Object value){
  Class<?> fieldType=field.getType();
  if (value != null && !StructureUtils.isForeignKey(field)) {
    final TypeConverter typeSerializer=flowManager.getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      value=typeSerializer.getDBValue(value);
      if (value != null) {
        fieldType=value.getClass();
        if (!fieldType.equals(typeSerializer.getDatabaseType())) {
          FlowLog.log(FlowLog.Level.W,String.format(TypeConverter.class.getSimpleName() + ""String_Node_Str"",typeSerializer.getDatabaseType(),fieldType));
        }
      }
    }
  }
  if (value == null) {
    values.putNull(fieldName);
  }
 else   if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
    values.put(fieldName,(Byte)value);
  }
 else   if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
    values.put(fieldName,(Short)value);
  }
 else   if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
    values.put(fieldName,(Integer)value);
  }
 else   if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
    values.put(fieldName,(Long)value);
  }
 else   if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
    values.put(fieldName,(Float)value);
  }
 else   if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
    values.put(fieldName,(Double)value);
  }
 else   if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
    values.put(fieldName,(Boolean)value);
  }
 else   if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(String.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
    values.put(fieldName,(byte[])value);
  }
 else   if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
    Column key=field.getAnnotation(Column.class);
    Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
    if (value instanceof JSONObject) {
      JSONObject jsonObject=((JSONObject)value);
      JSONModel<? extends Model> jsonModel=new JSONModel<Model>(jsonObject,(Class<Model>)entityType);
      jsonModel.save(false);
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        Object jsonValue=jsonObject.opt(foreignKeyReference.foreignColumnName());
        field.setAccessible(true);
        SqlUtils.putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),jsonValue);
      }
    }
 else {
      try {
        Model model=(Model)field.get(value);
        model.save(false);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(e);
      }
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        foreignColumnField.setAccessible(true);
        try {
          putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),foreignColumnField.get(value));
        }
 catch (        IllegalAccessException e) {
          FlowLog.logError(e);
        }
      }
    }
  }
 else   if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
    values.put(fieldName,((Enum<?>)value).name());
  }
}","@SuppressWarnings(""String_Node_Str"") public static void putField(ContentValues values,FlowManager flowManager,Field field,String fieldName,Object value){
  Class<?> fieldType=field.getType();
  if (value != null && !StructureUtils.isForeignKey(field)) {
    final TypeConverter typeSerializer=flowManager.getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      value=typeSerializer.getDBValue(value);
      if (value != null) {
        fieldType=value.getClass();
        if (!fieldType.equals(typeSerializer.getDatabaseType())) {
          FlowLog.log(FlowLog.Level.W,String.format(TypeConverter.class.getSimpleName() + ""String_Node_Str"",typeSerializer.getDatabaseType(),fieldType));
        }
      }
    }
  }
  if (value == null) {
    values.putNull(fieldName);
  }
 else   if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
    values.put(fieldName,(Byte)value);
  }
 else   if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
    values.put(fieldName,(Short)value);
  }
 else   if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
    values.put(fieldName,(Integer)value);
  }
 else   if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
    values.put(fieldName,(Long)value);
  }
 else   if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
    values.put(fieldName,(Float)value);
  }
 else   if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
    values.put(fieldName,(Double)value);
  }
 else   if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
    values.put(fieldName,(Boolean)value);
  }
 else   if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(String.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
    values.put(fieldName,(byte[])value);
  }
 else   if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
    Column key=field.getAnnotation(Column.class);
    Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
    if (value instanceof ModelContainer || ModelContainerMap.containsValue(value)) {
      ModelContainer<? extends Model,?> modelContainer=ModelContainerMap.getModelContainerInstance(entityType,value);
      modelContainer.save(false);
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        Object jsonValue=modelContainer.getValue(foreignKeyReference.foreignColumnName());
        field.setAccessible(true);
        SqlUtils.putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),jsonValue);
      }
    }
 else {
      try {
        Model model=(Model)field.get(value);
        model.save(false);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(e);
      }
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        foreignColumnField.setAccessible(true);
        try {
          putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),foreignColumnField.get(value));
        }
 catch (        IllegalAccessException e) {
          FlowLog.logError(e);
        }
      }
    }
  }
 else   if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
    values.put(fieldName,((Enum<?>)value).name());
  }
}"
27174,protected abstract Object getValue(String columnName);,@Override public abstract Object getValue(String columnName);
27175,"public BaseModelContainer(Class<ModelClass> table){
  mTableStructure=FlowManager.getManagerForTable(table).getTableStructureForClass(table);
}","public BaseModelContainer(Class<ModelClass> table,DataClass data){
  mTableStructure=FlowManager.getManagerForTable(table).getTableStructureForClass(table);
  mData=data;
}"
27176,"protected abstract void put(String columnName,Object value);","@Override public abstract void put(String columnName,Object value);"
27177,"/** 
 * Constructs this object with an empty   {@link org.json.JSONObject} referencing the {@link ModelClass} table.
 * @param table The table of the referenced model
 */
public JSONModel(Class<ModelClass> table){
  this(new JSONObject(),table);
}","/** 
 * Constructs this object with an empty   {@link org.json.JSONObject} referencing the {@link ModelClass} table.
 * @param table The table of the referenced model
 */
public JSONModel(Class<ModelClass> table){
  super(table,new JSONObject());
}"
27178,"@Override protected Object getValue(String columnName){
  return mJson.opt(columnName);
}","@Override public Object getValue(String columnName){
  return getData().opt(columnName);
}"
27179,"/** 
 * Loads a model from the DB into the json stored in this class. It also will recreate the JSON stored in this object
 * @param primaryKeys The keys to reference
 */
public void load(Object... primaryKeys){
  mJson=new JSONObject();
  ConditionQueryBuilder<ModelClass> primaryQuery=FlowManager.getPrimaryWhereQuery(getTable());
  load(new Select().from(mTableStructure.getModelType()).where(primaryQuery.replaceEmptyParams(primaryKeys)).query());
}","/** 
 * Loads a model from the DB into the json stored in this class. It also will recreate the JSON stored in this object
 * @param primaryKeys The keys to reference
 */
public void load(Object... primaryKeys){
  setData(new JSONObject());
  ConditionQueryBuilder<ModelClass> primaryQuery=FlowManager.getPrimaryWhereQuery(getTable());
  load(new Select().from(mTableStructure.getModelType()).where(primaryQuery.replaceEmptyParams(primaryKeys)).query());
}"
27180,"@Override protected void put(String columnName,Object value){
  try {
    mJson.put(columnName,value);
  }
 catch (  JSONException e) {
    FlowLog.logError(e);
  }
}","@Override public void put(String columnName,Object value){
  try {
    getData().put(columnName,value);
  }
 catch (  JSONException e) {
    FlowLog.logError(e);
  }
}"
27181,"@Override protected Object getValue(String columnName){
  return mDatamap.get(columnName);
}","@Override public Object getValue(String columnName){
  return getData().get(columnName);
}"
27182,"public MapModel(Class<ModelClass> table){
  this(table,new HashMap<String,Object>());
}","public MapModel(Class<ModelClass> table){
  this(new HashMap<String,Object>(),table);
}"
27183,"@Override protected void put(String columnName,Object value){
  mDatamap.put(columnName,value);
}","@Override public void put(String columnName,Object value){
  getData().put(columnName,value);
}"
27184,"/** 
 * {@inheritDoc}
 * @param annotations
 * @param roundEnv
 */
@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){
  final Set<? extends Element> annotatedElements=roundEnv.getElementsAnnotatedWith(Table.class);
  if (annotatedElements.size() > 0) {
    Iterator<? extends Element> iterator=annotatedElements.iterator();
    while (iterator.hasNext()) {
      Element element=iterator.next();
      System.out.println(element.asType());
      try {
        final String packageName=processingEnv.getElementUtils().getPackageOf(element).toString();
        TableDefinition tableDefinition=new TableDefinition(packageName,element);
        JavaWriter javaWriter=new JavaWriter(processingEnv.getFiler().createSourceFile(tableDefinition.getFQCN()).openWriter());
        tableDefinition.write(javaWriter);
        javaWriter.close();
        tableDefinition.writeAdapter(processingEnv);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 * @param annotations
 * @param roundEnv
 */
@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){
  final Set<? extends Element> annotatedElements=roundEnv.getElementsAnnotatedWith(Table.class);
  if (annotatedElements.size() > 0) {
    Iterator<? extends Element> iterator=annotatedElements.iterator();
    while (iterator.hasNext()) {
      Element element=iterator.next();
      System.out.println(element.asType());
      try {
        final String packageName=processingEnv.getElementUtils().getPackageOf(element).toString();
        TableDefinition tableDefinition=new TableDefinition(processingEnv,packageName,element);
        JavaWriter javaWriter=new JavaWriter(processingEnv.getFiler().createSourceFile(tableDefinition.getFQCN()).openWriter());
        tableDefinition.write(javaWriter);
        javaWriter.close();
        tableDefinition.writeAdapter(processingEnv);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return true;
}"
27185,"public void writeContentValue(JavaWriter javaWriter) throws IOException {
  javaWriter.emitStatement(""String_Node_Str"");
}","public void writeContentValue(JavaWriter javaWriter) throws IOException {
  if (columnType == Column.FOREIGN_KEY && isModel) {
    javaWriter.emitEmptyLine();
    if (isModelContainer) {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
 else {
      javaWriter.emitSingleLineComment(""String_Node_Str"");
    }
    javaWriter.emitStatement(getModelStatement(columnFieldName) + ""String_Node_Str"");
    for (    ForeignKeyReference foreignKeyReference : foreignKeyReferences) {
      String contentValueString=columnFieldName + ""String_Node_Str"";
      if (isModelContainer) {
      }
 else {
        contentValueString+=foreignKeyReference.foreignColumnName();
      }
      javaWriter.emitStatement(getContentStatement(foreignKeyReference.columnName(),contentValueString));
    }
  }
 else {
    javaWriter.emitStatement(getContentStatement(columnName,columnFieldName));
  }
}"
27186,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitField(""String_Node_Str"",columnName.toUpperCase(),Sets.newHashSet(Modifier.PUBLIC,Modifier.STATIC,Modifier.FINAL),""String_Node_Str"" + columnName + ""String_Node_Str"");
  javaWriter.emitEmptyLine();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  if (isModel || isModelContainer) {
    for (    ForeignKeyReference reference : foreignKeyReferences) {
      writeColumnDefinition(javaWriter,(columnName + ""String_Node_Str"" + reference.columnName()).toUpperCase(),reference.columnName());
    }
  }
 else {
    writeColumnDefinition(javaWriter,columnName);
  }
}"
27187,"public ColumnDefinition(VariableElement element){
  this.element=element;
  Column column=element.getAnnotation(Column.class);
  this.columnName=column.name();
  this.columnFieldName=element.getSimpleName().toString();
  this.columnFieldType=element.asType().toString();
  columnType=column.columnType();
}","public ColumnDefinition(ProcessingEnvironment processingEnvironment,VariableElement element){
  this.element=element;
  Column column=element.getAnnotation(Column.class);
  this.columnName=column.name().equals(""String_Node_Str"") ? element.getSimpleName().toString() : column.name();
  this.columnFieldName=element.getSimpleName().toString();
  this.columnFieldType=element.asType().toString();
  columnType=column.columnType();
  if (columnType == Column.FOREIGN_KEY) {
    foreignKeyReferences=column.references();
  }
  isModel=ProcessorUtils.implementsClass(processingEnvironment,""String_Node_Str"",element);
  isModelContainer=ProcessorUtils.implementsClass(processingEnvironment,""String_Node_Str"",element);
}"
27188,"public ContentValuesWriter(String tableName,String modelClassName,ArrayList<ColumnDefinition> columnDefinitions){
  this.columnDefinitions=columnDefinitions;
  this.modelClassName=modelClassName;
  this.tableName=tableName;
}","public ContentValuesWriter(TableDefinition tableDefinition){
  this.tableDefinition=tableDefinition;
}"
27189,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitEmptyLine();
  javaWriter.emitAnnotation(Override.class);
  javaWriter.beginMethod(""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC),modelClassName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  javaWriter.emitStatement(""String_Node_Str"");
  for (  ColumnDefinition columnDefinition : columnDefinitions) {
    javaWriter.emitStatement(""String_Node_Str"",columnDefinition.columnName,""String_Node_Str"" + columnDefinition.columnFieldName);
  }
  javaWriter.emitStatement(""String_Node_Str"",tableName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  javaWriter.endMethod();
  javaWriter.emitEmptyLine();
  javaWriter.emitAnnotation(Override.class);
  javaWriter.beginMethod(""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC),""String_Node_Str"",""String_Node_Str"");
  javaWriter.endMethod();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitEmptyLine();
  javaWriter.emitAnnotation(Override.class);
  javaWriter.beginMethod(""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC),""String_Node_Str"",""String_Node_Str"",tableDefinition.modelClassName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  javaWriter.emitStatement(""String_Node_Str"");
  for (  ColumnDefinition columnDefinition : tableDefinition.columnDefinitions) {
    columnDefinition.writeContentValue(javaWriter);
  }
  javaWriter.emitEmptyLine();
  javaWriter.emitStatement(""String_Node_Str"",""String_Node_Str"",tableDefinition.tableName,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  javaWriter.endMethod();
}"
27190,"@Override public String getFQCN(){
  return packageName + ""String_Node_Str"" + className;
}","@Override public String getFQCN(){
  return packageName + ""String_Node_Str"" + tableSourceClassName;
}"
27191,"public TableDefinition(String packageName,Element element){
  this.element=element;
  this.packageName=packageName;
  this.className=element.getSimpleName() + DBFLOW_TABLE_TAG;
  this.adapterName=element.getSimpleName() + DBFLOW_TABLE_ADAPTER;
  this.tableName=element.getAnnotation(Table.class).name();
  columnDefinitions=getColumnDefinitions(element);
  mContentValuesWriter=new ContentValuesWriter(tableName,element.getSimpleName().toString(),columnDefinitions);
}","public TableDefinition(ProcessingEnvironment processingEnvironment,String packageName,Element element){
  this.element=element;
  this.packageName=packageName;
  this.modelClassName=element.getSimpleName().toString();
  this.tableSourceClassName=modelClassName + DBFLOW_TABLE_TAG;
  this.adapterName=modelClassName + DBFLOW_TABLE_ADAPTER;
  this.tableName=element.getAnnotation(Table.class).name();
  this.processingEnvironment=processingEnvironment;
  columnDefinitions=new ArrayList<>();
  primaryColumnDefinitions=new ArrayList<>();
  getColumnDefinitions(element);
  mContentValuesWriter=new ContentValuesWriter(this);
  mWhereQueryWriter=new WhereQueryWriter(this);
  mLoadCursorWriter=new LoadCursorWriter(this);
}"
27192,"public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),null,""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  mContentValuesWriter.write(javaWriter);
  javaWriter.endType();
  javaWriter.close();
}","public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),null,""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  mContentValuesWriter.write(javaWriter);
  mLoadCursorWriter.write(javaWriter);
  mWhereQueryWriter.write(javaWriter);
  javaWriter.endType();
  javaWriter.close();
}"
27193,"private static ArrayList<ColumnDefinition> getColumnDefinitions(Element element){
  List<VariableElement> variableElements=ElementFilter.fieldsIn(element.getEnclosedElements());
  ArrayList<ColumnDefinition> columns=new ArrayList<>();
  for (  VariableElement variableElement : variableElements) {
    if (variableElement.getAnnotation(Column.class) != null) {
      columns.add(new ColumnDefinition(variableElement));
    }
  }
  return columns;
}","private void getColumnDefinitions(Element element){
  List<VariableElement> variableElements=ElementFilter.fieldsIn(element.getEnclosedElements());
  for (  VariableElement variableElement : variableElements) {
    if (variableElement.getAnnotation(Column.class) != null) {
      ColumnDefinition columnDefinition=new ColumnDefinition(processingEnvironment,variableElement);
      columnDefinitions.add(columnDefinition);
      if (columnDefinition.columnType == Column.PRIMARY_KEY) {
        primaryColumnDefinitions.add(columnDefinition);
      }
    }
  }
}"
27194,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitPackage(packageName);
  javaWriter.beginType(className,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  javaWriter.emitEmptyLine();
  for (  ColumnDefinition columnDefinition : columnDefinitions) {
    columnDefinition.write(javaWriter);
  }
  javaWriter.endType();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitPackage(packageName);
  javaWriter.beginType(tableSourceClassName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL));
  javaWriter.emitEmptyLine();
  javaWriter.emitField(""String_Node_Str"",""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.STATIC,Modifier.FINAL),""String_Node_Str"" + tableName + ""String_Node_Str"");
  javaWriter.emitEmptyLine();
  for (  ColumnDefinition columnDefinition : columnDefinitions) {
    columnDefinition.write(javaWriter);
  }
  javaWriter.endType();
}"
27195,"public void testUpdateEffect(){
  TestUpdateModel testUpdateModel=new TestUpdateModel();
  testUpdateModel.name=""String_Node_Str"";
  testUpdateModel.value=""String_Node_Str"";
  testUpdateModel.save(false);
  assertNotNull(TransactionManager.getInstance().selectModelById(TestUpdateModel.class,""String_Node_Str""));
  new Update().table(TestUpdateModel.class).set(Condition.column(""String_Node_Str"").is(""String_Node_Str"")).where().query();
  TestUpdateModel newUpdateModel=TransactionManager.getInstance().selectModelById(TestUpdateModel.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",newUpdateModel.value);
}","public void testUpdateEffect(){
  TestUpdateModel testUpdateModel=new TestUpdateModel();
  testUpdateModel.name=""String_Node_Str"";
  testUpdateModel.value=""String_Node_Str"";
  testUpdateModel.save(false);
  assertNotNull(Select.byId(TestUpdateModel.class,""String_Node_Str""));
  new Update().table(TestUpdateModel.class).set(Condition.column(""String_Node_Str"").is(""String_Node_Str"")).where().query();
  TestUpdateModel newUpdateModel=Select.byId(TestUpdateModel.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",newUpdateModel.value);
}"
27196,"/** 
 * Tests to ensure the model view operates as expected
 */
public void testModelView(){
  TestModel2 testModel2=new TestModel2();
  testModel2.order=6;
  testModel2.name=""String_Node_Str"";
  testModel2.save(false);
  testModel2=new TestModel2();
  testModel2.order=5;
  testModel2.name=""String_Node_Str"";
  testModel2.save(false);
  TransactionManager transactionManager=new TransactionManager(""String_Node_Str"",false);
  List<TestModelView> testModelViews=transactionManager.selectAllFromTable(TestModelView.class);
  assertTrue(!testModelViews.isEmpty());
  assertTrue(testModelViews.size() == 1);
}","/** 
 * Tests to ensure the model view operates as expected
 */
public void testModelView(){
  TestModel2 testModel2=new TestModel2();
  testModel2.order=6;
  testModel2.name=""String_Node_Str"";
  testModel2.save(false);
  testModel2=new TestModel2();
  testModel2.order=5;
  testModel2.name=""String_Node_Str"";
  testModel2.save(false);
  TransactionManager transactionManager=new TransactionManager(""String_Node_Str"",false);
  List<TestModelView> testModelViews=Select.all(TestModelView.class);
  assertTrue(!testModelViews.isEmpty());
  assertTrue(testModelViews.size() == 1);
}"
27197,"public void testConverters(){
  TestType testType=new TestType();
  testType.name=""String_Node_Str"";
  long testTime=System.currentTimeMillis();
  Calendar calendar=Calendar.getInstance();
  calendar.setTimeInMillis(testTime);
  testType.calendar=calendar;
  Date date=new Date(testTime);
  testType.date=date;
  java.sql.Date date1=new java.sql.Date(testTime);
  testType.sqlDate=date1;
  JSONObject jsonObject=null;
  try {
    jsonObject=new JSONObject(""String_Node_Str"");
    testType.json=jsonObject;
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  Location location=new Location(""String_Node_Str"");
  location.setLatitude(40.5);
  location.setLongitude(40.5);
  testType.location=location;
  testType.save(false);
  TestType retrieved=TransactionManager.getInstance().selectModelById(TestType.class,""String_Node_Str"");
  assertNotNull(retrieved);
  assertNotNull(retrieved.calendar);
  assertTrue(retrieved.calendar.equals(calendar));
  assertNotNull(retrieved.date);
  assertTrue(retrieved.date.equals(date));
  assertNotNull(retrieved.sqlDate);
  assertTrue(retrieved.sqlDate.equals(date1));
  assertNotNull(retrieved.json);
  assertTrue(retrieved.json.toString().equals(jsonObject.toString()));
  assertNotNull(retrieved.location);
  assertTrue(retrieved.location.getLongitude() == location.getLongitude());
  assertTrue(retrieved.location.getLatitude() == location.getLatitude());
}","public void testConverters(){
  TestType testType=new TestType();
  testType.name=""String_Node_Str"";
  long testTime=System.currentTimeMillis();
  Calendar calendar=Calendar.getInstance();
  calendar.setTimeInMillis(testTime);
  testType.calendar=calendar;
  Date date=new Date(testTime);
  testType.date=date;
  java.sql.Date date1=new java.sql.Date(testTime);
  testType.sqlDate=date1;
  JSONObject jsonObject=null;
  try {
    jsonObject=new JSONObject(""String_Node_Str"");
    testType.json=jsonObject;
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
  Location location=new Location(""String_Node_Str"");
  location.setLatitude(40.5);
  location.setLongitude(40.5);
  testType.location=location;
  testType.save(false);
  TestType retrieved=Select.byId(TestType.class,""String_Node_Str"");
  assertNotNull(retrieved);
  assertNotNull(retrieved.calendar);
  assertTrue(retrieved.calendar.equals(calendar));
  assertNotNull(retrieved.date);
  assertTrue(retrieved.date.equals(date));
  assertNotNull(retrieved.sqlDate);
  assertTrue(retrieved.sqlDate.equals(date1));
  assertNotNull(retrieved.json);
  assertTrue(retrieved.json.toString().equals(jsonObject.toString()));
  assertNotNull(retrieved.location);
  assertTrue(retrieved.location.getLongitude() == location.getLongitude());
  assertTrue(retrieved.location.getLatitude() == location.getLatitude());
}"
27198,"/** 
 * Deletes all items from the table. Be careful as this will clear data!
 */
@Override public void clear(){
  if (transact) {
    TransactionManager.getInstance().delete(MODIFICATION_INFO,mCursorList.getTable());
  }
 else {
    TransactionManager.getInstance().delete(mCursorList.getTable());
  }
  mInternalResultReceiver.onResultReceived(null);
}","/** 
 * Deletes all items from the table. Be careful as this will clear data!
 */
@Override public void clear(){
  if (transact) {
    TransactionManager.getInstance().delete(MODIFICATION_INFO,mCursorList.getTable());
  }
 else {
    Delete.table(mCursorList.getTable());
  }
  mInternalResultReceiver.onResultReceived(null);
}"
27199,"/** 
 * If the processor class is annotated with   {@link javax.annotation.processing.SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
@Override public Set<String> getSupportedAnnotationTypes(){
  Set<String> supportedTypes=new LinkedHashSet<String>();
  supportedTypes.add(Table.class.getName());
  supportedTypes.add(Column.class.getName());
  return supportedTypes;
}","/** 
 * If the processor class is annotated with   {@link javax.annotation.processing.SupportedAnnotationTypes}, return an unmodifiable set with the same set of strings as the annotation.  If the class is not so annotated, an empty set is returned.
 * @return the names of the annotation types supported by thisprocessor, or an empty set if none
 */
@Override public Set<String> getSupportedAnnotationTypes(){
  Set<String> supportedTypes=new LinkedHashSet<String>();
  supportedTypes.add(Table.class.getName());
  supportedTypes.add(Column.class.getName());
  supportedTypes.add(TypeConverter.class.getName());
  supportedTypes.add(ContainerAdapter.class.getName());
  return supportedTypes;
}"
27200,"public static boolean implementsClass(ProcessingEnvironment processingEnvironment,String fqTn,TypeElement element){
  TypeElement typeElement=processingEnvironment.getElementUtils().getTypeElement(fqTn);
  if (typeElement == null) {
    processingEnvironment.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"" + fqTn);
    return false;
  }
 else {
    TypeMirror classMirror=typeElement.asType();
    return processingEnvironment.getTypeUtils().isAssignable(element.asType(),classMirror);
  }
}","public static boolean implementsClass(ProcessingEnvironment processingEnvironment,String fqTn,TypeElement element){
  TypeElement typeElement=processingEnvironment.getElementUtils().getTypeElement(fqTn);
  if (typeElement == null) {
    processingEnvironment.getMessager().printMessage(Diagnostic.Kind.ERROR,""String_Node_Str"" + fqTn + ""String_Node_Str""+ ""String_Node_Str"");
    return false;
  }
 else {
    TypeMirror classMirror=typeElement.asType();
    return processingEnvironment.getTypeUtils().isAssignable(element.asType(),classMirror);
  }
}"
27201,"protected void writeColumnDefinition(JavaWriter javaWriter,String fieldName,String columnName) throws IOException {
  javaWriter.emitField(""String_Node_Str"",fieldName,Sets.newHashSet(Modifier.PUBLIC,Modifier.STATIC,Modifier.FINAL),""String_Node_Str"" + columnName + ""String_Node_Str"");
  javaWriter.emitEmptyLine();
}","/** 
 * When the field name is different from the column name (foreign key names)
 * @param javaWriter
 * @param fieldName
 * @param columnName
 * @throws IOException
 */
protected void writeColumnDefinition(JavaWriter javaWriter,String fieldName,String columnName) throws IOException {
  javaWriter.emitField(""String_Node_Str"",fieldName,Sets.newHashSet(Modifier.PUBLIC,Modifier.STATIC,Modifier.FINAL),""String_Node_Str"" + columnName + ""String_Node_Str"");
  javaWriter.emitEmptyLine();
}"
27202,"public ColumnDefinition(ProcessorManager processorManager,VariableElement element){
  this.element=element;
  column=element.getAnnotation(Column.class);
  this.columnName=column.name().equals(""String_Node_Str"") ? element.getSimpleName().toString() : column.name();
  this.columnFieldName=element.getSimpleName().toString();
  this.columnFieldType=element.asType().toString();
  if (element.asType().getKind().isPrimitive()) {
    this.modelType=processorManager.getTypeUtils().boxedClass((PrimitiveType)element.asType());
  }
 else {
    this.modelType=processorManager.getElements().getTypeElement(element.asType().toString());
  }
  columnType=column.columnType();
  if (columnType == Column.FOREIGN_KEY) {
    foreignKeyReferences=column.references();
  }
  isModel=ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL,modelType);
  final TypeConverterDefinition typeConverterDefinition=processorManager.getTypeConverterDefinition(modelType);
  if (typeConverterDefinition != null) {
    databaseType=typeConverterDefinition.getDbElement();
  }
 else {
    databaseType=modelType;
  }
  isModelContainer=ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL_CONTAINER,modelType);
}","public ColumnDefinition(ProcessorManager processorManager,VariableElement element){
  this.processorManager=processorManager;
  this.element=element;
  column=element.getAnnotation(Column.class);
  this.columnName=column.name().equals(""String_Node_Str"") ? element.getSimpleName().toString() : column.name();
  this.columnFieldName=element.getSimpleName().toString();
  this.columnFieldType=element.asType().toString();
  if (element.asType().getKind().isPrimitive()) {
    this.modelType=processorManager.getTypeUtils().boxedClass((PrimitiveType)element.asType());
  }
 else {
    DeclaredType declaredType=(DeclaredType)element.asType();
    if (!declaredType.getTypeArguments().isEmpty()) {
      isModelContainer=true;
      modelContainerType=columnFieldType;
      this.modelType=(TypeElement)processorManager.getTypeUtils().asElement(declaredType.getTypeArguments().get(0));
      columnFieldType=modelType.asType().toString();
    }
 else {
      this.modelType=processorManager.getElements().getTypeElement(element.asType().toString());
    }
  }
  columnType=column.columnType();
  if (columnType == Column.FOREIGN_KEY) {
    foreignKeyReferences=column.references();
  }
  isModel=ProcessorUtils.implementsClass(processorManager.getProcessingEnvironment(),Classes.MODEL,modelType);
  final TypeConverterDefinition typeConverterDefinition=processorManager.getTypeConverterDefinition(modelType);
  if (typeConverterDefinition != null) {
    hasTypeConverter=true;
  }
  if (!hasTypeConverter && !isModel) {
    hasTypeConverter=!SQLiteType.containsClass(columnFieldType);
  }
}"
27203,"@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.CONDITION_QUERY_BUILDER,Classes.MODEL_CONTAINER,Classes.MODEL_CONTAINER_UTILS,Classes.CONTAINER_ADAPTER,Classes.MODEL,Classes.CONTENT_VALUES,Classes.CURSOR,Classes.SQL_UTILS,Classes.SELECT,Classes.DELETE,Classes.CONDITION,Classes.TRANSACTION_MANAGER,Classes.PROCESS_MODEL_INFO,Classes.DBTRANSACTION_INFO);
  javaWriter.beginType(sourceFileName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + classElement.getSimpleName() + ""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,getModelClassQualifiedName());
  InternalAdapterHelper.writeGetTableName(javaWriter,classElement.getSimpleName().toString() + TableDefinition.DBFLOW_TABLE_TAG);
  mContentValuesWriter.write(javaWriter);
  mExistenceWriter.write(javaWriter);
  mWhereQueryWriter.write(javaWriter);
  mToModelWriter.write(javaWriter);
  mLoadCursorWriter.write(javaWriter);
  mDeleteWriter.write(javaWriter);
  javaWriter.endType();
  javaWriter.close();
}","@Override public void write(JavaWriter javaWriter) throws IOException {
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.FLOW_MANAGER,Classes.CONDITION_QUERY_BUILDER,Classes.MODEL_CONTAINER,Classes.MODEL_CONTAINER_UTILS,Classes.CONTAINER_ADAPTER,Classes.MODEL,Classes.CONTENT_VALUES,Classes.CURSOR,Classes.SQL_UTILS,Classes.SELECT,Classes.DELETE,Classes.CONDITION,Classes.TRANSACTION_MANAGER,Classes.PROCESS_MODEL_INFO,Classes.DBTRANSACTION_INFO);
  javaWriter.beginType(sourceFileName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + classElement.getSimpleName() + ""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,getModelClassQualifiedName());
  InternalAdapterHelper.writeGetTableName(javaWriter,classElement.getSimpleName().toString() + TableDefinition.DBFLOW_TABLE_TAG);
  mContentValuesWriter.write(javaWriter);
  mExistenceWriter.write(javaWriter);
  mWhereQueryWriter.write(javaWriter);
  mToModelWriter.write(javaWriter);
  mLoadCursorWriter.write(javaWriter);
  mDeleteWriter.write(javaWriter);
  javaWriter.endType();
  javaWriter.close();
}"
27204,"public TableDefinition(ProcessorManager manager,String packageName,Element element){
  this.element=element;
  this.packageName=packageName;
  this.modelClassName=element.getSimpleName().toString();
  this.tableSourceClassName=modelClassName + DBFLOW_TABLE_TAG;
  this.adapterName=modelClassName + DBFLOW_TABLE_ADAPTER;
  this.tableName=element.getAnnotation(Table.class).name();
  this.manager=manager;
  columnDefinitions=new ArrayList<>();
  primaryColumnDefinitions=new ArrayList<>();
  foreignKeyDefinitions=new ArrayList<>();
  getColumnDefinitions((TypeElement)element);
  mContentValuesWriter=new ContentValuesWriter(this,false);
  mWhereQueryWriter=new WhereQueryWriter(this,false);
  mLoadCursorWriter=new LoadCursorWriter(this,false);
  mExistenceWriter=new ExistenceWriter(this,false);
  mCreationQueryWriter=new CreationQueryWriter(manager,this);
  mDeleteWriter=new DeleteWriter(this,false);
}","public TableDefinition(ProcessorManager manager,String packageName,Element element){
  this.element=element;
  this.packageName=packageName;
  this.modelClassName=element.getSimpleName().toString();
  this.tableSourceClassName=modelClassName + DBFLOW_TABLE_TAG;
  this.adapterName=modelClassName + DBFLOW_TABLE_ADAPTER;
  this.tableName=element.getAnnotation(Table.class).name();
  if (tableName == null || tableName.isEmpty()) {
    tableName=element.getSimpleName().toString();
  }
  this.manager=manager;
  columnDefinitions=new ArrayList<>();
  primaryColumnDefinitions=new ArrayList<>();
  foreignKeyDefinitions=new ArrayList<>();
  getColumnDefinitions((TypeElement)element);
  mContentValuesWriter=new ContentValuesWriter(this,false);
  mWhereQueryWriter=new WhereQueryWriter(this,false);
  mLoadCursorWriter=new LoadCursorWriter(this,false);
  mExistenceWriter=new ExistenceWriter(this,false);
  mCreationQueryWriter=new CreationQueryWriter(manager,this);
  mDeleteWriter=new DeleteWriter(this,false);
}"
27205,"public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.MODEL_ADAPTER,Classes.CONDITION_QUERY_BUILDER,Classes.CURSOR,Classes.CONTENT_VALUES,Classes.SQL_UTILS,Classes.SELECT,Classes.CONDITION,Classes.DELETE,Classes.TRANSACTION_MANAGER,Classes.PROCESS_MODEL_INFO,Classes.DBTRANSACTION_INFO);
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,modelClassName);
  InternalAdapterHelper.writeGetTableName(javaWriter,tableSourceClassName);
  mContentValuesWriter.write(javaWriter);
  mExistenceWriter.write(javaWriter);
  mLoadCursorWriter.write(javaWriter);
  mWhereQueryWriter.write(javaWriter);
  mCreationQueryWriter.write(javaWriter);
  mDeleteWriter.write(javaWriter);
  javaWriter.endType();
  javaWriter.close();
}","public void writeAdapter(ProcessingEnvironment processingEnvironment) throws IOException {
  JavaWriter javaWriter=new JavaWriter(processingEnvironment.getFiler().createSourceFile(packageName + ""String_Node_Str"" + adapterName).openWriter());
  javaWriter.emitPackage(packageName);
  javaWriter.emitImports(Classes.MODEL_ADAPTER,Classes.FLOW_MANAGER,Classes.CONDITION_QUERY_BUILDER,Classes.CURSOR,Classes.CONTENT_VALUES,Classes.SQL_UTILS,Classes.SELECT,Classes.CONDITION,Classes.DELETE,Classes.TRANSACTION_MANAGER,Classes.PROCESS_MODEL_INFO,Classes.DBTRANSACTION_INFO);
  javaWriter.beginType(adapterName,""String_Node_Str"",Sets.newHashSet(Modifier.PUBLIC,Modifier.FINAL),""String_Node_Str"" + element.getSimpleName() + ""String_Node_Str"");
  InternalAdapterHelper.writeGetModelClass(javaWriter,modelClassName);
  InternalAdapterHelper.writeGetTableName(javaWriter,tableSourceClassName);
  mContentValuesWriter.write(javaWriter);
  mExistenceWriter.write(javaWriter);
  mLoadCursorWriter.write(javaWriter);
  mWhereQueryWriter.write(javaWriter);
  mCreationQueryWriter.write(javaWriter);
  mDeleteWriter.write(javaWriter);
  javaWriter.endType();
  javaWriter.close();
}"
27206,"public void testJsonModel(){
  try {
    JSONObject jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    TestJsonModel<TestModel1> testJsonModel1=new TestJsonModel<TestModel1>(TestModel1.class,jsonObject);
    testJsonModel1.save(false);
    assertTrue(testJsonModel1.exists());
    assertNotNull(testJsonModel1.toModel());
    jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    TestJsonModel<TestJsonModelClass> testJsonModel=new TestJsonModel<TestJsonModelClass>(TestJsonModelClass.class,jsonObject);
    testJsonModel.save(false);
    assertTrue(testJsonModel.exists());
    assertNotNull(testJsonModel.toModel());
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}","public void testJsonModel(){
  try {
    JSONObject jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    TestJsonModel<TestModel1> testJsonModel1=new TestJsonModel<TestModel1>(TestModel1.class,jsonObject);
    testJsonModel1.save(false);
    assertTrue(testJsonModel1.exists());
    assertNotNull(testJsonModel1.toModel());
    jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    TestJsonModel<TestJsonModelClass> testJsonModel=new TestJsonModel<TestJsonModelClass>(TestJsonModelClass.class,jsonObject);
    testJsonModel.save(false);
    assertTrue(testJsonModel.exists());
    assertNotNull(testJsonModel.toModel());
    assertNotNull(testJsonModel.toModel().testModel);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}"
27207,"@SuppressWarnings(""String_Node_Str"") public static void putField(ContentValues values,FlowManager flowManager,Field field,String fieldName,Object value){
  Class<?> fieldType=field.getType();
  if (value != null) {
    final TypeConverter typeSerializer=flowManager.getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      value=typeSerializer.getDBValue(value);
      if (value != null) {
        fieldType=value.getClass();
        if (!fieldType.equals(typeSerializer.getDatabaseType())) {
          FlowLog.log(FlowLog.Level.W,String.format(TypeConverter.class.getSimpleName() + ""String_Node_Str"",typeSerializer.getDatabaseType(),fieldType));
        }
      }
    }
  }
  if (value == null) {
    values.putNull(fieldName);
  }
 else   if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
    values.put(fieldName,(Byte)value);
  }
 else   if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
    values.put(fieldName,(Short)value);
  }
 else   if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
    values.put(fieldName,(Integer)value);
  }
 else   if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
    values.put(fieldName,(Long)value);
  }
 else   if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
    values.put(fieldName,(Float)value);
  }
 else   if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
    values.put(fieldName,(Double)value);
  }
 else   if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
    values.put(fieldName,(Boolean)value);
  }
 else   if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(String.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
    values.put(fieldName,(byte[])value);
  }
 else   if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
    Column key=field.getAnnotation(Column.class);
    Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
    TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
    for (    ForeignKeyReference foreignKeyReference : key.references()) {
      Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
      foreignColumnField.setAccessible(true);
      try {
        putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),foreignColumnField.get(value));
      }
 catch (      IllegalAccessException e) {
        FlowLog.logError(e);
      }
    }
  }
 else   if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
    values.put(fieldName,((Enum<?>)value).name());
  }
}","@SuppressWarnings(""String_Node_Str"") public static void putField(ContentValues values,FlowManager flowManager,Field field,String fieldName,Object value){
  Class<?> fieldType=field.getType();
  if (value != null) {
    final TypeConverter typeSerializer=flowManager.getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      value=typeSerializer.getDBValue(value);
      if (value != null) {
        fieldType=value.getClass();
        if (!fieldType.equals(typeSerializer.getDatabaseType())) {
          FlowLog.log(FlowLog.Level.W,String.format(TypeConverter.class.getSimpleName() + ""String_Node_Str"",typeSerializer.getDatabaseType(),fieldType));
        }
      }
    }
  }
  if (value == null) {
    values.putNull(fieldName);
  }
 else   if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
    values.put(fieldName,(Byte)value);
  }
 else   if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
    values.put(fieldName,(Short)value);
  }
 else   if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
    values.put(fieldName,(Integer)value);
  }
 else   if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
    values.put(fieldName,(Long)value);
  }
 else   if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
    values.put(fieldName,(Float)value);
  }
 else   if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
    values.put(fieldName,(Double)value);
  }
 else   if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
    values.put(fieldName,(Boolean)value);
  }
 else   if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(String.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
    values.put(fieldName,(byte[])value);
  }
 else   if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
    Column key=field.getAnnotation(Column.class);
    Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
    if (value instanceof JSONObject) {
      JSONObject jsonObject=((JSONObject)value);
      JSONModel<? extends Model> jsonModel=new JSONModel<Model>(jsonObject,(Class<Model>)entityType);
      jsonModel.save(false);
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        Object jsonValue=jsonObject.opt(foreignKeyReference.foreignColumnName());
        field.setAccessible(true);
        SqlUtils.putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),jsonValue);
      }
    }
 else {
      try {
        Model model=(Model)field.get(value);
        model.save(false);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(e);
      }
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        foreignColumnField.setAccessible(true);
        try {
          putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),foreignColumnField.get(value));
        }
 catch (        IllegalAccessException e) {
          FlowLog.logError(e);
        }
      }
    }
  }
 else   if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
    values.put(fieldName,((Enum<?>)value).name());
  }
}"
27208,"/** 
 * Converts the value from the database   {@link android.database.Cursor} into the value that goes into a model from thespecified  {@link com.grosner.dbflow.structure.TableStructure} and {@link java.lang.reflect.Field}.
 * @param cursor         The cursor from the DB
 * @param tableStructure The structure of the table we're on
 * @param field          The field from the {@link com.grosner.dbflow.structure.Model} class
 * @return The value that should be set on the field from the {@link com.grosner.dbflow.structure.TableStructure}
 */
public static Object getModelValueFromCursor(Cursor cursor,TableStructure tableStructure,Field field){
  int columnIndex=cursor.getColumnIndex(tableStructure.getColumnName(field));
  Object value=null;
  if (columnIndex >= 0) {
    Class<?> fieldType=field.getType();
    boolean columnIsNull=cursor.isNull(columnIndex);
    TypeConverter typeSerializer=tableStructure.getManager().getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      fieldType=typeSerializer.getDatabaseType();
    }
    if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
      value=cursor.getLong(columnIndex);
    }
 else     if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
      value=cursor.getFloat(columnIndex);
    }
 else     if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
      value=cursor.getDouble(columnIndex);
    }
 else     if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
      value=cursor.getInt(columnIndex) != 0;
    }
 else     if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
      value=cursor.getString(columnIndex).charAt(0);
    }
 else     if (fieldType.equals(String.class)) {
      value=cursor.getString(columnIndex);
    }
 else     if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
      value=cursor.getBlob(columnIndex);
    }
 else     if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
      final String entityId=cursor.getString(columnIndex);
      final Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
      Column foreignKey=field.getAnnotation(Column.class);
      String[] foreignColumns=new String[foreignKey.references().length];
      for (int i=0; i < foreignColumns.length; i++) {
        foreignColumns[i]=foreignKey.references()[i].foreignColumnName();
      }
      ConditionQueryBuilder conditionQueryBuilder=FlowManager.getManagerForTable(tableStructure.getModelType()).getStructure().getPrimaryWhereQuery(entityType);
      value=new Select().from(entityType).where().whereQuery(conditionQueryBuilder.replaceEmptyParams(foreignColumns)).querySingle();
    }
 else     if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
      @SuppressWarnings(""String_Node_Str"") final Class<? extends Enum> enumType=(Class<? extends Enum>)fieldType;
      value=Enum.valueOf(enumType,cursor.getString(columnIndex));
    }
    if (typeSerializer != null && !columnIsNull) {
      value=typeSerializer.getModelValue(value);
    }
  }
  return value;
}","/** 
 * Converts the value from the database   {@link android.database.Cursor} into the value that goes into a model from thespecified  {@link com.grosner.dbflow.structure.TableStructure} and {@link java.lang.reflect.Field}.
 * @param cursor         The cursor from the DB
 * @param tableStructure The structure of the table we're on
 * @param field          The field from the {@link com.grosner.dbflow.structure.Model} class
 * @return The value that should be set on the field from the {@link com.grosner.dbflow.structure.TableStructure}
 */
public static Object getModelValueFromCursor(Cursor cursor,TableStructure tableStructure,Field field,String columnName,Class<?> fieldType){
  int columnIndex=TextUtils.isEmpty(columnName) ? -1 : cursor.getColumnIndex(columnName);
  Object value=null;
  if (columnIndex >= 0 || (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType))) {
    boolean columnIsNull=cursor.isNull(columnIndex);
    TypeConverter typeSerializer=tableStructure.getManager().getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      fieldType=typeSerializer.getDatabaseType();
    }
    if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
      value=cursor.getLong(columnIndex);
    }
 else     if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
      value=cursor.getFloat(columnIndex);
    }
 else     if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
      value=cursor.getDouble(columnIndex);
    }
 else     if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
      value=cursor.getInt(columnIndex) != 0;
    }
 else     if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
      value=cursor.getString(columnIndex).charAt(0);
    }
 else     if (fieldType.equals(String.class)) {
      value=cursor.getString(columnIndex);
    }
 else     if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
      value=cursor.getBlob(columnIndex);
    }
 else     if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
      final Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
      Column foreignKey=field.getAnnotation(Column.class);
      Object[] foreignColumns=new Object[foreignKey.references().length];
      for (int i=0; i < foreignColumns.length; i++) {
        ForeignKeyReference foreignKeyReference=foreignKey.references()[i];
        foreignColumns[i]=getModelValueFromCursor(cursor,tableStructure,null,foreignKeyReference.columnName(),foreignKeyReference.columnType());
      }
      ConditionQueryBuilder conditionQueryBuilder=FlowManager.getManagerForTable(tableStructure.getModelType()).getStructure().getPrimaryWhereQuery(entityType);
      value=new Select().from(entityType).where().whereQuery(conditionQueryBuilder.replaceEmptyParams(foreignColumns)).querySingle();
    }
 else     if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
      @SuppressWarnings(""String_Node_Str"") final Class<? extends Enum> enumType=(Class<? extends Enum>)fieldType;
      value=Enum.valueOf(enumType,cursor.getString(columnIndex));
    }
    if (typeSerializer != null && !columnIsNull) {
      value=typeSerializer.getModelValue(value);
    }
  }
  return value;
}"
27209,"/** 
 * Loads a   {@link com.grosner.dbflow.structure.Model} from the DB cursor through reflection with thespecified  {@link com.grosner.dbflow.config.FlowManager}.
 * @param model        The model we load from the cursor
 * @param cursor       The cursor from the DB
 * @param < ModelClass > The class that implements {@link com.grosner.dbflow.structure.Model}
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>void loadFromCursor(ModelClass model,Cursor cursor){
  TableStructure<ModelClass> tableStructure=FlowManager.getManagerForTable(model.getClass()).getTableStructureForClass((Class<ModelClass>)model.getClass());
  Set<Field> fields=tableStructure.getColumns();
  for (  Field field : fields) {
    try {
      Object value=getModelValueFromCursor(cursor,tableStructure,field);
      if (value != null) {
        field.setAccessible(true);
        field.set(model,value);
      }
    }
 catch (    IllegalArgumentException e) {
      FlowLog.logError(e);
    }
catch (    IllegalAccessException e) {
      FlowLog.logError(e);
    }
catch (    SecurityException e) {
      FlowLog.logError(e);
    }
  }
}","/** 
 * Loads a   {@link com.grosner.dbflow.structure.Model} from the DB cursor through reflection with thespecified  {@link com.grosner.dbflow.config.FlowManager}.
 * @param model        The model we load from the cursor
 * @param cursor       The cursor from the DB
 * @param < ModelClass > The class that implements {@link com.grosner.dbflow.structure.Model}
 */
@SuppressWarnings(""String_Node_Str"") public static <ModelClass extends Model>void loadFromCursor(ModelClass model,Cursor cursor){
  TableStructure<ModelClass> tableStructure=FlowManager.getManagerForTable(model.getClass()).getTableStructureForClass((Class<ModelClass>)model.getClass());
  Set<Field> fields=tableStructure.getColumns();
  for (  Field field : fields) {
    try {
      Object value=getModelValueFromCursor(cursor,tableStructure,field,tableStructure.getColumnName(field),field.getType());
      if (value != null) {
        field.setAccessible(true);
        field.set(model,value);
      }
    }
 catch (    IllegalArgumentException e) {
      FlowLog.logError(e);
    }
catch (    IllegalAccessException e) {
      FlowLog.logError(e);
    }
catch (    SecurityException e) {
      FlowLog.logError(e);
    }
  }
}"
27210,"/** 
 * Loads a   {@link com.grosner.dbflow.structure.Model} from the DB cursor into {@link org.json.JSONObject} .
 * @param jsonModel    The {@link com.grosner.dbflow.structure.json.JSONModel} to load the cursor into
 * @param cursor       The cursor from the DB
 * @param < ModelClass > The class that implements {@link com.grosner.dbflow.structure.Model}
 */
public static <ModelClass extends Model>void loadFromCursor(JSONModel<ModelClass> jsonModel,Cursor cursor){
  Set<Field> fields=jsonModel.mTableStructure.getColumns();
  for (  Field field : fields) {
    Object value=SqlUtils.getModelValueFromCursor(cursor,jsonModel.mTableStructure,field);
    if (value != null) {
      try {
        jsonModel.mJson.put(jsonModel.mTableStructure.getColumnName(field),value);
      }
 catch (      JSONException e) {
        FlowLog.logError(e);
      }
    }
  }
}","/** 
 * Loads a   {@link com.grosner.dbflow.structure.Model} from the DB cursor into {@link org.json.JSONObject} .
 * @param jsonModel    The {@link com.grosner.dbflow.structure.json.JSONModel} to load the cursor into
 * @param cursor       The cursor from the DB
 * @param < ModelClass > The class that implements {@link com.grosner.dbflow.structure.Model}
 */
public static <ModelClass extends Model>void loadFromCursor(JSONModel<ModelClass> jsonModel,Cursor cursor){
  Set<Field> fields=jsonModel.mTableStructure.getColumns();
  for (  Field field : fields) {
    Object value=SqlUtils.getModelValueFromCursor(cursor,jsonModel.mTableStructure,field,jsonModel.mTableStructure.getColumnName(field),field.getType());
    if (value != null) {
      try {
        jsonModel.mJson.put(jsonModel.mTableStructure.getColumnName(field),value);
      }
 catch (      JSONException e) {
        FlowLog.logError(e);
      }
    }
  }
}"
27211,"/** 
 * Adds a join on a specific table for this query
 * @param table    The table this corresponds to
 * @param joinType The type of join to use
 * @return
 */
public Join join(Class<ModelClass> table,Join.JoinType joinType){
  Join join=new Join(this,table,joinType);
  mJoins.add(join);
  return join;
}","/** 
 * Adds a join on a specific table for this query
 * @param table    The table this corresponds to
 * @param joinType The type of join to use
 * @return
 */
public <JoinType extends Model>Join<JoinType> join(Class<JoinType> table,Join.JoinType joinType){
  Join<JoinType> join=new Join<JoinType>(this,table,joinType);
  mJoins.add(join);
  return join;
}"
27212,"Join(From from,Class<? extends Model> table,JoinType joinType){
  mFrom=from;
  mTable=table;
  mJoinType=joinType;
}","Join(From from,Class<ModelClass> table,JoinType joinType){
  mFrom=from;
  mTable=table;
  mJoinType=joinType;
}"
27213,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder();
  if (mJoinType != null) {
    queryBuilder.append(mJoinType.toString()).appendSpace();
  }
  queryBuilder.append(""String_Node_Str"").appendSpace().append(FlowManager.getManagerForTable(mTable).getTableName(mTable)).appendSpace();
  if (mAlias != null) {
    queryBuilder.append(""String_Node_Str"").append(mAlias).appendSpace();
  }
  if (mOn != null) {
    queryBuilder.append(""String_Node_Str"").appendSpace().append(mOn).appendSpace();
  }
 else   if (mUsing != null) {
    queryBuilder.append(""String_Node_Str"").appendArray(mUsing).append(""String_Node_Str"").appendSpace();
  }
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder();
  if (mJoinType != null) {
    queryBuilder.append(mJoinType.toString()).appendSpace();
  }
  queryBuilder.append(""String_Node_Str"").appendSpace().append(FlowManager.getTableName(mTable)).appendSpace();
  if (mAlias != null) {
    queryBuilder.append(""String_Node_Str"").append(mAlias).appendSpace();
  }
  if (mOn != null) {
    queryBuilder.append(""String_Node_Str"").appendSpace().append(mOn.getRawQuery()).appendSpace();
  }
 else   if (mUsing != null) {
    queryBuilder.append(""String_Node_Str"").appendArray(mUsing).append(""String_Node_Str"").appendSpace();
  }
  return queryBuilder.getQuery();
}"
27214,"public From on(String on){
  mOn=on;
  return mFrom;
}","public From on(Condition... onConditions){
  mOn=new ConditionQueryBuilder<ModelClass>(mTable,onConditions);
  return mFrom;
}"
27215,"public void testJsonModel(){
  try {
    JSONObject jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    TestJsonModel<TestModel1> testJsonModel1=new TestJsonModel<TestModel1>(TestModel1.class,jsonObject);
    testJsonModel1.save(false);
    assertTrue(testJsonModel1.exists());
    assertNotNull(testJsonModel1.toModel());
    jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    TestJsonModel<TestJsonModelClass> testJsonModel=new TestJsonModel<TestJsonModelClass>(TestJsonModelClass.class,jsonObject);
    testJsonModel.save(false);
    assertTrue(testJsonModel.exists());
    assertNotNull(testJsonModel.toModel());
    assertNotNull(testJsonModel.toModel().testModel);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}","public void testJsonModel(){
  try {
    JSONObject jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    JSONModel<TestModel1> testJsonModel1=new JSONModel<TestModel1>(jsonObject,TestModel1.class);
    testJsonModel1.save(false);
    assertTrue(testJsonModel1.exists());
    assertNotNull(testJsonModel1.toModel());
    jsonObject=new JSONObject(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    JSONModel<TestJsonModelClass> testJsonModel=new JSONModel<TestJsonModelClass>(jsonObject,TestJsonModelClass.class);
    testJsonModel.save(false);
    assertTrue(testJsonModel.exists());
    assertNotNull(testJsonModel.toModel());
    assertNotNull(testJsonModel.toModel().testModel);
  }
 catch (  JSONException e) {
    throw new RuntimeException(e);
  }
}"
27216,"/** 
 * The SQL from statement constructed.
 * @param querybase   The base query we append this query to
 * @param table       The table this corresponds to
 */
public From(Query querybase,Class<ModelClass> table){
  mQueryBuilderBase=querybase;
  mTable=table;
}","/** 
 * The SQL from statement constructed.
 * @param querybase The base query we append this query to
 * @param table     The table this corresponds to
 */
public From(Query querybase,Class<ModelClass> table){
  mQueryBuilderBase=querybase;
  mTable=table;
}"
27217,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder().append(mQueryBuilderBase.getQuery()).append(""String_Node_Str"").appendSpaceSeparated(FlowManager.getTableName(mTable)).appendQualifier(""String_Node_Str"",mAlias);
  for (  Join join : mJoins) {
    queryBuilder.append(join.getQuery());
  }
  return queryBuilder.getQuery().trim();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder().append(mQueryBuilderBase.getQuery());
  if (mQueryBuilderBase instanceof Select) {
    queryBuilder.append(""String_Node_Str"").appendSpaceSeparated(FlowManager.getTableName(mTable));
    queryBuilder.appendQualifier(""String_Node_Str"",mAlias);
    for (    Join join : mJoins) {
      queryBuilder.append(join.getQuery());
    }
  }
 else {
    queryBuilder.append(FlowManager.getTableName(mTable)).appendSpace();
  }
  return queryBuilder.getQuery();
}"
27218,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(mUpdate.getQuery()).append(""String_Node_Str"").append(mConditionQueryBuilder.getQuery());
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(mUpdate.getQuery()).append(""String_Node_Str"").append(mConditionQueryBuilder.getQuery()).appendSpace();
  return queryBuilder.getQuery();
}"
27219,"@SuppressWarnings(""String_Node_Str"") public static void putField(ContentValues values,FlowManager flowManager,Field field,String fieldName,Object value){
  Class<?> fieldType=field.getType();
  if (value != null) {
    final TypeConverter typeSerializer=flowManager.getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      value=typeSerializer.getDBValue(value);
      if (value != null) {
        fieldType=value.getClass();
        if (!fieldType.equals(typeSerializer.getDatabaseType())) {
          FlowLog.log(FlowLog.Level.W,String.format(TypeConverter.class.getSimpleName() + ""String_Node_Str"",typeSerializer.getDatabaseType(),fieldType));
        }
      }
    }
  }
  if (value == null) {
    values.putNull(fieldName);
  }
 else   if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
    values.put(fieldName,(Byte)value);
  }
 else   if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
    values.put(fieldName,(Short)value);
  }
 else   if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
    values.put(fieldName,(Integer)value);
  }
 else   if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
    values.put(fieldName,(Long)value);
  }
 else   if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
    values.put(fieldName,(Float)value);
  }
 else   if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
    values.put(fieldName,(Double)value);
  }
 else   if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
    values.put(fieldName,(Boolean)value);
  }
 else   if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(String.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
    values.put(fieldName,(byte[])value);
  }
 else   if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
    Column key=field.getAnnotation(Column.class);
    Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
    if (value instanceof JSONObject) {
      JSONObject jsonObject=((JSONObject)value);
      JSONModel<? extends Model> jsonModel=new JSONModel<Model>(jsonObject,(Class<Model>)entityType);
      jsonModel.save(false);
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        Object jsonValue=jsonObject.opt(foreignKeyReference.foreignColumnName());
        field.setAccessible(true);
        SqlUtils.putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),jsonValue);
      }
    }
 else {
      try {
        Model model=(Model)field.get(value);
        model.save(false);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(e);
      }
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        foreignColumnField.setAccessible(true);
        try {
          putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),foreignColumnField.get(value));
        }
 catch (        IllegalAccessException e) {
          FlowLog.logError(e);
        }
      }
    }
  }
 else   if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
    values.put(fieldName,((Enum<?>)value).name());
  }
}","@SuppressWarnings(""String_Node_Str"") public static void putField(ContentValues values,FlowManager flowManager,Field field,String fieldName,Object value){
  Class<?> fieldType=field.getType();
  if (value != null && !StructureUtils.isForeignKey(field)) {
    final TypeConverter typeSerializer=flowManager.getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      value=typeSerializer.getDBValue(value);
      if (value != null) {
        fieldType=value.getClass();
        if (!fieldType.equals(typeSerializer.getDatabaseType())) {
          FlowLog.log(FlowLog.Level.W,String.format(TypeConverter.class.getSimpleName() + ""String_Node_Str"",typeSerializer.getDatabaseType(),fieldType));
        }
      }
    }
  }
  if (value == null) {
    values.putNull(fieldName);
  }
 else   if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
    values.put(fieldName,(Byte)value);
  }
 else   if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
    values.put(fieldName,(Short)value);
  }
 else   if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
    values.put(fieldName,(Integer)value);
  }
 else   if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
    values.put(fieldName,(Long)value);
  }
 else   if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
    values.put(fieldName,(Float)value);
  }
 else   if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
    values.put(fieldName,(Double)value);
  }
 else   if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
    values.put(fieldName,(Boolean)value);
  }
 else   if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(String.class)) {
    values.put(fieldName,value.toString());
  }
 else   if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
    values.put(fieldName,(byte[])value);
  }
 else   if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
    Column key=field.getAnnotation(Column.class);
    Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
    if (value instanceof JSONObject) {
      JSONObject jsonObject=((JSONObject)value);
      JSONModel<? extends Model> jsonModel=new JSONModel<Model>(jsonObject,(Class<Model>)entityType);
      jsonModel.save(false);
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        Object jsonValue=jsonObject.opt(foreignKeyReference.foreignColumnName());
        field.setAccessible(true);
        SqlUtils.putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),jsonValue);
      }
    }
 else {
      try {
        Model model=(Model)field.get(value);
        model.save(false);
      }
 catch (      IllegalAccessException e) {
        throw new RuntimeException(e);
      }
      TableStructure tableStructure=flowManager.getStructure().getTableStructureForClass(entityType);
      for (      ForeignKeyReference foreignKeyReference : key.references()) {
        Field foreignColumnField=tableStructure.getField(foreignKeyReference.foreignColumnName());
        foreignColumnField.setAccessible(true);
        try {
          putField(values,flowManager,foreignColumnField,foreignKeyReference.columnName(),foreignColumnField.get(value));
        }
 catch (        IllegalAccessException e) {
          FlowLog.logError(e);
        }
      }
    }
  }
 else   if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
    values.put(fieldName,((Enum<?>)value).name());
  }
}"
27220,"@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (!TextUtils.isEmpty(mOrQualifier)) {
    queryBuilder.append(mOrQualifier).appendSpace();
  }
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  QueryBuilder queryBuilder=new QueryBuilder(""String_Node_Str"");
  if (!TextUtils.isEmpty(mOrQualifier)) {
    queryBuilder.append(""String_Node_Str"").appendSpaceSeparated(mOrQualifier);
  }
  return queryBuilder.getQuery();
}"
27221,"@Override public String getQuery(){
  String fromQuery=mWhereBase.getQuery();
  QueryBuilder queryBuilder=new QueryBuilder().append(fromQuery).appendSpace();
  queryBuilder.appendQualifier(""String_Node_Str"",mConditionQueryBuilder.getQuery()).appendQualifier(""String_Node_Str"",mGroupBy).appendQualifier(""String_Node_Str"",mHaving.getQuery()).appendQualifier(""String_Node_Str"",mOrderBy).appendQualifier(""String_Node_Str"",mLimit).appendQualifier(""String_Node_Str"",mOffset);
  if (FlowLog.isEnabled(FlowLog.Level.V)) {
    FlowLog.log(FlowLog.Level.V,queryBuilder.getQuery());
  }
  return queryBuilder.getQuery();
}","@Override public String getQuery(){
  String fromQuery=mWhereBase.getQuery();
  QueryBuilder queryBuilder=new QueryBuilder().append(fromQuery);
  queryBuilder.appendQualifier(""String_Node_Str"",mConditionQueryBuilder.getQuery()).appendQualifier(""String_Node_Str"",mGroupBy).appendQualifier(""String_Node_Str"",mHaving.getQuery()).appendQualifier(""String_Node_Str"",mOrderBy).appendQualifier(""String_Node_Str"",mLimit).appendQualifier(""String_Node_Str"",mOffset);
  if (FlowLog.isEnabled(FlowLog.Level.V)) {
    FlowLog.log(FlowLog.Level.V,queryBuilder.getQuery());
  }
  return queryBuilder.getQuery();
}"
27222,"/** 
 * Converts the value from the database   {@link android.database.Cursor} into the value that goes into a model from thespecified  {@link com.grosner.dbflow.structure.TableStructure} and {@link java.lang.reflect.Field}.
 * @param cursor         The cursor from the DB
 * @param tableStructure The structure of the table we're on
 * @param field          The field from the {@link com.grosner.dbflow.structure.Model} class
 * @return The value that should be set on the field from the {@link com.grosner.dbflow.structure.TableStructure}
 */
public static Object getModelValueFromCursor(Cursor cursor,TableStructure tableStructure,Field field,String columnName,Class<?> fieldType){
  int columnIndex=TextUtils.isEmpty(columnName) ? -1 : cursor.getColumnIndex(columnName);
  Object value=null;
  if (columnIndex >= 0 || (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType))) {
    boolean columnIsNull=cursor.isNull(columnIndex);
    TypeConverter typeSerializer=tableStructure.getManager().getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      fieldType=typeSerializer.getDatabaseType();
    }
    if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
      value=cursor.getLong(columnIndex);
    }
 else     if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
      value=cursor.getFloat(columnIndex);
    }
 else     if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
      value=cursor.getDouble(columnIndex);
    }
 else     if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
      value=cursor.getInt(columnIndex) != 0;
    }
 else     if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
      value=cursor.getString(columnIndex).charAt(0);
    }
 else     if (fieldType.equals(String.class)) {
      value=cursor.getString(columnIndex);
    }
 else     if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
      value=cursor.getBlob(columnIndex);
    }
 else     if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
      final Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
      Column foreignKey=field.getAnnotation(Column.class);
      Object[] foreignColumns=new Object[foreignKey.references().length];
      for (int i=0; i < foreignColumns.length; i++) {
        ForeignKeyReference foreignKeyReference=foreignKey.references()[i];
        foreignColumns[i]=getModelValueFromCursor(cursor,tableStructure,null,foreignKeyReference.columnName(),foreignKeyReference.columnType());
      }
      ConditionQueryBuilder conditionQueryBuilder=FlowManager.getPrimaryWhereQuery(tableStructure.getModelType());
      value=new Select().from(entityType).where().whereQuery(conditionQueryBuilder.replaceEmptyParams(foreignColumns)).querySingle();
    }
 else     if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
      @SuppressWarnings(""String_Node_Str"") final Class<? extends Enum> enumType=(Class<? extends Enum>)fieldType;
      value=Enum.valueOf(enumType,cursor.getString(columnIndex));
    }
    if (typeSerializer != null && !columnIsNull) {
      value=typeSerializer.getModelValue(value);
    }
  }
  return value;
}","/** 
 * Converts the value from the database   {@link android.database.Cursor} into the value that goes into a model from thespecified  {@link com.grosner.dbflow.structure.TableStructure} and {@link java.lang.reflect.Field}.
 * @param cursor         The cursor from the DB
 * @param tableStructure The structure of the table we're on
 * @param field          The field from the {@link com.grosner.dbflow.structure.Model} class
 * @return The value that should be set on the field from the {@link com.grosner.dbflow.structure.TableStructure}
 */
public static Object getModelValueFromCursor(Cursor cursor,TableStructure tableStructure,Field field,String columnName,Class<?> fieldType){
  int columnIndex=TextUtils.isEmpty(columnName) ? -1 : cursor.getColumnIndex(columnName);
  Object value=null;
  if (columnIndex >= 0 || (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType))) {
    boolean columnIsNull=cursor.isNull(columnIndex);
    TypeConverter typeSerializer=tableStructure.getManager().getTypeConverterForClass(fieldType);
    if (typeSerializer != null) {
      fieldType=typeSerializer.getDatabaseType();
    }
    if (fieldType.equals(Byte.class) || fieldType.equals(byte.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Short.class) || fieldType.equals(short.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
      value=cursor.getInt(columnIndex);
    }
 else     if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
      value=cursor.getLong(columnIndex);
    }
 else     if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
      value=cursor.getFloat(columnIndex);
    }
 else     if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
      value=cursor.getDouble(columnIndex);
    }
 else     if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
      value=cursor.getInt(columnIndex) != 0;
    }
 else     if (fieldType.equals(Character.class) || fieldType.equals(char.class)) {
      value=cursor.getString(columnIndex).charAt(0);
    }
 else     if (fieldType.equals(String.class)) {
      value=cursor.getString(columnIndex);
    }
 else     if (fieldType.equals(Byte[].class) || fieldType.equals(byte[].class)) {
      value=cursor.getBlob(columnIndex);
    }
 else     if (StructureUtils.isForeignKey(field) && ReflectionUtils.implementsModel(fieldType)) {
      final Class<? extends Model> entityType=(Class<? extends Model>)fieldType;
      Column foreignKey=field.getAnnotation(Column.class);
      Object[] foreignColumns=new Object[foreignKey.references().length];
      for (int i=0; i < foreignColumns.length; i++) {
        ForeignKeyReference foreignKeyReference=foreignKey.references()[i];
        foreignColumns[i]=getModelValueFromCursor(cursor,tableStructure,null,foreignKeyReference.columnName(),foreignKeyReference.columnType());
      }
      ConditionQueryBuilder conditionQueryBuilder=FlowManager.getPrimaryWhereQuery(entityType);
      value=new Select().from(entityType).where().whereQuery(conditionQueryBuilder.replaceEmptyParams(foreignColumns)).querySingle();
    }
 else     if (ReflectionUtils.isSubclassOf(fieldType,Enum.class)) {
      @SuppressWarnings(""String_Node_Str"") final Class<? extends Enum> enumType=(Class<? extends Enum>)fieldType;
      value=Enum.valueOf(enumType,cursor.getString(columnIndex));
    }
    if (typeSerializer != null && !columnIsNull) {
      value=typeSerializer.getModelValue(value);
    }
  }
  return value;
}"
27223,"public void testModelObserver(){
  List<ModelObserver<? extends Model>> modelObservers=mManager.getStructure().getModelObserverListForClass(TestModel1.class);
  assertNotNull(modelObservers);
  boolean found=false;
  for (  ModelObserver modelObserver : modelObservers) {
    if (modelObserver.getClass().equals(TestModelObserver.class)) {
      found=true;
      break;
    }
  }
  assertTrue(found);
}","public void testModelObserver(){
  List<ModelObserver<? extends Model>> modelObservers=mManager.getStructure().getModelObserverListForClass(TestModel1.class);
  assertNotNull(modelObservers);
  TestModelObserver model1Observer=null;
  for (  ModelObserver modelObserver : modelObservers) {
    if (modelObserver.getClass().equals(TestModelObserver.class)) {
      model1Observer=(TestModelObserver)modelObserver;
      break;
    }
  }
  assertNotNull(model1Observer);
  TestModel1 testModel1=new TestModel1();
  testModel1.id=""String_Node_Str"";
  testModel1.setManager(mManager);
  testModel1.save(false);
  final TestModelObserver finalModel1Observer=model1Observer;
  TransactionManager.getInstance().processOnRequestHandler(1000,new Runnable(){
    @Override public void run(){
      assertTrue(finalModel1Observer.isCalled());
    }
  }
);
}"
27224,"/** 
 * Runs UI operations in the handler
 * @param runnable
 */
public synchronized void processOnRequestHandler(Runnable runnable){
  mRequestHandler.post(runnable);
}","/** 
 * Runs UI operations in the handler with delay
 * @param runnable
 */
public synchronized void processOnRequestHandler(long delay,Runnable runnable){
  mRequestHandler.postDelayed(runnable,delay);
}"
27225,"@Override public void load(Cursor cursor){
  SqlUtils.loadFromCursor(FlowManager.getInstance(),this,cursor);
}","@Override public void load(Cursor cursor){
  SqlUtils.loadFromCursor(mManager,this,cursor);
}"
27226,"@Override public void save(boolean async){
  SqlUtils.save(FlowManager.getInstance(),this,async,SqlUtils.SAVE_MODE_DEFAULT,false);
}","@Override public void save(boolean async){
  SqlUtils.save(mManager,this,async,SqlUtils.SAVE_MODE_DEFAULT,false);
}"
27227,"/** 
 * Directly tries to insert this item into the DB without updating.
 * @param async If we want this to happen on the {@link com.grosner.dbflow.runtime.DBTransactionQueue}
 */
@Override public void insert(boolean async){
  SqlUtils.save(FlowManager.getInstance(),this,async,SqlUtils.SAVE_MODE_INSERT,false);
}","/** 
 * Directly tries to insert this item into the DB without updating.
 * @param async If we want this to happen on the {@link com.grosner.dbflow.runtime.DBTransactionQueue}
 */
@Override public void insert(boolean async){
  SqlUtils.save(mManager,this,async,SqlUtils.SAVE_MODE_INSERT,false);
}"
27228,"@Override public void update(boolean async){
  SqlUtils.save(FlowManager.getInstance(),this,async,SqlUtils.SAVE_MODE_UPDATE,false);
}","@Override public void update(boolean async){
  SqlUtils.save(mManager,this,async,SqlUtils.SAVE_MODE_UPDATE,false);
}"
27229,"@Override public boolean exists(){
  return SqlUtils.exists(FlowManager.getInstance(),this);
}","@Override public boolean exists(){
  return SqlUtils.exists(mManager,this);
}"
27230,"@Override public void delete(boolean async){
  SqlUtils.delete(FlowManager.getInstance(),this,async,false);
}","@Override public void delete(boolean async){
  SqlUtils.delete(mManager,this,async,false);
}"
27231,"/** 
 * Run this query and returns the   {@link android.database.Cursor} for it
 * @return the Sqlite {@link android.database.Cursor} from this query
 */
public Cursor query(){
  return mManager.getWritableDatabase().rawQuery(getQuery(),null);
}","/** 
 * Run this query and returns the   {@link android.database.Cursor} for it
 * @return the Sqlite {@link android.database.Cursor} from this query
 */
public Cursor query(){
  Cursor cursor=null;
  String query=getQuery();
  if (mWhereBase.getQueryBuilderBase() instanceof Select) {
    cursor=mManager.getWritableDatabase().rawQuery(query,null);
  }
 else {
    mManager.getWritableDatabase().execSQL(query);
  }
  return cursor;
}"
27232,"/** 
 * Checks to see if field is a   {@link com.grosner.dbflow.structure.ColumnType#PRIMARY_KEY}
 * @param field
 * @return
 */
public static boolean isPrimaryKey(Field field){
  Column column=field.getAnnotation(Column.class);
  boolean isPrimary=column != null;
  if (isPrimary) {
    isPrimary=column.value().value() != ColumnType.FOREIGN_KEY;
  }
  return isPrimary;
}","/** 
 * Checks to see if field is a   {@link com.grosner.dbflow.structure.ColumnType#PRIMARY_KEY}
 * @param field
 * @return
 */
public static boolean isPrimaryKey(Field field){
  Column column=field.getAnnotation(Column.class);
  boolean isPrimary=column != null;
  if (isPrimary) {
    isPrimary=(column.value().value() != ColumnType.FOREIGN_KEY && column.value().value() != ColumnType.NORMAL);
  }
  return isPrimary;
}"
27233,"/** 
 * This will append a SET columnName = value to this migration. It will execute each of these in succession with the order that this is called.
 * @param columnName
 * @param value
 * @return
 */
public UpdateTableMigration<ModelClass> set(String columnName,String value){
  if (mSetDefinitions == null) {
    mSetDefinitions=new ArrayList<QueryBuilder>();
  }
  QueryBuilder queryBuilder=new QueryBuilder().append(columnName).appendSpaceSeparated(""String_Node_Str"").append(value);
  mSetDefinitions.add(queryBuilder);
}","/** 
 * This will append a SET columnName = value to this migration. It will execute each of these in succession with the order that this is called.
 * @param columnName
 * @param value
 * @return
 */
public UpdateTableMigration<ModelClass> set(String columnName,String value){
  if (mSetDefinitions == null) {
    mSetDefinitions=new ArrayList<QueryBuilder>();
  }
  QueryBuilder queryBuilder=new QueryBuilder().append(columnName).appendSpaceSeparated(""String_Node_Str"").append(value);
  mSetDefinitions.add(queryBuilder);
  return this;
}"
27234,"public UpdateTableMigration<ModelClass> where(WhereQueryBuilder.WhereParam whereParam){
  if (mWhereQueryBuilder == null) {
    mWhereQueryBuilder=new WhereQueryBuilder<ModelClass>(mManager,mTable);
  }
  mWhereQueryBuilder.param(whereParam);
}","public UpdateTableMigration<ModelClass> where(WhereQueryBuilder.WhereParam whereParam){
  if (mWhereQueryBuilder == null) {
    mWhereQueryBuilder=new WhereQueryBuilder<ModelClass>(mManager,mTable);
  }
  mWhereQueryBuilder.param(whereParam);
  return this;
}"
27235,"/** 
 * Specify the database name. The .db is not necessary. This also must match any prepackaged database.
 * @param databaseName The name of the database in private app data
 * @return The builder
 */
public Builder databaseName(String databaseName){
  mConfiguration.mDatabaseName=databaseName;
  return this;
}","/** 
 * Specify the database name. The .db is not necessary. This also must match any prepackaged database.
 * @param databaseName The name of the database in private app data
 * @return The builder
 */
public Builder databaseName(String databaseName){
  mConfiguration.mDatabaseName=databaseName + ""String_Node_Str"";
  return this;
}"
27236,"@Override public String getQuery(){
  if (isChanged || mQuery.length() == 0) {
    isChanged=false;
    mQuery=new StringBuilder();
    Set<String> keys=mParams.keySet();
    int count=0;
    for (    String key : keys) {
      appendParam(mParams.get(key));
      if (count < keys.size() - 1) {
        appendSpaceSeparated(""String_Node_Str"");
      }
    }
  }
  return mQuery.toString();
}","@Override public String getQuery(){
  if (isChanged || mQuery.length() == 0) {
    isChanged=false;
    mQuery=new StringBuilder();
    Set<String> keys=mParams.keySet();
    int count=0;
    for (    String key : keys) {
      appendParam(mParams.get(key));
      if (count < keys.size() - 1) {
        appendSpaceSeparated(""String_Node_Str"");
      }
      count++;
    }
  }
  return mQuery.toString();
}"
27237,"/** 
 * Builds the structure of this table based on the   {@link com.grosner.dbflow.structure.Model}class passed in.
 * @param modelType
 */
public TableStructure(FlowManager flowManager,Class<ModelType> modelType){
  mManager=flowManager;
  mColumnNames=new HashMap<Field,String>();
  mFieldFromNames=new HashMap<String,Field>();
  mPrimaryKeys=new LinkedHashMap<String,Field>();
  mForeignKeys=new LinkedHashMap<String,Field>();
  mModelType=modelType;
  Table table=mModelType.getAnnotation(Table.class);
  if (table != null) {
    mTableName=table.name();
  }
 else {
    mTableName=mModelType.getSimpleName();
  }
  List<Field> fields=new ArrayList<Field>();
  fields=ReflectionUtils.getAllColumns(fields,mModelType);
  mCreationQuery=new TableCreationQueryBuilder();
  mCreationQuery.appendCreateTableIfNotExists(mTableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<QueryBuilder>();
  for (  Field field : fields) {
    TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
    Class type=field.getType();
    String columnName;
    Column column=field.getAnnotation(Column.class);
    if (column.name() != null && !column.name().equals(""String_Node_Str"")) {
      columnName=column.name();
    }
 else {
      columnName=field.getName();
    }
    mColumnNames.put(field,columnName);
    mFieldFromNames.put(columnName,field);
    if (column.value().value() == ColumnType.PRIMARY_KEY || column.value().value() == ColumnType.PRIMARY_KEY_AUTO_INCREMENT) {
      mPrimaryKeys.put(columnName,field);
    }
 else     if (column.value().value() == ColumnType.FOREIGN_KEY) {
      mForeignKeys.put(columnName,field);
    }
    if (SQLiteType.containsClass(type)) {
      tableCreationQuery.append(columnName).appendSpace().appendType(type);
    }
 else     if (ReflectionUtils.isSubclassOf(type,Enum.class)) {
      tableCreationQuery.append(columnName).appendSpace().appendSQLiteType(SQLiteType.TEXT);
    }
    mColumnDefinitions.add(tableCreationQuery.appendColumn(column));
  }
  if (!ReflectionUtils.implementsModelView(modelType)) {
    if (mPrimaryKeys.isEmpty()) {
      throw new PrimaryKeyNotFoundException(""String_Node_Str"" + mTableName + ""String_Node_Str"");
    }
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    Collection<Field> primaryKeys=getPrimaryKeys();
    int count=0;
    int index=0;
    for (    Field field : primaryKeys) {
      Column primaryKey=field.getAnnotation(Column.class);
      if (primaryKey.value().value() != ColumnType.PRIMARY_KEY_AUTO_INCREMENT) {
        count++;
        primaryKeyQueryBuilder.append(mColumnNames.get(field));
        if (index < mPrimaryKeys.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    Collection<Field> foreignKeys=getForeignKeys();
    for (    Field foreignKeyField : foreignKeys) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      Column foreignKey=foreignKeyField.getAnnotation(Column.class);
      foreignKeyQueryBuilder.append(mColumnNames.get(foreignKeyField)).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"").append(mTableName).append(""String_Node_Str"").append(foreignKey.foreignColumn()).append(""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!mPrimaryKeys.isEmpty() || !mForeignKeys.isEmpty()) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"");
  }
  mCreationQuery.appendColumnDefinitions(mColumnDefinitions).append(""String_Node_Str"");
}","/** 
 * Builds the structure of this table based on the   {@link com.grosner.dbflow.structure.Model}class passed in.
 * @param modelType
 */
public TableStructure(FlowManager flowManager,Class<ModelType> modelType){
  mManager=flowManager;
  mColumnNames=new HashMap<Field,String>();
  mFieldFromNames=new HashMap<String,Field>();
  mPrimaryKeys=new LinkedHashMap<String,Field>();
  mForeignKeys=new LinkedHashMap<String,Field>();
  mModelType=modelType;
  Table table=mModelType.getAnnotation(Table.class);
  if (table != null) {
    mTableName=table.name();
  }
 else {
    mTableName=mModelType.getSimpleName();
  }
  List<Field> fields=new ArrayList<Field>();
  fields=ReflectionUtils.getAllColumns(fields,mModelType);
  mCreationQuery=new TableCreationQueryBuilder();
  mCreationQuery.appendCreateTableIfNotExists(mTableName);
  ArrayList<QueryBuilder> mColumnDefinitions=new ArrayList<QueryBuilder>();
  for (  Field field : fields) {
    TableCreationQueryBuilder tableCreationQuery=new TableCreationQueryBuilder();
    Class type=field.getType();
    String columnName;
    Column column=field.getAnnotation(Column.class);
    if (column.name() != null && !column.name().equals(""String_Node_Str"")) {
      columnName=column.name();
    }
 else {
      columnName=field.getName();
    }
    mColumnNames.put(field,columnName);
    mFieldFromNames.put(columnName,field);
    if (column.value().value() == ColumnType.PRIMARY_KEY || column.value().value() == ColumnType.PRIMARY_KEY_AUTO_INCREMENT) {
      mPrimaryKeys.put(columnName,field);
    }
 else     if (column.value().value() == ColumnType.FOREIGN_KEY) {
      mForeignKeys.put(columnName,field);
    }
    if (SQLiteType.containsClass(type)) {
      tableCreationQuery.append(columnName).appendSpace().appendType(type);
    }
 else     if (ReflectionUtils.isSubclassOf(type,Enum.class)) {
      tableCreationQuery.append(columnName).appendSpace().appendSQLiteType(SQLiteType.TEXT);
    }
 else {
      TypeConverter typeConverter=mManager.getTypeConverterForClass(type);
      if (typeConverter != null) {
        tableCreationQuery.append(columnName).appendSpace().appendType(typeConverter.getDatabaseType());
      }
    }
    mColumnDefinitions.add(tableCreationQuery.appendColumn(column));
  }
  if (!ReflectionUtils.implementsModelView(modelType)) {
    if (mPrimaryKeys.isEmpty()) {
      throw new PrimaryKeyNotFoundException(""String_Node_Str"" + mTableName + ""String_Node_Str"");
    }
    QueryBuilder primaryKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
    Collection<Field> primaryKeys=getPrimaryKeys();
    int count=0;
    int index=0;
    for (    Field field : primaryKeys) {
      Column primaryKey=field.getAnnotation(Column.class);
      if (primaryKey.value().value() != ColumnType.PRIMARY_KEY_AUTO_INCREMENT) {
        count++;
        primaryKeyQueryBuilder.append(mColumnNames.get(field));
        if (index < mPrimaryKeys.size() - 1) {
          primaryKeyQueryBuilder.append(""String_Node_Str"");
        }
      }
      index++;
    }
    if (count > 0) {
      primaryKeyQueryBuilder.append(""String_Node_Str"");
      mColumnDefinitions.add(primaryKeyQueryBuilder);
    }
    QueryBuilder foreignKeyQueryBuilder;
    Collection<Field> foreignKeys=getForeignKeys();
    for (    Field foreignKeyField : foreignKeys) {
      foreignKeyQueryBuilder=new QueryBuilder().append(""String_Node_Str"");
      Column foreignKey=foreignKeyField.getAnnotation(Column.class);
      foreignKeyQueryBuilder.append(mColumnNames.get(foreignKeyField)).append(""String_Node_Str"").appendSpaceSeparated(""String_Node_Str"").append(mTableName).append(""String_Node_Str"").append(foreignKey.foreignColumn()).append(""String_Node_Str"");
      mColumnDefinitions.add(foreignKeyQueryBuilder);
    }
  }
 else   if (!mPrimaryKeys.isEmpty() || !mForeignKeys.isEmpty()) {
    FlowLog.log(FlowLog.Level.E,""String_Node_Str"");
  }
  mCreationQuery.appendColumnDefinitions(mColumnDefinitions).append(""String_Node_Str"");
}"
27238,"/** 
 * Gets all of the primary fields from the specified class.
 * @param outFields
 * @param inClass
 * @return
 */
public static List<Field> getPrimaryColumnFields(List<Field> outFields,Class<?> inClass){
  for (  Field field : inClass.getDeclaredFields()) {
    Column column=field.getAnnotation(Column.class);
    if (column != null && (column.columnType().type() == ColumnType.PRIMARY_KEY || column.columnType().type() == ColumnType.PRIMARY_KEY_AUTO_INCREMENT)) {
      outFields.add(field);
    }
  }
  if (inClass.getSuperclass() != null && !inClass.getSuperclass().equals(Model.class)) {
    outFields=getAllColumns(outFields,inClass.getSuperclass());
  }
  return outFields;
}","/** 
 * Gets all of the primary fields from the specified class.
 * @param outFields
 * @param inClass
 * @return
 */
public static List<Field> getPrimaryColumnFields(List<Field> outFields,Class<?> inClass){
  for (  Field field : inClass.getDeclaredFields()) {
    if (StructureUtils.isPrimaryKey(field)) {
      outFields.add(field);
    }
  }
  if (inClass.getSuperclass() != null && !inClass.getSuperclass().equals(Model.class)) {
    outFields=getAllColumns(outFields,inClass.getSuperclass());
  }
  return outFields;
}"
27239,"public void initialize(DBConfiguration dbConfiguration,DatabaseHelperListener helperListener){
  mDbConfiguration=dbConfiguration;
  mStructure=new DBStructure(dbConfiguration);
  mHelper=new FlowSQLiteOpenHelper(dbConfiguration);
  mHelper.setDatabaseListener(helperListener);
}","public void initialize(DBConfiguration dbConfiguration,DatabaseHelperListener helperListener){
  mDbConfiguration=dbConfiguration;
  mStructure=new DBStructure(dbConfiguration);
  mHelper=new FlowSQLiteOpenHelper(dbConfiguration);
  mHelper.setDatabaseListener(helperListener);
  getHelper().getWritableDatabase();
}"
27240,"public static void initialize(DBConfiguration dbConfiguration,DatabaseHelperListener databaseHelperListener){
  cache=new ModelCache();
  cache.initialize(dbConfiguration,databaseHelperListener);
}","public static void initialize(DBConfiguration dbConfiguration,DatabaseHelperListener databaseHelperListener){
  if (!isInitialized) {
    getCache().initialize(dbConfiguration,databaseHelperListener);
  }
 else {
    FlowLog.v(FlowManager.class.getSimpleName(),""String_Node_Str"");
  }
}"
27241,"/** 
 * If foreign keys are supported, we turn it on the DB.
 * @param database
 */
private void checkForeignKeySupport(SQLiteDatabase database){
  if (foreignKeysSupported) {
    database.execSQL(""String_Node_Str"");
  }
}","/** 
 * If foreign keys are supported, we turn it on the DB.
 * @param database
 */
private void checkForeignKeySupport(SQLiteDatabase database){
  if (foreignKeysSupported) {
    database.execSQL(""String_Node_Str"");
    FlowLog.i(getClass().getSimpleName(),""String_Node_Str"");
  }
}"
27242,"/** 
 * Deletes all of the models in the specified table with the   {@link com.raizlabs.android.dbflow.runtime.transaction.DeleteTransaction.DeleteWhereArgs}on the   {@link com.raizlabs.android.dbflow.runtime.DBTransactionQueue}
 * @param transctionInfo The information on how we should approach this request.
 * @param deleteWhereArgs The arguments of the deletion
 * @param table The table to delete models from.
 * @param < ModelClass > The class that implements {@link com.raizlabs.android.dbflow.structure.Model}.
 */
public <ModelClass extends Model>void deleteModelsWithQuery(DBTransactionInfo transctionInfo,DeleteTransaction.DeleteWhereArgs deleteWhereArgs,Class<ModelClass> table){
  addTransaction(new DeleteTransaction<ModelClass>(transctionInfo,deleteWhereArgs,table));
}","/** 
 * Deletes all of the models in the specified table with the   {@link com.raizlabs.android.dbflow.sql.builder.AbstractWhereQueryBuilder}on the   {@link com.raizlabs.android.dbflow.runtime.DBTransactionQueue}
 * @param transctionInfo The information on how we should approach this request.
 * @param whereQueryBuilder The where arguments of the deletion
 * @param table The table to delete models from.
 * @param < ModelClass > The class that implements {@link com.raizlabs.android.dbflow.structure.Model}.
 */
public <ModelClass extends Model>void deleteModelsWithQuery(DBTransactionInfo transctionInfo,AbstractWhereQueryBuilder<ModelClass> whereQueryBuilder,Class<ModelClass> table){
  addTransaction(new DeleteTransaction<ModelClass>(transctionInfo,whereQueryBuilder,table));
}"
27243,"/** 
 * Saves al of the passed in models to the   {@link com.raizlabs.android.dbflow.runtime.DBBatchSaveQueue}. This method is recommended for saving large amounts of continuous data as to batch up as much data as possible in a save.
 * @param models The list of models to save
 * @param < ModelClass > The class that implements {@link com.raizlabs.android.dbflow.structure.Model}.
 */
public <ModelClass extends Model>void saveOnSaveQueue(Collection<ModelClass> models){
  getSaveQueue().addAll(models);
}","/** 
 * Saves all of the passed in models to the   {@link com.raizlabs.android.dbflow.runtime.DBBatchSaveQueue}. This method is recommended for saving large amounts of continuous data as to batch up as much data as possible in a save.
 * @param models The list of models to save
 * @param < ModelClass > The class that implements {@link com.raizlabs.android.dbflow.structure.Model}.
 */
public <ModelClass extends Model>void saveOnSaveQueue(Collection<ModelClass> models){
  getSaveQueue().addAll(models);
}"
27244,"public Where<ModelClass> params(Map<String,String> params){
  mWhereQueryBuilder.params(params);
  return this;
}","public Where<ModelClass> params(Map<String,WhereQueryBuilder.WhereArgs> params){
  mWhereQueryBuilder.params(params);
  return this;
}"
27245,"public Where<ModelClass> param(String key,Object value){
  mWhereQueryBuilder.param(key,value);
  return this;
}","public Where<ModelClass> param(String key,WhereQueryBuilder.WhereArgs whereArgs){
  mWhereQueryBuilder.param(key,whereArgs);
  return this;
}"
27246,"protected char[] ensurePadding(char[] chars){
  char[] result=chars;
  int paddingCount=chars.length % 4;
  if (paddingCount > 0) {
    result=new char[chars.length + paddingCount];
    System.arraycopy(chars,0,result,0,chars.length);
    for (int i=0; i < paddingCount; i++) {
      result[chars.length + i]='=';
    }
  }
  return result;
}","protected char[] ensurePadding(char[] chars){
  char[] result=chars;
  int paddingCount=0;
  int remainder=chars.length % 4;
  if (remainder == 2 || remainder == 3) {
    paddingCount=4 - remainder;
  }
  if (paddingCount > 0) {
    result=new char[chars.length + paddingCount];
    System.arraycopy(chars,0,result,0,chars.length);
    for (int i=0; i < paddingCount; i++) {
      result[chars.length + i]='=';
    }
  }
  return result;
}"
27247,"@Override public <T>T parse(String compact,JwtHandler<T> handler) throws MalformedJwtException, SignatureException {
  Assert.notNull(handler,""String_Node_Str"");
  Assert.hasText(compact,""String_Node_Str"");
  Jwt jwt=parse(compact);
  if (jwt instanceof Jws) {
    Jws jws=(Jws)jwt;
    Object body=jws.getBody();
    if (body instanceof Claims) {
      return handler.onClaimsJws(jws);
    }
 else {
      return handler.onPlaintextJws(jws);
    }
  }
 else {
    Object body=jwt.getBody();
    if (body instanceof Claims) {
      return handler.onPlaintextJwt(jwt);
    }
 else {
      return handler.onClaimsJwt(jwt);
    }
  }
}","@Override public <T>T parse(String compact,JwtHandler<T> handler) throws MalformedJwtException, SignatureException {
  Assert.notNull(handler,""String_Node_Str"");
  Assert.hasText(compact,""String_Node_Str"");
  Jwt jwt=parse(compact);
  if (jwt instanceof Jws) {
    Jws jws=(Jws)jwt;
    Object body=jws.getBody();
    if (body instanceof Claims) {
      return handler.onClaimsJws((Jws<Claims>)jws);
    }
 else {
      return handler.onPlaintextJws((Jws<String>)jws);
    }
  }
 else {
    Object body=jwt.getBody();
    if (body instanceof Claims) {
      return handler.onClaimsJwt((Jwt<Header,Claims>)jwt);
    }
 else {
      return handler.onPlaintextJwt((Jwt<Header,String>)jwt);
    }
  }
}"
27248,"private void drawHeaderRowAndEvents(Canvas canvas){
  mHeaderColumnWidth=mTimeTextWidth + mHeaderColumnPadding * 2;
  mWidthPerDay=getWidth() - mHeaderColumnWidth - mColumnGap * (mNumberOfVisibleDays - 1);
  mWidthPerDay=mWidthPerDay / mNumberOfVisibleDays;
  Calendar today=today();
  if (mAreDimensionsInvalid) {
    mEffectiveMinHourHeight=Math.max(mMinHourHeight,(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / 24));
    mAreDimensionsInvalid=false;
    if (mScrollToDay != null)     goToDate(mScrollToDay);
    mAreDimensionsInvalid=false;
    if (mScrollToHour >= 0)     goToHour(mScrollToHour);
    mScrollToDay=null;
    mScrollToHour=-1;
    mAreDimensionsInvalid=false;
  }
  if (mIsFirstDraw) {
    mIsFirstDraw=false;
    if (mNumberOfVisibleDays >= 7 && today.get(Calendar.DAY_OF_WEEK) != mFirstDayOfWeek) {
      int difference=7 + (today.get(Calendar.DAY_OF_WEEK) - mFirstDayOfWeek);
      mCurrentOrigin.x+=(mWidthPerDay + mColumnGap) * difference;
    }
  }
  if (mNewHourHeight > 0) {
    if (mNewHourHeight < mEffectiveMinHourHeight)     mNewHourHeight=mEffectiveMinHourHeight;
 else     if (mNewHourHeight > mMaxHourHeight)     mNewHourHeight=mMaxHourHeight;
    mCurrentOrigin.y=(mCurrentOrigin.y / mHourHeight) * mNewHourHeight;
    mHourHeight=mNewHourHeight;
    mNewHourHeight=-1;
  }
  if (mCurrentOrigin.y < getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom - mTimeTextHeight / 2)   mCurrentOrigin.y=getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom - mTimeTextHeight / 2;
  if (mCurrentOrigin.y > 0) {
    mCurrentOrigin.y=0;
  }
  int leftDaysWithGaps=(int)-(Math.ceil(mCurrentOrigin.x / (mWidthPerDay + mColumnGap)));
  float startFromPixel=mCurrentOrigin.x + (mWidthPerDay + mColumnGap) * leftDaysWithGaps + mHeaderColumnWidth;
  float startPixel=startFromPixel;
  Calendar day=(Calendar)today.clone();
  day.add(Calendar.HOUR,6);
  int lineCount=(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / mHourHeight) + 1;
  lineCount=(lineCount) * (mNumberOfVisibleDays + 1);
  float[] hourLines=new float[lineCount * 4];
  if (mEventRects != null) {
    for (    EventRect eventRect : mEventRects) {
      eventRect.rectF=null;
    }
  }
  canvas.clipRect(mHeaderColumnWidth,mHeaderTextHeight + mHeaderRowPadding * 2 + mHeaderMarginBottom + mTimeTextHeight / 2,getWidth(),getHeight(),Region.Op.REPLACE);
  Calendar oldFirstVisibleDay=mFirstVisibleDay;
  mFirstVisibleDay=(Calendar)today.clone();
  mFirstVisibleDay.add(Calendar.DATE,-(Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap))));
  if (!mFirstVisibleDay.equals(oldFirstVisibleDay) && mScrollListener != null) {
    mScrollListener.onFirstVisibleDayChanged(mFirstVisibleDay,oldFirstVisibleDay);
  }
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    mLastVisibleDay=(Calendar)day.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    mLastVisibleDay.add(Calendar.DATE,dayNumber - 2);
    boolean sameDay=isSameDay(day,today);
    if (mEventRects == null || mRefreshEvents || (dayNumber == leftDaysWithGaps + 1 && mFetchedPeriod != (int)mWeekViewLoader.toWeekViewPeriodIndex(day) && Math.abs(mFetchedPeriod - mWeekViewLoader.toWeekViewPeriodIndex(day)) > 0.5)) {
      getMoreEvents(day);
      mRefreshEvents=false;
    }
    float start=(startPixel < mHeaderColumnWidth ? mHeaderColumnWidth : startPixel);
    if (mWidthPerDay + startPixel - start > 0) {
      if (mShowDistinctPastFutureColor) {
        boolean isWeekend=day.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY;
        Paint pastPaint=isWeekend && mShowDistinctWeekendColor ? mPastWeekendBackgroundPaint : mPastBackgroundPaint;
        Paint futurePaint=isWeekend && mShowDistinctWeekendColor ? mFutureWeekendBackgroundPaint : mFutureBackgroundPaint;
        float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
        if (sameDay) {
          Calendar now=Calendar.getInstance();
          float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,startY + beforeNow,pastPaint);
          canvas.drawRect(start,startY + beforeNow,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
 else         if (day.before(today)) {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),pastPaint);
        }
 else {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
      }
 else {
        canvas.drawRect(start,mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom,startPixel + mWidthPerDay,getHeight(),sameDay ? mTodayBackgroundPaint : mDayBackgroundPaint);
      }
    }
    int i=0;
    for (int hourNumber=0; hourNumber < 24; hourNumber++) {
      float top=mHeaderTextHeight + mHeaderRowPadding * 2 + mCurrentOrigin.y + mHourHeight * hourNumber + mTimeTextHeight / 2 + mHeaderMarginBottom;
      if (top > mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom - mHourSeparatorHeight && top < getHeight() && startPixel + mWidthPerDay - start > 0) {
        hourLines[i * 4]=start;
        hourLines[i * 4 + 1]=top;
        hourLines[i * 4 + 2]=startPixel + mWidthPerDay;
        hourLines[i * 4 + 3]=top;
        i++;
      }
    }
    canvas.drawLines(hourLines,mHourSeparatorPaint);
    drawEvents(day,startPixel,canvas);
    if (mShowNowLine && sameDay) {
      float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
      Calendar now=Calendar.getInstance();
      float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
      canvas.drawLine(start,startY + beforeNow,startPixel + mWidthPerDay,startY + beforeNow,mNowLinePaint);
    }
    startPixel+=mWidthPerDay + mColumnGap;
  }
  canvas.clipRect(mHeaderColumnWidth,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,Region.Op.REPLACE);
  canvas.drawRect(0,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,mHeaderBackgroundPaint);
  startPixel=startFromPixel;
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    boolean sameDay=isSameDay(day,today);
    String dayLabel=getDateTimeInterpreter().interpretDate(day);
    if (dayLabel == null)     throw new IllegalStateException(""String_Node_Str"");
    canvas.drawText(dayLabel,startPixel + mWidthPerDay / 2,mHeaderTextHeight + mHeaderRowPadding,sameDay ? mTodayHeaderTextPaint : mHeaderTextPaint);
    startPixel+=mWidthPerDay + mColumnGap;
  }
}","private void drawHeaderRowAndEvents(Canvas canvas){
  mHeaderColumnWidth=mTimeTextWidth + mHeaderColumnPadding * 2;
  mWidthPerDay=getWidth() - mHeaderColumnWidth - mColumnGap * (mNumberOfVisibleDays - 1);
  mWidthPerDay=mWidthPerDay / mNumberOfVisibleDays;
  Calendar today=today();
  if (mAreDimensionsInvalid) {
    mEffectiveMinHourHeight=Math.max(mMinHourHeight,(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / 24));
    mAreDimensionsInvalid=false;
    if (mScrollToDay != null)     goToDate(mScrollToDay);
    mAreDimensionsInvalid=false;
    if (mScrollToHour >= 0)     goToHour(mScrollToHour);
    mScrollToDay=null;
    mScrollToHour=-1;
    mAreDimensionsInvalid=false;
  }
  if (mIsFirstDraw) {
    mIsFirstDraw=false;
    if (mNumberOfVisibleDays >= 7 && today.get(Calendar.DAY_OF_WEEK) != mFirstDayOfWeek && mshowFirstDayOfWeekFirst) {
      int difference=(today.get(Calendar.DAY_OF_WEEK) - mFirstDayOfWeek);
      mCurrentOrigin.x+=(mWidthPerDay + mColumnGap) * difference;
    }
  }
  if (mNewHourHeight > 0) {
    if (mNewHourHeight < mEffectiveMinHourHeight)     mNewHourHeight=mEffectiveMinHourHeight;
 else     if (mNewHourHeight > mMaxHourHeight)     mNewHourHeight=mMaxHourHeight;
    mCurrentOrigin.y=(mCurrentOrigin.y / mHourHeight) * mNewHourHeight;
    mHourHeight=mNewHourHeight;
    mNewHourHeight=-1;
  }
  if (mCurrentOrigin.y < getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom - mTimeTextHeight / 2)   mCurrentOrigin.y=getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom - mTimeTextHeight / 2;
  if (mCurrentOrigin.y > 0) {
    mCurrentOrigin.y=0;
  }
  int leftDaysWithGaps=(int)-(Math.ceil(mCurrentOrigin.x / (mWidthPerDay + mColumnGap)));
  float startFromPixel=mCurrentOrigin.x + (mWidthPerDay + mColumnGap) * leftDaysWithGaps + mHeaderColumnWidth;
  float startPixel=startFromPixel;
  Calendar day=(Calendar)today.clone();
  day.add(Calendar.HOUR,6);
  int lineCount=(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / mHourHeight) + 1;
  lineCount=(lineCount) * (mNumberOfVisibleDays + 1);
  float[] hourLines=new float[lineCount * 4];
  if (mEventRects != null) {
    for (    EventRect eventRect : mEventRects) {
      eventRect.rectF=null;
    }
  }
  canvas.clipRect(mHeaderColumnWidth,mHeaderTextHeight + mHeaderRowPadding * 2 + mHeaderMarginBottom + mTimeTextHeight / 2,getWidth(),getHeight(),Region.Op.REPLACE);
  Calendar oldFirstVisibleDay=mFirstVisibleDay;
  mFirstVisibleDay=(Calendar)today.clone();
  mFirstVisibleDay.add(Calendar.DATE,-(Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap))));
  if (!mFirstVisibleDay.equals(oldFirstVisibleDay) && mScrollListener != null) {
    mScrollListener.onFirstVisibleDayChanged(mFirstVisibleDay,oldFirstVisibleDay);
  }
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    mLastVisibleDay=(Calendar)day.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    mLastVisibleDay.add(Calendar.DATE,dayNumber - 2);
    boolean sameDay=isSameDay(day,today);
    if (mEventRects == null || mRefreshEvents || (dayNumber == leftDaysWithGaps + 1 && mFetchedPeriod != (int)mWeekViewLoader.toWeekViewPeriodIndex(day) && Math.abs(mFetchedPeriod - mWeekViewLoader.toWeekViewPeriodIndex(day)) > 0.5)) {
      getMoreEvents(day);
      mRefreshEvents=false;
    }
    float start=(startPixel < mHeaderColumnWidth ? mHeaderColumnWidth : startPixel);
    if (mWidthPerDay + startPixel - start > 0) {
      if (mShowDistinctPastFutureColor) {
        boolean isWeekend=day.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY;
        Paint pastPaint=isWeekend && mShowDistinctWeekendColor ? mPastWeekendBackgroundPaint : mPastBackgroundPaint;
        Paint futurePaint=isWeekend && mShowDistinctWeekendColor ? mFutureWeekendBackgroundPaint : mFutureBackgroundPaint;
        float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
        if (sameDay) {
          Calendar now=Calendar.getInstance();
          float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,startY + beforeNow,pastPaint);
          canvas.drawRect(start,startY + beforeNow,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
 else         if (day.before(today)) {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),pastPaint);
        }
 else {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
      }
 else {
        canvas.drawRect(start,mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom,startPixel + mWidthPerDay,getHeight(),sameDay ? mTodayBackgroundPaint : mDayBackgroundPaint);
      }
    }
    int i=0;
    for (int hourNumber=0; hourNumber < 24; hourNumber++) {
      float top=mHeaderTextHeight + mHeaderRowPadding * 2 + mCurrentOrigin.y + mHourHeight * hourNumber + mTimeTextHeight / 2 + mHeaderMarginBottom;
      if (top > mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom - mHourSeparatorHeight && top < getHeight() && startPixel + mWidthPerDay - start > 0) {
        hourLines[i * 4]=start;
        hourLines[i * 4 + 1]=top;
        hourLines[i * 4 + 2]=startPixel + mWidthPerDay;
        hourLines[i * 4 + 3]=top;
        i++;
      }
    }
    canvas.drawLines(hourLines,mHourSeparatorPaint);
    drawEvents(day,startPixel,canvas);
    if (mShowNowLine && sameDay) {
      float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
      Calendar now=Calendar.getInstance();
      float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
      canvas.drawLine(start,startY + beforeNow,startPixel + mWidthPerDay,startY + beforeNow,mNowLinePaint);
    }
    startPixel+=mWidthPerDay + mColumnGap;
  }
  canvas.clipRect(mHeaderColumnWidth,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,Region.Op.REPLACE);
  canvas.drawRect(0,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,mHeaderBackgroundPaint);
  startPixel=startFromPixel;
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    boolean sameDay=isSameDay(day,today);
    String dayLabel=getDateTimeInterpreter().interpretDate(day);
    if (dayLabel == null)     throw new IllegalStateException(""String_Node_Str"");
    canvas.drawText(dayLabel,startPixel + mWidthPerDay / 2,mHeaderTextHeight + mHeaderRowPadding,sameDay ? mTodayHeaderTextPaint : mHeaderTextPaint);
    startPixel+=mWidthPerDay + mColumnGap;
  }
}"
27249,"public void setVerticalFlingEnabled(boolean enabled){
  mVerticalFlingEnabled=enabled;
}","/** 
 * Set whether the week view should fling vertically.
 * @return True if it should have vertical fling enabled.
 */
public void setVerticalFlingEnabled(boolean enabled){
  mVerticalFlingEnabled=enabled;
}"
27250,"public void setHorizontalFlingEnabled(boolean enabled){
  mHorizontalFlingEnabled=enabled;
}","/** 
 * Set whether the week view should fling horizontally.
 * @return True if it should have horizontal fling enabled.
 */
public void setHorizontalFlingEnabled(boolean enabled){
  mHorizontalFlingEnabled=enabled;
}"
27251,"public boolean isHorizontalFlingEnabled(){
  return mHorizontalFlingEnabled;
}","/** 
 * Get whether the week view should fling horizontally.
 * @return True if the week view has horizontal fling enabled.
 */
public boolean isHorizontalFlingEnabled(){
  return mHorizontalFlingEnabled;
}"
27252,"public boolean isVerticalFlingEnabled(){
  return mVerticalFlingEnabled;
}","/** 
 * Get whether the week view should fling vertically.
 * @return True if the week view has vertical fling enabled.
 */
public boolean isVerticalFlingEnabled(){
  return mVerticalFlingEnabled;
}"
27253,"/** 
 * Draw the name of the event on top of the event rectangle.
 * @param event The event of which the title (and location) should be drawn.
 * @param rect The rectangle on which the text is to be drawn.
 * @param canvas The canvas to draw upon.
 * @param originalTop The original top position of the rectangle. The rectangle may have some of its portion outside of the visible area.
 * @param originalLeft The original left position of the rectangle. The rectangle may have some of its portion outside of the visible area.
 */
private void drawEventTitle(WeekViewEvent event,RectF rect,Canvas canvas,float originalTop,float originalLeft){
  if (rect.right - rect.left - mEventPadding * 2 < 0)   return;
  SpannableStringBuilder bob=new SpannableStringBuilder();
  if (event.getName() != null) {
    bob.append(event.getName());
    bob.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),0,bob.length(),0);
    bob.append(' ');
  }
  if (event.getLocation() != null) {
    bob.append(event.getLocation());
  }
  StaticLayout textLayout=new StaticLayout(bob,mEventTextPaint,(int)(rect.right - originalLeft - mEventPadding * 2),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,false);
  int availableHeight=(int)(rect.bottom - originalTop - mEventPadding * 2);
  int lineHeight=textLayout.getHeight() / textLayout.getLineCount();
  if (lineHeight < availableHeight && textLayout.getHeight() > rect.height() - mEventPadding * 2) {
    int lineCount=textLayout.getLineCount();
    int availableLineCount=(int)Math.floor(lineCount * availableHeight / textLayout.getHeight());
    float widthAvailable=(rect.right - originalLeft - mEventPadding * 2) * availableLineCount;
    textLayout=new StaticLayout(TextUtils.ellipsize(bob,mEventTextPaint,widthAvailable,TextUtils.TruncateAt.END),mEventTextPaint,(int)(rect.right - originalLeft - mEventPadding * 2),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,false);
  }
 else   if (lineHeight >= availableHeight) {
    int width=(int)(rect.right - originalLeft - mEventPadding * 2);
    textLayout=new StaticLayout(TextUtils.ellipsize(bob,mEventTextPaint,width,TextUtils.TruncateAt.END),mEventTextPaint,width,Layout.Alignment.ALIGN_NORMAL,1.0f,1.0f,false);
  }
  canvas.save();
  canvas.translate(originalLeft + mEventPadding,originalTop + mEventPadding);
  textLayout.draw(canvas);
  canvas.restore();
}","/** 
 * Draw the name of the event on top of the event rectangle.
 * @param event The event of which the title (and location) should be drawn.
 * @param rect The rectangle on which the text is to be drawn.
 * @param canvas The canvas to draw upon.
 * @param originalTop The original top position of the rectangle. The rectangle may have some of its portion outside of the visible area.
 * @param originalLeft The original left position of the rectangle. The rectangle may have some of its portion outside of the visible area.
 */
private void drawEventTitle(WeekViewEvent event,RectF rect,Canvas canvas,float originalTop,float originalLeft){
  if (rect.right - rect.left - mEventPadding * 2 < 0)   return;
  if (rect.bottom - rect.top - mEventPadding * 2 < 0)   return;
  SpannableStringBuilder bob=new SpannableStringBuilder();
  if (event.getName() != null) {
    bob.append(event.getName());
    bob.setSpan(new StyleSpan(android.graphics.Typeface.BOLD),0,bob.length(),0);
    bob.append(' ');
  }
  if (event.getLocation() != null) {
    bob.append(event.getLocation());
  }
  int availableHeight=(int)(rect.bottom - originalTop - mEventPadding * 2);
  int availableWidth=(int)(rect.right - originalLeft - mEventPadding * 2);
  StaticLayout textLayout=new StaticLayout(bob,mEventTextPaint,availableWidth,Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,false);
  int lineHeight=textLayout.getHeight() / textLayout.getLineCount();
  if (availableHeight >= lineHeight) {
    int availableLineCount=availableHeight / lineHeight;
    do {
      textLayout=new StaticLayout(TextUtils.ellipsize(bob,mEventTextPaint,availableLineCount * availableWidth,TextUtils.TruncateAt.END),mEventTextPaint,(int)(rect.right - originalLeft - mEventPadding * 2),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,false);
      availableLineCount--;
    }
 while (textLayout.getHeight() > availableHeight);
    canvas.save();
    canvas.translate(originalLeft + mEventPadding,originalTop + mEventPadding);
    textLayout.draw(canvas);
    canvas.restore();
  }
}"
27254,"private void init(){
  mGestureDetector=new GestureDetectorCompat(mContext,mGestureListener);
  mScroller=new OverScroller(mContext);
  mTimeTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTimeTextPaint.setTextAlign(Paint.Align.RIGHT);
  mTimeTextPaint.setTextSize(mTextSize);
  mTimeTextPaint.setColor(mHeaderColumnTextColor);
  Rect rect=new Rect();
  mTimeTextPaint.getTextBounds(""String_Node_Str"",0,""String_Node_Str"".length(),rect);
  mTimeTextHeight=rect.height();
  mHeaderMarginBottom=mTimeTextHeight / 2;
  initTextTimeWidth();
  mHeaderTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHeaderTextPaint.setColor(mHeaderColumnTextColor);
  mHeaderTextPaint.setTextAlign(Paint.Align.CENTER);
  mHeaderTextPaint.setTextSize(mTextSize);
  mHeaderTextPaint.getTextBounds(""String_Node_Str"",0,""String_Node_Str"".length(),rect);
  mHeaderTextHeight=rect.height();
  mHeaderTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
  mHeaderBackgroundPaint=new Paint();
  mHeaderBackgroundPaint.setColor(mHeaderRowBackgroundColor);
  mDayBackgroundPaint=new Paint();
  mDayBackgroundPaint.setColor(mDayBackgroundColor);
  mFutureBackgroundPaint=new Paint();
  mFutureBackgroundPaint.setColor(mFutureBackgroundColor);
  mPastBackgroundPaint=new Paint();
  mPastBackgroundPaint.setColor(mPastBackgroundColor);
  mFutureWeekendBackgroundPaint=new Paint();
  mFutureWeekendBackgroundPaint.setColor(mFutureWeekendBackgroundColor);
  mPastWeekendBackgroundPaint=new Paint();
  mPastWeekendBackgroundPaint.setColor(mPastWeekendBackgroundColor);
  mHourSeparatorPaint=new Paint();
  mHourSeparatorPaint.setStyle(Paint.Style.STROKE);
  mHourSeparatorPaint.setStrokeWidth(mHourSeparatorHeight);
  mHourSeparatorPaint.setColor(mHourSeparatorColor);
  mNowLinePaint=new Paint();
  mNowLinePaint.setStrokeWidth(mNowLineThickness);
  mNowLinePaint.setColor(mNowLineColor);
  mTodayBackgroundPaint=new Paint();
  mTodayBackgroundPaint.setColor(mTodayBackgroundColor);
  mTodayHeaderTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTodayHeaderTextPaint.setTextAlign(Paint.Align.CENTER);
  mTodayHeaderTextPaint.setTextSize(mTextSize);
  mTodayHeaderTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
  mTodayHeaderTextPaint.setColor(mTodayHeaderTextColor);
  mEventBackgroundPaint=new Paint();
  mEventBackgroundPaint.setColor(Color.rgb(174,208,238));
  mHeaderColumnBackgroundPaint=new Paint();
  mHeaderColumnBackgroundPaint.setColor(mHeaderColumnBackgroundColor);
  mEventTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG | Paint.LINEAR_TEXT_FLAG);
  mEventTextPaint.setStyle(Paint.Style.FILL);
  mEventTextPaint.setColor(mEventTextColor);
  mEventTextPaint.setTextSize(mEventTextSize);
  mDefaultEventColor=Color.parseColor(""String_Node_Str"");
  mScaleDetector=new ScaleGestureDetector(mContext,new ScaleGestureDetector.OnScaleGestureListener(){
    @Override public void onScaleEnd(    ScaleGestureDetector detector){
      mIsZooming=false;
    }
    @Override public boolean onScaleBegin(    ScaleGestureDetector detector){
      mIsZooming=true;
      goToNearestOrigin();
      return true;
    }
    @Override public boolean onScale(    ScaleGestureDetector detector){
      mNewHourHeight=Math.round(mHourHeight * detector.getScaleFactor());
      invalidate();
      return true;
    }
  }
);
}","private void init(){
  mGestureDetector=new GestureDetectorCompat(mContext,mGestureListener);
  mScroller=new OverScroller(mContext,new FastOutLinearInInterpolator());
  mMinimumFlingVelocity=ViewConfiguration.get(mContext).getScaledMinimumFlingVelocity();
  mScaledTouchSlop=ViewConfiguration.get(mContext).getScaledTouchSlop();
  mTimeTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTimeTextPaint.setTextAlign(Paint.Align.RIGHT);
  mTimeTextPaint.setTextSize(mTextSize);
  mTimeTextPaint.setColor(mHeaderColumnTextColor);
  Rect rect=new Rect();
  mTimeTextPaint.getTextBounds(""String_Node_Str"",0,""String_Node_Str"".length(),rect);
  mTimeTextHeight=rect.height();
  mHeaderMarginBottom=mTimeTextHeight / 2;
  initTextTimeWidth();
  mHeaderTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHeaderTextPaint.setColor(mHeaderColumnTextColor);
  mHeaderTextPaint.setTextAlign(Paint.Align.CENTER);
  mHeaderTextPaint.setTextSize(mTextSize);
  mHeaderTextPaint.getTextBounds(""String_Node_Str"",0,""String_Node_Str"".length(),rect);
  mHeaderTextHeight=rect.height();
  mHeaderTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
  mHeaderBackgroundPaint=new Paint();
  mHeaderBackgroundPaint.setColor(mHeaderRowBackgroundColor);
  mDayBackgroundPaint=new Paint();
  mDayBackgroundPaint.setColor(mDayBackgroundColor);
  mFutureBackgroundPaint=new Paint();
  mFutureBackgroundPaint.setColor(mFutureBackgroundColor);
  mPastBackgroundPaint=new Paint();
  mPastBackgroundPaint.setColor(mPastBackgroundColor);
  mFutureWeekendBackgroundPaint=new Paint();
  mFutureWeekendBackgroundPaint.setColor(mFutureWeekendBackgroundColor);
  mPastWeekendBackgroundPaint=new Paint();
  mPastWeekendBackgroundPaint.setColor(mPastWeekendBackgroundColor);
  mHourSeparatorPaint=new Paint();
  mHourSeparatorPaint.setStyle(Paint.Style.STROKE);
  mHourSeparatorPaint.setStrokeWidth(mHourSeparatorHeight);
  mHourSeparatorPaint.setColor(mHourSeparatorColor);
  mNowLinePaint=new Paint();
  mNowLinePaint.setStrokeWidth(mNowLineThickness);
  mNowLinePaint.setColor(mNowLineColor);
  mTodayBackgroundPaint=new Paint();
  mTodayBackgroundPaint.setColor(mTodayBackgroundColor);
  mTodayHeaderTextPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mTodayHeaderTextPaint.setTextAlign(Paint.Align.CENTER);
  mTodayHeaderTextPaint.setTextSize(mTextSize);
  mTodayHeaderTextPaint.setTypeface(Typeface.DEFAULT_BOLD);
  mTodayHeaderTextPaint.setColor(mTodayHeaderTextColor);
  mEventBackgroundPaint=new Paint();
  mEventBackgroundPaint.setColor(Color.rgb(174,208,238));
  mHeaderColumnBackgroundPaint=new Paint();
  mHeaderColumnBackgroundPaint.setColor(mHeaderColumnBackgroundColor);
  mEventTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG | Paint.LINEAR_TEXT_FLAG);
  mEventTextPaint.setStyle(Paint.Style.FILL);
  mEventTextPaint.setColor(mEventTextColor);
  mEventTextPaint.setTextSize(mEventTextSize);
  mDefaultEventColor=Color.parseColor(""String_Node_Str"");
  mScaleDetector=new ScaleGestureDetector(mContext,new ScaleGestureDetector.OnScaleGestureListener(){
    @Override public void onScaleEnd(    ScaleGestureDetector detector){
      mIsZooming=false;
    }
    @Override public boolean onScaleBegin(    ScaleGestureDetector detector){
      mIsZooming=true;
      goToNearestOrigin();
      return true;
    }
    @Override public boolean onScale(    ScaleGestureDetector detector){
      mNewHourHeight=Math.round(mHourHeight * detector.getScaleFactor());
      invalidate();
      return true;
    }
  }
);
}"
27255,"@Override public void computeScroll(){
  super.computeScroll();
  if (mScroller.isFinished()) {
    if (mCurrentFlingDirection != Direction.NONE) {
      goToNearestOrigin();
    }
  }
 else {
    if (mScroller.computeScrollOffset()) {
      mCurrentOrigin.y=mScroller.getCurrY();
      mCurrentOrigin.x=mScroller.getCurrX();
      ViewCompat.postInvalidateOnAnimation(this);
    }
  }
}","@Override public void computeScroll(){
  super.computeScroll();
  if (mScroller.isFinished()) {
    if (mCurrentFlingDirection != Direction.NONE) {
      goToNearestOrigin();
    }
  }
 else {
    if (mCurrentFlingDirection != Direction.NONE && forceFinishScroll()) {
      goToNearestOrigin();
    }
 else     if (mScroller.computeScrollOffset()) {
      mCurrentOrigin.y=mScroller.getCurrY();
      mCurrentOrigin.x=mScroller.getCurrX();
      ViewCompat.postInvalidateOnAnimation(this);
    }
  }
}"
27256,"@Override public boolean onTouchEvent(MotionEvent event){
  mScaleDetector.onTouchEvent(event);
  boolean val=mGestureDetector.onTouchEvent(event);
  if (event.getAction() == MotionEvent.ACTION_UP && !mIsZooming && mCurrentFlingDirection == Direction.NONE) {
    if (mCurrentScrollDirection == Direction.HORIZONTAL) {
      goToNearestOrigin();
    }
    mCurrentScrollDirection=Direction.NONE;
  }
  return val;
}","@Override public boolean onTouchEvent(MotionEvent event){
  mScaleDetector.onTouchEvent(event);
  boolean val=mGestureDetector.onTouchEvent(event);
  if (event.getAction() == MotionEvent.ACTION_UP && !mIsZooming && mCurrentFlingDirection == Direction.NONE) {
    if (mCurrentScrollDirection == Direction.RIGHT || mCurrentScrollDirection == Direction.LEFT) {
      goToNearestOrigin();
    }
    mCurrentScrollDirection=Direction.NONE;
  }
  return val;
}"
27257,"private void goToNearestOrigin(){
  float leftDays=Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap));
  int nearestOrigin=(int)(mCurrentOrigin.x - leftDays * (mWidthPerDay + mColumnGap));
  if (nearestOrigin != 0) {
    mScroller.forceFinished(true);
    mScroller.startScroll((int)mCurrentOrigin.x,(int)mCurrentOrigin.y,-nearestOrigin,0,50);
    ViewCompat.postInvalidateOnAnimation(WeekView.this);
  }
  mCurrentScrollDirection=mCurrentFlingDirection=Direction.NONE;
}","private void goToNearestOrigin(){
  double leftDays=mCurrentOrigin.x / (mWidthPerDay + mColumnGap);
  if (mCurrentFlingDirection != Direction.NONE) {
    leftDays=Math.round(leftDays);
  }
 else   if (mCurrentScrollDirection == Direction.LEFT) {
    leftDays=Math.floor(leftDays);
  }
 else   if (mCurrentScrollDirection == Direction.RIGHT) {
    leftDays=Math.ceil(leftDays);
  }
 else {
    leftDays=Math.round(leftDays);
  }
  int nearestOrigin=(int)(mCurrentOrigin.x - leftDays * (mWidthPerDay + mColumnGap));
  if (nearestOrigin != 0) {
    mScroller.forceFinished(true);
    mScroller.startScroll((int)mCurrentOrigin.x,(int)mCurrentOrigin.y,-nearestOrigin,0,(int)(Math.abs(nearestOrigin) / mWidthPerDay * 500));
    ViewCompat.postInvalidateOnAnimation(WeekView.this);
  }
  mCurrentScrollDirection=mCurrentFlingDirection=Direction.NONE;
}"
27258,"private void drawHeaderRowAndEvents(Canvas canvas){
  mHeaderColumnWidth=mTimeTextWidth + mHeaderColumnPadding * 2;
  mWidthPerDay=getWidth() - mHeaderColumnWidth - mColumnGap * (mNumberOfVisibleDays - 1);
  mWidthPerDay=mWidthPerDay / mNumberOfVisibleDays;
  Calendar today=today();
  if (mAreDimensionsInvalid) {
    mEffectiveMinHourHeight=Math.max(mMinHourHeight,(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / 24));
    mAreDimensionsInvalid=false;
    if (mScrollToDay != null)     goToDate(mScrollToDay);
    mAreDimensionsInvalid=false;
    if (mScrollToHour >= 0)     goToHour(mScrollToHour);
    mScrollToDay=null;
    mScrollToHour=-1;
    mAreDimensionsInvalid=false;
  }
  if (mIsFirstDraw) {
    mIsFirstDraw=false;
    if (mNumberOfVisibleDays >= 7 && today.get(Calendar.DAY_OF_WEEK) != mFirstDayOfWeek) {
      int difference=7 + (today.get(Calendar.DAY_OF_WEEK) - mFirstDayOfWeek);
      mCurrentOrigin.x+=(mWidthPerDay + mColumnGap) * difference;
    }
  }
  if (mCurrentScrollDirection == Direction.VERTICAL)   mCurrentOrigin.y-=mDistanceY;
  if (mNewHourHeight > 0) {
    if (mNewHourHeight < mEffectiveMinHourHeight)     mNewHourHeight=mEffectiveMinHourHeight;
 else     if (mNewHourHeight > mMaxHourHeight)     mNewHourHeight=mMaxHourHeight;
    mCurrentOrigin.y=(mCurrentOrigin.y / mHourHeight) * mNewHourHeight;
    mHourHeight=mNewHourHeight;
    mNewHourHeight=-1;
  }
  if (mCurrentOrigin.y < getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom)   mCurrentOrigin.y=getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom;
  if (mCurrentOrigin.y > 0)   mCurrentOrigin.y=0;
  if (mCurrentScrollDirection == Direction.HORIZONTAL)   mCurrentOrigin.x-=mDistanceX;
  int leftDaysWithGaps=(int)-(Math.ceil(mCurrentOrigin.x / (mWidthPerDay + mColumnGap)));
  float startFromPixel=mCurrentOrigin.x + (mWidthPerDay + mColumnGap) * leftDaysWithGaps + mHeaderColumnWidth;
  float startPixel=startFromPixel;
  Calendar day=(Calendar)today.clone();
  day.add(Calendar.HOUR,6);
  int lineCount=(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / mHourHeight) + 1;
  lineCount=(lineCount) * (mNumberOfVisibleDays + 1);
  float[] hourLines=new float[lineCount * 4];
  if (mEventRects != null) {
    for (    EventRect eventRect : mEventRects) {
      eventRect.rectF=null;
    }
  }
  Calendar oldFirstVisibleDay=mFirstVisibleDay;
  mFirstVisibleDay=(Calendar)today.clone();
  mFirstVisibleDay.add(Calendar.DATE,-(Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap))));
  if (!mFirstVisibleDay.equals(oldFirstVisibleDay) && mScrolledListener != null) {
    mScrolledListener.onFirstVisibleDayChanged(mFirstVisibleDay,oldFirstVisibleDay);
  }
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    mLastVisibleDay=(Calendar)day.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    mLastVisibleDay.add(Calendar.DATE,dayNumber - 2);
    boolean sameDay=isSameDay(day,today);
    if (mEventRects == null || mRefreshEvents || (dayNumber == leftDaysWithGaps + 1 && mFetchedPeriod != (int)mWeekViewLoader.toWeekViewPeriodIndex(day) && Math.abs(mFetchedPeriod - mWeekViewLoader.toWeekViewPeriodIndex(day)) > 0.5)) {
      getMoreEvents(day);
      mRefreshEvents=false;
    }
    float start=(startPixel < mHeaderColumnWidth ? mHeaderColumnWidth : startPixel);
    if (mWidthPerDay + startPixel - start > 0) {
      if (mUseNewColoring) {
        boolean isWeekend=(day.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY);
        Paint pastPaint=isWeekend ? mPastWeekendBackgroundPaint : mPastBackgroundPaint;
        Paint futurePaint=isWeekend ? mFutureWeekendBackgroundPaint : mFutureBackgroundPaint;
        float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
        if (sameDay) {
          Calendar now=Calendar.getInstance();
          float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,startY + beforeNow,pastPaint);
          canvas.drawRect(start,startY + beforeNow,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
 else         if (day.before(today)) {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),pastPaint);
        }
 else {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
      }
 else {
        canvas.drawRect(start,mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom,startPixel + mWidthPerDay,getHeight(),sameDay ? mTodayBackgroundPaint : mDayBackgroundPaint);
      }
    }
    int i=0;
    for (int hourNumber=0; hourNumber < 24; hourNumber++) {
      float top=mHeaderTextHeight + mHeaderRowPadding * 2 + mCurrentOrigin.y + mHourHeight * hourNumber + mTimeTextHeight / 2 + mHeaderMarginBottom;
      if (top > mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom - mHourSeparatorHeight && top < getHeight() && startPixel + mWidthPerDay - start > 0) {
        hourLines[i * 4]=start;
        hourLines[i * 4 + 1]=top;
        hourLines[i * 4 + 2]=startPixel + mWidthPerDay;
        hourLines[i * 4 + 3]=top;
        i++;
      }
    }
    canvas.drawLines(hourLines,mHourSeparatorPaint);
    drawEvents(day,startPixel,canvas);
    if (mUseNewColoring && sameDay) {
      float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
      Calendar now=Calendar.getInstance();
      float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
      canvas.drawLine(start,startY + beforeNow,startPixel + mWidthPerDay,startY + beforeNow,mNowLinePaint);
    }
    startPixel+=mWidthPerDay + mColumnGap;
  }
  canvas.drawRect(0,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,mHeaderBackgroundPaint);
  startPixel=startFromPixel;
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    boolean sameDay=isSameDay(day,today);
    String dayLabel=getDateTimeInterpreter().interpretDate(day);
    if (dayLabel == null)     throw new IllegalStateException(""String_Node_Str"");
    canvas.drawText(dayLabel,startPixel + mWidthPerDay / 2,mHeaderTextHeight + mHeaderRowPadding,sameDay ? mTodayHeaderTextPaint : mHeaderTextPaint);
    startPixel+=mWidthPerDay + mColumnGap;
  }
}","private void drawHeaderRowAndEvents(Canvas canvas){
  mHeaderColumnWidth=mTimeTextWidth + mHeaderColumnPadding * 2;
  mWidthPerDay=getWidth() - mHeaderColumnWidth - mColumnGap * (mNumberOfVisibleDays - 1);
  mWidthPerDay=mWidthPerDay / mNumberOfVisibleDays;
  Calendar today=today();
  if (mAreDimensionsInvalid) {
    mEffectiveMinHourHeight=Math.max(mMinHourHeight,(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / 24));
    mAreDimensionsInvalid=false;
    if (mScrollToDay != null)     goToDate(mScrollToDay);
    mAreDimensionsInvalid=false;
    if (mScrollToHour >= 0)     goToHour(mScrollToHour);
    mScrollToDay=null;
    mScrollToHour=-1;
    mAreDimensionsInvalid=false;
  }
  if (mIsFirstDraw) {
    mIsFirstDraw=false;
    if (mNumberOfVisibleDays >= 7 && today.get(Calendar.DAY_OF_WEEK) != mFirstDayOfWeek) {
      int difference=7 + (today.get(Calendar.DAY_OF_WEEK) - mFirstDayOfWeek);
      mCurrentOrigin.x+=(mWidthPerDay + mColumnGap) * difference;
    }
  }
  if (mCurrentScrollDirection == Direction.VERTICAL)   mCurrentOrigin.y-=mDistanceY;
  if (mNewHourHeight > 0) {
    if (mNewHourHeight < mEffectiveMinHourHeight)     mNewHourHeight=mEffectiveMinHourHeight;
 else     if (mNewHourHeight > mMaxHourHeight)     mNewHourHeight=mMaxHourHeight;
    mCurrentOrigin.y=(mCurrentOrigin.y / mHourHeight) * mNewHourHeight;
    mHourHeight=mNewHourHeight;
    mNewHourHeight=-1;
  }
  if (mCurrentOrigin.y < getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom)   mCurrentOrigin.y=getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom;
  if (mCurrentOrigin.y > 0)   mCurrentOrigin.y=0;
  if (mCurrentScrollDirection == Direction.HORIZONTAL)   mCurrentOrigin.x-=mDistanceX;
  int leftDaysWithGaps=(int)-(Math.ceil(mCurrentOrigin.x / (mWidthPerDay + mColumnGap)));
  float startFromPixel=mCurrentOrigin.x + (mWidthPerDay + mColumnGap) * leftDaysWithGaps + mHeaderColumnWidth;
  float startPixel=startFromPixel;
  Calendar day=(Calendar)today.clone();
  day.add(Calendar.HOUR,6);
  int lineCount=(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / mHourHeight) + 1;
  lineCount=(lineCount) * (mNumberOfVisibleDays + 1);
  float[] hourLines=new float[lineCount * 4];
  if (mEventRects != null) {
    for (    EventRect eventRect : mEventRects) {
      eventRect.rectF=null;
    }
  }
  Calendar oldFirstVisibleDay=mFirstVisibleDay;
  mFirstVisibleDay=(Calendar)today.clone();
  mFirstVisibleDay.add(Calendar.DATE,-(Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap))));
  if (!mFirstVisibleDay.equals(oldFirstVisibleDay) && mScrollListener != null) {
    mScrollListener.onFirstVisibleDayChanged(mFirstVisibleDay,oldFirstVisibleDay);
  }
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    mLastVisibleDay=(Calendar)day.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    mLastVisibleDay.add(Calendar.DATE,dayNumber - 2);
    boolean sameDay=isSameDay(day,today);
    if (mEventRects == null || mRefreshEvents || (dayNumber == leftDaysWithGaps + 1 && mFetchedPeriod != (int)mWeekViewLoader.toWeekViewPeriodIndex(day) && Math.abs(mFetchedPeriod - mWeekViewLoader.toWeekViewPeriodIndex(day)) > 0.5)) {
      getMoreEvents(day);
      mRefreshEvents=false;
    }
    float start=(startPixel < mHeaderColumnWidth ? mHeaderColumnWidth : startPixel);
    if (mWidthPerDay + startPixel - start > 0) {
      if (mUseNewColoring) {
        boolean isWeekend=(day.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY);
        Paint pastPaint=isWeekend ? mPastWeekendBackgroundPaint : mPastBackgroundPaint;
        Paint futurePaint=isWeekend ? mFutureWeekendBackgroundPaint : mFutureBackgroundPaint;
        float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
        if (sameDay) {
          Calendar now=Calendar.getInstance();
          float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,startY + beforeNow,pastPaint);
          canvas.drawRect(start,startY + beforeNow,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
 else         if (day.before(today)) {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),pastPaint);
        }
 else {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
      }
 else {
        canvas.drawRect(start,mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom,startPixel + mWidthPerDay,getHeight(),sameDay ? mTodayBackgroundPaint : mDayBackgroundPaint);
      }
    }
    int i=0;
    for (int hourNumber=0; hourNumber < 24; hourNumber++) {
      float top=mHeaderTextHeight + mHeaderRowPadding * 2 + mCurrentOrigin.y + mHourHeight * hourNumber + mTimeTextHeight / 2 + mHeaderMarginBottom;
      if (top > mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom - mHourSeparatorHeight && top < getHeight() && startPixel + mWidthPerDay - start > 0) {
        hourLines[i * 4]=start;
        hourLines[i * 4 + 1]=top;
        hourLines[i * 4 + 2]=startPixel + mWidthPerDay;
        hourLines[i * 4 + 3]=top;
        i++;
      }
    }
    canvas.drawLines(hourLines,mHourSeparatorPaint);
    drawEvents(day,startPixel,canvas);
    if (mUseNewColoring && sameDay) {
      float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
      Calendar now=Calendar.getInstance();
      float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
      canvas.drawLine(start,startY + beforeNow,startPixel + mWidthPerDay,startY + beforeNow,mNowLinePaint);
    }
    startPixel+=mWidthPerDay + mColumnGap;
  }
  canvas.drawRect(0,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,mHeaderBackgroundPaint);
  startPixel=startFromPixel;
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    boolean sameDay=isSameDay(day,today);
    String dayLabel=getDateTimeInterpreter().interpretDate(day);
    if (dayLabel == null)     throw new IllegalStateException(""String_Node_Str"");
    canvas.drawText(dayLabel,startPixel + mWidthPerDay / 2,mHeaderTextHeight + mHeaderRowPadding,sameDay ? mTodayHeaderTextPaint : mHeaderTextPaint);
    startPixel+=mWidthPerDay + mColumnGap;
  }
}"
27259,"private void drawHeaderRowAndEvents(Canvas canvas){
  mHeaderColumnWidth=mTimeTextWidth + mHeaderColumnPadding * 2;
  mWidthPerDay=getWidth() - mHeaderColumnWidth - mColumnGap * (mNumberOfVisibleDays - 1);
  mWidthPerDay=mWidthPerDay / mNumberOfVisibleDays;
  Calendar today=today();
  if (mAreDimensionsInvalid) {
    mEffectiveMinHourHeight=Math.max(mMinHourHeight,(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / 24));
    mAreDimensionsInvalid=false;
    if (mScrollToDay != null)     goToDate(mScrollToDay);
    mAreDimensionsInvalid=false;
    if (mScrollToHour >= 0)     goToHour(mScrollToHour);
    mScrollToDay=null;
    mScrollToHour=-1;
    mAreDimensionsInvalid=false;
  }
  if (mIsFirstDraw) {
    mIsFirstDraw=false;
    if (mNumberOfVisibleDays >= 7 && today.get(Calendar.DAY_OF_WEEK) != mFirstDayOfWeek) {
      int difference=7 + (today.get(Calendar.DAY_OF_WEEK) - mFirstDayOfWeek);
      mCurrentOrigin.x+=(mWidthPerDay + mColumnGap) * difference;
    }
  }
  if (mCurrentScrollDirection == Direction.VERTICAL)   mCurrentOrigin.y-=mDistanceY;
  if (mNewHourHeight > 0) {
    if (mNewHourHeight < mEffectiveMinHourHeight)     mNewHourHeight=mEffectiveMinHourHeight;
 else     if (mNewHourHeight > mMaxHourHeight)     mNewHourHeight=mMaxHourHeight;
    mCurrentOrigin.y=(mCurrentOrigin.y / mHourHeight) * mNewHourHeight;
    mHourHeight=mNewHourHeight;
    mNewHourHeight=-1;
  }
  if (mCurrentOrigin.y < getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom)   mCurrentOrigin.y=getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom;
  if (mCurrentOrigin.y > 0)   mCurrentOrigin.y=0;
  if (mCurrentScrollDirection == Direction.HORIZONTAL)   mCurrentOrigin.x-=mDistanceX;
  int leftDaysWithGaps=(int)-(Math.ceil(mCurrentOrigin.x / (mWidthPerDay + mColumnGap)));
  float startFromPixel=mCurrentOrigin.x + (mWidthPerDay + mColumnGap) * leftDaysWithGaps + mHeaderColumnWidth;
  float startPixel=startFromPixel;
  Calendar day=(Calendar)today.clone();
  day.add(Calendar.HOUR,6);
  int lineCount=(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / mHourHeight) + 1;
  lineCount=(lineCount) * (mNumberOfVisibleDays + 1);
  float[] hourLines=new float[lineCount * 4];
  if (mEventRects != null) {
    for (    EventRect eventRect : mEventRects) {
      eventRect.rectF=null;
    }
  }
  Calendar oldFirstVisibleDay=mFirstVisibleDay;
  mFirstVisibleDay=(Calendar)today.clone();
  mFirstVisibleDay.add(Calendar.DATE,-(Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap))));
  if (!mFirstVisibleDay.equals(oldFirstVisibleDay) && mScrolledListener != null) {
    mScrolledListener.onFirstVisibleDayChanged(mFirstVisibleDay,oldFirstVisibleDay);
  }
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    mLastVisibleDay=(Calendar)day.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    mLastVisibleDay.add(Calendar.DATE,dayNumber - 2);
    boolean sameDay=isSameDay(day,today);
    if (mEventRects == null || mRefreshEvents || (dayNumber == leftDaysWithGaps + 1 && mFetchedPeriod != (int)mWeekViewLoader.toWeekViewPeriodIndex(day) && Math.abs(mFetchedPeriod - mWeekViewLoader.toWeekViewPeriodIndex(day)) > 0.5)) {
      getMoreEvents(day);
      mRefreshEvents=false;
    }
    float start=(startPixel < mHeaderColumnWidth ? mHeaderColumnWidth : startPixel);
    if (mWidthPerDay + startPixel - start > 0) {
      if (mUseNewColoring) {
        boolean isWeekend=(day.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY);
        Paint pastPaint=isWeekend ? mPastWeekendBackgroundPaint : mPastBackgroundPaint;
        Paint futurePaint=isWeekend ? mFutureWeekendBackgroundPaint : mFutureBackgroundPaint;
        float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
        if (sameDay) {
          Calendar now=Calendar.getInstance();
          float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,startY + beforeNow,pastPaint);
          canvas.drawRect(start,startY + beforeNow,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
 else         if (day.before(today)) {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),pastPaint);
        }
 else {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
      }
 else {
        canvas.drawRect(start,mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom,startPixel + mWidthPerDay,getHeight(),sameDay ? mTodayBackgroundPaint : mDayBackgroundPaint);
      }
    }
    int i=0;
    for (int hourNumber=0; hourNumber < 24; hourNumber++) {
      float top=mHeaderTextHeight + mHeaderRowPadding * 2 + mCurrentOrigin.y + mHourHeight * hourNumber + mTimeTextHeight / 2 + mHeaderMarginBottom;
      if (top > mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom - mHourSeparatorHeight && top < getHeight() && startPixel + mWidthPerDay - start > 0) {
        hourLines[i * 4]=start;
        hourLines[i * 4 + 1]=top;
        hourLines[i * 4 + 2]=startPixel + mWidthPerDay;
        hourLines[i * 4 + 3]=top;
        i++;
      }
    }
    canvas.drawLines(hourLines,mHourSeparatorPaint);
    drawEvents(day,startPixel,canvas);
    if (mUseNewColoring && sameDay) {
      float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
      Calendar now=Calendar.getInstance();
      float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
      canvas.drawLine(start,startY + beforeNow,startPixel + mWidthPerDay,startY + beforeNow,mNowLinePaint);
    }
    startPixel+=mWidthPerDay + mColumnGap;
  }
  canvas.drawRect(0,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,mHeaderBackgroundPaint);
  startPixel=startFromPixel;
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    boolean sameDay=isSameDay(day,today);
    String dayLabel=getDateTimeInterpreter().interpretDate(day);
    if (dayLabel == null)     throw new IllegalStateException(""String_Node_Str"");
    canvas.drawText(dayLabel,startPixel + mWidthPerDay / 2,mHeaderTextHeight + mHeaderRowPadding,sameDay ? mTodayHeaderTextPaint : mHeaderTextPaint);
    startPixel+=mWidthPerDay + mColumnGap;
  }
}","private void drawHeaderRowAndEvents(Canvas canvas){
  mHeaderColumnWidth=mTimeTextWidth + mHeaderColumnPadding * 2;
  mWidthPerDay=getWidth() - mHeaderColumnWidth - mColumnGap * (mNumberOfVisibleDays - 1);
  mWidthPerDay=mWidthPerDay / mNumberOfVisibleDays;
  Calendar today=today();
  if (mAreDimensionsInvalid) {
    mEffectiveMinHourHeight=Math.max(mMinHourHeight,(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / 24));
    mAreDimensionsInvalid=false;
    if (mScrollToDay != null)     goToDate(mScrollToDay);
    mAreDimensionsInvalid=false;
    if (mScrollToHour >= 0)     goToHour(mScrollToHour);
    mScrollToDay=null;
    mScrollToHour=-1;
    mAreDimensionsInvalid=false;
  }
  if (mIsFirstDraw) {
    mIsFirstDraw=false;
    if (mNumberOfVisibleDays >= 7 && today.get(Calendar.DAY_OF_WEEK) != mFirstDayOfWeek) {
      int difference=7 + (today.get(Calendar.DAY_OF_WEEK) - mFirstDayOfWeek);
      mCurrentOrigin.x+=(mWidthPerDay + mColumnGap) * difference;
    }
  }
  if (mCurrentScrollDirection == Direction.VERTICAL)   mCurrentOrigin.y-=mDistanceY;
  if (mNewHourHeight > 0) {
    if (mNewHourHeight < mEffectiveMinHourHeight)     mNewHourHeight=mEffectiveMinHourHeight;
 else     if (mNewHourHeight > mMaxHourHeight)     mNewHourHeight=mMaxHourHeight;
    mCurrentOrigin.y=(mCurrentOrigin.y / mHourHeight) * mNewHourHeight;
    mHourHeight=mNewHourHeight;
    mNewHourHeight=-1;
  }
  if (mCurrentOrigin.y < getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom)   mCurrentOrigin.y=getHeight() - mHourHeight * 24 - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom;
  if (mCurrentOrigin.y > 0)   mCurrentOrigin.y=0;
  if (mCurrentScrollDirection == Direction.HORIZONTAL)   mCurrentOrigin.x-=mDistanceX;
  int leftDaysWithGaps=(int)-(Math.ceil(mCurrentOrigin.x / (mWidthPerDay + mColumnGap)));
  float startFromPixel=mCurrentOrigin.x + (mWidthPerDay + mColumnGap) * leftDaysWithGaps + mHeaderColumnWidth;
  float startPixel=startFromPixel;
  Calendar day=(Calendar)today.clone();
  day.add(Calendar.HOUR,6);
  int lineCount=(int)((getHeight() - mHeaderTextHeight - mHeaderRowPadding * 2 - mHeaderMarginBottom) / mHourHeight) + 1;
  lineCount=(lineCount) * (mNumberOfVisibleDays + 1);
  float[] hourLines=new float[lineCount * 4];
  if (mEventRects != null) {
    for (    EventRect eventRect : mEventRects) {
      eventRect.rectF=null;
    }
  }
  Calendar oldFirstVisibleDay=mFirstVisibleDay;
  mFirstVisibleDay=(Calendar)today.clone();
  mFirstVisibleDay.add(Calendar.DATE,-(Math.round(mCurrentOrigin.x / (mWidthPerDay + mColumnGap))));
  if (!mFirstVisibleDay.equals(oldFirstVisibleDay) && mScrollListener != null) {
    mScrollListener.onFirstVisibleDayChanged(mFirstVisibleDay,oldFirstVisibleDay);
  }
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    mLastVisibleDay=(Calendar)day.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    mLastVisibleDay.add(Calendar.DATE,dayNumber - 2);
    boolean sameDay=isSameDay(day,today);
    if (mEventRects == null || mRefreshEvents || (dayNumber == leftDaysWithGaps + 1 && mFetchedPeriod != (int)mWeekViewLoader.toWeekViewPeriodIndex(day) && Math.abs(mFetchedPeriod - mWeekViewLoader.toWeekViewPeriodIndex(day)) > 0.5)) {
      getMoreEvents(day);
      mRefreshEvents=false;
    }
    float start=(startPixel < mHeaderColumnWidth ? mHeaderColumnWidth : startPixel);
    if (mWidthPerDay + startPixel - start > 0) {
      if (mUseNewColoring) {
        boolean isWeekend=(day.get(Calendar.DAY_OF_WEEK) == Calendar.SATURDAY || day.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY);
        Paint pastPaint=isWeekend ? mPastWeekendBackgroundPaint : mPastBackgroundPaint;
        Paint futurePaint=isWeekend ? mFutureWeekendBackgroundPaint : mFutureBackgroundPaint;
        float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
        if (sameDay) {
          Calendar now=Calendar.getInstance();
          float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,startY + beforeNow,pastPaint);
          canvas.drawRect(start,startY + beforeNow,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
 else         if (day.before(today)) {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),pastPaint);
        }
 else {
          canvas.drawRect(start,startY,startPixel + mWidthPerDay,getHeight(),futurePaint);
        }
      }
 else {
        canvas.drawRect(start,mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom,startPixel + mWidthPerDay,getHeight(),sameDay ? mTodayBackgroundPaint : mDayBackgroundPaint);
      }
    }
    int i=0;
    for (int hourNumber=0; hourNumber < 24; hourNumber++) {
      float top=mHeaderTextHeight + mHeaderRowPadding * 2 + mCurrentOrigin.y + mHourHeight * hourNumber + mTimeTextHeight / 2 + mHeaderMarginBottom;
      if (top > mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom - mHourSeparatorHeight && top < getHeight() && startPixel + mWidthPerDay - start > 0) {
        hourLines[i * 4]=start;
        hourLines[i * 4 + 1]=top;
        hourLines[i * 4 + 2]=startPixel + mWidthPerDay;
        hourLines[i * 4 + 3]=top;
        i++;
      }
    }
    canvas.drawLines(hourLines,mHourSeparatorPaint);
    drawEvents(day,startPixel,canvas);
    if (mUseNewColoring && sameDay) {
      float startY=mHeaderTextHeight + mHeaderRowPadding * 2 + mTimeTextHeight / 2 + mHeaderMarginBottom + mCurrentOrigin.y;
      Calendar now=Calendar.getInstance();
      float beforeNow=(now.get(Calendar.HOUR_OF_DAY) + now.get(Calendar.MINUTE) / 60.0f) * mHourHeight;
      canvas.drawLine(start,startY + beforeNow,startPixel + mWidthPerDay,startY + beforeNow,mNowLinePaint);
    }
    startPixel+=mWidthPerDay + mColumnGap;
  }
  canvas.drawRect(0,0,getWidth(),mHeaderTextHeight + mHeaderRowPadding * 2,mHeaderBackgroundPaint);
  startPixel=startFromPixel;
  for (int dayNumber=leftDaysWithGaps + 1; dayNumber <= leftDaysWithGaps + mNumberOfVisibleDays + 1; dayNumber++) {
    day=(Calendar)today.clone();
    day.add(Calendar.DATE,dayNumber - 1);
    boolean sameDay=isSameDay(day,today);
    String dayLabel=getDateTimeInterpreter().interpretDate(day);
    if (dayLabel == null)     throw new IllegalStateException(""String_Node_Str"");
    canvas.drawText(dayLabel,startPixel + mWidthPerDay / 2,mHeaderTextHeight + mHeaderRowPadding,sameDay ? mTodayHeaderTextPaint : mHeaderTextPaint);
    startPixel+=mWidthPerDay + mColumnGap;
  }
}"
27260,"/** 
 * Expands all the events to maximum possible width. The events will try to occupy maximum space available horizontally.
 * @param collisionGroup The group of events which overlap with each other.
 */
private void expandEventsToMaxWidth(List<EventRect> collisionGroup){
  List<List<EventRect>> columns=new ArrayList<List<EventRect>>();
  columns.add(new ArrayList<EventRect>());
  for (  EventRect eventRect : collisionGroup) {
    boolean isPlaced=false;
    for (    List<EventRect> column : columns) {
      if (column.size() == 0) {
        column.add(eventRect);
        isPlaced=true;
      }
 else       if (!isEventsCollide(eventRect.event,column.get(column.size() - 1).event)) {
        column.add(eventRect);
        isPlaced=true;
        break;
      }
    }
    if (!isPlaced) {
      List<EventRect> newColumn=new ArrayList<EventRect>();
      newColumn.add(eventRect);
      columns.add(newColumn);
    }
  }
  int maxRowCount=columns.get(0).size();
  for (int i=0; i < maxRowCount; i++) {
    float j=0;
    for (    List<EventRect> column : columns) {
      if (column.size() >= i + 1) {
        EventRect eventRect=column.get(i);
        eventRect.width=1f / columns.size();
        eventRect.left=j / columns.size();
        eventRect.top=eventRect.event.getStartTime().get(Calendar.HOUR_OF_DAY) * 60 + eventRect.event.getStartTime().get(Calendar.MINUTE);
        eventRect.bottom=eventRect.event.getEndTime().get(Calendar.HOUR_OF_DAY) * 60 + eventRect.event.getEndTime().get(Calendar.MINUTE);
        mEventRects.add(eventRect);
      }
      j++;
    }
  }
}","/** 
 * Expands all the events to maximum possible width. The events will try to occupy maximum space available horizontally.
 * @param collisionGroup The group of events which overlap with each other.
 */
private void expandEventsToMaxWidth(List<EventRect> collisionGroup){
  List<List<EventRect>> columns=new ArrayList<List<EventRect>>();
  columns.add(new ArrayList<EventRect>());
  for (  EventRect eventRect : collisionGroup) {
    boolean isPlaced=false;
    for (    List<EventRect> column : columns) {
      if (column.size() == 0) {
        column.add(eventRect);
        isPlaced=true;
      }
 else       if (!isEventsCollide(eventRect.event,column.get(column.size() - 1).event)) {
        column.add(eventRect);
        isPlaced=true;
        break;
      }
    }
    if (!isPlaced) {
      List<EventRect> newColumn=new ArrayList<EventRect>();
      newColumn.add(eventRect);
      columns.add(newColumn);
    }
  }
  int maxRowCount=0;
  for (  List<EventRect> column : columns) {
    maxRowCount=Math.max(maxRowCount,column.size());
  }
  for (int i=0; i < maxRowCount; i++) {
    float j=0;
    for (    List<EventRect> column : columns) {
      if (column.size() >= i + 1) {
        EventRect eventRect=column.get(i);
        eventRect.width=1f / columns.size();
        eventRect.left=j / columns.size();
        eventRect.top=eventRect.event.getStartTime().get(Calendar.HOUR_OF_DAY) * 60 + eventRect.event.getStartTime().get(Calendar.MINUTE);
        eventRect.bottom=eventRect.event.getEndTime().get(Calendar.HOUR_OF_DAY) * 60 + eventRect.event.getEndTime().get(Calendar.MINUTE);
        mEventRects.add(eventRect);
      }
      j++;
    }
  }
}"
27261,"/** 
 * Show a specific day on the week view.
 * @param date The date to show.
 */
public void goToDate(Calendar date){
  mScroller.forceFinished(true);
  date.set(Calendar.HOUR_OF_DAY,0);
  date.set(Calendar.MINUTE,0);
  date.set(Calendar.SECOND,0);
  date.set(Calendar.MILLISECOND,0);
  if (mAreDimensionsInvalid) {
    mScrollToDay=date;
    return;
  }
  mRefreshEvents=true;
  Calendar today=Calendar.getInstance();
  today.set(Calendar.HOUR_OF_DAY,0);
  today.set(Calendar.MINUTE,0);
  today.set(Calendar.SECOND,0);
  today.set(Calendar.MILLISECOND,0);
  int dateDifference=(int)((date.getTimeInMillis() - today.getTimeInMillis()) / (1000 * 60 * 60* 24));
  mCurrentOrigin.x=-dateDifference * (mWidthPerDay + mColumnGap);
  invalidate();
}","/** 
 * Show a specific day on the week view.
 * @param date The date to show.
 */
public void goToDate(Calendar date){
  mScroller.forceFinished(true);
  date.set(Calendar.HOUR_OF_DAY,0);
  date.set(Calendar.MINUTE,0);
  date.set(Calendar.SECOND,0);
  date.set(Calendar.MILLISECOND,0);
  if (mAreDimensionsInvalid) {
    mScrollToDay=date;
    return;
  }
  mRefreshEvents=true;
  Calendar today=Calendar.getInstance();
  today.set(Calendar.HOUR_OF_DAY,0);
  today.set(Calendar.MINUTE,0);
  today.set(Calendar.SECOND,0);
  today.set(Calendar.MILLISECOND,0);
  long dateInMillis=date.getTimeInMillis() + date.getTimeZone().getOffset(date.getTimeInMillis());
  long todayInMillis=today.getTimeInMillis() + today.getTimeZone().getOffset(today.getTimeInMillis());
  int dateDifference=(int)((dateInMillis - todayInMillis) / (1000 * 60 * 60* 24));
  mCurrentOrigin.x=-dateDifference * (mWidthPerDay + mColumnGap);
  invalidate();
}"
27262,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pull_to_zoom_list_view);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  listView=(PullToZoomListViewEx)findViewById(R.id.listview);
  String[] adapterData=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  listView.setAdapter(new ArrayAdapter<String>(PullToZoomListActivity.this,android.R.layout.simple_list_item_1,adapterData));
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Log.e(""String_Node_Str"",""String_Node_Str"" + position);
    }
  }
);
  DisplayMetrics localDisplayMetrics=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(localDisplayMetrics);
  int mScreenHeight=localDisplayMetrics.heightPixels;
  int mScreenWidth=localDisplayMetrics.widthPixels;
  AbsListView.LayoutParams localObject=new AbsListView.LayoutParams(mScreenWidth,(int)(9.0F * (mScreenWidth / 16.0F)));
  listView.setHeaderLayoutParams(localObject);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pull_to_zoom_list_view);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  listView=(PullToZoomListViewEx)findViewById(R.id.listview);
  String[] adapterData=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  listView.setAdapter(new ArrayAdapter<String>(PullToZoomListActivity.this,android.R.layout.simple_list_item_1,adapterData));
  listView.getPullRootView().setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Log.e(""String_Node_Str"",""String_Node_Str"" + position);
    }
  }
);
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Log.e(""String_Node_Str"",""String_Node_Str"" + position);
    }
  }
);
  DisplayMetrics localDisplayMetrics=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(localDisplayMetrics);
  int mScreenHeight=localDisplayMetrics.heightPixels;
  int mScreenWidth=localDisplayMetrics.widthPixels;
  AbsListView.LayoutParams localObject=new AbsListView.LayoutParams(mScreenWidth,(int)(9.0F * (mScreenWidth / 16.0F)));
  listView.setHeaderLayoutParams(localObject);
}"
27263,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pull_to_zoom_scroll_view);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  scrollView=(PullToZoomScrollViewEx)findViewById(R.id.scroll_view);
  scrollView.getRootView().findViewById(R.id.tv_test1).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  DisplayMetrics localDisplayMetrics=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(localDisplayMetrics);
  int mScreenHeight=localDisplayMetrics.heightPixels;
  int mScreenWidth=localDisplayMetrics.widthPixels;
  LinearLayout.LayoutParams localObject=new LinearLayout.LayoutParams(mScreenWidth,(int)(9.0F * (mScreenWidth / 16.0F)));
  scrollView.setHeaderLayoutParams(localObject);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pull_to_zoom_scroll_view);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  scrollView=(PullToZoomScrollViewEx)findViewById(R.id.scroll_view);
  scrollView.getPullRootView().findViewById(R.id.tv_test1).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  scrollView.getPullRootView().findViewById(R.id.tv_test2).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  scrollView.getPullRootView().findViewById(R.id.tv_test3).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  DisplayMetrics localDisplayMetrics=new DisplayMetrics();
  getWindowManager().getDefaultDisplay().getMetrics(localDisplayMetrics);
  int mScreenHeight=localDisplayMetrics.heightPixels;
  int mScreenWidth=localDisplayMetrics.widthPixels;
  LinearLayout.LayoutParams localObject=new LinearLayout.LayoutParams(mScreenWidth,(int)(9.0F * (mScreenWidth / 16.0F)));
  scrollView.setHeaderLayoutParams(localObject);
}"
27264,"/** 
 * 创建listView 如果要兼容API9,需要修改此处
 * @param context 上下文
 * @param attrs   AttributeSet
 * @return ListView
 */
@Override protected ListView createRootView(Context context,AttributeSet attrs){
  return new ListView(context,attrs);
}","/** 
 * 创建listView 如果要兼容API9,需要修改此处
 * @param context 上下文
 * @param attrs   AttributeSet
 * @return ListView
 */
@Override protected ListView createRootView(Context context,AttributeSet attrs){
  ListView lv=new ListView(context,attrs);
  lv.setId(android.R.id.list);
  return lv;
}"
27265,"@Override protected ScrollView createRootView(Context context,AttributeSet attrs){
  return new InternalScrollView(context,attrs);
}","@Override protected ScrollView createRootView(Context context,AttributeSet attrs){
  ScrollView scrollView=new InternalScrollView(context,attrs);
  scrollView.setId(R.id.scrollview);
  return scrollView;
}"
27266,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pull_to_zoom_list_view);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  listView=(PullToZoomListView)findViewById(R.id.listview);
  String[] adapterData=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  listView.setAdapter(new ArrayAdapter<String>(PullToZoomListActivity.this,android.R.layout.simple_list_item_1,adapterData));
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_pull_to_zoom_list_view);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  listView=(PullToZoomListViewEx)findViewById(R.id.listview);
  String[] adapterData=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  listView.setAdapter(new ArrayAdapter<String>(PullToZoomListActivity.this,android.R.layout.simple_list_item_1,adapterData));
  listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      Log.e(""String_Node_Str"",""String_Node_Str"" + position);
    }
  }
);
}"
27267,"@Override public boolean onOptionsItemSelected(MenuItem item){
  int id=item.getItemId();
  if (id == android.R.id.home) {
    finish();
    return true;
  }
 else   if (id == R.id.action_normal) {
    listView.setParallax(false);
    return true;
  }
 else   if (id == R.id.action_parallax) {
    listView.setParallax(true);
    return true;
  }
 else   if (id == R.id.action_show_head) {
    listView.showHeadView();
    return true;
  }
 else   if (id == R.id.action_hide_head) {
    listView.hideHeadView();
    return true;
  }
 else   if (id == R.id.action_disable_zoom) {
    listView.setEnableZoom(false);
    return true;
  }
 else   if (id == R.id.action_enable_zoom) {
    listView.setEnableZoom(true);
    return true;
  }
  return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  int id=item.getItemId();
  if (id == android.R.id.home) {
    finish();
    return true;
  }
 else   if (id == R.id.action_normal) {
    listView.setParallax(false);
    return true;
  }
 else   if (id == R.id.action_parallax) {
    listView.setParallax(true);
    return true;
  }
 else   if (id == R.id.action_show_head) {
    listView.setHideHeader(false);
    return true;
  }
 else   if (id == R.id.action_hide_head) {
    listView.setHideHeader(true);
    return true;
  }
 else   if (id == R.id.action_disable_zoom) {
    listView.setZoomEnabled(false);
    return true;
  }
 else   if (id == R.id.action_enable_zoom) {
    listView.setZoomEnabled(true);
    return true;
  }
  return super.onOptionsItemSelected(item);
}"
27268,"private Builder(){
  mAlertDialog=new AlertDialog.Builder(mContext).create();
  mAlertDialog.show();
  mAlertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  mAlertDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
  mAlertDialogWindow=mAlertDialog.getWindow();
  View contv=LayoutInflater.from(mContext).inflate(R.layout.layout_materialdialog,null);
  contv.setFocusable(true);
  contv.setFocusableInTouchMode(true);
  mAlertDialogWindow.setBackgroundDrawableResource(R.drawable.material_dialog_window);
  mAlertDialogWindow.setContentView(contv);
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,PixelFormat.TRANSLUCENT);
  mTitleView=(TextView)mAlertDialogWindow.findViewById(R.id.title);
  mMessageView=(TextView)mAlertDialogWindow.findViewById(R.id.message);
  mButtonLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.buttonLayout);
  mPositiveButton=(Button)mButtonLayout.findViewById(R.id.btn_p);
  mNegativeButton=(Button)mButtonLayout.findViewById(R.id.btn_n);
  if (mView != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
    linearLayout.removeAllViews();
    linearLayout.addView(mView);
  }
  if (mTitleResId != 0) {
    setTitle(mTitleResId);
  }
  if (mTitle != null) {
    setTitle(mTitle);
  }
  if (mTitle == null && mTitleResId == 0) {
    mTitleView.setVisibility(View.GONE);
  }
  if (mMessageResId != 0) {
    setMessage(mMessageResId);
  }
  if (mMessage != null) {
    setMessage(mMessage);
  }
  if (pId != -1) {
    mPositiveButton.setVisibility(View.VISIBLE);
    mPositiveButton.setText(pId);
    mPositiveButton.setOnClickListener(pListener);
    if (isLollipop()) {
      mPositiveButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (nId != -1) {
    mNegativeButton.setVisibility(View.VISIBLE);
    mNegativeButton.setText(nId);
    mNegativeButton.setOnClickListener(nListener);
    if (isLollipop()) {
      mNegativeButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (!isNullOrEmpty(pText)) {
    mPositiveButton.setVisibility(View.VISIBLE);
    mPositiveButton.setText(pText);
    mPositiveButton.setOnClickListener(pListener);
    if (isLollipop()) {
      mPositiveButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (!isNullOrEmpty(nText)) {
    mNegativeButton.setVisibility(View.VISIBLE);
    mNegativeButton.setText(nText);
    mNegativeButton.setOnClickListener(nListener);
    if (isLollipop()) {
      mNegativeButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (isNullOrEmpty(pText) && pId == -1) {
    mPositiveButton.setVisibility(View.GONE);
  }
  if (isNullOrEmpty(nText) && nId == -1) {
    mNegativeButton.setVisibility(View.GONE);
  }
  if (mBackgroundResId != -1) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackgroundResource(mBackgroundResId);
  }
  if (mBackgroundDrawable != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackground(mBackgroundDrawable);
  }
  if (mMessageContentView != null) {
    this.setContentView(mMessageContentView);
  }
  mAlertDialog.setCanceledOnTouchOutside(mCancel);
  if (mOnDismissListener != null) {
    mAlertDialog.setOnDismissListener(mOnDismissListener);
  }
}","private Builder(){
  mAlertDialog=new AlertDialog.Builder(mContext).create();
  mAlertDialog.show();
  mAlertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  mAlertDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_MASK_STATE);
  mAlertDialogWindow=mAlertDialog.getWindow();
  View contv=LayoutInflater.from(mContext).inflate(R.layout.layout_materialdialog,null);
  contv.setFocusable(true);
  contv.setFocusableInTouchMode(true);
  mAlertDialogWindow.setBackgroundDrawableResource(R.drawable.material_dialog_window);
  mAlertDialogWindow.setContentView(contv);
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,PixelFormat.TRANSLUCENT);
  mTitleView=(TextView)mAlertDialogWindow.findViewById(R.id.title);
  mMessageView=(TextView)mAlertDialogWindow.findViewById(R.id.message);
  mButtonLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.buttonLayout);
  mPositiveButton=(Button)mButtonLayout.findViewById(R.id.btn_p);
  mNegativeButton=(Button)mButtonLayout.findViewById(R.id.btn_n);
  if (mView != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
    linearLayout.removeAllViews();
    linearLayout.addView(mView);
  }
  if (mTitleResId != 0) {
    setTitle(mTitleResId);
  }
  if (mTitle != null) {
    setTitle(mTitle);
  }
  if (mTitle == null && mTitleResId == 0) {
    mTitleView.setVisibility(View.GONE);
  }
  if (mMessageResId != 0) {
    setMessage(mMessageResId);
  }
  if (mMessage != null) {
    setMessage(mMessage);
  }
  if (pId != -1) {
    mPositiveButton.setVisibility(View.VISIBLE);
    mPositiveButton.setText(pId);
    mPositiveButton.setOnClickListener(pListener);
    if (isLollipop()) {
      mPositiveButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (nId != -1) {
    mNegativeButton.setVisibility(View.VISIBLE);
    mNegativeButton.setText(nId);
    mNegativeButton.setOnClickListener(nListener);
    if (isLollipop()) {
      mNegativeButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (!isNullOrEmpty(pText)) {
    mPositiveButton.setVisibility(View.VISIBLE);
    mPositiveButton.setText(pText);
    mPositiveButton.setOnClickListener(pListener);
    if (isLollipop()) {
      mPositiveButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (!isNullOrEmpty(nText)) {
    mNegativeButton.setVisibility(View.VISIBLE);
    mNegativeButton.setText(nText);
    mNegativeButton.setOnClickListener(nListener);
    if (isLollipop()) {
      mNegativeButton.setBackgroundResource(android.R.color.transparent);
    }
  }
  if (isNullOrEmpty(pText) && pId == -1) {
    mPositiveButton.setVisibility(View.GONE);
  }
  if (isNullOrEmpty(nText) && nId == -1) {
    mNegativeButton.setVisibility(View.GONE);
  }
  if (mBackgroundResId != -1) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackgroundResource(mBackgroundResId);
  }
  if (mBackgroundDrawable != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackground(mBackgroundDrawable);
  }
  if (mMessageContentView != null) {
    this.setContentView(mMessageContentView);
  }
  mAlertDialog.setCanceledOnTouchOutside(mCancel);
  if (mOnDismissListener != null) {
    mAlertDialog.setOnDismissListener(mOnDismissListener);
  }
}"
27269,"private Builder(){
  mAlertDialog=new AlertDialog.Builder(mContext).create();
  mAlertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  mAlertDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
  mAlertDialog.show();
  mAlertDialogWindow=mAlertDialog.getWindow();
  View contv=LayoutInflater.from(mContext).inflate(R.layout.layout_materialdialog,null);
  contv.setFocusable(true);
  contv.setFocusableInTouchMode(true);
  mAlertDialogWindow.setContentView(contv);
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,PixelFormat.TRANSLUCENT);
  mTitleView=(TextView)mAlertDialogWindow.findViewById(R.id.title);
  mMessageView=(TextView)mAlertDialogWindow.findViewById(R.id.message);
  mButtonLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.buttonLayout);
  if (mView != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
    linearLayout.removeAllViews();
    linearLayout.addView(mView);
  }
  if (mTitleResId != 0) {
    setTitle(mTitleResId);
  }
  if (mTitle != null) {
    setTitle(mTitle);
  }
  if (mTitle == null && mTitleResId == 0) {
    mTitleView.setVisibility(View.GONE);
  }
  if (mMessageResId != 0) {
    setMessage(mMessageResId);
  }
  if (mMessage != null) {
    setMessage(mMessage);
  }
  if (mPositiveButton != null) {
    mButtonLayout.addView(mPositiveButton);
  }
  if (mLayoutParams != null && mNegativeButton != null) {
    if (mButtonLayout.getChildCount() > 0) {
      mLayoutParams.setMargins(dip2px(12),0,0,dip2px(BUTTON_BOTTOM));
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton,1);
    }
 else {
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton);
    }
  }
  if (mBackgroundResId != 0) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackgroundResource(mBackgroundResId);
  }
  if (mBackgroundDrawable != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackground(mBackgroundDrawable);
  }
  if (mMessageContentView != null) {
    this.setContentView(mMessageContentView);
  }
  mAlertDialog.setCanceledOnTouchOutside(mCancel);
  if (mOnDismissListener != null) {
    mAlertDialog.setOnDismissListener(mOnDismissListener);
  }
}","private Builder(){
  mAlertDialog=new AlertDialog.Builder(mContext).create();
  mAlertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  mAlertDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
  mAlertDialog.show();
  mAlertDialogWindow=mAlertDialog.getWindow();
  View contv=LayoutInflater.from(mContext).inflate(R.layout.layout_materialdialog,null);
  contv.setFocusable(true);
  contv.setFocusableInTouchMode(true);
  mAlertDialogWindow.setBackgroundDrawableResource(R.drawable.material_dialog_window);
  mAlertDialogWindow.setContentView(contv);
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,PixelFormat.TRANSLUCENT);
  mTitleView=(TextView)mAlertDialogWindow.findViewById(R.id.title);
  mMessageView=(TextView)mAlertDialogWindow.findViewById(R.id.message);
  mButtonLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.buttonLayout);
  if (mView != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
    linearLayout.removeAllViews();
    linearLayout.addView(mView);
  }
  if (mTitleResId != 0) {
    setTitle(mTitleResId);
  }
  if (mTitle != null) {
    setTitle(mTitle);
  }
  if (mTitle == null && mTitleResId == 0) {
    mTitleView.setVisibility(View.GONE);
  }
  if (mMessageResId != 0) {
    setMessage(mMessageResId);
  }
  if (mMessage != null) {
    setMessage(mMessage);
  }
  if (mPositiveButton != null) {
    mButtonLayout.addView(mPositiveButton);
  }
  if (mLayoutParams != null && mNegativeButton != null) {
    if (mButtonLayout.getChildCount() > 0) {
      mLayoutParams.setMargins(dip2px(12),0,0,dip2px(BUTTON_BOTTOM));
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton,1);
    }
 else {
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton);
    }
  }
  if (mBackgroundResId != 0) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackgroundResource(mBackgroundResId);
  }
  if (mBackgroundDrawable != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackground(mBackgroundDrawable);
  }
  if (mMessageContentView != null) {
    this.setContentView(mMessageContentView);
  }
  mAlertDialog.setCanceledOnTouchOutside(mCancel);
  if (mOnDismissListener != null) {
    mAlertDialog.setOnDismissListener(mOnDismissListener);
  }
}"
27270,"private Builder(){
  mAlertDialog=new AlertDialog.Builder(mContext).create();
  mAlertDialog.show();
  mAlertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  mAlertDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
  mAlertDialogWindow=mAlertDialog.getWindow();
  View contv=LayoutInflater.from(mContext).inflate(R.layout.layout_materialdialog,null);
  contv.setFocusable(true);
  contv.setFocusableInTouchMode(true);
  mAlertDialogWindow.setContentView(contv);
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,PixelFormat.TRANSLUCENT);
  mTitleView=(TextView)mAlertDialogWindow.findViewById(R.id.title);
  mMessageView=(TextView)mAlertDialogWindow.findViewById(R.id.message);
  mButtonLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.buttonLayout);
  if (mView != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
    linearLayout.removeAllViews();
    linearLayout.addView(mView);
  }
  if (mTitleResId != 0) {
    setTitle(mTitleResId);
  }
  if (mTitle != null) {
    setTitle(mTitle);
  }
  if (mTitle == null && mTitleResId == 0) {
    mTitleView.setVisibility(View.GONE);
  }
  if (mMessageResId != 0) {
    setMessage(mMessageResId);
  }
  if (mMessage != null) {
    setMessage(mMessage);
  }
  if (mPositiveButton != null) {
    mButtonLayout.addView(mPositiveButton);
  }
  if (mLayoutParams != null && mNegativeButton != null) {
    if (mButtonLayout.getChildCount() > 0) {
      mLayoutParams.setMargins(dip2px(12),0,0,dip2px(BUTTON_BOTTOM));
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton,1);
    }
 else {
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton);
    }
  }
  if (mBackgroundResId != 0) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackgroundResource(mBackgroundResId);
  }
  if (mBackgroundDrawable != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackground(mBackgroundDrawable);
  }
  if (mMessageContentView != null) {
    this.setContentView(mMessageContentView);
  }
  mAlertDialog.setCanceledOnTouchOutside(mCancel);
  if (mOnDismissListener != null) {
    mAlertDialog.setOnDismissListener(mOnDismissListener);
  }
}","private Builder(){
  mAlertDialog=new AlertDialog.Builder(mContext).create();
  mAlertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  mAlertDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
  mAlertDialog.show();
  mAlertDialogWindow=mAlertDialog.getWindow();
  View contv=LayoutInflater.from(mContext).inflate(R.layout.layout_materialdialog,null);
  contv.setFocusable(true);
  contv.setFocusableInTouchMode(true);
  mAlertDialogWindow.setContentView(contv);
  WindowManager.LayoutParams params=new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.WRAP_CONTENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,PixelFormat.TRANSLUCENT);
  mTitleView=(TextView)mAlertDialogWindow.findViewById(R.id.title);
  mMessageView=(TextView)mAlertDialogWindow.findViewById(R.id.message);
  mButtonLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.buttonLayout);
  if (mView != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
    linearLayout.removeAllViews();
    linearLayout.addView(mView);
  }
  if (mTitleResId != 0) {
    setTitle(mTitleResId);
  }
  if (mTitle != null) {
    setTitle(mTitle);
  }
  if (mTitle == null && mTitleResId == 0) {
    mTitleView.setVisibility(View.GONE);
  }
  if (mMessageResId != 0) {
    setMessage(mMessageResId);
  }
  if (mMessage != null) {
    setMessage(mMessage);
  }
  if (mPositiveButton != null) {
    mButtonLayout.addView(mPositiveButton);
  }
  if (mLayoutParams != null && mNegativeButton != null) {
    if (mButtonLayout.getChildCount() > 0) {
      mLayoutParams.setMargins(dip2px(12),0,0,dip2px(BUTTON_BOTTOM));
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton,1);
    }
 else {
      mNegativeButton.setLayoutParams(mLayoutParams);
      mButtonLayout.addView(mNegativeButton);
    }
  }
  if (mBackgroundResId != 0) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackgroundResource(mBackgroundResId);
  }
  if (mBackgroundDrawable != null) {
    LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.material_background);
    linearLayout.setBackground(mBackgroundDrawable);
  }
  if (mMessageContentView != null) {
    this.setContentView(mMessageContentView);
  }
  mAlertDialog.setCanceledOnTouchOutside(mCancel);
  if (mOnDismissListener != null) {
    mAlertDialog.setOnDismissListener(mOnDismissListener);
  }
}"
27271,"public void setView(View view){
  LinearLayout l=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
  l.removeAllViews();
  l.addView(view);
}","public void setView(View view){
  LinearLayout l=(LinearLayout)mAlertDialogWindow.findViewById(R.id.contentView);
  l.removeAllViews();
  ViewGroup.LayoutParams layoutParams=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  view.setLayoutParams(layoutParams);
  l.addView(view);
}"
27272,"public void setContentView(View contentView){
  LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.message_content_view);
  if (linearLayout != null) {
    linearLayout.removeAllViews();
    linearLayout.addView(contentView);
  }
}","public void setContentView(View contentView){
  ViewGroup.LayoutParams layoutParams=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  contentView.setLayoutParams(layoutParams);
  LinearLayout linearLayout=(LinearLayout)mAlertDialogWindow.findViewById(R.id.message_content_view);
  if (linearLayout != null) {
    linearLayout.removeAllViews();
    linearLayout.addView(contentView);
  }
}"
27273,"public void setDefaultRippleAlpha(int alpha){
  this.rippleAlpha=alpha;
  paint.setAlpha(alpha);
}","public void setDefaultRippleAlpha(int alpha){
  this.rippleAlpha=alpha;
  paint.setAlpha(alpha);
  invalidate();
}"
27274,"public void setRippleColor(int rippleColor){
  this.rippleColor=rippleColor;
  paint.setColor(rippleColor);
}","public void setRippleColor(int rippleColor){
  this.rippleColor=rippleColor;
  paint.setColor(rippleColor);
  paint.setAlpha(rippleAlpha);
  invalidate();
}"
27275,"public void setRippleBackground(int color){
  this.rippleBackground=new ColorDrawable(color);
}","public void setRippleBackground(int color){
  rippleBackground=new ColorDrawable(color);
  rippleBackground.setBounds(bounds);
  invalidate();
}"
27276,"public MenuItem setVisible(boolean visible){
  mFlags=(mFlags & HIDDEN) | (visible ? 0 : HIDDEN);
  return this;
}","public MenuItem setVisible(boolean visible){
  mFlags=(mFlags & ~HIDDEN) | (visible ? 0 : HIDDEN);
  return this;
}"
27277,"private void dismiss(View view,float yvel){
  mDragHelper.smoothSlideViewTo(view,0,top + height);
  mDragHelper.cancel();
  ViewCompat.postInvalidateOnAnimation(ClosableSlidingLayout.this);
}","private void dismiss(View view,float yvel){
  mDragHelper.smoothSlideViewTo(view,0,top + height);
  ViewCompat.postInvalidateOnAnimation(ClosableSlidingLayout.this);
}"
27278,"@Override public void onViewPositionChanged(View changedView,int left,int top,int dx,int dy){
  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
    invalidate();
  }
  if (height - top < 1 && mListener != null) {
    mListener.onClosed();
  }
}","@Override public void onViewPositionChanged(View changedView,int left,int top,int dx,int dy){
  if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {
    invalidate();
  }
  if (height - top < 1 && mListener != null) {
    mDragHelper.cancel();
    mListener.onClosed();
    mDragHelper.smoothSlideViewTo(changedView,0,top);
  }
}"
27279,"@Override public void onViewReleased(View releasedChild,float xvel,float yvel){
  if (yvel > MINVEL) {
    dismiss(releasedChild,yvel);
  }
 else {
    if (releasedChild.getTop() >= top + height / 2) {
      dismiss(releasedChild,yvel);
    }
 else {
      mDragHelper.smoothSlideViewTo(releasedChild,0,top);
    }
  }
  ViewCompat.postInvalidateOnAnimation(ClosableSlidingLayout.this);
}","@Override public void onViewReleased(View releasedChild,float xvel,float yvel){
  if (yvel > MINVEL) {
    dismiss(releasedChild,yvel);
  }
 else {
    if (releasedChild.getTop() >= top + height / 2) {
      dismiss(releasedChild,yvel);
    }
 else {
      mDragHelper.smoothSlideViewTo(releasedChild,0,top);
      ViewCompat.postInvalidateOnAnimation(ClosableSlidingLayout.this);
    }
  }
}"
27280,"private void init(final Context context){
  setCanceledOnTouchOutside(cancelOnTouchOutside);
  final ClosableSlidingLayout mDialogView=(ClosableSlidingLayout)View.inflate(context,R.layout.bottom_sheet_dialog,null);
  setContentView(mDialogView);
  if (!cancelOnSwipeDown)   mDialogView.swipeable=cancelOnSwipeDown;
  mDialogView.setSlideListener(new ClosableSlidingLayout.SlideListener(){
    @Override public void onClosed(){
      BottomSheet.this.dismiss();
    }
    @Override public void onOpened(){
      showFullItems();
    }
  }
);
  this.setOnShowListener(new OnShowListener(){
    @Override public void onShow(    DialogInterface dialogInterface){
      actions=menuItem;
      list.setAdapter(adapter);
      list.startLayoutAnimation();
      if (builder.icon == null)       icon.setVisibility(View.GONE);
 else {
        icon.setVisibility(View.VISIBLE);
        icon.setImageDrawable(builder.icon);
      }
    }
  }
);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    mDialogView.setPadding(0,mStatusBarAvailable ? mStatusBarHeight : 0,0,0);
    mDialogView.getChildAt(0).setPadding(0,0,0,mNavBarAvailable ? getNavigationBarHeight(getContext()) + mDialogView.getPaddingBottom() : 0);
  }
  final TextView title=(TextView)mDialogView.findViewById(R.id.bottom_sheet_title);
  if (builder.title != null) {
    title.setVisibility(View.VISIBLE);
    title.setText(builder.title);
  }
  icon=(ImageView)mDialogView.findViewById(R.id.bottom_sheet_title_image);
  list=(GridView)mDialogView.findViewById(R.id.bottom_sheet_gridview);
  mDialogView.mTarget=list;
  if (!builder.grid) {
    list.setNumColumns(1);
  }
  menuItem=builder.menuItems;
  if (builder.grid) {
    Iterator<MenuItem> i=menuItem.iterator();
    while (i.hasNext()) {
      MenuItem item=i.next();
      if (item.divider)       i.remove();
 else       if (item.icon == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (builder.limit > 0)   limit=builder.limit * getNumColumns();
 else   limit=Integer.MAX_VALUE;
  mDialogView.setCollapsible(false);
  if (menuItem.size() > limit) {
    fullMenuItem=new ArrayList<>(menuItem);
    menuItem=menuItem.subList(0,limit - 1);
    menuItem.add(new MenuItem(R.id.bs_more,moreText,more));
    mDialogView.setCollapsible(true);
  }
  actions=menuItem;
  adapter=new BaseAdapter(){
    @Override public int getCount(){
      return actions.size();
    }
    @Override public MenuItem getItem(    int position){
      return actions.get(position);
    }
    @Override public long getItemId(    int position){
      return position;
    }
    @Override public int getViewTypeCount(){
      return 2;
    }
    @Override public boolean isEnabled(    int position){
      return getItemViewType(position) == 0;
    }
    @Override public boolean areAllItemsEnabled(){
      return false;
    }
    @Override public int getItemViewType(    int position){
      return getItem(position).divider ? 1 : 0;
    }
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      ViewHolder holder;
      if (getItemViewType(position) == 0) {
        if (convertView == null) {
          LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
          if (builder.grid)           convertView=inflater.inflate(R.layout.bs_grid_entry,parent,false);
 else           convertView=inflater.inflate(R.layout.bs_list_entry,parent,false);
          holder=new ViewHolder();
          holder.title=(TextView)convertView.findViewById(R.id.bs_list_title);
          holder.image=(ImageView)convertView.findViewById(R.id.bs_list_image);
          convertView.setTag(holder);
        }
 else {
          holder=(ViewHolder)convertView.getTag();
        }
        MenuItem item=getItem(position);
        holder.title.setText(item.text);
        if (item.icon == null)         holder.image.setVisibility(collapseListIcons ? View.GONE : View.INVISIBLE);
 else {
          holder.image.setVisibility(View.VISIBLE);
          holder.image.setImageDrawable(item.icon);
        }
        return convertView;
      }
 else {
        if (convertView == null) {
          LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
          convertView=inflater.inflate(R.layout.bs_list_divider,parent,false);
          convertView.setVisibility(View.VISIBLE);
        }
        return convertView;
      }
    }
class ViewHolder {
      private TextView title;
      private ImageView image;
    }
  }
;
  list.setAdapter(adapter);
  list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      if (((MenuItem)adapter.getItem(position)).id == R.id.bs_more) {
        showFullItems();
        mDialogView.setCollapsible(false);
        return;
      }
      if (builder.listener != null) {
        builder.listener.onClick(BottomSheet.this,((MenuItem)adapter.getItem(position)).id);
      }
      dismiss();
    }
  }
);
  if (builder.dismissListener != null) {
    setOnDismissListener(builder.dismissListener);
  }
  setListLayout();
}","private void init(final Context context){
  setCanceledOnTouchOutside(cancelOnTouchOutside);
  final ClosableSlidingLayout mDialogView=(ClosableSlidingLayout)View.inflate(context,R.layout.bottom_sheet_dialog,null);
  setContentView(mDialogView);
  if (!cancelOnSwipeDown)   mDialogView.swipeable=cancelOnSwipeDown;
  mDialogView.setSlideListener(new ClosableSlidingLayout.SlideListener(){
    @Override public void onClosed(){
      BottomSheet.this.dismiss();
    }
    @Override public void onOpened(){
      showFullItems();
    }
  }
);
  this.setOnShowListener(new OnShowListener(){
    @Override public void onShow(    DialogInterface dialogInterface){
      actions=menuItem;
      list.setAdapter(adapter);
      list.startLayoutAnimation();
      if (builder.icon == null)       icon.setVisibility(View.GONE);
 else {
        icon.setVisibility(View.VISIBLE);
        icon.setImageDrawable(builder.icon);
      }
    }
  }
);
  int[] location=new int[2];
  mDialogView.getLocationOnScreen(location);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    mDialogView.setPadding(0,location[0] == 0 ? mStatusBarHeight : 0,0,0);
    mDialogView.getChildAt(0).setPadding(0,0,0,mNavBarAvailable ? getNavigationBarHeight(getContext()) + mDialogView.getPaddingBottom() : 0);
  }
  final TextView title=(TextView)mDialogView.findViewById(R.id.bottom_sheet_title);
  if (builder.title != null) {
    title.setVisibility(View.VISIBLE);
    title.setText(builder.title);
  }
  icon=(ImageView)mDialogView.findViewById(R.id.bottom_sheet_title_image);
  list=(GridView)mDialogView.findViewById(R.id.bottom_sheet_gridview);
  mDialogView.mTarget=list;
  if (!builder.grid) {
    list.setNumColumns(1);
  }
  menuItem=builder.menuItems;
  if (builder.grid) {
    Iterator<MenuItem> i=menuItem.iterator();
    while (i.hasNext()) {
      MenuItem item=i.next();
      if (item.divider)       i.remove();
 else       if (item.icon == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (builder.limit > 0)   limit=builder.limit * getNumColumns();
 else   limit=Integer.MAX_VALUE;
  mDialogView.setCollapsible(false);
  if (menuItem.size() > limit) {
    fullMenuItem=new ArrayList<>(menuItem);
    menuItem=menuItem.subList(0,limit - 1);
    menuItem.add(new MenuItem(R.id.bs_more,moreText,more));
    mDialogView.setCollapsible(true);
  }
  actions=menuItem;
  adapter=new BaseAdapter(){
    @Override public int getCount(){
      return actions.size();
    }
    @Override public MenuItem getItem(    int position){
      return actions.get(position);
    }
    @Override public long getItemId(    int position){
      return position;
    }
    @Override public int getViewTypeCount(){
      return 2;
    }
    @Override public boolean isEnabled(    int position){
      return getItemViewType(position) == 0;
    }
    @Override public boolean areAllItemsEnabled(){
      return false;
    }
    @Override public int getItemViewType(    int position){
      return getItem(position).divider ? 1 : 0;
    }
    @Override public View getView(    int position,    View convertView,    ViewGroup parent){
      ViewHolder holder;
      if (getItemViewType(position) == 0) {
        if (convertView == null) {
          LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
          if (builder.grid)           convertView=inflater.inflate(R.layout.bs_grid_entry,parent,false);
 else           convertView=inflater.inflate(R.layout.bs_list_entry,parent,false);
          holder=new ViewHolder();
          holder.title=(TextView)convertView.findViewById(R.id.bs_list_title);
          holder.image=(ImageView)convertView.findViewById(R.id.bs_list_image);
          convertView.setTag(holder);
        }
 else {
          holder=(ViewHolder)convertView.getTag();
        }
        MenuItem item=getItem(position);
        holder.title.setText(item.text);
        if (item.icon == null)         holder.image.setVisibility(collapseListIcons ? View.GONE : View.INVISIBLE);
 else {
          holder.image.setVisibility(View.VISIBLE);
          holder.image.setImageDrawable(item.icon);
        }
        return convertView;
      }
 else {
        if (convertView == null) {
          LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
          convertView=inflater.inflate(R.layout.bs_list_divider,parent,false);
          convertView.setVisibility(View.VISIBLE);
        }
        return convertView;
      }
    }
class ViewHolder {
      private TextView title;
      private ImageView image;
    }
  }
;
  list.setAdapter(adapter);
  list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      if (((MenuItem)adapter.getItem(position)).id == R.id.bs_more) {
        showFullItems();
        mDialogView.setCollapsible(false);
        return;
      }
      if (builder.listener != null) {
        builder.listener.onClick(BottomSheet.this,((MenuItem)adapter.getItem(position)).id);
      }
      dismiss();
    }
  }
);
  if (builder.dismissListener != null) {
    setOnDismissListener(builder.dismissListener);
  }
  setListLayout();
}"
27281,"@SuppressWarnings(""String_Node_Str"") public BottomSheet(Context context,int theme){
  super(context,theme);
  TypedArray a=getContext().obtainStyledAttributes(null,R.styleable.BottomSheet,R.attr.bottomSheetStyle,0);
  try {
    more=a.getDrawable(R.styleable.BottomSheet_bs_moreDrawable);
    close=a.getDrawable(R.styleable.BottomSheet_bs_closeDrawable);
    moreText=a.getString(R.styleable.BottomSheet_bs_moreText);
    collapseListIcons=a.getBoolean(R.styleable.BottomSheet_bs_collapseListIcons,true);
  }
  finally {
    a.recycle();
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
    mInPortrait=(context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT);
    try {
      Class c=Class.forName(""String_Node_Str"");
      Method m=c.getDeclaredMethod(""String_Node_Str"",String.class);
      m.setAccessible(true);
      sNavBarOverride=(String)m.invoke(null,""String_Node_Str"");
    }
 catch (    Throwable e) {
      sNavBarOverride=null;
    }
    int[] as={android.R.attr.windowTranslucentStatus,android.R.attr.windowTranslucentNavigation};
    a=context.obtainStyledAttributes(as);
    try {
      mStatusBarAvailable=a.getBoolean(0,false);
      mNavBarAvailable=a.getBoolean(1,false);
    }
  finally {
      a.recycle();
    }
    WindowManager.LayoutParams winParams=((Activity)context).getWindow().getAttributes();
    int bits=WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;
    if ((winParams.flags & bits) != 0) {
      mNavBarAvailable=true;
    }
    bits=WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
    if ((winParams.flags & bits) != 0) {
      mStatusBarAvailable=true;
    }
    mSmallestWidthDp=getSmallestWidthDp(wm);
    if (mNavBarAvailable)     setTranslucentStatus(true);
    mStatusBarHeight=getInternalDimensionSize(context.getResources(),STATUS_BAR_HEIGHT_RES_NAME);
  }
}","@SuppressWarnings(""String_Node_Str"") public BottomSheet(Context context,int theme){
  super(context,theme);
  TypedArray a=getContext().obtainStyledAttributes(null,R.styleable.BottomSheet,R.attr.bottomSheetStyle,0);
  try {
    more=a.getDrawable(R.styleable.BottomSheet_bs_moreDrawable);
    close=a.getDrawable(R.styleable.BottomSheet_bs_closeDrawable);
    moreText=a.getString(R.styleable.BottomSheet_bs_moreText);
    collapseListIcons=a.getBoolean(R.styleable.BottomSheet_bs_collapseListIcons,true);
  }
  finally {
    a.recycle();
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
    mInPortrait=(context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT);
    try {
      Class c=Class.forName(""String_Node_Str"");
      Method m=c.getDeclaredMethod(""String_Node_Str"",String.class);
      m.setAccessible(true);
      sNavBarOverride=(String)m.invoke(null,""String_Node_Str"");
    }
 catch (    Throwable e) {
      sNavBarOverride=null;
    }
    int[] as={android.R.attr.windowTranslucentNavigation};
    a=context.obtainStyledAttributes(as);
    try {
      mNavBarAvailable=a.getBoolean(0,false);
    }
  finally {
      a.recycle();
    }
    WindowManager.LayoutParams winParams=((Activity)context).getWindow().getAttributes();
    int bits=WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;
    if ((winParams.flags & bits) != 0) {
      mNavBarAvailable=true;
    }
    mSmallestWidthDp=getSmallestWidthDp(wm);
    if (mNavBarAvailable)     setTranslucentStatus(true);
    mStatusBarHeight=getInternalDimensionSize(context.getResources(),STATUS_BAR_HEIGHT_RES_NAME);
  }
}"
27282,"public static int getDaysInMonth(int month,int year){
switch (month) {
case Calendar.JANUARY:
case Calendar.MARCH:
case Calendar.MAY:
case Calendar.JULY:
case Calendar.AUGUST:
case Calendar.OCTOBER:
case Calendar.DECEMBER:
    return 31;
case Calendar.APRIL:
case Calendar.JUNE:
case Calendar.SEPTEMBER:
case Calendar.NOVEMBER:
  return 30;
case Calendar.FEBRUARY:
return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) ? 28 : 29;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}","public static int getDaysInMonth(int month,int year){
switch (month) {
case Calendar.JANUARY:
case Calendar.MARCH:
case Calendar.MAY:
case Calendar.JULY:
case Calendar.AUGUST:
case Calendar.OCTOBER:
case Calendar.DECEMBER:
    return 31;
case Calendar.APRIL:
case Calendar.JUNE:
case Calendar.SEPTEMBER:
case Calendar.NOVEMBER:
  return 30;
case Calendar.FEBRUARY:
return ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) ? 29 : 28;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
}"
27283,"/** 
 * Method to replace String.join, since it was only introduced in java8
 * @param array the array to be concatenated
 * @return concatenated String
 */
private String stringJoin(String[] array){
  String joined=""String_Node_Str"";
  for (  String str : array)   joined+=str;
  return joined;
}","/** 
 * Method to replace String.join, since it was only introduced in java8
 * @param array the array to be concatenated
 * @return concatenated String
 */
private String stringJoin(String[] array,int count){
  String joined=""String_Node_Str"";
  for (int i=0; i < count; i++)   joined+=array[i];
  return joined;
}"
27284,"/** 
 * Constructor for the Emoji.
 * @param description         The description of the emoji
 * @param supportsFitzpatrick wether the emoji supports the Fitzpatrick modifiers or not
 * @param aliases             the aliases for this emoji
 * @param tags                the tags associated with this emoji
 * @param bytes               the bytes that represent the emoji
 */
protected Emoji(String description,boolean supportsFitzpatrick,List<String> aliases,List<String> tags,byte... bytes){
  this.description=description;
  this.supportsFitzpatrick=supportsFitzpatrick;
  this.aliases=Collections.unmodifiableList(aliases);
  this.tags=Collections.unmodifiableList(tags);
  int count=0;
  try {
    this.unicode=new String(bytes,""String_Node_Str"");
    int stringLength=getUnicode().length();
    String[] pointCodes=new String[stringLength];
    String[] pointCodesHex=new String[stringLength];
    for (int offset=0; offset < stringLength; ) {
      final int codePoint=getUnicode().codePointAt(offset);
      pointCodes[count]=String.format(""String_Node_Str"",codePoint);
      pointCodesHex[count++]=String.format(""String_Node_Str"",codePoint);
      offset+=Character.charCount(codePoint);
    }
    this.htmlDec=stringJoin(pointCodes);
    this.htmlHex=stringJoin(pointCodesHex);
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Constructor for the Emoji.
 * @param description         The description of the emoji
 * @param supportsFitzpatrick wether the emoji supports the Fitzpatrick modifiers or not
 * @param aliases             the aliases for this emoji
 * @param tags                the tags associated with this emoji
 * @param bytes               the bytes that represent the emoji
 */
protected Emoji(String description,boolean supportsFitzpatrick,List<String> aliases,List<String> tags,byte... bytes){
  this.description=description;
  this.supportsFitzpatrick=supportsFitzpatrick;
  this.aliases=Collections.unmodifiableList(aliases);
  this.tags=Collections.unmodifiableList(tags);
  int count=0;
  try {
    this.unicode=new String(bytes,""String_Node_Str"");
    int stringLength=getUnicode().length();
    String[] pointCodes=new String[stringLength];
    String[] pointCodesHex=new String[stringLength];
    for (int offset=0; offset < stringLength; ) {
      final int codePoint=getUnicode().codePointAt(offset);
      pointCodes[count]=String.format(""String_Node_Str"",codePoint);
      pointCodesHex[count++]=String.format(""String_Node_Str"",codePoint);
      offset+=Character.charCount(codePoint);
    }
    this.htmlDec=stringJoin(pointCodes,count);
    this.htmlHex=stringJoin(pointCodesHex,count);
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
}"
27285,"@Override public boolean onTouchEvent(final MotionEvent event){
  Log.d(""String_Node_Str"",String.valueOf(event.getActionMasked()));
  Log.d(""String_Node_Str"",String.valueOf(mIsAnimating));
  Log.d(""String_Node_Str"",String.valueOf(mAnimationIsCancel));
  boolean superResult=super.onTouchEvent(event);
  if (event.getActionMasked() == MotionEvent.ACTION_DOWN && this.isEnabled() && mHover) {
    mRect=new Rect(getLeft(),getTop(),getRight(),getBottom());
    mAnimationIsCancel=false;
    mDownX=event.getX();
    mDownY=event.getY();
    mRadiusAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",0,dp(50)).setDuration(400);
    mRadiusAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    mRadiusAnimator.start();
    if (!superResult) {
      return true;
    }
  }
 else   if (event.getActionMasked() == MotionEvent.ACTION_MOVE && this.isEnabled() && mHover) {
    mDownX=event.getX();
    mDownY=event.getY();
    if (mAnimationIsCancel=!mRect.contains(getLeft() + (int)event.getX(),getTop() + (int)event.getY())) {
      setRadius(0);
    }
 else {
      setRadius(dp(50));
    }
    if (!superResult) {
      return true;
    }
  }
 else   if (event.getActionMasked() == MotionEvent.ACTION_UP && !mAnimationIsCancel && this.isEnabled()) {
    mDownX=event.getX();
    mDownY=event.getY();
    final float tempRadius=(float)Math.sqrt(mDownX * mDownX + mDownY * mDownY);
    float targetRadius=Math.max(tempRadius,mMaxRadius);
    if (mIsAnimating) {
      mRadiusAnimator.cancel();
    }
    mRadiusAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",dp(50),targetRadius);
    mRadiusAnimator.setDuration(500);
    mRadiusAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    mRadiusAnimator.addListener(new Animator.AnimatorListener(){
      @Override public void onAnimationStart(      Animator animator){
        mIsAnimating=true;
      }
      @Override public void onAnimationEnd(      Animator animator){
        setRadius(0);
        ViewHelper.setAlpha(RippleView.this,1);
        mIsAnimating=false;
      }
      @Override public void onAnimationCancel(      Animator animator){
      }
      @Override public void onAnimationRepeat(      Animator animator){
      }
    }
);
    mRadiusAnimator.start();
    if (!superResult) {
      return true;
    }
  }
  return superResult;
}","@Override public boolean onTouchEvent(final MotionEvent event){
  Log.d(""String_Node_Str"",String.valueOf(event.getActionMasked()));
  Log.d(""String_Node_Str"",String.valueOf(mIsAnimating));
  Log.d(""String_Node_Str"",String.valueOf(mAnimationIsCancel));
  boolean superResult=super.onTouchEvent(event);
  if (event.getActionMasked() == MotionEvent.ACTION_DOWN && this.isEnabled() && mHover) {
    mRect=new Rect(getLeft(),getTop(),getRight(),getBottom());
    mAnimationIsCancel=false;
    mDownX=event.getX();
    mDownY=event.getY();
    mRadiusAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",0,dp(50)).setDuration(400);
    mRadiusAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    mRadiusAnimator.addListener(new Animator.AnimatorListener(){
      @Override public void onAnimationStart(      Animator animator){
        mIsAnimating=true;
      }
      @Override public void onAnimationEnd(      Animator animator){
        setRadius(0);
        ViewHelper.setAlpha(RippleView.this,1);
        mIsAnimating=false;
      }
      @Override public void onAnimationCancel(      Animator animator){
      }
      @Override public void onAnimationRepeat(      Animator animator){
      }
    }
);
    mRadiusAnimator.start();
    if (!superResult) {
      return true;
    }
  }
 else   if (event.getActionMasked() == MotionEvent.ACTION_MOVE && this.isEnabled() && mHover) {
    mDownX=event.getX();
    mDownY=event.getY();
    if (mAnimationIsCancel=!mRect.contains(getLeft() + (int)event.getX(),getTop() + (int)event.getY())) {
      setRadius(0);
    }
 else {
      setRadius(dp(50));
    }
    if (!superResult) {
      return true;
    }
  }
 else   if (event.getActionMasked() == MotionEvent.ACTION_UP && !mAnimationIsCancel && this.isEnabled()) {
    mDownX=event.getX();
    mDownY=event.getY();
    final float tempRadius=(float)Math.sqrt(mDownX * mDownX + mDownY * mDownY);
    float targetRadius=Math.max(tempRadius,mMaxRadius);
    if (mIsAnimating) {
      mRadiusAnimator.cancel();
    }
    mRadiusAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",dp(50),targetRadius);
    mRadiusAnimator.setDuration(500);
    mRadiusAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    mRadiusAnimator.addListener(new Animator.AnimatorListener(){
      @Override public void onAnimationStart(      Animator animator){
        mIsAnimating=true;
      }
      @Override public void onAnimationEnd(      Animator animator){
        setRadius(0);
        ViewHelper.setAlpha(RippleView.this,1);
        mIsAnimating=false;
      }
      @Override public void onAnimationCancel(      Animator animator){
      }
      @Override public void onAnimationRepeat(      Animator animator){
      }
    }
);
    mRadiusAnimator.start();
    if (!superResult) {
      return true;
    }
  }
  return superResult;
}"
27286,"/** 
 * Loads the class with the specified binary name prioritized by the ""parent-first"" condition. It copy-cats   {@code ClassLoader#loadClass} while the ""parent-first"" priorities are considered.If the specified class is ""parent-first"", it behaves the same as  {@code ClassLoader#loadClass} ordered as below.<ol> <li><p>Invoke the  {@code #findLoadedClass} method to check if the class has already been loaded.</p></li><li><p>Invoke the parent's  {@code #loadClass} method.<li><p>Invoke the  {@code #findClass} method of this class loader to find the class.</p></li></ol> If the specified class is ""NOT parent-first"", the 2nd and 3rd actions are swapped.
 * @see https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#loadClass(java.lang.String,%20boolean)
 * @see http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/jdk7u141-b02/src/share/classes/java/lang/ClassLoader.java
 */
@Override protected Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {
synchronized (getClassLoadingLock(name)) {
    final Class<?> loadedClass=findLoadedClass(name);
    if (loadedClass != null) {
      return resolveClass(loadedClass,resolve);
    }
    final boolean parentFirst=isParentFirstPackage(name);
    if (!parentFirst) {
      try {
        return resolveClass(findClass(name),resolve);
      }
 catch (      ClassNotFoundException ignored) {
      }
    }
    try {
      return resolveClass(getParent().loadClass(name),resolve);
    }
 catch (    ClassNotFoundException ignored) {
    }
    if (parentFirst) {
      return resolveClass(findClass(name),resolve);
    }
    throw new ClassNotFoundException(name);
  }
}","/** 
 * Loads the class with the specified binary name prioritized by the ""parent-first"" condition. It copy-cats   {@code ClassLoader#loadClass} while the ""parent-first"" priorities are considered.If the specified class is ""parent-first"", it behaves the same as  {@code ClassLoader#loadClass} ordered as below.<ol> <li><p>Invoke the  {@code #findLoadedClass} method to check if the class has already been loaded.</p></li><li><p>Invoke the parent's  {@code #loadClass} method.<li><p>Invoke the  {@code #findClass} method of this class loader to find the class.</p></li></ol> If the specified class is ""NOT parent-first"", the 2nd and 3rd actions are swapped.
 * @see <a href=""https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#loadClass(java.lang.String,%20boolean)"">Oracle Java7's ClassLoader#loadClass</a>
 * @see <a href=""http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/jdk7u141-b02/src/share/classes/java/lang/ClassLoader.java"">OpenJDK7's ClassLoader</a>
 */
@Override protected Class<?> loadClass(String name,boolean resolve) throws ClassNotFoundException {
synchronized (getClassLoadingLock(name)) {
    final Class<?> loadedClass=findLoadedClass(name);
    if (loadedClass != null) {
      return resolveClass(loadedClass,resolve);
    }
    final boolean parentFirst=isParentFirstPackage(name);
    if (!parentFirst) {
      try {
        return resolveClass(findClass(name),resolve);
      }
 catch (      ClassNotFoundException ignored) {
      }
    }
    try {
      return resolveClass(getParent().loadClass(name),resolve);
    }
 catch (    ClassNotFoundException ignored) {
    }
    if (parentFirst) {
      return resolveClass(findClass(name),resolve);
    }
    throw new ClassNotFoundException(name);
  }
}"
27287,"/** 
 * Adds the specified path to the list of URLs (for   {@code URLClassLoader}) to search for classes and resources. It internally calls   {@code URLClassLoader#addURL}. Some plugins (embulk-input-jdbc, for example) are calling this method to load external JAR files.
 * @see https://github.com/embulk/embulk-input-jdbc/blob/ebfff0b249d507fc730c87e08b56e6aa492060ca/embulk-input-jdbc/src/main/java/org/embulk/input/jdbc/AbstractJdbcInputPlugin.java#L586-L595
 */
public void addPath(Path path){
  try {
    addUrl(path.toUri().toURL());
  }
 catch (  MalformedURLException ex) {
    throw new IllegalArgumentException(ex);
  }
}","/** 
 * Adds the specified path to the list of URLs (for   {@code URLClassLoader}) to search for classes and resources. It internally calls   {@code URLClassLoader#addURL}. Some plugins (embulk-input-jdbc, for example) are calling this method to load external JAR files.
 * @see <a href=""https://github.com/embulk/embulk-input-jdbc/blob/ebfff0b249d507fc730c87e08b56e6aa492060ca/embulk-input-jdbc/src/main/java/org/embulk/input/jdbc/AbstractJdbcInputPlugin.java#L586-L595"">embulk-input-jdbc</a>
 */
public void addPath(Path path){
  try {
    addUrl(path.toUri().toURL());
  }
 catch (  MalformedURLException ex) {
    throw new IllegalArgumentException(ex);
  }
}"
27288,"@Test @Ignore(""String_Node_Str"") public void checkCharacterTypesRuleLongReplace(){
  final String original[]={""String_Node_Str""};
  final String pass_types[]={""String_Node_Str""};
  exception.expect(AssertionError.class);
  checkCharacterTypesRuleInternal(original,original,pass_types,""String_Node_Str"",""String_Node_Str"");
}","@Test public void checkCharacterTypesRuleLongReplace(){
  final String original[]={""String_Node_Str""};
  final String pass_types[]={""String_Node_Str""};
  exception.expect(TaskValidationException.class);
  checkCharacterTypesRuleInternal(original,original,pass_types,""String_Node_Str"",""String_Node_Str"");
}"
27289,"@Test @Ignore(""String_Node_Str"") public void checkUniqueNumberSuffixRuleNegativeLength(){
  final String originalColumnNames[]={""String_Node_Str""};
  exception.expect(AssertionError.class);
  checkUniqueNumberSuffixRuleInternal(originalColumnNames,originalColumnNames,DEFAULT,-1,-2);
}","@Test public void checkUniqueNumberSuffixRuleNegativeLength(){
  final String originalColumnNames[]={""String_Node_Str""};
  exception.expect(ConfigException.class);
  checkUniqueNumberSuffixRuleInternal(originalColumnNames,originalColumnNames,DEFAULT,-1,-2);
}"
27290,"@Test @Ignore(""String_Node_Str"") public void checkCharacterTypesRuleEmptyReplace(){
  final String original[]={""String_Node_Str""};
  final String pass_types[]={""String_Node_Str""};
  exception.expect(AssertionError.class);
  checkCharacterTypesRuleInternal(original,original,pass_types,""String_Node_Str"",""String_Node_Str"");
}","@Test public void checkCharacterTypesRuleEmptyReplace(){
  final String original[]={""String_Node_Str""};
  final String pass_types[]={""String_Node_Str""};
  exception.expect(TaskValidationException.class);
  checkCharacterTypesRuleInternal(original,original,pass_types,""String_Node_Str"",""String_Node_Str"");
}"
27291,"@Test @Ignore(""String_Node_Str"") public void checkTruncateRuleNegative(){
  final String original[]={""String_Node_Str""};
  ConfigSource config=Exec.newConfigSource().set(""String_Node_Str"",ImmutableList.of(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",-1)));
  exception.expect(AssertionError.class);
  renameAndCheckSchema(config,original,original);
}","@Test public void checkTruncateRuleNegative(){
  final String original[]={""String_Node_Str""};
  ConfigSource config=Exec.newConfigSource().set(""String_Node_Str"",ImmutableList.of(ImmutableMap.of(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",-1)));
  exception.expect(TaskValidationException.class);
  renameAndCheckSchema(config,original,original);
}"
27292,"private TimestampFormatter[] newTimestampFormatters(TimestampFormatter.Task formatterTask,Schema schema,Map<String,TimestampColumnOption> columnOptions){
  TimestampFormatter[] formatters=new TimestampFormatter[schema.getColumnCount()];
  int i=0;
  for (  Column column : schema.getColumns()) {
    if (column.getType() instanceof TimestampType) {
      Optional<TimestampColumnOption> option=Optional.fromNullable(columnOptions.get(column.getName()));
      formatters[i]=new TimestampFormatter(formatterTask,option);
    }
  }
  return formatters;
}","private TimestampFormatter[] newTimestampFormatters(TimestampFormatter.Task formatterTask,Schema schema,Map<String,TimestampColumnOption> columnOptions){
  TimestampFormatter[] formatters=new TimestampFormatter[schema.getColumnCount()];
  int i=0;
  for (  Column column : schema.getColumns()) {
    if (column.getType() instanceof TimestampType) {
      Optional<TimestampColumnOption> option=Optional.fromNullable(columnOptions.get(column.getName()));
      formatters[i]=new TimestampFormatter(formatterTask,option);
    }
    i++;
  }
  return formatters;
}"
27293,"public static void main(String[] args) throws Exception {
  System.out.println(Arrays.asList(args));
  File thisFolder=new File(SelfrunTest.class.getResource(""String_Node_Str"").toURI()).getParentFile();
  try (FileWriter writer=new FileWriter(new File(thisFolder,""String_Node_Str""))){
    for (    String arg : args) {
      writer.write(arg);
      writer.write(System.getProperty(""String_Node_Str""));
    }
  }
 }","public static void main(String[] args) throws Exception {
  System.out.println(Arrays.asList(args));
  File thisFolder=new File(SelfrunTest.class.getResource(""String_Node_Str"").toURI()).getParentFile();
  try (BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(thisFolder,""String_Node_Str"")),Charset.defaultCharset()))){
    for (    String arg : args) {
      writer.write(arg);
      writer.newLine();
    }
  }
 }"
27294,"@BeforeClass public static void prepare() throws Exception {
  File selfrun=findSelfrun();
  FileSystem fs=FileSystems.getDefault();
  String line=new String(Files.readAllBytes(fs.getPath(selfrun.getAbsolutePath())),Charset.defaultCharset());
  File thisFolder=new File(SelfrunTest.class.getResource(""String_Node_Str"").toURI()).getParentFile();
  testSelfrun=new File(thisFolder,System.getProperty(""String_Node_Str"").equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  testSelfrun.setExecutable(true);
  File classpath=thisFolder.getParentFile().getParentFile().getParentFile();
  line=line.replaceAll(""String_Node_Str"",""String_Node_Str"" + classpath.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  Files.write(fs.getPath(testSelfrun.getAbsolutePath()),line.getBytes(Charset.defaultCharset()),StandardOpenOption.CREATE);
}","@BeforeClass public static void prepare() throws Exception {
  File selfrun=findSelfrun();
  FileSystem fs=FileSystems.getDefault();
  String line=new String(Files.readAllBytes(fs.getPath(selfrun.getAbsolutePath())),Charset.defaultCharset());
  File thisFolder=new File(SelfrunTest.class.getResource(""String_Node_Str"").toURI()).getParentFile();
  testSelfrun=new File(thisFolder,System.getProperty(""String_Node_Str"").equals(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  File classpath=thisFolder.getParentFile().getParentFile().getParentFile();
  line=line.replaceAll(""String_Node_Str"",""String_Node_Str"" + classpath.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  Files.write(fs.getPath(testSelfrun.getAbsolutePath()),line.getBytes(Charset.defaultCharset()),StandardOpenOption.CREATE);
  if (!testSelfrun.setExecutable(true)) {
    throw new Exception(""String_Node_Str"");
  }
}"
27295,"private List<String> execute(String... arguments) throws Exception {
  File temp=new File(testSelfrun.getParentFile(),""String_Node_Str"" + testSelfrun.getName());
  try (FileWriter writer=new FileWriter(temp)){
    writer.write(testSelfrun.getAbsolutePath());
    for (    String argument : arguments) {
      writer.write(""String_Node_Str"");
      writer.write(argument);
    }
  }
   temp.setExecutable(true);
  File argsFile=new File(testSelfrun.getParentFile(),""String_Node_Str"");
  argsFile.delete();
  Process process=Runtime.getRuntime().exec(temp.getAbsolutePath());
  int exitCode=process.waitFor();
  if (exitCode != 0 || !argsFile.exists()) {
    StringBuilder builder=new StringBuilder();
    try (BufferedReader reader=new BufferedReader(new InputStreamReader(process.getErrorStream()))){
      builder.append(reader.readLine());
      builder.append(System.getProperty(""String_Node_Str""));
    }
     throw new Exception(builder.toString());
  }
  FileSystem fs=FileSystems.getDefault();
  List<String> args=Files.readAllLines(fs.getPath(argsFile.getAbsolutePath()),Charset.defaultCharset());
  return args;
}","private List<String> execute(String... arguments) throws Exception {
  File temp=new File(testSelfrun.getParentFile(),""String_Node_Str"" + testSelfrun.getName());
  try (BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(temp),Charset.defaultCharset()))){
    writer.write(testSelfrun.getAbsolutePath());
    for (    String argument : arguments) {
      writer.write(""String_Node_Str"");
      writer.write(argument);
    }
  }
   if (!temp.setExecutable(true)) {
    throw new Exception(""String_Node_Str"");
  }
  File argsFile=new File(testSelfrun.getParentFile(),""String_Node_Str"");
  if (argsFile.exists()) {
    if (!argsFile.delete()) {
      throw new IOException(""String_Node_Str"" + argsFile);
    }
  }
  Process process=Runtime.getRuntime().exec(temp.getAbsolutePath());
  int exitCode=process.waitFor();
  if (exitCode != 0 || !argsFile.exists()) {
    StringBuilder builder=new StringBuilder();
    try (BufferedReader reader=new BufferedReader(new InputStreamReader(process.getErrorStream(),Charset.defaultCharset()))){
      builder.append(reader.readLine());
      builder.append(System.getProperty(""String_Node_Str""));
    }
     throw new Exception(builder.toString());
  }
  FileSystem fs=FileSystems.getDefault();
  List<String> args=Files.readAllLines(fs.getPath(argsFile.getAbsolutePath()),Charset.defaultCharset());
  return args;
}"
27296,"@Test public void testJFile() throws Exception {
  File javaArgsFile=new File(testSelfrun.getParentFile(),""String_Node_Str"");
  FileSystem fs=FileSystems.getDefault();
  Files.write(fs.getPath(javaArgsFile.getAbsolutePath()),""String_Node_Str"".getBytes(),StandardOpenOption.CREATE);
  List<String> args=execute(""String_Node_Str"",javaArgsFile.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
  assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",testSelfrun.getAbsolutePath(),""String_Node_Str"",""String_Node_Str""),args);
}","@Test public void testJFile() throws Exception {
  File javaArgsFile=new File(testSelfrun.getParentFile(),""String_Node_Str"");
  FileSystem fs=FileSystems.getDefault();
  Files.write(fs.getPath(javaArgsFile.getAbsolutePath()),""String_Node_Str"".getBytes(Charset.defaultCharset()),StandardOpenOption.CREATE);
  List<String> args=execute(""String_Node_Str"",javaArgsFile.getAbsolutePath(),""String_Node_Str"",""String_Node_Str"");
  assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",testSelfrun.getAbsolutePath(),""String_Node_Str"",""String_Node_Str""),args);
}"
27297,"public static Buffer runFileInputSampling(final FileInputRunner runner,ConfigSource inputConfig){
  ConfigSource samplingInputConfig=inputConfig.deepCopy();
  samplingInputConfig.getNestedOrSetEmpty(""String_Node_Str"").set(""String_Node_Str"",""String_Node_Str"");
  try {
    runner.transaction(samplingInputConfig,new InputPlugin.Control(){
      public List<CommitReport> run(      TaskSource taskSource,      Schema schema,      int taskCount){
        runner.run(taskSource,schema,0,new PageOutput(){
          @Override public void add(          Page page){
            throw new RuntimeException(""String_Node_Str"");
          }
          public void finish(){
          }
          public void close(){
          }
        }
);
        throw new NoSampleException(""String_Node_Str"");
      }
    }
);
    throw new AssertionError(""String_Node_Str"");
  }
 catch (  SampledNoticeError error) {
    return error.getSample();
  }
}","public static Buffer runFileInputSampling(final FileInputRunner runner,ConfigSource inputConfig){
  ConfigSource samplingInputConfig=inputConfig.deepCopy();
  samplingInputConfig.getNestedOrSetEmpty(""String_Node_Str"").set(""String_Node_Str"",""String_Node_Str"");
  samplingInputConfig.set(""String_Node_Str"",null);
  try {
    runner.transaction(samplingInputConfig,new InputPlugin.Control(){
      public List<CommitReport> run(      TaskSource taskSource,      Schema schema,      int taskCount){
        runner.run(taskSource,schema,0,new PageOutput(){
          @Override public void add(          Page page){
            throw new RuntimeException(""String_Node_Str"");
          }
          public void finish(){
          }
          public void close(){
          }
        }
);
        throw new NoSampleException(""String_Node_Str"");
      }
    }
);
    throw new AssertionError(""String_Node_Str"");
  }
 catch (  SampledNoticeError error) {
    return error.getSample();
  }
}"
27298,"@Override public long skip(long len){
  return read(null,0,(int)Math.min(len,Integer.MAX_VALUE));
}","@Override public long skip(long len){
  int skipped=read(null,0,(int)Math.min(len,Integer.MAX_VALUE));
  return skipped > 0 ? skipped : 0;
}"
27299,"public void cleanup(String configPath){
  String resumePath=options.getResumeStatePath();
  if (resumePath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ConfigSource config=loadYamlConfig(configPath);
  ConfigSource resumeConfig=loadYamlConfig(resumePath);
  ResumeState resume=resumeConfig.loadConfig(ResumeState.class);
  ExecSession exec=newExecSession(config);
  LocalExecutor local=injector.getInstance(LocalExecutor.class);
  local.cleanup(config,resume);
  boolean dontCare=new File(options.getResumeStatePath()).delete();
}","public void cleanup(String configPath){
  String resumePath=options.getResumeStatePath();
  if (resumePath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ConfigSource config=loadYamlConfig(configPath);
  ConfigSource resumeConfig=loadYamlConfig(resumePath);
  ResumeState resume=resumeConfig.loadConfig(ResumeState.class);
  LocalExecutor local=injector.getInstance(LocalExecutor.class);
  local.cleanup(config,resume);
  boolean dontCare=new File(options.getResumeStatePath()).delete();
}"
27300,"@Override public ConfigDiff transaction(ConfigSource config,int taskCount,FileOutputPlugin.Control control){
  PluginTask task=config.loadConfig(PluginTask.class);
  String.format(task.getSequenceFormat(),0,0);
  return resume(task.dump(),taskCount,control);
}","@Override public ConfigDiff transaction(ConfigSource config,int taskCount,FileOutputPlugin.Control control){
  PluginTask task=config.loadConfig(PluginTask.class);
  try {
    String dontCare=String.format(Locale.ENGLISH,task.getSequenceFormat(),0,0);
  }
 catch (  IllegalFormatException ex) {
    throw new ConfigException(""String_Node_Str"",ex);
  }
  return resume(task.dump(),taskCount,control);
}"
27301,"@Override public int compare(Message o1,Message o2){
  int prio1=o1.getPriority().getPrio();
  int prio2=o1.getPriority().getPrio();
  if (prio1 == prio2) {
    return o1.getTimestamp().compareTo(o2.getTimestamp());
  }
  return prio1 - prio2;
}","@Override public int compare(Message o1,Message o2){
  int prio1=o1.getPriority().getPrio();
  int prio2=o2.getPriority().getPrio();
  if (prio1 == prio2) {
    return o1.getTimestamp().compareTo(o2.getTimestamp());
  }
  return prio1 - prio2;
}"
27302,"public void error(String messageFormat,Object... args){
  if (messagePriorityThreshold <= Priority.ERROR.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.ERROR,currentTimestamp(),String.format(messageFormat,args)));
}","public void error(String messageFormat,Object... args){
  if (messagePriorityThreshold > Priority.ERROR.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.ERROR,currentTimestamp(),String.format(messageFormat,args)));
}"
27303,"public synchronized List<Message> getMessages(){
  return ImmutableList.copyOf(messages);
}","public synchronized List<Message> getMessages(){
  List<Message> result=new ArrayList<Message>(messages);
  Collections.sort(result,new MessagePriorityComparator());
  Collections.reverse(result);
  return ImmutableList.copyOf(result);
}"
27304,"public synchronized void addAllMessagesTo(Collection<Message> collection){
  collection.addAll(messages);
}","public synchronized void addAllMessagesTo(Collection<Message> collection){
  for (  Message msg : collection) {
    if (msg.getPriority().getPrio() >= messagePriorityThreshold) {
      addMessage(msg);
      ;
    }
  }
}"
27305,"public void info(String messageFormat,Object... args){
  if (messagePriorityThreshold <= Priority.INFO.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.INFO,currentTimestamp(),String.format(messageFormat,args)));
}","public void info(String messageFormat,Object... args){
  if (messagePriorityThreshold > Priority.INFO.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.INFO,currentTimestamp(),String.format(messageFormat,args)));
}"
27306,"public void debug(String messageFormat,Object... args){
  if (messagePriorityThreshold <= Priority.DEBUG.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.DEBUG,currentTimestamp(),String.format(messageFormat,args)));
}","public void debug(String messageFormat,Object... args){
  if (messagePriorityThreshold > Priority.DEBUG.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.DEBUG,currentTimestamp(),String.format(messageFormat,args)));
}"
27307,"public void warn(String messageFormat,Object... args){
  if (messagePriorityThreshold <= Priority.WARN.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.WARN,currentTimestamp(),String.format(messageFormat,args)));
}","public void warn(String messageFormat,Object... args){
  if (messagePriorityThreshold > Priority.WARN.getPrio()) {
    return;
  }
  addMessage(new Message(Priority.WARN,currentTimestamp(),String.format(messageFormat,args)));
}"
27308,"public void onItemRangeChanged(int startPosition,int itemCount){
  headersViewByHeadersIds.clear();
  if (startPosition + itemCount >= isHeaderByItemPosition.size()) {
    for (int i=startPosition; i < startPosition + itemCount; i++) {
      if (i >= isHeaderByItemPosition.size()) {
        isHeaderByItemPosition.add(null);
      }
    }
  }
  for (int i=0; i < itemCount; i++) {
    isHeaderByItemPosition.set(i + startPosition,null);
  }
  long startPositionId=adapter.getHeaderId(startPosition);
  if (startPosition > 0) {
    long beforeStartPositionId=adapter.getHeaderId(startPosition - 1);
    isHeaderByItemPosition.set(startPosition,startPositionId != beforeStartPositionId);
  }
  if (startPosition + itemCount < isHeaderByItemPosition.size()) {
    long afterStartPositionId=adapter.getHeaderId(startPosition + itemCount);
    isHeaderByItemPosition.set(startPosition + itemCount,startPositionId != afterStartPositionId);
  }
}","public void onItemRangeChanged(int startPosition,int itemCount){
  headersViewByHeadersIds.clear();
  if (startPosition >= isHeaderByItemPosition.size()) {
    return;
  }
  final int start=Math.min(startPosition,isHeaderByItemPosition.size());
  final int end=Math.min(startPosition + itemCount + 1,isHeaderByItemPosition.size());
  for (int i=start; i < end; ++i) {
    isHeaderByItemPosition.set(i,null);
  }
}"
27309,"void receivedPublishQos1(Channel channel,MqttPublishMessage msg){
  final Topic topic=new Topic(msg.variableHeader().topicName());
  String clientID=NettyUtils.clientID(channel);
  String username=NettyUtils.userName(channel);
  if (!m_authorizator.canWrite(topic,username,clientID)) {
    LOG.error(""String_Node_Str"",clientID,topic);
    return;
  }
  final int messageID=msg.variableHeader().messageId();
  IMessagesStore.StoredMessage toStoreMsg=asStoredMessage(msg);
  toStoreMsg.setClientID(clientID);
  this.publisher.publish2Subscribers(toStoreMsg,topic,messageID);
  sendPubAck(clientID,messageID);
  if (msg.fixedHeader().isRetain()) {
    if (!msg.payload().isReadable()) {
      m_messagesStore.cleanRetained(topic);
    }
 else {
      m_messagesStore.storeRetained(topic,toStoreMsg);
    }
  }
  m_interceptor.notifyTopicPublished(msg,clientID,username);
}","void receivedPublishQos1(Channel channel,MqttPublishMessage msg){
  final Topic topic=new Topic(msg.variableHeader().topicName());
  topic.getTokens();
  if (!topic.isValid()) {
    LOG.warn(""String_Node_Str"");
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  String clientID=NettyUtils.clientID(channel);
  String username=NettyUtils.userName(channel);
  if (!m_authorizator.canWrite(topic,username,clientID)) {
    LOG.error(""String_Node_Str"",clientID,topic);
    return;
  }
  final int messageID=msg.variableHeader().messageId();
  IMessagesStore.StoredMessage toStoreMsg=asStoredMessage(msg);
  toStoreMsg.setClientID(clientID);
  this.publisher.publish2Subscribers(toStoreMsg,topic,messageID);
  sendPubAck(clientID,messageID);
  if (msg.fixedHeader().isRetain()) {
    if (!msg.payload().isReadable()) {
      m_messagesStore.cleanRetained(topic);
    }
 else {
      m_messagesStore.storeRetained(topic,toStoreMsg);
    }
  }
  m_interceptor.notifyTopicPublished(msg,clientID,username);
}"
27310,"private List<Token> parseTopic(String topic) throws ParseException {
  List<Token> res=new ArrayList<>();
  String[] splitted=topic.split(""String_Node_Str"");
  if (splitted.length == 0) {
    res.add(Token.EMPTY);
  }
  if (topic.endsWith(""String_Node_Str"")) {
    String[] newSplitted=new String[splitted.length + 1];
    System.arraycopy(splitted,0,newSplitted,0,splitted.length);
    newSplitted[splitted.length]=""String_Node_Str"";
    splitted=newSplitted;
  }
  for (int i=0; i < splitted.length; i++) {
    String s=splitted[i];
    if (s.isEmpty()) {
      res.add(Token.EMPTY);
    }
 else     if (s.equals(""String_Node_Str"")) {
      if (i != splitted.length - 1) {
        throw new ParseException(""String_Node_Str"",i);
      }
      res.add(Token.MULTI);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else     if (s.equals(""String_Node_Str"")) {
      res.add(Token.SINGLE);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else {
      res.add(new Token(s));
    }
  }
  return res;
}","private List<Token> parseTopic(String topic) throws ParseException {
  if (topic.length() == 0) {
    throw new ParseException(""String_Node_Str"" + ""String_Node_Str"",0);
  }
  List<Token> res=new ArrayList<>();
  String[] splitted=topic.split(""String_Node_Str"");
  if (splitted.length == 0) {
    res.add(Token.EMPTY);
  }
  if (topic.endsWith(""String_Node_Str"")) {
    String[] newSplitted=new String[splitted.length + 1];
    System.arraycopy(splitted,0,newSplitted,0,splitted.length);
    newSplitted[splitted.length]=""String_Node_Str"";
    splitted=newSplitted;
  }
  for (int i=0; i < splitted.length; i++) {
    String s=splitted[i];
    if (s.isEmpty()) {
      res.add(Token.EMPTY);
    }
 else     if (s.equals(""String_Node_Str"")) {
      if (i != splitted.length - 1) {
        throw new ParseException(""String_Node_Str"",i);
      }
      res.add(Token.MULTI);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else     if (s.equals(""String_Node_Str"")) {
      res.add(Token.SINGLE);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else {
      res.add(new Token(s));
    }
  }
  return res;
}"
27311,"void verifyNoPublishIsReceived(){
  final Object messageReceived=m_channel.readOutbound();
  assertNull(""String_Node_Str"",messageReceived);
}","void verifyNoPublishIsReceived(EmbeddedChannel channel){
  final Object messageReceived=channel.readOutbound();
  assertNull(""String_Node_Str"",messageReceived);
}"
27312,"@Override public void channelRead(ChannelHandlerContext ctx,Object message) throws Exception {
  MqttMessage msg=(MqttMessage)message;
  if (msg.fixedHeader() == null) {
    throw new IOException(""String_Node_Str"");
  }
  MqttMessageType messageType=msg.fixedHeader().messageType();
  LOG.debug(""String_Node_Str"",messageType);
  try {
switch (messageType) {
case CONNECT:
      m_processor.processConnect(ctx.channel(),(MqttConnectMessage)msg);
    break;
case SUBSCRIBE:
  m_processor.processSubscribe(ctx.channel(),(MqttSubscribeMessage)msg);
break;
case UNSUBSCRIBE:
m_processor.processUnsubscribe(ctx.channel(),(MqttUnsubscribeMessage)msg);
break;
case PUBLISH:
m_processor.processPublish(ctx.channel(),(MqttPublishMessage)msg);
break;
case PUBREC:
m_processor.processPubRec(ctx.channel(),msg);
break;
case PUBCOMP:
m_processor.processPubComp(ctx.channel(),msg);
break;
case PUBREL:
m_processor.processPubRel(ctx.channel(),msg);
break;
case DISCONNECT:
m_processor.processDisconnect(ctx.channel());
break;
case PUBACK:
m_processor.processPubAck(ctx.channel(),(MqttPubAckMessage)msg);
break;
case PINGREQ:
MqttFixedHeader pingHeader=new MqttFixedHeader(MqttMessageType.PINGRESP,false,AT_MOST_ONCE,false,0);
MqttMessage pingResp=new MqttMessage(pingHeader);
ctx.writeAndFlush(pingResp).addListener(CLOSE_ON_FAILURE);
break;
default :
LOG.error(""String_Node_Str"",messageType);
break;
}
}
 catch (Throwable ex) {
ctx.fireExceptionCaught(ex);
}
 finally {
ReferenceCountUtil.release(msg);
}
}","@Override public void channelRead(ChannelHandlerContext ctx,Object message) throws Exception {
  MqttMessage msg=(MqttMessage)message;
  if (msg.fixedHeader() == null) {
    throw new IOException(""String_Node_Str"");
  }
  MqttMessageType messageType=msg.fixedHeader().messageType();
  LOG.debug(""String_Node_Str"",messageType);
  try {
switch (messageType) {
case CONNECT:
      m_processor.processConnect(ctx.channel(),(MqttConnectMessage)msg);
    break;
case SUBSCRIBE:
  m_processor.processSubscribe(ctx.channel(),(MqttSubscribeMessage)msg);
break;
case UNSUBSCRIBE:
m_processor.processUnsubscribe(ctx.channel(),(MqttUnsubscribeMessage)msg);
break;
case PUBLISH:
m_processor.processPublish(ctx.channel(),(MqttPublishMessage)msg);
break;
case PUBREC:
m_processor.processPubRec(ctx.channel(),msg);
break;
case PUBCOMP:
m_processor.processPubComp(ctx.channel(),msg);
break;
case PUBREL:
m_processor.processPubRel(ctx.channel(),msg);
break;
case DISCONNECT:
m_processor.processDisconnect(ctx.channel());
break;
case PUBACK:
m_processor.processPubAck(ctx.channel(),(MqttPubAckMessage)msg);
break;
case PINGREQ:
MqttFixedHeader pingHeader=new MqttFixedHeader(MqttMessageType.PINGRESP,false,AT_MOST_ONCE,false,0);
MqttMessage pingResp=new MqttMessage(pingHeader);
ctx.writeAndFlush(pingResp).addListener(CLOSE_ON_FAILURE);
break;
default :
LOG.error(""String_Node_Str"",messageType);
break;
}
}
 catch (Throwable ex) {
LOG.error(""String_Node_Str"",messageType,ex);
ctx.channel().close().addListener(new ChannelFutureListener(){
@Override public void operationComplete(ChannelFuture future){
LOG.info(""String_Node_Str"");
}
}
);
}
 finally {
ReferenceCountUtil.release(msg);
}
}"
27313,"public void processConnect(Channel channel,MqttConnectMessage msg){
  MqttConnectPayload payload=msg.payload();
  String clientId=payload.clientIdentifier();
  LOG.debug(""String_Node_Str"",clientId,payload.userName());
  if (msg.variableHeader().version() != MqttVersion.MQTT_3_1.protocolLevel() && msg.variableHeader().version() != MqttVersion.MQTT_3_1_1.protocolLevel()) {
    MqttConnAckMessage badProto=connAck(CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION);
    LOG.error(""String_Node_Str"",clientId);
    channel.writeAndFlush(badProto).addListener(FIRE_EXCEPTION_ON_FAILURE);
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final boolean cleanSession=msg.variableHeader().isCleanSession();
  if (clientId == null || clientId.length() == 0) {
    if (!cleanSession || !this.allowZeroByteClientId) {
      MqttConnAckMessage badId=connAck(CONNECTION_REFUSED_IDENTIFIER_REJECTED);
      channel.writeAndFlush(badId).addListener(FIRE_EXCEPTION_ON_FAILURE);
      channel.close().addListener(CLOSE_ON_FAILURE);
      LOG.error(""String_Node_Str"",payload.userName());
      return;
    }
    clientId=UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str"");
    LOG.info(""String_Node_Str"",clientId,payload.userName());
  }
  if (!login(channel,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  ConnectionDescriptor descriptor=new ConnectionDescriptor(clientId,channel,cleanSession);
  final ConnectionDescriptor existing=this.connectionDescriptors.addConnection(descriptor);
  if (existing != null) {
    LOG.info(""String_Node_Str"",clientId);
    existing.abort();
    this.connectionDescriptors.removeConnection(existing);
    this.connectionDescriptors.addConnection(descriptor);
  }
  initializeKeepAliveTimeout(channel,msg,clientId);
  storeWillMessage(msg,clientId);
  if (!sendAck(descriptor,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  m_interceptor.notifyClientConnected(msg);
  if (!descriptor.assignState(SENDACK,SESSION_CREATED)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final ClientSession clientSession=this.sessionsRepository.createOrLoadClientSession(clientId,cleanSession);
  if (!republish(descriptor,msg,clientSession)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  int flushIntervalMs=500;
  setupAutoFlusher(channel,flushIntervalMs);
  final boolean success=descriptor.assignState(MESSAGES_REPUBLISHED,ESTABLISHED);
  if (!success) {
    channel.close().addListener(CLOSE_ON_FAILURE);
  }
  LOG.info(""String_Node_Str"",clientId,payload.userName());
}","public void processConnect(Channel channel,MqttConnectMessage msg){
  MqttConnectPayload payload=msg.payload();
  String clientId=payload.clientIdentifier();
  final String username=payload.userName();
  LOG.debug(""String_Node_Str"",clientId,username);
  if (msg.variableHeader().version() != MqttVersion.MQTT_3_1.protocolLevel() && msg.variableHeader().version() != MqttVersion.MQTT_3_1_1.protocolLevel()) {
    MqttConnAckMessage badProto=connAck(CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION);
    LOG.error(""String_Node_Str"",clientId);
    channel.writeAndFlush(badProto).addListener(FIRE_EXCEPTION_ON_FAILURE);
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final boolean cleanSession=msg.variableHeader().isCleanSession();
  if (clientId == null || clientId.length() == 0) {
    if (!cleanSession || !this.allowZeroByteClientId) {
      MqttConnAckMessage badId=connAck(CONNECTION_REFUSED_IDENTIFIER_REJECTED);
      channel.writeAndFlush(badId).addListener(FIRE_EXCEPTION_ON_FAILURE);
      channel.close().addListener(CLOSE_ON_FAILURE);
      LOG.error(""String_Node_Str"",username);
      return;
    }
    clientId=UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str"");
    LOG.info(""String_Node_Str"",clientId,username);
  }
  if (!login(channel,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  ConnectionDescriptor descriptor=new ConnectionDescriptor(clientId,channel,cleanSession);
  final ConnectionDescriptor existing=this.connectionDescriptors.addConnection(descriptor);
  if (existing != null) {
    LOG.info(""String_Node_Str"",clientId);
    existing.abort();
    this.connectionDescriptors.removeConnection(existing);
    this.connectionDescriptors.addConnection(descriptor);
  }
  initializeKeepAliveTimeout(channel,msg,clientId);
  storeWillMessage(msg,clientId);
  if (!cleanSession && reauthorizeSubscriptionsOnConnect) {
    reauthorizeOnExistingSubscriptions(clientId,username);
  }
  if (!sendAck(descriptor,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  m_interceptor.notifyClientConnected(msg);
  if (!descriptor.assignState(SENDACK,SESSION_CREATED)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final ClientSession clientSession=this.sessionsRepository.createOrLoadClientSession(clientId,cleanSession);
  if (!republish(descriptor,msg,clientSession)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  int flushIntervalMs=500;
  setupAutoFlusher(channel,flushIntervalMs);
  final boolean success=descriptor.assignState(MESSAGES_REPUBLISHED,ESTABLISHED);
  if (!success) {
    channel.close().addListener(CLOSE_ON_FAILURE);
  }
  LOG.info(""String_Node_Str"",clientId,username);
}"
27314,"/** 
 * @param subscriptions the subscription store where are stored all the existing clients subscriptions.
 * @param storageService the persistent store to use for save/load of messages for QoS1 and QoS2 handling.
 * @param sessionsStore the clients sessions store, used to persist subscriptions.
 * @param authenticator the authenticator used in connect messages.
 * @param allowAnonymous true connection to clients without credentials.
 * @param allowZeroByteClientId true to allow clients connect without a clientid
 * @param authorizator used to apply ACL policies to publishes and subscriptions.
 * @param interceptor to notify events to an intercept handler
 */
void init(IConnectionsManager connectionDescriptors,ISubscriptionsDirectory subscriptions,IMessagesStore storageService,ISessionsStore sessionsStore,IAuthenticator authenticator,boolean allowAnonymous,boolean allowZeroByteClientId,IAuthorizator authorizator,BrokerInterceptor interceptor,SessionsRepository sessionsRepository){
  LOG.debug(""String_Node_Str"");
  this.connectionDescriptors=connectionDescriptors;
  this.subscriptionInCourse=new ConcurrentHashMap<>();
  this.m_interceptor=interceptor;
  this.subscriptions=subscriptions;
  this.allowAnonymous=allowAnonymous;
  this.allowZeroByteClientId=allowZeroByteClientId;
  m_authorizator=authorizator;
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",subscriptions.dumpTree());
  }
  m_authenticator=authenticator;
  m_messagesStore=storageService;
  m_sessionsStore=sessionsStore;
  this.sessionsRepository=sessionsRepository;
  LOG.info(""String_Node_Str"");
  final PersistentQueueMessageSender messageSender=new PersistentQueueMessageSender(this.connectionDescriptors);
  this.messagesPublisher=new MessagesPublisher(connectionDescriptors,messageSender,subscriptions,this.sessionsRepository);
  LOG.debug(""String_Node_Str"");
  this.qos0PublishHandler=new Qos0PublishHandler(m_authorizator,m_messagesStore,m_interceptor,this.messagesPublisher);
  this.qos1PublishHandler=new Qos1PublishHandler(m_authorizator,m_messagesStore,m_interceptor,this.connectionDescriptors,this.messagesPublisher);
  this.qos2PublishHandler=new Qos2PublishHandler(m_authorizator,subscriptions,m_messagesStore,m_interceptor,this.connectionDescriptors,this.messagesPublisher,this.sessionsRepository);
  LOG.debug(""String_Node_Str"");
  this.internalRepublisher=new InternalRepublisher(messageSender);
}","/** 
 * @param subscriptions the subscription store where are stored all the existing clients subscriptions.
 * @param storageService the persistent store to use for save/load of messages for QoS1 and QoS2 handling.
 * @param sessionsStore the clients sessions store, used to persist subscriptions.
 * @param authenticator the authenticator used in connect messages.
 * @param allowAnonymous true connection to clients without credentials.
 * @param allowZeroByteClientId true to allow clients connect without a clientid
 * @param authorizator used to apply ACL policies to publishes and subscriptions.
 * @param interceptor to notify events to an intercept handler
 */
void init(IConnectionsManager connectionDescriptors,ISubscriptionsDirectory subscriptions,IMessagesStore storageService,ISessionsStore sessionsStore,IAuthenticator authenticator,boolean allowAnonymous,boolean allowZeroByteClientId,IAuthorizator authorizator,BrokerInterceptor interceptor,SessionsRepository sessionsRepository,boolean reauthorizeSubscriptionsOnConnect){
  LOG.debug(""String_Node_Str"");
  this.connectionDescriptors=connectionDescriptors;
  this.subscriptionInCourse=new ConcurrentHashMap<>();
  this.m_interceptor=interceptor;
  this.subscriptions=subscriptions;
  this.allowAnonymous=allowAnonymous;
  this.reauthorizeSubscriptionsOnConnect=reauthorizeSubscriptionsOnConnect;
  this.allowZeroByteClientId=allowZeroByteClientId;
  m_authorizator=authorizator;
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",subscriptions.dumpTree());
  }
  m_authenticator=authenticator;
  m_messagesStore=storageService;
  m_sessionsStore=sessionsStore;
  this.sessionsRepository=sessionsRepository;
  LOG.info(""String_Node_Str"");
  final PersistentQueueMessageSender messageSender=new PersistentQueueMessageSender(this.connectionDescriptors);
  this.messagesPublisher=new MessagesPublisher(connectionDescriptors,messageSender,subscriptions,this.sessionsRepository);
  LOG.debug(""String_Node_Str"");
  this.qos0PublishHandler=new Qos0PublishHandler(m_authorizator,m_messagesStore,m_interceptor,this.messagesPublisher);
  this.qos1PublishHandler=new Qos1PublishHandler(m_authorizator,m_messagesStore,m_interceptor,this.connectionDescriptors,this.messagesPublisher);
  this.qos2PublishHandler=new Qos2PublishHandler(m_authorizator,subscriptions,m_messagesStore,m_interceptor,this.connectionDescriptors,this.messagesPublisher,this.sessionsRepository);
  LOG.debug(""String_Node_Str"");
  this.internalRepublisher=new InternalRepublisher(messageSender);
}"
27315,"private boolean removeSubscriptions(ConnectionDescriptor descriptor,String clientID){
  final boolean success=descriptor.assignState(ESTABLISHED,SUBSCRIPTIONS_REMOVED);
  if (!success) {
    return false;
  }
  if (descriptor.cleanSession) {
    LOG.trace(""String_Node_Str"",descriptor.clientID);
    final ClientSession session=this.sessionsRepository.sessionForClient(clientID);
    session.wipeSubscriptions();
    LOG.trace(""String_Node_Str"",descriptor.clientID);
  }
  return true;
}","private boolean removeSubscriptions(ConnectionDescriptor descriptor,String clientID){
  final boolean success=descriptor.assignState(ESTABLISHED,SUBSCRIPTIONS_REMOVED);
  if (!success) {
    return false;
  }
  if (descriptor.cleanSession) {
    LOG.trace(""String_Node_Str"",descriptor.clientID);
    final ClientSession session=this.sessionsRepository.sessionForClient(clientID);
    session.wipeSubscriptions();
    for (    Subscription existingSub : session.getSubscriptions()) {
      this.subscriptions.removeSubscription(existingSub.getTopicFilter(),clientID);
    }
    LOG.trace(""String_Node_Str"",descriptor.clientID);
  }
  return true;
}"
27316,"/** 
 * Initialize the processing part of the broker.
 * @param props the properties carrier where some props like port end host could be loaded. For the full list check of configurable properties check moquette.conf file.
 * @param embeddedObservers a list of callbacks to be notified of certain events inside the broker. Could be empty list of null.
 * @param authenticator an implementation of the authenticator to be used, if null load that specified in config and fallback on the default one (permit all).
 * @param authorizator an implementation of the authorizator to be used, if null load that specified in config and fallback on the default one (permit all).
 * @param server the server to init.
 * @return the processor created for the broker.
 */
public ProtocolProcessor init(IConfig props,List<? extends InterceptHandler> embeddedObservers,IAuthenticator authenticator,IAuthorizator authorizator,Server server){
  IMessagesStore messagesStore;
  LOG.info(""String_Node_Str"");
  String storageClassName=props.getProperty(BrokerConstants.STORAGE_CLASS_NAME,INMEMDB_STORE_CLASS);
  if (storageClassName == null || storageClassName.isEmpty()) {
    LOG.error(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final IStore store=instantiateConfiguredStore(storageClassName,props,server.getScheduler());
  if (store == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  store.initStore();
  messagesStore=store.messagesStore();
  m_sessionsStore=store.sessionsStore();
  SessionsRepository sessionsRepository=new SessionsRepository(this.m_sessionsStore,server.getScheduler());
  sessionsRepository.init();
  this.subscriptionsStore=m_sessionsStore.subscriptionStore();
  storeShutdown=new Runnable(){
    @Override public void run(){
      store.close();
    }
  }
;
  LOG.info(""String_Node_Str"");
  List<InterceptHandler> observers=new ArrayList<>(embeddedObservers);
  String interceptorClassName=props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);
  if (interceptorClassName != null && !interceptorClassName.isEmpty()) {
    InterceptHandler handler=loadClass(interceptorClassName,InterceptHandler.class,Server.class,server);
    if (handler != null) {
      observers.add(handler);
    }
  }
  BrokerInterceptor interceptor=new BrokerInterceptor(props,observers);
  LOG.info(""String_Node_Str"");
  ISubscriptionsDirectory subscriptions=new CTrieSubscriptionDirectory();
  subscriptions.init(sessionsRepository);
  LOG.info(""String_Node_Str"");
  String authenticatorClassName=props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  if (authenticator == null && !authenticatorClassName.isEmpty()) {
    authenticator=loadClass(authenticatorClassName,IAuthenticator.class,IConfig.class,props);
  }
  IResourceLoader resourceLoader=props.getResourceLoader();
  if (authenticator == null) {
    String passwdPath=props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (passwdPath.isEmpty()) {
      authenticator=new AcceptAllAuthenticator();
    }
 else {
      authenticator=new ResourceAuthenticator(resourceLoader,passwdPath);
    }
    LOG.info(""String_Node_Str"",authenticator.getClass().getName());
  }
  LOG.info(""String_Node_Str"");
  String authorizatorClassName=props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
  if (authorizator == null && !authorizatorClassName.isEmpty()) {
    authorizator=loadClass(authorizatorClassName,IAuthorizator.class,IConfig.class,props);
  }
  if (authorizator == null) {
    String aclFilePath=props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (aclFilePath != null && !aclFilePath.isEmpty()) {
      authorizator=new DenyAllAuthorizator();
      try {
        LOG.info(""String_Node_Str"",aclFilePath);
        authorizator=ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));
      }
 catch (      ParseException pex) {
        LOG.error(""String_Node_Str"" + aclFilePath,pex);
      }
    }
 else {
      authorizator=new PermitAllAuthorizator();
    }
    LOG.info(""String_Node_Str"",authorizator.getClass().getName());
  }
  LOG.info(""String_Node_Str"");
  connectionDescriptors=new ConnectionDescriptorStore();
  LOG.info(""String_Node_Str"");
  boolean allowAnonymous=Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,""String_Node_Str""));
  boolean allowZeroByteClientId=Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME,""String_Node_Str""));
  m_processor.init(connectionDescriptors,subscriptions,messagesStore,m_sessionsStore,authenticator,allowAnonymous,allowZeroByteClientId,authorizator,interceptor,sessionsRepository);
  return m_processor;
}","/** 
 * Initialize the processing part of the broker.
 * @param props the properties carrier where some props like port end host could be loaded. For the full list check of configurable properties check moquette.conf file.
 * @param embeddedObservers a list of callbacks to be notified of certain events inside the broker. Could be empty list of null.
 * @param authenticator an implementation of the authenticator to be used, if null load that specified in config and fallback on the default one (permit all).
 * @param authorizator an implementation of the authorizator to be used, if null load that specified in config and fallback on the default one (permit all).
 * @param server the server to init.
 * @return the processor created for the broker.
 */
public ProtocolProcessor init(IConfig props,List<? extends InterceptHandler> embeddedObservers,IAuthenticator authenticator,IAuthorizator authorizator,Server server){
  IMessagesStore messagesStore;
  LOG.info(""String_Node_Str"");
  String storageClassName=props.getProperty(BrokerConstants.STORAGE_CLASS_NAME,INMEMDB_STORE_CLASS);
  if (storageClassName == null || storageClassName.isEmpty()) {
    LOG.error(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final IStore store=instantiateConfiguredStore(storageClassName,props,server.getScheduler());
  if (store == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  store.initStore();
  messagesStore=store.messagesStore();
  m_sessionsStore=store.sessionsStore();
  SessionsRepository sessionsRepository=new SessionsRepository(this.m_sessionsStore,server.getScheduler());
  sessionsRepository.init();
  this.subscriptionsStore=m_sessionsStore.subscriptionStore();
  storeShutdown=new Runnable(){
    @Override public void run(){
      store.close();
    }
  }
;
  LOG.info(""String_Node_Str"");
  List<InterceptHandler> observers=new ArrayList<>(embeddedObservers);
  String interceptorClassName=props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);
  if (interceptorClassName != null && !interceptorClassName.isEmpty()) {
    InterceptHandler handler=loadClass(interceptorClassName,InterceptHandler.class,Server.class,server);
    if (handler != null) {
      observers.add(handler);
    }
  }
  BrokerInterceptor interceptor=new BrokerInterceptor(props,observers);
  LOG.info(""String_Node_Str"");
  ISubscriptionsDirectory subscriptions=new CTrieSubscriptionDirectory();
  subscriptions.init(sessionsRepository);
  LOG.info(""String_Node_Str"");
  String authenticatorClassName=props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  if (authenticator == null && !authenticatorClassName.isEmpty()) {
    authenticator=loadClass(authenticatorClassName,IAuthenticator.class,IConfig.class,props);
  }
  IResourceLoader resourceLoader=props.getResourceLoader();
  if (authenticator == null) {
    String passwdPath=props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (passwdPath.isEmpty()) {
      authenticator=new AcceptAllAuthenticator();
    }
 else {
      authenticator=new ResourceAuthenticator(resourceLoader,passwdPath);
    }
    LOG.info(""String_Node_Str"",authenticator.getClass().getName());
  }
  LOG.info(""String_Node_Str"");
  String authorizatorClassName=props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
  if (authorizator == null && !authorizatorClassName.isEmpty()) {
    authorizator=loadClass(authorizatorClassName,IAuthorizator.class,IConfig.class,props);
  }
  if (authorizator == null) {
    String aclFilePath=props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (aclFilePath != null && !aclFilePath.isEmpty()) {
      authorizator=new DenyAllAuthorizator();
      try {
        LOG.info(""String_Node_Str"",aclFilePath);
        authorizator=ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));
      }
 catch (      ParseException pex) {
        LOG.error(""String_Node_Str"" + aclFilePath,pex);
      }
    }
 else {
      authorizator=new PermitAllAuthorizator();
    }
    LOG.info(""String_Node_Str"",authorizator.getClass().getName());
  }
  LOG.info(""String_Node_Str"");
  connectionDescriptors=new ConnectionDescriptorStore();
  LOG.info(""String_Node_Str"");
  boolean allowAnonymous=props.boolProp(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,true);
  boolean allowZeroByteClientId=props.boolProp(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME,false);
  boolean reauthorizeSubscriptionsOnConnect=props.boolProp(BrokerConstants.REAUTHORIZE_SUBSCRIPTIONS_ON_CONNECT,false);
  m_processor.init(connectionDescriptors,subscriptions,messagesStore,m_sessionsStore,authenticator,allowAnonymous,allowZeroByteClientId,authorizator,interceptor,sessionsRepository,reauthorizeSubscriptionsOnConnect);
  return m_processor;
}"
27317,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  String clientID=NettyUtils.clientID(ctx.channel());
  if (clientID != null && !clientID.isEmpty()) {
    LOG.info(""String_Node_Str"",clientID);
    m_processor.processConnectionLost(clientID,ctx.channel());
  }
  ctx.close().addListener(CLOSE_ON_FAILURE);
}","@Override public void channelInactive(ChannelHandlerContext ctx){
  String clientID=NettyUtils.clientID(ctx.channel());
  if (clientID != null && !clientID.isEmpty()) {
    LOG.info(""String_Node_Str"",clientID);
    m_processor.processConnectionLost(clientID,ctx.channel());
  }
  ctx.close().addListener(CLOSE_ON_FAILURE);
}"
27318,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  LOG.error(""String_Node_Str"" + ""String_Node_Str"",NettyUtils.clientID(ctx.channel()),cause.getCause(),cause.getMessage());
  ctx.close().addListener(CLOSE_ON_FAILURE);
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){
  LOG.error(""String_Node_Str"",NettyUtils.clientID(ctx.channel()),cause);
  ctx.close().addListener(CLOSE_ON_FAILURE);
}"
27319,"@Override public void channelRead(ChannelHandlerContext ctx,Object message){
  MqttMessage msg=(MqttMessage)message;
  MqttMessageType messageType=msg.fixedHeader().messageType();
  LOG.debug(""String_Node_Str"",messageType);
  try {
switch (messageType) {
case CONNECT:
      m_processor.processConnect(ctx.channel(),(MqttConnectMessage)msg);
    break;
case SUBSCRIBE:
  m_processor.processSubscribe(ctx.channel(),(MqttSubscribeMessage)msg);
break;
case UNSUBSCRIBE:
m_processor.processUnsubscribe(ctx.channel(),(MqttUnsubscribeMessage)msg);
break;
case PUBLISH:
m_processor.processPublish(ctx.channel(),(MqttPublishMessage)msg);
break;
case PUBREC:
m_processor.processPubRec(ctx.channel(),msg);
break;
case PUBCOMP:
m_processor.processPubComp(ctx.channel(),msg);
break;
case PUBREL:
m_processor.processPubRel(ctx.channel(),msg);
break;
case DISCONNECT:
m_processor.processDisconnect(ctx.channel());
break;
case PUBACK:
m_processor.processPubAck(ctx.channel(),(MqttPubAckMessage)msg);
break;
case PINGREQ:
MqttFixedHeader pingHeader=new MqttFixedHeader(MqttMessageType.PINGRESP,false,AT_MOST_ONCE,false,0);
MqttMessage pingResp=new MqttMessage(pingHeader);
ctx.writeAndFlush(pingResp).addListener(CLOSE_ON_FAILURE);
break;
default :
LOG.error(""String_Node_Str"",messageType);
break;
}
}
 catch (Throwable ex) {
LOG.error(""String_Node_Str"",ex.getCause(),ex);
ctx.fireExceptionCaught(ex);
ctx.close().addListener(CLOSE_ON_FAILURE);
}
 finally {
ReferenceCountUtil.release(msg);
}
}","@Override public void channelRead(ChannelHandlerContext ctx,Object message){
  MqttMessage msg=(MqttMessage)message;
  MqttMessageType messageType=msg.fixedHeader().messageType();
  LOG.debug(""String_Node_Str"",messageType);
  try {
switch (messageType) {
case CONNECT:
      m_processor.processConnect(ctx.channel(),(MqttConnectMessage)msg);
    break;
case SUBSCRIBE:
  m_processor.processSubscribe(ctx.channel(),(MqttSubscribeMessage)msg);
break;
case UNSUBSCRIBE:
m_processor.processUnsubscribe(ctx.channel(),(MqttUnsubscribeMessage)msg);
break;
case PUBLISH:
m_processor.processPublish(ctx.channel(),(MqttPublishMessage)msg);
break;
case PUBREC:
m_processor.processPubRec(ctx.channel(),msg);
break;
case PUBCOMP:
m_processor.processPubComp(ctx.channel(),msg);
break;
case PUBREL:
m_processor.processPubRel(ctx.channel(),msg);
break;
case DISCONNECT:
m_processor.processDisconnect(ctx.channel());
break;
case PUBACK:
m_processor.processPubAck(ctx.channel(),(MqttPubAckMessage)msg);
break;
case PINGREQ:
MqttFixedHeader pingHeader=new MqttFixedHeader(MqttMessageType.PINGRESP,false,AT_MOST_ONCE,false,0);
MqttMessage pingResp=new MqttMessage(pingHeader);
ctx.writeAndFlush(pingResp).addListener(CLOSE_ON_FAILURE);
break;
default :
LOG.error(""String_Node_Str"",messageType);
break;
}
}
 catch (Throwable ex) {
ctx.fireExceptionCaught(ex);
}
 finally {
ReferenceCountUtil.release(msg);
}
}"
27320,"@Override public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
  if (ctx.channel().isWritable()) {
    m_processor.notifyChannelWritable(ctx.channel());
  }
  ctx.fireChannelWritabilityChanged();
}","@Override public void channelWritabilityChanged(ChannelHandlerContext ctx){
  if (ctx.channel().isWritable()) {
    m_processor.notifyChannelWritable(ctx.channel());
  }
  ctx.fireChannelWritabilityChanged();
}"
27321,"/** 
 * Remove the clientID from topic subscription, if not previously subscribed, doesn't reply any error.
 * @param channel the channel of the incoming message.
 * @param msg the decoded unsubscribe message.
 */
public void processUnsubscribe(Channel channel,MqttUnsubscribeMessage msg){
  List<String> topics=msg.payload().topics();
  String clientID=NettyUtils.clientID(channel);
  LOG.debug(""String_Node_Str"",clientID,topics);
  ClientSession clientSession=this.sessionsRepository.sessionForClient(clientID);
  for (  String t : topics) {
    Topic topic=new Topic(t);
    boolean validTopic=topic.isValid();
    if (!validTopic) {
      channel.close().addListener(CLOSE_ON_FAILURE);
      LOG.error(""String_Node_Str"",clientID,topics,topic);
      return;
    }
    LOG.trace(""String_Node_Str"",clientID,topic);
    subscriptions.removeSubscription(topic,clientID);
    clientSession.unsubscribeFrom(topic);
    String username=NettyUtils.userName(channel);
    m_interceptor.notifyTopicUnsubscribed(topic.toString(),clientID,username);
  }
  int messageID=msg.variableHeader().messageId();
  MqttFixedHeader fixedHeader=new MqttFixedHeader(MqttMessageType.UNSUBACK,false,AT_LEAST_ONCE,false,0);
  MqttUnsubAckMessage ackMessage=new MqttUnsubAckMessage(fixedHeader,from(messageID));
  LOG.debug(""String_Node_Str"",clientID,topics,messageID);
  channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);
  LOG.info(""String_Node_Str"",clientID,topics);
}","/** 
 * Remove the clientID from topic subscription, if not previously subscribed, doesn't reply any error.
 * @param channel the channel of the incoming message.
 * @param msg the decoded unsubscribe message.
 */
public void processUnsubscribe(Channel channel,MqttUnsubscribeMessage msg){
  List<String> topics=msg.payload().topics();
  String clientID=NettyUtils.clientID(channel);
  LOG.debug(""String_Node_Str"",clientID,topics);
  ClientSession clientSession=this.sessionsRepository.sessionForClient(clientID);
  for (  String t : topics) {
    Topic topic=new Topic(t);
    boolean validTopic=topic.isValid();
    if (!validTopic) {
      channel.close().addListener(CLOSE_ON_FAILURE);
      LOG.error(""String_Node_Str"",clientID,topics,topic);
      return;
    }
    LOG.trace(""String_Node_Str"",clientID,topic);
    subscriptions.removeSubscription(topic,clientID);
    clientSession.unsubscribeFrom(topic);
    String username=NettyUtils.userName(channel);
    m_interceptor.notifyTopicUnsubscribed(topic.toString(),clientID,username);
  }
  int messageID=msg.variableHeader().messageId();
  MqttFixedHeader fixedHeader=new MqttFixedHeader(MqttMessageType.UNSUBACK,false,AT_MOST_ONCE,false,0);
  MqttUnsubAckMessage ackMessage=new MqttUnsubAckMessage(fixedHeader,from(messageID));
  LOG.debug(""String_Node_Str"",clientID,topics,messageID);
  channel.writeAndFlush(ackMessage).addListener(FIRE_EXCEPTION_ON_FAILURE);
  LOG.info(""String_Node_Str"",clientID,topics);
}"
27322,"public void processConnect(Channel channel,MqttConnectMessage msg){
  MqttConnectPayload payload=msg.payload();
  String clientId=payload.clientIdentifier();
  LOG.info(""String_Node_Str"",clientId,payload.userName());
  if (msg.variableHeader().version() != MqttVersion.MQTT_3_1.protocolLevel() && msg.variableHeader().version() != MqttVersion.MQTT_3_1_1.protocolLevel()) {
    MqttConnAckMessage badProto=connAck(CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION);
    LOG.error(""String_Node_Str"",clientId);
    channel.writeAndFlush(badProto).addListener(FIRE_EXCEPTION_ON_FAILURE);
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final boolean cleanSession=msg.variableHeader().isCleanSession();
  if (clientId == null || clientId.length() == 0) {
    if (!cleanSession || !this.allowZeroByteClientId) {
      MqttConnAckMessage badId=connAck(CONNECTION_REFUSED_IDENTIFIER_REJECTED);
      channel.writeAndFlush(badId).addListener(FIRE_EXCEPTION_ON_FAILURE);
      channel.close().addListener(CLOSE_ON_FAILURE);
      LOG.error(""String_Node_Str"",payload.userName());
      return;
    }
    clientId=UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str"");
    LOG.info(""String_Node_Str"",clientId,payload.userName());
  }
  if (!login(channel,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  ConnectionDescriptor descriptor=new ConnectionDescriptor(clientId,channel,cleanSession);
  ConnectionDescriptor existing=this.connectionDescriptors.addConnection(descriptor);
  if (existing != null) {
    LOG.info(""String_Node_Str"",clientId);
    existing.abort();
    this.connectionDescriptors.removeConnection(existing);
    this.connectionDescriptors.addConnection(descriptor);
  }
  initializeKeepAliveTimeout(channel,msg,clientId);
  storeWillMessage(msg,clientId);
  if (!sendAck(descriptor,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  m_interceptor.notifyClientConnected(msg);
  if (!descriptor.assignState(SENDACK,SESSION_CREATED)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final ClientSession clientSession=this.sessionsRepository.createOrLoadClientSession(clientId,cleanSession);
  if (!republish(descriptor,msg,clientSession)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final boolean success=descriptor.assignState(MESSAGES_REPUBLISHED,ESTABLISHED);
  if (!success) {
    channel.close().addListener(CLOSE_ON_FAILURE);
  }
  LOG.info(""String_Node_Str"",clientId,payload.userName());
}","public void processConnect(Channel channel,MqttConnectMessage msg){
  MqttConnectPayload payload=msg.payload();
  String clientId=payload.clientIdentifier();
  LOG.info(""String_Node_Str"",clientId,payload.userName());
  if (msg.variableHeader().version() != MqttVersion.MQTT_3_1.protocolLevel() && msg.variableHeader().version() != MqttVersion.MQTT_3_1_1.protocolLevel()) {
    MqttConnAckMessage badProto=connAck(CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION);
    LOG.error(""String_Node_Str"",clientId);
    channel.writeAndFlush(badProto).addListener(FIRE_EXCEPTION_ON_FAILURE);
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final boolean cleanSession=msg.variableHeader().isCleanSession();
  if (clientId == null || clientId.length() == 0) {
    if (!cleanSession || !this.allowZeroByteClientId) {
      MqttConnAckMessage badId=connAck(CONNECTION_REFUSED_IDENTIFIER_REJECTED);
      channel.writeAndFlush(badId).addListener(FIRE_EXCEPTION_ON_FAILURE);
      channel.close().addListener(CLOSE_ON_FAILURE);
      LOG.error(""String_Node_Str"",payload.userName());
      return;
    }
    clientId=UUID.randomUUID().toString().replace(""String_Node_Str"",""String_Node_Str"");
    LOG.info(""String_Node_Str"",clientId,payload.userName());
  }
  if (!login(channel,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  ConnectionDescriptor descriptor=new ConnectionDescriptor(clientId,channel,cleanSession);
  final ConnectionDescriptor existing=this.connectionDescriptors.addConnection(descriptor);
  if (existing != null) {
    LOG.info(""String_Node_Str"",clientId);
    existing.abort();
    this.connectionDescriptors.removeConnection(existing);
    this.connectionDescriptors.addConnection(descriptor);
  }
  initializeKeepAliveTimeout(channel,msg,clientId);
  storeWillMessage(msg,clientId);
  if (!sendAck(descriptor,msg,clientId)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  m_interceptor.notifyClientConnected(msg);
  if (!descriptor.assignState(SENDACK,SESSION_CREATED)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final ClientSession clientSession=this.sessionsRepository.createOrLoadClientSession(clientId,cleanSession);
  if (!republish(descriptor,msg,clientSession)) {
    channel.close().addListener(CLOSE_ON_FAILURE);
    return;
  }
  final boolean success=descriptor.assignState(MESSAGES_REPUBLISHED,ESTABLISHED);
  if (!success) {
    channel.close().addListener(CLOSE_ON_FAILURE);
  }
  LOG.info(""String_Node_Str"",clientId,payload.userName());
}"
27323,"private boolean removeSubscriptions(ConnectionDescriptor descriptor,String clientID){
  final boolean success=descriptor.assignState(ESTABLISHED,SUBSCRIPTIONS_REMOVED);
  if (!success) {
    return false;
  }
  if (descriptor.cleanSession) {
    LOG.info(""String_Node_Str"",descriptor.clientID);
    subscriptionStore.wipeSubscriptions(clientID);
    LOG.info(""String_Node_Str"",descriptor.clientID);
  }
  return true;
}","private boolean removeSubscriptions(ConnectionDescriptor descriptor,String clientID){
  final boolean success=descriptor.assignState(ESTABLISHED,SUBSCRIPTIONS_REMOVED);
  if (!success) {
    return false;
  }
  if (descriptor.cleanSession) {
    LOG.info(""String_Node_Str"",descriptor.clientID);
    final ClientSession session=this.sessionsRepository.sessionForClient(clientID);
    session.wipeSubscriptions();
    LOG.info(""String_Node_Str"",descriptor.clientID);
  }
  return true;
}"
27324,"@Override public void onPublish(InterceptPublishMessage msg){
  ByteBuf payload=msg.getPayload();
  byte[] payloadContent=readBytesAndRewind(payload);
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.getTopicName(),new String(payloadContent));
  ITopic<HazelcastMsg> topic=hz.getTopic(""String_Node_Str"");
  HazelcastMsg hazelcastMsg=new HazelcastMsg(msg);
  topic.publish(hazelcastMsg);
}","@Override public void onPublish(InterceptPublishMessage msg){
  ByteBuf payload=msg.getPayload();
  byte[] payloadContent=readBytesAndRewind(payload);
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.getTopicName(),new String(payloadContent,UTF_8));
  ITopic<HazelcastMsg> topic=hz.getTopic(""String_Node_Str"");
  HazelcastMsg hazelcastMsg=new HazelcastMsg(msg);
  topic.publish(hazelcastMsg);
}"
27325,"public byte[] getPassword(){
  return msg.payload().password().getBytes();
}","public byte[] getPassword(){
  return msg.payload().password().getBytes(StandardCharsets.UTF_8);
}"
27326,"public byte[] getWillMessage(){
  return msg.payload().willMessage().getBytes();
}","public byte[] getWillMessage(){
  return msg.payload().willMessage().getBytes(StandardCharsets.UTF_8);
}"
27327,"public void writeAndFlush(Object payload){
  this.channel.writeAndFlush(payload);
}","public void writeAndFlush(Object payload){
  this.channel.writeAndFlush(payload).addListener(FIRE_EXCEPTION_ON_FAILURE);
}"
27328,"public void abort(){
  LOG.info(""String_Node_Str"",clientID);
  this.channel.close();
}","public void abort(){
  LOG.info(""String_Node_Str"",clientID);
  this.channel.close().addListener(CLOSE_ON_FAILURE);
}"
27329,"public boolean close(){
  LOG.info(""String_Node_Str"",clientID);
  final boolean success=assignState(ConnectionState.INTERCEPTORS_NOTIFIED,ConnectionState.DISCONNECTED);
  if (!success) {
    return false;
  }
  this.channel.close();
  return true;
}","public boolean close(){
  LOG.info(""String_Node_Str"",clientID);
  final boolean success=assignState(ConnectionState.INTERCEPTORS_NOTIFIED,ConnectionState.DISCONNECTED);
  if (!success) {
    return false;
  }
  this.channel.close().addListener(CLOSE_ON_FAILURE);
  return true;
}"
27330,"@Override public Reader loadResource(String relativePath){
  LOG.info(""String_Node_Str"",relativePath);
  InputStream is=this.classLoader.getResourceAsStream(relativePath);
  return is != null ? new InputStreamReader(is) : null;
}","@Override public Reader loadResource(String relativePath){
  LOG.info(""String_Node_Str"",relativePath);
  InputStream is=this.classLoader.getResourceAsStream(relativePath);
  return is != null ? new InputStreamReader(is,StandardCharsets.UTF_8) : null;
}"
27331,"public Reader loadResource(File f){
  LOG.info(""String_Node_Str"",f.getAbsolutePath());
  if (f.isDirectory()) {
    LOG.error(""String_Node_Str"",f.getAbsolutePath());
    throw new ResourceIsDirectoryException(""String_Node_Str"" + f + ""String_Node_Str"");
  }
  try {
    return new FileReader(f);
  }
 catch (  FileNotFoundException e) {
    LOG.error(""String_Node_Str"",f.getAbsolutePath());
    return null;
  }
}","public Reader loadResource(File f){
  LOG.info(""String_Node_Str"",f.getAbsolutePath());
  if (f.isDirectory()) {
    LOG.error(""String_Node_Str"",f.getAbsolutePath());
    throw new ResourceIsDirectoryException(""String_Node_Str"" + f + ""String_Node_Str"");
  }
  try {
    return Files.newBufferedReader(f.toPath(),UTF_8);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",f.getAbsolutePath());
    return null;
  }
}"
27332,"@Override public void userEventTriggered(ChannelHandlerContext ctx,Object evt) throws Exception {
  if (evt instanceof IdleStateEvent) {
    IdleState e=((IdleStateEvent)evt).state();
    if (e == IdleState.READER_IDLE) {
      LOG.info(""String_Node_Str"",NettyUtils.clientID(ctx.channel()));
      ctx.fireChannelInactive();
      ctx.close();
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",NettyUtils.clientID(ctx.channel()),evt.getClass().getName());
    }
    super.userEventTriggered(ctx,evt);
  }
}","@Override public void userEventTriggered(ChannelHandlerContext ctx,Object evt) throws Exception {
  if (evt instanceof IdleStateEvent) {
    IdleState e=((IdleStateEvent)evt).state();
    if (e == IdleState.READER_IDLE) {
      LOG.info(""String_Node_Str"",NettyUtils.clientID(ctx.channel()));
      ctx.fireChannelInactive();
      ctx.close().addListener(CLOSE_ON_FAILURE);
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",NettyUtils.clientID(ctx.channel()),evt.getClass().getName());
    }
    super.userEventTriggered(ctx,evt);
  }
}"
27333,"private void initFactory(String host,int port,String protocol,final PipelineInitializer pipeliner){
  LOG.info(""String_Node_Str"",protocol);
  ServerBootstrap b=new ServerBootstrap();
  b.group(m_bossGroup,m_workerGroup).channel(channelClass).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ChannelPipeline pipeline=ch.pipeline();
      try {
        pipeliner.init(pipeline);
      }
 catch (      Throwable th) {
        LOG.error(""String_Node_Str"",th);
        throw th;
      }
    }
  }
).option(ChannelOption.SO_BACKLOG,nettySoBacklog).option(ChannelOption.SO_REUSEADDR,nettySoReuseaddr).option(ChannelOption.TCP_NODELAY,nettyTcpNodelay).childOption(ChannelOption.SO_KEEPALIVE,nettySoKeepalive);
  try {
    LOG.info(""String_Node_Str"",host,port);
    ChannelFuture f=b.bind(host,port);
    LOG.info(""String_Node_Str"",host,port);
    f.sync();
  }
 catch (  InterruptedException ex) {
    LOG.error(""String_Node_Str"",protocol,ex);
  }
}","private void initFactory(String host,int port,String protocol,final PipelineInitializer pipeliner){
  LOG.info(""String_Node_Str"",protocol);
  ServerBootstrap b=new ServerBootstrap();
  b.group(m_bossGroup,m_workerGroup).channel(channelClass).childHandler(new ChannelInitializer<SocketChannel>(){
    @Override public void initChannel(    SocketChannel ch) throws Exception {
      ChannelPipeline pipeline=ch.pipeline();
      try {
        pipeliner.init(pipeline);
      }
 catch (      Throwable th) {
        LOG.error(""String_Node_Str"",th);
        throw th;
      }
    }
  }
).option(ChannelOption.SO_BACKLOG,nettySoBacklog).option(ChannelOption.SO_REUSEADDR,nettySoReuseaddr).option(ChannelOption.TCP_NODELAY,nettyTcpNodelay).childOption(ChannelOption.SO_KEEPALIVE,nettySoKeepalive);
  try {
    LOG.info(""String_Node_Str"",host,port);
    ChannelFuture f=b.bind(host,port);
    LOG.info(""String_Node_Str"",host,port);
    f.sync().addListener(FIRE_EXCEPTION_ON_FAILURE);
  }
 catch (  InterruptedException ex) {
    LOG.error(""String_Node_Str"",protocol,ex);
  }
}"
27334,"public void close(){
  LOG.info(""String_Node_Str"");
  if (m_workerGroup == null || m_bossGroup == null) {
    LOG.error(""String_Node_Str"");
    throw new IllegalStateException(""String_Node_Str"");
  }
  Future<?> workerWaiter=m_workerGroup.shutdownGracefully();
  Future<?> bossWaiter=m_bossGroup.shutdownGracefully();
  LOG.info(""String_Node_Str"");
  try {
    workerWaiter.await(10,TimeUnit.SECONDS);
    bossWaiter.await(10,TimeUnit.SECONDS);
  }
 catch (  InterruptedException iex) {
    LOG.warn(""String_Node_Str"");
  }
  if (!m_workerGroup.isTerminated()) {
    LOG.warn(""String_Node_Str"");
    m_workerGroup.shutdownGracefully(0L,0L,TimeUnit.MILLISECONDS);
  }
  if (!m_bossGroup.isTerminated()) {
    LOG.warn(""String_Node_Str"");
    m_bossGroup.shutdownGracefully(0L,0L,TimeUnit.MILLISECONDS);
  }
  LOG.info(""String_Node_Str"");
  MessageMetrics metrics=m_metricsCollector.computeMetrics();
  LOG.info(""String_Node_Str"",metrics.messagesRead(),metrics.messagesWrote());
  LOG.info(""String_Node_Str"");
  BytesMetrics bytesMetrics=m_bytesMetricsCollector.computeMetrics();
  LOG.info(""String_Node_Str"",bytesMetrics.readBytes(),bytesMetrics.wroteBytes());
}","@SuppressWarnings(""String_Node_Str"") @Override public void close(){
  LOG.info(""String_Node_Str"");
  if (m_workerGroup == null || m_bossGroup == null) {
    LOG.error(""String_Node_Str"");
    throw new IllegalStateException(""String_Node_Str"");
  }
  Future<?> workerWaiter=m_workerGroup.shutdownGracefully();
  Future<?> bossWaiter=m_bossGroup.shutdownGracefully();
  LOG.info(""String_Node_Str"");
  try {
    workerWaiter.await(10,TimeUnit.SECONDS);
    bossWaiter.await(10,TimeUnit.SECONDS);
  }
 catch (  InterruptedException iex) {
    LOG.warn(""String_Node_Str"");
  }
  if (!m_workerGroup.isTerminated()) {
    LOG.warn(""String_Node_Str"");
    m_workerGroup.shutdownGracefully(0L,0L,TimeUnit.MILLISECONDS);
  }
  if (!m_bossGroup.isTerminated()) {
    LOG.warn(""String_Node_Str"");
    m_bossGroup.shutdownGracefully(0L,0L,TimeUnit.MILLISECONDS);
  }
  LOG.info(""String_Node_Str"");
  MessageMetrics metrics=m_metricsCollector.computeMetrics();
  LOG.info(""String_Node_Str"",metrics.messagesRead(),metrics.messagesWrote());
  LOG.info(""String_Node_Str"");
  BytesMetrics bytesMetrics=m_bytesMetricsCollector.computeMetrics();
  LOG.info(""String_Node_Str"",bytesMetrics.readBytes(),bytesMetrics.wroteBytes());
}"
27335,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  String clientID=NettyUtils.clientID(ctx.channel());
  if (clientID != null && !clientID.isEmpty()) {
    LOG.info(""String_Node_Str"",clientID);
    m_processor.processConnectionLost(clientID,ctx.channel());
  }
  ctx.close();
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  String clientID=NettyUtils.clientID(ctx.channel());
  if (clientID != null && !clientID.isEmpty()) {
    LOG.info(""String_Node_Str"",clientID);
    m_processor.processConnectionLost(clientID,ctx.channel());
  }
  ctx.close().addListener(CLOSE_ON_FAILURE);
}"
27336,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  LOG.error(""String_Node_Str"" + ""String_Node_Str"",NettyUtils.clientID(ctx.channel()),cause.getCause(),cause.getMessage());
  ctx.close();
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) throws Exception {
  LOG.error(""String_Node_Str"" + ""String_Node_Str"",NettyUtils.clientID(ctx.channel()),cause.getCause(),cause.getMessage());
  ctx.close().addListener(CLOSE_ON_FAILURE);
}"
27337,"@Override public void channelRead(ChannelHandlerContext ctx,Object message){
  MqttMessage msg=(MqttMessage)message;
  MqttMessageType messageType=msg.fixedHeader().messageType();
  LOG.debug(""String_Node_Str"",messageType);
  try {
switch (messageType) {
case CONNECT:
      m_processor.processConnect(ctx.channel(),(MqttConnectMessage)msg);
    break;
case SUBSCRIBE:
  m_processor.processSubscribe(ctx.channel(),(MqttSubscribeMessage)msg);
break;
case UNSUBSCRIBE:
m_processor.processUnsubscribe(ctx.channel(),(MqttUnsubscribeMessage)msg);
break;
case PUBLISH:
m_processor.processPublish(ctx.channel(),(MqttPublishMessage)msg);
break;
case PUBREC:
m_processor.processPubRec(ctx.channel(),msg);
break;
case PUBCOMP:
m_processor.processPubComp(ctx.channel(),msg);
break;
case PUBREL:
m_processor.processPubRel(ctx.channel(),msg);
break;
case DISCONNECT:
m_processor.processDisconnect(ctx.channel());
break;
case PUBACK:
m_processor.processPubAck(ctx.channel(),(MqttPubAckMessage)msg);
break;
case PINGREQ:
MqttFixedHeader pingHeader=new MqttFixedHeader(MqttMessageType.PINGRESP,false,AT_MOST_ONCE,false,0);
MqttMessage pingResp=new MqttMessage(pingHeader);
ctx.writeAndFlush(pingResp);
break;
default :
LOG.error(""String_Node_Str"",messageType);
break;
}
}
 catch (Throwable ex) {
LOG.error(""String_Node_Str"" + ex.getCause(),ex);
ctx.fireExceptionCaught(ex);
ctx.close();
}
 finally {
ReferenceCountUtil.release(msg);
}
}","@Override public void channelRead(ChannelHandlerContext ctx,Object message){
  MqttMessage msg=(MqttMessage)message;
  MqttMessageType messageType=msg.fixedHeader().messageType();
  LOG.debug(""String_Node_Str"",messageType);
  try {
switch (messageType) {
case CONNECT:
      m_processor.processConnect(ctx.channel(),(MqttConnectMessage)msg);
    break;
case SUBSCRIBE:
  m_processor.processSubscribe(ctx.channel(),(MqttSubscribeMessage)msg);
break;
case UNSUBSCRIBE:
m_processor.processUnsubscribe(ctx.channel(),(MqttUnsubscribeMessage)msg);
break;
case PUBLISH:
m_processor.processPublish(ctx.channel(),(MqttPublishMessage)msg);
break;
case PUBREC:
m_processor.processPubRec(ctx.channel(),msg);
break;
case PUBCOMP:
m_processor.processPubComp(ctx.channel(),msg);
break;
case PUBREL:
m_processor.processPubRel(ctx.channel(),msg);
break;
case DISCONNECT:
m_processor.processDisconnect(ctx.channel());
break;
case PUBACK:
m_processor.processPubAck(ctx.channel(),(MqttPubAckMessage)msg);
break;
case PINGREQ:
MqttFixedHeader pingHeader=new MqttFixedHeader(MqttMessageType.PINGRESP,false,AT_MOST_ONCE,false,0);
MqttMessage pingResp=new MqttMessage(pingHeader);
ctx.writeAndFlush(pingResp).addListener(CLOSE_ON_FAILURE);
break;
default :
LOG.error(""String_Node_Str"",messageType);
break;
}
}
 catch (Throwable ex) {
LOG.error(""String_Node_Str"",ex.getCause(),ex);
ctx.fireExceptionCaught(ex);
ctx.close().addListener(CLOSE_ON_FAILURE);
}
 finally {
ReferenceCountUtil.release(msg);
}
}"
27338,"@Override public void write(ChannelHandlerContext ctx,Object msg,ChannelPromise promise) throws Exception {
  BytesMetrics metrics=ctx.channel().attr(ATTR_KEY_METRICS).get();
  metrics.incrementWrote(((ByteBuf)msg).writableBytes());
  ctx.write(msg,promise);
}","@Override public void write(ChannelHandlerContext ctx,Object msg,ChannelPromise promise) throws Exception {
  BytesMetrics metrics=ctx.channel().attr(ATTR_KEY_METRICS).get();
  metrics.incrementWrote(((ByteBuf)msg).writableBytes());
  ctx.write(msg,promise).addListener(CLOSE_ON_FAILURE);
}"
27339,"@Override public void write(ChannelHandlerContext ctx,Object msg,ChannelPromise promise) throws Exception {
  logMQTTMessage(ctx,msg,""String_Node_Str"");
  ctx.write(msg,promise);
}","@Override public void write(ChannelHandlerContext ctx,Object msg,ChannelPromise promise) throws Exception {
  logMQTTMessage(ctx,msg,""String_Node_Str"");
  ctx.write(msg,promise).addListener(CLOSE_ON_FAILURE);
}"
27340,"@Override public void write(ChannelHandlerContext ctx,Object msg,ChannelPromise promise) throws Exception {
  MessageMetrics metrics=ctx.channel().attr(ATTR_KEY_METRICS).get();
  metrics.incrementWrote(1);
  ctx.write(msg,promise);
}","@Override public void write(ChannelHandlerContext ctx,Object msg,ChannelPromise promise) throws Exception {
  MessageMetrics metrics=ctx.channel().attr(ATTR_KEY_METRICS).get();
  metrics.incrementWrote(1);
  ctx.write(msg,promise).addListener(CLOSE_ON_FAILURE);
}"
27341,"void assignDefaults(){
  setProperty(BrokerConstants.PORT_PROPERTY_NAME,Integer.toString(BrokerConstants.PORT));
  setProperty(BrokerConstants.HOST_PROPERTY_NAME,BrokerConstants.HOST);
  setProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,Boolean.TRUE.toString());
  setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
}","void assignDefaults(){
  setProperty(BrokerConstants.PORT_PROPERTY_NAME,Integer.toString(BrokerConstants.PORT));
  setProperty(BrokerConstants.HOST_PROPERTY_NAME,BrokerConstants.HOST);
  setProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,Boolean.TRUE.toString());
  setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,String.valueOf(BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE));
}"
27342,"@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MqttDecoder());
  pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
  pipeline.addLast(""String_Node_Str"",handler);
}","@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
  pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
  pipeline.addLast(""String_Node_Str"",handler);
}"
27343,"private void initializeWSSTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWSSTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27344,"private void initializePlainTCPTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String tcpPortProp=props.getProperty(PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(tcpPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(tcpPortProp);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      if (errorsCather.isPresent()) {
        pipeline.addLast(""String_Node_Str"",errorsCather.get());
      }
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      if (metrics.isPresent()) {
        pipeline.addLast(""String_Node_Str"",metrics.get());
      }
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializePlainTCPTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String tcpPortProp=props.getProperty(PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(tcpPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(tcpPortProp);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      if (errorsCather.isPresent()) {
        pipeline.addLast(""String_Node_Str"",errorsCather.get());
      }
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      if (metrics.isPresent()) {
        pipeline.addLast(""String_Node_Str"",metrics.get());
      }
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27345,"private void initializeSSLTCPTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeSSLTCPTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27346,"private void initializeWebSocketTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  String webSocketPortProp=props.getProperty(WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(new HttpServerCodec());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWebSocketTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  String webSocketPortProp=props.getProperty(WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(new HttpServerCodec());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27347,"@Override public void initialize(ProtocolProcessor processor,IConfig props,ISslContextCreator sslCtxCreator) throws IOException {
  LOG.info(""String_Node_Str"");
  nettySoBacklog=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME,""String_Node_Str""));
  nettySoReuseaddr=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME,""String_Node_Str""));
  nettyTcpNodelay=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME,""String_Node_Str""));
  nettySoKeepalive=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME,""String_Node_Str""));
  nettyChannelTimeoutSeconds=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME,""String_Node_Str""));
  boolean epoll=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME,""String_Node_Str""));
  if (epoll) {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new EpollEventLoopGroup();
    m_workerGroup=new EpollEventLoopGroup();
    channelClass=EpollServerSocketChannel.class;
  }
 else {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new NioEventLoopGroup();
    m_workerGroup=new NioEventLoopGroup();
    channelClass=NioServerSocketChannel.class;
  }
  final NettyMQTTHandler mqttHandler=new NettyMQTTHandler(processor);
  final boolean useFineMetrics=Boolean.parseBoolean(props.getProperty(METRICS_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useFineMetrics) {
    DropWizardMetricsHandler metricsHandler=new DropWizardMetricsHandler();
    metricsHandler.init(props);
    this.metrics=Optional.of(metricsHandler);
  }
 else {
    this.metrics=Optional.empty();
  }
  final boolean useBugSnag=Boolean.parseBoolean(props.getProperty(BUGSNAG_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useBugSnag) {
    BugSnagErrorsHandler bugSnagHandler=new BugSnagErrorsHandler();
    bugSnagHandler.init(props);
    this.errorsCather=Optional.of(bugSnagHandler);
  }
 else {
    this.errorsCather=Optional.empty();
  }
  initializePlainTCPTransport(mqttHandler,props);
  initializeWebSocketTransport(mqttHandler,props);
  String sslTcpPortProp=props.getProperty(BrokerConstants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SSLContext sslContext=sslCtxCreator.initSSLContext();
    if (sslContext == null) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(mqttHandler,props,sslContext);
    initializeWSSTransport(mqttHandler,props,sslContext);
  }
}","@Override public void initialize(ProtocolProcessor processor,IConfig props,ISslContextCreator sslCtxCreator) throws IOException {
  LOG.info(""String_Node_Str"");
  nettySoBacklog=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME,""String_Node_Str""));
  nettySoReuseaddr=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME,""String_Node_Str""));
  nettyTcpNodelay=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME,""String_Node_Str""));
  nettySoKeepalive=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME,""String_Node_Str""));
  nettyChannelTimeoutSeconds=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME,""String_Node_Str""));
  maxBytesInMessage=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,String.valueOf(BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE)));
  boolean epoll=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME,""String_Node_Str""));
  if (epoll) {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new EpollEventLoopGroup();
    m_workerGroup=new EpollEventLoopGroup();
    channelClass=EpollServerSocketChannel.class;
  }
 else {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new NioEventLoopGroup();
    m_workerGroup=new NioEventLoopGroup();
    channelClass=NioServerSocketChannel.class;
  }
  final NettyMQTTHandler mqttHandler=new NettyMQTTHandler(processor);
  final boolean useFineMetrics=Boolean.parseBoolean(props.getProperty(METRICS_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useFineMetrics) {
    DropWizardMetricsHandler metricsHandler=new DropWizardMetricsHandler();
    metricsHandler.init(props);
    this.metrics=Optional.of(metricsHandler);
  }
 else {
    this.metrics=Optional.empty();
  }
  final boolean useBugSnag=Boolean.parseBoolean(props.getProperty(BUGSNAG_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useBugSnag) {
    BugSnagErrorsHandler bugSnagHandler=new BugSnagErrorsHandler();
    bugSnagHandler.init(props);
    this.errorsCather=Optional.of(bugSnagHandler);
  }
 else {
    this.errorsCather=Optional.empty();
  }
  initializePlainTCPTransport(mqttHandler,props);
  initializeWebSocketTransport(mqttHandler,props);
  String sslTcpPortProp=props.getProperty(BrokerConstants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SSLContext sslContext=sslCtxCreator.initSSLContext();
    if (sslContext == null) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(mqttHandler,props,sslContext);
    initializeWSSTransport(mqttHandler,props,sslContext);
  }
}"
27348,"/** 
 * Create the SUBACK response from a list of topicFilters
 */
private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters,int messageId){
  List<Integer> grantedQoSLevels=new ArrayList<>();
  for (  MqttTopicSubscription req : topicFilters) {
    grantedQoSLevels.add(req.qualityOfService().value());
  }
  MqttFixedHeader fixedHeader=new MqttFixedHeader(MqttMessageType.SUBACK,false,AT_LEAST_ONCE,false,0);
  MqttSubAckPayload payload=new MqttSubAckPayload(grantedQoSLevels);
  return new MqttSubAckMessage(fixedHeader,from(messageId),payload);
}","/** 
 * Create the SUBACK response from a list of topicFilters
 */
private MqttSubAckMessage doAckMessageFromValidateFilters(List<MqttTopicSubscription> topicFilters,int messageId){
  List<Integer> grantedQoSLevels=new ArrayList<>();
  for (  MqttTopicSubscription req : topicFilters) {
    grantedQoSLevels.add(req.qualityOfService().value());
  }
  MqttFixedHeader fixedHeader=new MqttFixedHeader(MqttMessageType.SUBACK,false,AT_MOST_ONCE,false,0);
  MqttSubAckPayload payload=new MqttSubAckPayload(grantedQoSLevels);
  return new MqttSubAckMessage(fixedHeader,from(messageId),payload);
}"
27349,"/** 
 * Specialized version to publish will testament message.
 */
private void forwardPublishWill(WillMessage will,String clientID){
  LOG.info(""String_Node_Str"",clientID,will.getTopic());
  IMessagesStore.StoredMessage tobeStored=asStoredMessage(will);
  tobeStored.setClientID(clientID);
  Topic topic=new Topic(tobeStored.getTopic());
  this.messagesPublisher.publish2Subscribers(tobeStored,topic);
}","/** 
 * Specialized version to publish will testament message.
 */
private void forwardPublishWill(WillMessage will,String clientID){
  LOG.info(""String_Node_Str"",clientID,will.getTopic());
  IMessagesStore.StoredMessage tobeStored=asStoredMessage(will);
  tobeStored.setClientID(clientID);
  Topic topic=new Topic(tobeStored.getTopic());
  this.messagesPublisher.publish2Subscribers(tobeStored,topic);
  if (will.isRetained()) {
    m_messagesStore.storeRetained(topic,tobeStored);
  }
}"
27350,"void assignDefaults(){
  setProperty(BrokerConstants.PORT_PROPERTY_NAME,Integer.toString(BrokerConstants.PORT));
  setProperty(BrokerConstants.HOST_PROPERTY_NAME,BrokerConstants.HOST);
  setProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,Boolean.TRUE.toString());
  setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
}","void assignDefaults(){
  setProperty(BrokerConstants.PORT_PROPERTY_NAME,Integer.toString(BrokerConstants.PORT));
  setProperty(BrokerConstants.HOST_PROPERTY_NAME,BrokerConstants.HOST);
  setProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,Boolean.TRUE.toString());
  setProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
  setProperty(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,String.valueOf(BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE));
}"
27351,"@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MqttDecoder());
  pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
  pipeline.addLast(""String_Node_Str"",handler);
}","@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
  pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
  pipeline.addLast(""String_Node_Str"",handler);
}"
27352,"private void initializeWSSTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWSSTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WSS_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27353,"private void initializePlainTCPTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String tcpPortProp=props.getProperty(PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(tcpPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(tcpPortProp);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      if (errorsCather.isPresent()) {
        pipeline.addLast(""String_Node_Str"",errorsCather.get());
      }
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      if (metrics.isPresent()) {
        pipeline.addLast(""String_Node_Str"",metrics.get());
      }
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializePlainTCPTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String tcpPortProp=props.getProperty(PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(tcpPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(tcpPortProp);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      if (errorsCather.isPresent()) {
        pipeline.addLast(""String_Node_Str"",errorsCather.get());
      }
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      if (metrics.isPresent()) {
        pipeline.addLast(""String_Node_Str"",metrics.get());
      }
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27354,"private void initializeSSLTCPTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeSSLTCPTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  LOG.info(""String_Node_Str"");
  String sslPortProp=props.getProperty(SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(sslPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.SSL_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27355,"private void initializeWebSocketTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  String webSocketPortProp=props.getProperty(WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(new HttpServerCodec());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder());
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWebSocketTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  LOG.info(""String_Node_Str"");
  String webSocketPortProp=props.getProperty(WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
  if (DISABLED_PORT_BIND.equals(webSocketPortProp)) {
    LOG.info(""String_Node_Str"",BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME,DISABLED_PORT_BIND);
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  initFactory(host,port,""String_Node_Str"",new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(new HttpServerCodec());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(nettyChannelTimeoutSeconds,0,0));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MqttDecoder(maxBytesInMessage));
      pipeline.addLast(""String_Node_Str"",MqttEncoder.INSTANCE);
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTMessageLogger());
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27356,"@Override public void initialize(ProtocolProcessor processor,IConfig props,ISslContextCreator sslCtxCreator) throws IOException {
  LOG.info(""String_Node_Str"");
  nettySoBacklog=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME,""String_Node_Str""));
  nettySoReuseaddr=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME,""String_Node_Str""));
  nettyTcpNodelay=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME,""String_Node_Str""));
  nettySoKeepalive=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME,""String_Node_Str""));
  nettyChannelTimeoutSeconds=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME,""String_Node_Str""));
  boolean epoll=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME,""String_Node_Str""));
  if (epoll) {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new EpollEventLoopGroup();
    m_workerGroup=new EpollEventLoopGroup();
    channelClass=EpollServerSocketChannel.class;
  }
 else {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new NioEventLoopGroup();
    m_workerGroup=new NioEventLoopGroup();
    channelClass=NioServerSocketChannel.class;
  }
  final NettyMQTTHandler mqttHandler=new NettyMQTTHandler(processor);
  final boolean useFineMetrics=Boolean.parseBoolean(props.getProperty(METRICS_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useFineMetrics) {
    DropWizardMetricsHandler metricsHandler=new DropWizardMetricsHandler();
    metricsHandler.init(props);
    this.metrics=Optional.of(metricsHandler);
  }
 else {
    this.metrics=Optional.empty();
  }
  final boolean useBugSnag=Boolean.parseBoolean(props.getProperty(BUGSNAG_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useBugSnag) {
    BugSnagErrorsHandler bugSnagHandler=new BugSnagErrorsHandler();
    bugSnagHandler.init(props);
    this.errorsCather=Optional.of(bugSnagHandler);
  }
 else {
    this.errorsCather=Optional.empty();
  }
  initializePlainTCPTransport(mqttHandler,props);
  initializeWebSocketTransport(mqttHandler,props);
  String sslTcpPortProp=props.getProperty(BrokerConstants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SSLContext sslContext=sslCtxCreator.initSSLContext();
    if (sslContext == null) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(mqttHandler,props,sslContext);
    initializeWSSTransport(mqttHandler,props,sslContext);
  }
}","@Override public void initialize(ProtocolProcessor processor,IConfig props,ISslContextCreator sslCtxCreator) throws IOException {
  LOG.info(""String_Node_Str"");
  nettySoBacklog=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_SO_BACKLOG_PROPERTY_NAME,""String_Node_Str""));
  nettySoReuseaddr=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_REUSEADDR_PROPERTY_NAME,""String_Node_Str""));
  nettyTcpNodelay=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_TCP_NODELAY_PROPERTY_NAME,""String_Node_Str""));
  nettySoKeepalive=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_SO_KEEPALIVE_PROPERTY_NAME,""String_Node_Str""));
  nettyChannelTimeoutSeconds=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_CHANNEL_TIMEOUT_SECONDS_PROPERTY_NAME,""String_Node_Str""));
  maxBytesInMessage=Integer.parseInt(props.getProperty(BrokerConstants.NETTY_MAX_BYTES_PROPERTY_NAME,String.valueOf(BrokerConstants.DEFAULT_NETTY_MAX_BYTES_IN_MESSAGE)));
  boolean epoll=Boolean.parseBoolean(props.getProperty(BrokerConstants.NETTY_EPOLL_PROPERTY_NAME,""String_Node_Str""));
  if (epoll) {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new EpollEventLoopGroup();
    m_workerGroup=new EpollEventLoopGroup();
    channelClass=EpollServerSocketChannel.class;
  }
 else {
    LOG.info(""String_Node_Str"");
    m_bossGroup=new NioEventLoopGroup();
    m_workerGroup=new NioEventLoopGroup();
    channelClass=NioServerSocketChannel.class;
  }
  final NettyMQTTHandler mqttHandler=new NettyMQTTHandler(processor);
  final boolean useFineMetrics=Boolean.parseBoolean(props.getProperty(METRICS_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useFineMetrics) {
    DropWizardMetricsHandler metricsHandler=new DropWizardMetricsHandler();
    metricsHandler.init(props);
    this.metrics=Optional.of(metricsHandler);
  }
 else {
    this.metrics=Optional.empty();
  }
  final boolean useBugSnag=Boolean.parseBoolean(props.getProperty(BUGSNAG_ENABLE_PROPERTY_NAME,""String_Node_Str""));
  if (useBugSnag) {
    BugSnagErrorsHandler bugSnagHandler=new BugSnagErrorsHandler();
    bugSnagHandler.init(props);
    this.errorsCather=Optional.of(bugSnagHandler);
  }
 else {
    this.errorsCather=Optional.empty();
  }
  initializePlainTCPTransport(mqttHandler,props);
  initializeWebSocketTransport(mqttHandler,props);
  String sslTcpPortProp=props.getProperty(BrokerConstants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SSLContext sslContext=sslCtxCreator.initSSLContext();
    if (sslContext == null) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(mqttHandler,props,sslContext);
    initializeWSSTransport(mqttHandler,props,sslContext);
  }
}"
27357,"/** 
 * SPI method used by Broker embedded applications to add intercept handlers.
 */
public boolean addInterceptHandler(InterceptHandler interceptHandler){
  if (!m_initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return m_processor.addInterceptHandler(interceptHandler);
}","/** 
 * SPI method used by Broker embedded applications to add intercept handlers.
 * @param interceptHandler the handler to add.
 * @return true id operation was successful.
 */
public boolean addInterceptHandler(InterceptHandler interceptHandler){
  if (!m_initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return m_processor.addInterceptHandler(interceptHandler);
}"
27358,"/** 
 * SPI method used by Broker embedded applications to get list of subscribers. Returns null if the broker is not started.
 */
public List<Subscription> getSubscriptions(){
  if (m_processorBootstrapper == null) {
    return null;
  }
  return m_processorBootstrapper.getSubscriptions();
}","/** 
 * SPI method used by Broker embedded applications to get list of subscribers. Returns null if the broker is not started.
 * @return list of subscriptions.
 */
public List<Subscription> getSubscriptions(){
  if (m_processorBootstrapper == null) {
    return null;
  }
  return m_processorBootstrapper.getSubscriptions();
}"
27359,"/** 
 * SPI method used by Broker embedded applications to remove intercept handlers.
 */
public boolean removeInterceptHandler(InterceptHandler interceptHandler){
  if (!m_initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return m_processor.removeInterceptHandler(interceptHandler);
}","/** 
 * SPI method used by Broker embedded applications to remove intercept handlers.
 * @param interceptHandler the handler to remove.
 * @return true id operation was successful.
 */
public boolean removeInterceptHandler(InterceptHandler interceptHandler){
  if (!m_initialized) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return m_processor.removeInterceptHandler(interceptHandler);
}"
27360,"/** 
 * Is called when the write timeout expire.
 */
protected void channelIdle(ChannelHandlerContext ctx) throws Exception {
  ctx.channel().flush();
}","/** 
 * Is called when the write timeout expire.
 * @param ctx the channel context.
 * @throws Exception in case of any IO error.
 */
protected void channelIdle(ChannelHandlerContext ctx) throws Exception {
  ctx.channel().flush();
}"
27361,"/** 
 * Remove the messages stored in a cleanSession false.
 */
public void removeEnqueued(MessageGUID guid){
  this.m_sessionsStore.removeEnqueued(this.clientID,guid);
}","/** 
 * Remove the messages stored in a cleanSession false.
 * @param guid the guid of the message to remove from the queue.
 */
public void removeEnqueued(MessageGUID guid){
  this.m_sessionsStore.removeEnqueued(this.clientID,guid);
}"
27362,"/** 
 * Enqueue a message to be sent to the client.
 * @return false if the queue is full.
 */
public boolean enqueue(PublishMessage pubMessage){
  return m_queueToPublish.offer(pubMessage);
}","/** 
 * Enqueue a message to be sent to the client.
 * @param pubMessage the message to enqueue.
 * @return false if the queue is full.
 */
public boolean enqueue(PublishMessage pubMessage){
  return m_queueToPublish.offer(pubMessage);
}"
27363,"/** 
 * Persist the message.
 * @return the unique id in the storage (guid).
 */
MessageGUID storePublishForFuture(StoredMessage evt);","/** 
 * Persist the message.
 * @param storedMessage the message to store for future usage.
 * @return the unique id in the storage (guid).
 */
MessageGUID storePublishForFuture(StoredMessage storedMessage);"
27364,"/** 
 * Persist the message.  If the message is empty then the topic is cleaned, else it's stored.
 */
void storeRetained(String topic,MessageGUID guid);","/** 
 * Persist the message.  If the message is empty then the topic is cleaned, else it's stored.
 * @param topic for the retained.
 * @param guid of the message to mark as retained.
 */
void storeRetained(String topic,MessageGUID guid);"
27365,"/** 
 * Return the list of persisted publishes for the given clientID. For QoS1 and QoS2 with clean session flag, this method return the list of  missed publish events while the client was disconnected.
 */
List<StoredMessage> listMessagesInSession(Collection<MessageGUID> guids);","/** 
 * Return the list of persisted publishes for the given clientID. For QoS1 and QoS2 with clean session flag, this method return the list of  missed publish events while the client was disconnected.
 * @param guids the list of of guid to use as search keys.
 * @return the list of stored messages matching the passed keys.
 */
List<StoredMessage> listMessagesInSession(Collection<MessageGUID> guids);"
27366,"/** 
 * Return a list of retained messages that satisfy the condition.
 */
Collection<StoredMessage> searchMatching(IMatchingCondition condition);","/** 
 * Return a list of retained messages that satisfy the condition.
 * @param condition the condition to match during the search.
 * @return the collection of matching messages.
 */
Collection<StoredMessage> searchMatching(IMatchingCondition condition);"
27367,"/** 
 * Removed a specific subscription
 */
void removeSubscription(String topic,String clientID);","/** 
 * Removed a specific subscription
 * @param topic the topic of the subscription.
 * @param clientID the session client.
 */
void removeSubscription(String topic,String clientID);"
27368,"/** 
 * Store the guid to be later published.
 */
void bindToDeliver(MessageGUID guid,String clientID);","/** 
 * Store the guid to be later published.
 * @param guid the message guid to bind.
 * @param clientID the clientID
 */
void bindToDeliver(MessageGUID guid,String clientID);"
27369,"/** 
 * @return the subscription stored by clientID and topicFilter, if any else null;
 */
Subscription getSubscription(ClientTopicCouple couple);","/** 
 * @param couple the subscription descriptor.
 * @return the subscription stored by clientID and topicFilter, if any else null;
 */
Subscription getSubscription(ClientTopicCouple couple);"
27370,"/** 
 * List the guids for retained messages for the session
 */
Collection<MessageGUID> enqueued(String clientID);","/** 
 * List the guids for retained messages for the session
 * @param clientID the client ID owning the queue.
 * @return the list of enqueued message UUIDs.
 */
Collection<MessageGUID> enqueued(String clientID);"
27371,"/** 
 * Save the binding messageID, clientID <-> guid
 */
void inFlight(String clientID,int messageID,MessageGUID guid);","/** 
 * Save the binding messageID, clientID - guid
 * @param clientID the client ID
 * @param messageID the message ID
 * @param guid the uuid of the message to mark as inflight.
 */
void inFlight(String clientID,int messageID,MessageGUID guid);"
27372,"/** 
 * Return the next valid packetIdentifier for the given client session.
 */
int nextPacketID(String clientID);","/** 
 * Return the next valid packetIdentifier for the given client session.
 * @param clientID the clientID requesting next packet id.
 * @return the next valid id.
 */
int nextPacketID(String clientID);"
27373,"/** 
 * Remove form the queue of stored messages for session.
 */
void removeEnqueued(String clientID,MessageGUID guid);","/** 
 * Remove form the queue of stored messages for session.
 * @param clientID the client ID owning the queue.
 * @param guid the message guid to dequeue.
 */
void removeEnqueued(String clientID,MessageGUID guid);"
27374,"/** 
 * Remove all the subscriptions of the session
 */
void wipeSubscriptions(String sessionID);","/** 
 * Remove all the subscriptions of the session
 * @param sessionID the client ID
 */
void wipeSubscriptions(String sessionID);"
27375,"/** 
 * @return true iff there are subscriptions persisted with clientID
 */
boolean contains(String clientID);","/** 
 * @param clientID the session client ID.
 * @return true iff there are subscriptions persisted with clientID
 */
boolean contains(String clientID);"
27376,"/** 
 * @return the guid of message just acked.
 */
MessageGUID secondPhaseAcknowledged(String clientID,int messageID);","/** 
 * @param clientID the client ID accessing the second phase.
 * @param messageID the message ID that reached the second phase.
 * @return the guid of message just acked.
 */
MessageGUID secondPhaseAcknowledged(String clientID,int messageID);"
27377,"/** 
 * Add a new subscription to the session
 */
void addNewSubscription(Subscription newSubscription);","/** 
 * Add a new subscription to the session
 * @param newSubscription the subscription to add.
 */
void addNewSubscription(Subscription newSubscription);"
27378,"/** 
 * Remove the clientID from topic subscription, if not previously subscribed, doesn't reply any error
 */
public void processUnsubscribe(Channel channel,UnsubscribeMessage msg){
  List<String> topics=msg.topicFilters();
  String clientID=NettyUtils.clientID(channel);
  LOG.debug(""String_Node_Str"",topics,clientID);
  ClientSession clientSession=m_sessionsStore.sessionForClient(clientID);
  for (  String topic : topics) {
    boolean validTopic=SubscriptionsStore.validate(topic);
    if (!validTopic) {
      channel.close();
      LOG.warn(""String_Node_Str"",topic,clientID);
      return;
    }
    subscriptions.removeSubscription(topic,clientID);
    clientSession.unsubscribeFrom(topic);
    String username=NettyUtils.userName(channel);
    m_interceptor.notifyTopicUnsubscribed(topic,clientID,username);
  }
  int messageID=msg.getMessageID();
  UnsubAckMessage ackMessage=new UnsubAckMessage();
  ackMessage.setMessageID(messageID);
  LOG.info(""String_Node_Str"",messageID);
  channel.writeAndFlush(ackMessage);
}","/** 
 * Remove the clientID from topic subscription, if not previously subscribed, doesn't reply any error.
 * @param channel the channel of the incoming message.
 * @param msg the decoded unsubscribe message.
 */
public void processUnsubscribe(Channel channel,UnsubscribeMessage msg){
  List<String> topics=msg.topicFilters();
  String clientID=NettyUtils.clientID(channel);
  LOG.debug(""String_Node_Str"",topics,clientID);
  ClientSession clientSession=m_sessionsStore.sessionForClient(clientID);
  for (  String topic : topics) {
    boolean validTopic=SubscriptionsStore.validate(topic);
    if (!validTopic) {
      channel.close();
      LOG.warn(""String_Node_Str"",topic,clientID);
      return;
    }
    subscriptions.removeSubscription(topic,clientID);
    clientSession.unsubscribeFrom(topic);
    String username=NettyUtils.userName(channel);
    m_interceptor.notifyTopicUnsubscribed(topic,clientID,username);
  }
  int messageID=msg.getMessageID();
  UnsubAckMessage ackMessage=new UnsubAckMessage();
  ackMessage.setMessageID(messageID);
  LOG.info(""String_Node_Str"",messageID);
  channel.writeAndFlush(ackMessage);
}"
27379,"/** 
 * Intended usage is only for embedded versions of the broker, where the hosting application want to use the broker to send a publish message. Inspired by   {@link #processPublish} but with some changes to avoid security check, and the handshake phasesfor Qos1 and Qos2. It also doesn't notifyTopicPublished because using internally the owner should already know where it's publishing.
 */
public void internalPublish(PublishMessage msg){
  final AbstractMessage.QOSType qos=msg.getQos();
  final String topic=msg.getTopicName();
  LOG.info(""String_Node_Str"",topic,qos);
  MessageGUID guid=null;
  IMessagesStore.StoredMessage toStoreMsg=asStoredMessage(msg);
  if (msg.getClientId() == null || msg.getClientId().isEmpty()) {
    toStoreMsg.setClientID(""String_Node_Str"");
  }
 else {
    toStoreMsg.setClientID(msg.getClientId());
  }
  toStoreMsg.setMessageID(1);
  if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) {
    guid=m_messagesStore.storePublishForFuture(toStoreMsg);
  }
  List<Subscription> topicMatchingSubscriptions=subscriptions.matches(topic);
  this.messagesPublisher.publish2Subscribers(toStoreMsg,topicMatchingSubscriptions);
  if (!msg.isRetainFlag()) {
    return;
  }
  if (qos == AbstractMessage.QOSType.MOST_ONE || !msg.getPayload().hasRemaining()) {
    m_messagesStore.cleanRetained(topic);
    return;
  }
  if (guid == null) {
    guid=m_messagesStore.storePublishForFuture(toStoreMsg);
  }
  m_messagesStore.storeRetained(topic,guid);
}","/** 
 * Intended usage is only for embedded versions of the broker, where the hosting application want to use the broker to send a publish message. Inspired by   {@link #processPublish} but with some changes to avoid security check, and the handshake phasesfor Qos1 and Qos2. It also doesn't notifyTopicPublished because using internally the owner should already know where it's publishing.
 * @param msg the message to publish.
 */
public void internalPublish(PublishMessage msg){
  final AbstractMessage.QOSType qos=msg.getQos();
  final String topic=msg.getTopicName();
  LOG.info(""String_Node_Str"",topic,qos);
  MessageGUID guid=null;
  IMessagesStore.StoredMessage toStoreMsg=asStoredMessage(msg);
  if (msg.getClientId() == null || msg.getClientId().isEmpty()) {
    toStoreMsg.setClientID(""String_Node_Str"");
  }
 else {
    toStoreMsg.setClientID(msg.getClientId());
  }
  toStoreMsg.setMessageID(1);
  if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) {
    guid=m_messagesStore.storePublishForFuture(toStoreMsg);
  }
  List<Subscription> topicMatchingSubscriptions=subscriptions.matches(topic);
  this.messagesPublisher.publish2Subscribers(toStoreMsg,topicMatchingSubscriptions);
  if (!msg.isRetainFlag()) {
    return;
  }
  if (qos == AbstractMessage.QOSType.MOST_ONE || !msg.getPayload().hasRemaining()) {
    m_messagesStore.cleanRetained(topic);
    return;
  }
  if (guid == null) {
    guid=m_messagesStore.storePublishForFuture(toStoreMsg);
  }
  m_messagesStore.storeRetained(topic,guid);
}"
27380,"/** 
 * Second phase of a publish QoS2 protocol, sent by publisher to the broker. Search the stored message and publish to all interested subscribers.
 */
public void processPubRel(Channel channel,PubRelMessage msg){
  this.qos2PublishHandler.processPubRel(channel,msg);
}","/** 
 * Second phase of a publish QoS2 protocol, sent by publisher to the broker. Search the stored message and publish to all interested subscribers.
 * @param channel the channel of the incoming message.
 * @param msg the decoded pubrel message.
 */
public void processPubRel(Channel channel,PubRelMessage msg){
  this.qos2PublishHandler.processPubRel(channel,msg);
}"
27381,"/** 
 * Initialize the processing part of the broker.
 * @param props the properties carrier where some props like port end host could be loaded.For the full list check of configurable properties check moquette.conf file.
 * @param embeddedObservers a list of callbacks to be notified of certain events inside the broker.Could be empty list of null.
 * @param authenticator an implementation of the authenticator to be used, if null load that specified in configand fallback on the default one (permit all).
 * @param authorizator an implementation of the authorizator to be used, if null load that specified in configand fallback on the default one (permit all).
 */
public ProtocolProcessor init(IConfig props,List<? extends InterceptHandler> embeddedObservers,IAuthenticator authenticator,IAuthorizator authorizator,Server server){
  subscriptions=new SubscriptionsStore();
  m_mapStorage=new MapDBPersistentStore(props);
  m_mapStorage.initStore();
  IMessagesStore messagesStore=m_mapStorage.messagesStore();
  m_sessionsStore=m_mapStorage.sessionsStore();
  List<InterceptHandler> observers=new ArrayList<>(embeddedObservers);
  String interceptorClassName=props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);
  if (interceptorClassName != null && !interceptorClassName.isEmpty()) {
    try {
      InterceptHandler handler;
      try {
        final Constructor<? extends InterceptHandler> constructor=Class.forName(interceptorClassName).asSubclass(InterceptHandler.class).getConstructor(Server.class);
        handler=constructor.newInstance(server);
      }
 catch (      NoSuchMethodException nsme) {
        handler=Class.forName(interceptorClassName).asSubclass(InterceptHandler.class).newInstance();
      }
      observers.add(handler);
    }
 catch (    Throwable ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
  m_interceptor=new BrokerInterceptor(observers);
  subscriptions.init(m_sessionsStore);
  String configPath=System.getProperty(""String_Node_Str"",null);
  String authenticatorClassName=props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  if (!authenticatorClassName.isEmpty()) {
    authenticator=(IAuthenticator)loadClass(authenticatorClassName,IAuthenticator.class,props);
    LOG.info(""String_Node_Str"",authenticatorClassName);
  }
  IResourceLoader resourceLoader=props.getResourceLoader();
  if (authenticator == null) {
    String passwdPath=props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (passwdPath.isEmpty()) {
      authenticator=new AcceptAllAuthenticator();
    }
 else {
      authenticator=new ResourceAuthenticator(resourceLoader,passwdPath);
    }
  }
  String authorizatorClassName=props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
  if (!authorizatorClassName.isEmpty()) {
    authorizator=(IAuthorizator)loadClass(authorizatorClassName,IAuthorizator.class,props);
    LOG.info(""String_Node_Str"",authorizatorClassName);
  }
  if (authorizator == null) {
    String aclFilePath=props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (aclFilePath != null && !aclFilePath.isEmpty()) {
      authorizator=new DenyAllAuthorizator();
      try {
        authorizator=ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));
      }
 catch (      ParseException pex) {
        LOG.error(String.format(""String_Node_Str"",resourceLoader.getName(),aclFilePath),pex);
      }
      LOG.info(""String_Node_Str"",aclFilePath);
    }
 else {
      authorizator=new PermitAllAuthorizator();
      LOG.info(""String_Node_Str"");
    }
  }
  boolean allowAnonymous=Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,""String_Node_Str""));
  boolean allowZeroByteClientId=Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME,""String_Node_Str""));
  m_processor.init(subscriptions,messagesStore,m_sessionsStore,authenticator,allowAnonymous,allowZeroByteClientId,authorizator,m_interceptor,props.getProperty(BrokerConstants.PORT_PROPERTY_NAME));
  return m_processor;
}","/** 
 * Initialize the processing part of the broker.
 * @param props the properties carrier where some props like port end host could be loaded.For the full list check of configurable properties check moquette.conf file.
 * @param embeddedObservers a list of callbacks to be notified of certain events inside the broker.Could be empty list of null.
 * @param authenticator an implementation of the authenticator to be used, if null load that specified in configand fallback on the default one (permit all).
 * @param authorizator an implementation of the authorizator to be used, if null load that specified in configand fallback on the default one (permit all).
 * @param server the serber to init.
 * @return the processor created for the broker.
 */
public ProtocolProcessor init(IConfig props,List<? extends InterceptHandler> embeddedObservers,IAuthenticator authenticator,IAuthorizator authorizator,Server server){
  subscriptions=new SubscriptionsStore();
  m_mapStorage=new MapDBPersistentStore(props);
  m_mapStorage.initStore();
  IMessagesStore messagesStore=m_mapStorage.messagesStore();
  m_sessionsStore=m_mapStorage.sessionsStore();
  List<InterceptHandler> observers=new ArrayList<>(embeddedObservers);
  String interceptorClassName=props.getProperty(BrokerConstants.INTERCEPT_HANDLER_PROPERTY_NAME);
  if (interceptorClassName != null && !interceptorClassName.isEmpty()) {
    try {
      InterceptHandler handler;
      try {
        final Constructor<? extends InterceptHandler> constructor=Class.forName(interceptorClassName).asSubclass(InterceptHandler.class).getConstructor(Server.class);
        handler=constructor.newInstance(server);
      }
 catch (      NoSuchMethodException nsme) {
        handler=Class.forName(interceptorClassName).asSubclass(InterceptHandler.class).newInstance();
      }
      observers.add(handler);
    }
 catch (    Throwable ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
  m_interceptor=new BrokerInterceptor(observers);
  subscriptions.init(m_sessionsStore);
  String configPath=System.getProperty(""String_Node_Str"",null);
  String authenticatorClassName=props.getProperty(BrokerConstants.AUTHENTICATOR_CLASS_NAME,""String_Node_Str"");
  if (!authenticatorClassName.isEmpty()) {
    authenticator=(IAuthenticator)loadClass(authenticatorClassName,IAuthenticator.class,props);
    LOG.info(""String_Node_Str"",authenticatorClassName);
  }
  IResourceLoader resourceLoader=props.getResourceLoader();
  if (authenticator == null) {
    String passwdPath=props.getProperty(BrokerConstants.PASSWORD_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (passwdPath.isEmpty()) {
      authenticator=new AcceptAllAuthenticator();
    }
 else {
      authenticator=new ResourceAuthenticator(resourceLoader,passwdPath);
    }
  }
  String authorizatorClassName=props.getProperty(BrokerConstants.AUTHORIZATOR_CLASS_NAME,""String_Node_Str"");
  if (!authorizatorClassName.isEmpty()) {
    authorizator=(IAuthorizator)loadClass(authorizatorClassName,IAuthorizator.class,props);
    LOG.info(""String_Node_Str"",authorizatorClassName);
  }
  if (authorizator == null) {
    String aclFilePath=props.getProperty(BrokerConstants.ACL_FILE_PROPERTY_NAME,""String_Node_Str"");
    if (aclFilePath != null && !aclFilePath.isEmpty()) {
      authorizator=new DenyAllAuthorizator();
      try {
        authorizator=ACLFileParser.parse(resourceLoader.loadResource(aclFilePath));
      }
 catch (      ParseException pex) {
        LOG.error(String.format(""String_Node_Str"",resourceLoader.getName(),aclFilePath),pex);
      }
      LOG.info(""String_Node_Str"",aclFilePath);
    }
 else {
      authorizator=new PermitAllAuthorizator();
      LOG.info(""String_Node_Str"");
    }
  }
  boolean allowAnonymous=Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ANONYMOUS_PROPERTY_NAME,""String_Node_Str""));
  boolean allowZeroByteClientId=Boolean.parseBoolean(props.getProperty(BrokerConstants.ALLOW_ZERO_BYTE_CLIENT_ID_PROPERTY_NAME,""String_Node_Str""));
  m_processor.init(subscriptions,messagesStore,m_sessionsStore,authenticator,allowAnonymous,allowZeroByteClientId,authorizator,m_interceptor,props.getProperty(BrokerConstants.PORT_PROPERTY_NAME));
  return m_processor;
}"
27382,"/** 
 * Parse the ACL configuration file
 * @throws java.text.ParseException if the format is not compliant.
 */
public static AuthorizationsCollector parse(Reader reader) throws ParseException {
  if (reader == null) {
    LOG.warn(""String_Node_Str"");
    return AuthorizationsCollector.emptyImmutableCollector();
  }
  BufferedReader br=new BufferedReader(reader);
  String line;
  AuthorizationsCollector collector=new AuthorizationsCollector();
  try {
    while ((line=br.readLine()) != null) {
      int commentMarker=line.indexOf('#');
      if (commentMarker != -1) {
        if (commentMarker == 0) {
          continue;
        }
 else {
          throw new ParseException(line,commentMarker);
        }
      }
 else {
        if (line.isEmpty() || line.matches(""String_Node_Str"")) {
          continue;
        }
        collector.parse(line);
      }
    }
  }
 catch (  IOException ex) {
    throw new ParseException(""String_Node_Str"",1);
  }
  return collector;
}","/** 
 * Parse the ACL configuration file
 * @param reader to parse
 * @return the collector of authorizations form reader passed into.
 * @throws ParseException if the format is not compliant.
 */
public static AuthorizationsCollector parse(Reader reader) throws ParseException {
  if (reader == null) {
    LOG.warn(""String_Node_Str"");
    return AuthorizationsCollector.emptyImmutableCollector();
  }
  BufferedReader br=new BufferedReader(reader);
  String line;
  AuthorizationsCollector collector=new AuthorizationsCollector();
  try {
    while ((line=br.readLine()) != null) {
      int commentMarker=line.indexOf('#');
      if (commentMarker != -1) {
        if (commentMarker == 0) {
          continue;
        }
 else {
          throw new ParseException(line,commentMarker);
        }
      }
 else {
        if (line.isEmpty() || line.matches(""String_Node_Str"")) {
          continue;
        }
        collector.parse(line);
      }
    }
  }
 catch (  IOException ex) {
    throw new ParseException(""String_Node_Str"",1);
  }
  return collector;
}"
27383,"/** 
 * Initialize the subscription tree with the list of subscriptions. Maintained for compatibility reasons.
 */
public void init(ISessionsStore sessionsStore){
  LOG.debug(""String_Node_Str"");
  m_sessionsStore=sessionsStore;
  List<ClientTopicCouple> subscriptions=sessionsStore.listAllSubscriptions();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",dumpTree());
  }
  for (  ClientTopicCouple clientTopic : subscriptions) {
    LOG.debug(""String_Node_Str"",clientTopic.clientID,clientTopic.topicFilter);
    add(clientTopic);
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"",dumpTree());
  }
}","/** 
 * Initialize the subscription tree with the list of subscriptions. Maintained for compatibility reasons.
 * @param sessionsStore to be used as backing store from the subscription store.
 */
public void init(ISessionsStore sessionsStore){
  LOG.debug(""String_Node_Str"");
  m_sessionsStore=sessionsStore;
  List<ClientTopicCouple> subscriptions=sessionsStore.listAllSubscriptions();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",dumpTree());
  }
  for (  ClientTopicCouple clientTopic : subscriptions) {
    LOG.debug(""String_Node_Str"",clientTopic.clientID,clientTopic.topicFilter);
    add(clientTopic);
  }
  if (LOG.isTraceEnabled()) {
    LOG.trace(""String_Node_Str"",dumpTree());
  }
}"
27384,"/** 
 * Given a topic string return the clients subscriptions that matches it. Topic string can't contain character # and + because they are reserved to listeners subscriptions, and not topic publishing.
 */
public List<Subscription> matches(String topic){
  List<Token> tokens;
  try {
    tokens=parseTopic(topic);
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    return Collections.emptyList();
  }
  Queue<Token> tokenQueue=new LinkedBlockingDeque<>(tokens);
  List<ClientTopicCouple> matchingSubs=new ArrayList<>();
  subscriptions.get().matches(tokenQueue,matchingSubs);
  Map<String,Subscription> subsForClient=new HashMap<>();
  for (  ClientTopicCouple matchingCouple : matchingSubs) {
    Subscription existingSub=subsForClient.get(matchingCouple.clientID);
    Subscription sub=m_sessionsStore.getSubscription(matchingCouple);
    if (sub == null) {
      continue;
    }
    if (existingSub == null || existingSub.getRequestedQos().byteValue() < sub.getRequestedQos().byteValue()) {
      subsForClient.put(matchingCouple.clientID,sub);
    }
  }
  return new ArrayList<>(subsForClient.values());
}","/** 
 * Given a topic string return the clients subscriptions that matches it. Topic string can't contain character # and + because they are reserved to listeners subscriptions, and not topic publishing.
 * @param topic to use fo searching matching subscriptions.
 * @return the list of matching subscriptions, or empty if not matching.
 */
public List<Subscription> matches(String topic){
  List<Token> tokens;
  try {
    tokens=parseTopic(topic);
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    return Collections.emptyList();
  }
  Queue<Token> tokenQueue=new LinkedBlockingDeque<>(tokens);
  List<ClientTopicCouple> matchingSubs=new ArrayList<>();
  subscriptions.get().matches(tokenQueue,matchingSubs);
  Map<String,Subscription> subsForClient=new HashMap<>();
  for (  ClientTopicCouple matchingCouple : matchingSubs) {
    Subscription existingSub=subsForClient.get(matchingCouple.clientID);
    Subscription sub=m_sessionsStore.getSubscription(matchingCouple);
    if (sub == null) {
      continue;
    }
    if (existingSub == null || existingSub.getRequestedQos().byteValue() < sub.getRequestedQos().byteValue()) {
      subsForClient.put(matchingCouple.clientID,sub);
    }
  }
  return new ArrayList<>(subsForClient.values());
}"
27385,"/** 
 * Visit the topics tree to remove matching subscriptions with clientID. It's a mutating structure operation so create a new subscription tree (partial or total).
 */
public void removeForClient(String clientID){
  TreeNode oldRoot;
  TreeNode newRoot;
  do {
    oldRoot=subscriptions.get();
    newRoot=oldRoot.removeClientSubscriptions(clientID);
  }
 while (!subscriptions.compareAndSet(oldRoot,newRoot));
}","/** 
 * Visit the topics tree to remove matching subscriptions with clientID. It's a mutating structure operation so create a new subscription tree (partial or total).
 * @param clientID the client ID to remove.
 */
public void removeForClient(String clientID){
  TreeNode oldRoot;
  TreeNode newRoot;
  do {
    oldRoot=subscriptions.get();
    newRoot=oldRoot.removeClientSubscriptions(clientID);
  }
 while (!subscriptions.compareAndSet(oldRoot,newRoot));
}"
27386,"/** 
 * Verify if the 2 topics matching respecting the rules of MQTT Appendix A
 */
public static boolean matchTopics(String msgTopic,String subscriptionTopic){
  try {
    List<Token> msgTokens=SubscriptionsStore.parseTopic(msgTopic);
    List<Token> subscriptionTokens=SubscriptionsStore.parseTopic(subscriptionTopic);
    int i=0;
    for (; i < subscriptionTokens.size(); i++) {
      Token subToken=subscriptionTokens.get(i);
      if (subToken != Token.MULTI && subToken != Token.SINGLE) {
        if (i >= msgTokens.size()) {
          return false;
        }
        Token msgToken=msgTokens.get(i);
        if (!msgToken.equals(subToken)) {
          return false;
        }
      }
 else {
        if (subToken == Token.MULTI) {
          return true;
        }
        if (subToken == Token.SINGLE) {
        }
      }
    }
    return i == msgTokens.size();
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    throw new RuntimeException(ex);
  }
}","/** 
 * Verify if the 2 topics matching respecting the rules of MQTT Appendix A
 * @param msgTopic the topic to match from the message
 * @param subscriptionTopic the topic filter of the subscription
 * @return true if the two topics match.
 */
public static boolean matchTopics(String msgTopic,String subscriptionTopic){
  try {
    List<Token> msgTokens=SubscriptionsStore.parseTopic(msgTopic);
    List<Token> subscriptionTokens=SubscriptionsStore.parseTopic(subscriptionTopic);
    int i=0;
    for (; i < subscriptionTokens.size(); i++) {
      Token subToken=subscriptionTokens.get(i);
      if (subToken != Token.MULTI && subToken != Token.SINGLE) {
        if (i >= msgTokens.size()) {
          return false;
        }
        Token msgToken=msgTokens.get(i);
        if (!msgToken.equals(subToken)) {
          return false;
        }
      }
 else {
        if (subToken == Token.MULTI) {
          return true;
        }
        if (subToken == Token.SINGLE) {
        }
      }
    }
    return i == msgTokens.size();
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    throw new RuntimeException(ex);
  }
}"
27387,"/** 
 * Check if the topic filter of the subscription is well formed
 */
public static boolean validate(String topicFilter){
  try {
    parseTopic(topicFilter);
    return true;
  }
 catch (  ParseException pex) {
    LOG.info(""String_Node_Str"",topicFilter);
    return false;
  }
}","/** 
 * Check if the topic filter of the subscription is well formed
 * @param topicFilter the filter to validate
 * @return true if it's correct.
 */
public static boolean validate(String topicFilter){
  try {
    parseTopic(topicFilter);
    return true;
  }
 catch (  ParseException pex) {
    LOG.info(""String_Node_Str"",topicFilter);
    return false;
  }
}"
27388,"@Override public MessageGUID storePublishForFuture(StoredMessage evt){
  LOG.debug(""String_Node_Str"",evt);
  if (evt.getClientID() == null) {
    LOG.error(""String_Node_Str"",evt);
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MessageGUID guid=new MessageGUID(UUID.randomUUID().toString());
  evt.setGuid(guid);
  LOG.debug(""String_Node_Str"",guid);
  m_persistentMessageStore.put(guid,evt);
  ConcurrentMap<Integer,MessageGUID> messageIdToGuid=m_db.getHashMap(MapDBSessionsStore.messageId2GuidsMapName(evt.getClientID()));
  messageIdToGuid.put(evt.getMessageID(),guid);
  return guid;
}","@Override public MessageGUID storePublishForFuture(StoredMessage storedMessage){
  LOG.debug(""String_Node_Str"",storedMessage);
  if (storedMessage.getClientID() == null) {
    LOG.error(""String_Node_Str"",storedMessage);
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MessageGUID guid=new MessageGUID(UUID.randomUUID().toString());
  storedMessage.setGuid(guid);
  LOG.debug(""String_Node_Str"",guid);
  m_persistentMessageStore.put(guid,storedMessage);
  ConcurrentMap<Integer,MessageGUID> messageIdToGuid=m_db.getHashMap(MapDBSessionsStore.messageId2GuidsMapName(storedMessage.getClientID()));
  messageIdToGuid.put(storedMessage.getMessageID(),guid);
  return guid;
}"
27389,"/** 
 * Factory method to create message store backed by MapDB
 */
public IMessagesStore messagesStore(){
  return m_messageStore;
}","/** 
 * Factory method to create message store backed by MapDB
 * @return the message store instance.
 */
public IMessagesStore messagesStore(){
  return m_messageStore;
}"
27390,"/** 
 * Ask the implementation of the authorizator if the topic can be used in a publish.
 */
boolean canWrite(String topic,String user,String client);","/** 
 * Ask the implementation of the authorizator if the topic can be used in a publish.
 * @param topic the topic to write to.
 * @param user the user
 * @param client the client
 * @return true if the user from client can publish data on topic.
 */
boolean canWrite(String topic,String user,String client);"
27391,"protected void directSend(ClientSession clientsession,String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retained,Integer messageID){
  String clientId=clientsession.clientID;
  LOG.debug(""String_Node_Str"",clientId,topic,qos,retained,messageID);
  PublishMessage pubMessage=new PublishMessage();
  pubMessage.setRetainFlag(retained);
  pubMessage.setTopicName(topic);
  pubMessage.setQos(qos);
  pubMessage.setPayload(message);
  LOG.info(""String_Node_Str"",clientId,topic);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",DebugUtils.payload2Str(message));
  }
  if (pubMessage.getQos() != AbstractMessage.QOSType.MOST_ONE) {
    pubMessage.setMessageID(messageID);
  }
 else {
    if (messageID != null) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + messageID);
    }
  }
  if (m_clientIDs == null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (m_clientIDs.get(clientId) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",clientId,m_clientIDs));
  }
  Channel channel=m_clientIDs.get(clientId).channel;
  LOG.trace(""String_Node_Str"",clientId);
  if (channel.isWritable()) {
    channel.write(pubMessage);
  }
 else {
    clientsession.enqueue(pubMessage);
  }
}","protected void directSend(ClientSession clientsession,String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retained,Integer messageID){
  String clientId=clientsession.clientID;
  LOG.debug(""String_Node_Str"",clientId,topic,qos,retained,messageID);
  PublishMessage pubMessage=new PublishMessage();
  pubMessage.setRetainFlag(retained);
  pubMessage.setTopicName(topic);
  pubMessage.setQos(qos);
  pubMessage.setPayload(message);
  LOG.info(""String_Node_Str"",clientId,topic);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",DebugUtils.payload2Str(message));
  }
  if (pubMessage.getQos() != AbstractMessage.QOSType.MOST_ONE) {
    pubMessage.setMessageID(messageID);
  }
 else {
    if (messageID != null) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + messageID);
    }
  }
  if (m_clientIDs == null) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (m_clientIDs.get(clientId) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",clientId,m_clientIDs));
  }
  Channel channel=m_clientIDs.get(clientId).channel;
  LOG.trace(""String_Node_Str"",clientId);
  if (channel.isWritable()) {
    LOG.debug(""String_Node_Str"");
    channel.writeAndFlush(pubMessage);
  }
 else {
    LOG.debug(""String_Node_Str"");
    clientsession.enqueue(pubMessage);
  }
}"
27392,"/** 
 * Republish QoS1 and QoS2 messages stored into the session for the clientID.
 */
private void republishStoredInSession(ClientSession clientSession){
  LOG.trace(""String_Node_Str"",clientSession);
  List<IMessagesStore.StoredMessage> publishedEvents=clientSession.storedMessages();
  if (publishedEvents.isEmpty()) {
    LOG.info(""String_Node_Str"",clientSession.clientID);
    return;
  }
  LOG.info(""String_Node_Str"",clientSession.clientID);
  for (  IMessagesStore.StoredMessage pubEvt : publishedEvents) {
    directSend(clientSession,pubEvt.getTopic(),pubEvt.getQos(),pubEvt.getMessage(),false,pubEvt.getMessageID());
    clientSession.removeEnqueued(pubEvt.getGuid());
  }
}","/** 
 * Republish QoS1 and QoS2 messages stored into the session for the clientID.
 */
private void republishStoredInSession(ClientSession clientSession){
  LOG.trace(""String_Node_Str"",clientSession);
  List<IMessagesStore.StoredMessage> publishedEvents=clientSession.storedMessages();
  if (publishedEvents.isEmpty()) {
    LOG.info(""String_Node_Str"",clientSession.clientID);
    return;
  }
  LOG.info(""String_Node_Str"",clientSession.clientID);
  for (  IMessagesStore.StoredMessage pubEvt : publishedEvents) {
    LOG.trace(""String_Node_Str"",pubEvt.getMessageID());
    clientSession.inFlightAckWaiting(pubEvt.getGuid(),pubEvt.getMessageID());
    directSend(clientSession,pubEvt.getTopic(),pubEvt.getQos(),pubEvt.getMessage(),false,pubEvt.getMessageID());
    clientSession.removeEnqueued(pubEvt.getGuid());
  }
}"
27393,"@Before public void setUp() throws Exception {
  startServer();
  String dbPath=IntegrationUtils.localMapDBPath();
  IntegrationUtils.cleanPersistenceFile(dbPath);
  m_subscriber=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_dataStore);
  m_messageCollector=new MessageCollector();
  m_subscriber.setCallback(m_messageCollector);
  m_publisher=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_pubDataStore);
}","@Before public void setUp() throws Exception {
  String dbPath=IntegrationUtils.localMapDBPath();
  IntegrationUtils.cleanPersistenceFile(dbPath);
  startServer();
  m_subscriber=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_dataStore);
  m_messageCollector=new MessageCollector();
  m_subscriber.setCallback(m_messageCollector);
  m_publisher=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_pubDataStore);
}"
27394,"@Before public void setUp() throws Exception {
  startServer();
  String dbPath=IntegrationUtils.localMapDBPath();
  IntegrationUtils.cleanPersistenceFile(dbPath);
  m_subscriber=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_dataStore);
  m_messageCollector=new MessageCollector();
  m_subscriber.setCallback(m_messageCollector);
  m_publisher=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_pubDataStore);
}","@Before public void setUp() throws Exception {
  String dbPath=IntegrationUtils.localMapDBPath();
  IntegrationUtils.cleanPersistenceFile(dbPath);
  startServer();
  m_subscriber=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_dataStore);
  m_messageCollector=new MessageCollector();
  m_subscriber.setCallback(m_messageCollector);
  m_publisher=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_pubDataStore);
}"
27395,"@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
  pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",handler);
}","@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
  pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",handler);
}"
27396,"private void initializeWSSTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  String sslPortProp=props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWSSTransport(final NettyMQTTHandler handler,IConfig props,final SSLContext sslContext) throws IOException {
  String sslPortProp=props.getProperty(BrokerConstants.WSS_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  String sNeedsClientAuth=props.getProperty(BrokerConstants.NEED_CLIENT_AUTH,""String_Node_Str"");
  final boolean needsClientAuth=Boolean.valueOf(sNeedsClientAuth);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",createSslHandler(sslContext,needsClientAuth));
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27397,"private void initializeWebSocketTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  String webSocketPortProp=props.getProperty(BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME);
  if (webSocketPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  initFactory(host,port,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWebSocketTransport(final NettyMQTTHandler handler,IConfig props) throws IOException {
  String webSocketPortProp=props.getProperty(BrokerConstants.WEB_SOCKET_PORT_PROPERTY_NAME);
  if (webSocketPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final MoquetteIdleTimeoutHandler timeoutHandler=new MoquetteIdleTimeoutHandler();
  String host=props.getProperty(BrokerConstants.HOST_PROPERTY_NAME);
  initFactory(host,port,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",MQTT_SUBPROTOCOL_CSV_LIST));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",timeoutHandler);
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27398,"/** 
 * Given a topic string return the clients subscriptions that matches it. Topic string can't contain character # and + because they are reserved to listeners subscriptions, and not topic publishing.
 */
public List<Subscription> matches(String topic){
  List<Token> tokens;
  try {
    tokens=parseTopic(topic);
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    return Collections.emptyList();
  }
  Queue<Token> tokenQueue=new LinkedBlockingDeque<>(tokens);
  List<ClientTopicCouple> matchingSubs=new ArrayList<>();
  subscriptions.get().matches(tokenQueue,matchingSubs);
  Map<String,Subscription> subsForClient=new HashMap<>();
  for (  ClientTopicCouple matchingCouple : matchingSubs) {
    Subscription existingSub=subsForClient.get(matchingCouple.clientID);
    Subscription sub=m_sessionsStore.getSubscription(matchingCouple);
    if (existingSub == null || existingSub.getRequestedQos().byteValue() < sub.getRequestedQos().byteValue()) {
      subsForClient.put(matchingCouple.clientID,sub);
    }
  }
  return new ArrayList<>(subsForClient.values());
}","/** 
 * Given a topic string return the clients subscriptions that matches it. Topic string can't contain character # and + because they are reserved to listeners subscriptions, and not topic publishing.
 */
public List<Subscription> matches(String topic){
  List<Token> tokens;
  try {
    tokens=parseTopic(topic);
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    return Collections.emptyList();
  }
  Queue<Token> tokenQueue=new LinkedBlockingDeque<>(tokens);
  List<ClientTopicCouple> matchingSubs=new ArrayList<>();
  subscriptions.get().matches(tokenQueue,matchingSubs);
  Map<String,Subscription> subsForClient=new HashMap<>();
  for (  ClientTopicCouple matchingCouple : matchingSubs) {
    Subscription existingSub=subsForClient.get(matchingCouple.clientID);
    Subscription sub=m_sessionsStore.getSubscription(matchingCouple);
    if (sub == null) {
      continue;
    }
    if (existingSub == null || existingSub.getRequestedQos().byteValue() < sub.getRequestedQos().byteValue()) {
      subsForClient.put(matchingCouple.clientID,sub);
    }
  }
  return new ArrayList<>(subsForClient.values());
}"
27399,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  String clientID=(String)NettyUtils.getAttribute(ctx,NettyChannel.ATTR_KEY_CLIENTID);
  if (clientID != null && !clientID.isEmpty()) {
    m_processor.processConnectionLost(new LostConnectionEvent(clientID));
  }
  ctx.close();
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  String clientID=(String)NettyUtils.getAttribute(ctx,NettyChannel.ATTR_KEY_CLIENTID);
  if (clientID != null && !clientID.isEmpty()) {
    boolean stolen=false;
    Boolean stolenAttr=(Boolean)NettyUtils.getAttribute(ctx,NettyChannel.ATTR_KEY_SESSION_STOLEN);
    if (stolenAttr != null && stolenAttr == Boolean.TRUE) {
      stolen=stolenAttr;
    }
    m_processor.processConnectionLost(new LostConnectionEvent(clientID,stolen));
  }
  ctx.close();
}"
27400,"public void processConnect(ServerChannel session,ConnectMessage msg){
  LOG.debug(""String_Node_Str"",msg.getClientID());
  if (msg.getProtocolVersion() != VERSION_3_1 && msg.getProtocolVersion() != VERSION_3_1_1) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    LOG.warn(""String_Node_Str"");
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() == 0) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    m_interceptor.notifyClientConnected(msg);
    return;
  }
  if (msg.isUserFlag()) {
    byte[] pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
 else     if (!this.allowAnonymous) {
      failedCredentials(session);
      return;
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      failedCredentials(session);
      return;
    }
    session.setAttribute(NettyChannel.ATTR_KEY_USERNAME,msg.getUsername());
  }
 else   if (!this.allowAnonymous) {
    failedCredentials(session);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    ServerChannel oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(NettyChannel.ATTR_KEY_CLEANSESSION);
    if (cleanSession) {
      cleanSession(msg.getClientID());
    }
    oldSession.close(false);
    LOG.debug(""String_Node_Str"",msg.getClientID());
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  LOG.debug(""String_Node_Str"",keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_KEEPALIVE,keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_CLEANSESSION,msg.isCleanSession());
  session.setAttribute(NettyChannel.ATTR_KEY_CLIENTID,msg.getClientID());
  LOG.debug(""String_Node_Str"",session);
  session.setIdleTime(Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    AbstractMessage.QOSType willQos=AbstractMessage.QOSType.valueOf(msg.getWillQos());
    byte[] willPayload=msg.getWillMessage();
    ByteBuffer bb=(ByteBuffer)ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
    WillMessage will=new WillMessage(msg.getWillTopic(),bb,msg.isWillRetain(),willQos);
    m_willStore.put(msg.getClientID(),will);
  }
  subscriptions.activate(msg.getClientID());
  if (msg.isCleanSession()) {
    cleanSession(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  boolean isSessionAlreadyStored=m_sessionsStore.contains(msg.getClientID());
  if (!msg.isCleanSession() && isSessionAlreadyStored) {
    okResp.setSessionPresent(true);
  }
  session.write(okResp);
  m_interceptor.notifyClientConnected(msg);
  if (!isSessionAlreadyStored) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    m_sessionsStore.createNewSession(msg.getClientID());
  }
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.isCleanSession());
  if (!msg.isCleanSession()) {
    republishStoredInSession(msg.getClientID());
  }
}","public void processConnect(ServerChannel session,ConnectMessage msg){
  LOG.debug(""String_Node_Str"",msg.getClientID());
  if (msg.getProtocolVersion() != VERSION_3_1 && msg.getProtocolVersion() != VERSION_3_1_1) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    LOG.warn(""String_Node_Str"");
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() == 0) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    m_interceptor.notifyClientConnected(msg);
    return;
  }
  if (msg.isUserFlag()) {
    byte[] pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
 else     if (!this.allowAnonymous) {
      failedCredentials(session);
      return;
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      failedCredentials(session);
      return;
    }
    session.setAttribute(NettyChannel.ATTR_KEY_USERNAME,msg.getUsername());
  }
 else   if (!this.allowAnonymous) {
    failedCredentials(session);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    ServerChannel oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(NettyChannel.ATTR_KEY_CLEANSESSION);
    if (cleanSession) {
      cleanSession(msg.getClientID());
    }
    oldSession.setAttribute(NettyChannel.ATTR_KEY_SESSION_STOLEN,true);
    oldSession.close(false);
    LOG.debug(""String_Node_Str"",msg.getClientID());
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  LOG.debug(""String_Node_Str"",keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_KEEPALIVE,keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_CLEANSESSION,msg.isCleanSession());
  session.setAttribute(NettyChannel.ATTR_KEY_CLIENTID,msg.getClientID());
  LOG.debug(""String_Node_Str"",session);
  session.setIdleTime(Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    AbstractMessage.QOSType willQos=AbstractMessage.QOSType.valueOf(msg.getWillQos());
    byte[] willPayload=msg.getWillMessage();
    ByteBuffer bb=(ByteBuffer)ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
    WillMessage will=new WillMessage(msg.getWillTopic(),bb,msg.isWillRetain(),willQos);
    m_willStore.put(msg.getClientID(),will);
  }
  subscriptions.activate(msg.getClientID());
  if (msg.isCleanSession()) {
    cleanSession(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  boolean isSessionAlreadyStored=m_sessionsStore.contains(msg.getClientID());
  if (!msg.isCleanSession() && isSessionAlreadyStored) {
    okResp.setSessionPresent(true);
  }
  session.write(okResp);
  m_interceptor.notifyClientConnected(msg);
  if (!isSessionAlreadyStored) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    m_sessionsStore.createNewSession(msg.getClientID());
  }
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.isCleanSession());
  if (!msg.isCleanSession()) {
    republishStoredInSession(msg.getClientID());
  }
}"
27401,"public void processConnectionLost(LostConnectionEvent evt){
  String clientID=evt.clientID;
  if (m_clientIDs.remove(clientID) != null) {
    subscriptions.deactivate(clientID);
    LOG.info(""String_Node_Str"",clientID);
  }
  if (m_willStore.containsKey(clientID)) {
    WillMessage will=m_willStore.get(clientID);
    forwardPublishWill(will,clientID);
    m_willStore.remove(clientID);
  }
}","public void processConnectionLost(LostConnectionEvent evt){
  String clientID=evt.clientID;
  if (evt.sessionStolen && m_clientIDs.remove(clientID) != null) {
    subscriptions.deactivate(clientID);
    LOG.info(""String_Node_Str"",clientID);
  }
  if (!evt.sessionStolen && m_willStore.containsKey(clientID)) {
    WillMessage will=m_willStore.get(clientID);
    forwardPublishWill(will,clientID);
    m_willStore.remove(clientID);
  }
}"
27402,"public LostConnectionEvent(String clientID){
  this.clientID=clientID;
}","public LostConnectionEvent(String clientID,boolean stolen){
  this.clientID=clientID;
  this.sessionStolen=stolen;
}"
27403,"@Override public void removeMessageInSession(String clientID,Integer messageID){
  List<PublishEvent> events=m_persistentMessageStore.get(clientID);
  PublishEvent toRemoveEvt=null;
  for (  PublishEvent evt : events) {
    if (evt.getMessageID() == null && messageID == null) {
      toRemoveEvt=evt;
    }
    if (evt.getMessageID() == messageID) {
      toRemoveEvt=evt;
    }
  }
  events.remove(toRemoveEvt);
  m_persistentMessageStore.put(clientID,events);
}","@Override public void removeMessageInSession(String clientID,Integer messageID){
  List<PublishEvent> events=m_persistentMessageStore.get(clientID);
  if (events == null) {
    return;
  }
  PublishEvent toRemoveEvt=null;
  for (  PublishEvent evt : events) {
    if (evt.getMessageID() == null && messageID == null) {
      toRemoveEvt=evt;
    }
    if (evt.getMessageID() == messageID) {
      toRemoveEvt=evt;
    }
  }
  events.remove(toRemoveEvt);
  m_persistentMessageStore.put(clientID,events);
}"
27404,"@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",sslHandler);
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
  pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",handler);
}","@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",sslHandlerFactory.create());
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
  pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",handler);
}"
27405,"private void initializeWSSTransport(IMessaging messaging,IConfig props,final SslHandler sslHandler) throws IOException {
  String sslPortProp=props.getProperty(Constants.WSS_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(Constants.HOST_PROPERTY_NAME);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",sslHandler);
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWSSTransport(IMessaging messaging,IConfig props,final SslHandlerFactory sslHandlerFactory) throws IOException {
  String sslPortProp=props.getProperty(Constants.WSS_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(Constants.HOST_PROPERTY_NAME);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",sslHandlerFactory.create());
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27406,"private void initializeSSLTCPTransport(IMessaging messaging,IConfig props,final SslHandler sslHandler) throws IOException {
  String sslPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(Constants.HOST_PROPERTY_NAME);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",sslHandler);
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeSSLTCPTransport(IMessaging messaging,IConfig props,final SslHandlerFactory sslHandlerFactory) throws IOException {
  String sslPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(Constants.HOST_PROPERTY_NAME);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",sslHandlerFactory.create());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27407,"@Override public void initialize(IMessaging messaging,IConfig props) throws IOException {
  m_bossGroup=new NioEventLoopGroup();
  m_workerGroup=new NioEventLoopGroup();
  initializePlainTCPTransport(messaging,props);
  initializeWebSocketTransport(messaging,props);
  String sslTcpPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(Constants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SslHandler sslHandler=initSSLHandler(props);
    if (sslHandler == null) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(messaging,props,sslHandler);
    initializeWSSTransport(messaging,props,sslHandler);
  }
}","@Override public void initialize(IMessaging messaging,IConfig props) throws IOException {
  m_bossGroup=new NioEventLoopGroup();
  m_workerGroup=new NioEventLoopGroup();
  initializePlainTCPTransport(messaging,props);
  initializeWebSocketTransport(messaging,props);
  String sslTcpPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(Constants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SslHandlerFactory sslHandlerFactory=initSSLHandlerFactory(props);
    if (!sslHandlerFactory.canCreate()) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(messaging,props,sslHandlerFactory);
    initializeWSSTransport(messaging,props,sslHandlerFactory);
  }
}"
27408,"@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",sslHandler);
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
  pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",handler);
}","@Override void init(ChannelPipeline pipeline) throws Exception {
  pipeline.addLast(""String_Node_Str"",sslHandler);
  pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
  pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
  pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
  pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
  pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
  pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
  pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
  pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
  pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
  pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
  pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
  pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
  pipeline.addLast(""String_Node_Str"",handler);
}"
27409,"private SslHandler initSSLHandler(int sslPort,Properties props){
  final String jksPath=props.getProperty(Constants.JKS_PATH_PROPERTY_NAME);
  LOG.info(""String_Node_Str"",sslPort,jksPath);
  if (jksPath == null || jksPath.isEmpty()) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  final String keyStorePassword=props.getProperty(Constants.KEY_STORE_PASSWORD_PROPERTY_NAME);
  final String keyManagerPassword=props.getProperty(Constants.KEY_MANAGER_PASSWORD_PROPERTY_NAME);
  if (keyStorePassword == null || keyStorePassword.isEmpty()) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  if (keyManagerPassword == null || keyManagerPassword.isEmpty()) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  LOG.info(""String_Node_Str"",sslPort,jksPath);
  try {
    InputStream jksInputStream=jksDatastore(jksPath);
    SSLContext serverContext=SSLContext.getInstance(""String_Node_Str"");
    final KeyStore ks=KeyStore.getInstance(""String_Node_Str"");
    ks.load(jksInputStream,keyStorePassword.toCharArray());
    final KeyManagerFactory kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(ks,keyManagerPassword.toCharArray());
    serverContext.init(kmf.getKeyManagers(),null,null);
    SSLEngine engine=serverContext.createSSLEngine();
    engine.setUseClientMode(false);
    return new SslHandler(engine);
  }
 catch (  NoSuchAlgorithmException|UnrecoverableKeyException|CertificateException|KeyStoreException|KeyManagementException|IOException ex) {
    LOG.error(""String_Node_Str"",ex);
    return null;
  }
}","private SslHandler initSSLHandler(Properties props){
  final String jksPath=props.getProperty(Constants.JKS_PATH_PROPERTY_NAME);
  LOG.info(""String_Node_Str"",jksPath);
  if (jksPath == null || jksPath.isEmpty()) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  final String keyStorePassword=props.getProperty(Constants.KEY_STORE_PASSWORD_PROPERTY_NAME);
  final String keyManagerPassword=props.getProperty(Constants.KEY_MANAGER_PASSWORD_PROPERTY_NAME);
  if (keyStorePassword == null || keyStorePassword.isEmpty()) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  if (keyManagerPassword == null || keyManagerPassword.isEmpty()) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  try {
    InputStream jksInputStream=jksDatastore(jksPath);
    SSLContext serverContext=SSLContext.getInstance(""String_Node_Str"");
    final KeyStore ks=KeyStore.getInstance(""String_Node_Str"");
    ks.load(jksInputStream,keyStorePassword.toCharArray());
    final KeyManagerFactory kmf=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(ks,keyManagerPassword.toCharArray());
    serverContext.init(kmf.getKeyManagers(),null,null);
    SSLEngine engine=serverContext.createSSLEngine();
    engine.setUseClientMode(false);
    return new SslHandler(engine);
  }
 catch (  NoSuchAlgorithmException|UnrecoverableKeyException|CertificateException|KeyStoreException|KeyManagementException|IOException ex) {
    LOG.error(""String_Node_Str"",ex);
    return null;
  }
}"
27410,"private void initializeSSLTCPTransport(IMessaging messaging,Properties props) throws IOException {
  String sslPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  final SslHandler sslHandler=initSSLHandler(sslPort,props);
  if (sslHandler == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(Constants.HOST_PROPERTY_NAME);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",sslHandler);
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeSSLTCPTransport(IMessaging messaging,Properties props,final SslHandler sslHandler) throws IOException {
  String sslPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  if (sslPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int sslPort=Integer.parseInt(sslPortProp);
  LOG.info(""String_Node_Str"",sslPort);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(Constants.HOST_PROPERTY_NAME);
  initFactory(host,sslPort,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline) throws Exception {
      pipeline.addLast(""String_Node_Str"",sslHandler);
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addFirst(""String_Node_Str"",new BytesMetricsHandler(m_bytesMetricsCollector));
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27411,"@Override public void initialize(IMessaging messaging,Properties props) throws IOException {
  m_bossGroup=new NioEventLoopGroup();
  m_workerGroup=new NioEventLoopGroup();
  initializePlainTCPTransport(messaging,props);
  initializeWebSocketTransport(messaging,props);
  initializeSSLTCPTransport(messaging,props);
}","@Override public void initialize(IMessaging messaging,Properties props) throws IOException {
  m_bossGroup=new NioEventLoopGroup();
  m_workerGroup=new NioEventLoopGroup();
  initializePlainTCPTransport(messaging,props);
  initializeWebSocketTransport(messaging,props);
  String sslTcpPortProp=props.getProperty(Constants.SSL_PORT_PROPERTY_NAME);
  String wssPortProp=props.getProperty(Constants.WSS_PORT_PROPERTY_NAME);
  if (sslTcpPortProp != null || wssPortProp != null) {
    SslHandler sslHandler=initSSLHandler(props);
    if (sslHandler == null) {
      LOG.error(""String_Node_Str"");
      return;
    }
    initializeSSLTCPTransport(messaging,props,sslHandler);
    initializeWSSTransport(messaging,props,sslHandler);
  }
}"
27412,"void removeMessageInSession(String clientID,int packetID);","void removeMessageInSession(String clientID,Integer packetID);"
27413,"@Override public void removeMessageInSession(String clientID,int messageID){
  List<PublishEvent> events=m_persistentMessageStore.get(clientID);
  PublishEvent toRemoveEvt=null;
  for (  PublishEvent evt : events) {
    if (evt.getMessageID() == messageID) {
      toRemoveEvt=evt;
    }
  }
  events.remove(toRemoveEvt);
  m_persistentMessageStore.put(clientID,events);
}","@Override public void removeMessageInSession(String clientID,Integer messageID){
  List<PublishEvent> events=m_persistentMessageStore.get(clientID);
  PublishEvent toRemoveEvt=null;
  for (  PublishEvent evt : events) {
    if (evt.getMessageID() == null && messageID == null) {
      toRemoveEvt=evt;
    }
    if (evt.getMessageID() == messageID) {
      toRemoveEvt=evt;
    }
  }
  events.remove(toRemoveEvt);
  m_persistentMessageStore.put(clientID,events);
}"
27414,"@MQTTMessage(message=ConnectMessage.class) void processConnect(ServerChannel session,ConnectMessage msg){
  LOG.debug(""String_Node_Str"",msg.getClientID());
  if (msg.getProcotolVersion() != VERSION_3_1 && msg.getProcotolVersion() != VERSION_3_1_1) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    LOG.warn(""String_Node_Str"");
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() == 0) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    ServerChannel oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(NettyChannel.ATTR_KEY_CLEANSESSION);
    if (cleanSession) {
      cleanSession(msg.getClientID());
    }
    oldSession.close(false);
    LOG.debug(""String_Node_Str"",msg.getClientID());
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  LOG.debug(""String_Node_Str"",keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_KEEPALIVE,keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_CLEANSESSION,msg.isCleanSession());
  session.setAttribute(NettyChannel.ATTR_KEY_CLIENTID,msg.getClientID());
  LOG.debug(""String_Node_Str"",session);
  session.setIdleTime(Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    AbstractMessage.QOSType willQos=AbstractMessage.QOSType.values()[msg.getWillQos()];
    byte[] willPayload=msg.getWillMessage().getBytes();
    ByteBuffer bb=(ByteBuffer)ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
    WillMessage will=new WillMessage(msg.getWillTopic(),bb,msg.isWillRetain(),willQos);
    m_willStore.put(msg.getClientID(),will);
  }
  if (msg.isUserFlag()) {
    String pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
 else     if (!this.allowAnonymous) {
      failedCredetials(session);
      return;
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      failedCredetials(session);
      return;
    }
    session.setAttribute(NettyChannel.ATTR_KEY_USERNAME,msg.getUsername());
  }
 else   if (!this.allowAnonymous) {
    failedCredetials(session);
    return;
  }
  subscriptions.activate(msg.getClientID());
  if (msg.isCleanSession()) {
    cleanSession(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  if (!msg.isCleanSession() && m_sessionsStore.contains(msg.getClientID())) {
    okResp.setSessionPresent(true);
  }
  session.write(okResp);
  LOG.info(""String_Node_Str"",msg.getClientID());
  m_sessionsStore.addNewSubscription(Subscription.createEmptySubscription(msg.getClientID(),true),msg.getClientID());
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.isCleanSession());
  if (!msg.isCleanSession()) {
    republishStoredInSession(msg.getClientID());
  }
}","@MQTTMessage(message=ConnectMessage.class) void processConnect(ServerChannel session,ConnectMessage msg){
  LOG.debug(""String_Node_Str"",msg.getClientID());
  if (msg.getProcotolVersion() != VERSION_3_1 && msg.getProcotolVersion() != VERSION_3_1_1) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    LOG.warn(""String_Node_Str"");
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() == 0) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    ServerChannel oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(NettyChannel.ATTR_KEY_CLEANSESSION);
    if (cleanSession) {
      cleanSession(msg.getClientID());
    }
    oldSession.close(false);
    LOG.debug(""String_Node_Str"",msg.getClientID());
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  LOG.debug(""String_Node_Str"",keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_KEEPALIVE,keepAlive);
  session.setAttribute(NettyChannel.ATTR_KEY_CLEANSESSION,msg.isCleanSession());
  session.setAttribute(NettyChannel.ATTR_KEY_CLIENTID,msg.getClientID());
  LOG.debug(""String_Node_Str"",session);
  session.setIdleTime(Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    AbstractMessage.QOSType willQos=AbstractMessage.QOSType.values()[msg.getWillQos()];
    byte[] willPayload=msg.getWillMessage().getBytes();
    ByteBuffer bb=(ByteBuffer)ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
    WillMessage will=new WillMessage(msg.getWillTopic(),bb,msg.isWillRetain(),willQos);
    m_willStore.put(msg.getClientID(),will);
  }
  if (msg.isUserFlag()) {
    String pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
 else     if (!this.allowAnonymous) {
      failedCredentials(session);
      return;
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      failedCredentials(session);
      return;
    }
    session.setAttribute(NettyChannel.ATTR_KEY_USERNAME,msg.getUsername());
  }
 else   if (!this.allowAnonymous) {
    failedCredentials(session);
    return;
  }
  subscriptions.activate(msg.getClientID());
  if (msg.isCleanSession()) {
    cleanSession(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  if (!msg.isCleanSession() && m_sessionsStore.contains(msg.getClientID())) {
    okResp.setSessionPresent(true);
  }
  session.write(okResp);
  LOG.info(""String_Node_Str"",msg.getClientID());
  m_sessionsStore.addNewSubscription(Subscription.createEmptySubscription(msg.getClientID(),true),msg.getClientID());
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.isCleanSession());
  if (!msg.isCleanSession()) {
    republishStoredInSession(msg.getClientID());
  }
}"
27415,"public int getMessageID(){
  return m_msgID;
}","public Integer getMessageID(){
  return m_msgID;
}"
27416,"public int getMessageID(){
  return m_msgID;
}","public Integer getMessageID(){
  return m_msgID;
}"
27417,"@Override public void removeMessageInSession(String clientID,int messageID){
  List<StoredPublishEvent> events=m_persistentMessageStore.get(clientID);
  if (events == null) {
    return;
  }
  StoredPublishEvent toRemoveEvt=null;
  for (  StoredPublishEvent evt : events) {
    if (evt.getMessageID() == messageID) {
      toRemoveEvt=evt;
    }
  }
  events.remove(toRemoveEvt);
  m_persistentMessageStore.put(clientID,events);
  m_db.commit();
}","@Override public void removeMessageInSession(String clientID,Integer messageID){
  List<StoredPublishEvent> events=m_persistentMessageStore.get(clientID);
  if (events == null) {
    return;
  }
  StoredPublishEvent toRemoveEvt=null;
  for (  StoredPublishEvent evt : events) {
    if (evt.getMessageID() == null && messageID == null) {
      toRemoveEvt=evt;
    }
    if (evt.getMessageID() == messageID) {
      toRemoveEvt=evt;
    }
  }
  events.remove(toRemoveEvt);
  m_persistentMessageStore.put(clientID,events);
  m_db.commit();
}"
27418,"public BytesMetrics computeMetrics(){
  BytesMetrics allMetrics=new BytesMetrics();
  for (  BytesMetrics m : m_allMetrics) {
    allMetrics.incrementRead(m.readBytes());
    allMetrics.incrementWrote(m.wroteBytes());
  }
  return allMetrics;
}","public BytesMetrics computeMetrics(){
  BytesMetrics allMetrics=new BytesMetrics();
  allMetrics.incrementRead(readBytes.get());
  allMetrics.incrementWrote(wroteBytes.get());
  return allMetrics;
}"
27419,"@Override public void close(ChannelHandlerContext ctx,ChannelPromise promise) throws Exception {
  BytesMetrics metrics=ctx.attr(ATTR_KEY_METRICS).get();
  m_collector.addMetrics(metrics);
  super.close(ctx,promise);
}","@Override public void close(ChannelHandlerContext ctx,ChannelPromise promise) throws Exception {
  BytesMetrics metrics=ctx.attr(ATTR_KEY_METRICS).get();
  m_collector.sumReadBytes(metrics.readBytes());
  m_collector.sumWroteBytes(metrics.wroteBytes());
  super.close(ctx,promise);
}"
27420,"public MessageMetrics computeMetrics(){
  MessageMetrics allMetrics=new MessageMetrics();
  for (  MessageMetrics m : m_allMetrics) {
    allMetrics.incrementRead(m.messagesRead());
    allMetrics.incrementWrote(m.messagesWrote());
  }
  return allMetrics;
}","public MessageMetrics computeMetrics(){
  MessageMetrics allMetrics=new MessageMetrics();
  allMetrics.incrementRead(readMsgs.get());
  allMetrics.incrementWrote(wroteMsgs.get());
  return allMetrics;
}"
27421,"@Override public void close(ChannelHandlerContext ctx,ChannelPromise promise) throws Exception {
  MessageMetrics metrics=ctx.attr(ATTR_KEY_METRICS).get();
  m_collector.addMetrics(metrics);
  super.close(ctx,promise);
}","@Override public void close(ChannelHandlerContext ctx,ChannelPromise promise) throws Exception {
  MessageMetrics metrics=ctx.attr(ATTR_KEY_METRICS).get();
  m_collector.sumReadMessages(metrics.messagesRead());
  m_collector.sumWroteMessages(metrics.messagesWrote());
  super.close(ctx,promise);
}"
27422,"@Override protected void encode(ChannelHandlerContext ctx,PublishMessage message,ByteBuf out){
  if (message.getQos() == AbstractMessage.QOSType.RESERVED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getTopicName() == null || message.getTopicName().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ByteBuf variableHeaderBuff=ctx.alloc().buffer(2);
  try {
    variableHeaderBuff.writeBytes(Utils.encodeString(message.getTopicName()));
    if (message.getQos() == AbstractMessage.QOSType.LEAST_ONE || message.getQos() == AbstractMessage.QOSType.EXACTLY_ONCE) {
      if (message.getMessageID() == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      variableHeaderBuff.writeShort(message.getMessageID());
    }
    variableHeaderBuff.writeBytes(message.getPayload());
    int variableHeaderSize=variableHeaderBuff.readableBytes();
    byte flags=Utils.encodeFlags(message);
    ByteBuf buff=ctx.alloc().buffer(2 + variableHeaderSize);
    buff.writeByte(AbstractMessage.PUBLISH << 4 | flags);
    buff.writeBytes(Utils.encodeRemainingLength(variableHeaderSize));
    buff.writeBytes(variableHeaderBuff);
    out.writeBytes(buff);
  }
  finally {
    variableHeaderBuff.release();
  }
}","@Override protected void encode(ChannelHandlerContext ctx,PublishMessage message,ByteBuf out){
  if (message.getQos() == AbstractMessage.QOSType.RESERVED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getTopicName() == null || message.getTopicName().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ByteBuf variableHeaderBuff=ctx.alloc().buffer(2);
  ByteBuf buff=null;
  try {
    variableHeaderBuff.writeBytes(Utils.encodeString(message.getTopicName()));
    if (message.getQos() == AbstractMessage.QOSType.LEAST_ONE || message.getQos() == AbstractMessage.QOSType.EXACTLY_ONCE) {
      if (message.getMessageID() == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      variableHeaderBuff.writeShort(message.getMessageID());
    }
    variableHeaderBuff.writeBytes(message.getPayload());
    int variableHeaderSize=variableHeaderBuff.readableBytes();
    byte flags=Utils.encodeFlags(message);
    buff=ctx.alloc().buffer(2 + variableHeaderSize);
    buff.writeByte(AbstractMessage.PUBLISH << 4 | flags);
    buff.writeBytes(Utils.encodeRemainingLength(variableHeaderSize));
    buff.writeBytes(variableHeaderBuff);
    out.writeBytes(buff);
  }
  finally {
    variableHeaderBuff.release();
    if (buff != null) {
      buff.release();
    }
  }
}"
27423,"/** 
 * Return the next valid packetIdentifer for the given client session.
 */
@Override public int nextPacketID(String clientID){
  Set<Integer> inFlightForClient=this.m_inFlightIds.get(clientID);
  if (inFlightForClient == null) {
    int nextPacketId=1;
    inFlightForClient=new HashSet<>();
    inFlightForClient.add(nextPacketId);
    this.m_inFlightIds.put(clientID,inFlightForClient);
    return nextPacketId;
  }
  int maxId=Collections.max(inFlightForClient);
  int nextPacketId=(maxId + 1) % 0xFFFF;
  inFlightForClient.add(nextPacketId);
  return nextPacketId;
}","/** 
 * Return the next valid packetIdentifier for the given client session.
 */
@Override public int nextPacketID(String clientID){
  Set<Integer> inFlightForClient=this.m_inFlightIds.get(clientID);
  if (inFlightForClient == null) {
    int nextPacketId=1;
    inFlightForClient=new HashSet<>();
    inFlightForClient.add(nextPacketId);
    this.m_inFlightIds.put(clientID,inFlightForClient);
    return nextPacketId;
  }
  int maxId=inFlightForClient.isEmpty() ? 0 : Collections.max(inFlightForClient);
  int nextPacketId=(maxId + 1) % 0xFFFF;
  inFlightForClient.add(nextPacketId);
  return nextPacketId;
}"
27424,"@Override public List<PublishEvent> retrievePersistedPublishes(String clientID){
  return m_persistentMessageStore.get(clientID);
}","@Override public List<PublishEvent> retrievePersistedPublishes(String clientID){
  return new ArrayList<>(m_persistentMessageStore.get(clientID));
}"
27425,"private void republishStored(String clientID){
  LOG.trace(""String_Node_Str"");
  List<PublishEvent> publishedEvents=m_messagesStore.retrievePersistedPublishes(clientID);
  if (publishedEvents == null) {
    LOG.info(""String_Node_Str"",clientID);
    return;
  }
  LOG.info(""String_Node_Str"",clientID);
  for (  PublishEvent pubEvt : publishedEvents) {
    sendPublish(pubEvt.getClientID(),pubEvt.getTopic(),pubEvt.getQos(),pubEvt.getMessage(),false,pubEvt.getMessageID());
  }
}","private void republishStored(String clientID){
  LOG.trace(""String_Node_Str"");
  List<PublishEvent> publishedEvents=m_messagesStore.retrievePersistedPublishes(clientID);
  if (publishedEvents == null) {
    LOG.info(""String_Node_Str"",clientID);
    return;
  }
  LOG.info(""String_Node_Str"",clientID);
  for (  PublishEvent pubEvt : publishedEvents) {
    sendPublish(pubEvt.getClientID(),pubEvt.getTopic(),pubEvt.getQos(),pubEvt.getMessage(),false,pubEvt.getMessageID());
    m_messagesStore.cleanPersistedPublishMessage(clientID,pubEvt.getMessageID());
  }
}"
27426,"public void removeQoS2Message(String publishKey){
  m_qos2Store.remove(publishKey);
}","public void removeQoS2Message(String publishKey){
  LOG.debug(""String_Node_Str"",publishKey);
  m_qos2Store.remove(publishKey);
}"
27427,"@Override public void onEvent(ValueEvent t,long l,boolean bln) throws Exception {
  MessagingEvent evt=t.getEvent();
  LOG.info(""String_Node_Str"",evt);
  if (evt instanceof StopEvent) {
    processStop();
    return;
  }
  if (evt instanceof LostConnectionEvent) {
    LostConnectionEvent lostEvt=(LostConnectionEvent)evt;
    m_processor.processConnectionLost(lostEvt);
    return;
  }
  if (evt instanceof ProtocolEvent) {
    ServerChannel session=((ProtocolEvent)evt).getSession();
    AbstractMessage message=((ProtocolEvent)evt).getMessage();
    annotationSupport.dispatch(session,message);
  }
}","@Override public void onEvent(ValueEvent t,long l,boolean bln) throws Exception {
  MessagingEvent evt=t.getEvent();
  LOG.info(""String_Node_Str"",evt);
  if (evt instanceof StopEvent) {
    processStop();
    return;
  }
  if (evt instanceof LostConnectionEvent) {
    LostConnectionEvent lostEvt=(LostConnectionEvent)evt;
    m_processor.processConnectionLost(lostEvt);
    return;
  }
  if (evt instanceof ProtocolEvent) {
    ServerChannel session=((ProtocolEvent)evt).getSession();
    AbstractMessage message=((ProtocolEvent)evt).getMessage();
    try {
      annotationSupport.dispatch(session,message);
    }
 catch (    Throwable th) {
      LOG.error(""String_Node_Str"",message,session,th);
    }
  }
}"
27428,"@Override protected void encode(ChannelHandlerContext chc,ByteBuf bb,List<Object> out) throws Exception {
  BinaryWebSocketFrame result=new BinaryWebSocketFrame(bb);
  out.add(bb);
}","@Override protected void encode(ChannelHandlerContext chc,ByteBuf bb,List<Object> out) throws Exception {
  BinaryWebSocketFrame result=new BinaryWebSocketFrame();
  System.out.println(""String_Node_Str"" + ByteBufUtil.hexDump(bb));
  result.content().writeBytes(bb);
  out.add(result);
}"
27429,"private void initializeWebSocketTransport(IMessaging messaging,Properties props) throws IOException {
  String webSocketPortProp=props.getProperty(""String_Node_Str"");
  if (webSocketPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(""String_Node_Str"");
  initFactory(host,port,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}","private void initializeWebSocketTransport(IMessaging messaging,Properties props) throws IOException {
  String webSocketPortProp=props.getProperty(""String_Node_Str"");
  if (webSocketPortProp == null) {
    LOG.info(""String_Node_Str"");
    return;
  }
  int port=Integer.parseInt(webSocketPortProp);
  final NettyMQTTHandler handler=new NettyMQTTHandler();
  handler.setMessaging(messaging);
  String host=props.getProperty(""String_Node_Str"");
  initFactory(host,port,new PipelineInitializer(){
    @Override void init(    ChannelPipeline pipeline){
      pipeline.addLast(""String_Node_Str"",new HttpResponseEncoder());
      pipeline.addLast(""String_Node_Str"",new HttpRequestDecoder());
      pipeline.addLast(""String_Node_Str"",new HttpObjectAggregator(65536));
      pipeline.addLast(""String_Node_Str"",new WebSocketServerProtocolHandler(""String_Node_Str"",""String_Node_Str""));
      pipeline.addLast(""String_Node_Str"",new WebSocketFrameToByteBufDecoder());
      pipeline.addLast(""String_Node_Str"",new ByteBufToWebSocketFrameEncoder());
      pipeline.addFirst(""String_Node_Str"",new IdleStateHandler(0,0,Constants.DEFAULT_CONNECT_TIMEOUT));
      pipeline.addAfter(""String_Node_Str"",""String_Node_Str"",new MoquetteIdleTimoutHandler());
      pipeline.addLast(""String_Node_Str"",new MQTTDecoder());
      pipeline.addLast(""String_Node_Str"",new MQTTEncoder());
      pipeline.addLast(""String_Node_Str"",new MessageMetricsHandler(m_metricsCollector));
      pipeline.addLast(""String_Node_Str"",handler);
    }
  }
);
}"
27430,"@Override protected void decode(ChannelHandlerContext chc,BinaryWebSocketFrame frame,List<Object> out) throws Exception {
  ByteBuf bb=frame.content();
  out.add(bb);
}","@Override protected void decode(ChannelHandlerContext chc,BinaryWebSocketFrame frame,List<Object> out) throws Exception {
  ByteBuf bb=frame.content();
  System.out.println(""String_Node_Str"" + ByteBufUtil.hexDump(bb));
  bb.retain();
  out.add(bb);
}"
27431,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  NettyChannel channel=m_channelMapper.get(ctx);
  String clientID=(String)channel.getAttribute(Constants.ATTR_CLIENTID);
  m_messaging.lostConnection(clientID);
  ctx.close();
synchronized (m_channelMapper) {
    m_channelMapper.remove(ctx);
  }
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  NettyChannel channel=m_channelMapper.get(ctx);
  String clientID=(String)channel.getAttribute(Constants.ATTR_CLIENTID);
  m_messaging.lostConnection(channel,clientID);
  ctx.close();
synchronized (m_channelMapper) {
    m_channelMapper.remove(ctx);
  }
}"
27432,void lostConnection(String clientID);,"void lostConnection(ServerChannel session,String clientID);"
27433,"@MQTTMessage(message=ConnectMessage.class) void processConnect(ServerChannel session,ConnectMessage msg){
  LOG.debug(""String_Node_Str"",msg.getClientID());
  if (msg.getProcotolVersion() != VERSION_3_1 && msg.getProcotolVersion() != VERSION_3_1_1) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    LOG.warn(""String_Node_Str"");
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() > 23 || msg.getClientID().length() == 0) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    ServerChannel oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(Constants.CLEAN_SESSION);
    if (cleanSession) {
      cleanSession(msg.getClientID());
    }
    m_clientIDs.get(msg.getClientID()).getSession().close(false);
    LOG.info(""String_Node_Str"",msg.getClientID());
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  LOG.debug(""String_Node_Str"",keepAlive);
  session.setAttribute(Constants.KEEP_ALIVE,keepAlive);
  session.setAttribute(Constants.CLEAN_SESSION,msg.isCleanSession());
  session.setAttribute(Constants.ATTR_CLIENTID,msg.getClientID());
  session.setIdleTime(Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    AbstractMessage.QOSType willQos=AbstractMessage.QOSType.values()[msg.getWillQos()];
    byte[] willPayload=msg.getWillMessage().getBytes();
    ByteBuffer bb=(ByteBuffer)ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
    WillMessage will=new WillMessage(msg.getWillTopic(),bb,msg.isWillRetain(),willQos);
    m_willStore.put(msg.getClientID(),will);
  }
  if (msg.isUserFlag()) {
    String pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      ConnAckMessage okResp=new ConnAckMessage();
      okResp.setReturnCode(ConnAckMessage.BAD_USERNAME_OR_PASSWORD);
      session.write(okResp);
      return;
    }
  }
  subscriptions.activate(msg.getClientID());
  if (msg.isCleanSession()) {
    cleanSession(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  if (!msg.isCleanSession() && m_sessionsStore.contains(msg.getClientID())) {
    okResp.setSessionPresent(true);
  }
  LOG.debug(""String_Node_Str"");
  session.write(okResp);
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.isCleanSession());
  LOG.info(""String_Node_Str"",msg.getClientID());
  m_sessionsStore.addNewSubscription(Subscription.createEmptySubscription(msg.getClientID(),true),msg.getClientID());
  if (!msg.isCleanSession()) {
    republishStored(msg.getClientID());
  }
}","@MQTTMessage(message=ConnectMessage.class) void processConnect(ServerChannel session,ConnectMessage msg){
  LOG.debug(""String_Node_Str"",msg.getClientID());
  if (msg.getProcotolVersion() != VERSION_3_1 && msg.getProcotolVersion() != VERSION_3_1_1) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    LOG.warn(""String_Node_Str"");
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() > 23 || msg.getClientID().length() == 0) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    LOG.info(""String_Node_Str"",msg.getClientID());
    ServerChannel oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(Constants.CLEAN_SESSION);
    if (cleanSession) {
      cleanSession(msg.getClientID());
    }
    oldSession.close(false);
    LOG.debug(""String_Node_Str"",msg.getClientID());
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  LOG.debug(""String_Node_Str"",keepAlive);
  session.setAttribute(Constants.KEEP_ALIVE,keepAlive);
  session.setAttribute(Constants.CLEAN_SESSION,msg.isCleanSession());
  session.setAttribute(Constants.ATTR_CLIENTID,msg.getClientID());
  session.setIdleTime(Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    AbstractMessage.QOSType willQos=AbstractMessage.QOSType.values()[msg.getWillQos()];
    byte[] willPayload=msg.getWillMessage().getBytes();
    ByteBuffer bb=(ByteBuffer)ByteBuffer.allocate(willPayload.length).put(willPayload).flip();
    WillMessage will=new WillMessage(msg.getWillTopic(),bb,msg.isWillRetain(),willQos);
    m_willStore.put(msg.getClientID(),will);
  }
  if (msg.isUserFlag()) {
    String pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      ConnAckMessage okResp=new ConnAckMessage();
      okResp.setReturnCode(ConnAckMessage.BAD_USERNAME_OR_PASSWORD);
      session.write(okResp);
      return;
    }
  }
  subscriptions.activate(msg.getClientID());
  if (msg.isCleanSession()) {
    cleanSession(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  if (!msg.isCleanSession() && m_sessionsStore.contains(msg.getClientID())) {
    okResp.setSessionPresent(true);
  }
  LOG.debug(""String_Node_Str"");
  session.write(okResp);
  LOG.info(""String_Node_Str"",msg.getClientID(),msg.isCleanSession());
  LOG.info(""String_Node_Str"",msg.getClientID());
  m_sessionsStore.addNewSubscription(Subscription.createEmptySubscription(msg.getClientID(),true),msg.getClientID());
  if (!msg.isCleanSession()) {
    republishStored(msg.getClientID());
  }
}"
27434,"void processConnectionLost(String clientID){
  if (m_clientIDs.remove(clientID) != null) {
    subscriptions.deactivate(clientID);
    LOG.info(""String_Node_Str"",clientID);
  }
  if (m_willStore.containsKey(clientID)) {
    WillMessage will=m_willStore.get(clientID);
    processPublish(will,clientID);
    m_willStore.remove(clientID);
  }
}","void processConnectionLost(LostConnectionEvent evt){
  String clientID=evt.clientID;
  if (m_clientIDs.containsKey(clientID)) {
    if (!m_clientIDs.get(clientID).getSession().equals(evt.session)) {
      LOG.info(""String_Node_Str"",clientID);
      return;
    }
  }
  if (m_clientIDs.remove(clientID) != null) {
    subscriptions.deactivate(clientID);
    LOG.info(""String_Node_Str"",clientID);
  }
  if (m_willStore.containsKey(clientID)) {
    WillMessage will=m_willStore.get(clientID);
    processPublish(will,clientID);
    m_willStore.remove(clientID);
  }
}"
27435,"@Override public void lostConnection(String clientID){
  disruptorPublish(new LostConnectionEvent(clientID));
}","@Override public void lostConnection(ServerChannel session,String clientID){
  disruptorPublish(new LostConnectionEvent(session,clientID));
}"
27436,"@Override public void onEvent(ValueEvent t,long l,boolean bln) throws Exception {
  MessagingEvent evt=t.getEvent();
  LOG.info(""String_Node_Str"",evt);
  if (evt instanceof StopEvent) {
    processStop();
    return;
  }
  if (evt instanceof LostConnectionEvent) {
    LostConnectionEvent lostEvt=(LostConnectionEvent)evt;
    m_processor.processConnectionLost(lostEvt.getClientID());
    return;
  }
  if (evt instanceof ProtocolEvent) {
    ServerChannel session=((ProtocolEvent)evt).getSession();
    AbstractMessage message=((ProtocolEvent)evt).getMessage();
    annotationSupport.dispatch(session,message);
  }
}","@Override public void onEvent(ValueEvent t,long l,boolean bln) throws Exception {
  MessagingEvent evt=t.getEvent();
  LOG.info(""String_Node_Str"",evt);
  if (evt instanceof StopEvent) {
    processStop();
    return;
  }
  if (evt instanceof LostConnectionEvent) {
    LostConnectionEvent lostEvt=(LostConnectionEvent)evt;
    m_processor.processConnectionLost(lostEvt);
    return;
  }
  if (evt instanceof ProtocolEvent) {
    ServerChannel session=((ProtocolEvent)evt).getSession();
    AbstractMessage message=((ProtocolEvent)evt).getMessage();
    annotationSupport.dispatch(session,message);
  }
}"
27437,"public LostConnectionEvent(String clienID){
  m_clientID=clienID;
}","public LostConnectionEvent(ServerChannel session,String clientID){
  this.session=session;
  this.clientID=clientID;
}"
27438,"/** 
 * Verify if the 2 topics matching respecting the rules of MQTT Appendix A
 */
public static boolean matchTopics(String msgTopic,String subscriptionTopic){
  try {
    List<Token> msgTokens=SubscriptionsStore.splitTopic(msgTopic);
    List<Token> subscriptionTokens=SubscriptionsStore.splitTopic(subscriptionTopic);
    int i=0;
    Token subToken=null;
    for (; i < subscriptionTokens.size(); i++) {
      subToken=subscriptionTokens.get(i);
      if (subToken != Token.MULTI && subToken != Token.SINGLE) {
        if (i >= msgTokens.size()) {
          return false;
        }
        Token msgToken=msgTokens.get(i);
        if (!msgToken.equals(subToken)) {
          return false;
        }
      }
 else {
        if (subToken == Token.MULTI) {
          return true;
        }
        if (subToken == Token.SINGLE) {
        }
      }
    }
    if (subToken == Token.SINGLE && (i - msgTokens.size() == 1)) {
      i--;
    }
    return i == msgTokens.size();
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    throw new RuntimeException(ex);
  }
}","/** 
 * Verify if the 2 topics matching respecting the rules of MQTT Appendix A
 */
public static boolean matchTopics(String msgTopic,String subscriptionTopic){
  try {
    List<Token> msgTokens=SubscriptionsStore.splitTopic(msgTopic);
    List<Token> subscriptionTokens=SubscriptionsStore.splitTopic(subscriptionTopic);
    int i=0;
    Token subToken=null;
    for (; i < subscriptionTokens.size(); i++) {
      subToken=subscriptionTokens.get(i);
      if (subToken != Token.MULTI && subToken != Token.SINGLE) {
        if (i >= msgTokens.size()) {
          return false;
        }
        Token msgToken=msgTokens.get(i);
        if (!msgToken.equals(subToken)) {
          return false;
        }
      }
 else {
        if (subToken == Token.MULTI) {
          return true;
        }
        if (subToken == Token.SINGLE) {
        }
      }
    }
    return i == msgTokens.size();
  }
 catch (  ParseException ex) {
    LOG.error(null,ex);
    throw new RuntimeException(ex);
  }
}"
27439,"protected static List<Token> splitTopic(String topic) throws ParseException {
  List res=new ArrayList<Token>();
  String[] splitted=topic.split(""String_Node_Str"");
  if (splitted.length == 0) {
    res.add(Token.EMPTY);
  }
  for (int i=0; i < splitted.length; i++) {
    String s=splitted[i];
    if (s.isEmpty()) {
      res.add(Token.EMPTY);
    }
 else     if (s.equals(""String_Node_Str"")) {
      if (i != splitted.length - 1) {
        throw new ParseException(""String_Node_Str"",i);
      }
      res.add(Token.MULTI);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else     if (s.equals(""String_Node_Str"")) {
      res.add(Token.SINGLE);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else {
      res.add(new Token(s));
    }
  }
  return res;
}","protected static List<Token> splitTopic(String topic) throws ParseException {
  List res=new ArrayList<Token>();
  String[] splitted=topic.split(""String_Node_Str"");
  if (splitted.length == 0) {
    res.add(Token.EMPTY);
  }
  if (topic.endsWith(""String_Node_Str"")) {
    String[] newSplitted=new String[splitted.length + 1];
    System.arraycopy(splitted,0,newSplitted,0,splitted.length);
    newSplitted[splitted.length]=""String_Node_Str"";
    splitted=newSplitted;
  }
  for (int i=0; i < splitted.length; i++) {
    String s=splitted[i];
    if (s.isEmpty()) {
      res.add(Token.EMPTY);
    }
 else     if (s.equals(""String_Node_Str"")) {
      if (i != splitted.length - 1) {
        throw new ParseException(""String_Node_Str"",i);
      }
      res.add(Token.MULTI);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else     if (s.equals(""String_Node_Str"")) {
      res.add(Token.SINGLE);
    }
 else     if (s.contains(""String_Node_Str"")) {
      throw new ParseException(""String_Node_Str"" + s,i);
    }
 else {
      res.add(new Token(s));
    }
  }
  return res;
}"
27440,"@Test public void testMatchTopics_single(){
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertFalse(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertFalse(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
}","@Test public void testMatchTopics_single(){
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertFalse(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertFalse(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertTrue(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
  assertFalse(SubscriptionsStore.matchTopics(""String_Node_Str"",""String_Node_Str""));
}"
27441,"@Test public void testSplitTopic() throws ParseException {
  List tokens=store.splitTopic(""String_Node_Str"");
  assertEqualsSeq(asArray(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),tokens);
  tokens=store.splitTopic(""String_Node_Str"");
  assertEqualsSeq(asArray(Token.EMPTY,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),tokens);
  tokens=store.splitTopic(""String_Node_Str"");
  assertEqualsSeq(asArray(Token.EMPTY),tokens);
}","@Test public void testSplitTopic() throws ParseException {
  List tokens=store.splitTopic(""String_Node_Str"");
  assertEqualsSeq(asArray(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),tokens);
  tokens=store.splitTopic(""String_Node_Str"");
  assertEqualsSeq(asArray(Token.EMPTY,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),tokens);
  tokens=store.splitTopic(""String_Node_Str"");
  assertEqualsSeq(asArray(Token.EMPTY,Token.EMPTY),tokens);
}"
27442,"private void processInit(Properties props){
  m_storageService=new HawtDBStorageService();
  m_storageService.initStore();
  subscriptions.init(m_storageService);
  String path=props.getProperty(""String_Node_Str"");
  IAuthenticator authenticator=new FileAuthenticator(path);
  m_processor.init(subscriptions,m_storageService,authenticator);
}","private void processInit(Properties props){
  m_storageService=new HawtDBStorageService();
  m_storageService.initStore();
  subscriptions.init(m_storageService);
  String passwdPath=props.getProperty(""String_Node_Str"");
  String configPath=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  IAuthenticator authenticator=new FileAuthenticator(configPath + passwdPath);
  m_processor.init(subscriptions,m_storageService,authenticator);
}"
27443,"public void startServer() throws IOException {
  ConfigurationParser confParser=new ConfigurationParser();
  try {
    confParser.parse(new File(""String_Node_Str""));
  }
 catch (  ParseException pex) {
    LOG.warn(""String_Node_Str"",pex);
  }
  Properties configProps=confParser.getProperties();
  messaging=SimpleMessaging.getInstance();
  messaging.init(configProps);
  m_acceptor=new NettyAcceptor();
  m_acceptor.initialize(messaging,configProps);
}","public void startServer() throws IOException {
  ConfigurationParser confParser=new ConfigurationParser();
  try {
    String configPath=System.getProperty(""String_Node_Str"",""String_Node_Str"");
    confParser.parse(new File(configPath + ""String_Node_Str""));
  }
 catch (  ParseException pex) {
    LOG.warn(""String_Node_Str"",pex);
  }
  Properties configProps=confParser.getProperties();
  messaging=SimpleMessaging.getInstance();
  messaging.init(configProps);
  m_acceptor=new NettyAcceptor();
  m_acceptor.initialize(messaging,configProps);
}"
27444,"@Test public void testPublishToMultipleSubscribers() throws InterruptedException {
  final Subscription subscription=new Subscription(FAKE_CLIENT_ID,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  final Subscription subscriptionClient2=new Subscription(FAKE_CLIENT_ID2,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  SubscriptionsStore subs=new SubscriptionsStore(){
    @Override public List<Subscription> matches(    String topic){
      if (topic.equals(FAKE_TOPIC)) {
        return Arrays.asList(subscription,subscriptionClient2);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + FAKE_TOPIC + ""String_Node_Str""+ topic);
      }
    }
  }
;
  subs.init(m_storageService);
  m_processor.init(subs,m_storageService);
  MockReceiverChannel firstReceiverSession=new MockReceiverChannel();
  ConnectMessage connectMessage=new ConnectMessage();
  connectMessage.setProcotolVersion((byte)3);
  connectMessage.setClientID(FAKE_CLIENT_ID);
  connectMessage.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(firstReceiverSession,connectMessage);
  MockReceiverChannel secondReceiverSession=new MockReceiverChannel();
  ConnectMessage connectMessage2=new ConnectMessage();
  connectMessage2.setProcotolVersion((byte)3);
  connectMessage2.setClientID(FAKE_CLIENT_ID2);
  connectMessage2.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(secondReceiverSession,connectMessage2);
  ByteBuffer buffer=ByteBuffer.allocate(5).put(""String_Node_Str"".getBytes());
  PublishEvent pubEvt=new PublishEvent(FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,buffer,false,""String_Node_Str"",null);
  m_processor.processPublish(pubEvt);
  Thread.sleep(100);
  PublishMessage pub2FirstSubscriber=(PublishMessage)firstReceiverSession.getMessage();
  assertNotNull(pub2FirstSubscriber);
  String firstMessageContent=DebugUtils.payload2Str(pub2FirstSubscriber.getPayload());
  assertEquals(""String_Node_Str"",firstMessageContent);
  PublishMessage pub2SecondSubscriber=(PublishMessage)secondReceiverSession.getMessage();
  assertNotNull(pub2SecondSubscriber);
  String secondMessageContent=DebugUtils.payload2Str(pub2SecondSubscriber.getPayload());
  assertEquals(""String_Node_Str"",secondMessageContent);
}","@Test public void testPublishToMultipleSubscribers() throws InterruptedException {
  final Subscription subscription=new Subscription(FAKE_CLIENT_ID,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  final Subscription subscriptionClient2=new Subscription(FAKE_CLIENT_ID2,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  SubscriptionsStore subs=new SubscriptionsStore(){
    @Override public List<Subscription> matches(    String topic){
      if (topic.equals(FAKE_TOPIC)) {
        return Arrays.asList(subscription,subscriptionClient2);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + FAKE_TOPIC + ""String_Node_Str""+ topic);
      }
    }
  }
;
  subs.init(m_storageService);
  m_processor.init(subs,m_storageService);
  MockReceiverChannel firstReceiverSession=new MockReceiverChannel();
  ConnectMessage connectMessage=new ConnectMessage();
  connectMessage.setProcotolVersion((byte)3);
  connectMessage.setClientID(FAKE_CLIENT_ID);
  connectMessage.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(firstReceiverSession,connectMessage);
  MockReceiverChannel secondReceiverSession=new MockReceiverChannel();
  ConnectMessage connectMessage2=new ConnectMessage();
  connectMessage2.setProcotolVersion((byte)3);
  connectMessage2.setClientID(FAKE_CLIENT_ID2);
  connectMessage2.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(secondReceiverSession,connectMessage2);
  ByteBuffer buffer=ByteBuffer.allocate(5).put(""String_Node_Str"".getBytes());
  buffer.rewind();
  PublishEvent pubEvt=new PublishEvent(FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,buffer,false,""String_Node_Str"",null);
  m_processor.processPublish(pubEvt);
  Thread.sleep(100);
  PublishMessage pub2FirstSubscriber=(PublishMessage)firstReceiverSession.getMessage();
  assertNotNull(pub2FirstSubscriber);
  String firstMessageContent=DebugUtils.payload2Str(pub2FirstSubscriber.getPayload());
  assertEquals(""String_Node_Str"",firstMessageContent);
  PublishMessage pub2SecondSubscriber=(PublishMessage)secondReceiverSession.getMessage();
  assertNotNull(pub2SecondSubscriber);
  String secondMessageContent=DebugUtils.payload2Str(pub2SecondSubscriber.getPayload());
  assertEquals(""String_Node_Str"",secondMessageContent);
}"
27445,"@Override public void userEventTriggered(ChannelHandlerContext ctx,Object evt) throws Exception {
  if (evt instanceof IdleState) {
    IdleState e=(IdleState)evt;
    if (e == IdleState.ALL_IDLE) {
      ctx.close();
    }
  }
}","@Override public void userEventTriggered(ChannelHandlerContext ctx,Object evt) throws Exception {
  if (evt instanceof IdleStateEvent) {
    IdleState e=((IdleStateEvent)evt).state();
    if (e == IdleState.ALL_IDLE) {
      ctx.close();
    }
  }
}"
27446,"@After public void tearDown(){
  File dbFile=new File(Server.STORAGE_FILE_PATH);
  if (dbFile.exists()) {
    dbFile.delete();
  }
  assertFalse(dbFile.exists());
}","@After public void tearDown(){
  if (m_storageService != null) {
    m_storageService.close();
  }
  File dbFile=new File(Server.STORAGE_FILE_PATH);
  if (dbFile.exists()) {
    dbFile.delete();
  }
  assertFalse(dbFile.exists());
}"
27447,"@Override public void channelRead(ChannelHandlerContext ctx,Object message){
  AbstractMessage msg=(AbstractMessage)message;
  LOG.info(""String_Node_Str"",Utils.msgType2String(msg.getMessageType()));
  try {
switch (msg.getMessageType()) {
case CONNECT:
case SUBSCRIBE:
case UNSUBSCRIBE:
case PUBLISH:
case PUBREC:
case PUBCOMP:
case PUBREL:
case DISCONNECT:
case PUBACK:
      NettyChannel channel;
synchronized (m_channelMapper) {
      if (!m_channelMapper.containsKey(ctx)) {
        m_channelMapper.put(ctx,new NettyChannel(ctx));
      }
      channel=m_channelMapper.get(ctx);
    }
  m_messaging.handleProtocolMessage(channel,msg);
break;
case PINGREQ:
PingRespMessage pingResp=new PingRespMessage();
ctx.write(pingResp);
break;
}
}
 catch (Exception ex) {
LOG.error(""String_Node_Str"",ex);
}
}","@Override public void channelRead(ChannelHandlerContext ctx,Object message){
  AbstractMessage msg=(AbstractMessage)message;
  LOG.info(""String_Node_Str"",Utils.msgType2String(msg.getMessageType()));
  try {
switch (msg.getMessageType()) {
case CONNECT:
case SUBSCRIBE:
case UNSUBSCRIBE:
case PUBLISH:
case PUBREC:
case PUBCOMP:
case PUBREL:
case DISCONNECT:
case PUBACK:
      NettyChannel channel;
synchronized (m_channelMapper) {
      if (!m_channelMapper.containsKey(ctx)) {
        m_channelMapper.put(ctx,new NettyChannel(ctx));
      }
      channel=m_channelMapper.get(ctx);
    }
  m_messaging.handleProtocolMessage(channel,msg);
break;
case PINGREQ:
PingRespMessage pingResp=new PingRespMessage();
ctx.writeAndFlush(pingResp);
break;
}
}
 catch (Exception ex) {
LOG.error(""String_Node_Str"",ex);
}
}"
27448,"private void sendPublish(String clientId,String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retained,int messageID){
  LOG.debug(""String_Node_Str"",clientId,topic,qos,retained,messageID);
  PublishMessage pubMessage=new PublishMessage();
  pubMessage.setRetainFlag(retained);
  pubMessage.setTopicName(topic);
  pubMessage.setQos(qos);
  pubMessage.setPayload(message);
  LOG.info(""String_Node_Str"",clientId,topic);
  LOG.debug(""String_Node_Str"",new String(message.array()));
  if (pubMessage.getQos() != AbstractMessage.QOSType.MOST_ONE) {
    pubMessage.setMessageID(messageID);
  }
  if (m_clientIDs == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"",m_clientIDs);
  if (m_clientIDs.get(clientId) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",clientId,m_clientIDs));
  }
  LOG.debug(""String_Node_Str"",clientId,m_clientIDs.get(clientId).getSession());
  disruptorPublish(new OutputMessagingEvent(m_clientIDs.get(clientId).getSession(),pubMessage));
}","private void sendPublish(String clientId,String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retained,int messageID){
  LOG.debug(""String_Node_Str"",clientId,topic,qos,retained,messageID);
  PublishMessage pubMessage=new PublishMessage();
  pubMessage.setRetainFlag(retained);
  pubMessage.setTopicName(topic);
  pubMessage.setQos(qos);
  pubMessage.setPayload(message);
  LOG.info(""String_Node_Str"",clientId,topic);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",DebugUtils.payload2Str(message));
  }
  if (pubMessage.getQos() != AbstractMessage.QOSType.MOST_ONE) {
    pubMessage.setMessageID(messageID);
  }
  if (m_clientIDs == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LOG.debug(""String_Node_Str"",m_clientIDs);
  if (m_clientIDs.get(clientId) == null) {
    throw new RuntimeException(String.format(""String_Node_Str"",clientId,m_clientIDs));
  }
  LOG.debug(""String_Node_Str"",clientId,m_clientIDs.get(clientId).getSession());
  disruptorPublish(new OutputMessagingEvent(m_clientIDs.get(clientId).getSession(),pubMessage));
}"
27449,"/** 
 * Flood the subscribers with the message to notify. MessageID is optional and should only used for QoS 1 and 2
 */
private void publish2Subscribers(String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retain,Integer messageID){
  LOG.debug(""String_Node_Str"",topic);
  LOG.debug(""String_Node_Str"",new String(message.array()));
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",subscriptions.dumpTree());
  }
  for (  final Subscription sub : subscriptions.matches(topic)) {
    if (qos.ordinal() > sub.getRequestedQos().ordinal()) {
      qos=sub.getRequestedQos();
    }
    LOG.debug(""String_Node_Str"",sub.getClientId(),sub.getTopic(),qos,sub.isActive());
    if (qos == AbstractMessage.QOSType.MOST_ONE && sub.isActive()) {
      sendPublish(sub.getClientId(),topic,qos,message,false);
    }
 else {
      if (!sub.isCleanSession() && !sub.isActive()) {
        PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
        m_storageService.storePublishForFuture(newPublishEvt);
      }
 else {
        if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) {
          String publishKey=String.format(""String_Node_Str"",sub.getClientId(),messageID);
          PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
          m_storageService.addInFlight(newPublishEvt,publishKey);
        }
        if (sub.isActive()) {
          sendPublish(sub.getClientId(),topic,qos,message,false);
        }
      }
    }
  }
}","/** 
 * Flood the subscribers with the message to notify. MessageID is optional and should only used for QoS 1 and 2
 */
private void publish2Subscribers(String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retain,Integer messageID){
  LOG.debug(""String_Node_Str"",topic);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",DebugUtils.payload2Str(message));
    LOG.debug(""String_Node_Str"",subscriptions.dumpTree());
  }
  for (  final Subscription sub : subscriptions.matches(topic)) {
    if (qos.ordinal() > sub.getRequestedQos().ordinal()) {
      qos=sub.getRequestedQos();
    }
    message.rewind();
    LOG.debug(""String_Node_Str"",sub.getClientId(),sub.getTopic(),qos,sub.isActive());
    if (qos == AbstractMessage.QOSType.MOST_ONE && sub.isActive()) {
      sendPublish(sub.getClientId(),topic,qos,message,false);
    }
 else {
      if (!sub.isCleanSession() && !sub.isActive()) {
        PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
        m_storageService.storePublishForFuture(newPublishEvt);
      }
 else {
        if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) {
          String publishKey=String.format(""String_Node_Str"",sub.getClientId(),messageID);
          PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
          m_storageService.addInFlight(newPublishEvt,publishKey);
        }
        if (sub.isActive()) {
          sendPublish(sub.getClientId(),topic,qos,message,false);
        }
      }
    }
  }
}"
27450,"@Test public void testUnsubscribe_do_not_notify_anymore_same_session() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",0);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertEquals(""String_Node_Str"",m_callback.getTopic());
  m_client.unsubscribe(""String_Node_Str"");
  m_callback.reinit();
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertNull(m_callback.getMessage());
}","@Test public void testUnsubscribe_do_not_notify_anymore_same_session() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",0);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertEquals(""String_Node_Str"",m_callback.getTopic());
  m_client.unsubscribe(""String_Node_Str"");
  m_callback.reinit();
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertNull(m_callback.getMessage(false));
}"
27451,"@Test public void testUnsubscribe_do_not_notify_anymore_new_session() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",0);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertEquals(""String_Node_Str"",m_callback.getTopic());
  m_client.unsubscribe(""String_Node_Str"");
  m_client.disconnect();
  m_callback.reinit();
  m_client.connect(options);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertNull(m_callback.getMessage());
}","@Test public void testUnsubscribe_do_not_notify_anymore_new_session() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",0);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertEquals(""String_Node_Str"",m_callback.getTopic());
  m_client.unsubscribe(""String_Node_Str"");
  m_client.disconnect();
  m_callback.reinit();
  m_client.connect(options);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertNull(m_callback.getMessage(false));
}"
27452,"@Test public void avoidMultipleNotificationsAfterMultipleReconnection_cleanSessionFalseQoS1() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  assertNotNull(m_callback.getMessage());
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  assertNotNull(m_callback.getMessage());
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
}","@Test public void avoidMultipleNotificationsAfterMultipleReconnection_cleanSessionFalseQoS1() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  MqttMessage message=m_callback.getMessage(true);
  assertNotNull(message);
  assertEquals(""String_Node_Str"",message.toString());
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  message=m_callback.getMessage(true);
  assertNotNull(message);
  assertEquals(""String_Node_Str"",message.toString());
}"
27453,"@Test public void testPublishWithQoS1_notCleanSession() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  m_client.connect(options);
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
}","@Test public void testPublishWithQoS1_notCleanSession() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  m_client.connect(options);
  assertEquals(""String_Node_Str"",m_callback.getMessage(true).toString());
}"
27454,"@Test public void testPublishWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_callback.reinit();
  m_client.connect(options);
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
  assertEquals(2,m_callback.getMessage().getQos());
}","@Test public void testPublishWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_callback.reinit();
  m_client.connect(options);
  MqttMessage message=m_callback.getMessage(true);
  assertEquals(""String_Node_Str"",message.toString());
  assertEquals(2,message.getQos());
}"
27455,"@Before public void setUp() throws Exception {
  startServer();
  m_client=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_dataStore);
  m_callback=new TestCallback();
  m_client.setCallback(m_callback);
}","@Before public void setUp() throws Exception {
  File dbFile=new File(Server.STORAGE_FILE_PATH);
  assertFalse(dbFile.exists());
  startServer();
  m_client=new MqttClient(""String_Node_Str"",""String_Node_Str"",s_dataStore);
  m_callback=new TestCallback();
  m_client.setCallback(m_callback);
}"
27456,"public MqttMessage getMessage(){
  try {
    m_latch.await(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return m_message;
}","public MqttMessage getMessage(boolean checkElapsed){
  try {
    boolean elapsed=!m_latch.await(1,TimeUnit.SECONDS);
    if (elapsed && checkElapsed) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return m_message;
}"
27457,"/** 
 * Check that after a client has connected with clean session false, subscribed to some topic and exited, if it reconnect with clean session true, the m_server correctly cleanup every previous subscription
 */
@Test public void testCleanSession_correctlyClientSubscriptions() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",0);
  m_client.disconnect();
  m_client.connect();
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertNull(m_callback.getMessage());
}","/** 
 * Check that after a client has connected with clean session false, subscribed to some topic and exited, if it reconnect with clean session true, the m_server correctly cleanup every previous subscription
 */
@Test public void testCleanSession_correctlyClientSubscriptions() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",0);
  m_client.disconnect();
  m_client.connect();
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),0,false);
  assertNull(m_callback.getMessage(false));
}"
27458,"@After public void tearDown() throws Exception {
  if (m_client.isConnected()) {
    m_client.disconnect();
  }
  m_server.stopServer();
  File dbFile=new File(Server.STORAGE_FILE_PATH);
  if (dbFile.exists()) {
    dbFile.delete();
  }
}","@After public void tearDown() throws Exception {
  if (m_client.isConnected()) {
    m_client.disconnect();
  }
  m_server.stopServer();
  File dbFile=new File(Server.STORAGE_FILE_PATH);
  if (dbFile.exists()) {
    dbFile.delete();
  }
  assertFalse(dbFile.exists());
}"
27459,"@Test public void testPublishWithQoS1() throws Exception {
  LOG.info(""String_Node_Str"");
  m_client.connect();
  m_client.subscribe(""String_Node_Str"",1);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),1,false);
  m_client.disconnect();
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
  assertEquals(1,m_callback.getMessage().getQos());
}","@Test public void testPublishWithQoS1() throws Exception {
  LOG.info(""String_Node_Str"");
  m_client.connect();
  m_client.subscribe(""String_Node_Str"",1);
  m_client.publish(""String_Node_Str"",""String_Node_Str"".getBytes(),1,false);
  m_client.disconnect();
  MqttMessage message=m_callback.getMessage(true);
  assertEquals(""String_Node_Str"",message.toString());
  assertEquals(1,message.getQos());
}"
27460,"@Test public void checkReceivePublishedMessage_after_a_reconnect_with_notCleanSession() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  m_client.disconnect();
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  assertNotNull(m_callback.getMessage());
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
}","@Test public void checkReceivePublishedMessage_after_a_reconnect_with_notCleanSession() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  m_client.disconnect();
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",1);
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),1);
  MqttMessage message=m_callback.getMessage(true);
  assertNotNull(message);
  assertEquals(""String_Node_Str"",message.toString());
}"
27461,"@Test public void testPublishReceiveWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  assertNotNull(m_callback.getMessage());
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
}","@Test public void testPublishReceiveWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  MqttMessage message=m_callback.getMessage(true);
  assertNotNull(message);
  assertEquals(""String_Node_Str"",message.toString());
}"
27462,"@Test public void testPublishWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_client.connect(options);
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
  assertEquals(2,m_callback.getMessage().getQos());
}","@Test public void testPublishWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_callback.reinit();
  m_client.connect(options);
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
  assertEquals(2,m_callback.getMessage().getQos());
}"
27463,"@Test public void testPublishReceiveWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_client.connect(options);
  assertNotNull(m_callback);
  assertNotNull(m_callback.getMessage());
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
}","@Test public void testPublishReceiveWithQoS2() throws Exception {
  LOG.info(""String_Node_Str"");
  MqttConnectOptions options=new MqttConnectOptions();
  options.setCleanSession(false);
  m_client.connect(options);
  m_client.subscribe(""String_Node_Str"",2);
  m_client.disconnect();
  publishFromAnotherClient(""String_Node_Str"",""String_Node_Str"".getBytes(),2);
  m_callback.reinit();
  m_client.connect(options);
  assertNotNull(m_callback);
  assertNotNull(m_callback.getMessage());
  assertEquals(""String_Node_Str"",m_callback.getMessage().toString());
}"
27464,"@Test public void testPublishOfRetainedMessage_afterNewSubscription() throws Exception {
  m_session=new DummyChannel(){
    @Override public void write(    Object value){
      try {
        System.out.println(""String_Node_Str"" + value.getClass().getName());
        if (value instanceof PublishMessage) {
          m_receivedMessage=(AbstractMessage)value;
        }
        if (m_receivedMessage instanceof ConnAckMessage) {
          ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
          m_returnCode=buf.getReturnCode();
        }
      }
 catch (      Exception ex) {
        throw new AssertionError(""String_Node_Str"");
      }
    }
  }
;
  final Subscription subscription=new Subscription(FAKE_PUBLISHER_ID,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  SubscriptionsStore subs=new SubscriptionsStore(){
    @Override public List<Subscription> matches(    String topic){
      if (topic.equals(FAKE_TOPIC)) {
        return Arrays.asList(subscription);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + FAKE_TOPIC + ""String_Node_Str""+ topic);
      }
    }
  }
;
  subs.init(new MemoryStorageService());
  m_processor.init(subs,m_storageService);
  ConnectMessage connectMessage=new ConnectMessage();
  connectMessage.setClientID(FAKE_PUBLISHER_ID);
  connectMessage.setProcotolVersion((byte)3);
  connectMessage.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(m_session,connectMessage);
  ByteBuffer buffer=ByteBuffer.allocate(5).put(""String_Node_Str"".getBytes());
  PublishEvent pubEvt=new PublishEvent(FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,buffer,true,""String_Node_Str"",null);
  m_processor.processPublish(pubEvt);
  SubscribeMessage msg=new SubscribeMessage();
  msg.addSubscription(new SubscribeMessage.Couple((byte)QOSType.MOST_ONE.ordinal(),""String_Node_Str""));
  m_processor.processSubscribe(m_session,msg,FAKE_PUBLISHER_ID,false);
  assertNotNull(m_receivedMessage);
  assertTrue(m_receivedMessage instanceof PublishMessage);
  PublishMessage pubMessage=(PublishMessage)m_receivedMessage;
  assertEquals(FAKE_TOPIC,pubMessage.getTopicName());
}","@Test public void testPublishOfRetainedMessage_afterNewSubscription() throws Exception {
  final CountDownLatch publishRecvSignal=new CountDownLatch(1);
  m_session=new DummyChannel(){
    @Override public void write(    Object value){
      try {
        System.out.println(""String_Node_Str"" + value.getClass().getName());
        if (value instanceof PublishMessage) {
          m_receivedMessage=(AbstractMessage)value;
          publishRecvSignal.countDown();
        }
        if (m_receivedMessage instanceof ConnAckMessage) {
          ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
          m_returnCode=buf.getReturnCode();
        }
      }
 catch (      Exception ex) {
        throw new AssertionError(""String_Node_Str"");
      }
    }
  }
;
  final Subscription subscription=new Subscription(FAKE_PUBLISHER_ID,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  SubscriptionsStore subs=new SubscriptionsStore(){
    @Override public List<Subscription> matches(    String topic){
      if (topic.equals(FAKE_TOPIC)) {
        return Arrays.asList(subscription);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + FAKE_TOPIC + ""String_Node_Str""+ topic);
      }
    }
  }
;
  subs.init(new MemoryStorageService());
  m_processor.init(subs,m_storageService);
  ConnectMessage connectMessage=new ConnectMessage();
  connectMessage.setClientID(FAKE_PUBLISHER_ID);
  connectMessage.setProcotolVersion((byte)3);
  connectMessage.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(m_session,connectMessage);
  ByteBuffer buffer=ByteBuffer.allocate(5).put(""String_Node_Str"".getBytes());
  PublishEvent pubEvt=new PublishEvent(FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,buffer,true,""String_Node_Str"",null);
  m_processor.processPublish(pubEvt);
  SubscribeMessage msg=new SubscribeMessage();
  msg.addSubscription(new SubscribeMessage.Couple((byte)QOSType.MOST_ONE.ordinal(),""String_Node_Str""));
  m_processor.processSubscribe(m_session,msg,FAKE_PUBLISHER_ID,false);
  assertTrue(publishRecvSignal.await(1,TimeUnit.SECONDS));
  assertNotNull(m_receivedMessage);
  assertTrue(m_receivedMessage instanceof PublishMessage);
  PublishMessage pubMessage=(PublishMessage)m_receivedMessage;
  assertEquals(FAKE_TOPIC,pubMessage.getTopicName());
}"
27465,"@Override public void write(Object value){
  try {
    System.out.println(""String_Node_Str"" + value.getClass().getName());
    if (value instanceof PublishMessage) {
      m_receivedMessage=(AbstractMessage)value;
    }
    if (m_receivedMessage instanceof ConnAckMessage) {
      ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
      m_returnCode=buf.getReturnCode();
    }
  }
 catch (  Exception ex) {
    throw new AssertionError(""String_Node_Str"");
  }
}","@Override public void write(Object value){
  try {
    System.out.println(""String_Node_Str"" + value.getClass().getName());
    if (value instanceof PublishMessage) {
      m_receivedMessage=(AbstractMessage)value;
      publishRecvSignal.countDown();
    }
    if (m_receivedMessage instanceof ConnAckMessage) {
      ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
      m_returnCode=buf.getReturnCode();
    }
  }
 catch (  Exception ex) {
    throw new AssertionError(""String_Node_Str"");
  }
}"
27466,"/** 
 * Flood the subscribers with the message to notify. MessageID is optional and should only used for QoS 1 and 2
 */
private void publish2Subscribers(String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retain,Integer messageID){
  LOG.debug(""String_Node_Str"",topic);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",subscriptions.dumpTree());
  }
  for (  final Subscription sub : subscriptions.matches(topic)) {
    LOG.debug(""String_Node_Str"",sub.getClientId(),sub.getTopic(),qos,sub.isActive());
    if (qos == AbstractMessage.QOSType.MOST_ONE) {
      sendPublish(sub.getClientId(),topic,qos,message,false);
    }
 else {
      if (!sub.isCleanSession() && !sub.isActive()) {
        PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
        m_storageService.storePublishForFuture(newPublishEvt);
      }
 else {
        if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) {
          String publishKey=String.format(""String_Node_Str"",sub.getClientId(),messageID);
          PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
          m_storageService.addInFlight(newPublishEvt,publishKey);
        }
        sendPublish(sub.getClientId(),topic,qos,message,false);
      }
    }
  }
}","/** 
 * Flood the subscribers with the message to notify. MessageID is optional and should only used for QoS 1 and 2
 */
private void publish2Subscribers(String topic,AbstractMessage.QOSType qos,ByteBuffer message,boolean retain,Integer messageID){
  LOG.debug(""String_Node_Str"",topic);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"",subscriptions.dumpTree());
  }
  for (  final Subscription sub : subscriptions.matches(topic)) {
    LOG.debug(""String_Node_Str"",sub.getClientId(),sub.getTopic(),qos,sub.isActive());
    if (qos == AbstractMessage.QOSType.MOST_ONE && sub.isActive()) {
      sendPublish(sub.getClientId(),topic,qos,message,false);
    }
 else {
      if (!sub.isCleanSession() && !sub.isActive()) {
        PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
        m_storageService.storePublishForFuture(newPublishEvt);
      }
 else {
        if (qos == AbstractMessage.QOSType.EXACTLY_ONCE) {
          String publishKey=String.format(""String_Node_Str"",sub.getClientId(),messageID);
          PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),messageID,null);
          m_storageService.addInFlight(newPublishEvt,publishKey);
        }
        sendPublish(sub.getClientId(),topic,qos,message,false);
      }
    }
  }
}"
27467,"@Test public void testPublishOfRetainedMessage_afterNewSubscription() throws Exception {
  m_session=new DummyChannel(){
    @Override public void write(    Object value){
      try {
        System.out.println(""String_Node_Str"" + value.getClass().getName());
        if (value instanceof PublishMessage) {
          m_receivedMessage=(AbstractMessage)value;
        }
        if (m_receivedMessage instanceof ConnAckMessage) {
          ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
          m_returnCode=buf.getReturnCode();
        }
      }
 catch (      Exception ex) {
        throw new AssertionError(""String_Node_Str"");
      }
    }
  }
;
  final Subscription subscription=new Subscription(FAKE_CLIENT_ID,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  SubscriptionsStore subs=new SubscriptionsStore(){
    @Override public List<Subscription> matches(    String topic){
      if (topic.equals(FAKE_TOPIC)) {
        return Arrays.asList(subscription);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + FAKE_TOPIC + ""String_Node_Str""+ topic);
      }
    }
  }
;
  subs.init(new MemoryStorageService());
  m_processor.init(subs,m_storageService);
  ConnectMessage connectMessage=new ConnectMessage();
  connectMessage.setClientID(FAKE_CLIENT_ID);
  connectMessage.setProcotolVersion((byte)3);
  connectMessage.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(m_session,connectMessage);
  ByteBuffer buffer=ByteBuffer.allocate(5).put(""String_Node_Str"".getBytes());
  PublishEvent pubEvt=new PublishEvent(FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,buffer,true,""String_Node_Str"",null);
  m_processor.processPublish(pubEvt);
  SubscribeMessage msg=new SubscribeMessage();
  msg.addSubscription(new SubscribeMessage.Couple((byte)QOSType.MOST_ONE.ordinal(),""String_Node_Str""));
  m_processor.processSubscribe(m_session,msg,FAKE_CLIENT_ID,false);
  assertNotNull(m_receivedMessage);
  assertTrue(m_receivedMessage instanceof PublishMessage);
  PublishMessage pubMessage=(PublishMessage)m_receivedMessage;
  assertEquals(FAKE_TOPIC,pubMessage.getTopicName());
}","@Test public void testPublishOfRetainedMessage_afterNewSubscription() throws Exception {
  m_session=new DummyChannel(){
    @Override public void write(    Object value){
      try {
        System.out.println(""String_Node_Str"" + value.getClass().getName());
        if (value instanceof PublishMessage) {
          m_receivedMessage=(AbstractMessage)value;
        }
        if (m_receivedMessage instanceof ConnAckMessage) {
          ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
          m_returnCode=buf.getReturnCode();
        }
      }
 catch (      Exception ex) {
        throw new AssertionError(""String_Node_Str"");
      }
    }
  }
;
  final Subscription subscription=new Subscription(FAKE_PUBLISHER_ID,FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,true);
  SubscriptionsStore subs=new SubscriptionsStore(){
    @Override public List<Subscription> matches(    String topic){
      if (topic.equals(FAKE_TOPIC)) {
        return Arrays.asList(subscription);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + FAKE_TOPIC + ""String_Node_Str""+ topic);
      }
    }
  }
;
  subs.init(new MemoryStorageService());
  m_processor.init(subs,m_storageService);
  ConnectMessage connectMessage=new ConnectMessage();
  connectMessage.setClientID(FAKE_PUBLISHER_ID);
  connectMessage.setProcotolVersion((byte)3);
  connectMessage.setCleanSession(subscription.isCleanSession());
  m_processor.processConnect(m_session,connectMessage);
  ByteBuffer buffer=ByteBuffer.allocate(5).put(""String_Node_Str"".getBytes());
  PublishEvent pubEvt=new PublishEvent(FAKE_TOPIC,AbstractMessage.QOSType.MOST_ONE,buffer,true,""String_Node_Str"",null);
  m_processor.processPublish(pubEvt);
  SubscribeMessage msg=new SubscribeMessage();
  msg.addSubscription(new SubscribeMessage.Couple((byte)QOSType.MOST_ONE.ordinal(),""String_Node_Str""));
  m_processor.processSubscribe(m_session,msg,FAKE_PUBLISHER_ID,false);
  assertNotNull(m_receivedMessage);
  assertTrue(m_receivedMessage instanceof PublishMessage);
  PublishMessage pubMessage=(PublishMessage)m_receivedMessage;
  assertEquals(FAKE_TOPIC,pubMessage.getTopicName());
}"
27468,"@Override void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws Exception {
  LOG.debug(""String_Node_Str"" + in);
  int startPos=in.readerIndex();
  in.resetReaderIndex();
  PublishMessage message=new PublishMessage();
  if (!decodeCommonHeader(message,in)) {
    LOG.info(""String_Node_Str"" + in);
    in.resetReaderIndex();
    return;
  }
  int remainingLength=message.getRemainingLength();
  String topic=Utils.decodeString(in);
  if (topic == null) {
    in.resetReaderIndex();
    return;
  }
  message.setTopicName(topic);
  if (message.getQos() == AbstractMessage.QOSType.LEAST_ONE || message.getQos() == AbstractMessage.QOSType.EXACTLY_ONCE) {
    message.setMessageID(in.readUnsignedShort());
  }
  int stopPos=in.readerIndex();
  int payloadSize=remainingLength - (stopPos - startPos - 2) + (Utils.numBytesToEncode(remainingLength) - 1);
  if (in.readableBytes() < payloadSize) {
    in.resetReaderIndex();
    return;
  }
  byte[] b=new byte[payloadSize];
  in.readBytes(b);
  message.setPayload(b);
  out.add(message);
}","@Override void decode(ChannelHandlerContext ctx,ByteBuf in,List<Object> out) throws Exception {
  LOG.info(""String_Node_Str"" + in);
  in.resetReaderIndex();
  int startPos=in.readerIndex();
  PublishMessage message=new PublishMessage();
  if (!decodeCommonHeader(message,in)) {
    LOG.info(""String_Node_Str"" + in);
    in.resetReaderIndex();
    return;
  }
  int remainingLength=message.getRemainingLength();
  String topic=Utils.decodeString(in);
  if (topic == null) {
    in.resetReaderIndex();
    return;
  }
  message.setTopicName(topic);
  if (message.getQos() == AbstractMessage.QOSType.LEAST_ONE || message.getQos() == AbstractMessage.QOSType.EXACTLY_ONCE) {
    message.setMessageID(in.readUnsignedShort());
  }
  int stopPos=in.readerIndex();
  int payloadSize=remainingLength - (stopPos - startPos - 2) + (Utils.numBytesToEncode(remainingLength) - 1);
  if (in.readableBytes() < payloadSize) {
    in.resetReaderIndex();
    return;
  }
  byte[] b=new byte[payloadSize];
  in.readBytes(b);
  message.setPayload(b);
  out.add(message);
}"
27469,"public void storeRetained(String topic,byte[] message,AbstractMessage.QOSType qos){
  if (message.length == 0) {
    m_retainedStore.remove(topic);
  }
 else {
    m_retainedStore.put(topic,new StoredMessage(message,qos));
  }
}","public void storeRetained(String topic,byte[] message,AbstractMessage.QOSType qos){
  if (message.length == 0) {
    m_retainedStore.remove(topic);
  }
 else {
    m_retainedStore.put(topic,new StoredMessage(message,qos,topic));
  }
}"
27470,"StoredMessage(byte[] message,AbstractMessage.QOSType qos){
  m_qos=qos;
  m_payload=message;
}","StoredMessage(byte[] message,AbstractMessage.QOSType qos,String topic){
  m_qos=qos;
  m_payload=message;
  m_topic=topic;
}"
27471,"protected void processSubscribe(IoSession session,SubscribeMessage msg,String clientID,boolean cleanSession){
  LOG.debug(""String_Node_Str"");
  for (  SubscribeMessage.Couple req : msg.subscriptions()) {
    QOSType qos=AbstractMessage.QOSType.fromByte(req.getQos());
    Subscription newSubscription=new Subscription(clientID,req.getTopic(),qos,cleanSession);
    subscribeSingleTopic(newSubscription,req.getTopic());
  }
  SubAckMessage ackMessage=new SubAckMessage();
  ackMessage.setMessageID(msg.getMessageID());
  for (int i=0; i < msg.subscriptions().size(); i++) {
    ackMessage.addType(QOSType.MOST_ONE);
  }
  LOG.info(""String_Node_Str"" + msg.getMessageID());
  session.write(ackMessage);
}","protected void processSubscribe(IoSession session,SubscribeMessage msg,String clientID,boolean cleanSession){
  LOG.debug(""String_Node_Str"");
  for (  SubscribeMessage.Couple req : msg.subscriptions()) {
    QOSType qos=AbstractMessage.QOSType.values()[req.getQos()];
    Subscription newSubscription=new Subscription(clientID,req.getTopic(),qos,cleanSession);
    subscribeSingleTopic(newSubscription,req.getTopic());
  }
  SubAckMessage ackMessage=new SubAckMessage();
  ackMessage.setMessageID(msg.getMessageID());
  for (int i=0; i < msg.subscriptions().size(); i++) {
    ackMessage.addType(QOSType.MOST_ONE);
  }
  LOG.info(""String_Node_Str"" + msg.getMessageID());
  session.write(ackMessage);
}"
27472,"private void subscribeSingleTopic(Subscription newSubscription,final String topic){
  subscriptions.add(newSubscription);
  Collection<StoredMessage> messages=m_storageService.searchMatching(new IMatchingCondition(){
    public boolean match(    String key){
      return SubscriptionsStore.matchTopics(key,topic);
    }
  }
);
  for (  StoredMessage storedMsg : messages) {
    LOG.debug(""String_Node_Str"" + topic);
    notify(new NotifyEvent(newSubscription.getClientId(),topic,storedMsg.getQos(),storedMsg.getPayload(),true));
  }
}","private void subscribeSingleTopic(Subscription newSubscription,final String topic){
  subscriptions.add(newSubscription);
  Collection<StoredMessage> messages=m_storageService.searchMatching(new IMatchingCondition(){
    public boolean match(    String key){
      return SubscriptionsStore.matchTopics(key,topic);
    }
  }
);
  for (  StoredMessage storedMsg : messages) {
    LOG.debug(""String_Node_Str"" + topic);
    notify(new NotifyEvent(newSubscription.getClientId(),storedMsg.getTopic(),storedMsg.getQos(),storedMsg.getPayload(),true));
  }
}"
27473,"@Override public void filterWrite(NextFilter nextFilter,IoSession session,WriteRequest writeRequest) throws Exception {
  try {
    m_receivedMessage=(AbstractMessage)writeRequest.getMessage();
    if (m_receivedMessage instanceof ConnAckMessage) {
      ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
      m_returnCode=buf.getReturnCode();
    }
  }
 catch (  Exception ex) {
    throw new AssertionError(""String_Node_Str"");
  }
}","@Override public void filterWrite(IoFilter.NextFilter nextFilter,IoSession session,WriteRequest writeRequest) throws Exception {
  try {
    System.out.println(""String_Node_Str"" + writeRequest.getMessage().getClass().getName());
    if (writeRequest.getMessage() instanceof PublishMessage) {
      m_receivedMessage=(AbstractMessage)writeRequest.getMessage();
    }
    if (m_receivedMessage instanceof ConnAckMessage) {
      ConnAckMessage buf=(ConnAckMessage)m_receivedMessage;
      m_returnCode=buf.getReturnCode();
    }
  }
 catch (  Exception ex) {
    throw new AssertionError(""String_Node_Str"");
  }
}"
27474,"public void republishStored(String clientID){
  disruptorPublish(new RepublishEvent(clientID));
}","public void republishStored(String clientID){
  LOG.debug(""String_Node_Str"" + clientID);
  disruptorPublish(new RepublishEvent(clientID));
}"
27475,"protected void processPublish(PublishEvent evt){
  LOG.debug(""String_Node_Str"");
  final String topic=evt.getTopic();
  final QOSType qos=evt.getQos();
  final byte[] message=evt.getMessage();
  boolean retain=evt.isRetain();
  CleanInFlightEvent cleanEvt=null;
  if (qos == QOSType.LEAST_ONE) {
    String publishKey=String.format(""String_Node_Str"",evt.getClientID(),evt.getMessageID());
    m_storageService.addInFlight(evt,publishKey);
    cleanEvt=new CleanInFlightEvent(publishKey);
  }
  for (  final Subscription sub : subscriptions.matches(topic)) {
    if (qos == QOSType.MOST_ONE) {
      notify(new NotifyEvent(sub.clientId,topic,qos,message,false));
    }
 else {
      if (!sub.isCleanSession() && !sub.isActive()) {
        m_storageService.storePublishForFuture(evt);
      }
      notify(new NotifyEvent(sub.clientId,topic,qos,message,false));
    }
  }
  if (cleanEvt != null) {
    refill(cleanEvt);
    sendPubAck(new PubAckEvent(evt.getMessageID(),evt.getClientID()));
  }
  if (retain) {
    m_storageService.storeRetained(topic,message,qos);
  }
}","protected void processPublish(PublishEvent evt){
  LOG.debug(""String_Node_Str"" + evt);
  final String topic=evt.getTopic();
  final QOSType qos=evt.getQos();
  final byte[] message=evt.getMessage();
  boolean retain=evt.isRetain();
  CleanInFlightEvent cleanEvt=null;
  if (qos == QOSType.LEAST_ONE) {
    String publishKey=String.format(""String_Node_Str"",evt.getClientID(),evt.getMessageID());
    m_storageService.addInFlight(evt,publishKey);
    cleanEvt=new CleanInFlightEvent(publishKey);
  }
  for (  final Subscription sub : subscriptions.matches(topic)) {
    if (qos == QOSType.MOST_ONE) {
      notify(new NotifyEvent(sub.clientId,topic,qos,message,false));
    }
 else {
      if (!sub.isCleanSession() && !sub.isActive()) {
        PublishEvent newPublishEvt=new PublishEvent(topic,qos,message,retain,sub.getClientId(),evt.getMessageID(),null);
        m_storageService.storePublishForFuture(newPublishEvt);
      }
 else {
        notify(new NotifyEvent(sub.clientId,topic,qos,message,false));
      }
    }
  }
  if (cleanEvt != null) {
    refill(cleanEvt);
    sendPubAck(new PubAckEvent(evt.getMessageID(),evt.getClientID()));
  }
  if (retain) {
    m_storageService.storeRetained(topic,message,qos);
  }
}"
27476,"protected void processSubscribe(IoSession session,SubscribeMessage msg,String clientID,boolean cleanSession){
  LOG.debug(""String_Node_Str"");
  for (  SubscribeMessage.Couple req : msg.subscriptions()) {
    QOSType qos=AbstractMessage.QOSType.values()[req.getQos()];
    Subscription newSubscription=new Subscription(clientID,req.getTopic(),qos,cleanSession);
    subscribeSingleTopic(newSubscription,req.getTopic());
  }
  SubAckMessage ackMessage=new SubAckMessage();
  ackMessage.setMessageID(msg.getMessageID());
  for (int i=0; i < msg.subscriptions().size(); i++) {
    ackMessage.addType(QOSType.MOST_ONE);
  }
  LOG.info(""String_Node_Str"",msg.getMessageID());
  session.write(ackMessage);
}","protected void processSubscribe(IoSession session,SubscribeMessage msg,String clientID,boolean cleanSession){
  LOG.debug(""String_Node_Str"");
  for (  SubscribeMessage.Couple req : msg.subscriptions()) {
    QOSType qos=AbstractMessage.QOSType.values()[req.getQos()];
    Subscription newSubscription=new Subscription(clientID,req.getTopic(),qos,cleanSession);
    subscribeSingleTopic(newSubscription,req.getTopic());
  }
  SubAckMessage ackMessage=new SubAckMessage();
  ackMessage.setMessageID(msg.getMessageID());
  for (int i=0; i < msg.subscriptions().size(); i++) {
    ackMessage.addType(QOSType.MOST_ONE);
    ackMessage.addType(QOSType.LEAST_ONE);
  }
  LOG.info(""String_Node_Str"" + msg.getMessageID());
  session.write(ackMessage);
}"
27477,"protected void processConnect(IoSession session,ConnectMessage msg){
  if (msg.getProcotolVersion() != 0x03) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() > 23) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    IoSession oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(Constants.CLEAN_SESSION);
    if (cleanSession) {
      processRemoveAllSubscriptions(msg.getClientID());
    }
    m_clientIDs.get(msg.getClientID()).getSession().close(false);
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  session.setAttribute(""String_Node_Str"",keepAlive);
  session.setAttribute(Constants.CLEAN_SESSION,msg.isCleanSession());
  session.setAttribute(Constants.ATTR_CLIENTID,msg.getClientID());
  session.getConfig().setIdleTime(IdleStatus.READER_IDLE,Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    QOSType willQos=QOSType.values()[msg.getWillQos()];
    PublishEvent pubEvt=new PublishEvent(msg.getWillTopic(),willQos,msg.getWillMessage().getBytes(),msg.isWillRetain(),msg.getClientID(),session);
    processPublish(pubEvt);
  }
  if (msg.isUserFlag()) {
    String pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      ConnAckMessage okResp=new ConnAckMessage();
      okResp.setReturnCode(ConnAckMessage.BAD_USERNAME_OR_PASSWORD);
      session.write(okResp);
      return;
    }
  }
  if (msg.isCleanSession()) {
    processRemoveAllSubscriptions(msg.getClientID());
  }
 else {
    republishStored(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  session.write(okResp);
}","protected void processConnect(IoSession session,ConnectMessage msg){
  if (msg.getProcotolVersion() != 0x03) {
    ConnAckMessage badProto=new ConnAckMessage();
    badProto.setReturnCode(ConnAckMessage.UNNACEPTABLE_PROTOCOL_VERSION);
    session.write(badProto);
    session.close(false);
    return;
  }
  if (msg.getClientID() == null || msg.getClientID().length() > 23) {
    ConnAckMessage okResp=new ConnAckMessage();
    okResp.setReturnCode(ConnAckMessage.IDENTIFIER_REJECTED);
    session.write(okResp);
    return;
  }
  if (m_clientIDs.containsKey(msg.getClientID())) {
    IoSession oldSession=m_clientIDs.get(msg.getClientID()).getSession();
    boolean cleanSession=(Boolean)oldSession.getAttribute(Constants.CLEAN_SESSION);
    if (cleanSession) {
      processRemoveAllSubscriptions(msg.getClientID());
    }
    m_clientIDs.get(msg.getClientID()).getSession().close(false);
  }
  ConnectionDescriptor connDescr=new ConnectionDescriptor(msg.getClientID(),session,msg.isCleanSession());
  m_clientIDs.put(msg.getClientID(),connDescr);
  int keepAlive=msg.getKeepAlive();
  session.setAttribute(""String_Node_Str"",keepAlive);
  session.setAttribute(Constants.CLEAN_SESSION,msg.isCleanSession());
  session.setAttribute(Constants.ATTR_CLIENTID,msg.getClientID());
  session.getConfig().setIdleTime(IdleStatus.READER_IDLE,Math.round(keepAlive * 1.5f));
  if (msg.isWillFlag()) {
    QOSType willQos=QOSType.values()[msg.getWillQos()];
    PublishEvent pubEvt=new PublishEvent(msg.getWillTopic(),willQos,msg.getWillMessage().getBytes(),msg.isWillRetain(),msg.getClientID(),session);
    processPublish(pubEvt);
  }
  if (msg.isUserFlag()) {
    String pwd=null;
    if (msg.isPasswordFlag()) {
      pwd=msg.getPassword();
    }
    if (!m_authenticator.checkValid(msg.getUsername(),pwd)) {
      ConnAckMessage okResp=new ConnAckMessage();
      okResp.setReturnCode(ConnAckMessage.BAD_USERNAME_OR_PASSWORD);
      session.write(okResp);
      return;
    }
  }
  subscriptions.connect(msg.getClientID());
  if (msg.isCleanSession()) {
    processRemoveAllSubscriptions(msg.getClientID());
  }
 else {
    republishStored(msg.getClientID());
  }
  ConnAckMessage okResp=new ConnAckMessage();
  okResp.setReturnCode(ConnAckMessage.CONNECTION_ACCEPTED);
  session.write(okResp);
}"
27478,"private void processRepublish(RepublishEvent evt) throws InterruptedException {
  List<PublishEvent> publishedEvents=m_storageService.retrivePersistedPublishes(evt.getClientID());
  if (publishedEvents == null) {
    return;
  }
  for (  PublishEvent pubEvt : publishedEvents) {
    notify(new NotifyEvent(pubEvt.getClientID(),pubEvt.getTopic(),pubEvt.getQos(),pubEvt.getMessage(),false,pubEvt.getMessageID()));
  }
}","private void processRepublish(RepublishEvent evt) throws InterruptedException {
  LOG.debug(""String_Node_Str"");
  List<PublishEvent> publishedEvents=m_storageService.retrivePersistedPublishes(evt.getClientID());
  if (publishedEvents == null) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  for (  PublishEvent pubEvt : publishedEvents) {
    notify(new NotifyEvent(pubEvt.getClientID(),pubEvt.getTopic(),pubEvt.getQos(),pubEvt.getMessage(),false,pubEvt.getMessageID()));
  }
}"
27479,"public void onEvent(ValueEvent t,long l,boolean bln) throws Exception {
  LOG.debug(""String_Node_Str"");
  MessagingEvent evt=t.getEvent();
  if (evt instanceof PublishEvent) {
    processPublish((PublishEvent)evt);
  }
 else   if (evt instanceof StopEvent) {
    processStop();
  }
 else   if (evt instanceof DisconnectEvent) {
    DisconnectEvent disEvt=(DisconnectEvent)evt;
    String clientID=(String)disEvt.getSession().getAttribute(Constants.ATTR_CLIENTID);
    processDisconnect(disEvt.getSession(),clientID);
  }
 else   if (evt instanceof CleanInFlightEvent) {
    m_storageService.cleanInFlight(((CleanInFlightEvent)evt).getMsgId());
  }
 else   if (evt instanceof RepublishEvent) {
    processRepublish((RepublishEvent)evt);
  }
 else   if (evt instanceof ProtocolEvent) {
    IoSession session=((ProtocolEvent)evt).getSession();
    AbstractMessage message=((ProtocolEvent)evt).getMessage();
    if (message instanceof ConnectMessage) {
      processConnect(session,(ConnectMessage)message);
    }
 else     if (message instanceof PublishMessage) {
      PublishMessage pubMsg=(PublishMessage)message;
      PublishEvent pubEvt;
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      if (message.getQos() == QOSType.MOST_ONE) {
        pubEvt=new PublishEvent(pubMsg.getTopicName(),pubMsg.getQos(),pubMsg.getPayload(),pubMsg.isRetainFlag(),clientID,session);
      }
 else {
        pubEvt=new PublishEvent(pubMsg.getTopicName(),pubMsg.getQos(),pubMsg.getPayload(),pubMsg.isRetainFlag(),clientID,pubMsg.getMessageID(),session);
      }
      processPublish(pubEvt);
    }
 else     if (message instanceof DisconnectMessage) {
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      boolean cleanSession=(Boolean)session.getAttribute(Constants.CLEAN_SESSION);
      if (cleanSession) {
        processRemoveAllSubscriptions(clientID);
      }
      processDisconnect(session,clientID);
    }
 else     if (message instanceof UnsubscribeMessage) {
      UnsubscribeMessage unsubMsg=(UnsubscribeMessage)message;
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      processUnsubscribe(session,clientID,unsubMsg.topics(),unsubMsg.getMessageID());
    }
 else     if (message instanceof SubscribeMessage) {
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      boolean cleanSession=(Boolean)session.getAttribute(Constants.CLEAN_SESSION);
      processSubscribe(session,(SubscribeMessage)message,clientID,cleanSession);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + message);
    }
  }
 else   if (evt instanceof InitEvent) {
    processInit();
  }
}","public void onEvent(ValueEvent t,long l,boolean bln) throws Exception {
  MessagingEvent evt=t.getEvent();
  LOG.debug(""String_Node_Str"" + evt);
  if (evt instanceof PublishEvent) {
    processPublish((PublishEvent)evt);
  }
 else   if (evt instanceof StopEvent) {
    processStop();
  }
 else   if (evt instanceof DisconnectEvent) {
    DisconnectEvent disEvt=(DisconnectEvent)evt;
    String clientID=(String)disEvt.getSession().getAttribute(Constants.ATTR_CLIENTID);
    processDisconnect(disEvt.getSession(),clientID);
  }
 else   if (evt instanceof CleanInFlightEvent) {
    m_storageService.cleanInFlight(((CleanInFlightEvent)evt).getMsgId());
  }
 else   if (evt instanceof RepublishEvent) {
    processRepublish((RepublishEvent)evt);
  }
 else   if (evt instanceof ProtocolEvent) {
    IoSession session=((ProtocolEvent)evt).getSession();
    AbstractMessage message=((ProtocolEvent)evt).getMessage();
    if (message instanceof ConnectMessage) {
      processConnect(session,(ConnectMessage)message);
    }
 else     if (message instanceof PublishMessage) {
      PublishMessage pubMsg=(PublishMessage)message;
      PublishEvent pubEvt;
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      if (message.getQos() == QOSType.MOST_ONE) {
        pubEvt=new PublishEvent(pubMsg.getTopicName(),pubMsg.getQos(),pubMsg.getPayload(),pubMsg.isRetainFlag(),clientID,session);
      }
 else {
        pubEvt=new PublishEvent(pubMsg.getTopicName(),pubMsg.getQos(),pubMsg.getPayload(),pubMsg.isRetainFlag(),clientID,pubMsg.getMessageID(),session);
      }
      processPublish(pubEvt);
    }
 else     if (message instanceof DisconnectMessage) {
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      boolean cleanSession=(Boolean)session.getAttribute(Constants.CLEAN_SESSION);
      if (cleanSession) {
        processRemoveAllSubscriptions(clientID);
      }
      processDisconnect(session,clientID);
    }
 else     if (message instanceof UnsubscribeMessage) {
      UnsubscribeMessage unsubMsg=(UnsubscribeMessage)message;
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      processUnsubscribe(session,clientID,unsubMsg.topics(),unsubMsg.getMessageID());
    }
 else     if (message instanceof SubscribeMessage) {
      String clientID=(String)session.getAttribute(Constants.ATTR_CLIENTID);
      boolean cleanSession=(Boolean)session.getAttribute(Constants.CLEAN_SESSION);
      processSubscribe(session,(SubscribeMessage)message,clientID,cleanSession);
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + message);
    }
  }
 else   if (evt instanceof InitEvent) {
    processInit();
  }
}"
27480,"public MessageDecoderResult decode(IoSession session,IoBuffer in,ProtocolDecoderOutput out) throws Exception {
  int startPos=in.position();
  PublishMessage message=new PublishMessage();
  if (decodeCommonHeader(message,in) == NEED_DATA) {
    return NEED_DATA;
  }
  int remainingLength=message.getRemainingLength();
  String topic=Utils.decodeString(in);
  if (topic == null) {
    return NEED_DATA;
  }
  message.setTopicName(topic);
  if (message.getQos() == QOSType.LEAST_ONE || message.getQos() == QOSType.EXACTLY_ONCE) {
    message.setMessageID(Utils.readWord(in));
  }
  int stopPos=in.position();
  int payloadSize=remainingLength - (stopPos - startPos - 2);
  byte[] b=new byte[payloadSize];
  if (in.remaining() < payloadSize) {
    return NEED_DATA;
  }
  in.get(b);
  message.setPayload(b);
  out.write(message);
  return OK;
}","public MessageDecoderResult decode(IoSession session,IoBuffer in,ProtocolDecoderOutput out) throws Exception {
  LOG.debug(""String_Node_Str"" + in);
  int startPos=in.position();
  PublishMessage message=new PublishMessage();
  if (decodeCommonHeader(message,in) == NEED_DATA) {
    LOG.info(""String_Node_Str"" + in);
    return NEED_DATA;
  }
  int remainingLength=message.getRemainingLength();
  String topic=Utils.decodeString(in);
  if (topic == null) {
    return NEED_DATA;
  }
  message.setTopicName(topic);
  if (message.getQos() == QOSType.LEAST_ONE || message.getQos() == QOSType.EXACTLY_ONCE) {
    message.setMessageID(Utils.readWord(in));
  }
  int stopPos=in.position();
  int payloadSize=remainingLength - (stopPos - startPos - 2) + (Utils.numBytesToEncode(remainingLength) - 1);
  if (in.remaining() < payloadSize) {
    return NEED_DATA;
  }
  byte[] b=new byte[payloadSize];
  in.get(b);
  message.setPayload(b);
  out.write(message);
  return OK;
}"
27481,"public void encode(IoSession session,PublishMessage message,ProtocolEncoderOutput out) throws Exception {
  if (message.getQos() == QOSType.RESERVED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getTopicName() == null || message.getTopicName().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IoBuffer variableHeaderBuff=IoBuffer.allocate(2).setAutoExpand(true);
  variableHeaderBuff.put(Utils.encodeString(message.getTopicName()));
  if (message.getQos() == QOSType.LEAST_ONE || message.getQos() == QOSType.EXACTLY_ONCE) {
    if (message.getMessageID() == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    Utils.writeWord(variableHeaderBuff,message.getMessageID());
  }
  variableHeaderBuff.put(message.getPayload());
  variableHeaderBuff.flip();
  int variableHeaderSize=variableHeaderBuff.remaining();
  byte flags=Utils.encodeFlags(message);
  IoBuffer buff=IoBuffer.allocate(2 + variableHeaderSize);
  buff.put((byte)(AbstractMessage.PUBLISH << 4 | flags));
  buff.put(Utils.encodeRemainingLength(variableHeaderSize));
  buff.put(variableHeaderBuff).flip();
  out.write(buff);
}","public void encode(IoSession session,PublishMessage message,ProtocolEncoderOutput out) throws Exception {
  if (message.getQos() == QOSType.RESERVED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getTopicName() == null || message.getTopicName().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IoBuffer variableHeaderBuff=IoBuffer.allocate(2).setAutoExpand(true);
  variableHeaderBuff.put(Utils.encodeString(message.getTopicName()));
  if (message.getQos() == QOSType.LEAST_ONE || message.getQos() == QOSType.EXACTLY_ONCE) {
    if (message.getMessageID() == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    Utils.writeWord(variableHeaderBuff,message.getMessageID());
  }
  variableHeaderBuff.put(message.getPayload());
  variableHeaderBuff.flip();
  int variableHeaderSize=variableHeaderBuff.remaining();
  byte flags=Utils.encodeFlags(message);
  IoBuffer buff=IoBuffer.allocate(2 + variableHeaderSize).setAutoExpand(true);
  ;
  buff.put((byte)(AbstractMessage.PUBLISH << 4 | flags));
  buff.put(Utils.encodeRemainingLength(variableHeaderSize));
  buff.put(variableHeaderBuff).flip();
  out.write(buff);
}"
27482,"public void encode(IoSession session,UnsubscribeMessage message,ProtocolEncoderOutput out) throws Exception {
  if (message.topics().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getQos() != QOSType.LEAST_ONE) {
    throw new IllegalArgumentException(""String_Node_Str"" + message.getQos());
  }
  IoBuffer variableHeaderBuff=IoBuffer.allocate(4).setAutoExpand(true);
  Utils.writeWord(variableHeaderBuff,message.getMessageID());
  for (  String topic : message.topics()) {
    variableHeaderBuff.put(Utils.encodeString(topic));
  }
  variableHeaderBuff.flip();
  int variableHeaderSize=variableHeaderBuff.remaining();
  byte flags=Utils.encodeFlags(message);
  IoBuffer buff=IoBuffer.allocate(4 + variableHeaderSize);
  buff.put((byte)(AbstractMessage.UNSUBSCRIBE << 4 | flags));
  buff.put(Utils.encodeRemainingLength(4 + variableHeaderSize));
  buff.put(variableHeaderBuff).flip();
  out.write(buff);
}","public void encode(IoSession session,UnsubscribeMessage message,ProtocolEncoderOutput out) throws Exception {
  if (message.topics().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getQos() != QOSType.LEAST_ONE) {
    throw new IllegalArgumentException(""String_Node_Str"" + message.getQos());
  }
  IoBuffer variableHeaderBuff=IoBuffer.allocate(4).setAutoExpand(true);
  Utils.writeWord(variableHeaderBuff,message.getMessageID());
  for (  String topic : message.topics()) {
    variableHeaderBuff.put(Utils.encodeString(topic));
  }
  variableHeaderBuff.flip();
  int variableHeaderSize=variableHeaderBuff.remaining();
  byte flags=Utils.encodeFlags(message);
  IoBuffer buff=IoBuffer.allocate(2 + variableHeaderSize);
  buff.put((byte)(AbstractMessage.UNSUBSCRIBE << 4 | flags));
  buff.put(Utils.encodeRemainingLength(2 + variableHeaderSize));
  buff.put(variableHeaderBuff).flip();
  out.write(buff);
}"
27483,"@Test public void testEncodeWithMultiTopic() throws Exception {
  m_msg.setQos(QOSType.LEAST_ONE);
  String topic1=""String_Node_Str"";
  String topic2=""String_Node_Str"";
  m_msg.addTopic(topic1);
  m_msg.addTopic(topic2);
  m_encoder.encode(null,m_msg,m_mockProtoEncoder);
  assertEquals((byte)0xA2,(byte)m_mockProtoEncoder.getBuffer().get());
  assertEquals(18,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xAA,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xBB,m_mockProtoEncoder.getBuffer().get());
  verifyString(topic1,m_mockProtoEncoder.getBuffer());
  verifyString(topic2,m_mockProtoEncoder.getBuffer());
}","@Test public void testEncodeWithMultiTopic() throws Exception {
  m_msg.setQos(QOSType.LEAST_ONE);
  String topic1=""String_Node_Str"";
  String topic2=""String_Node_Str"";
  m_msg.addTopic(topic1);
  m_msg.addTopic(topic2);
  m_encoder.encode(null,m_msg,m_mockProtoEncoder);
  assertEquals((byte)0xA2,(byte)m_mockProtoEncoder.getBuffer().get());
  assertEquals(16,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xAA,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xBB,m_mockProtoEncoder.getBuffer().get());
  verifyString(topic1,m_mockProtoEncoder.getBuffer());
  verifyString(topic2,m_mockProtoEncoder.getBuffer());
}"
27484,"static byte encodeFlags(AbstractMessage message){
  byte flags=0;
  if (message.isDupFlag()) {
    flags|=0x08;
  }
  flags|=((message.getQos().ordinal() & 0x03) << 1);
  return flags;
}","static byte encodeFlags(AbstractMessage message){
  byte flags=0;
  if (message.isDupFlag()) {
    flags|=0x08;
  }
  if (message.isRetainFlag()) {
    flags|=0x01;
  }
  flags|=((message.getQos().ordinal() & 0x03) << 1);
  return flags;
}"
27485,"public MessageDecoderResult decode(IoSession session,IoBuffer in,ProtocolDecoderOutput out) throws Exception {
  SubAckMessage message=new SubAckMessage();
  if (decodeCommonHeader(message,in) == NEED_DATA) {
    return NEED_DATA;
  }
  int remainingLength=message.getRemainingLength();
  message.setMessageID(Utils.readWord(in));
  if (in.remaining() < remainingLength) {
    return NEED_DATA;
  }
  for (int i=0; i < remainingLength; i++) {
    byte qos=in.get();
    message.addType(QOSType.values()[qos]);
  }
  out.write(message);
  return OK;
}","public MessageDecoderResult decode(IoSession session,IoBuffer in,ProtocolDecoderOutput out) throws Exception {
  SubAckMessage message=new SubAckMessage();
  if (decodeCommonHeader(message,in) == NEED_DATA) {
    return NEED_DATA;
  }
  int remainingLength=message.getRemainingLength();
  message.setMessageID(Utils.readWord(in));
  remainingLength-=2;
  if (in.remaining() < remainingLength) {
    return NEED_DATA;
  }
  for (int i=0; i < remainingLength; i++) {
    byte qos=in.get();
    message.addType(QOSType.values()[qos]);
  }
  out.write(message);
  return OK;
}"
27486,"private void initHeaderQos(IoBuffer buff,int messageID,QOSType... qoss) throws IllegalAccessException {
  buff.clear().put((byte)(AbstractMessage.SUBACK << 4)).put(Utils.encodeRemainingLength(3));
  Utils.writeWord(buff,messageID);
  for (  QOSType qos : qoss) {
    buff.put((byte)qos.ordinal());
  }
}","private void initHeaderQos(IoBuffer buff,int messageID,QOSType... qoss) throws IllegalAccessException {
  buff.clear().put((byte)(AbstractMessage.SUBACK << 4)).put(Utils.encodeRemainingLength(2 + qoss.length));
  Utils.writeWord(buff,messageID);
  for (  QOSType qos : qoss) {
    buff.put((byte)qos.ordinal());
  }
}"
27487,"@Test public void testEncodeWithMultiTopic() throws Exception {
  SubscribeMessage msg=new SubscribeMessage();
  msg.setQos(QOSType.LEAST_ONE);
  msg.setMessageID(0xAABB);
  Couple c1=new Couple((byte)1,""String_Node_Str"");
  Couple c2=new Couple((byte)0,""String_Node_Str"");
  msg.addSubscription(c1);
  msg.addSubscription(c2);
  m_encoder.encode(null,msg,m_mockProtoEncoder);
  assertEquals((byte)0x82,(byte)m_mockProtoEncoder.getBuffer().get());
  assertEquals(20,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xAA,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xBB,m_mockProtoEncoder.getBuffer().get());
  verifyString(c1.getTopic(),m_mockProtoEncoder.getBuffer());
  assertEquals(c1.getQos(),m_mockProtoEncoder.getBuffer().get());
  verifyString(c2.getTopic(),m_mockProtoEncoder.getBuffer());
  assertEquals(c2.getQos(),m_mockProtoEncoder.getBuffer().get());
}","@Test public void testEncodeWithMultiTopic() throws Exception {
  SubscribeMessage msg=new SubscribeMessage();
  msg.setQos(QOSType.LEAST_ONE);
  msg.setMessageID(0xAABB);
  Couple c1=new Couple((byte)1,""String_Node_Str"");
  Couple c2=new Couple((byte)0,""String_Node_Str"");
  msg.addSubscription(c1);
  msg.addSubscription(c2);
  m_encoder.encode(null,msg,m_mockProtoEncoder);
  assertEquals((byte)0x82,(byte)m_mockProtoEncoder.getBuffer().get());
  assertEquals(16,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xAA,m_mockProtoEncoder.getBuffer().get());
  assertEquals((byte)0xBB,m_mockProtoEncoder.getBuffer().get());
  verifyString(c1.getTopic(),m_mockProtoEncoder.getBuffer());
  assertEquals(c1.getQos(),m_mockProtoEncoder.getBuffer().get());
  verifyString(c2.getTopic(),m_mockProtoEncoder.getBuffer());
  assertEquals(c2.getQos(),m_mockProtoEncoder.getBuffer().get());
}"
27488,"public void encode(IoSession session,PublishMessage message,ProtocolEncoderOutput out) throws Exception {
  if (message.getQos() == QOSType.RESERVED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getTopicName() == null || message.getTopicName().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IoBuffer variableHeaderBuff=IoBuffer.allocate(2).setAutoExpand(true);
  variableHeaderBuff.put(Utils.encodeString(message.getTopicName()));
  if (message.getQos() == QOSType.LEAST_ONE || message.getQos() == QOSType.EXACTLY_ONCE) {
    if (message.getMessageID() == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    Utils.writeWord(variableHeaderBuff,message.getMessageID());
  }
  variableHeaderBuff.put(message.getPayload());
  variableHeaderBuff.flip();
  int variableHeaderSize=variableHeaderBuff.remaining();
  byte flags=Utils.encodeFlags(message);
  IoBuffer buff=IoBuffer.allocate(4 + variableHeaderSize);
  buff.put((byte)(AbstractMessage.PUBLISH << 4 | flags));
  buff.put(Utils.encodeRemainingLength(4 + variableHeaderSize));
  buff.put(variableHeaderBuff).flip();
  out.write(buff);
}","public void encode(IoSession session,PublishMessage message,ProtocolEncoderOutput out) throws Exception {
  if (message.getQos() == QOSType.RESERVED) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (message.getTopicName() == null || message.getTopicName().isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  IoBuffer variableHeaderBuff=IoBuffer.allocate(2).setAutoExpand(true);
  variableHeaderBuff.put(Utils.encodeString(message.getTopicName()));
  if (message.getQos() == QOSType.LEAST_ONE || message.getQos() == QOSType.EXACTLY_ONCE) {
    if (message.getMessageID() == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    Utils.writeWord(variableHeaderBuff,message.getMessageID());
  }
  variableHeaderBuff.put(message.getPayload());
  variableHeaderBuff.flip();
  int variableHeaderSize=variableHeaderBuff.remaining();
  byte flags=Utils.encodeFlags(message);
  IoBuffer buff=IoBuffer.allocate(2 + variableHeaderSize);
  buff.put((byte)(AbstractMessage.PUBLISH << 4 | flags));
  buff.put(Utils.encodeRemainingLength(variableHeaderSize));
  buff.put(variableHeaderBuff).flip();
  out.write(buff);
}"
27489,"@Test public void testEncodeWithQos_1_MessageID() throws Exception {
  String topic=""String_Node_Str"";
  PublishMessage msg=new PublishMessage();
  msg.setQos(QOSType.LEAST_ONE);
  msg.setMessageID(1);
  msg.setTopicName(topic);
  byte[] payload=new byte[]{0x0A,0x0B,0x0C};
  msg.setPayload(payload);
  m_encoder.encode(null,msg,m_mockProtoEncoder);
  assertEquals(0x32,m_mockProtoEncoder.getBuffer().get());
  assertEquals(26,m_mockProtoEncoder.getBuffer().get());
  verifyString(topic,m_mockProtoEncoder.getBuffer());
  assertEquals(0,m_mockProtoEncoder.getBuffer().get());
  assertEquals(1,m_mockProtoEncoder.getBuffer().get());
  verifyBuff(payload.length,payload,m_mockProtoEncoder.getBuffer());
}","@Test public void testEncodeWithQos_1_MessageID() throws Exception {
  String topic=""String_Node_Str"";
  PublishMessage msg=new PublishMessage();
  msg.setQos(QOSType.LEAST_ONE);
  msg.setMessageID(1);
  msg.setTopicName(topic);
  byte[] payload=new byte[]{0x0A,0x0B,0x0C};
  msg.setPayload(payload);
  m_encoder.encode(null,msg,m_mockProtoEncoder);
  assertEquals(0x32,m_mockProtoEncoder.getBuffer().get());
  assertEquals(14,m_mockProtoEncoder.getBuffer().get());
  verifyString(topic,m_mockProtoEncoder.getBuffer());
  assertEquals(0,m_mockProtoEncoder.getBuffer().get());
  assertEquals(1,m_mockProtoEncoder.getBuffer().get());
  verifyBuff(payload.length,payload,m_mockProtoEncoder.getBuffer());
}"
27490,"@Test public void testEncodeWithQos_0_noMessageID() throws Exception {
  String topic=""String_Node_Str"";
  PublishMessage msg=new PublishMessage();
  msg.setQos(QOSType.MOST_ONE);
  msg.setTopicName(topic);
  byte[] payload=new byte[]{0x0A,0x0B,0x0C};
  msg.setPayload(payload);
  m_encoder.encode(null,msg,m_mockProtoEncoder);
  assertEquals(0x30,m_mockProtoEncoder.getBuffer().get());
  assertEquals(24,m_mockProtoEncoder.getBuffer().get());
  verifyString(topic,m_mockProtoEncoder.getBuffer());
  verifyBuff(payload.length,payload,m_mockProtoEncoder.getBuffer());
}","@Test public void testEncodeWithQos_0_noMessageID() throws Exception {
  String topic=""String_Node_Str"";
  PublishMessage msg=new PublishMessage();
  msg.setQos(QOSType.MOST_ONE);
  msg.setTopicName(topic);
  byte[] payload=new byte[]{0x0A,0x0B,0x0C};
  msg.setPayload(payload);
  m_encoder.encode(null,msg,m_mockProtoEncoder);
  assertEquals(0x30,m_mockProtoEncoder.getBuffer().get());
  assertEquals(12,m_mockProtoEncoder.getBuffer().get());
  verifyString(topic,m_mockProtoEncoder.getBuffer());
  verifyBuff(payload.length,payload,m_mockProtoEncoder.getBuffer());
}"
27491,"protected MessageDecoderResult decodeCommonHeader(AbstractMessage message,IoBuffer in){
  if (in.remaining() < 2) {
    return NEED_DATA;
  }
  byte h1=in.get();
  byte messageType=(byte)((h1 & 0x0010) >> 4);
  boolean dupFlag=((byte)((h1 & 0x0008) >> 3) == 1);
  byte qosLevel=(byte)((h1 & 0x0006) >> 1);
  boolean retainFlag=((byte)(h1 & 0x0001) == 1);
  int remainingLength=Utils.decodeRemainingLenght(in);
  if (remainingLength == -1) {
    return NEED_DATA;
  }
  message.setMessageType(messageType);
  message.setDupFlag(dupFlag);
  message.setQos(AbstractMessage.QOSType.values()[qosLevel]);
  message.setRetainFlag(retainFlag);
  message.setRemainingLength(remainingLength);
  return OK;
}","protected MessageDecoderResult decodeCommonHeader(AbstractMessage message,IoBuffer in){
  if (in.remaining() < 2) {
    return NEED_DATA;
  }
  byte h1=in.get();
  byte messageType=(byte)((h1 & 0x00F0) >> 4);
  boolean dupFlag=((byte)((h1 & 0x0008) >> 3) == 1);
  byte qosLevel=(byte)((h1 & 0x0006) >> 1);
  boolean retainFlag=((byte)(h1 & 0x0001) == 1);
  int remainingLength=Utils.decodeRemainingLenght(in);
  if (remainingLength == -1) {
    return NEED_DATA;
  }
  message.setMessageType(messageType);
  message.setDupFlag(dupFlag);
  message.setQos(AbstractMessage.QOSType.values()[qosLevel]);
  message.setRetainFlag(retainFlag);
  message.setRemainingLength(remainingLength);
  return OK;
}"
27492,"@Test public void testHeader() throws Exception {
  m_buff=IoBuffer.allocate(14);
  initHeader(m_buff);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertNotNull(m_mockProtoDecoder.getMessage());
  assertEquals(MessageDecoder.OK,res);
  assertEquals(ConnAckMessage.CONNECTION_ACCEPTED,m_mockProtoDecoder.getMessage().getReturnCode());
}","@Test public void testHeader() throws Exception {
  m_buff=IoBuffer.allocate(14);
  initHeader(m_buff);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertNotNull(m_mockProtoDecoder.getMessage());
  assertEquals(MessageDecoder.OK,res);
  assertEquals(ConnAckMessage.CONNECTION_ACCEPTED,m_mockProtoDecoder.getMessage().getReturnCode());
  assertEquals(AbstractMessage.CONNACK,m_mockProtoDecoder.getMessage().getMessageType());
}"
27493,"@Test public void testBaseHeader_extra_with_user_pwd() throws UnsupportedEncodingException, Exception {
  m_buff=IoBuffer.allocate(55);
  initHeader(m_buff,(byte)53);
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  m_buff.flip();
  m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  verifyBaseHeader(m_mockProtoDecoder.getMessage());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getClientID());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getWillTopic());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getWillMessage());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getUsername());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getPassword());
}","@Test public void testBaseHeader_extra_with_user_pwd() throws UnsupportedEncodingException, Exception {
  m_buff=IoBuffer.allocate(55);
  initHeader(m_buff,(byte)53);
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  encodeString(m_buff,""String_Node_Str"");
  m_buff.flip();
  m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  verifyBaseHeader(m_mockProtoDecoder.getMessage());
  assertEquals(AbstractMessage.CONNECT,m_mockProtoDecoder.getMessage().getMessageType());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getClientID());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getWillTopic());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getWillMessage());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getUsername());
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getPassword());
}"
27494,"@Test public void testHeader() throws Exception {
  m_buff=IoBuffer.allocate(14);
  int messageId=0xAABB;
  initHeader(m_buff,messageId);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertNotNull(m_mockProtoDecoder.getMessage());
  assertEquals(MessageDecoder.OK,res);
  assertEquals(messageId,m_mockProtoDecoder.getMessage().getMessageID());
}","@Test public void testHeader() throws Exception {
  m_buff=IoBuffer.allocate(14);
  int messageId=0xAABB;
  initHeader(m_buff,messageId);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertNotNull(m_mockProtoDecoder.getMessage());
  assertEquals(MessageDecoder.OK,res);
  assertEquals(messageId,m_mockProtoDecoder.getMessage().getMessageID());
  assertEquals(AbstractMessage.PUBACK,m_mockProtoDecoder.getMessage().getMessageType());
}"
27495,"@Test public void testHeader() throws Exception {
  m_buff=IoBuffer.allocate(14);
  initHeader(m_buff);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertNotNull(m_mockProtoDecoder.getMessage());
  assertEquals(MessageDecoder.OK,res);
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getTopicName());
  assertNull(m_mockProtoDecoder.getMessage().getMessageID());
}","@Test public void testHeader() throws Exception {
  m_buff=IoBuffer.allocate(14);
  initHeader(m_buff);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertNotNull(m_mockProtoDecoder.getMessage());
  assertEquals(MessageDecoder.OK,res);
  assertEquals(""String_Node_Str"",m_mockProtoDecoder.getMessage().getTopicName());
  assertNull(m_mockProtoDecoder.getMessage().getMessageID());
  assertEquals(AbstractMessage.PUBLISH,m_mockProtoDecoder.getMessage().getMessageType());
}"
27496,"@Test public void testBadQos() throws Exception {
  initHeaderQos(m_buff,0xAABB,QOSType.LEAST_ONE,QOSType.MOST_ONE,QOSType.MOST_ONE);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertEquals(MessageDecoderResult.OK,res);
  assertEquals(0xAABB,m_mockProtoDecoder.getMessage().getMessageID());
  List<QOSType> qoses=m_mockProtoDecoder.getMessage().types();
  assertEquals(3,qoses.size());
  assertEquals(QOSType.LEAST_ONE,qoses.get(0));
  assertEquals(QOSType.MOST_ONE,qoses.get(1));
  assertEquals(QOSType.MOST_ONE,qoses.get(2));
}","@Test public void testBadQos() throws Exception {
  initHeaderQos(m_buff,0xAABB,QOSType.LEAST_ONE,QOSType.MOST_ONE,QOSType.MOST_ONE);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertEquals(MessageDecoderResult.OK,res);
  assertEquals(0xAABB,m_mockProtoDecoder.getMessage().getMessageID());
  List<QOSType> qoses=m_mockProtoDecoder.getMessage().types();
  assertEquals(3,qoses.size());
  assertEquals(QOSType.LEAST_ONE,qoses.get(0));
  assertEquals(QOSType.MOST_ONE,qoses.get(1));
  assertEquals(QOSType.MOST_ONE,qoses.get(2));
  assertEquals(AbstractMessage.SUBACK,m_mockProtoDecoder.getMessage().getMessageType());
}"
27497,"private void initHeaderQos(IoBuffer buff,int messageID,QOSType... qoss) throws IllegalAccessException {
  buff.clear().put((byte)(AbstractMessage.SUBSCRIBE << 4)).put(Utils.encodeRemainingLength(3));
  Utils.writeWord(buff,messageID);
  for (  QOSType qos : qoss) {
    buff.put((byte)qos.ordinal());
  }
}","private void initHeaderQos(IoBuffer buff,int messageID,QOSType... qoss) throws IllegalAccessException {
  buff.clear().put((byte)(AbstractMessage.SUBACK << 4)).put(Utils.encodeRemainingLength(3));
  Utils.writeWord(buff,messageID);
  for (  QOSType qos : qoss) {
    buff.put((byte)qos.ordinal());
  }
}"
27498,"@Test public void testMultiTopic() throws Exception {
  m_buff=IoBuffer.allocate(4).setAutoExpand(true);
  Couple c1=new Couple((byte)2,""String_Node_Str"");
  Couple c2=new Couple((byte)1,""String_Node_Str"");
  initMultiTopic(m_buff,123,c1,c2);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertEquals(MessageDecoderResult.OK,res);
  assertEquals(2,m_mockProtoDecoder.getMessage().subscriptions().size());
}","@Test public void testMultiTopic() throws Exception {
  m_buff=IoBuffer.allocate(4).setAutoExpand(true);
  Couple c1=new Couple((byte)2,""String_Node_Str"");
  Couple c2=new Couple((byte)1,""String_Node_Str"");
  initMultiTopic(m_buff,123,c1,c2);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertEquals(MessageDecoderResult.OK,res);
  assertEquals(2,m_mockProtoDecoder.getMessage().subscriptions().size());
  assertEquals(AbstractMessage.SUBSCRIBE,m_mockProtoDecoder.getMessage().getMessageType());
}"
27499,"private void initMultiTopic(IoBuffer buff,int messageID,String... topics) throws IllegalAccessException {
  IoBuffer topicBuffer=IoBuffer.allocate(4).setAutoExpand(true);
  Utils.writeWord(topicBuffer,messageID);
  for (  String topic : topics) {
    topicBuffer.put(Utils.encodeString(topic));
  }
  topicBuffer.flip();
  buff.clear().put((byte)(AbstractMessage.SUBSCRIBE << 4 | (byte)0x02)).put(Utils.encodeRemainingLength(topicBuffer.remaining()));
  buff.put(topicBuffer);
}","private void initMultiTopic(IoBuffer buff,int messageID,String... topics) throws IllegalAccessException {
  IoBuffer topicBuffer=IoBuffer.allocate(4).setAutoExpand(true);
  Utils.writeWord(topicBuffer,messageID);
  for (  String topic : topics) {
    topicBuffer.put(Utils.encodeString(topic));
  }
  topicBuffer.flip();
  buff.clear().put((byte)(AbstractMessage.UNSUBSCRIBE << 4 | (byte)0x02)).put(Utils.encodeRemainingLength(topicBuffer.remaining()));
  buff.put(topicBuffer);
}"
27500,"@Test public void testMultiTopic() throws Exception {
  m_buff=IoBuffer.allocate(4).setAutoExpand(true);
  String topic1=""String_Node_Str"";
  String topic2=""String_Node_Str"";
  initMultiTopic(m_buff,123,topic1,topic2);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertEquals(MessageDecoderResult.OK,res);
  assertEquals(2,m_mockProtoDecoder.getMessage().topics().size());
  assertEquals(topic1,m_mockProtoDecoder.getMessage().topics().get(0));
  assertEquals(topic2,m_mockProtoDecoder.getMessage().topics().get(1));
}","@Test public void testMultiTopic() throws Exception {
  m_buff=IoBuffer.allocate(4).setAutoExpand(true);
  String topic1=""String_Node_Str"";
  String topic2=""String_Node_Str"";
  initMultiTopic(m_buff,123,topic1,topic2);
  m_buff.flip();
  MessageDecoderResult res=m_msgdec.decode(null,m_buff,m_mockProtoDecoder);
  assertEquals(MessageDecoderResult.OK,res);
  assertEquals(2,m_mockProtoDecoder.getMessage().topics().size());
  assertEquals(topic1,m_mockProtoDecoder.getMessage().topics().get(0));
  assertEquals(topic2,m_mockProtoDecoder.getMessage().topics().get(1));
  assertEquals(AbstractMessage.UNSUBSCRIBE,m_mockProtoDecoder.getMessage().getMessageType());
}"
27501,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  NewsEntity newsEntity=mNewsList != null ? mNewsList.get(position) : null;
  if (newsEntity == null)   return;
  Intent intent=new Intent();
  intent.putExtra(""String_Node_Str"",newsEntity.id);
  intent.putExtra(""String_Node_Str"",newsEntity);
  intent.setClass(getActivity(),NewsDetailActivity.class);
  getActivity().startActivity(intent);
  boolean setReadFlag=ZhihuApplication.getNewsReadDataSource().readNews(String.valueOf(newsEntity.id));
  if (setReadFlag) {
    ZhihuUtils.setReadStatus4NewsEntity(mNewsList,newsEntity);
    mAdapter.updateData(mNewsList);
  }
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  NewsEntity newsEntity=mNewsList != null ? mNewsList.get(position) : null;
  if (newsEntity == null)   return;
  Intent intent=new Intent();
  intent.putExtra(""String_Node_Str"",newsEntity.id);
  intent.putExtra(""String_Node_Str"",newsEntity);
  intent.setClass(getActivity(),NewsDetailActivity.class);
  startActivity(intent);
  new SetReadFlagTask(newsEntity).executeOnExecutor(MyAsyncTask.THREAD_POOL_EXECUTOR);
}"
27502,"@Override protected NewsListEntity doInBackground(String... params){
  if (params.length == 0)   return null;
  String theKey=params[0];
  String oldContent=((NewsDataSource)getDataSource()).getContent(theKey);
  NewsListEntity newsListEntity=null;
  if (!TextUtils.isEmpty(oldContent)) {
    newsListEntity=(NewsListEntity)GsonUtils.getEntity(oldContent,NewsListEntity.class);
    if (newsListEntity != null) {
      ZhihuUtils.setReadStatus4NewsList(newsListEntity.stories);
    }
    return newsListEntity;
  }
 else {
    String newContent=null;
    try {
      newContent=getUrl(Constants.Url.URLDEFORE + ZhihuUtils.getAddedDate(theKey));
      newsListEntity=(NewsListEntity)GsonUtils.getEntity(newContent,NewsListEntity.class);
      isRefreshSuccess=!ListUtils.isEmpty(newsListEntity.stories);
    }
 catch (    IOException e) {
      e.printStackTrace();
      this.isRefreshSuccess=false;
      this.mException=e;
    }
catch (    Exception e) {
      e.printStackTrace();
      this.isRefreshSuccess=false;
      this.mException=e;
    }
    isContentSame=checkIsContentSame(oldContent,newContent);
    if (isRefreshSuccess && !isContentSame) {
      ((NewsDataSource)getDataSource()).insertOrUpdateNewsList(Constants.NEWS_LIST,theKey,newContent);
    }
    if (newsListEntity != null) {
      ZhihuUtils.setReadStatus4NewsList(newsListEntity.stories);
    }
    return newsListEntity;
  }
}","@Override protected Boolean doInBackground(String... params){
  return ZhihuApplication.getNewsReadDataSource().readNews(String.valueOf(mNewsEntity.id));
}"
27503,"@Override public void onPostExecute(NewsListEntity result){
  if (!isAdded())   return;
  mPullToRefreshLayout.setRefreshComplete();
  if (getView() != null) {
    setListShown(true);
  }
  if (result != null) {
    mNewsList=new ArrayList<NewsEntity>();
    NewsEntity tagNewsEntity=new NewsEntity();
    tagNewsEntity.isTag=true;
    tagNewsEntity.title=result.date;
    mNewsList.add(tagNewsEntity);
    mNewsList.addAll(result.stories);
    mCurrentDate=result.date;
    setAdapter(mNewsList);
  }
}","@Override protected void onPostExecute(Boolean result){
  super.onPostExecute(result);
  if (result) {
    ZhihuUtils.setReadStatus4NewsEntity(mNewsList,mNewsEntity);
    mAdapter.updateData(mNewsList);
  }
}"
27504,"@Override public void onPostExecute(ArrayList<NewsEntity> resultList,boolean isRefreshSuccess,boolean isContentSame){
  if (isAdded()) {
    mPullToRefreshLayout.setRefreshComplete();
    if (getView() != null) {
      setListShown(true);
    }
    if (isRefreshSuccess && !isContentSame) {
      mNewsList=resultList;
      if (mAdapter != null) {
        mAdapter.updateData(mNewsList);
      }
 else {
        mAdapter=new NewsAdapter(getActivity(),mNewsList);
        mListView.setAdapter(mAdapter);
      }
    }
  }
}","@Override public void onPostExecute(ArrayList<NewsEntity> resultList,boolean isRefreshSuccess,boolean isContentSame){
  if (isAdded()) {
    mPullToRefreshLayout.setRefreshComplete();
    if (getView() != null) {
      setListShown(true);
    }
    if (isRefreshSuccess && !isContentSame) {
      mNewsList=resultList;
      setAdapter(mNewsList);
    }
  }
}"
27505,"@SuppressLint(""String_Node_Str"") @Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if (requestCode == Constants.REQUESTCODE_SETTING) {
    NewsListFragment fragment=(NewsListFragment)getSupportFragmentManager().findFragmentById(android.R.id.content);
    fragment.updateList();
    SharedPreferences mPerferences=PreferenceManager.getDefaultSharedPreferences(this);
    if (isDarkTheme != mPerferences.getBoolean(""String_Node_Str"",false)) {
      recreateActivity();
    }
  }
}","@SuppressLint(""String_Node_Str"") @Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
  if (requestCode == Constants.REQUESTCODE_SETTING) {
    SharedPreferences mPerferences=PreferenceManager.getDefaultSharedPreferences(this);
    if (isDarkTheme != mPerferences.getBoolean(""String_Node_Str"",false)) {
      recreateActivity();
    }
  }
}"
27506,"@Override protected void onCreate(Bundle arg0){
  super.onCreate(arg0);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  Bundle bundle=new Bundle();
  bundle.putString(""String_Node_Str"",getIntent().getStringExtra(""String_Node_Str""));
  Fragment newFragment=getFragment();
  newFragment.setArguments(bundle);
  if (newFragment != null) {
    getSupportFragmentManager().beginTransaction().replace(android.R.id.content,newFragment).commit();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  if (savedInstanceState == null) {
    mImageUrl=getIntent().getStringExtra(""String_Node_Str"");
    Bundle bundle=new Bundle();
    bundle.putString(""String_Node_Str"",mImageUrl);
    Fragment newFragment=getFragment();
    newFragment.setArguments(bundle);
    if (newFragment != null) {
      getSupportFragmentManager().beginTransaction().replace(android.R.id.content,newFragment).commit();
    }
  }
 else {
    mImageUrl=savedInstanceState.getString(NEWS_DETAIL_IMAGE);
  }
}"
27507,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Bundle bundle=getArguments();
  mImageUrl=bundle != null ? bundle.getString(""String_Node_Str"") : ""String_Node_Str"";
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (savedInstanceState == null) {
    Bundle bundle=getArguments();
    mImageUrl=bundle != null ? bundle.getString(""String_Node_Str"") : ""String_Node_Str"";
  }
 else {
    mImageUrl=savedInstanceState.getString(IMAGE_URL);
  }
}"
27508,"@Override public void onPageFinished(WebView view,String url){
  super.onPageFinished(view,url);
  mLogger.i(""String_Node_Str"" + url);
  String urlStrArray[]=new String[mDetailImageList.size()];
  mDetailImageList.toArray(urlStrArray);
  if (NetWorkHelper.isMobile(getActivity()) && PreferenceManager.getDefaultSharedPreferences(getActivity()).getBoolean(""String_Node_Str"",false)) {
  }
 else {
    new DetailImageDownloadTask(getActivity(),new ResponseListener(){
      @Override public void onPreExecute(){
      }
      @Override public void onPostExecute(      String content,      boolean isRefreshSuccess,      boolean isContentSame){
        if (!isAdded()) {
          return;
        }
        String javascript=""String_Node_Str"";
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
          mWebView.evaluateJavascript(javascript,new ValueCallback<String>(){
            @TargetApi(Build.VERSION_CODES.HONEYCOMB) @Override public void onReceiveValue(            String s){
              JsonReader reader=new JsonReader(new StringReader(s));
              reader.setLenient(true);
              try {
                if (reader.peek() != JsonToken.NULL) {
                  if (reader.peek() == JsonToken.STRING) {
                    String msg=reader.nextString();
                    if (msg != null) {
                    }
                  }
                }
              }
 catch (              IOException e) {
                Log.e(""String_Node_Str"",""String_Node_Str"",e);
              }
 finally {
                try {
                  reader.close();
                }
 catch (                IOException e) {
                }
              }
            }
          }
);
        }
 else {
          mWebView.loadUrl(""String_Node_Str"" + javascript);
        }
      }
      @Override public void onProgressUpdate(      String value){
        if (!isAdded()) {
          return;
        }
        String javascript=""String_Node_Str"" + value + ""String_Node_Str"";
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
          mWebView.evaluateJavascript(javascript,new ValueCallback<String>(){
            @Override public void onReceiveValue(            String s){
              JsonReader reader=new JsonReader(new StringReader(s));
              reader.setLenient(true);
              try {
                if (reader.peek() != JsonToken.NULL) {
                  if (reader.peek() == JsonToken.STRING) {
                    String msg=reader.nextString();
                    if (msg != null) {
                    }
                  }
                }
              }
 catch (              IOException e) {
                Log.e(""String_Node_Str"",""String_Node_Str"",e);
              }
 finally {
                try {
                  reader.close();
                }
 catch (                IOException e) {
                }
              }
            }
          }
);
        }
 else {
          mWebView.loadUrl(""String_Node_Str"" + javascript);
        }
      }
      @Override public void onFail(      Exception e){
        e.printStackTrace();
      }
    }
).executeOnExecutor(MyAsyncTask.DOWNLOAD_THREAD_POOL_EXECUTOR,urlStrArray);
  }
}","@Override public void onPageFinished(WebView view,String url){
  super.onPageFinished(view,url);
  mLogger.i(""String_Node_Str"" + url);
  String urlStrArray[]=new String[mDetailImageList.size()];
  mDetailImageList.toArray(urlStrArray);
  if (!isAdded()) {
    return;
  }
  if (NetWorkHelper.isMobile(getActivity()) && PreferenceManager.getDefaultSharedPreferences(getActivity()).getBoolean(""String_Node_Str"",false)) {
  }
 else {
    new DetailImageDownloadTask(getActivity(),new ResponseListener(){
      @Override public void onPreExecute(){
      }
      @Override public void onPostExecute(      String content,      boolean isRefreshSuccess,      boolean isContentSame){
        if (!isAdded()) {
          return;
        }
        String javascript=""String_Node_Str"";
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
          mWebView.evaluateJavascript(javascript,new ValueCallback<String>(){
            @TargetApi(Build.VERSION_CODES.HONEYCOMB) @Override public void onReceiveValue(            String s){
              JsonReader reader=new JsonReader(new StringReader(s));
              reader.setLenient(true);
              try {
                if (reader.peek() != JsonToken.NULL) {
                  if (reader.peek() == JsonToken.STRING) {
                    String msg=reader.nextString();
                    if (msg != null) {
                    }
                  }
                }
              }
 catch (              IOException e) {
                Log.e(""String_Node_Str"",""String_Node_Str"",e);
              }
 finally {
                try {
                  reader.close();
                }
 catch (                IOException e) {
                }
              }
            }
          }
);
        }
 else {
          mWebView.loadUrl(""String_Node_Str"" + javascript);
        }
      }
      @Override public void onProgressUpdate(      String value){
        if (!isAdded()) {
          return;
        }
        String javascript=""String_Node_Str"" + value + ""String_Node_Str"";
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
          mWebView.evaluateJavascript(javascript,new ValueCallback<String>(){
            @Override public void onReceiveValue(            String s){
              JsonReader reader=new JsonReader(new StringReader(s));
              reader.setLenient(true);
              try {
                if (reader.peek() != JsonToken.NULL) {
                  if (reader.peek() == JsonToken.STRING) {
                    String msg=reader.nextString();
                    if (msg != null) {
                    }
                  }
                }
              }
 catch (              IOException e) {
                Log.e(""String_Node_Str"",""String_Node_Str"",e);
              }
 finally {
                try {
                  reader.close();
                }
 catch (                IOException e) {
                }
              }
            }
          }
);
        }
 else {
          mWebView.loadUrl(""String_Node_Str"" + javascript);
        }
      }
      @Override public void onFail(      Exception e){
        e.printStackTrace();
      }
    }
).executeOnExecutor(MyAsyncTask.DOWNLOAD_THREAD_POOL_EXECUTOR,urlStrArray);
  }
}"
27509,"@Override protected void doRefresh(){
  new GetNewsDetailTask(getActivity(),this).executeOnExecutor(MyAsyncTask.THREAD_POOL_EXECUTOR,String.valueOf(mNewsId));
}","@Override protected void doRefresh(){
  if (!isAdded()) {
    new GetNewsDetailTask(getActivity(),this).executeOnExecutor(MyAsyncTask.THREAD_POOL_EXECUTOR,String.valueOf(mNewsId));
  }
}"
27510,"@Override public Optional<LightEmissionProperty> getFor(Location<World> location){
  net.minecraft.world.World world=(net.minecraft.world.World)location.getExtent();
  Block block=(Block)location.getBlockType();
  final BlockState blockState=location.getBlock();
  return Optional.of(new LightEmissionProperty(block.getLightValue(BlockUtil.toNative(blockState),world,VecHelper.toBlockPos(location))));
}","@Override public Optional<LightEmissionProperty> getFor(Location<World> location){
}"
27511,"@Override protected Optional<MatterProperty> getForBlock(IBlockState block){
  if (block.getBlock() instanceof BlockLiquid || block.getBlock() instanceof BlockFluidBase || block.getBlock() instanceof IFluidBlock) {
    return Optional.of(LIQUID);
  }
 else   if (block.getMaterial() == Material.AIR) {
    return Optional.of(GAS);
  }
 else {
    return Optional.of(SOLID);
  }
}","@Override protected Optional<MatterProperty> getForBlock(@Nullable Location<?> location,IBlockState block){
  if (block.getBlock() instanceof BlockLiquid || block.getBlock() instanceof BlockFluidBase || block.getBlock() instanceof IFluidBlock) {
    return Optional.of(LIQUID);
  }
 else   if (block.getMaterial() == Material.AIR) {
    return Optional.of(GAS);
  }
 else {
    return Optional.of(SOLID);
  }
}"
27512,"private static NotifyNeighborBlockEvent callNeighborNotifyEvent(Event event){
  NotifyNeighborBlockEvent spongeEvent=(NotifyNeighborBlockEvent)event;
  LocatableBlock locatableBlock=spongeEvent.getCause().first(LocatableBlock.class).orElse(null);
  TileEntity tileEntitySource=spongeEvent.getCause().first(TileEntity.class).orElse(null);
  Location<World> sourceLocation;
  IBlockState state;
  if (locatableBlock != null) {
    sourceLocation=locatableBlock.getLocation();
    state=(IBlockState)locatableBlock.getBlockState();
  }
 else   if (tileEntitySource != null) {
    sourceLocation=tileEntitySource.getLocation();
    state=(IBlockState)sourceLocation.getBlock();
  }
 else {
    return spongeEvent;
  }
  EnumSet<EnumFacing> facings=EnumSet.noneOf(EnumFacing.class);
  for (  Map.Entry<Direction,BlockState> mapEntry : spongeEvent.getNeighbors().entrySet()) {
    if (mapEntry.getKey() != Direction.NONE) {
      facings.add(DirectionFacingProvider.getInstance().get(mapEntry.getKey()).get());
    }
  }
  if (facings.isEmpty()) {
    return spongeEvent;
  }
  BlockPos pos=((IMixinLocation)(Object)sourceLocation).getBlockPos();
  net.minecraft.world.World world=(net.minecraft.world.World)sourceLocation.getExtent();
  final NeighborNotifyEvent forgeEvent=new NeighborNotifyEvent(world,pos,state,facings,false);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}","private static NotifyNeighborBlockEvent callNeighborNotifyEvent(Event event){
  NotifyNeighborBlockEvent spongeEvent=(NotifyNeighborBlockEvent)event;
  LocatableBlock locatableBlock=spongeEvent.getCause().first(LocatableBlock.class).orElse(null);
  TileEntity tileEntitySource=spongeEvent.getCause().first(TileEntity.class).orElse(null);
  Location<World> sourceLocation;
  IBlockState state;
  if (locatableBlock != null) {
    sourceLocation=locatableBlock.getLocation();
    state=(IBlockState)locatableBlock.getBlockState();
  }
 else   if (tileEntitySource != null) {
    sourceLocation=tileEntitySource.getLocation();
    state=(IBlockState)sourceLocation.getBlock();
  }
 else {
    return spongeEvent;
  }
  EnumSet<EnumFacing> facings=EnumSet.noneOf(EnumFacing.class);
  for (  Map.Entry<Direction,BlockState> mapEntry : spongeEvent.getNeighbors().entrySet()) {
    if (mapEntry.getKey() != Direction.NONE) {
      facings.add(DirectionFacingProvider.getInstance().get(mapEntry.getKey()).get());
    }
  }
  if (facings.isEmpty()) {
    return spongeEvent;
  }
  BlockPos pos=VecHelper.toBlockPos(sourceLocation);
  net.minecraft.world.World world=(net.minecraft.world.World)sourceLocation.getExtent();
  final NeighborNotifyEvent forgeEvent=new NeighborNotifyEvent(world,pos,state,facings,false);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}"
27513,"/** 
 * @author gabizou - April 8th, 2018
 * @reason This overwrites the forge handling to cater to Sponge's villager handling.There have been too many bugs with the re-assignment of VillagerProfessions and mods not registering them normally, which ends up causing sync issues between the forge professions and sponge professions. This aims to have failsafes for handling with Sponge's system.
 */
@SuppressWarnings(""String_Node_Str"") @Overwrite public void populateBuyingList(){
  final VillagerRegistry.VillagerProfession professionForge=this.getProfessionForge();
  if (this.careerId != 0 && this.careerLevel != 0) {
    ++this.careerLevel;
  }
 else {
    this.careerId=professionForge.getRandomCareer(this.rand) + 1;
    this.careerLevel=1;
  }
  if (this.buyingList == null) {
    this.buyingList=new MerchantRecipeList();
  }
  int careerNumberId=this.careerId - 1;
  int careerLevel=this.careerLevel - 1;
  final VillagerRegistry.VillagerCareer career=professionForge.getCareer(careerNumberId);
  final IMixinVillagerCareer mixinCareer=(IMixinVillagerCareer)career;
  if (mixinCareer.isDelayed() && SpongeImpl.isMainThread()) {
    mixinCareer.performDelayedInit();
  }
  if (false) {
    SpongeForgeVillagerRegistry.populateOffers(this,career,careerLevel,rand);
    return;
  }
  SpongeForgeVillagerRegistry.spongePopupateList(this,professionForge,careerNumberId,careerLevel,this.rand);
}","/** 
 * @author gabizou - April 8th, 2018
 * @reason This overwrites the forge handling to cater to Sponge's villager handling.There have been too many bugs with the re-assignment of VillagerProfessions and mods not registering them normally, which ends up causing sync issues between the forge professions and sponge professions. This aims to have failsafes for handling with Sponge's system.
 */
@SuppressWarnings(""String_Node_Str"") @Overwrite public void populateBuyingList(){
  final VillagerRegistry.VillagerProfession professionForge=this.getProfessionForge();
  if (this.careerId != 0 && this.careerLevel != 0) {
    ++this.careerLevel;
  }
 else {
    this.careerId=professionForge.getRandomCareer(this.rand) + 1;
    this.careerLevel=1;
  }
  if (this.buyingList == null) {
    this.buyingList=new MerchantRecipeList();
  }
  int careerNumberId=this.careerId - 1;
  int careerLevel=this.careerLevel - 1;
  final VillagerRegistry.VillagerCareer career=professionForge.getCareer(careerNumberId);
  final IMixinVillagerCareer mixinCareer=(IMixinVillagerCareer)career;
  if (mixinCareer.isDelayed() && SpongeImpl.isMainThread()) {
    mixinCareer.performDelayedInit();
  }
  if (mixinCareer.isModded()) {
    SpongeForgeVillagerRegistry.populateOffers(this,career,careerLevel,rand);
    return;
  }
  SpongeForgeVillagerRegistry.spongePopupateList(this,professionForge,careerNumberId,careerLevel,this.rand);
}"
27514,"@SuppressWarnings(""String_Node_Str"") public static void spongePopupateList(IMixinEntityVillagerForge mixinEntityVillager,VillagerRegistry.VillagerProfession professionForge,int careerNumberId,int careerLevel,Random rand){
  if (mixinEntityVillager.getProfession() == null) {
    mixinEntityVillager.setProfession(SpongeForgeVillagerRegistry.fromNative(professionForge));
  }
  final Profession profession=mixinEntityVillager.getProfession().get();
  final VillagerRegistry.VillagerCareer career=professionForge.getCareer(careerNumberId);
  final List<Career> careers=((SpongeProfession)profession).getUnderlyingCareers();
  if (careers.size() <= careerNumberId) {
    final List<Career> underlyingCareers=((SpongeProfession)profession).getUnderlyingCareers();
    underlyingCareers.clear();
    final IMixinVillagerProfession mixinProfession=(IMixinVillagerProfession)professionForge;
    for (    VillagerRegistry.VillagerCareer villagerCareer : mixinProfession.getCareers()) {
      fromNative(villagerCareer);
    }
    if (careers.size() <= careerNumberId) {
      printMismatch(careerNumberId,profession,careers,mixinProfession);
      populateOffers(mixinEntityVillager,career,careerLevel,rand);
      return;
    }
  }
  final SpongeCareer spongeCareer=(SpongeCareer)careers.get(careerNumberId);
  SpongeVillagerRegistry.getInstance().populateOffers((Merchant)mixinEntityVillager,(List<TradeOffer>)(List<?>)mixinEntityVillager.getForgeTrades(),spongeCareer,careerLevel,rand);
}","@SuppressWarnings(""String_Node_Str"") public static void spongePopupateList(IMixinEntityVillagerForge mixinEntityVillager,VillagerRegistry.VillagerProfession professionForge,int careerNumberId,int careerLevel,Random rand){
  if (!mixinEntityVillager.getProfession().isPresent()) {
    mixinEntityVillager.setProfession(SpongeForgeVillagerRegistry.fromNative(professionForge));
  }
  final Profession profession=mixinEntityVillager.getProfession().get();
  final VillagerRegistry.VillagerCareer career=professionForge.getCareer(careerNumberId);
  final List<Career> careers=((SpongeProfession)profession).getUnderlyingCareers();
  if (careers.size() <= careerNumberId) {
    final List<Career> underlyingCareers=((SpongeProfession)profession).getUnderlyingCareers();
    underlyingCareers.clear();
    final IMixinVillagerProfession mixinProfession=(IMixinVillagerProfession)professionForge;
    for (    VillagerRegistry.VillagerCareer villagerCareer : mixinProfession.getCareers()) {
      fromNative(villagerCareer);
    }
    if (careers.size() <= careerNumberId) {
      printMismatch(careerNumberId,profession,careers,mixinProfession);
      populateOffers(mixinEntityVillager,career,careerLevel,rand);
      return;
    }
  }
  final SpongeCareer spongeCareer=(SpongeCareer)careers.get(careerNumberId);
  SpongeVillagerRegistry.getInstance().populateOffers((Merchant)mixinEntityVillager,(List<TradeOffer>)(List<?>)mixinEntityVillager.getForgeTrades(),spongeCareer,careerLevel + 1,rand);
}"
27515,"/** 
 * @author gabizou - May 23rd, 2018
 * @reason - Even though Dedicated server does handle this change, I'm inlining theblock check for the player since
 * @param player
 * @param pos
 * @return True if the block is modifiable
 */
@Override @Overwrite @Override public boolean isBlockModifiable(EntityPlayer player,BlockPos pos){
  if (super.isBlockModifiable(player,pos)) {
    return true;
  }
  if (!this.isFake() && ServerUtils.isCallingFromMainThread()) {
    try (CauseStackManager.StackFrame frame=Sponge.getCauseStackManager().pushCauseFrame()){
      frame.addContext(EventContextKeys.USED_ITEM,ItemStackUtil.snapshotOf(player.getActiveItemStack()));
      return SpongeCommonEventFactory.callChangeBlockEventPre(this,pos,player).isCancelled();
    }
   }
  return false;
}","/** 
 * @author gabizou - May 23rd, 2018
 * @reason - Even though Dedicated server does handle this change, I'm inlining theblock check for the player since
 * @param player
 * @param pos
 * @return True if the block is modifiable
 */
@Overwrite @Override public boolean isBlockModifiable(EntityPlayer player,BlockPos pos){
  if (super.isBlockModifiable(player,pos)) {
    return true;
  }
  if (!this.isFake() && ServerUtils.isCallingFromMainThread()) {
    try (CauseStackManager.StackFrame frame=Sponge.getCauseStackManager().pushCauseFrame()){
      frame.addContext(EventContextKeys.USED_ITEM,ItemStackUtil.snapshotOf(player.getActiveItemStack()));
      return SpongeCommonEventFactory.callChangeBlockEventPre(this,pos,player).isCancelled();
    }
   }
  return false;
}"
27516,"@Override public Class<?> getCustomResourcePackClass(){
  if (getSource().isDirectory()) {
    return FMLFolderResourcePack.class;
  }
  return FMLFileResourcePack.class;
}","@Override public Class<?> getCustomResourcePackClass(){
  if (this.getSource().isDirectory()) {
    return FMLFolderResourcePack.class;
  }
  return FMLFileResourcePack.class;
}"
27517,"@Subscribe public void onPreInit(FMLPreInitializationEvent event){
  try {
    SpongeImpl.getGame().getEventManager().registerListeners(SpongeImpl.getPlugin().getInstance().get(),SpongeInternalListeners.getInstance());
    registerService(ChunkTicketManager.class,new SpongeChunkTicketManager());
    SpongeBootstrap.initializeServices();
    SpongeBootstrap.initializeCommands();
    SpongeImpl.getRegistry().preInit();
    SpongeModMessageHandler.init();
    Preconditions.checkArgument(Class.forName(""String_Node_Str"").getSuperclass().equals(SpongeEntityAICommonSuperclass.class));
    MinecraftForge.EVENT_BUS.register(new SpongeEventHooks());
    SpongeInternalListeners.getInstance().registerServiceCallback(PermissionService.class,input -> input.registerContextCalculator(new SpongeContextCalculator()));
    MinecraftForge.EVENT_BUS.register(this);
    MinecraftForge.EVENT_BUS.register(this.game.getChannelRegistrar());
    if (event.getSide().isServer()) {
      SpongeHooks.enableThreadContentionMonitoring();
    }
  }
 catch (  Throwable t) {
    this.controller.errorOccurred(this,t);
  }
}","@Subscribe public void onPreInit(FMLPreInitializationEvent event){
  try {
    SpongeImpl.getGame().getEventManager().registerListeners(SpongeImpl.getPlugin().getInstance().get(),SpongeInternalListeners.getInstance());
    this.registerService(ChunkTicketManager.class,new SpongeChunkTicketManager());
    SpongeBootstrap.initializeServices();
    SpongeBootstrap.initializeCommands();
    SpongeImpl.getRegistry().preInit();
    SpongeModMessageHandler.init();
    Preconditions.checkArgument(Class.forName(""String_Node_Str"").getSuperclass().equals(SpongeEntityAICommonSuperclass.class));
    MinecraftForge.EVENT_BUS.register(new SpongeEventHooks());
    SpongeInternalListeners.getInstance().registerServiceCallback(PermissionService.class,input -> input.registerContextCalculator(new SpongeContextCalculator()));
    MinecraftForge.EVENT_BUS.register(this);
    MinecraftForge.EVENT_BUS.register(this.game.getChannelRegistrar());
    if (event.getSide().isServer()) {
      SpongeHooks.enableThreadContentionMonitoring();
    }
  }
 catch (  Throwable t) {
    this.controller.errorOccurred(this,t);
  }
}"
27518,"public SpongeMod() throws Exception {
  super(SpongeModMetadata.getSpongeForgeMetadata());
  ModContainerFactory.instance().registerContainerType(Type.getType(Plugin.class),SpongeModPluginContainer.class);
  SpongeMod.instance=this;
  this.modFile=SpongeCoremod.modFile;
  final Stage stage=SpongeGuice.getInjectorStage((Boolean)Launch.blackboard.get(""String_Node_Str"") ? Stage.DEVELOPMENT : Stage.PRODUCTION);
  SpongeImpl.getLogger().info(""String_Node_Str"",stage);
  Guice.createInjector(stage,new SpongeModule(),new SpongeForgeModule());
  SpongeImpl.getRegistry().preRegistryInit();
  SpongeGameData.addRegistryCallback(ForgeRegistries.BLOCKS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.BLOCKS.getKey(obj);
    if (key == null || ((IMixinBlock)obj).isDummy()) {
      return;
    }
    BlockTypeRegistryModule.getInstance().registerFromGameData(key.toString(),(BlockType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.ITEMS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.ITEMS.getKey(obj);
    if (key == null) {
      return;
    }
    ItemTypeRegistryModule.getInstance().registerFromGameData(key.toString(),(ItemType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.ENCHANTMENTS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.ENCHANTMENTS.getKey(obj);
    if (key == null) {
      return;
    }
    EnchantmentRegistryModule.getInstance().registerFromGameData(key.toString(),(EnchantmentType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.POTIONS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.POTIONS.getKey(obj);
    if (key == null) {
      return;
    }
    PotionEffectTypeRegistryModule.getInstance().registerFromGameData(key.toString(),(PotionEffectType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.VILLAGER_PROFESSIONS,((owner,manager,id,obj,oldObj) -> {
    final IMixinVillagerProfession mixinProfession=(IMixinVillagerProfession)obj;
    final SpongeProfession spongeProfession=new SpongeProfession(id,mixinProfession.getId(),mixinProfession.getProfessionName());
    final SpongeProfession registeredProfession=SpongeForgeVillagerRegistry.validateProfession(obj,spongeProfession);
    ProfessionRegistryModule.getInstance().registerAdditionalCatalog(registeredProfession);
    for (    VillagerRegistry.VillagerCareer career : mixinProfession.getCareers()) {
      SpongeForgeVillagerRegistry.registerForgeCareer(career);
    }
  }
));
  SpongeGameData.addRegistryCallback(ForgeRegistries.SOUND_EVENTS,(owner,manager,id,obj,oldObj) -> SoundRegistryModule.inst().registerAdditionalCatalog((SoundType)obj));
  SpongeForgeModuleRegistry.registerForgeData();
  this.game.getEventManager().registerListeners(this,this);
  SpongeImpl.getInternalPlugins().add((PluginContainer)ForgeModContainer.getInstance());
}","public SpongeMod() throws Exception {
  super(SpongeModMetadata.getSpongeForgeMetadata());
  ModContainerFactory.instance().registerContainerType(Type.getType(Plugin.class),SpongeModPluginContainer.class);
  SpongeMod.instance=this;
  this.modFile=SpongeCoremod.modFile;
  final Stage stage=SpongeGuice.getInjectorStage((Boolean)Launch.blackboard.get(""String_Node_Str"") ? Stage.DEVELOPMENT : Stage.PRODUCTION);
  SpongeImpl.getLogger().info(""String_Node_Str"",stage);
  Guice.createInjector(stage,new SpongeModule(),new SpongeForgeModule());
  SpongeImpl.getRegistry().preRegistryInit();
  SpongeGameData.addRegistryCallback(ForgeRegistries.BLOCKS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.BLOCKS.getKey(obj);
    if (key == null || ((IMixinBlock)obj).isDummy()) {
      return;
    }
    BlockTypeRegistryModule.getInstance().registerFromGameData(key.toString(),(BlockType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.ITEMS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.ITEMS.getKey(obj);
    if (key == null) {
      return;
    }
    ItemTypeRegistryModule.getInstance().registerFromGameData(key.toString(),(ItemType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.ENCHANTMENTS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.ENCHANTMENTS.getKey(obj);
    if (key == null) {
      return;
    }
    EnchantmentRegistryModule.getInstance().registerFromGameData(key.toString(),(EnchantmentType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.POTIONS,(owner,manager,id,obj,oldObj) -> {
    final ResourceLocation key=ForgeRegistries.POTIONS.getKey(obj);
    if (key == null) {
      return;
    }
    PotionEffectTypeRegistryModule.getInstance().registerFromGameData(key.toString(),(PotionEffectType)obj);
  }
);
  SpongeGameData.addRegistryCallback(ForgeRegistries.VILLAGER_PROFESSIONS,((owner,manager,id,obj,oldObj) -> {
    final IMixinVillagerProfession mixinProfession=(IMixinVillagerProfession)obj;
    final SpongeProfession spongeProfession=new SpongeProfession(id,mixinProfession.getId(),mixinProfession.getProfessionName());
    final SpongeProfession registeredProfession=SpongeForgeVillagerRegistry.syncProfession(obj,spongeProfession);
    ProfessionRegistryModule.getInstance().registerAdditionalCatalog(registeredProfession);
    for (    VillagerRegistry.VillagerCareer career : mixinProfession.getCareers()) {
      SpongeForgeVillagerRegistry.registerForgeCareer(career);
    }
  }
));
  SpongeGameData.addRegistryCallback(ForgeRegistries.SOUND_EVENTS,(owner,manager,id,obj,oldObj) -> SoundRegistryModule.inst().registerAdditionalCatalog((SoundType)obj));
  SpongeForgeModuleRegistry.registerForgeData();
  this.game.getEventManager().registerListeners(this,this);
  SpongeImpl.getInternalPlugins().add((PluginContainer)ForgeModContainer.getInstance());
}"
27519,"public static LoadChunkEvent createLoadChunkEvent(ChunkEvent.Load forgeEvent){
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  if (isMainThread) {
    Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  }
  final Cause cause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),forgeEvent.getWorld());
  return SpongeEventFactory.createLoadChunkEvent(cause,(Chunk)forgeEvent.getChunk());
}","private static LoadChunkEvent createLoadChunkEvent(ChunkEvent.Load forgeEvent){
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  if (isMainThread) {
    Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  }
  final Cause cause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),forgeEvent.getWorld());
  return SpongeEventFactory.createLoadChunkEvent(cause,(Chunk)forgeEvent.getChunk());
}"
27520,"public static ChangeInventoryEvent.Pickup.Pre callEntityItemPickupEvent(Event event){
  ChangeInventoryEvent.Pickup.Pre spongeEvent=(ChangeInventoryEvent.Pickup.Pre)event;
  EntityItem entityItem=(EntityItem)spongeEvent.getTargetEntity();
  EntityItemPickupEvent forgeEvent=new EntityItemPickupEvent((EntityPlayer)spongeEvent.getCause().first(Player.class).get(),entityItem);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}","private static ChangeInventoryEvent.Pickup.Pre callEntityItemPickupEvent(Event event){
  final ChangeInventoryEvent.Pickup.Pre spongeEvent=(ChangeInventoryEvent.Pickup.Pre)event;
  if (spongeEvent.getTargetEntity() instanceof EntityItem) {
    final EntityItem entityItem=(EntityItem)spongeEvent.getTargetEntity();
    final Player player=spongeEvent.getCause().first(Player.class).orElse(null);
    if (player != null) {
      final EntityItemPickupEvent forgeEvent=new EntityItemPickupEvent((EntityPlayer)player,entityItem);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
  }
  return spongeEvent;
}"
27521,"private static void handleCustomStack(SpawnEntityEvent event){
  ListIterator<org.spongepowered.api.entity.Entity> it=event.getEntities().listIterator();
  while (it.hasNext()) {
    Entity entity=(Entity)it.next();
    if (entity.getClass().equals(EntityItem.class)) {
      ItemStack stack=((EntityItem)entity).getItem();
      if (stack.isEmpty()) {
        continue;
      }
      Item item=stack.getItem();
      if (item == null) {
        FMLLog.warning(""String_Node_Str"" + ""String_Node_Str"",entity.posX,entity.posY,entity.posZ);
        entity.setDead();
        event.setCancelled(true);
        continue;
      }
      if (item.hasCustomEntity(stack)) {
        Entity newEntity=item.createEntity(entity.getEntityWorld(),entity,stack);
        if (newEntity != null) {
          entity.setDead();
          EntityJoinWorldEvent cancelledEvent=new EntityJoinWorldEvent(entity,entity.getEntityWorld());
          cancelledEvent.setCanceled(true);
          ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(cancelledEvent,true);
          if (!cancelledEvent.isCanceled()) {
            SpongeImpl.getLogger().error(""String_Node_Str"");
          }
          it.set((org.spongepowered.api.entity.Entity)newEntity);
          continue;
        }
      }
    }
  }
}","private static void handleCustomStack(SpawnEntityEvent event){
  ListIterator<org.spongepowered.api.entity.Entity> it=event.getEntities().listIterator();
  while (it.hasNext()) {
    Entity entity=(Entity)it.next();
    if (entity instanceof EntityItem) {
      final ItemStack stack=((EntityItem)entity).getItem();
      if (stack.isEmpty()) {
        FMLLog.warning(""String_Node_Str"" + ""String_Node_Str"",entity.posX,entity.posY,entity.posZ);
        entity.setDead();
        continue;
      }
      final Item item=stack.getItem();
      if (item.hasCustomEntity(stack)) {
        final Entity newEntity=item.createEntity(entity.getEntityWorld(),entity,stack);
        if (newEntity != null) {
          entity.setDead();
          final EntityJoinWorldEvent cancelledEvent=new EntityJoinWorldEvent(entity,entity.getEntityWorld());
          cancelledEvent.setCanceled(true);
          ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(cancelledEvent,true);
          if (!cancelledEvent.isCanceled()) {
            SpongeImpl.getLogger().error(""String_Node_Str"");
          }
          it.set((org.spongepowered.api.entity.Entity)newEntity);
        }
      }
    }
  }
}"
27522,"public static ChangeBlockEvent.Place callBlockPlaceEvent(Event event){
  ChangeBlockEvent.Place spongeEvent=(ChangeBlockEvent.Place)event;
  if (spongeEvent.getCause().root() instanceof Player) {
    EntityPlayer player=(EntityPlayer)spongeEvent.getCause().first(Player.class).get();
    net.minecraft.world.World world=player.world;
    final PhaseTracker phaseTracker=PhaseTracker.getInstance();
    final PhaseContext<?> currentContext=phaseTracker.getCurrentContext();
    PhaseContext<?> target=currentContext;
    if (currentContext instanceof UnwindingPhaseContext) {
      target=((UnwindingPhaseContext)currentContext).getUnwindingContext();
    }
    PacketContext<?> context=target instanceof PacketContext<?> ? (PacketContext<?>)target : null;
    Packet<?> contextPacket=context != null ? context.getPacket() : null;
    if (contextPacket == null) {
      return spongeEvent;
    }
    if (spongeEvent.getTransactions().size() == 1) {
      BlockPos pos=VecHelper.toBlockPos(spongeEvent.getTransactions().get(0).getOriginal().getPosition());
      IBlockState state=(IBlockState)spongeEvent.getTransactions().get(0).getOriginal().getState();
      net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshot.getWorld().getBlockState(blockSnapshot.getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.PlaceEvent forgeEvent=new BlockEvent.PlaceEvent(blockSnapshot,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
 else {
      Iterator<Transaction<BlockSnapshot>> iterator=spongeEvent.getTransactions().iterator();
      List<net.minecraftforge.common.util.BlockSnapshot> blockSnapshots=new ArrayList<>();
      while (iterator.hasNext()) {
        Transaction<BlockSnapshot> transaction=iterator.next();
        Location<World> location=transaction.getOriginal().getLocation().get();
        IBlockState state=(IBlockState)transaction.getOriginal().getState();
        BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
        net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
        blockSnapshots.add(blockSnapshot);
      }
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshots.get(0).getWorld().getBlockState(blockSnapshots.get(0).getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.MultiPlaceEvent forgeEvent=new BlockEvent.MultiPlaceEvent(blockSnapshots,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
  }
  return spongeEvent;
}","private static ChangeBlockEvent.Place callBlockPlaceEvent(Event event){
  ChangeBlockEvent.Place spongeEvent=(ChangeBlockEvent.Place)event;
  if (spongeEvent.getCause().root() instanceof Player) {
    EntityPlayer player=(EntityPlayer)spongeEvent.getCause().root();
    net.minecraft.world.World world=player.world;
    final PhaseTracker phaseTracker=PhaseTracker.getInstance();
    final PhaseContext<?> currentContext=phaseTracker.getCurrentContext();
    PhaseContext<?> target=currentContext;
    if (currentContext instanceof UnwindingPhaseContext) {
      target=((UnwindingPhaseContext)currentContext).getUnwindingContext();
    }
    PacketContext<?> context=target instanceof PacketContext<?> ? (PacketContext<?>)target : null;
    Packet<?> contextPacket=context != null ? context.getPacket() : null;
    if (contextPacket == null) {
      return spongeEvent;
    }
    if (spongeEvent.getTransactions().size() == 1) {
      BlockPos pos=VecHelper.toBlockPos(spongeEvent.getTransactions().get(0).getOriginal().getPosition());
      IBlockState state=(IBlockState)spongeEvent.getTransactions().get(0).getOriginal().getState();
      net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshot.getWorld().getBlockState(blockSnapshot.getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.PlaceEvent forgeEvent=new BlockEvent.PlaceEvent(blockSnapshot,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
 else {
      Iterator<Transaction<BlockSnapshot>> iterator=spongeEvent.getTransactions().iterator();
      List<net.minecraftforge.common.util.BlockSnapshot> blockSnapshots=new ArrayList<>();
      while (iterator.hasNext()) {
        Transaction<BlockSnapshot> transaction=iterator.next();
        Location<World> location=transaction.getOriginal().getLocation().get();
        IBlockState state=(IBlockState)transaction.getOriginal().getState();
        BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
        net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
        blockSnapshots.add(blockSnapshot);
      }
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshots.get(0).getWorld().getBlockState(blockSnapshots.get(0).getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.MultiPlaceEvent forgeEvent=new BlockEvent.MultiPlaceEvent(blockSnapshots,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
  }
  return spongeEvent;
}"
27523,"public static UnloadChunkEvent createUnloadChunkEvent(ChunkEvent.Unload forgeEvent){
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  if (isMainThread) {
    Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  }
  final Cause cause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),forgeEvent.getWorld());
  return SpongeEventFactory.createUnloadChunkEvent(cause,(Chunk)forgeEvent.getChunk());
}","private static UnloadChunkEvent createUnloadChunkEvent(ChunkEvent.Unload forgeEvent){
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  if (isMainThread) {
    Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  }
  final Cause cause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),forgeEvent.getWorld());
  return SpongeEventFactory.createUnloadChunkEvent(cause,(Chunk)forgeEvent.getChunk());
}"
27524,"public static Event createSpongeEvent(net.minecraftforge.fml.common.eventhandler.Event forgeEvent){
  if (forgeEvent instanceof BlockEvent.MultiPlaceEvent) {
    return createChangeBlockEventPlace((BlockEvent.MultiPlaceEvent)forgeEvent);
  }
  if (forgeEvent instanceof BlockEvent.PlaceEvent) {
    return createChangeBlockEventPlace((BlockEvent.PlaceEvent)forgeEvent);
  }
  if (forgeEvent instanceof BlockEvent.BreakEvent) {
    return createChangeBlockEventPre((BlockEvent.BreakEvent)forgeEvent);
  }
  if (forgeEvent instanceof ServerChatEvent) {
    return createMessageChannelEventChat((ServerChatEvent)forgeEvent);
  }
  if (forgeEvent instanceof PlayerSleepInBedEvent) {
    return createSleepingEventPre((PlayerSleepInBedEvent)forgeEvent);
  }
  if (forgeEvent instanceof ChunkEvent.Load) {
    return createLoadChunkEvent((ChunkEvent.Load)forgeEvent);
  }
  if (forgeEvent instanceof ChunkEvent.Unload) {
    return createUnloadChunkEvent((ChunkEvent.Unload)forgeEvent);
  }
  return null;
}","public static Event createSpongeEvent(net.minecraftforge.fml.common.eventhandler.Event forgeEvent){
  return propgateCancellation(createSpongeEventImpl(forgeEvent),forgeEvent);
}"
27525,"public static Event callForgeEvent(Event spongeEvent,Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz){
  if (EntityItemPickupEvent.class.isAssignableFrom(clazz)) {
    return callEntityItemPickupEvent(spongeEvent);
  }
 else   if (PlayerInteractEvent.EntityInteractSpecific.class.isAssignableFrom(clazz)) {
    return callEntityInteractEvent(spongeEvent);
  }
 else   if (PlayerInteractEvent.EntityInteract.class.isAssignableFrom(clazz)) {
    return callEntityInteractEvent(spongeEvent);
  }
 else   if (BlockEvent.NeighborNotifyEvent.class.isAssignableFrom(clazz)) {
    return callNeighborNotifyEvent(spongeEvent);
  }
 else   if (BlockEvent.PlaceEvent.class.isAssignableFrom(clazz)) {
    return callBlockPlaceEvent(spongeEvent);
  }
 else   if (PlayerInteractEvent.class.isAssignableFrom(clazz)) {
    return createPlayerInteractEvent(spongeEvent);
  }
 else   if (LivingDropsEvent.class.isAssignableFrom(clazz)) {
    return callLivingDropsEvent(spongeEvent);
  }
 else   if (ItemTossEvent.class.isAssignableFrom(clazz)) {
    return callItemTossEvent(spongeEvent);
  }
 else   if (PlayerLoggedInEvent.class.isAssignableFrom(clazz)) {
    return callPlayerLoggedInEvent(spongeEvent);
  }
 else   if (PlayerLoggedOutEvent.class.isAssignableFrom(clazz)) {
    return callPlayerLoggedOutEvent(spongeEvent);
  }
 else   if (PlayerRespawnEvent.class.isAssignableFrom(clazz)) {
    return callPlayerRespawnEvent(spongeEvent);
  }
 else   if (EntityTravelToDimensionEvent.class.isAssignableFrom(clazz)) {
    return callEntityTravelToDimensionEvent(spongeEvent);
  }
 else   if (EntityJoinWorldEvent.class.isAssignableFrom(clazz)) {
    return callEntityJoinWorldEvent(spongeEvent);
  }
 else   if (WorldEvent.Unload.class.isAssignableFrom(clazz)) {
    return callWorldUnloadEvent(spongeEvent);
  }
 else   if (WorldEvent.Load.class.isAssignableFrom(clazz)) {
    return callWorldLoadEvent(spongeEvent);
  }
 else   if (WorldEvent.Save.class.isAssignableFrom(clazz)) {
    return callWorldSaveEvent(spongeEvent);
  }
 else   if (ChunkEvent.Load.class.isAssignableFrom(clazz)) {
    return callChunkLoadEvent(spongeEvent);
  }
 else   if (ChunkEvent.Unload.class.isAssignableFrom(clazz)) {
    return callChunkUnloadEvent(spongeEvent);
  }
 else   if (net.minecraftforge.event.world.ExplosionEvent.Start.class.isAssignableFrom(clazz)) {
    return callExplosionEventPre(spongeEvent);
  }
 else   if (net.minecraftforge.event.world.ExplosionEvent.Detonate.class.isAssignableFrom(clazz)) {
    return callExplosionEventDetonate(spongeEvent);
  }
  return spongeEvent;
}","static Event callForgeEvent(Event spongeEvent,Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz){
  if (EntityItemPickupEvent.class.isAssignableFrom(clazz)) {
    return callEntityItemPickupEvent(spongeEvent);
  }
 else   if (PlayerInteractEvent.EntityInteractSpecific.class.isAssignableFrom(clazz)) {
    return callEntityInteractEvent(spongeEvent);
  }
 else   if (PlayerInteractEvent.EntityInteract.class.isAssignableFrom(clazz)) {
    return callEntityInteractEvent(spongeEvent);
  }
 else   if (BlockEvent.NeighborNotifyEvent.class.isAssignableFrom(clazz)) {
    return callNeighborNotifyEvent(spongeEvent);
  }
 else   if (BlockEvent.PlaceEvent.class.isAssignableFrom(clazz)) {
    return callBlockPlaceEvent(spongeEvent);
  }
 else   if (PlayerInteractEvent.class.isAssignableFrom(clazz)) {
    return createPlayerInteractEvent(spongeEvent);
  }
 else   if (LivingDropsEvent.class.isAssignableFrom(clazz)) {
    return callForgeItemDropEvent(spongeEvent);
  }
 else   if (ItemTossEvent.class.isAssignableFrom(clazz)) {
    return callForgeItemDropEvent(spongeEvent);
  }
 else   if (PlayerLoggedInEvent.class.isAssignableFrom(clazz)) {
    return callPlayerLoggedInEvent(spongeEvent);
  }
 else   if (PlayerLoggedOutEvent.class.isAssignableFrom(clazz)) {
    return callPlayerLoggedOutEvent(spongeEvent);
  }
 else   if (PlayerRespawnEvent.class.isAssignableFrom(clazz)) {
    return callPlayerRespawnEvent(spongeEvent);
  }
 else   if (EntityTravelToDimensionEvent.class.isAssignableFrom(clazz)) {
    return callEntityTravelToDimensionEvent(spongeEvent);
  }
 else   if (EntityJoinWorldEvent.class.isAssignableFrom(clazz)) {
    return callEntityJoinWorldEvent(spongeEvent);
  }
 else   if (WorldEvent.Unload.class.isAssignableFrom(clazz)) {
    return callWorldUnloadEvent(spongeEvent);
  }
 else   if (WorldEvent.Load.class.isAssignableFrom(clazz)) {
    return callWorldLoadEvent(spongeEvent);
  }
 else   if (WorldEvent.Save.class.isAssignableFrom(clazz)) {
    return callWorldSaveEvent(spongeEvent);
  }
 else   if (ChunkEvent.Load.class.isAssignableFrom(clazz)) {
    return callChunkLoadEvent(spongeEvent);
  }
 else   if (ChunkEvent.Unload.class.isAssignableFrom(clazz)) {
    return callChunkUnloadEvent(spongeEvent);
  }
 else   if (net.minecraftforge.event.world.ExplosionEvent.Start.class.isAssignableFrom(clazz)) {
    return callExplosionEventPre(spongeEvent);
  }
 else   if (net.minecraftforge.event.world.ExplosionEvent.Detonate.class.isAssignableFrom(clazz)) {
    return callExplosionEventDetonate(spongeEvent);
  }
 else   if (ItemFishedEvent.class.isAssignableFrom(clazz)) {
    return callItemFishedEvent(spongeEvent);
  }
 else   if (LivingEntityUseItemEvent.class.isAssignableFrom(clazz)) {
    return callLivingUseItemEvent((UseItemStackEvent)spongeEvent);
  }
 else   if (AdvancementEvent.class.isAssignableFrom(clazz)) {
    return callAdvancementGrantEvent((org.spongepowered.api.event.advancement.AdvancementEvent.Grant)spongeEvent);
  }
  return spongeEvent;
}"
27526,"public static ChangeBlockEvent.Pre createChangeBlockEventPre(BlockEvent.BreakEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  final PhaseTracker phaseTracker=PhaseTracker.getInstance();
  final PhaseData data=phaseTracker.getCurrentPhaseData();
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FAKE_PLAYER,EntityUtil.toPlayer(player));
  }
 else {
    Sponge.getCauseStackManager().pushCause(player);
  }
  if (owner != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,owner);
    if (Sponge.getCauseStackManager().getCurrentCause() == null) {
      Sponge.getCauseStackManager().pushCause(owner);
    }
  }
 else {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,(User)player);
    if (Sponge.getCauseStackManager().getCurrentCause() == null) {
      Sponge.getCauseStackManager().pushCause(player);
    }
  }
  if (notifier != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.NOTIFIER,notifier);
  }
  Sponge.getCauseStackManager().addContext(EventContextKeys.PLAYER_BREAK,(World)world);
  return SpongeEventFactory.createChangeBlockEventPre(Sponge.getCauseStackManager().getCurrentCause(),ImmutableList.of(new Location<>((World)world,pos.getX(),pos.getY(),pos.getZ())));
}","private static ChangeBlockEvent.Pre createChangeBlockEventPre(BlockEvent.BreakEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  final PhaseTracker phaseTracker=PhaseTracker.getInstance();
  final PhaseData data=phaseTracker.getCurrentPhaseData();
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FAKE_PLAYER,EntityUtil.toPlayer(player));
  }
 else {
    Sponge.getCauseStackManager().pushCause(player);
  }
  if (owner != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,owner);
    if (!Sponge.getCauseStackManager().getCurrentCause().contains(owner)) {
      Sponge.getCauseStackManager().pushCause(owner);
    }
  }
 else {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,(User)player);
    if (!Sponge.getCauseStackManager().getCurrentCause().contains(player)) {
      Sponge.getCauseStackManager().pushCause(player);
    }
  }
  if (notifier != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.NOTIFIER,notifier);
  }
  Sponge.getCauseStackManager().addContext(EventContextKeys.PLAYER_BREAK,(World)world);
  return SpongeEventFactory.createChangeBlockEventPre(Sponge.getCauseStackManager().getCurrentCause(),ImmutableList.of(new Location<>((World)world,pos.getX(),pos.getY(),pos.getZ())));
}"
27527,"public static void handlePrefireLogic(Event event){
  if (event instanceof SpawnEntityEvent) {
    handleCustomStack((SpawnEntityEvent)event);
  }
}","static void handlePrefireLogic(Event event){
  if (event instanceof SpawnEntityEvent) {
    handleCustomStack((SpawnEntityEvent)event);
  }
}"
27528,"public static ChangeBlockEvent.Place createChangeBlockEventPlace(BlockEvent.MultiPlaceEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  ImmutableList.Builder<Transaction<BlockSnapshot>> builder=new ImmutableList.Builder<Transaction<BlockSnapshot>>();
  for (  net.minecraftforge.common.util.BlockSnapshot blockSnapshot : forgeEvent.getReplacedBlockSnapshots()) {
    final BlockPos snapshotPos=blockSnapshot.getPos();
    BlockSnapshot originalSnapshot=((IMixinBlockSnapshot)blockSnapshot).createSpongeBlockSnapshot();
    BlockSnapshot finalSnapshot=((World)world).createSnapshot(snapshotPos.getX(),snapshotPos.getY(),snapshotPos.getZ());
    builder.add(new Transaction<>(originalSnapshot,finalSnapshot));
  }
  final PhaseTracker phaseTracker=PhaseTracker.getInstance();
  final PhaseData data=phaseTracker.getCurrentPhaseData();
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FAKE_PLAYER,EntityUtil.toPlayer(player));
  }
 else   if (Sponge.getCauseStackManager().getCurrentCause() == null) {
    Sponge.getCauseStackManager().pushCause(player);
  }
  if (owner != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,owner);
    if (Sponge.getCauseStackManager().getCurrentCause() == null) {
      Sponge.getCauseStackManager().pushCause(owner);
    }
  }
 else {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,(User)player);
    if (Sponge.getCauseStackManager().getCurrentCause() == null) {
      Sponge.getCauseStackManager().pushCause(player);
    }
  }
  if (notifier != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.NOTIFIER,notifier);
  }
  return SpongeEventFactory.createChangeBlockEventPlace(Sponge.getCauseStackManager().getCurrentCause(),builder.build());
}","private static ChangeBlockEvent.Place createChangeBlockEventPlace(BlockEvent.MultiPlaceEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  ImmutableList.Builder<Transaction<BlockSnapshot>> builder=new ImmutableList.Builder<>();
  for (  net.minecraftforge.common.util.BlockSnapshot blockSnapshot : forgeEvent.getReplacedBlockSnapshots()) {
    final BlockPos snapshotPos=blockSnapshot.getPos();
    BlockSnapshot originalSnapshot=((IMixinBlockSnapshot)blockSnapshot).createSpongeBlockSnapshot();
    BlockSnapshot finalSnapshot=((World)world).createSnapshot(snapshotPos.getX(),snapshotPos.getY(),snapshotPos.getZ());
    builder.add(new Transaction<>(originalSnapshot,finalSnapshot));
  }
  final PhaseTracker phaseTracker=PhaseTracker.getInstance();
  final PhaseData data=phaseTracker.getCurrentPhaseData();
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FAKE_PLAYER,EntityUtil.toPlayer(player));
  }
 else   if (!Sponge.getCauseStackManager().getCurrentCause().contains(player)) {
    Sponge.getCauseStackManager().pushCause(player);
  }
  if (owner != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,owner);
    if (!Sponge.getCauseStackManager().getCurrentCause().contains(owner)) {
      Sponge.getCauseStackManager().pushCause(owner);
    }
  }
 else {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,(User)player);
    if (!Sponge.getCauseStackManager().getCurrentCause().contains(player)) {
      Sponge.getCauseStackManager().pushCause(player);
    }
  }
  if (notifier != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.NOTIFIER,notifier);
  }
  return SpongeEventFactory.createChangeBlockEventPlace(Sponge.getCauseStackManager().getCurrentCause(),builder.build());
}"
27529,"private static InteractEntityEvent.Secondary callEntityInteractEvent(Event event){
  InteractEntityEvent.Secondary spongeEvent=(InteractEntityEvent.Secondary)event;
  Optional<Player> player=spongeEvent.getCause().first(Player.class);
  if (!player.isPresent()) {
    return null;
  }
  final EntityPlayerMP entityPlayerMP=EntityUtil.toNative(player.get());
  final EnumHand hand=entityPlayerMP.getActiveHand();
  final EntityPlayer entityPlayer=(EntityPlayer)player.get();
  final Entity entity=(Entity)spongeEvent.getTargetEntity();
  final Vector3d hitVec=spongeEvent.getInteractionPoint().orElse(null);
  PlayerInteractEvent forgeEvent=null;
  if (hitVec != null) {
    forgeEvent=new PlayerInteractEvent.EntityInteractSpecific(entityPlayer,hand,entity,VecHelper.toVec3d(hitVec));
  }
 else {
    forgeEvent=new PlayerInteractEvent.EntityInteract(entityPlayer,hand,entity);
  }
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}","private static InteractEntityEvent.Secondary callEntityInteractEvent(Event event){
  InteractEntityEvent.Secondary spongeEvent=(InteractEntityEvent.Secondary)event;
  Optional<Player> player=spongeEvent.getCause().first(Player.class);
  if (!player.isPresent()) {
    return null;
  }
  final EntityPlayerMP entityPlayerMP=EntityUtil.toNative(player.get());
  final EnumHand hand=entityPlayerMP.getActiveHand();
  final EntityPlayer entityPlayer=(EntityPlayer)player.get();
  final Entity entity=(Entity)spongeEvent.getTargetEntity();
  final Vector3d hitVec=spongeEvent.getInteractionPoint().orElse(null);
  PlayerInteractEvent forgeEvent;
  if (hitVec != null) {
    forgeEvent=new PlayerInteractEvent.EntityInteractSpecific(entityPlayer,hand,entity,VecHelper.toVec3d(hitVec));
  }
 else {
    forgeEvent=new PlayerInteractEvent.EntityInteract(entityPlayer,hand,entity);
  }
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}"
27530,"public static SpawnEntityEvent callEntityJoinWorldEvent(Event event){
  SpawnEntityEvent spongeEvent=(SpawnEntityEvent)event;
  ListIterator<org.spongepowered.api.entity.Entity> iterator=spongeEvent.getEntities().listIterator();
  if (spongeEvent.getEntities().size() == 0) {
    return spongeEvent;
  }
  boolean canCancelEvent=true;
  while (iterator.hasNext()) {
    org.spongepowered.api.entity.Entity entity=iterator.next();
    EntityJoinWorldEvent forgeEvent=new EntityJoinWorldEvent((Entity)entity,(net.minecraft.world.World)entity.getLocation().getExtent());
    boolean prev=StaticMixinForgeHelper.preventInternalForgeEntityListener;
    StaticMixinForgeHelper.preventInternalForgeEntityListener=true;
    ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
    StaticMixinForgeHelper.preventInternalForgeEntityListener=prev;
    Entity mcEntity=(Entity)entity;
    if (mcEntity.isDead) {
      canCancelEvent=false;
    }
    if (forgeEvent.isCanceled()) {
      iterator.remove();
    }
  }
  if (spongeEvent.getEntities().size() == 0 && canCancelEvent) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}","private static SpawnEntityEvent callEntityJoinWorldEvent(Event event){
  SpawnEntityEvent spongeEvent=(SpawnEntityEvent)event;
  ListIterator<org.spongepowered.api.entity.Entity> iterator=spongeEvent.getEntities().listIterator();
  if (spongeEvent.getEntities().isEmpty()) {
    return spongeEvent;
  }
  boolean canCancelEvent=true;
  while (iterator.hasNext()) {
    org.spongepowered.api.entity.Entity entity=iterator.next();
    EntityJoinWorldEvent forgeEvent=new EntityJoinWorldEvent((Entity)entity,(net.minecraft.world.World)entity.getLocation().getExtent());
    boolean prev=StaticMixinForgeHelper.preventInternalForgeEntityListener;
    StaticMixinForgeHelper.preventInternalForgeEntityListener=true;
    ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
    StaticMixinForgeHelper.preventInternalForgeEntityListener=prev;
    Entity mcEntity=(Entity)entity;
    if (mcEntity.isDead) {
      canCancelEvent=false;
    }
    if (forgeEvent.isCanceled()) {
      iterator.remove();
    }
  }
  if (spongeEvent.getEntities().isEmpty() && canCancelEvent) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}"
27531,"public static NotifyNeighborBlockEvent callNeighborNotifyEvent(Event event){
  NotifyNeighborBlockEvent spongeEvent=(NotifyNeighborBlockEvent)event;
  LocatableBlock locatableBlock=spongeEvent.getCause().first(LocatableBlock.class).orElse(null);
  TileEntity tileEntitySource=spongeEvent.getCause().first(TileEntity.class).orElse(null);
  Location<World> sourceLocation=null;
  IBlockState state=null;
  if (locatableBlock != null) {
    Location<World> location=locatableBlock.getLocation();
    sourceLocation=location;
    state=(IBlockState)locatableBlock.getBlockState();
  }
 else   if (tileEntitySource != null) {
    sourceLocation=tileEntitySource.getLocation();
    state=(IBlockState)sourceLocation.getBlock();
  }
 else {
    return spongeEvent;
  }
  EnumSet<EnumFacing> facings=EnumSet.noneOf(EnumFacing.class);
  for (  Map.Entry<Direction,BlockState> mapEntry : spongeEvent.getNeighbors().entrySet()) {
    if (mapEntry.getKey() != Direction.NONE) {
      facings.add(DirectionFacingProvider.getInstance().get(mapEntry.getKey()).get());
    }
  }
  if (facings.isEmpty()) {
    return spongeEvent;
  }
  BlockPos pos=((IMixinLocation)(Object)sourceLocation).getBlockPos();
  net.minecraft.world.World world=(net.minecraft.world.World)sourceLocation.getExtent();
  final NeighborNotifyEvent forgeEvent=new NeighborNotifyEvent(world,pos,state,facings,false);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}","private static NotifyNeighborBlockEvent callNeighborNotifyEvent(Event event){
  NotifyNeighborBlockEvent spongeEvent=(NotifyNeighborBlockEvent)event;
  LocatableBlock locatableBlock=spongeEvent.getCause().first(LocatableBlock.class).orElse(null);
  TileEntity tileEntitySource=spongeEvent.getCause().first(TileEntity.class).orElse(null);
  Location<World> sourceLocation;
  IBlockState state;
  if (locatableBlock != null) {
    sourceLocation=locatableBlock.getLocation();
    state=(IBlockState)locatableBlock.getBlockState();
  }
 else   if (tileEntitySource != null) {
    sourceLocation=tileEntitySource.getLocation();
    state=(IBlockState)sourceLocation.getBlock();
  }
 else {
    return spongeEvent;
  }
  EnumSet<EnumFacing> facings=EnumSet.noneOf(EnumFacing.class);
  for (  Map.Entry<Direction,BlockState> mapEntry : spongeEvent.getNeighbors().entrySet()) {
    if (mapEntry.getKey() != Direction.NONE) {
      facings.add(DirectionFacingProvider.getInstance().get(mapEntry.getKey()).get());
    }
  }
  if (facings.isEmpty()) {
    return spongeEvent;
  }
  BlockPos pos=((IMixinLocation)(Object)sourceLocation).getBlockPos();
  net.minecraft.world.World world=(net.minecraft.world.World)sourceLocation.getExtent();
  final NeighborNotifyEvent forgeEvent=new NeighborNotifyEvent(world,pos,state,facings,false);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
  return spongeEvent;
}"
27532,"public static SleepingEvent.Pre createSleepingEventPre(PlayerSleepInBedEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getEntity().getEntityWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  BlockSnapshot bedSnapshot=((World)world).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
  Sponge.getCauseStackManager().pushCause(forgeEvent.getEntity());
  return SpongeEventFactory.createSleepingEventPre(Sponge.getCauseStackManager().getCurrentCause(),bedSnapshot,(org.spongepowered.api.entity.Entity)forgeEvent.getEntity());
}","private static SleepingEvent.Pre createSleepingEventPre(PlayerSleepInBedEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getEntity().getEntityWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  BlockSnapshot bedSnapshot=((World)world).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
  Sponge.getCauseStackManager().pushCause(forgeEvent.getEntity());
  return SpongeEventFactory.createSleepingEventPre(Sponge.getCauseStackManager().getCurrentCause(),bedSnapshot,(org.spongepowered.api.entity.Entity)forgeEvent.getEntity());
}"
27533,"public static Class<? extends net.minecraftforge.fml.common.eventhandler.Event> getForgeEventClass(Event spongeEvent){
  final Class<? extends Event> clazz=spongeEvent.getClass();
  if (ChangeInventoryEvent.Pickup.Pre.class.isAssignableFrom(clazz)) {
    if (spongeEvent.getCause().root() instanceof Player) {
      return EntityItemPickupEvent.class;
    }
  }
  if (DestructEntityEvent.Death.class.isAssignableFrom(clazz)) {
    return LivingDeathEvent.class;
  }
  if (InteractBlockEvent.Primary.class.isAssignableFrom(clazz)) {
    return PlayerInteractEvent.class;
  }
  if (InteractBlockEvent.Secondary.class.isAssignableFrom(clazz)) {
    return PlayerInteractEvent.class;
  }
  if (InteractBlockEvent.class.isAssignableFrom(clazz)) {
    return PlayerInteractEvent.class;
  }
  if (InteractEntityEvent.Secondary.class.isAssignableFrom(clazz)) {
    InteractEntityEvent event=(InteractEntityEvent)spongeEvent;
    if (event.getInteractionPoint().isPresent()) {
      return PlayerInteractEvent.EntityInteractSpecific.class;
    }
 else {
      return PlayerInteractEvent.EntityInteract.class;
    }
  }
  if (NotifyNeighborBlockEvent.class.isAssignableFrom(clazz)) {
    return BlockEvent.NeighborNotifyEvent.class;
  }
  if (ChangeBlockEvent.Place.class.isAssignableFrom(clazz)) {
    return BlockEvent.PlaceEvent.class;
  }
  if (ExplosionEvent.Pre.class.isAssignableFrom(clazz)) {
    return net.minecraftforge.event.world.ExplosionEvent.Start.class;
  }
  if (ExplosionEvent.Detonate.class.isAssignableFrom(clazz)) {
    return net.minecraftforge.event.world.ExplosionEvent.Detonate.class;
  }
  if (DropItemEvent.Destruct.class.isAssignableFrom(clazz)) {
    return LivingDropsEvent.class;
  }
  if (DropItemEvent.Dispense.class.isAssignableFrom(clazz)) {
    return ItemTossEvent.class;
  }
  if (ClientConnectionEvent.Join.class.isAssignableFrom(clazz)) {
    return PlayerLoggedInEvent.class;
  }
  if (ClientConnectionEvent.Disconnect.class.isAssignableFrom(clazz)) {
    return PlayerLoggedOutEvent.class;
  }
  if (RespawnPlayerEvent.class.isAssignableFrom(clazz)) {
    return PlayerRespawnEvent.class;
  }
  if (MoveEntityEvent.Teleport.class.isAssignableFrom(clazz)) {
    return EntityTravelToDimensionEvent.class;
  }
  if (SpawnEntityEvent.class.isAssignableFrom(clazz)) {
    return EntityJoinWorldEvent.class;
  }
  if (LoadWorldEvent.class.isAssignableFrom(clazz)) {
    return WorldEvent.Load.class;
  }
  if (UnloadWorldEvent.class.isAssignableFrom(clazz)) {
    return WorldEvent.Unload.class;
  }
  if (SaveWorldEvent.Post.class.isAssignableFrom(clazz)) {
    return WorldEvent.Save.class;
  }
  if (LoadChunkEvent.class.isAssignableFrom(clazz)) {
    return ChunkEvent.Load.class;
  }
  if (UnloadChunkEvent.class.isAssignableFrom(clazz)) {
    return ChunkEvent.Unload.class;
  }
  return null;
}","static Class<? extends net.minecraftforge.fml.common.eventhandler.Event> getForgeEventClass(Event spongeEvent){
  final Class<? extends Event> clazz=spongeEvent.getClass();
  if (ChangeInventoryEvent.Pickup.Pre.class.isAssignableFrom(clazz)) {
    if (spongeEvent.getCause().root() instanceof Player) {
      return EntityItemPickupEvent.class;
    }
  }
  if (DestructEntityEvent.Death.class.isAssignableFrom(clazz)) {
    return LivingDeathEvent.class;
  }
  if (InteractBlockEvent.Primary.class.isAssignableFrom(clazz)) {
    return PlayerInteractEvent.class;
  }
  if (InteractBlockEvent.Secondary.class.isAssignableFrom(clazz)) {
    return PlayerInteractEvent.class;
  }
  if (InteractBlockEvent.class.isAssignableFrom(clazz)) {
    return PlayerInteractEvent.class;
  }
  if (InteractEntityEvent.Secondary.class.isAssignableFrom(clazz)) {
    InteractEntityEvent event=(InteractEntityEvent)spongeEvent;
    if (event.getInteractionPoint().isPresent()) {
      return PlayerInteractEvent.EntityInteractSpecific.class;
    }
 else {
      return PlayerInteractEvent.EntityInteract.class;
    }
  }
  if (NotifyNeighborBlockEvent.class.isAssignableFrom(clazz)) {
    return BlockEvent.NeighborNotifyEvent.class;
  }
  if (ChangeBlockEvent.Place.class.isAssignableFrom(clazz)) {
    return BlockEvent.PlaceEvent.class;
  }
  if (ExplosionEvent.Pre.class.isAssignableFrom(clazz)) {
    return net.minecraftforge.event.world.ExplosionEvent.Start.class;
  }
  if (ExplosionEvent.Detonate.class.isAssignableFrom(clazz)) {
    return net.minecraftforge.event.world.ExplosionEvent.Detonate.class;
  }
  if (DropItemEvent.Destruct.class.isAssignableFrom(clazz)) {
    return LivingDropsEvent.class;
  }
  if (DropItemEvent.Dispense.class.isAssignableFrom(clazz)) {
    return ItemTossEvent.class;
  }
  if (DropItemEvent.Custom.class.isAssignableFrom(clazz)) {
    return ItemTossEvent.class;
  }
  if (ClientConnectionEvent.Join.class.isAssignableFrom(clazz)) {
    return PlayerLoggedInEvent.class;
  }
  if (ClientConnectionEvent.Disconnect.class.isAssignableFrom(clazz)) {
    return PlayerLoggedOutEvent.class;
  }
  if (RespawnPlayerEvent.class.isAssignableFrom(clazz)) {
    return PlayerRespawnEvent.class;
  }
  if (MoveEntityEvent.Teleport.class.isAssignableFrom(clazz)) {
    return EntityTravelToDimensionEvent.class;
  }
  if (SpawnEntityEvent.class.isAssignableFrom(clazz)) {
    return EntityJoinWorldEvent.class;
  }
  if (LoadWorldEvent.class.isAssignableFrom(clazz)) {
    return WorldEvent.Load.class;
  }
  if (UnloadWorldEvent.class.isAssignableFrom(clazz)) {
    return WorldEvent.Unload.class;
  }
  if (SaveWorldEvent.Post.class.isAssignableFrom(clazz)) {
    return WorldEvent.Save.class;
  }
  if (LoadChunkEvent.class.isAssignableFrom(clazz)) {
    return ChunkEvent.Load.class;
  }
  if (UnloadChunkEvent.class.isAssignableFrom(clazz)) {
    return ChunkEvent.Unload.class;
  }
  if (FishingEvent.Stop.class.isAssignableFrom(clazz)) {
    return ItemFishedEvent.class;
  }
  if (UseItemStackEvent.Start.class.isAssignableFrom(clazz)) {
    return LivingEntityUseItemEvent.Start.class;
  }
  if (UseItemStackEvent.Tick.class.isAssignableFrom(clazz)) {
    return LivingEntityUseItemEvent.Tick.class;
  }
  if (UseItemStackEvent.Stop.class.isAssignableFrom(clazz)) {
    return LivingEntityUseItemEvent.Stop.class;
  }
  if (UseItemStackEvent.Finish.class.isAssignableFrom(clazz)) {
    return LivingEntityUseItemEvent.Finish.class;
  }
  if (org.spongepowered.api.event.advancement.AdvancementEvent.Grant.class.isAssignableFrom(clazz)) {
    return AdvancementEvent.class;
  }
  return null;
}"
27534,"public static MessageChannelEvent.Chat createMessageChannelEventChat(ServerChatEvent forgeEvent){
  final ITextComponent forgeComponent=forgeEvent.getComponent();
  final MessageFormatter formatter=new MessageFormatter();
  MessageChannel channel;
  Text[] chat=SpongeTexts.splitChatMessage((TextComponentTranslation)forgeComponent);
  if (chat[1] == null) {
    chat[1]=chat[0] != null ? chat[0] : SpongeTexts.toText(forgeComponent);
    chat[0]=null;
  }
  if (chat[0] != null) {
    formatter.getHeader().add(new DefaultHeaderApplier(chat[0]));
  }
  formatter.getBody().add(new DefaultBodyApplier(chat[1]));
  Text rawSpongeMessage=Text.of(forgeEvent.getMessage());
  MessageChannel originalChannel=channel=((Player)forgeEvent.getPlayer()).getMessageChannel();
  Sponge.getCauseStackManager().pushCause(forgeEvent.getPlayer());
  return SpongeEventFactory.createMessageChannelEventChat(Sponge.getCauseStackManager().getCurrentCause(),originalChannel,Optional.ofNullable(channel),formatter,rawSpongeMessage,false);
}","private static MessageChannelEvent.Chat createMessageChannelEventChat(ServerChatEvent forgeEvent){
  final ITextComponent forgeComponent=forgeEvent.getComponent();
  final MessageFormatter formatter=new MessageFormatter();
  MessageChannel channel;
  Text[] chat=SpongeTexts.splitChatMessage((TextComponentTranslation)forgeComponent);
  if (chat[1] == null) {
    chat[1]=chat[0] != null ? chat[0] : SpongeTexts.toText(forgeComponent);
    chat[0]=null;
  }
  if (chat[0] != null) {
    formatter.getHeader().add(new DefaultHeaderApplier(chat[0]));
  }
  formatter.getBody().add(new DefaultBodyApplier(chat[1]));
  Text rawSpongeMessage=Text.of(forgeEvent.getMessage());
  MessageChannel originalChannel=channel=((Player)forgeEvent.getPlayer()).getMessageChannel();
  Sponge.getCauseStackManager().pushCause(forgeEvent.getPlayer());
  return SpongeEventFactory.createMessageChannelEventChat(Sponge.getCauseStackManager().getCurrentCause(),originalChannel,Optional.ofNullable(channel),formatter,rawSpongeMessage,false);
}"
27535,"@Override public boolean post(Event spongeEvent,boolean allowClientThread){
  if (!allowClientThread & Sponge.getGame().getPlatform().getExecutionType().isClient()) {
    return false;
  }
  final boolean useCauseStackManager=shouldUseCauseStackManager(allowClientThread);
  if (spongeEvent.getClass().getInterfaces().length > 0) {
    Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz=SpongeForgeEventFactory.getForgeEventClass(spongeEvent);
    if (clazz != null) {
      return post(spongeEvent,clazz,useCauseStackManager);
    }
  }
  return post(spongeEvent,getHandlerCache(spongeEvent).getListeners(),false,true,useCauseStackManager);
}","@Override public boolean post(Event spongeEvent,boolean allowClientThread){
  this.extendedPost(spongeEvent,allowClientThread);
  return spongeEvent instanceof Cancellable && ((Cancellable)spongeEvent).isCancelled();
}"
27536,"/** 
 * @author
 * @reason Forge compatibility
 */
@Overwrite public static void registerPortalAgentType(@Nullable Teleporter teleporter){
  if (teleporter == null) {
    return;
  }
  if (PortalAgentTypes.DEFAULT.equals(((PortalAgent)teleporter).getType())) {
    return;
  }
  PortalAgentRegistryModule.getInstance().validatePortalAgent(teleporter);
}","/** 
 * @author
 * @reason Forge compatibility
 */
@Overwrite public static void registerPortalAgentType(@Nullable IMixinITeleporter teleporter){
  if (teleporter == null) {
    return;
  }
  if (PortalAgentTypes.DEFAULT.equals(((PortalAgent)teleporter).getType())) {
    return;
  }
  PortalAgentRegistryModule.getInstance().validatePortalAgent(teleporter);
}"
27537,"@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str""),cancellable=true) public void onGetWorldDirectory(CallbackInfoReturnable<File> cir){
  final ModContainer activeContainer=Loader.instance().activeModContainer();
  if ((activeContainer != null && activeContainer != SpongeMod.instance && !(activeContainer instanceof PluginContainerExtension))) {
    if (this.modWorldDirectory != null) {
      cir.setReturnValue(this.modWorldDirectory);
    }
 else {
      this.modWorldDirectory=new File(""String_Node_Str"",Sponge.getServer().getDefaultWorldName());
      cir.setReturnValue(this.modWorldDirectory);
    }
  }
}","@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str""),cancellable=true) public void onGetWorldDirectory(CallbackInfoReturnable<File> cir){
  final ModContainer activeContainer=Loader.instance().activeModContainer();
  if ((activeContainer != null && activeContainer != SpongeMod.instance && !(activeContainer instanceof PluginContainerExtension))) {
    if (this.modWorldDirectory != null) {
      cir.setReturnValue(this.modWorldDirectory);
    }
 else {
      final String defaultWorldName=Sponge.getServer().getDefaultWorldName();
      final String defaultWorldPath=Sponge.getPlatform().getType().isClient() ? ""String_Node_Str"" + File.separator + defaultWorldName : defaultWorldName;
      this.modWorldDirectory=SpongeImpl.getGameDir().resolve(defaultWorldPath).toFile();
      cir.setReturnValue(this.modWorldDirectory);
    }
  }
}"
27538,"@Subscribe public void onStateEvent(FMLStateEvent event){
  if (!event.getClass().equals(FMLConstructionEvent.class)) {
    SpongeImpl.getGame().getEventManager().post((Event)event);
  }
}","@Subscribe public void onStateEvent(FMLStateEvent event){
  if (!event.getClass().equals(FMLConstructionEvent.class)) {
    SpongeImpl.postEvent((Event)event,true);
  }
}"
27539,"@Override public boolean post(Event spongeEvent){
  if (spongeEvent.getClass().getInterfaces().length > 0) {
    Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz=SpongeForgeEventFactory.getForgeEventClass(spongeEvent);
    if (clazz != null) {
      return post(spongeEvent,clazz);
    }
  }
  return post(spongeEvent,getHandlerCache(spongeEvent).getListeners(),false,true);
}","@Override public boolean post(Event spongeEvent,boolean allowClientThread){
  if (!allowClientThread & Sponge.getGame().getPlatform().getExecutionType().isClient()) {
    return false;
  }
  final boolean useCauseStackManager=shouldUseCauseStackManager(allowClientThread);
  if (spongeEvent.getClass().getInterfaces().length > 0) {
    Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz=SpongeForgeEventFactory.getForgeEventClass(spongeEvent);
    if (clazz != null) {
      return post(spongeEvent,clazz,useCauseStackManager);
    }
  }
  return post(spongeEvent,getHandlerCache(spongeEvent).getListeners(),false,true,useCauseStackManager);
}"
27540,"@Override public boolean post(Event event,boolean forced){
  org.spongepowered.api.event.Event spongeEvent=null;
  if (!isSpongeSetUp) {
    try {
      Sponge.getCauseStackManager();
    }
 catch (    Exception e) {
      return false;
    }
  }
  isSpongeSetUp=true;
  final boolean isMainThread=SpongeImpl.isMainThread();
  try (final CauseStackManager.StackFrame frame=isMainThread ? Sponge.getCauseStackManager().pushCauseFrame() : null){
    if (!forced) {
      if (!isEventAllowed(event)) {
        return false;
      }
      spongeEvent=SpongeForgeEventFactory.createSpongeEvent(event);
    }
    IEventListener[] listeners=event.getListenerList().getListeners(this.busID);
    if (!forced && (event instanceof org.spongepowered.api.event.Event || spongeEvent != null) && !Sponge.getGame().getPlatform().getExecutionType().isClient()) {
      boolean cancelled=((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,event,listeners);
      if (!cancelled) {
        SpongeForgeEventFactory.onForgePost(event);
      }
      return cancelled;
    }
    listeners=event.getListenerList().getListeners(this.busID);
    int index=0;
    IMixinASMEventHandler modListener=null;
    try {
      for (; index < listeners.length; index++) {
        final IEventListener listener=listeners[index];
        if (listener instanceof IMixinASMEventHandler) {
          modListener=(IMixinASMEventHandler)listener;
          modListener.getTimingsHandler().startTimingIfSync();
          try (PhaseContext<?> context=SpongeForgeEventHooks.preEventPhaseCheck(listener,event)){
            listener.invoke(event);
          }
           modListener.getTimingsHandler().stopTimingIfSync();
        }
 else {
          listener.invoke(event);
        }
      }
    }
 catch (    Throwable throwable) {
      if (modListener != null) {
        modListener.getTimingsHandler().stopTimingIfSync();
      }
      this.exceptionHandler.handleException((EventBus)(Object)this,event,listeners,index,throwable);
      throw new RuntimeException(throwable);
    }
    return (event.isCancelable() ? event.isCanceled() : false);
  }
 }","@Override public boolean post(Event event,boolean forced){
  org.spongepowered.api.event.Event spongeEvent=null;
  if (!isSpongeSetUp) {
    try {
      Sponge.getCauseStackManager();
    }
 catch (    Exception e) {
      return false;
    }
  }
  isSpongeSetUp=true;
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  try (final CauseStackManager.StackFrame frame=isMainThread ? Sponge.getCauseStackManager().pushCauseFrame() : null){
    if (!forced) {
      if (!isEventAllowed(event)) {
        return false;
      }
      spongeEvent=SpongeForgeEventFactory.createSpongeEvent(event);
    }
    IEventListener[] listeners=event.getListenerList().getListeners(this.busID);
    if (!forced && (event instanceof org.spongepowered.api.event.Event || spongeEvent != null) && !Sponge.getGame().getPlatform().getExecutionType().isClient()) {
      boolean cancelled=((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,event,listeners,SpongeModEventManager.shouldUseCauseStackManager(false));
      if (!cancelled) {
        SpongeForgeEventFactory.onForgePost(event);
      }
      return cancelled;
    }
    listeners=event.getListenerList().getListeners(this.busID);
    int index=0;
    IMixinASMEventHandler modListener=null;
    try {
      for (; index < listeners.length; index++) {
        final IEventListener listener=listeners[index];
        if (listener instanceof IMixinASMEventHandler) {
          modListener=(IMixinASMEventHandler)listener;
          modListener.getTimingsHandler().startTimingIfSync();
          try (PhaseContext<?> context=SpongeForgeEventHooks.preEventPhaseCheck(listener,event)){
            listener.invoke(event);
          }
           modListener.getTimingsHandler().stopTimingIfSync();
        }
 else {
          listener.invoke(event);
        }
      }
    }
 catch (    Throwable throwable) {
      if (modListener != null) {
        modListener.getTimingsHandler().stopTimingIfSync();
      }
      this.exceptionHandler.handleException((EventBus)(Object)this,event,listeners,index,throwable);
      throw new RuntimeException(throwable);
    }
    return (event.isCancelable() ? event.isCanceled() : false);
  }
 }"
27541,"@Override public org.spongepowered.api.event.Event postForgeAndCreateSpongeEvent(Event forgeEvent){
  org.spongepowered.api.event.Event spongeEvent;
  try (final CauseStackManager.StackFrame frame=Sponge.getCauseStackManager().pushCauseFrame()){
    spongeEvent=SpongeForgeEventFactory.createSpongeEvent(forgeEvent);
    IEventListener[] listeners=forgeEvent.getListenerList().getListeners(this.busID);
    boolean cancelled=((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,forgeEvent,listeners);
    if (!cancelled) {
      SpongeForgeEventFactory.onForgePost(forgeEvent);
    }
  }
   return spongeEvent;
}","@Override public org.spongepowered.api.event.Event postForgeAndCreateSpongeEvent(Event forgeEvent){
  org.spongepowered.api.event.Event spongeEvent;
  try (final CauseStackManager.StackFrame frame=Sponge.getCauseStackManager().pushCauseFrame()){
    spongeEvent=SpongeForgeEventFactory.createSpongeEvent(forgeEvent);
    IEventListener[] listeners=forgeEvent.getListenerList().getListeners(this.busID);
    boolean cancelled=((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,forgeEvent,listeners,true);
    if (!cancelled) {
      SpongeForgeEventFactory.onForgePost(forgeEvent);
    }
  }
   return spongeEvent;
}"
27542,"public static LoadChunkEvent createLoadChunkEvent(ChunkEvent.Load forgeEvent){
  return SpongeEventFactory.createLoadChunkEvent(Cause.of(NamedCause.source(forgeEvent.getWorld())),(Chunk)forgeEvent.getChunk());
}","public static LoadChunkEvent createLoadChunkEvent(ChunkEvent.Load forgeEvent){
  Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  return SpongeEventFactory.createLoadChunkEvent(Sponge.getCauseStackManager().getCurrentCause(),(Chunk)forgeEvent.getChunk());
}"
27543,"public static ChangeBlockEvent.Break createChangeBlockEventBreak(BlockEvent.BreakEvent forgeEvent){
  final BlockPos pos=forgeEvent.getPos();
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  final CauseTracker causeTracker=CauseTracker.getInstance();
  final PhaseData data=causeTracker.getCurrentPhaseData();
  BlockSnapshot originalSnapshot=((World)forgeEvent.getWorld()).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
  BlockSnapshot finalSnapshot=BlockTypes.AIR.getDefaultState().snapshotFor(new Location<>((World)world,VecHelper.toVector3d(pos)));
  ImmutableList<Transaction<BlockSnapshot>> blockSnapshots=new ImmutableList.Builder<Transaction<BlockSnapshot>>().add(new Transaction<>(originalSnapshot,finalSnapshot)).build();
  Cause.Builder builder=null;
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    if (owner != null) {
      builder=Cause.source(owner);
      builder.named(NamedCause.FAKE_PLAYER,player);
    }
 else     if (notifier != null) {
      builder=Cause.source(notifier);
      builder.named(NamedCause.FAKE_PLAYER,player);
    }
 else {
      builder=Cause.builder().named(NamedCause.FAKE_PLAYER,player);
    }
  }
  if (builder == null) {
    builder=Cause.source(player);
  }
  if (owner != null) {
    builder.owner(owner);
  }
  if (notifier != null) {
    builder.notifier(notifier);
  }
  builder.named(NamedCause.PLAYER_BREAK,world);
  ChangeBlockEvent.Break spongeEvent=SpongeEventFactory.createChangeBlockEventBreak(builder.build(),blockSnapshots);
  return spongeEvent;
}","public static ChangeBlockEvent.Break createChangeBlockEventBreak(BlockEvent.BreakEvent forgeEvent){
  final BlockPos pos=forgeEvent.getPos();
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  final CauseTracker causeTracker=CauseTracker.getInstance();
  final PhaseData data=causeTracker.getCurrentPhaseData();
  BlockSnapshot originalSnapshot=((World)forgeEvent.getWorld()).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
  BlockSnapshot finalSnapshot=BlockTypes.AIR.getDefaultState().snapshotFor(new Location<>((World)world,VecHelper.toVector3d(pos)));
  ImmutableList<Transaction<BlockSnapshot>> blockSnapshots=new ImmutableList.Builder<Transaction<BlockSnapshot>>().add(new Transaction<>(originalSnapshot,finalSnapshot)).build();
  Cause.Builder builder=null;
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FAKE_PLAYER,EntityUtil.toPlayer(player));
  }
  Sponge.getCauseStackManager().pushCause(player);
  if (owner != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,owner);
  }
  if (notifier != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.NOTIFIER,notifier);
  }
  Sponge.getCauseStackManager().addContext(EventContextKeys.PLAYER_BREAK,(World)world);
  return SpongeEventFactory.createChangeBlockEventBreak(Sponge.getCauseStackManager().getCurrentCause(),blockSnapshots);
}"
27544,"@SuppressWarnings(""String_Node_Str"") public static DropItemEvent.Destruct callLivingDropsEvent(Event event){
  DropItemEvent.Destruct spongeEvent=(DropItemEvent.Destruct)event;
  Object source=spongeEvent.getCause().root();
  Optional<DamageSource> damageSource=spongeEvent.getCause().first(DamageSource.class);
  if (!(source instanceof EntitySpawnCause) || !damageSource.isPresent()) {
    callEntityJoinWorldEvent(spongeEvent);
    return spongeEvent;
  }
  EntitySpawnCause spawnCause=(EntitySpawnCause)source;
  Entity entity=EntityUtil.toNative(spawnCause.getEntity());
  if (entity == null || !(entity instanceof EntityLivingBase)) {
    return spongeEvent;
  }
  LivingDropsEvent forgeEvent=null;
  if (entity instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)entity;
    forgeEvent=new PlayerDropsEvent(player,(net.minecraft.util.DamageSource)damageSource.get(),(List<EntityItem>)(List<?>)spongeEvent.getEntities(),((IMixinEntityLivingBase)entity).getRecentlyHit() > 0);
  }
 else {
    forgeEvent=new LivingDropsEvent((EntityLivingBase)entity,(net.minecraft.util.DamageSource)damageSource.get(),(List<EntityItem>)(List<?>)spongeEvent.getEntities(),0,((IMixinEntityLivingBase)entity).getRecentlyHit() > 0);
  }
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
 else {
    callEntityJoinWorldEvent(spongeEvent);
  }
  return spongeEvent;
}","@SuppressWarnings(""String_Node_Str"") public static DropItemEvent.Destruct callLivingDropsEvent(Event event){
  DropItemEvent.Destruct spongeEvent=(DropItemEvent.Destruct)event;
  final Cause cause=spongeEvent.getCause();
  Object source=cause.root();
  Optional<DamageSource> damageSource=cause.first(DamageSource.class);
  final Optional<Entity> spawnEntity=cause.first(Entity.class);
  final Optional<SpawnType> spawnType=cause.getContext().get(EventContextKeys.SPAWN_TYPE);
  if (!spawnType.isPresent() || !damageSource.isPresent() || !spawnEntity.isPresent()) {
    callEntityJoinWorldEvent(spongeEvent);
    return spongeEvent;
  }
  Entity entity=spawnEntity.get();
  if (entity == null || !(entity instanceof EntityLivingBase)) {
    return spongeEvent;
  }
  LivingDropsEvent forgeEvent=null;
  if (entity instanceof EntityPlayer) {
    EntityPlayer player=(EntityPlayer)entity;
    forgeEvent=new PlayerDropsEvent(player,(net.minecraft.util.DamageSource)damageSource.get(),(List<EntityItem>)(List<?>)spongeEvent.getEntities(),((IMixinEntityLivingBase)entity).getRecentlyHit() > 0);
  }
 else {
    forgeEvent=new LivingDropsEvent((EntityLivingBase)entity,(net.minecraft.util.DamageSource)damageSource.get(),(List<EntityItem>)(List<?>)spongeEvent.getEntities(),0,((IMixinEntityLivingBase)entity).getRecentlyHit() > 0);
  }
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    spongeEvent.setCancelled(true);
  }
 else {
    callEntityJoinWorldEvent(spongeEvent);
  }
  return spongeEvent;
}"
27545,"public static DropItemEvent.Dispense callItemTossEvent(Event event){
  DropItemEvent.Dispense spongeEvent=(DropItemEvent.Dispense)event;
  Object source=spongeEvent.getCause().root();
  if (spongeEvent.getEntities().size() <= 0) {
    return spongeEvent;
  }
  if (!(source instanceof EntitySpawnCause)) {
    callEntityJoinWorldEvent(spongeEvent);
    return spongeEvent;
  }
  EntitySpawnCause spawnCause=(EntitySpawnCause)source;
  Entity entity=EntityUtil.toNative(spawnCause.getEntity());
  EntityItem item=(EntityItem)spongeEvent.getEntities().get(0);
  if (entity == null || item == null || item.getItem() == null || !(entity instanceof Player)) {
    return spongeEvent;
  }
  ItemTossEvent forgeEvent=new ItemTossEvent(item,(EntityPlayerMP)entity);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    if (item.isDead) {
      return spongeEvent;
    }
    spongeEvent.setCancelled(true);
  }
 else {
    callEntityJoinWorldEvent(spongeEvent);
  }
  return spongeEvent;
}","public static DropItemEvent.Dispense callItemTossEvent(Event event){
  DropItemEvent.Dispense spongeEvent=(DropItemEvent.Dispense)event;
  if (spongeEvent.getEntities().size() <= 0) {
    return spongeEvent;
  }
  final Cause cause=spongeEvent.getCause();
  Object source=cause.root();
  Optional<DamageSource> damageSource=cause.first(DamageSource.class);
  final Optional<Entity> spawnEntity=cause.first(Entity.class);
  final Optional<SpawnType> spawnType=cause.getContext().get(EventContextKeys.SPAWN_TYPE);
  if (!spawnType.isPresent() || !damageSource.isPresent() || !spawnEntity.isPresent()) {
    callEntityJoinWorldEvent(spongeEvent);
    return spongeEvent;
  }
  Entity entity=spawnEntity.get();
  EntityItem item=(EntityItem)spongeEvent.getEntities().get(0);
  if (entity == null || item == null || item.getItem() == null || !(entity instanceof Player)) {
    return spongeEvent;
  }
  ItemTossEvent forgeEvent=new ItemTossEvent(item,(EntityPlayerMP)entity);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
  if (forgeEvent.isCanceled()) {
    if (item.isDead) {
      return spongeEvent;
    }
    spongeEvent.setCancelled(true);
  }
 else {
    callEntityJoinWorldEvent(spongeEvent);
  }
  return spongeEvent;
}"
27546,"public static ChangeBlockEvent.Place callBlockPlaceEvent(Event event){
  ChangeBlockEvent.Place spongeEvent=(ChangeBlockEvent.Place)event;
  if (spongeEvent.getCause().root() instanceof Player) {
    EntityPlayer player=(EntityPlayer)spongeEvent.getCause().first(Player.class).get();
    net.minecraft.world.World world=player.world;
    final CauseTracker causeTracker=CauseTracker.getInstance();
    PhaseContext context=causeTracker.getCurrentContext();
    Packet<?> contextPacket=context.firstNamed(InternalNamedCauses.Packet.CAPTURED_PACKET,Packet.class).orElse(null);
    if (contextPacket == null) {
      return spongeEvent;
    }
    if (spongeEvent.getTransactions().size() == 1) {
      BlockPos pos=VecHelper.toBlockPos(spongeEvent.getTransactions().get(0).getOriginal().getPosition());
      IBlockState state=(IBlockState)spongeEvent.getTransactions().get(0).getOriginal().getState();
      net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshot.getWorld().getBlockState(blockSnapshot.getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.PlaceEvent forgeEvent=new BlockEvent.PlaceEvent(blockSnapshot,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
 else {
      Iterator<Transaction<BlockSnapshot>> iterator=spongeEvent.getTransactions().iterator();
      List<net.minecraftforge.common.util.BlockSnapshot> blockSnapshots=new ArrayList<>();
      while (iterator.hasNext()) {
        Transaction<BlockSnapshot> transaction=iterator.next();
        Location<World> location=transaction.getOriginal().getLocation().get();
        IBlockState state=(IBlockState)transaction.getOriginal().getState();
        BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
        net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
        blockSnapshots.add(blockSnapshot);
      }
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshots.get(0).getWorld().getBlockState(blockSnapshots.get(0).getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.MultiPlaceEvent forgeEvent=new BlockEvent.MultiPlaceEvent(blockSnapshots,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
  }
  return spongeEvent;
}","public static ChangeBlockEvent.Place callBlockPlaceEvent(Event event){
  ChangeBlockEvent.Place spongeEvent=(ChangeBlockEvent.Place)event;
  if (spongeEvent.getCause().root() instanceof Player) {
    EntityPlayer player=(EntityPlayer)spongeEvent.getCause().first(Player.class).get();
    net.minecraft.world.World world=player.world;
    final CauseTracker causeTracker=CauseTracker.getInstance();
    PhaseContext context=causeTracker.getCurrentContext();
    Packet<?> contextPacket=context.getExtra(InternalNamedCauses.Packet.CAPTURED_PACKET,Packet.class);
    if (contextPacket == null) {
      return spongeEvent;
    }
    if (spongeEvent.getTransactions().size() == 1) {
      BlockPos pos=VecHelper.toBlockPos(spongeEvent.getTransactions().get(0).getOriginal().getPosition());
      IBlockState state=(IBlockState)spongeEvent.getTransactions().get(0).getOriginal().getState();
      net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshot.getWorld().getBlockState(blockSnapshot.getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.PlaceEvent forgeEvent=new BlockEvent.PlaceEvent(blockSnapshot,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
 else {
      Iterator<Transaction<BlockSnapshot>> iterator=spongeEvent.getTransactions().iterator();
      List<net.minecraftforge.common.util.BlockSnapshot> blockSnapshots=new ArrayList<>();
      while (iterator.hasNext()) {
        Transaction<BlockSnapshot> transaction=iterator.next();
        Location<World> location=transaction.getOriginal().getLocation().get();
        IBlockState state=(IBlockState)transaction.getOriginal().getState();
        BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
        net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
        blockSnapshots.add(blockSnapshot);
      }
      IBlockState placedAgainst=Blocks.AIR.getDefaultState();
      EnumHand hand=EnumHand.MAIN_HAND;
      if (contextPacket instanceof CPacketPlayerTryUseItemOnBlock) {
        CPacketPlayerTryUseItemOnBlock packet=(CPacketPlayerTryUseItemOnBlock)contextPacket;
        EnumFacing facing=packet.getDirection();
        placedAgainst=blockSnapshots.get(0).getWorld().getBlockState(blockSnapshots.get(0).getPos().offset(facing.getOpposite()));
        hand=packet.getHand();
      }
      BlockEvent.MultiPlaceEvent forgeEvent=new BlockEvent.MultiPlaceEvent(blockSnapshots,placedAgainst,player,hand);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.setCancelled(true);
      }
    }
  }
  return spongeEvent;
}"
27547,"public static UnloadChunkEvent createUnloadChunkEvent(ChunkEvent.Unload forgeEvent){
  return SpongeEventFactory.createUnloadChunkEvent(Cause.of(NamedCause.source(forgeEvent.getWorld())),(Chunk)forgeEvent.getChunk());
}","public static UnloadChunkEvent createUnloadChunkEvent(ChunkEvent.Unload forgeEvent){
  Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  return SpongeEventFactory.createUnloadChunkEvent(Sponge.getCauseStackManager().getCurrentCause(),(Chunk)forgeEvent.getChunk());
}"
27548,"public static ChangeBlockEvent.Pre createChangeBlockEventPre(BlockEvent.BreakEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  final CauseTracker causeTracker=CauseTracker.getInstance();
  final PhaseData data=causeTracker.getCurrentPhaseData();
  Cause.Builder builder=null;
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    if (owner != null) {
      builder=Cause.source(owner);
      builder.named(NamedCause.FAKE_PLAYER,player);
    }
 else     if (notifier != null) {
      builder=Cause.source(notifier);
      builder.named(NamedCause.FAKE_PLAYER,player);
    }
 else {
      builder=Cause.builder().named(NamedCause.FAKE_PLAYER,player);
    }
  }
  if (builder == null) {
    builder=Cause.source(player);
  }
  if (owner != null) {
    builder.owner(owner);
  }
  if (notifier != null) {
    builder.notifier(notifier);
  }
  builder.named(NamedCause.PLAYER_BREAK,world);
  ChangeBlockEvent.Pre spongeEvent=SpongeEventFactory.createChangeBlockEventPre(builder.build(),ImmutableList.of(new Location<>((World)world,pos.getX(),pos.getY(),pos.getZ())));
  return spongeEvent;
}","public static ChangeBlockEvent.Pre createChangeBlockEventPre(BlockEvent.BreakEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  final CauseTracker causeTracker=CauseTracker.getInstance();
  final PhaseData data=causeTracker.getCurrentPhaseData();
  User owner=data.context.getOwner().orElse(null);
  User notifier=data.context.getNotifier().orElse(null);
  EntityPlayer player=forgeEvent.getPlayer();
  if (SpongeImplHooks.isFakePlayer(player)) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FAKE_PLAYER,EntityUtil.toPlayer(player));
  }
  Sponge.getCauseStackManager().pushCause(player);
  if (owner != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.OWNER,owner);
  }
  if (notifier != null) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.NOTIFIER,notifier);
  }
  Sponge.getCauseStackManager().addContext(EventContextKeys.PLAYER_BREAK,(World)world);
  return SpongeEventFactory.createChangeBlockEventPre(Sponge.getCauseStackManager().getCurrentCause(),ImmutableList.of(new Location<>((World)world,pos.getX(),pos.getY(),pos.getZ())));
}"
27549,"public static ChangeBlockEvent.Place createChangeBlockEventPlace(BlockEvent.MultiPlaceEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  ImmutableList.Builder<Transaction<BlockSnapshot>> builder=new ImmutableList.Builder<Transaction<BlockSnapshot>>();
  for (  net.minecraftforge.common.util.BlockSnapshot blockSnapshot : forgeEvent.getReplacedBlockSnapshots()) {
    final BlockPos snapshotPos=blockSnapshot.getPos();
    BlockSnapshot originalSnapshot=((IMixinBlockSnapshot)blockSnapshot).createSpongeBlockSnapshot();
    BlockSnapshot finalSnapshot=((World)world).createSnapshot(snapshotPos.getX(),snapshotPos.getY(),snapshotPos.getZ());
    builder.add(new Transaction<>(originalSnapshot,finalSnapshot));
  }
  ChangeBlockEvent.Place spongeEvent=SpongeEventFactory.createChangeBlockEventPlace(Cause.source(forgeEvent.getPlayer()).build(),builder.build());
  return spongeEvent;
}","public static ChangeBlockEvent.Place createChangeBlockEventPlace(BlockEvent.MultiPlaceEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getWorld();
  if (world.isRemote) {
    return null;
  }
  ImmutableList.Builder<Transaction<BlockSnapshot>> builder=new ImmutableList.Builder<Transaction<BlockSnapshot>>();
  for (  net.minecraftforge.common.util.BlockSnapshot blockSnapshot : forgeEvent.getReplacedBlockSnapshots()) {
    final BlockPos snapshotPos=blockSnapshot.getPos();
    BlockSnapshot originalSnapshot=((IMixinBlockSnapshot)blockSnapshot).createSpongeBlockSnapshot();
    BlockSnapshot finalSnapshot=((World)world).createSnapshot(snapshotPos.getX(),snapshotPos.getY(),snapshotPos.getZ());
    builder.add(new Transaction<>(originalSnapshot,finalSnapshot));
  }
  Sponge.getCauseStackManager().pushCause(forgeEvent.getPlayer());
  return SpongeEventFactory.createChangeBlockEventPlace(Sponge.getCauseStackManager().getCurrentCause(),builder.build());
}"
27550,"public static SleepingEvent.Pre createSleepingEventPre(PlayerSleepInBedEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getEntity().getEntityWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  BlockSnapshot bedSnapshot=((World)world).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
  SleepingEvent.Pre spongeEvent=SpongeEventFactory.createSleepingEventPre(Cause.source(forgeEvent.getEntity()).build(),bedSnapshot,(org.spongepowered.api.entity.Entity)forgeEvent.getEntity());
  return spongeEvent;
}","public static SleepingEvent.Pre createSleepingEventPre(PlayerSleepInBedEvent forgeEvent){
  final net.minecraft.world.World world=forgeEvent.getEntity().getEntityWorld();
  if (world.isRemote) {
    return null;
  }
  final BlockPos pos=forgeEvent.getPos();
  BlockSnapshot bedSnapshot=((World)world).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
  Sponge.getCauseStackManager().pushCause(forgeEvent.getEntity());
  return SpongeEventFactory.createSleepingEventPre(Sponge.getCauseStackManager().getCurrentCause(),bedSnapshot,(org.spongepowered.api.entity.Entity)forgeEvent.getEntity());
}"
27551,"public static MessageChannelEvent.Chat createMessageChannelEventChat(ServerChatEvent forgeEvent){
  final ITextComponent forgeComponent=forgeEvent.getComponent();
  final MessageFormatter formatter=new MessageFormatter();
  MessageChannel channel;
  Text[] chat=SpongeTexts.splitChatMessage((TextComponentTranslation)forgeComponent);
  if (chat[1] == null) {
    chat[1]=chat[0] != null ? chat[0] : SpongeTexts.toText(forgeComponent);
    chat[0]=null;
  }
  if (chat[0] != null) {
    formatter.getHeader().add(new DefaultHeaderApplier(chat[0]));
  }
  formatter.getBody().add(new DefaultBodyApplier(chat[1]));
  Text rawSpongeMessage=Text.of(forgeEvent.getMessage());
  MessageChannel originalChannel=channel=((Player)forgeEvent.getPlayer()).getMessageChannel();
  MessageChannelEvent.Chat spongeEvent=SpongeEventFactory.createMessageChannelEventChat(Cause.source(forgeEvent.getPlayer()).build(),originalChannel,Optional.ofNullable(channel),formatter,rawSpongeMessage,false);
  return spongeEvent;
}","public static MessageChannelEvent.Chat createMessageChannelEventChat(ServerChatEvent forgeEvent){
  final ITextComponent forgeComponent=forgeEvent.getComponent();
  final MessageFormatter formatter=new MessageFormatter();
  MessageChannel channel;
  Text[] chat=SpongeTexts.splitChatMessage((TextComponentTranslation)forgeComponent);
  if (chat[1] == null) {
    chat[1]=chat[0] != null ? chat[0] : SpongeTexts.toText(forgeComponent);
    chat[0]=null;
  }
  if (chat[0] != null) {
    formatter.getHeader().add(new DefaultHeaderApplier(chat[0]));
  }
  formatter.getBody().add(new DefaultBodyApplier(chat[1]));
  Text rawSpongeMessage=Text.of(forgeEvent.getMessage());
  MessageChannel originalChannel=channel=((Player)forgeEvent.getPlayer()).getMessageChannel();
  Sponge.getCauseStackManager().pushCause(forgeEvent.getPlayer());
  return SpongeEventFactory.createMessageChannelEventChat(Sponge.getCauseStackManager().getCurrentCause(),originalChannel,Optional.ofNullable(channel),formatter,rawSpongeMessage,false);
}"
27552,"public static void preEventPhaseCheck(IEventListener listener,Event event){
  if (!CauseTracker.ENABLED) {
    return;
  }
  if (event instanceof TickEvent.WorldTickEvent) {
    final TickEvent.WorldTickEvent worldTickEvent=(TickEvent.WorldTickEvent)event;
    if (!(worldTickEvent.world instanceof IMixinWorldServer)) {
      return;
    }
    if (worldTickEvent.phase == TickEvent.Phase.START) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.PRE_WORLD_TICK_LISTENER,PhaseContext.start().add(NamedCause.source(listener)).add(NamedCause.of(InternalNamedCauses.Tracker.TICK_EVENT,event)).addCaptures().player().complete());
    }
 else     if (worldTickEvent.phase == TickEvent.Phase.END) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.POST_WORLD_TICK_LISTENER,PhaseContext.start().add(NamedCause.source(listener)).add(NamedCause.of(InternalNamedCauses.Tracker.TICK_EVENT,event)).addCaptures().player().complete());
    }
  }
  if (event instanceof TickEvent.ServerTickEvent) {
    final TickEvent.ServerTickEvent serverTickEvent=(TickEvent.ServerTickEvent)event;
    if (serverTickEvent.phase == TickEvent.Phase.START) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.PRE_SERVER_TICK_LISTENER,PhaseContext.start().add(NamedCause.source(listener)).add(NamedCause.of(InternalNamedCauses.Tracker.TICK_EVENT,event)).addCaptures().player().complete());
    }
 else     if (serverTickEvent.phase == TickEvent.Phase.END) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.POST_SERVER_TICK_LISTENER,PhaseContext.start().source(listener).addExtra(InternalNamedCauses.Tracker.TICK_EVENT,event).addCaptures().player().complete());
    }
  }
}","public static void preEventPhaseCheck(IEventListener listener,Event event){
  if (!CauseTracker.ENABLED) {
    return;
  }
  if (event instanceof TickEvent.WorldTickEvent) {
    final TickEvent.WorldTickEvent worldTickEvent=(TickEvent.WorldTickEvent)event;
    if (!(worldTickEvent.world instanceof IMixinWorldServer)) {
      return;
    }
    if (worldTickEvent.phase == TickEvent.Phase.START) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.PRE_WORLD_TICK_LISTENER,PhaseContext.start().source(listener).addExtra(InternalNamedCauses.Tracker.TICK_EVENT,event).addCaptures().player().complete());
    }
 else     if (worldTickEvent.phase == TickEvent.Phase.END) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.POST_WORLD_TICK_LISTENER,PhaseContext.start().source(listener).addExtra(InternalNamedCauses.Tracker.TICK_EVENT,event).addCaptures().player().complete());
    }
  }
  if (event instanceof TickEvent.ServerTickEvent) {
    final TickEvent.ServerTickEvent serverTickEvent=(TickEvent.ServerTickEvent)event;
    if (serverTickEvent.phase == TickEvent.Phase.START) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.PRE_SERVER_TICK_LISTENER,PhaseContext.start().source(listener).addExtra(InternalNamedCauses.Tracker.TICK_EVENT,event).addCaptures().player().complete());
    }
 else     if (serverTickEvent.phase == TickEvent.Phase.END) {
      CauseTracker.getInstance().switchToPhase(PluginPhase.Listener.POST_SERVER_TICK_LISTENER,PhaseContext.start().source(listener).addExtra(InternalNamedCauses.Tracker.TICK_EVENT,event).addCaptures().player().complete());
    }
  }
}"
27553,"@Inject(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str""),cancellable=true) private void onCatchFirePreCheckOther(World world,BlockPos pos,int chance,Random random,int age,EnumFacing facing,CallbackInfo callbackInfo){
  if (!world.isRemote) {
    if (SpongeCommonEventFactory.callChangeBlockEventPre((IMixinWorldServer)world,pos,NamedCause.of(NamedCause.FIRE_SPREAD,world)).isCancelled()) {
      callbackInfo.cancel();
    }
  }
}","@Inject(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str""),cancellable=true) private void onCatchFirePreCheckOther(World world,BlockPos pos,int chance,Random random,int age,EnumFacing facing,CallbackInfo callbackInfo){
  if (!world.isRemote) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FIRE_SPREAD,(org.spongepowered.api.world.World)world);
    if (SpongeCommonEventFactory.callChangeBlockEventPre((IMixinWorldServer)world,pos).isCancelled()) {
      callbackInfo.cancel();
    }
  }
}"
27554,"@Inject(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str""),cancellable=true) private void onCatchFirePreCheck(World world,BlockPos pos,int chance,Random random,int age,EnumFacing facing,CallbackInfo callbackInfo){
  if (!world.isRemote) {
    if (SpongeCommonEventFactory.callChangeBlockEventPre((IMixinWorldServer)world,pos,NamedCause.of(NamedCause.FIRE_SPREAD,world)).isCancelled()) {
      callbackInfo.cancel();
    }
  }
}","@Inject(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str""),cancellable=true) private void onCatchFirePreCheck(World world,BlockPos pos,int chance,Random random,int age,EnumFacing facing,CallbackInfo callbackInfo){
  if (!world.isRemote) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.FIRE_SPREAD,(org.spongepowered.api.world.World)world);
    if (SpongeCommonEventFactory.callChangeBlockEventPre((IMixinWorldServer)world,pos).isCancelled()) {
      callbackInfo.cancel();
    }
  }
}"
27555,"@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onBreakBlock(Block block,IBlockState state,net.minecraft.world.World worldIn,BlockPos pos){
  if (CauseTracker.ENABLED && !worldIn.isRemote) {
    if (SpongeCommonEventFactory.callChangeBlockEventPre((IMixinWorldServer)worldIn,pos,NamedCause.of(""String_Node_Str"",worldIn)).isCancelled()) {
      return;
    }
    final CauseTracker causeTracker=CauseTracker.getInstance();
    final IPhaseState currentState=causeTracker.getCurrentState();
    final boolean isBlockAlready=currentState.getPhase() != TrackingPhases.BLOCK;
    final boolean isWorldGen=currentState.getPhase().isWorldGeneration(currentState);
    if (isBlockAlready && !isWorldGen) {
      final LocatableBlock locatable=LocatableBlock.builder().location(new Location<World>((World)worldIn,pos.getX(),pos.getY(),pos.getZ())).state((BlockState)state).build();
      causeTracker.switchToPhase(BlockPhase.State.BLOCK_DECAY,PhaseContext.start().source(locatable).addCaptures().complete());
    }
    block.beginLeavesDecay(state,worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.completePhase(BlockPhase.State.BLOCK_DECAY);
    }
  }
 else {
    block.beginLeavesDecay(state,worldIn,pos);
  }
}","@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onBreakBlock(Block block,IBlockState state,net.minecraft.world.World worldIn,BlockPos pos){
  if (CauseTracker.ENABLED && !worldIn.isRemote) {
    Sponge.getCauseStackManager().addContext(EventContextKeys.LEAVES_DECAY,(World)worldIn);
    if (SpongeCommonEventFactory.callChangeBlockEventPre((IMixinWorldServer)worldIn,pos).isCancelled()) {
      return;
    }
    final CauseTracker causeTracker=CauseTracker.getInstance();
    final IPhaseState currentState=causeTracker.getCurrentState();
    final boolean isBlockAlready=currentState.getPhase() != TrackingPhases.BLOCK;
    final boolean isWorldGen=currentState.getPhase().isWorldGeneration(currentState);
    if (isBlockAlready && !isWorldGen) {
      final LocatableBlock locatable=LocatableBlock.builder().location(new Location<World>((World)worldIn,pos.getX(),pos.getY(),pos.getZ())).state((BlockState)state).build();
      causeTracker.switchToPhase(BlockPhase.State.BLOCK_DECAY,PhaseContext.start().source(locatable).addCaptures().complete());
    }
    block.beginLeavesDecay(state,worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.completePhase(BlockPhase.State.BLOCK_DECAY);
    }
  }
 else {
    block.beginLeavesDecay(state,worldIn,pos);
  }
}"
27556,"public SpongeCoremod(){
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  try {
    JavaVersionCheckUtils.ensureJava8();
  }
 catch (  Exception e) {
    e.printStackTrace();
    this.clearSecurityManager();
    Runtime.getRuntime().exit(1);
  }
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  SpongeLaunch.initPaths((File)FMLInjectionData.data()[6]);
  SpongeLaunch.setupMixinEnvironment();
  if (this.isProductionEnvironment()) {
    Mixins.registerErrorHandlerClass(""String_Node_Str"");
  }
  Mixins.addConfiguration(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  MixinEnvironment.getDefaultEnvironment().registerTokenProviderClass(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  MixinEnvironment.getEnvironment(Phase.PREINIT).registerTokenProviderClass(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  MixinEnvironment.getEnvironment(Phase.INIT).registerTokenProviderClass(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  SpongeLaunch.setupSuperClassTransformer();
}","public SpongeCoremod(){
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  try {
    JavaVersionCheckUtils.ensureJava8();
  }
 catch (  Exception e) {
    e.printStackTrace();
    this.clearSecurityManager();
    Runtime.getRuntime().exit(1);
  }
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  SpongeLaunch.initPaths((File)FMLInjectionData.data()[6]);
  SpongeLaunch.setupMixinEnvironment();
  if (this.isProductionEnvironment()) {
    Mixins.registerErrorHandlerClass(""String_Node_Str"");
  }
  Mixins.addConfiguration(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  MixinEnvironment.getDefaultEnvironment().registerTokenProviderClass(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  MixinEnvironment.getEnvironment(Phase.PREINIT).registerTokenProviderClass(""String_Node_Str"");
  Mixins.addConfiguration(""String_Node_Str"");
  MixinEnvironment.getEnvironment(Phase.INIT).registerTokenProviderClass(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  SpongeLaunch.setupSuperClassTransformer();
}"
27557,"public static LoadChunkEvent createLoadChunkEvent(ChunkEvent.Load forgeEvent){
  Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  return SpongeEventFactory.createLoadChunkEvent(Sponge.getCauseStackManager().getCurrentCause(),(Chunk)forgeEvent.getChunk());
}","public static LoadChunkEvent createLoadChunkEvent(ChunkEvent.Load forgeEvent){
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  if (isMainThread) {
    Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  }
  final Cause cause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),forgeEvent.getWorld());
  return SpongeEventFactory.createLoadChunkEvent(cause,(Chunk)forgeEvent.getChunk());
}"
27558,"public static UnloadChunkEvent createUnloadChunkEvent(ChunkEvent.Unload forgeEvent){
  Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  return SpongeEventFactory.createUnloadChunkEvent(Sponge.getCauseStackManager().getCurrentCause(),(Chunk)forgeEvent.getChunk());
}","public static UnloadChunkEvent createUnloadChunkEvent(ChunkEvent.Unload forgeEvent){
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  if (isMainThread) {
    Sponge.getCauseStackManager().pushCause(forgeEvent.getWorld());
  }
  final Cause cause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),forgeEvent.getWorld());
  return SpongeEventFactory.createUnloadChunkEvent(cause,(Chunk)forgeEvent.getChunk());
}"
27559,"@Override public boolean post(Event event,boolean forced){
  org.spongepowered.api.event.Event spongeEvent=null;
  try (final CauseStackManager.CauseStackFrame frame=Sponge.getCauseStackManager().pushCauseFrame()){
    if (!forced) {
      if (!isEventAllowed(event)) {
        return false;
      }
      spongeEvent=SpongeForgeEventFactory.createSpongeEvent(event);
    }
    IEventListener[] listeners=event.getListenerList().getListeners(this.busID);
    if (!forced && (event instanceof org.spongepowered.api.event.Event || spongeEvent != null) && !Sponge.getGame().getPlatform().getExecutionType().isClient()) {
      boolean cancelled=((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,event,listeners);
      if (!cancelled) {
        SpongeForgeEventFactory.onForgePost(event);
      }
      return cancelled;
    }
    listeners=event.getListenerList().getListeners(this.busID);
    int index=0;
    IMixinASMEventHandler modListener=null;
    try {
      for (; index < listeners.length; index++) {
        final IEventListener listener=listeners[index];
        if (listener instanceof IMixinASMEventHandler) {
          modListener=(IMixinASMEventHandler)listener;
          modListener.getTimingsHandler().startTimingIfSync();
          SpongeForgeEventHooks.preEventPhaseCheck(listener,event);
          listener.invoke(event);
          SpongeForgeEventHooks.postEventPhaseCheck(listener,event);
          modListener.getTimingsHandler().stopTimingIfSync();
        }
 else {
          listener.invoke(event);
        }
      }
    }
 catch (    Throwable throwable) {
      if (modListener != null) {
        modListener.getTimingsHandler().stopTimingIfSync();
      }
      this.exceptionHandler.handleException((EventBus)(Object)this,event,listeners,index,throwable);
      throw new RuntimeException(throwable);
    }
  }
   return (event.isCancelable() ? event.isCanceled() : false);
}","@Override public boolean post(Event event,boolean forced){
  org.spongepowered.api.event.Event spongeEvent=null;
  if (!isSpongeSetUp) {
    try {
      Sponge.getCauseStackManager();
    }
 catch (    Exception e) {
      return false;
    }
  }
  isSpongeSetUp=true;
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  try (final CauseStackManager.CauseStackFrame frame=isMainThread ? Sponge.getCauseStackManager().pushCauseFrame() : null){
    if (!forced) {
      if (!isEventAllowed(event)) {
        return false;
      }
      spongeEvent=SpongeForgeEventFactory.createSpongeEvent(event);
    }
    IEventListener[] listeners=event.getListenerList().getListeners(this.busID);
    if (!forced && (event instanceof org.spongepowered.api.event.Event || spongeEvent != null) && !Sponge.getGame().getPlatform().getExecutionType().isClient()) {
      boolean cancelled=((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,event,listeners);
      if (!cancelled) {
        SpongeForgeEventFactory.onForgePost(event);
      }
      return cancelled;
    }
    listeners=event.getListenerList().getListeners(this.busID);
    int index=0;
    IMixinASMEventHandler modListener=null;
    try {
      for (; index < listeners.length; index++) {
        final IEventListener listener=listeners[index];
        if (listener instanceof IMixinASMEventHandler) {
          modListener=(IMixinASMEventHandler)listener;
          modListener.getTimingsHandler().startTimingIfSync();
          SpongeForgeEventHooks.preEventPhaseCheck(listener,event);
          listener.invoke(event);
          SpongeForgeEventHooks.postEventPhaseCheck(listener,event);
          modListener.getTimingsHandler().stopTimingIfSync();
        }
 else {
          listener.invoke(event);
        }
      }
    }
 catch (    Throwable throwable) {
      if (modListener != null) {
        modListener.getTimingsHandler().stopTimingIfSync();
      }
      this.exceptionHandler.handleException((EventBus)(Object)this,event,listeners,index,throwable);
      throw new RuntimeException(throwable);
    }
    return (event.isCancelable() ? event.isCanceled() : false);
  }
 }"
27560,"@SubscribeEvent(priority=EventPriority.HIGHEST) public void onCustomPacketRegistration(CustomPacketRegistrationEvent<?> event){
  Set<String> channels=((IMixinNetPlayHandler)event.getHandler()).getRegisteredChannels();
  ;
  try (final CauseStackManager.CauseStackFrame causeStackFrame=Sponge.getCauseStackManager().pushCauseFrame()){
    if (event.getHandler() instanceof NetHandlerPlayServer) {
      Sponge.getCauseStackManager().pushCause(((NetHandlerPlayServer)event.getHandler()).player);
    }
    Sponge.getCauseStackManager().addContext(NET_HANDLER,event.getHandler());
    if (event.getOperation().equals(""String_Node_Str"")) {
      channels.addAll(event.getRegistrations());
      for (      String channel : event.getRegistrations()) {
        SpongeImpl.postEvent(SpongeEventFactory.createChannelRegistrationEventRegister(Sponge.getCauseStackManager().getCurrentCause(),channel));
      }
    }
 else     if (event.getOperation().equals(""String_Node_Str"")) {
      channels.removeAll(event.getRegistrations());
      for (      String channel : event.getRegistrations()) {
        SpongeImpl.postEvent(SpongeEventFactory.createChannelRegistrationEventUnregister(Sponge.getCauseStackManager().getCurrentCause(),channel));
      }
    }
  }
 }","@SubscribeEvent(priority=EventPriority.HIGHEST) public void onCustomPacketRegistration(CustomPacketRegistrationEvent<?> event){
  Set<String> channels=((IMixinNetPlayHandler)event.getHandler()).getRegisteredChannels();
  ;
  final boolean isMainThread=Sponge.isServerAvailable() && Sponge.getServer().isMainThread();
  try (final CauseStackManager.CauseStackFrame frame=isMainThread ? Sponge.getCauseStackManager().pushCauseFrame() : null){
    if (isMainThread) {
      if (event.getHandler() instanceof NetHandlerPlayServer) {
        Sponge.getCauseStackManager().pushCause(((NetHandlerPlayServer)event.getHandler()).player);
      }
      Sponge.getCauseStackManager().addContext(NET_HANDLER,event.getHandler());
    }
    if (event.getOperation().equals(""String_Node_Str"")) {
      channels.addAll(event.getRegistrations());
      for (      String channel : event.getRegistrations()) {
        final Cause currentCause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),Sponge.getGame());
        SpongeImpl.postEvent(SpongeEventFactory.createChannelRegistrationEventRegister(currentCause,channel));
      }
    }
 else     if (event.getOperation().equals(""String_Node_Str"")) {
      channels.removeAll(event.getRegistrations());
      for (      String channel : event.getRegistrations()) {
        final Cause currentCause=isMainThread ? Sponge.getCauseStackManager().getCurrentCause() : Cause.of(EventContext.empty(),Sponge.getGame());
        SpongeImpl.postEvent(SpongeEventFactory.createChannelRegistrationEventUnregister(currentCause,channel));
      }
    }
  }
 }"
27561,"private static LoadWorldEvent callWorldLoadEvent(Event event){
  LoadWorldEvent spongeEvent=(LoadWorldEvent)event;
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(new WorldEvent.Load((net.minecraft.world.World)spongeEvent.getTargetWorld()),true);
  return spongeEvent;
}","private static LoadWorldEvent callWorldLoadEvent(Event event){
  LoadWorldEvent spongeEvent=(LoadWorldEvent)event;
  ((IMixinWorld)spongeEvent.getTargetWorld()).setCallingWorldEvent(true);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(new WorldEvent.Load((net.minecraft.world.World)spongeEvent.getTargetWorld()),true);
  ((IMixinWorld)spongeEvent.getTargetWorld()).setCallingWorldEvent(false);
  return spongeEvent;
}"
27562,"private static SaveWorldEvent callWorldSaveEvent(Event event){
  SaveWorldEvent spongeEvent=(SaveWorldEvent)event;
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(new WorldEvent.Save((net.minecraft.world.World)spongeEvent.getTargetWorld()),true);
  return spongeEvent;
}","private static SaveWorldEvent callWorldSaveEvent(Event event){
  SaveWorldEvent spongeEvent=(SaveWorldEvent)event;
  ((IMixinWorld)spongeEvent.getTargetWorld()).setCallingWorldEvent(true);
  ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(new WorldEvent.Save((net.minecraft.world.World)spongeEvent.getTargetWorld()),true);
  ((IMixinWorld)spongeEvent.getTargetWorld()).setCallingWorldEvent(false);
  return spongeEvent;
}"
27563,"/** 
 * @author blood - August 10th, 2016
 * @reason Constructs a WorldProvider instance in order to locate the save folder name to use.
 * @return The path if available
 */
@Overwrite public static Optional<Path> getWorldFolder(DimensionType dimensionType,int dimensionId){
  if (dimensionType == null) {
    return Optional.empty();
  }
  Path path=dimensionPathByDimensionId.get(dimensionId);
  if (path == null) {
    try {
      WorldProvider provider=dimensionType.createDimension();
      provider.setDimension(dimensionId);
      String worldFolder=provider.getSaveFolder();
      path=SpongeImpl.getGame().getSavesDirectory().resolve(SpongeImpl.getServer().getFolderName()).resolve(worldFolder);
      WorldManager.registerDimensionPath(dimensionId,path);
    }
 catch (    Throwable t) {
      return Optional.empty();
    }
  }
  return Optional.ofNullable(path);
}","/** 
 * @author blood - August 10th, 2016
 * @reason Constructs a WorldProvider instance in order to locate the save folder name to use.
 * @return The path if available
 */
@Overwrite public static Path getWorldFolder(DimensionType dimensionType,int dimensionId){
  Path path=dimensionPathByDimensionId.get(dimensionId);
  if (path != null) {
    return path;
  }
  if (dimensionType == null) {
    return null;
  }
  try {
    WorldProvider provider=dimensionType.createDimension();
    provider.setDimension(dimensionId);
    String worldFolder=provider.getSaveFolder();
    path=SpongeImpl.getGame().getSavesDirectory().resolve(SpongeImpl.getServer().getFolderName()).resolve(worldFolder);
    WorldManager.registerDimensionPath(dimensionId,path);
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  return path;
}"
27564,"/** 
 * @author Zidane - June 2nd, 2016
 * @reason Forge's initDimension is very different from Sponge's multi-world. We basically rig it into our system so mods work.
 * @param dim The dimension to load
 */
@Overwrite public static void initDimension(int dim){
  if (WorldManager.getWorldByDimensionId(dim).isPresent()) {
    return;
  }
  if (dim == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  WorldManager.getWorldByDimensionId(0).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str""));
  DimensionType dimensionType=WorldManager.getDimensionType(dim).orElse(null);
  if (dimensionType == null) {
    SpongeImpl.getLogger().warn(""String_Node_Str"" + ""String_Node_Str"",dim);
    return;
  }
  final WorldProvider provider=dimensionType.createDimension();
  provider.setDimension(dim);
  String worldFolder=WorldManager.getWorldFolderByDimensionId(dim).orElse(provider.getSaveFolder());
  WorldProperties properties=WorldManager.getWorldProperties(worldFolder).orElse(null);
  if (properties == null) {
    final WorldArchetype.Builder builder=WorldArchetype.builder().dimension((org.spongepowered.api.world.DimensionType)(Object)dimensionType).keepsSpawnLoaded(dimensionType.shouldLoadSpawn());
    String modId=StaticMixinForgeHelper.getModIdFromClass(provider.getClass());
    final WorldArchetype archetype=builder.build(modId + ""String_Node_Str"" + dimensionType.getName().toLowerCase(),dimensionType.getName());
    properties=WorldManager.createWorldProperties(worldFolder,archetype);
    ((IMixinWorldInfo)properties).setDimensionId(dim);
  }
  if (!properties.isEnabled()) {
    SpongeImpl.getLogger().warn(""String_Node_Str"",worldFolder,dim);
    return;
  }
  Optional<WorldServer> optWorld=WorldManager.loadWorld(properties);
  if (!optWorld.isPresent()) {
    SpongeImpl.getLogger().error(""String_Node_Str"",properties.getWorldName());
  }
}","/** 
 * @author Zidane - June 2nd, 2016
 * @reason Forge's initDimension is very different from Sponge's multi-world. We basically rig it into our system so mods work.
 * @param dim The dimension to load
 */
@Overwrite public static void initDimension(int dim){
  if (WorldManager.getWorldByDimensionId(dim).isPresent()) {
    return;
  }
  if (dim == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  WorldManager.getWorldByDimensionId(0).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str""));
  DimensionType dimensionType=WorldManager.getDimensionType(dim).orElse(null);
  if (dimensionType == null) {
    SpongeImpl.getLogger().warn(""String_Node_Str"" + ""String_Node_Str"",dim);
    return;
  }
  final WorldProvider provider=dimensionType.createDimension();
  provider.setDimension(dim);
  String worldFolder=WorldManager.getWorldFolderByDimensionId(dim).orElse(provider.getSaveFolder());
  WorldProperties properties=WorldManager.getWorldProperties(worldFolder).orElse(null);
  if (properties == null) {
    String modId=StaticMixinForgeHelper.getModIdFromClass(provider.getClass());
    WorldArchetype archetype=Sponge.getRegistry().getType(WorldArchetype.class,modId + ""String_Node_Str"" + dimensionType.getName().toLowerCase()).orElse(null);
    if (archetype == null) {
      final WorldArchetype.Builder builder=WorldArchetype.builder().dimension((org.spongepowered.api.world.DimensionType)(Object)dimensionType).keepsSpawnLoaded(dimensionType.shouldLoadSpawn());
      archetype=builder.build(modId + ""String_Node_Str"" + dimensionType.getName().toLowerCase(),dimensionType.getName());
    }
    IMixinWorldSettings worldSettings=(IMixinWorldSettings)archetype;
    worldSettings.setDimensionType((org.spongepowered.api.world.DimensionType)(Object)dimensionType);
    worldSettings.setLoadOnStartup(false);
    properties=WorldManager.createWorldProperties(worldFolder,archetype,dim);
    ((IMixinWorldInfo)properties).setDimensionId(dim);
    ((IMixinWorldInfo)properties).setIsMod(true);
  }
  if (!properties.isEnabled()) {
    SpongeImpl.getLogger().warn(""String_Node_Str"",worldFolder,dim);
    return;
  }
  Optional<WorldServer> optWorld=WorldManager.loadWorld(properties);
  if (!optWorld.isPresent()) {
    SpongeImpl.getLogger().error(""String_Node_Str"",properties.getWorldName());
  }
}"
27565,"@Overwrite public static void registerDimension(int id,DimensionType type){
  WorldManager.registerDimension(id,type,false);
}","@Overwrite public static void registerDimension(int id,DimensionType type){
  WorldManager.registerDimension(id,type);
}"
27566,"/** 
 * @author Simon816Remove call to firePlayerLoggedOut because SpongeCommon's MixinNetHandlerPlayServer.onDisconnectPlayer fires the event already. NOTE: ANY call to playerLoggedOut will need to fire the PlayerLoggedOutEvent manually!
 */
@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onFirePlayerLoggedOutCall(FMLCommonHandler thisCtx,EntityPlayer playerIn){
}","/** 
 * @author Simon816
 * @author dualspiralRemove call to firePlayerLoggedOut under ordinary circumstances because SpongeCommon's MixinNetHandlerPlayServer.onDisconnectHandler fires the event already. There is a special case where this event is reinstated - if Sponge's ClientConnectionEvent#Login event is cancelled - which we can detect because the EntityPlayerMP's NetHandlerPlayServer has not been reinstated at this stage. In that scenario, we fire Forge's event as a matter of compatibility with mods that might have started their setup with players. NOTE: ANY call to playerLoggedOut will need to fire the PlayerLoggedOutEvent manually!
 */
@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onFirePlayerLoggedOutCall(FMLCommonHandler thisCtx,EntityPlayer playerIn){
  if (playerIn instanceof EntityPlayerMP && ((EntityPlayerMP)playerIn).connection == null) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().firePlayerLoggedOut(playerIn);
  }
}"
27567,"public static ChunkEvent.Unload createChunkUnloadEvent(Event event){
  UnloadChunkEvent spongeEvent=(UnloadChunkEvent)event;
  ChunkEvent.Unload forgeEvent=new ChunkEvent.Unload(((Chunk)spongeEvent.getTargetChunk()));
  return forgeEvent;
}","public static ChunkEvent.Unload createChunkUnloadEvent(Event event){
  UnloadChunkEvent spongeEvent=(UnloadChunkEvent)event;
  ChunkEvent.Unload forgeEvent=new ChunkEvent.Unload(((net.minecraft.world.chunk.Chunk)spongeEvent.getTargetChunk()));
  return forgeEvent;
}"
27568,"public static ChunkEvent createChunkEvent(Event event){
  TargetChunkEvent spongeEvent=(TargetChunkEvent)event;
  ChunkEvent forgeEvent=new ChunkEvent(((Chunk)spongeEvent.getTargetChunk()));
  return forgeEvent;
}","public static ChunkEvent createChunkEvent(Event event){
  TargetChunkEvent spongeEvent=(TargetChunkEvent)event;
  ChunkEvent forgeEvent=new ChunkEvent(((net.minecraft.world.chunk.Chunk)spongeEvent.getTargetChunk()));
  return forgeEvent;
}"
27569,"public static ChunkEvent.Load createChunkLoadEvent(Event event){
  LoadChunkEvent spongeEvent=(LoadChunkEvent)event;
  ChunkEvent.Load forgeEvent=new ChunkEvent.Load(((Chunk)spongeEvent.getTargetChunk()));
  return forgeEvent;
}","public static ChunkEvent.Load createChunkLoadEvent(Event event){
  LoadChunkEvent spongeEvent=(LoadChunkEvent)event;
  ChunkEvent.Load forgeEvent=new ChunkEvent.Load(((net.minecraft.world.chunk.Chunk)spongeEvent.getTargetChunk()));
  return forgeEvent;
}"
27570,"@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onBreakBlock(Block block,IBlockState state,World worldIn,BlockPos pos){
  if (CauseTracker.ENABLED && !worldIn.isRemote) {
    IMixinWorldServer spongeWorld=(IMixinWorldServer)worldIn;
    final CauseTracker causeTracker=spongeWorld.getCauseTracker();
    final boolean isBlockAlready=causeTracker.getStack().current() != TrackingPhases.BLOCK;
    final IPhaseState currentState=causeTracker.getStack().peek().state;
    final boolean isWorldGen=currentState.getPhase().isWorldGeneration(currentState);
    final IBlockState blockState=worldIn.getBlockState(pos);
    final IBlockState actualState=blockState.getActualState(worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.switchToPhase(BlockPhase.State.BLOCK_DECAY,PhaseContext.start().add(NamedCause.source(spongeWorld.createSpongeBlockSnapshot(blockState,actualState,pos,3))).addCaptures().complete());
    }
    block.beginLeavesDecay(blockState,worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.completePhase();
    }
  }
 else {
    block.beginLeavesDecay(state,worldIn,pos);
  }
}","@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onBreakBlock(Block block,IBlockState state,World worldIn,BlockPos pos){
  if (CauseTracker.ENABLED && !worldIn.isRemote) {
    IMixinWorldServer spongeWorld=(IMixinWorldServer)worldIn;
    final CauseTracker causeTracker=spongeWorld.getCauseTracker();
    final IPhaseState currentState=causeTracker.getCurrentState();
    final boolean isBlockAlready=currentState.getPhase() != TrackingPhases.BLOCK;
    final boolean isWorldGen=currentState.getPhase().isWorldGeneration(currentState);
    final IBlockState blockState=worldIn.getBlockState(pos);
    final IBlockState actualState=blockState.getActualState(worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.switchToPhase(BlockPhase.State.BLOCK_DECAY,PhaseContext.start().add(NamedCause.source(spongeWorld.createSpongeBlockSnapshot(blockState,actualState,pos,3))).addCaptures().complete());
    }
    block.beginLeavesDecay(blockState,worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.completePhase();
    }
  }
 else {
    block.beginLeavesDecay(state,worldIn,pos);
  }
}"
27571,"@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onBreakBlock(Block block,IBlockState state,World worldIn,BlockPos pos){
  if (CauseTracker.ENABLED && !worldIn.isRemote) {
    IMixinWorldServer spongeWorld=(IMixinWorldServer)worldIn;
    final CauseTracker causeTracker=spongeWorld.getCauseTracker();
    final boolean isBlockAlready=causeTracker.getStack().current() != TrackingPhases.BLOCK;
    final IPhaseState currentState=causeTracker.getStack().peek().state;
    final boolean isWorldGen=currentState.getPhase().isWorldGeneration(currentState);
    final IBlockState actualState=state.getActualState(worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.switchToPhase(BlockPhase.State.BLOCK_DECAY,PhaseContext.start().add(NamedCause.source(spongeWorld.createSpongeBlockSnapshot(state,actualState,pos,3))).addCaptures().complete());
    }
    block.beginLeavesDecay(state,worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.completePhase();
    }
  }
 else {
    block.beginLeavesDecay(state,worldIn,pos);
  }
}","@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"",remap=false)) public void onBreakBlock(Block block,IBlockState state,World worldIn,BlockPos pos){
  if (CauseTracker.ENABLED && !worldIn.isRemote) {
    IMixinWorldServer spongeWorld=(IMixinWorldServer)worldIn;
    final CauseTracker causeTracker=spongeWorld.getCauseTracker();
    final IPhaseState currentState=causeTracker.getCurrentState();
    final boolean isBlockAlready=currentState.getPhase() != TrackingPhases.BLOCK;
    final boolean isWorldGen=currentState.getPhase().isWorldGeneration(currentState);
    final IBlockState actualState=state.getActualState(worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.switchToPhase(BlockPhase.State.BLOCK_DECAY,PhaseContext.start().add(NamedCause.source(spongeWorld.createSpongeBlockSnapshot(state,actualState,pos,3))).addCaptures().complete());
    }
    block.beginLeavesDecay(state,worldIn,pos);
    if (isBlockAlready && !isWorldGen) {
      causeTracker.completePhase();
    }
  }
 else {
    block.beginLeavesDecay(state,worldIn,pos);
  }
}"
27572,"/** 
 * @author bloodmc
 * @reason Since we capture blocks as they are set in the world, gettingthe current blockstate will not work during Forge's BlockBreak event as the state will be post. In order to workaround this issue, we set the captured extended state before creating the event.
 */
@Overwrite public static boolean canHarvestBlock(Block block,EntityPlayer player,IBlockAccess world,BlockPos pos){
  final IBlockState state;
  final IBlockState staticState=StaticMixinForgeHelper.breakEventExtendedState;
  if (staticState != null) {
    state=staticState;
  }
 else {
    state=world.getBlockState(pos).getActualState(world,pos);
  }
  if (world instanceof IMixinWorldServer && player instanceof EntityPlayerMP) {
    final CauseTracker causeTracker=((IMixinWorldServer)world).getCauseTracker();
    final PhaseData peek=causeTracker.getStack().peek();
    final IPhaseState phaseState=peek.state;
    phaseState.getPhase().capturePlayerUsingStackToBreakBlock(null,(EntityPlayerMP)player,phaseState,peek.context,causeTracker);
  }
  if (state.getMaterial().isToolNotRequired()) {
    return true;
  }
  ItemStack stack=player.inventory.getCurrentItem();
  String tool=block.getHarvestTool(state);
  if (stack == null || tool == null) {
    return player.canHarvestBlock(state);
  }
  int toolLevel=stack.getItem().getHarvestLevel(stack,tool);
  if (toolLevel < 0) {
    return player.canHarvestBlock(state);
  }
  return toolLevel >= block.getHarvestLevel(state);
}","/** 
 * @author bloodmc
 * @reason Since we capture blocks as they are set in the world, gettingthe current blockstate will not work during Forge's BlockBreak event as the state will be post. In order to workaround this issue, we set the captured extended state before creating the event.
 */
@Overwrite public static boolean canHarvestBlock(Block block,EntityPlayer player,IBlockAccess world,BlockPos pos){
  final IBlockState state;
  final IBlockState staticState=StaticMixinForgeHelper.breakEventExtendedState;
  if (staticState != null) {
    state=staticState;
  }
 else {
    state=world.getBlockState(pos).getActualState(world,pos);
  }
  if (world instanceof IMixinWorldServer && player instanceof EntityPlayerMP) {
    final CauseTracker causeTracker=((IMixinWorldServer)world).getCauseTracker();
    final PhaseData peek=causeTracker.getCurrentPhaseData();
    final IPhaseState phaseState=peek.state;
    phaseState.getPhase().capturePlayerUsingStackToBreakBlock(null,(EntityPlayerMP)player,phaseState,peek.context,causeTracker);
  }
  if (state.getMaterial().isToolNotRequired()) {
    return true;
  }
  ItemStack stack=player.inventory.getCurrentItem();
  String tool=block.getHarvestTool(state);
  if (stack == null || tool == null) {
    return player.canHarvestBlock(state);
  }
  int toolLevel=stack.getItem().getHarvestLevel(stack,tool);
  if (toolLevel < 0) {
    return player.canHarvestBlock(state);
  }
  return toolLevel >= block.getHarvestLevel(state);
}"
27573,"/** 
 * @author gabizou - June 21st, 2016
 * @reason Rewrites the forge handling of this to properly handlewhen sheared drops are captured by whatever current phase the {@link CauseTracker} is in.Returns true if the item can be used on the given entity, e.g. shears on sheep.
 */
@Overwrite @Override public boolean itemInteractionForEntity(ItemStack itemstack,EntityPlayer player,EntityLivingBase entity,EnumHand hand){
  if (entity.worldObj.isRemote) {
    return false;
  }
  if (entity instanceof IShearable) {
    IShearable target=(IShearable)entity;
    BlockPos pos=new BlockPos(entity.posX,entity.posY,entity.posZ);
    if (target.isShearable(itemstack,entity.worldObj,pos)) {
      List<ItemStack> drops=target.onSheared(itemstack,entity.worldObj,pos,EnchantmentHelper.getEnchantmentLevel(Enchantments.FORTUNE,itemstack));
      final CauseTracker causeTracker=((IMixinWorldServer)entity.worldObj).getCauseTracker();
      final PhaseData currentData=causeTracker.getStack().peek();
      final IPhaseState currentState=currentData.state;
      final PhaseContext phaseContext=currentData.context;
      final Random random=EntityUtil.fromNative(entity).getRandom();
      final IMixinEntity mixinEntity=EntityUtil.toMixin(entity);
      final double posX=entity.posX;
      final double posY=entity.posY + 1.0F;
      final double posZ=entity.posZ;
      final Vector3d position=new Vector3d(posX,posY,posZ);
      for (      ItemStack drop : drops) {
        final ItemStack item;
        if (drop.getItem() != null) {
          final ItemStackSnapshot snapshot=ItemStackUtil.createSnapshot(drop);
          final List<ItemStackSnapshot> original=new ArrayList<>();
          original.add(snapshot);
          final DropItemEvent.Pre dropEvent=SpongeEventFactory.createDropItemEventPre(Cause.of(NamedCause.source(entity)),ImmutableList.of(snapshot),original);
          if (dropEvent.isCancelled()) {
            continue;
          }
          Transform<World> suggested=new Transform<>(mixinEntity.getWorld(),position);
          SpawnCause cause=EntitySpawnCause.builder().entity(mixinEntity).type(SpawnTypes.DROPPED_ITEM).build();
          ConstructEntityEvent.Pre event=SpongeEventFactory.createConstructEntityEventPre(Cause.of(NamedCause.source(cause)),EntityTypes.ITEM,suggested);
          SpongeImpl.postEvent(event);
          item=event.isCancelled() ? null : ItemStackUtil.fromSnapshotToNative(dropEvent.getDroppedItems().get(0));
        }
 else {
          continue;
        }
        if (item == null) {
          continue;
        }
        if (item.stackSize != 0 && item.getItem() != null) {
          if (!currentState.getPhase().ignoresItemPreMerging(currentState) && SpongeImpl.getGlobalConfig().getConfig().getOptimizations().doDropsPreMergeItemDrops()) {
            if (currentState.tracksEntitySpecificDrops()) {
              final Multimap<UUID,ItemDropData> multimap=phaseContext.getCapturedEntityDropSupplier().get();
              final Collection<ItemDropData> itemStacks=multimap.get(entity.getUniqueID());
              SpongeImplHooks.addItemStackToListForSpawning(itemStacks,ItemDropData.item(item).motion(new Vector3d((random.nextFloat() - random.nextFloat()) * 0.1F,random.nextFloat() * 0.05F,(random.nextFloat() - random.nextFloat()) * 0.1F)).position(new Vector3d(posX,posY,posZ)).build());
              continue;
            }
 else {
              final List<ItemDropData> itemStacks=phaseContext.getCapturedItemStackSupplier().get();
              SpongeImplHooks.addItemStackToListForSpawning(itemStacks,ItemDropData.item(item).position(new Vector3d(posX,posY,posZ)).motion(new Vector3d((random.nextFloat() - random.nextFloat()) * 0.1F,random.nextFloat() * 0.05F,(random.nextFloat() - random.nextFloat()) * 0.1F)).build());
              continue;
            }
          }
          EntityItem entityitem=new EntityItem(entity.worldObj,posX,posY,posZ,item);
          entityitem.setDefaultPickupDelay();
          entityitem.motionY+=random.nextFloat() * 0.05F;
          entityitem.motionX+=(random.nextFloat() - random.nextFloat()) * 0.1F;
          entityitem.motionZ+=(random.nextFloat() - random.nextFloat()) * 0.1F;
          if (currentState.getPhase().doesCaptureEntityDrops(currentState)) {
            if (currentState.tracksEntitySpecificDrops()) {
              phaseContext.getCapturedEntityItemDropSupplier().get().put(entity.getUniqueID(),entityitem);
            }
 else {
              phaseContext.getCapturedItemsSupplier().get().add(entityitem);
            }
            continue;
          }
          entity.worldObj.spawnEntityInWorld(entityitem);
        }
      }
      itemstack.damageItem(1,entity);
    }
    return true;
  }
  return false;
}","/** 
 * @author gabizou - June 21st, 2016
 * @reason Rewrites the forge handling of this to properly handlewhen sheared drops are captured by whatever current phase the {@link CauseTracker} is in.Returns true if the item can be used on the given entity, e.g. shears on sheep.
 */
@Overwrite @Override public boolean itemInteractionForEntity(ItemStack itemstack,EntityPlayer player,EntityLivingBase entity,EnumHand hand){
  if (entity.worldObj.isRemote) {
    return false;
  }
  if (entity instanceof IShearable) {
    IShearable target=(IShearable)entity;
    BlockPos pos=new BlockPos(entity.posX,entity.posY,entity.posZ);
    if (target.isShearable(itemstack,entity.worldObj,pos)) {
      List<ItemStack> drops=target.onSheared(itemstack,entity.worldObj,pos,EnchantmentHelper.getEnchantmentLevel(Enchantments.FORTUNE,itemstack));
      final CauseTracker causeTracker=((IMixinWorldServer)entity.worldObj).getCauseTracker();
      final PhaseData currentData=causeTracker.getCurrentPhaseData();
      final IPhaseState currentState=currentData.state;
      final PhaseContext phaseContext=currentData.context;
      final Random random=EntityUtil.fromNative(entity).getRandom();
      final IMixinEntity mixinEntity=EntityUtil.toMixin(entity);
      final double posX=entity.posX;
      final double posY=entity.posY + 1.0F;
      final double posZ=entity.posZ;
      final Vector3d position=new Vector3d(posX,posY,posZ);
      for (      ItemStack drop : drops) {
        final ItemStack item;
        if (drop.getItem() != null) {
          final ItemStackSnapshot snapshot=ItemStackUtil.createSnapshot(drop);
          final List<ItemStackSnapshot> original=new ArrayList<>();
          original.add(snapshot);
          final DropItemEvent.Pre dropEvent=SpongeEventFactory.createDropItemEventPre(Cause.of(NamedCause.source(entity)),ImmutableList.of(snapshot),original);
          if (dropEvent.isCancelled()) {
            continue;
          }
          Transform<World> suggested=new Transform<>(mixinEntity.getWorld(),position);
          SpawnCause cause=EntitySpawnCause.builder().entity(mixinEntity).type(SpawnTypes.DROPPED_ITEM).build();
          ConstructEntityEvent.Pre event=SpongeEventFactory.createConstructEntityEventPre(Cause.of(NamedCause.source(cause)),EntityTypes.ITEM,suggested);
          SpongeImpl.postEvent(event);
          item=event.isCancelled() ? null : ItemStackUtil.fromSnapshotToNative(dropEvent.getDroppedItems().get(0));
        }
 else {
          continue;
        }
        if (item == null) {
          continue;
        }
        if (item.stackSize != 0 && item.getItem() != null) {
          if (!currentState.getPhase().ignoresItemPreMerging(currentState) && SpongeImpl.getGlobalConfig().getConfig().getOptimizations().doDropsPreMergeItemDrops()) {
            if (currentState.tracksEntitySpecificDrops()) {
              final Multimap<UUID,ItemDropData> multimap=phaseContext.getCapturedEntityDropSupplier().get();
              final Collection<ItemDropData> itemStacks=multimap.get(entity.getUniqueID());
              SpongeImplHooks.addItemStackToListForSpawning(itemStacks,ItemDropData.item(item).motion(new Vector3d((random.nextFloat() - random.nextFloat()) * 0.1F,random.nextFloat() * 0.05F,(random.nextFloat() - random.nextFloat()) * 0.1F)).position(new Vector3d(posX,posY,posZ)).build());
              continue;
            }
 else {
              final List<ItemDropData> itemStacks=phaseContext.getCapturedItemStackSupplier().get();
              SpongeImplHooks.addItemStackToListForSpawning(itemStacks,ItemDropData.item(item).position(new Vector3d(posX,posY,posZ)).motion(new Vector3d((random.nextFloat() - random.nextFloat()) * 0.1F,random.nextFloat() * 0.05F,(random.nextFloat() - random.nextFloat()) * 0.1F)).build());
              continue;
            }
          }
          EntityItem entityitem=new EntityItem(entity.worldObj,posX,posY,posZ,item);
          entityitem.setDefaultPickupDelay();
          entityitem.motionY+=random.nextFloat() * 0.05F;
          entityitem.motionX+=(random.nextFloat() - random.nextFloat()) * 0.1F;
          entityitem.motionZ+=(random.nextFloat() - random.nextFloat()) * 0.1F;
          if (currentState.getPhase().doesCaptureEntityDrops(currentState)) {
            if (currentState.tracksEntitySpecificDrops()) {
              phaseContext.getCapturedEntityItemDropSupplier().get().put(entity.getUniqueID(),entityitem);
            }
 else {
              phaseContext.getCapturedItemsSupplier().get().add(entityitem);
            }
            continue;
          }
          entity.worldObj.spawnEntityInWorld(entityitem);
        }
      }
      itemstack.damageItem(1,entity);
    }
    return true;
  }
  return false;
}"
27574,"@Subscribe public void onServerStopped(FMLServerStoppedEvent event) throws IOException {
  try {
    CommandManager service=this.game.getCommandManager();
    service.getCommands().stream().filter(mapping -> mapping.getCallable() instanceof MinecraftCommandWrapper).forEach(service::removeMapping);
    ((SqlServiceImpl)this.game.getServiceManager().provideUnchecked(SqlService.class)).close();
  }
 catch (  Throwable t) {
    this.controller.errorOccurred(this,t);
  }
}","@Subscribe public void onServerStopped(FMLServerStoppedEvent event) throws IOException {
  try {
    CommandManager service=this.game.getCommandManager();
    service.getCommands().stream().filter(mapping -> mapping.getCallable() instanceof MinecraftCommandWrapper).forEach(service::removeMapping);
    ((SqlServiceImpl)this.game.getServiceManager().provideUnchecked(SqlService.class)).close();
  }
 catch (  Throwable t) {
    this.controller.errorOccurred(this,t);
  }
  WorldManager.unregisterAllWorldSettings();
}"
27575,"@Subscribe public void onServerAboutToStart(FMLServerAboutToStartEvent event){
  try {
    ((IMixinServerCommandManager)SpongeImpl.getServer().getCommandManager()).registerEarlyCommands(this.game);
  }
 catch (  Throwable t) {
    this.controller.errorOccurred(this,t);
  }
}","@Subscribe public void onServerAboutToStart(FMLServerAboutToStartEvent event){
  try {
    ((IMixinServerCommandManager)SpongeImpl.getServer().getCommandManager()).registerEarlyCommands(this.game);
  }
 catch (  Throwable t) {
    this.controller.errorOccurred(this,t);
  }
  WorldManager.registerVanillaTypesAndDimensions();
}"
27576,"private boolean isEventAllowed(Event event){
  if (event instanceof BlockEvent.PlaceEvent) {
    return false;
  }
 else   if (event instanceof BlockEvent.BreakEvent) {
    return false;
  }
 else   if (event instanceof PlayerInteractEvent.EntityInteract) {
    return false;
  }
 else   if (event instanceof LivingDropsEvent) {
    return false;
  }
 else   if (event instanceof WorldEvent.Save) {
    return false;
  }
 else   if (event instanceof AttackEntityEvent) {
    return false;
  }
  return true;
}","private boolean isEventAllowed(Event event){
  if (event instanceof BlockEvent.PlaceEvent) {
    return false;
  }
 else   if (event instanceof BlockEvent.BreakEvent) {
    return false;
  }
 else   if (event instanceof PlayerInteractEvent.EntityInteract) {
    return false;
  }
 else   if (event instanceof LivingDropsEvent) {
    return false;
  }
 else   if (event instanceof WorldEvent.Save) {
    return false;
  }
 else   if (event instanceof WorldEvent.Unload) {
    return false;
  }
 else   if (event instanceof AttackEntityEvent) {
    return false;
  }
  return true;
}"
27577,"/** 
 * @author Zidane - June 2nd, 2016
 * @reason Forge's initDimension is very different from Sponge's multi-world. We basically rig it into our system so mods work.
 * @param dim The dimension to load
 */
@Overwrite public static void initDimension(int dim){
  if (WorldManager.getWorldByDimensionId(dim).isPresent()) {
    return;
  }
  if (dim == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final WorldServer worldServer=WorldManager.getWorldByDimensionId(0).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str""));
  final DimensionType dimensionType=WorldManager.getDimensionType(dim).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str""));
  final WorldProvider provider=dimensionType.createDimension();
  WorldProperties properties=WorldManager.getWorldProperties(provider.getSaveFolder()).orElse(null);
  final AnvilSaveHandler saveHandler=new AnvilSaveHandler(getCurrentSaveRootDirectory(),provider.getSaveFolder(),true,SpongeImpl.getServer().getDataFixer());
  if (properties == null) {
    final WorldInfo info=saveHandler.loadWorldInfo();
    final IMixinWorldInfo mixinWorldInfo=(IMixinWorldInfo)info;
    ((IMixinWorldInfo)info).createWorldConfig();
    mixinWorldInfo.setDimensionType((org.spongepowered.api.world.DimensionType)(Object)dimensionType);
    mixinWorldInfo.setDimensionId(dim);
    ((WorldProperties)mixinWorldInfo).setKeepSpawnLoaded(dimensionType.shouldLoadSpawn());
    mixinWorldInfo.getWorldConfig().save();
    WorldManager.setUuidOnProperties(WorldManager.getCurrentSavesDirectory().get(),((WorldProperties)info));
    properties=(WorldProperties)mixinWorldInfo;
    WorldManager.registerWorldProperties(((WorldProperties)mixinWorldInfo));
  }
  final WorldServerMulti worldServerMulti=new WorldServerMulti(SpongeImpl.getServer(),new WorldServerMultiAdapterWorldInfo(saveHandler,(WorldInfo)properties),dim,worldServer,SpongeImpl.getServer().theProfiler);
  WorldManager.forceAddWorld(dim,worldServerMulti);
  Sponge.getEventManager().post(SpongeEventFactory.createLoadWorldEvent(Cause.of(NamedCause.source(SpongeImpl.getServer())),(World)worldServerMulti));
}","/** 
 * @author Zidane - June 2nd, 2016
 * @reason Forge's initDimension is very different from Sponge's multi-world. We basically rig it into our system so mods work.
 * @param dim The dimension to load
 */
@Overwrite public static void initDimension(int dim){
  if (WorldManager.getWorldByDimensionId(dim).isPresent()) {
    return;
  }
  if (dim == 0) {
    throw new RuntimeException(""String_Node_Str"");
  }
  WorldManager.getWorldByDimensionId(0).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str""));
  final DimensionType dimensionType=WorldManager.getDimensionType(dim).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str""));
  final WorldProvider provider=dimensionType.createDimension();
  provider.setDimension(dim);
  String worldFolder=provider.getSaveFolder();
  WorldProperties properties=WorldManager.getWorldProperties(worldFolder).orElse(null);
  if (properties == null) {
    final WorldArchetype.Builder builder=SpongeImpl.getRegistry().createBuilder(WorldArchetype.Builder.class).dimension((org.spongepowered.api.world.DimensionType)(Object)dimensionType).keepsSpawnLoaded(dimensionType.shouldLoadSpawn());
    String modId=SpongeMod.instance.getModIdFromClass(provider.getClass());
    final WorldArchetype archetype=builder.build(modId + ""String_Node_Str"" + dimensionType.getName().toLowerCase(),dimensionType.getName());
    properties=WorldManager.createWorldProperties(worldFolder,archetype);
    ((IMixinWorldInfo)properties).setDimensionId(dim);
  }
  Optional<WorldServer> optWorld=WorldManager.loadWorld(properties);
  if (!optWorld.isPresent()) {
    SpongeImpl.getLogger().error(""String_Node_Str"",properties.getWorldName());
  }
}"
27578,"@Overwrite public static void setWorld(int id,WorldServer world,MinecraftServer server){
  if (world == null) {
    WorldManager.unloadWorld(WorldManager.getWorldByDimensionId(id).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str"")),false,true,true,false);
  }
}","@Overwrite public static void setWorld(int id,WorldServer world,MinecraftServer server){
  if (world != null) {
    WorldManager.forceAddWorld(id,world);
    FMLLog.info(""String_Node_Str"",id,world.getWorldInfo().getWorldName(),world.getMinecraftServer());
  }
 else {
    WorldManager.unloadWorld(WorldManager.getWorldByDimensionId(id).orElseThrow(() -> new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str"")),false,true,true,false);
  }
  WorldManager.reorderWorldsVanillaFirst();
}"
27579,"public SpongeMod() throws Exception {
  super(SpongeMod.createMetadata(ImmutableMap.<String,Object>of(""String_Node_Str"",SpongeImpl.ECOSYSTEM_ID,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  ModContainerFactory.instance().registerContainerType(Type.getType(Plugin.class),SpongeModPluginContainer.class);
  SpongeMod.instance=this;
  this.modFile=SpongeJava6Bridge.modFile;
  Guice.createInjector(new SpongeGuiceModule()).getInstance(SpongeImpl.class);
  this.game=SpongeImpl.getGame();
  SpongeGameData.addRegistryCallback(ForgeRegistries.BLOCKS,(obj,id,location) -> BlockTypeRegistryModule.getInstance().registerFromGameData(ForgeRegistries.BLOCKS.getKey(obj).toString(),(BlockType)obj));
  SpongeGameData.addRegistryCallback(ForgeRegistries.ITEMS,(obj,id,location) -> ItemTypeRegistryModule.getInstance().registerFromGameData(ForgeRegistries.ITEMS.getKey(obj).toString(),(ItemType)obj));
  SpongeGameData.addRegistryCallback(ForgeRegistries.ENCHANTMENTS,(obj,id,location) -> EnchantmentRegistryModule.getInstance().registerFromGameData(ForgeRegistries.ENCHANTMENTS.getKey(obj).toString(),(Enchantment)obj));
  SpongeGameData.addRegistryCallback(ForgeRegistries.POTION_TYPES,(obj,id,location) -> PotionEffectTypeRegistryModule.getInstance().registerFromGameData(ForgeRegistries.POTION_TYPES.getKey(obj).toString(),(PotionEffectType)obj));
  VillagerRegistry.instance();
  this.game.getRegistry().preRegistryInit();
  SpongeForgeModuleRegistry.registerForgeData();
  this.game.getEventManager().registerListeners(this,this);
  RegistryHelper.setFinalStatic(Sponge.class,""String_Node_Str"",this.game);
  SpongeImpl.getInternalPlugins().add((PluginContainer)ForgeModContainer.getInstance());
}","public SpongeMod() throws Exception {
  super(SpongeMod.createMetadata(ImmutableMap.<String,Object>of(""String_Node_Str"",SpongeImpl.ECOSYSTEM_ID,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
  ModContainerFactory.instance().registerContainerType(Type.getType(Plugin.class),SpongeModPluginContainer.class);
  SpongeMod.instance=this;
  this.modFile=SpongeJava6Bridge.modFile;
  Guice.createInjector(new SpongeGuiceModule()).getInstance(SpongeImpl.class);
  this.game=SpongeImpl.getGame();
  SpongeGameData.addRegistryCallback(ForgeRegistries.BLOCKS,(obj,id,location) -> BlockTypeRegistryModule.getInstance().registerFromGameData(ForgeRegistries.BLOCKS.getKey(obj).toString(),(BlockType)obj));
  SpongeGameData.addRegistryCallback(ForgeRegistries.ITEMS,(obj,id,location) -> ItemTypeRegistryModule.getInstance().registerFromGameData(ForgeRegistries.ITEMS.getKey(obj).toString(),(ItemType)obj));
  SpongeGameData.addRegistryCallback(ForgeRegistries.ENCHANTMENTS,(obj,id,location) -> EnchantmentRegistryModule.getInstance().registerFromGameData(ForgeRegistries.ENCHANTMENTS.getKey(obj).toString(),(Enchantment)obj));
  SpongeGameData.addRegistryCallback(ForgeRegistries.POTIONS,(obj,id,location) -> PotionEffectTypeRegistryModule.getInstance().registerFromGameData(ForgeRegistries.POTIONS.getKey(obj).toString(),(PotionEffectType)obj));
  VillagerRegistry.instance();
  RegistryHelper.setFinalStatic(Sponge.class,""String_Node_Str"",this.game);
  this.game.getRegistry().preRegistryInit();
  SpongeForgeModuleRegistry.registerForgeData();
  this.game.getEventManager().registerListeners(this,this);
  SpongeImpl.getInternalPlugins().add((PluginContainer)ForgeModContainer.getInstance());
}"
27580,"@Override protected boolean throwEvent(ICommandSender sender,String[] args) throws InvocationCommandException {
  CommandEvent event=new CommandEvent(this.command,sender,args);
  if (MinecraftForge.EVENT_BUS.post(event)) {
    if (event.exception != null) {
      throw new InvocationCommandException(Text.of(""String_Node_Str""),event.exception);
    }
    return false;
  }
  return super.throwEvent(sender,args);
}","@Override protected boolean throwEvent(ICommandSender sender,String[] args) throws InvocationCommandException {
  CommandEvent event=new CommandEvent(this.command,sender,args);
  if (MinecraftForge.EVENT_BUS.post(event)) {
    if (event.getException() != null) {
      throw new InvocationCommandException(Text.of(""String_Node_Str""),event.getException());
    }
    return false;
  }
  return super.throwEvent(sender,args);
}"
27581,"@Override public Optional<LightEmissionProperty> getFor(Location<World> location){
  net.minecraft.world.World world=(net.minecraft.world.World)location.getExtent();
  Block block=(Block)location.getBlockType();
  final BlockState blockState=location.getBlock();
  return Optional.of(new LightEmissionProperty(block.getLightValue(BlockUtil.toBlockState(blockState),world,VecHelper.toBlockPos(location))));
}","@Override public Optional<LightEmissionProperty> getFor(Location<World> location){
  net.minecraft.world.World world=(net.minecraft.world.World)location.getExtent();
  Block block=(Block)location.getBlockType();
  final BlockState blockState=location.getBlock();
  return Optional.of(new LightEmissionProperty(block.getLightValue(BlockUtil.toNative(blockState),world,VecHelper.toBlockPos(location))));
}"
27582,"@SideOnly(Side.SERVER) @SubscribeEvent public void onChunkWatchEvent(ChunkWatchEvent event){
  IMixinEntity spongeEntity=(IMixinEntity)event.getPlayer();
  if (spongeEntity.isTeleporting()) {
    event.getPlayer().mountEntity(spongeEntity.getTeleportVehicle());
    spongeEntity.setTeleportVehicle(null);
    spongeEntity.setIsTeleporting(false);
  }
}","@SideOnly(Side.SERVER) @SubscribeEvent public void onChunkWatchEvent(ChunkWatchEvent event){
  IMixinEntity spongeEntity=(IMixinEntity)event.getPlayer();
  if (spongeEntity.isTeleporting()) {
    spongeEntity.getTeleportVehicle().getPassengers().add(event.getPlayer());
    spongeEntity.setTeleportVehicle(null);
    spongeEntity.setIsTeleporting(false);
  }
}"
27583,"public static ChangeBlockEvent.Place callBlockPlaceEvent(Event event){
  if (!(event instanceof ChangeBlockEvent.Place)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ChangeBlockEvent.Place spongeEvent=(ChangeBlockEvent.Place)event;
  if (spongeEvent.getCause().first(Player.class).isPresent()) {
    EntityPlayer player=(EntityPlayer)spongeEvent.getCause().first(Player.class).get();
    net.minecraft.world.World world=(net.minecraft.world.World)spongeEvent.getTargetWorld();
    if (spongeEvent.getTransactions().size() == 1) {
      BlockPos pos=VecHelper.toBlockPos(spongeEvent.getTransactions().get(0).getOriginal().getPosition());
      IBlockState state=(IBlockState)spongeEvent.getTransactions().get(0).getOriginal().getState();
      net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
      IBlockState placedAgainst=Blocks.air.getDefaultState();
      if (StaticMixinHelper.packetPlayer != null && StaticMixinHelper.processingPacket instanceof C08PacketPlayerBlockPlacement) {
        C08PacketPlayerBlockPlacement packet=(C08PacketPlayerBlockPlacement)StaticMixinHelper.processingPacket;
        EnumFacing facing=EnumFacing.getFront(packet.getPlacedBlockDirection());
        placedAgainst=blockSnapshot.world.getBlockState(blockSnapshot.pos.offset(facing.getOpposite()));
      }
      BlockEvent.PlaceEvent forgeEvent=new BlockEvent.PlaceEvent(blockSnapshot,placedAgainst,player);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.getTransactions().get(0).setValid(false);
      }
    }
 else {
      Iterator<Transaction<BlockSnapshot>> iterator=spongeEvent.getTransactions().iterator();
      List<net.minecraftforge.common.util.BlockSnapshot> blockSnapshots=new ArrayList<>();
      while (iterator.hasNext()) {
        Transaction<BlockSnapshot> transaction=iterator.next();
        Location<World> location=transaction.getOriginal().getLocation().get();
        IBlockState state=(IBlockState)transaction.getOriginal().getState();
        BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
        net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
        blockSnapshots.add(blockSnapshot);
      }
      IBlockState placedAgainst=Blocks.air.getDefaultState();
      if (StaticMixinHelper.packetPlayer != null && StaticMixinHelper.processingPacket instanceof C08PacketPlayerBlockPlacement) {
        C08PacketPlayerBlockPlacement packet=(C08PacketPlayerBlockPlacement)StaticMixinHelper.processingPacket;
        EnumFacing facing=EnumFacing.getFront(packet.getPlacedBlockDirection());
        placedAgainst=blockSnapshots.get(0).world.getBlockState(blockSnapshots.get(0).pos.offset(facing.getOpposite()));
      }
      BlockEvent.MultiPlaceEvent forgeEvent=new BlockEvent.MultiPlaceEvent(blockSnapshots,placedAgainst,player);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        while (iterator.hasNext()) {
          iterator.next().setValid(false);
        }
      }
    }
  }
  return spongeEvent;
}","public static ChangeBlockEvent.Place callBlockPlaceEvent(Event event){
  if (!(event instanceof ChangeBlockEvent.Place)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ChangeBlockEvent.Place spongeEvent=(ChangeBlockEvent.Place)event;
  if (spongeEvent.getCause().first(Player.class).isPresent()) {
    EntityPlayer player=(EntityPlayer)spongeEvent.getCause().first(Player.class).get();
    net.minecraft.world.World world=(net.minecraft.world.World)spongeEvent.getTargetWorld();
    final CauseTracker causeTracker=((IMixinWorld)world).getCauseTracker();
    if (spongeEvent.getTransactions().size() == 1) {
      BlockPos pos=VecHelper.toBlockPos(spongeEvent.getTransactions().get(0).getOriginal().getPosition());
      IBlockState state=(IBlockState)spongeEvent.getTransactions().get(0).getOriginal().getState();
      net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
      IBlockState placedAgainst=Blocks.air.getDefaultState();
      if (causeTracker.getCurrentPlayerPacket() instanceof C08PacketPlayerBlockPlacement) {
        C08PacketPlayerBlockPlacement packet=(C08PacketPlayerBlockPlacement)causeTracker.getCurrentPlayerPacket();
        EnumFacing facing=EnumFacing.getFront(packet.getPlacedBlockDirection());
        placedAgainst=blockSnapshot.world.getBlockState(blockSnapshot.pos.offset(facing.getOpposite()));
      }
      BlockEvent.PlaceEvent forgeEvent=new BlockEvent.PlaceEvent(blockSnapshot,placedAgainst,player);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        spongeEvent.getTransactions().get(0).setValid(false);
      }
    }
 else {
      Iterator<Transaction<BlockSnapshot>> iterator=spongeEvent.getTransactions().iterator();
      List<net.minecraftforge.common.util.BlockSnapshot> blockSnapshots=new ArrayList<>();
      while (iterator.hasNext()) {
        Transaction<BlockSnapshot> transaction=iterator.next();
        Location<World> location=transaction.getOriginal().getLocation().get();
        IBlockState state=(IBlockState)transaction.getOriginal().getState();
        BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
        net.minecraftforge.common.util.BlockSnapshot blockSnapshot=new net.minecraftforge.common.util.BlockSnapshot(world,pos,state);
        blockSnapshots.add(blockSnapshot);
      }
      IBlockState placedAgainst=Blocks.air.getDefaultState();
      if (causeTracker.getCurrentPlayerPacket() instanceof C08PacketPlayerBlockPlacement) {
        C08PacketPlayerBlockPlacement packet=(C08PacketPlayerBlockPlacement)causeTracker.getCurrentPlayerPacket();
        EnumFacing facing=EnumFacing.getFront(packet.getPlacedBlockDirection());
        placedAgainst=blockSnapshots.get(0).world.getBlockState(blockSnapshots.get(0).pos.offset(facing.getOpposite()));
      }
      BlockEvent.MultiPlaceEvent forgeEvent=new BlockEvent.MultiPlaceEvent(blockSnapshots,placedAgainst,player);
      ((IMixinEventBus)MinecraftForge.EVENT_BUS).post(forgeEvent,true);
      if (forgeEvent.isCanceled()) {
        while (iterator.hasNext()) {
          iterator.next().setValid(false);
        }
      }
    }
  }
  return spongeEvent;
}"
27584,"public boolean post(Event spongeEvent,boolean allowClientThread){
  if (!allowClientThread & SpongeMod.instance.isClientThread()) {
    return false;
  }
  if (spongeEvent.getClass().getInterfaces().length > 0) {
    Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz=this.eventMappings.get(spongeEvent.getClass().getInterfaces()[0]);
    if (clazz == null) {
      clazz=eventBulkMappings.get(spongeEvent.getClass().getInterfaces()[0]);
      if (clazz != null) {
        return postBulk(spongeEvent,clazz);
      }
    }
 else {
      StaticMixinHelper.processingInternalForgeEvent=true;
      net.minecraftforge.fml.common.eventhandler.Event forgeEvent=SpongeForgeEventFactory.findAndCreateForgeEvent(spongeEvent,clazz);
      StaticMixinHelper.processingInternalForgeEvent=false;
      if (forgeEvent != null) {
        Class<?> enclosingClass=forgeEvent.getClass().getEnclosingClass();
        EventBus bus=this.busMappings.get(enclosingClass == null ? forgeEvent.getClass() : enclosingClass);
        if (bus == null) {
          bus=MinecraftForge.EVENT_BUS;
        }
        SpongeForgeEventFactory.lastForgeEvent=forgeEvent;
        return post(spongeEvent,forgeEvent,forgeEvent.getListenerList().getListeners(((IMixinEventBus)bus).getBusID()));
      }
    }
  }
  return post(spongeEvent,getHandlerCache(spongeEvent).getListeners(),false,true);
}","public boolean post(Event spongeEvent,boolean allowClientThread){
  if (!allowClientThread & SpongeMod.instance.isClientThread()) {
    return false;
  }
  if (spongeEvent.getClass().getInterfaces().length > 0) {
    Class<? extends net.minecraftforge.fml.common.eventhandler.Event> clazz=this.eventMappings.get(spongeEvent.getClass().getInterfaces()[0]);
    if (clazz == null) {
      clazz=eventBulkMappings.get(spongeEvent.getClass().getInterfaces()[0]);
      if (clazz != null) {
        return postBulk(spongeEvent,clazz);
      }
    }
 else {
      StaticMixinHelper.processingInternalForgeEvent=true;
      net.minecraftforge.fml.common.eventhandler.Event forgeEvent=SpongeForgeEventFactory.findAndCreateForgeEvent(spongeEvent,clazz);
      StaticMixinHelper.processingInternalForgeEvent=false;
      if (forgeEvent != null) {
        Class<?> enclosingClass=forgeEvent.getClass().getEnclosingClass();
        EventBus bus=this.busMappings.get(enclosingClass == null ? forgeEvent.getClass() : enclosingClass);
        if (bus == null) {
          bus=MinecraftForge.EVENT_BUS;
        }
        return post(spongeEvent,forgeEvent,forgeEvent.getListenerList().getListeners(((IMixinEventBus)bus).getBusID()));
      }
    }
  }
  return post(spongeEvent,getHandlerCache(spongeEvent).getListeners(),false,true);
}"
27585,"@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str"")) public void onConstructed(EntityPlayer player,Action action,BlockPos pos,EnumFacing face,net.minecraft.world.World world,CallbackInfo ci){
  if (player instanceof EntityPlayerMP && !StaticMixinHelper.processingInternalForgeEvent) {
    if (pos != null) {
      this.blockSnapshot=((World)world).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
    }
 else {
      this.blockSnapshot=BlockTypes.AIR.getDefaultState().snapshotFor(new Location<>((World)world,Vector3i.ZERO));
    }
  }
}","@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str"")) public void onConstructed(EntityPlayer player,Action action,BlockPos pos,EnumFacing face,net.minecraft.world.World world,CallbackInfo ci){
  if (player instanceof EntityPlayerMP && !StaticMixinHelper.processingInternalForgeEvent) {
    if (pos != null) {
      this.blockSnapshot=((World)world).createSnapshot(pos.getX(),pos.getY(),pos.getZ());
    }
 else {
      this.blockSnapshot=BlockTypes.AIR.getDefaultState().snapshotFor(new Location<>((World)world,Vector3i.ZERO));
    }
    StaticMixinForgeHelper.lastPlayerInteractCancelled=false;
  }
}"
27586,"@Override public Event createSpongeEvent(){
  if (this.action == Action.LEFT_CLICK_BLOCK) {
    return SpongeEventFactory.createInteractBlockEventPrimary(getCause(),getInteractionPoint(),getTargetBlock(),getTargetSide());
  }
 else {
    return SpongeEventFactory.createInteractBlockEventSecondary(getCause(),getInteractionPoint(),getTargetBlock(),getTargetSide());
  }
}","@Override public Event createSpongeEvent(){
  if (action == Action.LEFT_CLICK_BLOCK) {
    return SpongeEventFactory.createInteractBlockEventSecondary(getCause(),getInteractionPoint(),getTargetBlock(),getTargetSide());
  }
 else   if (action == Action.RIGHT_CLICK_AIR) {
    return SpongeEventFactory.createInteractBlockEventPrimary(getCause(),getInteractionPoint(),getTargetBlock().withState(BlockTypes.AIR.getDefaultState()),getTargetSide());
  }
 else {
    return SpongeEventFactory.createInteractBlockEventSecondary(getCause(),getInteractionPoint(),getTargetBlock(),getTargetSide());
  }
}"
27587,"@Overwrite public static PlayerInteractEvent onPlayerInteract(EntityPlayer player,Action action,net.minecraft.world.World world,BlockPos pos,EnumFacing face){
  if (world.isRemote) {
    PlayerInteractEvent event=new PlayerInteractEvent(player,action,pos,face,world);
    MinecraftForge.EVENT_BUS.post(event);
    return event;
  }
  InteractBlockEvent event=null;
  if (action == Action.LEFT_CLICK_BLOCK) {
    event=SpongeEventFactory.createInteractBlockEventPrimary(Cause.of(NamedCause.source(player)),Optional.empty(),((World)world).createSnapshot(VecHelper.toVector(pos)),face == null ? Direction.NONE : DirectionFacingProvider.getInstance().getKey(face).get());
  }
 else   if (action == Action.RIGHT_CLICK_AIR) {
    event=SpongeEventFactory.createInteractBlockEventSecondary(Cause.of(NamedCause.source(player)),Optional.empty(),((World)world).createSnapshot(VecHelper.toVector(pos)).withState(BlockTypes.AIR.getDefaultState()),face == null ? Direction.NONE : DirectionFacingProvider.getInstance().getKey(face).get());
  }
 else {
    event=SpongeEventFactory.createInteractBlockEventSecondary(Cause.of(NamedCause.source(player)),Optional.empty(),((World)world).createSnapshot(VecHelper.toVector(pos)),face == null ? Direction.NONE : DirectionFacingProvider.getInstance().getKey(face).get());
  }
  SpongeImpl.postEvent(event);
  return (PlayerInteractEvent)SpongeForgeEventFactory.lastForgeEvent;
}","@Overwrite public static PlayerInteractEvent onPlayerInteract(EntityPlayer player,Action action,net.minecraft.world.World world,BlockPos pos,EnumFacing face){
  if (world.isRemote) {
    PlayerInteractEvent event=new PlayerInteractEvent(player,action,pos,face,world);
    MinecraftForge.EVENT_BUS.post(event);
    return event;
  }
  PlayerInteractEvent forgeEvent=new PlayerInteractEvent(player,action,pos,face,world);
  Event spongeEvent=((IMixinEvent)forgeEvent).createSpongeEvent();
  if (((SpongeModEventManager)SpongeImpl.getGame().getEventManager()).post(spongeEvent,forgeEvent,forgeEvent.getListenerList().getListeners(((IMixinEventBus)MinecraftForge.EVENT_BUS).getBusID()))) {
    forgeEvent.setCanceled(true);
  }
  if (forgeEvent.isCanceled()) {
    StaticMixinForgeHelper.lastPlayerInteractCancelled=true;
  }
  return forgeEvent;
}"
27588,"@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) public boolean onActivateBlockOrUseItem(ItemInWorldManager itemManager,EntityPlayer player,net.minecraft.world.World worldIn,ItemStack stack,BlockPos pos,EnumFacing side,float hitX,float hitY,float hitZ){
  boolean result=itemManager.activateBlockOrUseItem(player,worldIn,stack,pos,side,hitX,hitY,hitZ);
  if (stack != null && !result) {
    if (SpongeForgeEventFactory.lastForgeEvent instanceof PlayerInteractEvent && SpongeForgeEventFactory.lastForgeEvent.isCanceled()) {
      return false;
    }
    itemManager.tryUseItem(player,worldIn,stack);
  }
  return result;
}","@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) public boolean onActivateBlockOrUseItem(ItemInWorldManager itemManager,EntityPlayer player,net.minecraft.world.World worldIn,ItemStack stack,BlockPos pos,EnumFacing side,float hitX,float hitY,float hitZ){
  boolean result=itemManager.activateBlockOrUseItem(player,worldIn,stack,pos,side,hitX,hitY,hitZ);
  if (stack != null && !result) {
    if (StaticMixinForgeHelper.lastPlayerInteractCancelled) {
      return false;
    }
    itemManager.tryUseItem(player,worldIn,stack);
  }
  return result;
}"
27589,"@Overwrite public void wakeUpPlayer(boolean immediately,boolean updateWorldFlag,boolean setSpawn){
  IBlockState iblockstate=this.nmsPlayer.worldObj.getBlockState(this.playerLocation);
  Transform<World> newLocation=null;
  if (this.playerLocation != null && iblockstate.getBlock().isBed(this.nmsPlayer.worldObj,this.playerLocation,this.nmsPlayer)) {
    iblockstate.getBlock().setBedOccupied(this.nmsPlayer.worldObj,this.playerLocation,this.nmsPlayer,false);
    BlockPos blockpos=iblockstate.getBlock().getBedSpawnPosition(this.nmsPlayer.worldObj,this.playerLocation,this.nmsPlayer);
    if (blockpos == null) {
      blockpos=this.nmsPlayer.playerLocation.up();
    }
    newLocation=this.getTransform().setPosition(new Vector3d(blockpos.getX() + 0.5F,blockpos.getY() + 0.1F,blockpos.getZ() + 0.5F));
  }
  SleepingEvent.Post post=null;
  if (!this.nmsPlayer.worldObj.isRemote) {
    post=SpongeEventFactory.createSleepingEventPost(Sponge.getGame(),Cause.of(NamedCause.source(this)),this.getWorld().createSnapshot(VecHelper.toVector(this.playerLocation)),Optional.ofNullable(newLocation),this,setSpawn);
    Sponge.getEventManager().post(post);
    if (post.isCancelled()) {
      return;
    }
    net.minecraftforge.event.ForgeEventFactory.onPlayerWakeup(this.nmsPlayer,immediately,updateWorldFlag,setSpawn);
    this.setSize(0.6F,1.8F);
    if (post.getSpawnTransform().isPresent()) {
      this.setTransform(post.getSpawnTransform().get());
    }
  }
  this.sleeping=false;
  if (!this.nmsPlayer.worldObj.isRemote && updateWorldFlag) {
    this.nmsPlayer.worldObj.updateAllPlayersSleepingFlag();
  }
  this.sleepTimer=immediately ? 0 : 100;
  if (post != null) {
    if (setSpawn) {
      this.setSpawnPoint(post.getSpawnTransform().isPresent() ? VecHelper.toBlockPos(post.getSpawnTransform().get().getPosition()) : this.playerLocation,false);
    }
    Sponge.getGame().getEventManager().post(SpongeEventFactory.createSleepingEventFinish(Sponge.getGame(),post.getCause(),this.getWorld().createSnapshot(VecHelper.toVector(this.playerLocation)),this));
  }
 else {
    if (setSpawn) {
      this.setSpawnPoint(this.playerLocation,false);
    }
  }
}","@Overwrite public void wakeUpPlayer(boolean immediately,boolean updateWorldFlag,boolean setSpawn){
  IBlockState iblockstate=this.nmsPlayer.worldObj.getBlockState(this.playerLocation);
  Transform<World> newLocation=null;
  if (this.playerLocation != null && iblockstate.getBlock().isBed(this.nmsPlayer.worldObj,this.playerLocation,this.nmsPlayer)) {
    iblockstate.getBlock().setBedOccupied(this.nmsPlayer.worldObj,this.playerLocation,this.nmsPlayer,false);
    BlockPos blockpos=iblockstate.getBlock().getBedSpawnPosition(this.nmsPlayer.worldObj,this.playerLocation,this.nmsPlayer);
    if (blockpos == null) {
      blockpos=this.nmsPlayer.playerLocation.up();
    }
    newLocation=this.getTransform().setPosition(new Vector3d(blockpos.getX() + 0.5F,blockpos.getY() + 0.1F,blockpos.getZ() + 0.5F));
  }
  SleepingEvent.Post post=null;
  if (!this.nmsPlayer.worldObj.isRemote) {
    post=SpongeEventFactory.createSleepingEventPost(Sponge.getGame(),Cause.of(NamedCause.source(this)),this.getWorld().createSnapshot(VecHelper.toVector(this.playerLocation)),Optional.ofNullable(newLocation),this,setSpawn);
    Sponge.getEventManager().post(post);
    if (post.isCancelled()) {
      return;
    }
    net.minecraftforge.event.ForgeEventFactory.onPlayerWakeup(this.nmsPlayer,immediately,updateWorldFlag,setSpawn);
    this.setSize(0.6F,1.8F);
    if (post.getSpawnTransform().isPresent()) {
      this.setTransform(post.getSpawnTransform().get());
    }
  }
 else {
    net.minecraftforge.event.ForgeEventFactory.onPlayerWakeup(this.nmsPlayer,immediately,updateWorldFlag,setSpawn);
    this.setSize(0.6F,1.8F);
  }
  this.sleeping=false;
  if (!this.nmsPlayer.worldObj.isRemote && updateWorldFlag) {
    this.nmsPlayer.worldObj.updateAllPlayersSleepingFlag();
  }
  this.sleepTimer=immediately ? 0 : 100;
  if (post != null) {
    if (setSpawn) {
      this.setSpawnPoint(post.getSpawnTransform().isPresent() ? VecHelper.toBlockPos(post.getSpawnTransform().get().getPosition()) : this.playerLocation,false);
    }
    Sponge.getGame().getEventManager().post(SpongeEventFactory.createSleepingEventFinish(Sponge.getGame(),post.getCause(),this.getWorld().createSnapshot(VecHelper.toVector(this.playerLocation)),this));
  }
 else {
    if (setSpawn) {
      this.setSpawnPoint(this.playerLocation,false);
    }
  }
}"
27590,"/** 
 * @author bloodmc - November 15th, 2015Purpose: Sends a packet to server requesting block tracking data. If player has permission, the block owner and notifier data will be  received and displayed on debug screen.
 */
@Overwrite protected List<String> call(){
  BlockPos blockpos=new BlockPos(this.mc.getRenderViewEntity().posX,this.mc.getRenderViewEntity().getEntityBoundingBox().minY,this.mc.getRenderViewEntity().posZ);
  if (this.isReducedDebug()) {
    return Lists.newArrayList(new String[]{""String_Node_Str"" + this.mc.getVersion() + ""String_Node_Str""+ ClientBrandRetriever.getClientModName()+ ""String_Node_Str"",this.mc.debug,this.mc.renderGlobal.getDebugInfoRenders(),this.mc.renderGlobal.getDebugInfoEntities(),""String_Node_Str"" + this.mc.effectRenderer.getStatistics() + ""String_Node_Str""+ this.mc.theWorld.getDebugLoadedEntities(),this.mc.theWorld.getProviderName(),""String_Node_Str"",String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos.getX() & 15),Integer.valueOf(blockpos.getY() & 15),Integer.valueOf(blockpos.getZ() & 15)})});
  }
 else {
    Entity entity=this.mc.getRenderViewEntity();
    EnumFacing enumfacing=entity.getHorizontalFacing();
    String s=""String_Node_Str"";
switch (enumfacing.ordinal() + 1) {
case 1:
      s=""String_Node_Str"";
    break;
case 2:
  s=""String_Node_Str"";
break;
case 3:
s=""String_Node_Str"";
break;
case 4:
s=""String_Node_Str"";
}
ArrayList<String> arraylist=Lists.newArrayList(new String[]{""String_Node_Str"" + this.mc.getVersion() + ""String_Node_Str""+ ClientBrandRetriever.getClientModName()+ ""String_Node_Str"",this.mc.debug,this.mc.renderGlobal.getDebugInfoRenders(),this.mc.renderGlobal.getDebugInfoEntities(),""String_Node_Str"" + this.mc.effectRenderer.getStatistics() + ""String_Node_Str""+ this.mc.theWorld.getDebugLoadedEntities(),this.mc.theWorld.getProviderName(),""String_Node_Str"",String.format(""String_Node_Str"",new Object[]{Double.valueOf(this.mc.getRenderViewEntity().posX),Double.valueOf(this.mc.getRenderViewEntity().getEntityBoundingBox().minY),Double.valueOf(this.mc.getRenderViewEntity().posZ)}),String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos.getX()),Integer.valueOf(blockpos.getY()),Integer.valueOf(blockpos.getZ())}),String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos.getX() & 15),Integer.valueOf(blockpos.getY() & 15),Integer.valueOf(blockpos.getZ() & 15),Integer.valueOf(blockpos.getX() >> 4),Integer.valueOf(blockpos.getY() >> 4),Integer.valueOf(blockpos.getZ() >> 4)}),String.format(""String_Node_Str"",new Object[]{enumfacing,s,Float.valueOf(MathHelper.wrapAngleTo180_float(entity.rotationYaw)),Float.valueOf(MathHelper.wrapAngleTo180_float(entity.rotationPitch))})});
if (this.mc.theWorld != null && this.mc.theWorld.isBlockLoaded(blockpos)) {
Chunk chunk=this.mc.theWorld.getChunkFromBlockCoords(blockpos);
arraylist.add(""String_Node_Str"" + chunk.getBiome(blockpos,this.mc.theWorld.getWorldChunkManager()).biomeName);
arraylist.add(""String_Node_Str"" + chunk.getLightSubtracted(blockpos,0) + ""String_Node_Str""+ chunk.getLightFor(EnumSkyBlock.SKY,blockpos)+ ""String_Node_Str""+ chunk.getLightFor(EnumSkyBlock.BLOCK,blockpos)+ ""String_Node_Str"");
DifficultyInstance difficultyinstance=this.mc.theWorld.getDifficultyForLocation(blockpos);
if (this.mc.isIntegratedServerRunning() && this.mc.getIntegratedServer() != null) {
EntityPlayerMP entityplayermp=this.mc.getIntegratedServer().getConfigurationManager().getPlayerByUUID(this.mc.thePlayer.getUniqueID());
if (entityplayermp != null) {
difficultyinstance=entityplayermp.worldObj.getDifficultyForLocation(new BlockPos(entityplayermp));
}
}
arraylist.add(String.format(""String_Node_Str"",new Object[]{Float.valueOf(difficultyinstance.getAdditionalDifficulty()),Long.valueOf(this.mc.theWorld.getWorldTime() / 24000L)}));
}
if (this.mc.entityRenderer != null && this.mc.entityRenderer.isShaderActive()) {
arraylist.add(""String_Node_Str"" + this.mc.entityRenderer.getShaderGroup().getShaderGroupName());
}
if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && this.mc.objectMouseOver.getBlockPos() != null) {
BlockPos blockpos1=this.mc.objectMouseOver.getBlockPos();
arraylist.add(String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos1.getX()),Integer.valueOf(blockpos1.getY()),Integer.valueOf(blockpos1.getZ())}));
if (!this.mc.objectMouseOver.getBlockPos().equals(this.cursorPos)) {
SpongeModMessageHandler.INSTANCE.sendToServer(new MessageTrackerDataRequest(0,-1,blockpos1.getX(),blockpos1.getY(),blockpos1.getZ()));
}
arraylist.add(""String_Node_Str"" + this.blockOwner);
arraylist.add(""String_Node_Str"" + this.blockNotifier);
this.cursorPos=this.mc.objectMouseOver.getBlockPos();
}
 else if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY) {
Entity target=this.mc.objectMouseOver.entityHit;
BlockPos blockPos=target.getPosition();
if (!blockPos.equals(this.cursorPos)) {
SpongeModMessageHandler.INSTANCE.sendToServer(new MessageTrackerDataRequest(1,target.getEntityId(),blockPos.getX(),blockPos.getY(),blockPos.getZ()));
}
arraylist.add(""String_Node_Str"" + this.blockOwner);
arraylist.add(""String_Node_Str"" + this.blockNotifier);
this.cursorPos=blockPos;
}
return arraylist;
}
}","/** 
 * @author bloodmc - November 15th, 2015Purpose: Sends a packet to server requesting block tracking data. If player has permission, the block owner and notifier data will be  received and displayed on debug screen.
 */
@Overwrite protected List<String> call(){
  BlockPos blockpos=new BlockPos(this.mc.getRenderViewEntity().posX,this.mc.getRenderViewEntity().getEntityBoundingBox().minY,this.mc.getRenderViewEntity().posZ);
  if (this.isReducedDebug()) {
    return Lists.newArrayList(new String[]{""String_Node_Str"" + this.mc.getVersion() + ""String_Node_Str""+ ClientBrandRetriever.getClientModName()+ ""String_Node_Str"",this.mc.debug,this.mc.renderGlobal.getDebugInfoRenders(),this.mc.renderGlobal.getDebugInfoEntities(),""String_Node_Str"" + this.mc.effectRenderer.getStatistics() + ""String_Node_Str""+ this.mc.theWorld.getDebugLoadedEntities(),this.mc.theWorld.getProviderName(),""String_Node_Str"",String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos.getX() & 15),Integer.valueOf(blockpos.getY() & 15),Integer.valueOf(blockpos.getZ() & 15)})});
  }
 else {
    Entity entity=this.mc.getRenderViewEntity();
    EnumFacing enumfacing=entity.getHorizontalFacing();
    String s=""String_Node_Str"";
switch (enumfacing.ordinal() - 1) {
case 1:
      s=""String_Node_Str"";
    break;
case 2:
  s=""String_Node_Str"";
break;
case 3:
s=""String_Node_Str"";
break;
case 4:
s=""String_Node_Str"";
}
ArrayList<String> arraylist=Lists.newArrayList(new String[]{""String_Node_Str"" + this.mc.getVersion() + ""String_Node_Str""+ ClientBrandRetriever.getClientModName()+ ""String_Node_Str"",this.mc.debug,this.mc.renderGlobal.getDebugInfoRenders(),this.mc.renderGlobal.getDebugInfoEntities(),""String_Node_Str"" + this.mc.effectRenderer.getStatistics() + ""String_Node_Str""+ this.mc.theWorld.getDebugLoadedEntities(),this.mc.theWorld.getProviderName(),""String_Node_Str"",String.format(""String_Node_Str"",new Object[]{Double.valueOf(this.mc.getRenderViewEntity().posX),Double.valueOf(this.mc.getRenderViewEntity().getEntityBoundingBox().minY),Double.valueOf(this.mc.getRenderViewEntity().posZ)}),String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos.getX()),Integer.valueOf(blockpos.getY()),Integer.valueOf(blockpos.getZ())}),String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos.getX() & 15),Integer.valueOf(blockpos.getY() & 15),Integer.valueOf(blockpos.getZ() & 15),Integer.valueOf(blockpos.getX() >> 4),Integer.valueOf(blockpos.getY() >> 4),Integer.valueOf(blockpos.getZ() >> 4)}),String.format(""String_Node_Str"",new Object[]{enumfacing,s,Float.valueOf(MathHelper.wrapAngleTo180_float(entity.rotationYaw)),Float.valueOf(MathHelper.wrapAngleTo180_float(entity.rotationPitch))})});
if (this.mc.theWorld != null && this.mc.theWorld.isBlockLoaded(blockpos)) {
Chunk chunk=this.mc.theWorld.getChunkFromBlockCoords(blockpos);
arraylist.add(""String_Node_Str"" + chunk.getBiome(blockpos,this.mc.theWorld.getWorldChunkManager()).biomeName);
arraylist.add(""String_Node_Str"" + chunk.getLightSubtracted(blockpos,0) + ""String_Node_Str""+ chunk.getLightFor(EnumSkyBlock.SKY,blockpos)+ ""String_Node_Str""+ chunk.getLightFor(EnumSkyBlock.BLOCK,blockpos)+ ""String_Node_Str"");
DifficultyInstance difficultyinstance=this.mc.theWorld.getDifficultyForLocation(blockpos);
if (this.mc.isIntegratedServerRunning() && this.mc.getIntegratedServer() != null) {
EntityPlayerMP entityplayermp=this.mc.getIntegratedServer().getConfigurationManager().getPlayerByUUID(this.mc.thePlayer.getUniqueID());
if (entityplayermp != null) {
difficultyinstance=entityplayermp.worldObj.getDifficultyForLocation(new BlockPos(entityplayermp));
}
}
arraylist.add(String.format(""String_Node_Str"",new Object[]{Float.valueOf(difficultyinstance.getAdditionalDifficulty()),Long.valueOf(this.mc.theWorld.getWorldTime() / 24000L)}));
}
if (this.mc.entityRenderer != null && this.mc.entityRenderer.isShaderActive()) {
arraylist.add(""String_Node_Str"" + this.mc.entityRenderer.getShaderGroup().getShaderGroupName());
}
if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.BLOCK && this.mc.objectMouseOver.getBlockPos() != null) {
BlockPos blockpos1=this.mc.objectMouseOver.getBlockPos();
arraylist.add(String.format(""String_Node_Str"",new Object[]{Integer.valueOf(blockpos1.getX()),Integer.valueOf(blockpos1.getY()),Integer.valueOf(blockpos1.getZ())}));
if (!this.mc.objectMouseOver.getBlockPos().equals(this.cursorPos)) {
SpongeModMessageHandler.INSTANCE.sendToServer(new MessageTrackerDataRequest(0,-1,blockpos1.getX(),blockpos1.getY(),blockpos1.getZ()));
}
arraylist.add(""String_Node_Str"" + this.blockOwner);
arraylist.add(""String_Node_Str"" + this.blockNotifier);
this.cursorPos=this.mc.objectMouseOver.getBlockPos();
}
 else if (this.mc.objectMouseOver != null && this.mc.objectMouseOver.typeOfHit == MovingObjectPosition.MovingObjectType.ENTITY) {
Entity target=this.mc.objectMouseOver.entityHit;
BlockPos blockPos=target.getPosition();
if (!blockPos.equals(this.cursorPos)) {
SpongeModMessageHandler.INSTANCE.sendToServer(new MessageTrackerDataRequest(1,target.getEntityId(),blockPos.getX(),blockPos.getY(),blockPos.getZ()));
}
arraylist.add(""String_Node_Str"" + this.blockOwner);
arraylist.add(""String_Node_Str"" + this.blockNotifier);
this.cursorPos=blockPos;
}
return arraylist;
}
}"
27591,"@Inject public SpongeModGame(Platform platform,PluginManager pluginManager,EventManager eventManager,SpongeGameRegistry gameRegistry,ServiceManager serviceManager,TeleportHelper teleportHelper){
  super(platform,pluginManager,eventManager,gameRegistry,serviceManager,teleportHelper);
}","@Inject public SpongeModGame(Platform platform,PluginManager pluginManager,EventManager eventManager,SpongeGameRegistry gameRegistry,ServiceManager serviceManager,TeleportHelper teleportHelper,Logger logger){
  super(platform,pluginManager,eventManager,gameRegistry,serviceManager,teleportHelper,logger);
}"
27592,"public SpongeCoremod(){
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  MixinBootstrap.init();
  MixinEnvironment.getEnvironment(Phase.PREINIT).addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  SpongeLaunch.initialize(null,null,null);
  Sponge.getGlobalConfig();
  MixinEnvironment.getDefaultEnvironment().addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
}","public SpongeCoremod(){
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  MixinBootstrap.init();
  MixinEnvironment.getEnvironment(Phase.PREINIT).addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  SpongeLaunch.initialize(null,null,null);
  Sponge.getGlobalConfig();
  MixinEnvironment.getDefaultEnvironment().addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
}"
27593,"public SpongeCoremod(){
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  MixinBootstrap.init();
  MixinEnvironment.getEnvironment(Phase.PREINIT).addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  SpongeLaunch.initialize(null,null,null);
  Sponge.getGlobalConfig();
  MixinEnvironment.getDefaultEnvironment().addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
}","public SpongeCoremod(){
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  MixinBootstrap.init();
  MixinEnvironment.getEnvironment(Phase.PREINIT).addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  SpongeLaunch.initialize(null,null,null);
  Sponge.getGlobalConfig();
  MixinEnvironment.getDefaultEnvironment().addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").addConfiguration(""String_Node_Str"").registerTokenProviderClass(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addClassLoaderExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
  Launch.classLoader.addTransformerExclusion(""String_Node_Str"");
}"
27594,"@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"")) public PlayerInteractEvent onFirePlayerInteractEvent(EntityPlayer player,PlayerInteractEvent.Action action,World world,BlockPos pos,EnumFacing face){
  PlayerInteractEvent event=new PlayerInteractEvent(playerEntity,PlayerInteractEvent.Action.RIGHT_CLICK_AIR,new BlockPos(0,0,0),null,world);
  double reach=this.playerEntity.theItemInWorldManager.getGameType() == WorldSettings.GameType.CREATIVE ? 5 : 4.5;
  Optional<BlockRayHit> attempt=BlockRay.from((Player)this.playerEntity).filter(BlockRay.maxDistanceFilter(((Player)this.playerEntity).getLocation().getPosition(),reach)).end();
  boolean missed;
  if (attempt.isPresent()) {
    BlockRayHit hit=attempt.get();
    missed=hit.getExtent().getBlockType(hit.getBlockPosition()).equals(BlockTypes.AIR);
  }
 else {
    missed=true;
  }
  if (missed) {
    MinecraftForge.EVENT_BUS.post(event);
  }
 else {
    event.useItem=Event.Result.DEFAULT;
  }
  return event;
}","@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),remap=false) public PlayerInteractEvent onFirePlayerInteractEvent(EntityPlayer player,PlayerInteractEvent.Action action,World world,BlockPos pos,EnumFacing face){
  PlayerInteractEvent event=new PlayerInteractEvent(playerEntity,PlayerInteractEvent.Action.RIGHT_CLICK_AIR,new BlockPos(0,0,0),null,world);
  double reach=this.playerEntity.theItemInWorldManager.getGameType() == WorldSettings.GameType.CREATIVE ? 5 : 4.5;
  Optional<BlockRayHit> attempt=BlockRay.from((Player)this.playerEntity).filter(BlockRay.maxDistanceFilter(((Player)this.playerEntity).getLocation().getPosition(),reach)).end();
  boolean missed;
  if (attempt.isPresent()) {
    BlockRayHit hit=attempt.get();
    missed=hit.getExtent().getBlockType(hit.getBlockPosition()).equals(BlockTypes.AIR);
  }
 else {
    missed=true;
  }
  if (missed) {
    MinecraftForge.EVENT_BUS.post(event);
  }
 else {
    event.useItem=Event.Result.DEFAULT;
  }
  return event;
}"
27595,"private static NeighborNotifyEvent fromSpongeEvent(BlockUpdateEvent blockUpdateEvent){
  Location location=blockUpdateEvent.getBlock();
  SpongeGameRegistry registry=Sponge.getSpongeRegistry();
  EnumSet<EnumFacing> facings=EnumSet.noneOf(EnumFacing.class);
  for (  Direction direction : Direction.values()) {
    if ((direction.isCardinal() || direction == Direction.UP || direction == Direction.DOWN) && blockUpdateEvent.getAffectedBlocks().contains(location.getRelative(direction))) {
      facings.add(registry.directionMap.get(direction));
    }
  }
  NeighborNotifyEvent event=new NeighborNotifyEvent((World)(Object)blockUpdateEvent.getBlock().getExtent(),new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ()),(IBlockState)(Object)blockUpdateEvent.getBlock().getExtent().getBlock(blockUpdateEvent.getBlock().getBlockPosition()),facings);
  ((IMixinEvent)event).setSpongeEvent(blockUpdateEvent);
  return event;
}","@SuppressWarnings(""String_Node_Str"") private static NeighborNotifyEvent fromSpongeEvent(BlockUpdateEvent blockUpdateEvent){
  Location location=blockUpdateEvent.getBlock();
  EnumSet<EnumFacing> facings=EnumSet.noneOf(EnumFacing.class);
  for (  Direction direction : Direction.values()) {
    if ((direction.isCardinal() || direction == Direction.UP || direction == Direction.DOWN) && blockUpdateEvent.getAffectedBlocks().contains(location.getRelative(direction))) {
      facings.add(SpongeGameRegistry.directionMap.get(direction));
    }
  }
  NeighborNotifyEvent event=new NeighborNotifyEvent((World)(Object)blockUpdateEvent.getBlock().getExtent(),new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ()),(IBlockState)(Object)blockUpdateEvent.getBlock().getExtent().getBlock(blockUpdateEvent.getBlock().getBlockPosition()),facings);
  ((IMixinEvent)event).setSpongeEvent(blockUpdateEvent);
  return event;
}"
27596,"private static ServerChatEvent fromSpongeEvent(PlayerChatEvent spongeEvent){
  IChatComponent component=SpongeTexts.toComponent(spongeEvent.getMessage(),spongeEvent.getEntity().getLocale());
  if (!(component instanceof ChatComponentTranslation)) {
    component=new ChatComponentTranslation(""String_Node_Str"",component);
  }
  ServerChatEvent event=new ServerChatEvent((EntityPlayerMP)spongeEvent.getEntity(),Texts.toPlain(spongeEvent.getMessage()),(ChatComponentTranslation)component);
  ((IMixinEvent)event).setSpongeEvent(spongeEvent);
  return event;
}","@SuppressWarnings(""String_Node_Str"") private static ServerChatEvent fromSpongeEvent(PlayerChatEvent spongeEvent){
  IChatComponent component=SpongeTexts.toComponent(spongeEvent.getMessage(),spongeEvent.getEntity().getLocale());
  if (!(component instanceof ChatComponentTranslation)) {
    component=new ChatComponentTranslation(""String_Node_Str"",component);
  }
  ServerChatEvent event=new ServerChatEvent((EntityPlayerMP)spongeEvent.getEntity(),Texts.toPlain(spongeEvent.getMessage()),(ChatComponentTranslation)component);
  ((IMixinEvent)event).setSpongeEvent(spongeEvent);
  return event;
}"
27597,"private static PlayerInteractEvent fromSpongeEvent(PlayerInteractBlockEvent spongeEvent){
  Action action=actionFromSponge(spongeEvent.getInteractionType(),spongeEvent.getBlock().getBlockType());
  BlockPos pos=VecHelper.toBlockPos(spongeEvent.getBlock().getPosition());
  EnumFacing face=Sponge.getSpongeRegistry().directionMap.get(spongeEvent.getSide());
  PlayerInteractEvent event=new PlayerInteractEvent((EntityPlayer)spongeEvent.getEntity(),action,pos,face,(World)spongeEvent.getEntity().getWorld());
  ((IMixinEvent)event).setSpongeEvent(spongeEvent);
  return event;
}","@SuppressWarnings(""String_Node_Str"") private static PlayerInteractEvent fromSpongeEvent(PlayerInteractBlockEvent spongeEvent){
  Action action=actionFromSponge(spongeEvent.getInteractionType(),spongeEvent.getBlock().getBlockType());
  BlockPos pos=VecHelper.toBlockPos(spongeEvent.getBlock().getPosition());
  EnumFacing face=SpongeGameRegistry.directionMap.get(spongeEvent.getSide());
  PlayerInteractEvent event=new PlayerInteractEvent((EntityPlayer)spongeEvent.getEntity(),action,pos,face,(World)spongeEvent.getEntity().getWorld());
  ((IMixinEvent)event).setSpongeEvent(spongeEvent);
  return event;
}"
27598,"@Override public Direction getSide(){
  if (this.face != null) {
    return ((SpongeGameRegistry)Sponge.getGame().getRegistry()).directionMap.inverse().get(this.face);
  }
  return Direction.NONE;
}","@Override public Direction getSide(){
  if (this.face != null) {
    return SpongeGameRegistry.directionMap.inverse().get(this.face);
  }
  return Direction.NONE;
}"
27599,"private static BlockEvent.PlaceEvent fromSpongeEvent(PlayerPlaceBlockEvent spongeEvent){
  Location location=spongeEvent.getBlock();
  World world=(World)spongeEvent.getBlock().getExtent();
  BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
  BlockEvent.PlaceEvent event=new BlockEvent.PlaceEvent((net.minecraftforge.common.util.BlockSnapshot)spongeEvent.getReplacementBlock(),world.getBlockState(pos),(EntityPlayer)spongeEvent.getEntity());
  ((IMixinEvent)event).setSpongeEvent(spongeEvent);
  return event;
}","@SuppressWarnings(""String_Node_Str"") private static BlockEvent.PlaceEvent fromSpongeEvent(PlayerPlaceBlockEvent spongeEvent){
  Location location=spongeEvent.getBlock();
  World world=(World)spongeEvent.getBlock().getExtent();
  BlockPos pos=new BlockPos(location.getBlockX(),location.getBlockY(),location.getBlockZ());
  BlockEvent.PlaceEvent event=new BlockEvent.PlaceEvent((net.minecraftforge.common.util.BlockSnapshot)spongeEvent.getReplacementBlock(),world.getBlockState(pos),(EntityPlayer)spongeEvent.getEntity());
  ((IMixinEvent)event).setSpongeEvent(spongeEvent);
  return event;
}"
27600,"@Override public boolean isCancelled(){
  if (spongeEvent instanceof Cancellable) {
    return ((Cancellable)spongeEvent).isCancelled();
  }
  return isCanceled();
}","@Override public boolean isCancelled(){
  if (this.spongeEvent instanceof Cancellable) {
    return ((Cancellable)this.spongeEvent).isCancelled();
  }
  return isCanceled();
}"
27601,"@Override public void setCancelled(boolean cancel){
  if (spongeEvent instanceof Cancellable) {
    ((Cancellable)spongeEvent).setCancelled(cancel);
  }
  setCanceled(cancel);
}","@Override public void setCancelled(boolean cancel){
  if (this.spongeEvent instanceof Cancellable) {
    ((Cancellable)this.spongeEvent).setCancelled(cancel);
  }
  setCanceled(cancel);
}"
27602,"public static void addEntityToConfig(World world,SpongeEntityType type,byte activationType){
  Preconditions.checkNotNull(world,""String_Node_Str"");
  Preconditions.checkNotNull(type,""String_Node_Str"");
  List<SpongeConfig<?>> configs=new ArrayList<SpongeConfig<?>>();
  configs.add(Sponge.getGlobalConfig());
  configs.add(((IMixinWorldProvider)world.provider).getDimensionConfig());
  configs.add(((IMixinWorld)world).getWorldConfig());
  Preconditions.checkNotNull(configs.get(0),""String_Node_Str"");
  Preconditions.checkNotNull(configs.get(1),""String_Node_Str"");
  Preconditions.checkNotNull(configs.get(2),""String_Node_Str"");
  String entityType=""String_Node_Str"";
  if (activationType == 1) {
    entityType=""String_Node_Str"";
  }
 else   if (activationType == 2) {
    entityType=""String_Node_Str"";
  }
 else   if (activationType == 3) {
    entityType=""String_Node_Str"";
  }
 else   if (activationType == 4) {
    entityType=""String_Node_Str"";
  }
  for (  SpongeConfig<?> config : configs) {
    if (config == null)     continue;
    if (config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId()).isVirtual()) {
      config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId(),""String_Node_Str"").setValue(true);
    }
    if (config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId(),entityType,type.getEntityName()).isVirtual()) {
      config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId(),entityType,type.getEntityName()).setValue(true);
      config.save();
    }
  }
}","public static void addEntityToConfig(World world,SpongeEntityType type,byte activationType){
  checkNotNull(world,""String_Node_Str"");
  checkNotNull(type,""String_Node_Str"");
  List<SpongeConfig<?>> configs=new ArrayList<SpongeConfig<?>>();
  configs.add(Sponge.getGlobalConfig());
  configs.add(((IMixinWorldProvider)world.provider).getDimensionConfig());
  configs.add(((IMixinWorld)world).getWorldConfig());
  checkNotNull(configs.get(0),""String_Node_Str"");
  checkNotNull(configs.get(1),""String_Node_Str"");
  checkNotNull(configs.get(2),""String_Node_Str"");
  String entityType=""String_Node_Str"";
  if (activationType == 1) {
    entityType=""String_Node_Str"";
  }
 else   if (activationType == 2) {
    entityType=""String_Node_Str"";
  }
 else   if (activationType == 3) {
    entityType=""String_Node_Str"";
  }
 else   if (activationType == 4) {
    entityType=""String_Node_Str"";
  }
  for (  SpongeConfig<?> config : configs) {
    if (config == null)     continue;
    if (config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId()).isVirtual()) {
      config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId(),""String_Node_Str"").setValue(true);
    }
    if (config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId(),entityType,type.getEntityName()).isVirtual()) {
      config.getRootNode().getNode(SpongeConfig.MODULE_ENTITY_ACTIVATION_RANGE,type.getModId(),entityType,type.getEntityName()).setValue(true);
      config.save();
    }
  }
}"
27603,@Shadow public abstract int getAverageGroundLevel();,"public int getAverageGroundLevel(){
  if (((GeneratorType)this.terrainType).equals(GeneratorTypes.END)) {
    return 50;
  }
 else {
    return this.terrainType.getMinimumSpawnHeight(this.worldObj);
  }
}"
27604,@Shadow public abstract boolean getHasNoSky();,"public boolean getHasNoSky(){
  if (((GeneratorType)this.terrainType).equals(GeneratorTypes.NETHER)) {
    return true;
  }
 else {
    return this.hasNoSky;
  }
}"
27605,"@Override public String getName(){
  return name;
}","@Override public String getName(){
  return this.name;
}"
27606,"@Override public String getId(){
  return name;
}","@Override public String getId(){
  return this.name;
}"
27607,"protected void prepareSpawnArea(WorldServer world){
  int i=0;
  this.setUserMessage(""String_Node_Str"");
  MinecraftServer.getServer().logInfo(""String_Node_Str"" + world.provider.getDimensionId());
  BlockPos blockpos=world.getSpawnPoint();
  long j=MinecraftServer.getCurrentTimeMillis();
  for (int k=-192; k <= 192 && this.isServerRunning(); k+=16) {
    for (int l=-192; l <= 192 && this.isServerRunning(); l+=16) {
      long i1=MinecraftServer.getCurrentTimeMillis();
      if (i1 - j > 1000L) {
        this.outputPercentRemaining(""String_Node_Str"",i * 100 / 625);
        j=i1;
      }
      ++i;
      world.theChunkProviderServer.loadChunk(blockpos.getX() + k >> 4,blockpos.getZ() + l >> 4);
    }
  }
  this.clearCurrentTask();
}","protected void prepareSpawnArea(WorldServer world){
  int i=0;
  this.setUserMessage(""String_Node_Str"");
  logger.info(""String_Node_Str"" + world.provider.getDimensionId());
  BlockPos blockpos=world.getSpawnPoint();
  long j=MinecraftServer.getCurrentTimeMillis();
  for (int k=-192; k <= 192 && this.isServerRunning(); k+=16) {
    for (int l=-192; l <= 192 && this.isServerRunning(); l+=16) {
      long i1=MinecraftServer.getCurrentTimeMillis();
      if (i1 - j > 1000L) {
        this.outputPercentRemaining(""String_Node_Str"",i * 100 / 625);
        j=i1;
      }
      ++i;
      world.theChunkProviderServer.loadChunk(blockpos.getX() + k >> 4,blockpos.getZ() + l >> 4);
    }
  }
  this.clearCurrentTask();
}"
27608,"@Override public Optional<WorldProperties> createWorld(WorldCreationSettings settings){
  String worldName=settings.getWorldName();
  final Optional<World> optExisting=getWorld(worldName);
  if (optExisting.isPresent()) {
    return Optional.of(optExisting.get().getProperties());
  }
  int dim;
  AnvilSaveHandler savehandler=new AnvilSaveHandler(new File(getFolderName()),worldName,true);
  WorldInfo worldInfo=savehandler.loadWorldInfo();
  if (worldInfo != null) {
    if (!SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId()).isPresent()) {
      SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
      return Optional.of((WorldProperties)worldInfo);
    }
 else {
      return SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId());
    }
  }
 else {
    dim=DimensionManager.getNextFreeDimId();
    worldInfo=new WorldInfo((WorldSettings)(Object)settings,settings.getWorldName());
    ((WorldProperties)worldInfo).setKeepSpawnLoaded(settings.doesKeepSpawnLoaded());
    ((WorldProperties)worldInfo).setLoadOnStartup(settings.loadOnStartup());
    ((WorldProperties)worldInfo).setEnabled(settings.isEnabled());
    ((WorldProperties)worldInfo).setGeneratorType(settings.getGeneratorType());
    SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
  }
  ((IMixinWorldInfo)worldInfo).setDimensionId(dim);
  ((IMixinWorldInfo)worldInfo).setDimensionType(settings.getDimensionType());
  UUID uuid=UUID.randomUUID();
  ((IMixinWorldInfo)worldInfo).setUUID(uuid);
  SpongeMod.instance.getSpongeRegistry().registerWorldUniqueId(uuid,worldName);
  if (!DimensionManager.isDimensionRegistered(dim)) {
    DimensionManager.registerDimension(dim,((SpongeDimensionType)((WorldProperties)worldInfo).getDimensionType()).getDimensionTypeId());
  }
  savehandler.saveWorldInfoWithPlayer(worldInfo,getConfigurationManager().getHostPlayerData());
  SpongeMod.instance.getEventManager().post(SpongeEventFactory.createWorldCreate(SpongeMod.instance.getGame(),(WorldProperties)worldInfo,settings));
  return Optional.of((WorldProperties)worldInfo);
}","@Override public Optional<WorldProperties> createWorld(WorldCreationSettings settings){
  String worldName=settings.getWorldName();
  final Optional<World> optExisting=getWorld(worldName);
  if (optExisting.isPresent()) {
    return Optional.of(optExisting.get().getProperties());
  }
  int dim;
  AnvilSaveHandler savehandler=null;
  if (FMLCommonHandler.instance().getSide() == Side.CLIENT) {
    savehandler=new AnvilSaveHandler(new File(FMLCommonHandler.instance().getSavesDirectory() + File.separator + getFolderName()),worldName,true);
  }
 else {
    savehandler=new AnvilSaveHandler(new File(getFolderName()),worldName,true);
  }
  WorldInfo worldInfo=savehandler.loadWorldInfo();
  if (worldInfo != null) {
    if (!SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId()).isPresent()) {
      SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
      return Optional.of((WorldProperties)worldInfo);
    }
 else {
      return SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId());
    }
  }
 else {
    dim=DimensionManager.getNextFreeDimId();
    worldInfo=new WorldInfo((WorldSettings)(Object)settings,settings.getWorldName());
    ((WorldProperties)worldInfo).setKeepSpawnLoaded(settings.doesKeepSpawnLoaded());
    ((WorldProperties)worldInfo).setLoadOnStartup(settings.loadOnStartup());
    ((WorldProperties)worldInfo).setEnabled(settings.isEnabled());
    ((WorldProperties)worldInfo).setGeneratorType(settings.getGeneratorType());
    SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
    SpongeMod.instance.getSpongeRegistry().registerWorldDimensionId(dim,worldName);
  }
  ((IMixinWorldInfo)worldInfo).setDimensionId(dim);
  ((IMixinWorldInfo)worldInfo).setDimensionType(settings.getDimensionType());
  UUID uuid=UUID.randomUUID();
  ((IMixinWorldInfo)worldInfo).setUUID(uuid);
  SpongeMod.instance.getSpongeRegistry().registerWorldUniqueId(uuid,worldName);
  if (!DimensionManager.isDimensionRegistered(dim)) {
    DimensionManager.registerDimension(dim,((SpongeDimensionType)((WorldProperties)worldInfo).getDimensionType()).getDimensionTypeId());
  }
  savehandler.saveWorldInfoWithPlayer(worldInfo,getConfigurationManager().getHostPlayerData());
  SpongeMod.instance.getEventManager().post(SpongeEventFactory.createWorldCreate(SpongeMod.instance.getGame(),(WorldProperties)worldInfo,settings));
  return Optional.of((WorldProperties)worldInfo);
}"
27609,"@Override public Optional<World> loadWorld(String worldName){
  final Optional<World> optExisting=getWorld(worldName);
  if (optExisting.isPresent()) {
    return optExisting;
  }
  File file=new File(getFolderName(),worldName);
  if ((file.exists()) && (!file.isDirectory())) {
    throw new IllegalArgumentException(""String_Node_Str"" + worldName + ""String_Node_Str"");
  }
  AnvilSaveHandler savehandler=new AnvilSaveHandler(new File(getFolderName()),worldName,true);
  int dim=0;
  WorldInfo worldInfo=savehandler.loadWorldInfo();
  if (worldInfo != null) {
    if (!((WorldProperties)worldInfo).isEnabled()) {
      SpongeMod.instance.getLogger().error(""String_Node_Str"" + worldName + ""String_Node_Str"");
      return Optional.absent();
    }
    if (!SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId()).isPresent()) {
      SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
    }
 else {
      worldInfo=(WorldInfo)SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId()).get();
    }
    dim=((IMixinWorldInfo)worldInfo).getDimensionId();
  }
 else {
    return Optional.absent();
  }
  WorldSettings settings=new WorldSettings(worldInfo);
  if (!DimensionManager.isDimensionRegistered(dim)) {
    DimensionManager.registerDimension(dim,((SpongeDimensionType)((WorldProperties)worldInfo).getDimensionType()).getDimensionTypeId());
  }
  WorldServer world=(WorldServer)new WorldServer((MinecraftServer)(Object)this,savehandler,worldInfo,dim,this.theProfiler).init();
  world.initialize(settings);
  world.provider.setDimension(dim);
  world.addWorldAccess(new WorldManager((MinecraftServer)(Object)this,world));
  MinecraftForge.EVENT_BUS.post(new WorldEvent.Load(world));
  if (!isSinglePlayer()) {
    world.getWorldInfo().setGameType(getGameType());
  }
  this.setDifficultyForAllWorlds(this.getDifficulty());
  if (((WorldProperties)worldInfo).doesKeepSpawnLoaded()) {
    this.prepareSpawnArea(world);
  }
  return Optional.of((World)world);
}","@Override public Optional<World> loadWorld(String worldName){
  final Optional<World> optExisting=getWorld(worldName);
  if (optExisting.isPresent()) {
    return optExisting;
  }
  File file=new File(getFolderName(),worldName);
  if ((file.exists()) && (!file.isDirectory())) {
    throw new IllegalArgumentException(""String_Node_Str"" + worldName + ""String_Node_Str"");
  }
  AnvilSaveHandler savehandler=null;
  if (FMLCommonHandler.instance().getSide() == Side.CLIENT) {
    savehandler=new AnvilSaveHandler(new File(FMLCommonHandler.instance().getSavesDirectory() + File.separator + getFolderName()),worldName,true);
  }
 else {
    savehandler=new AnvilSaveHandler(new File(getFolderName()),worldName,true);
  }
  int dim;
  WorldInfo worldInfo=savehandler.loadWorldInfo();
  if (worldInfo != null) {
    if (!((WorldProperties)worldInfo).isEnabled()) {
      SpongeMod.instance.getLogger().error(""String_Node_Str"" + worldName + ""String_Node_Str"");
      return Optional.absent();
    }
    if (!SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId()).isPresent()) {
      SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
    }
 else {
      worldInfo=(WorldInfo)SpongeMod.instance.getSpongeRegistry().getWorldProperties(((WorldProperties)worldInfo).getUniqueId()).get();
    }
    dim=((IMixinWorldInfo)worldInfo).getDimensionId();
    if (!DimensionManager.isDimensionRegistered(dim)) {
      DimensionManager.registerDimension(dim,((SpongeDimensionType)((WorldProperties)worldInfo).getDimensionType()).getDimensionTypeId());
    }
    if (SpongeMod.instance.getSpongeRegistry().getWorldFolder(dim) == null) {
      SpongeMod.instance.getSpongeRegistry().registerWorldDimensionId(dim,worldName);
    }
  }
 else {
    return Optional.absent();
  }
  WorldSettings settings=new WorldSettings(worldInfo);
  WorldServer world=(WorldServer)new WorldServer((MinecraftServer)(Object)this,savehandler,worldInfo,dim,this.theProfiler).init();
  world.initialize(settings);
  world.provider.setDimension(dim);
  world.addWorldAccess(new WorldManager((MinecraftServer)(Object)this,world));
  MinecraftForge.EVENT_BUS.post(new WorldEvent.Load(world));
  if (!isSinglePlayer()) {
    world.getWorldInfo().setGameType(getGameType());
  }
  this.setDifficultyForAllWorlds(this.getDifficulty());
  if (((WorldProperties)worldInfo).doesKeepSpawnLoaded()) {
    this.prepareSpawnArea(world);
  }
  return Optional.of((World)world);
}"
27610,"@Overwrite protected void loadAllWorlds(String overworldFolder,String unused,long seed,WorldType type,String generator){
  this.convertMapIfNeeded(overworldFolder);
  this.setUserMessage(""String_Node_Str"");
  List<Integer> idList=new LinkedList<Integer>(Arrays.asList(DimensionManager.getStaticDimensionIDs()));
  idList.remove(Integer.valueOf(0));
  idList.add(0,0);
  for (  int dim : idList) {
    WorldProvider provider=WorldProvider.getProviderForDimension(dim);
    String worldFolder=""String_Node_Str"";
    if (dim == 0) {
      worldFolder=overworldFolder;
    }
 else {
      worldFolder=SpongeMod.instance.getSpongeRegistry().getWorldFolder(dim);
      if (worldFolder == null) {
        worldFolder=provider.getSaveFolder();
      }
    }
    WorldInfo worldInfo=null;
    WorldSettings newWorldSettings=null;
    AnvilSaveHandler worldsavehandler=null;
    worldsavehandler=new AnvilSaveHandler(new File(getFolderName()),worldFolder,true);
    worldInfo=worldsavehandler.loadWorldInfo();
    if (worldInfo == null) {
      newWorldSettings=new WorldSettings(seed,this.getGameType(),this.canStructuresSpawn(),this.isHardcore(),type);
      newWorldSettings.setWorldName(generator);
      if (this.enableBonusChest) {
        newWorldSettings.enableBonusChest();
      }
      worldInfo=new WorldInfo(newWorldSettings,worldFolder);
      ((IMixinWorldInfo)worldInfo).setUUID(UUID.randomUUID());
      if (dim == 0 || dim == -1 || dim == 1) {
        ((WorldProperties)worldInfo).setKeepSpawnLoaded(true);
        ((WorldProperties)worldInfo).setLoadOnStartup(true);
        ((WorldProperties)worldInfo).setEnabled(true);
        ((WorldProperties)worldInfo).setGeneratorType(GeneratorTypes.DEFAULT);
        SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
      }
    }
 else {
      worldInfo.setWorldName(worldFolder);
      newWorldSettings=new WorldSettings(worldInfo);
    }
    if (dim == 0) {
      this.setResourcePackFromWorld(this.getFolderName(),worldsavehandler);
    }
    ((IMixinWorldInfo)worldInfo).setDimensionId(dim);
    ((IMixinWorldInfo)worldInfo).setDimensionType(((Dimension)provider).getType());
    UUID uuid=((WorldProperties)worldInfo).getUniqueId();
    SpongeMod.instance.getSpongeRegistry().registerWorldUniqueId(uuid,worldFolder);
    WorldServer world=(WorldServer)new WorldServer((MinecraftServer)(Object)this,worldsavehandler,worldInfo,dim,this.theProfiler).init();
    world.initialize(newWorldSettings);
    world.addWorldAccess(new WorldManager((MinecraftServer)(Object)this,world));
    if (!this.isSinglePlayer()) {
      world.getWorldInfo().setGameType(this.getGameType());
    }
    SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
    net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(world));
  }
  this.serverConfigManager.setPlayerManager(new WorldServer[]{DimensionManager.getWorld(0)});
  this.setDifficultyForAllWorlds(this.getDifficulty());
  this.initialWorldChunkLoad();
}","@Overwrite protected void loadAllWorlds(String overworldFolder,String unused,long seed,WorldType type,String generator){
  this.convertMapIfNeeded(overworldFolder);
  this.setUserMessage(""String_Node_Str"");
  List<Integer> idList=new LinkedList<Integer>(Arrays.asList(DimensionManager.getStaticDimensionIDs()));
  idList.remove(Integer.valueOf(0));
  idList.add(0,0);
  for (  int dim : idList) {
    WorldProvider provider=WorldProvider.getProviderForDimension(dim);
    String worldFolder=""String_Node_Str"";
    if (dim == 0) {
      worldFolder=overworldFolder;
    }
 else {
      worldFolder=SpongeMod.instance.getSpongeRegistry().getWorldFolder(dim);
      if (worldFolder != null) {
        final Optional<World> optExisting=getWorld(worldFolder);
        if (optExisting.isPresent()) {
          continue;
        }
      }
 else {
        worldFolder=provider.getSaveFolder();
      }
    }
    WorldInfo worldInfo=null;
    WorldSettings newWorldSettings=null;
    AnvilSaveHandler worldsavehandler=null;
    if (FMLCommonHandler.instance().getSide() == Side.CLIENT) {
      worldsavehandler=new AnvilSaveHandler(new File(dim == 0 ? ""String_Node_Str"" : FMLCommonHandler.instance().getSavesDirectory() + File.separator + getFolderName()),worldFolder,true);
    }
 else {
      worldsavehandler=new AnvilSaveHandler(new File(dim == 0 ? ""String_Node_Str"" : getFolderName()),worldFolder,true);
    }
    worldInfo=worldsavehandler.loadWorldInfo();
    if (worldInfo == null) {
      newWorldSettings=new WorldSettings(seed,this.getGameType(),this.canStructuresSpawn(),this.isHardcore(),type);
      newWorldSettings.setWorldName(generator);
      if (this.enableBonusChest) {
        newWorldSettings.enableBonusChest();
      }
      worldInfo=new WorldInfo(newWorldSettings,worldFolder);
      ((IMixinWorldInfo)worldInfo).setUUID(UUID.randomUUID());
      if (dim == 0 || dim == -1 || dim == 1) {
        ((WorldProperties)worldInfo).setKeepSpawnLoaded(true);
        ((WorldProperties)worldInfo).setLoadOnStartup(true);
        ((WorldProperties)worldInfo).setEnabled(true);
        ((WorldProperties)worldInfo).setGeneratorType(GeneratorTypes.DEFAULT);
        SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
      }
    }
 else {
      worldInfo.setWorldName(worldFolder);
      newWorldSettings=new WorldSettings(worldInfo);
    }
    if (dim == 0) {
      this.setResourcePackFromWorld(this.getFolderName(),worldsavehandler);
    }
    ((IMixinWorldInfo)worldInfo).setDimensionId(dim);
    ((IMixinWorldInfo)worldInfo).setDimensionType(((Dimension)provider).getType());
    UUID uuid=((WorldProperties)worldInfo).getUniqueId();
    SpongeMod.instance.getSpongeRegistry().registerWorldUniqueId(uuid,worldFolder);
    WorldServer world=(WorldServer)new WorldServer((MinecraftServer)(Object)this,worldsavehandler,worldInfo,dim,this.theProfiler).init();
    world.initialize(newWorldSettings);
    world.addWorldAccess(new WorldManager((MinecraftServer)(Object)this,world));
    if (!this.isSinglePlayer()) {
      world.getWorldInfo().setGameType(this.getGameType());
    }
    SpongeMod.instance.getSpongeRegistry().registerWorldProperties((WorldProperties)worldInfo);
    net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.world.WorldEvent.Load(world));
  }
  this.serverConfigManager.setPlayerManager(new WorldServer[]{DimensionManager.getWorld(0)});
  this.setDifficultyForAllWorlds(this.getDifficulty());
  this.initialWorldChunkLoad();
}"
27611,"@Overwrite protected void initialWorldChunkLoad(){
  for (  WorldServer worldserver : DimensionManager.getWorlds()) {
    WorldProperties worldProperties=((World)worldserver).getProperties();
    if (worldProperties.doesKeepSpawnLoaded()) {
      int i=0;
      this.setUserMessage(""String_Node_Str"");
      MinecraftServer.getServer().logInfo(""String_Node_Str"" + worldserver.provider.getDimensionId());
      BlockPos blockpos=worldserver.getSpawnPoint();
      long j=MinecraftServer.getCurrentTimeMillis();
      for (int k=-192; k <= 192 && this.isServerRunning(); k+=16) {
        for (int l=-192; l <= 192 && this.isServerRunning(); l+=16) {
          long i1=MinecraftServer.getCurrentTimeMillis();
          if (i1 - j > 1000L) {
            this.outputPercentRemaining(""String_Node_Str"",i * 100 / 625);
            j=i1;
          }
          ++i;
          worldserver.theChunkProviderServer.loadChunk(blockpos.getX() + k >> 4,blockpos.getZ() + l >> 4);
        }
      }
    }
  }
  this.clearCurrentTask();
}","@Overwrite protected void initialWorldChunkLoad(){
  for (  WorldServer worldserver : DimensionManager.getWorlds()) {
    WorldProperties worldProperties=((World)worldserver).getProperties();
    if (worldProperties.doesKeepSpawnLoaded()) {
      prepareSpawnArea(worldserver);
    }
  }
  this.clearCurrentTask();
}"
27612,"@Override public boolean shouldApplyMixin(String targetClassName,String mixinClassName){
  return true;
}","@Override public boolean shouldApplyMixin(String targetClassName,String mixinClassName){
  if (mixinClassName.contains(""String_Node_Str"") && MixinEnvironment.getCurrentEnvironment().getSide() == Side.SERVER) {
    return false;
  }
  return true;
}"
27613,"public String getId(){
  return ""String_Node_Str"" + this.id;
}","@Override public String getId(){
  return ""String_Node_Str"" + this.id;
}"
27614,"@SuppressWarnings(""String_Node_Str"") @Override public <T extends DataManipulator<T>>Optional<T> getData(Class<T> dataClass){
  if (NameData.class.isAssignableFrom((Class)dataClass)) {
    NameData nameData=new SpongeNameData();
    return (Optional<T>)(Optional)nameData.fill(this);
  }
  return Optional.absent();
}","@SuppressWarnings(""String_Node_Str"") @Override public <T extends DataManipulator<T>>Optional<T> getData(Class<T> dataClass){
  return Optional.absent();
}"
27615,"@Overwrite public WorldInfo loadWorldInfo(){
  File file1=new File(this.worldDirectory,""String_Node_Str"");
  File file2=new File(this.worldDirectory,""String_Node_Str"");
  File spongeFile=new File(this.worldDirectory,""String_Node_Str"");
  File spongeOldFile=new File(this.worldDirectory,""String_Node_Str"");
  NBTTagCompound nbttagcompound;
  NBTTagCompound nbttagcompound1;
  WorldInfo worldInfo=null;
  if (!file1.exists() && file2.exists()) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().confirmBackupLevelDatUse((SaveHandler)(Object)this);
  }
  if (file1.exists() || file2.exists()) {
    try {
      nbttagcompound=CompressedStreamTools.readCompressed(new FileInputStream(file1.exists() ? file1 : file2));
      nbttagcompound1=nbttagcompound.getCompoundTag(""String_Node_Str"");
      worldInfo=new WorldInfo(nbttagcompound1);
      if (DimensionManager.getCurrentSaveRootDirectory().equals(this.worldDirectory)) {
        net.minecraftforge.fml.common.FMLCommonHandler.instance().handleWorldDataLoad((SaveHandler)(Object)this,worldInfo,nbttagcompound);
      }
      if (spongeFile.exists() || spongeOldFile.exists()) {
        nbttagcompound=CompressedStreamTools.readCompressed(new FileInputStream(spongeFile.exists() ? spongeFile : spongeOldFile));
        ((IMixinWorldInfo)worldInfo).setSpongeRootLevelNBT(nbttagcompound);
        if (nbttagcompound.hasKey(SpongeMod.instance.getModId())) {
          NBTTagCompound spongeNbt=nbttagcompound.getCompoundTag(SpongeMod.instance.getModId());
          ((IMixinWorldInfo)worldInfo).readSpongeNbt(spongeNbt);
        }
      }
      return worldInfo;
    }
 catch (    net.minecraftforge.fml.common.StartupQuery.AbortedException e) {
      throw e;
    }
catch (    Exception exception1) {
      exception1.printStackTrace();
    }
  }
  return null;
}","@Overwrite public WorldInfo loadWorldInfo(){
  File file1=new File(this.worldDirectory,""String_Node_Str"");
  File file2=new File(this.worldDirectory,""String_Node_Str"");
  File spongeFile=new File(this.worldDirectory,""String_Node_Str"");
  File spongeOldFile=new File(this.worldDirectory,""String_Node_Str"");
  NBTTagCompound nbttagcompound;
  NBTTagCompound nbttagcompound1;
  WorldInfo worldInfo=null;
  if (!file1.exists() && file2.exists()) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().confirmBackupLevelDatUse((SaveHandler)(Object)this);
  }
  if (file1.exists() || file2.exists()) {
    try {
      nbttagcompound=CompressedStreamTools.readCompressed(new FileInputStream(file1.exists() ? file1 : file2));
      nbttagcompound1=nbttagcompound.getCompoundTag(""String_Node_Str"");
      worldInfo=new WorldInfo(nbttagcompound1);
      if (this.worldDirectory.getParentFile() == null || (FMLCommonHandler.instance().getSide() == Side.CLIENT && this.worldDirectory.getParentFile().equals(FMLCommonHandler.instance().getSavesDirectory()))) {
        net.minecraftforge.fml.common.FMLCommonHandler.instance().handleWorldDataLoad((SaveHandler)(Object)this,worldInfo,nbttagcompound);
      }
      if (spongeFile.exists() || spongeOldFile.exists()) {
        nbttagcompound=CompressedStreamTools.readCompressed(new FileInputStream(spongeFile.exists() ? spongeFile : spongeOldFile));
        ((IMixinWorldInfo)worldInfo).setSpongeRootLevelNBT(nbttagcompound);
        if (nbttagcompound.hasKey(SpongeMod.instance.getModId())) {
          NBTTagCompound spongeNbt=nbttagcompound.getCompoundTag(SpongeMod.instance.getModId());
          ((IMixinWorldInfo)worldInfo).readSpongeNbt(spongeNbt);
        }
      }
      return worldInfo;
    }
 catch (    net.minecraftforge.fml.common.StartupQuery.AbortedException e) {
      throw e;
    }
catch (    Exception exception1) {
      exception1.printStackTrace();
    }
  }
  return null;
}"
27616,"@Overwrite public void saveWorldInfoWithPlayer(WorldInfo worldInformation,NBTTagCompound tagCompound){
  NBTTagCompound nbttagcompound1=worldInformation.cloneNBTCompound(tagCompound);
  NBTTagCompound nbttagcompound2=new NBTTagCompound();
  nbttagcompound2.setTag(""String_Node_Str"",nbttagcompound1);
  if (DimensionManager.getCurrentSaveRootDirectory().equals(this.worldDirectory)) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().handleWorldDataSave((SaveHandler)(Object)this,worldInformation,nbttagcompound2);
  }
  try {
    File file1=new File(this.worldDirectory,""String_Node_Str"");
    File file2=new File(this.worldDirectory,""String_Node_Str"");
    File file3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(nbttagcompound2,new FileOutputStream(file1));
    if (file2.exists()) {
      file2.delete();
    }
    file3.renameTo(file2);
    if (file3.exists()) {
      file3.delete();
    }
    file1.renameTo(file3);
    if (file1.exists()) {
      file1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
  try {
    File spongeFile1=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile2=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(((IMixinWorldInfo)worldInformation).getSpongeRootLevelNbt(),new FileOutputStream(spongeFile1));
    if (spongeFile2.exists()) {
      spongeFile2.delete();
    }
    spongeFile3.renameTo(spongeFile2);
    if (spongeFile3.exists()) {
      spongeFile3.delete();
    }
    spongeFile1.renameTo(spongeFile3);
    if (spongeFile1.exists()) {
      spongeFile1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
}","@Overwrite public void saveWorldInfoWithPlayer(WorldInfo worldInformation,NBTTagCompound tagCompound){
  NBTTagCompound nbttagcompound1=worldInformation.cloneNBTCompound(tagCompound);
  NBTTagCompound nbttagcompound2=new NBTTagCompound();
  nbttagcompound2.setTag(""String_Node_Str"",nbttagcompound1);
  if (this.worldDirectory.getParentFile() == null || (FMLCommonHandler.instance().getSide() == Side.CLIENT && this.worldDirectory.getParentFile().equals(FMLCommonHandler.instance().getSavesDirectory()))) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().handleWorldDataSave((SaveHandler)(Object)this,worldInformation,nbttagcompound2);
  }
  try {
    File file1=new File(this.worldDirectory,""String_Node_Str"");
    File file2=new File(this.worldDirectory,""String_Node_Str"");
    File file3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(nbttagcompound2,new FileOutputStream(file1));
    if (file2.exists()) {
      file2.delete();
    }
    file3.renameTo(file2);
    if (file3.exists()) {
      file3.delete();
    }
    file1.renameTo(file3);
    if (file1.exists()) {
      file1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
  try {
    File spongeFile1=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile2=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(((IMixinWorldInfo)worldInformation).getSpongeRootLevelNbt(),new FileOutputStream(spongeFile1));
    if (spongeFile2.exists()) {
      spongeFile2.delete();
    }
    spongeFile3.renameTo(spongeFile2);
    if (spongeFile3.exists()) {
      spongeFile3.delete();
    }
    spongeFile1.renameTo(spongeFile3);
    if (spongeFile1.exists()) {
      spongeFile1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
}"
27617,"@Overwrite public void saveWorldInfo(WorldInfo worldInformation){
  NBTTagCompound nbttagcompound=worldInformation.getNBTTagCompound();
  NBTTagCompound nbttagcompound1=new NBTTagCompound();
  nbttagcompound1.setTag(""String_Node_Str"",nbttagcompound);
  if (DimensionManager.getCurrentSaveRootDirectory().equals(this.worldDirectory)) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().handleWorldDataSave((SaveHandler)(Object)this,worldInformation,nbttagcompound1);
  }
  try {
    File file1=new File(this.worldDirectory,""String_Node_Str"");
    File file2=new File(this.worldDirectory,""String_Node_Str"");
    File file3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(nbttagcompound1,new FileOutputStream(file1));
    if (file2.exists()) {
      file2.delete();
    }
    file3.renameTo(file2);
    if (file3.exists()) {
      file3.delete();
    }
    file1.renameTo(file3);
    if (file1.exists()) {
      file1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
  try {
    File spongeFile1=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile2=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(((IMixinWorldInfo)worldInformation).getSpongeRootLevelNbt(),new FileOutputStream(spongeFile1));
    if (spongeFile2.exists()) {
      spongeFile2.delete();
    }
    spongeFile3.renameTo(spongeFile2);
    if (spongeFile3.exists()) {
      spongeFile3.delete();
    }
    spongeFile1.renameTo(spongeFile3);
    if (spongeFile1.exists()) {
      spongeFile1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
}","@Overwrite public void saveWorldInfo(WorldInfo worldInformation){
  NBTTagCompound nbttagcompound=worldInformation.getNBTTagCompound();
  NBTTagCompound nbttagcompound1=new NBTTagCompound();
  nbttagcompound1.setTag(""String_Node_Str"",nbttagcompound);
  if (this.worldDirectory.getParentFile() == null || (FMLCommonHandler.instance().getSide() == Side.CLIENT && this.worldDirectory.getParentFile().equals(FMLCommonHandler.instance().getSavesDirectory()))) {
    net.minecraftforge.fml.common.FMLCommonHandler.instance().handleWorldDataSave((SaveHandler)(Object)this,worldInformation,nbttagcompound1);
  }
  try {
    File file1=new File(this.worldDirectory,""String_Node_Str"");
    File file2=new File(this.worldDirectory,""String_Node_Str"");
    File file3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(nbttagcompound1,new FileOutputStream(file1));
    if (file2.exists()) {
      file2.delete();
    }
    file3.renameTo(file2);
    if (file3.exists()) {
      file3.delete();
    }
    file1.renameTo(file3);
    if (file1.exists()) {
      file1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
  try {
    File spongeFile1=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile2=new File(this.worldDirectory,""String_Node_Str"");
    File spongeFile3=new File(this.worldDirectory,""String_Node_Str"");
    CompressedStreamTools.writeCompressed(((IMixinWorldInfo)worldInformation).getSpongeRootLevelNbt(),new FileOutputStream(spongeFile1));
    if (spongeFile2.exists()) {
      spongeFile2.delete();
    }
    spongeFile3.renameTo(spongeFile2);
    if (spongeFile3.exists()) {
      spongeFile3.delete();
    }
    spongeFile1.renameTo(spongeFile3);
    if (spongeFile1.exists()) {
      spongeFile1.delete();
    }
  }
 catch (  Exception exception) {
    exception.printStackTrace();
  }
}"
27618,"private void updateSpongeNbt(){
  this.spongeNbt.setString(""String_Node_Str"",this.levelName);
  this.spongeNbt.setInteger(""String_Node_Str"",this.dimension);
  if (this.dimensionType != null) {
    this.spongeNbt.setString(""String_Node_Str"",this.dimensionType.getDimensionClass().getName());
  }
  if (this.uuid != null) {
    this.spongeNbt.setLong(""String_Node_Str"",this.uuid.getMostSignificantBits());
    this.spongeNbt.setLong(""String_Node_Str"",this.uuid.getLeastSignificantBits());
  }
  this.spongeNbt.setBoolean(""String_Node_Str"",this.worldEnabled);
  this.spongeNbt.setBoolean(""String_Node_Str"",this.keepSpawnLoaded);
  this.spongeNbt.setBoolean(""String_Node_Str"",this.loadOnStartup);
}","private void updateSpongeNbt(){
  if (this.levelName != null) {
    this.spongeNbt.setString(""String_Node_Str"",this.levelName);
  }
  this.spongeNbt.setInteger(""String_Node_Str"",this.dimension);
  if (this.dimensionType != null) {
    this.spongeNbt.setString(""String_Node_Str"",this.dimensionType.getDimensionClass().getName());
  }
  if (this.uuid != null) {
    this.spongeNbt.setLong(""String_Node_Str"",this.uuid.getMostSignificantBits());
    this.spongeNbt.setLong(""String_Node_Str"",this.uuid.getLeastSignificantBits());
  }
  this.spongeNbt.setBoolean(""String_Node_Str"",this.worldEnabled);
  this.spongeNbt.setBoolean(""String_Node_Str"",this.keepSpawnLoaded);
  this.spongeNbt.setBoolean(""String_Node_Str"",this.loadOnStartup);
}"
27619,"@Override public boolean call(CommandSource source,String arguments,List<String> parents) throws CommandException {
  CommandHandler handler=(CommandHandler)MinecraftServer.getServer().getCommandManager();
  final ICommandSender mcSender=source instanceof ICommandSender ? (ICommandSender)source : new WrapperICommandSender(source);
  final String[] args=arguments.split(""String_Node_Str"");
  int usernameIndex=handler.getUsernameIndex(this.command,args);
  int successCount=0;
  if (testPermission(source)) {
    net.minecraftforge.event.CommandEvent event=new net.minecraftforge.event.CommandEvent(this.command,mcSender,args);
    if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(event)) {
      if (event.exception != null) {
        com.google.common.base.Throwables.propagateIfPossible(event.exception);
      }
      return false;
    }
    if (usernameIndex > -1) {
      @SuppressWarnings(""String_Node_Str"") List<Entity> list=PlayerSelector.matchEntities(mcSender,args[usernameIndex],Entity.class);
      String previousNameVal=args[usernameIndex];
      mcSender.setCommandStat(CommandResultStats.Type.AFFECTED_ENTITIES,list.size());
      for (      Entity entity : list) {
        args[usernameIndex]=entity.getUniqueID().toString();
        if (handler.tryExecute(mcSender,args,this.command,arguments)) {
          ++successCount;
        }
      }
      args[usernameIndex]=previousNameVal;
    }
 else {
      mcSender.setCommandStat(CommandResultStats.Type.AFFECTED_ENTITIES,1);
      if (handler.tryExecute(mcSender,args,this.command,arguments)) {
        ++successCount;
      }
    }
  }
 else {
    source.sendMessage(Texts.builder(SpongeMod.instance.getGame().getRegistry().getTranslationById(TRANSLATION_NO_PERMISSION).get(),new Object[0]).color(TextColors.RED).build());
  }
  mcSender.setCommandStat(CommandResultStats.Type.SUCCESS_COUNT,successCount);
  return successCount > 0;
}","@Override public boolean call(CommandSource source,String arguments,List<String> parents) throws CommandException {
  CommandHandler handler=(CommandHandler)MinecraftServer.getServer().getCommandManager();
  final ICommandSender mcSender=source instanceof ICommandSender ? (ICommandSender)source : new WrapperICommandSender(source);
  final String[] args=splitArgs(arguments);
  int usernameIndex=handler.getUsernameIndex(this.command,args);
  int successCount=0;
  if (testPermission(source)) {
    net.minecraftforge.event.CommandEvent event=new net.minecraftforge.event.CommandEvent(this.command,mcSender,args);
    if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(event)) {
      if (event.exception != null) {
        com.google.common.base.Throwables.propagateIfPossible(event.exception);
      }
      return false;
    }
    if (usernameIndex > -1) {
      @SuppressWarnings(""String_Node_Str"") List<Entity> list=PlayerSelector.matchEntities(mcSender,args[usernameIndex],Entity.class);
      String previousNameVal=args[usernameIndex];
      mcSender.setCommandStat(CommandResultStats.Type.AFFECTED_ENTITIES,list.size());
      for (      Entity entity : list) {
        args[usernameIndex]=entity.getUniqueID().toString();
        if (handler.tryExecute(mcSender,args,this.command,arguments)) {
          ++successCount;
        }
      }
      args[usernameIndex]=previousNameVal;
    }
 else {
      mcSender.setCommandStat(CommandResultStats.Type.AFFECTED_ENTITIES,1);
      if (handler.tryExecute(mcSender,args,this.command,arguments)) {
        ++successCount;
      }
    }
  }
 else {
    source.sendMessage(Texts.builder(SpongeMod.instance.getGame().getRegistry().getTranslationById(TRANSLATION_NO_PERMISSION).get(),new Object[0]).color(TextColors.RED).build());
  }
  mcSender.setCommandStat(CommandResultStats.Type.SUCCESS_COUNT,successCount);
  return successCount > 0;
}"
27620,"@Override @SuppressWarnings(""String_Node_Str"") public List<String> getSuggestions(CommandSource source,String arguments) throws CommandException {
  return this.command.addTabCompletionOptions((ICommandSender)source,arguments.split(""String_Node_Str""),null);
}","@Override @SuppressWarnings(""String_Node_Str"") public List<String> getSuggestions(CommandSource source,String arguments) throws CommandException {
  return this.command.addTabCompletionOptions((ICommandSender)source,splitArgs(arguments),null);
}"
27621,"private void setEntityInteractionTypes(){
  RegistryHelper.mapFields(EntityInteractionTypes.class,this.entityInteractionTypeMappings);
}","private void setEntityInteractionTypes(){
  RegistryHelper.mapFields(EntityInteractionTypes.class,SpongeGameRegistry.entityInteractionTypeMappings);
}"
27622,"public int human$getExperienceSinceLevel(){
  return this.human$getTotalExperience() - human$xpAtLevel(this.human$getLevel());
}","public int human$getExperienceSinceLevel(){
  return this.human$getTotalExperience() - xpAtLevel(this.human$getLevel());
}"
27623,"public void human$setExperienceSinceLevel(int experience){
  this.human$setTotalExperience(human$xpAtLevel(this.experienceLevel) + experience);
}","public void human$setExperienceSinceLevel(int experience){
  this.human$setTotalExperience(xpAtLevel(this.experienceLevel) + experience);
}"
27624,"public MixinBlockUpdateEvent(World world,BlockPos pos,IBlockState state,EnumSet<EnumFacing> notifiedSides){
  super(world,pos,state);
  this.affectedBlocks=new HashSet<BlockLoc>();
  for (  EnumFacing notifiedSide : notifiedSides) {
    BlockPos offset=pos.offset(notifiedSide);
    this.affectedBlocks.add(((org.spongepowered.api.world.World)world).getFullBlock(offset.getX(),offset.getY(),offset.getZ()));
  }
  this.notifiedSides=notifiedSides;
}","public MixinBlockUpdateEvent(World world,BlockPos pos,IBlockState state,EnumSet<EnumFacing> notifiedSides){
  super(world,pos,state);
  this.notifiedSides=notifiedSides;
}"
27625,"@Override public Collection<BlockLoc> getAffectedBlocks(){
  return this.affectedBlocks;
}","@Override public Collection<BlockLoc> getAffectedBlocks(){
  if (this.affectedBlocks == null) {
    this.affectedBlocks=new HashSet<BlockLoc>();
    for (    EnumFacing notifiedSide : notifiedSides) {
      BlockPos offset=pos.offset(notifiedSide);
      this.affectedBlocks.add(((org.spongepowered.api.world.World)world).getFullBlock(offset.getX(),offset.getY(),offset.getZ()));
    }
  }
  return this.affectedBlocks;
}"
27626,"/** 
 * Gets the list of packets that are needed to spawn the particle effect at the position. This method tries to minimize the amount of packets for better performance and lower bandwidth use.
 * @param effect The particle effect
 * @param position The position
 * @return The packets
 */
public static List<Packet> toPackets(SpongeParticleEffect effect,Vector3d position){
  SpongeParticleType type=effect.getType();
  EnumParticleTypes internal=type.getInternalType();
  Vector3f offset=effect.getOffset();
  int count=effect.getCount();
  int[] extra=new int[0];
  float px=(float)position.getX();
  float py=(float)position.getY();
  float pz=(float)position.getZ();
  float ox=offset.getX();
  float oy=offset.getY();
  float oz=offset.getZ();
  float f0=0f;
  float f1=0f;
  float f2=0f;
  if (effect instanceof SpongeParticleEffect.Materialized) {
    ItemStack item=((SpongeParticleEffect.Materialized)effect).getItem();
    ItemType itemType=item.getItem();
    int id=0;
    int data=0;
    if (internal == EnumParticleTypes.ITEM_CRACK) {
      id=Item.itemRegistry.getIDForObject(itemType);
      data=item.getDamage();
    }
 else     if (internal == EnumParticleTypes.BLOCK_CRACK || internal == EnumParticleTypes.BLOCK_DUST) {
      if (itemType instanceof ItemBlock) {
        id=Block.blockRegistry.getIDForObject(((ItemBlock)itemType).getBlock());
        data=item.getDamage();
      }
    }
    if (id == 0) {
      return Collections.emptyList();
    }
    extra=new int[]{id,data};
  }
  if (effect instanceof SpongeParticleEffect.Resized) {
    float size=((SpongeParticleEffect.Resized)effect).getSize();
    if (internal == EnumParticleTypes.EXPLOSION_LARGE) {
      size=(-size * 2f) + 2f;
    }
    if (size == 0f) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
    f0=size;
  }
 else   if (effect instanceof SpongeParticleEffect.Colored) {
    Color color0=((SpongeParticleEffect.Colored)effect).getColor();
    Color color1=((SpongeParticleType.Colorable)type).getDefaultColor();
    if (color0.equals(color1)) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
    f0=color0.getRed() / 255f;
    f1=color0.getGreen() / 255f;
    f2=color0.getBlue() / 255f;
    if (f0 == 0f && internal == EnumParticleTypes.REDSTONE) {
      f0=0.00001f;
    }
  }
 else   if (effect instanceof SpongeParticleEffect.Note) {
    float note=((SpongeParticleEffect.Note)effect).getNote();
    if (note == 0f) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
    f0=note / 24f;
  }
 else   if (type.hasMotion()) {
    Vector3f motion=effect.getMotion();
    float mx=motion.getX();
    float my=motion.getY();
    float mz=motion.getZ();
    if (internal == EnumParticleTypes.WATER_SPLASH) {
      my=0f;
    }
    if (mx == 0f && my == 0f && mz == 0f) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
 else {
      f0=mx;
      f1=my;
      f2=mz;
    }
  }
  if (f0 == 0f && f1 == 0f && f2 == 0f) {
    return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
  }
  List<Packet> packets=Lists.newArrayList();
  if (ox == 0f && oy == 0f && oz == 0f) {
    for (int i=0; i < count; i++) {
      packets.add(new S2APacketParticles(internal,true,px,py,pz,f0,f1,f2,1f,0,extra));
    }
  }
 else {
    Random random=new Random();
    for (int i=0; i < count; i++) {
      float px0=(float)(px + (random.nextFloat() * 2f - 1f) * ox);
      float py0=(float)(py + (random.nextFloat() * 2f - 1f) * oy);
      float pz0=(float)(pz + (random.nextFloat() * 2f - 1f) * oz);
      packets.add(new S2APacketParticles(internal,true,px0,py0,pz0,f0,f1,f2,1f,0,extra));
    }
  }
  return packets;
}","/** 
 * Gets the list of packets that are needed to spawn the particle effect at the position. This method tries to minimize the amount of packets for better performance and lower bandwidth use.
 * @param effect The particle effect
 * @param position The position
 * @return The packets
 */
public static List<Packet> toPackets(SpongeParticleEffect effect,Vector3d position){
  SpongeParticleType type=effect.getType();
  EnumParticleTypes internal=type.getInternalType();
  Vector3f offset=effect.getOffset();
  int count=effect.getCount();
  int[] extra=new int[0];
  float px=(float)position.getX();
  float py=(float)position.getY();
  float pz=(float)position.getZ();
  float ox=offset.getX();
  float oy=offset.getY();
  float oz=offset.getZ();
  float f0=0f;
  float f1=0f;
  float f2=0f;
  if (effect instanceof SpongeParticleEffect.Materialized) {
    ItemStack item=((SpongeParticleEffect.Materialized)effect).getItem();
    ItemType itemType=item.getItem();
    int id=0;
    int data=0;
    if (internal == EnumParticleTypes.ITEM_CRACK) {
      id=Item.itemRegistry.getIDForObject(itemType);
      data=item.getDamage();
    }
 else     if (internal == EnumParticleTypes.BLOCK_CRACK || internal == EnumParticleTypes.BLOCK_DUST) {
      if (itemType instanceof ItemBlock) {
        id=Block.blockRegistry.getIDForObject(((ItemBlock)itemType).getBlock());
        data=item.getDamage();
      }
    }
    if (id == 0) {
      return Collections.emptyList();
    }
    extra=new int[]{id,data};
  }
  if (effect instanceof SpongeParticleEffect.Resized) {
    float size=((SpongeParticleEffect.Resized)effect).getSize();
    if (internal == EnumParticleTypes.EXPLOSION_LARGE) {
      size=(-size * 2f) + 2f;
    }
    if (size == 0f) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
    f0=size;
  }
 else   if (effect instanceof SpongeParticleEffect.Colored) {
    Color color0=((SpongeParticleEffect.Colored)effect).getColor();
    Color color1=((SpongeParticleType.Colorable)type).getDefaultColor();
    if (color0.equals(color1)) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
    f0=color0.getRed() / 255f;
    f1=color0.getGreen() / 255f;
    f2=color0.getBlue() / 255f;
    if (f0 == 0f && internal == EnumParticleTypes.REDSTONE) {
      f0=0.00001f;
    }
  }
 else   if (effect instanceof SpongeParticleEffect.Note) {
    float note=((SpongeParticleEffect.Note)effect).getNote();
    if (note == 0f) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
    f0=note / 24f;
  }
 else   if (type.hasMotion()) {
    Vector3f motion=effect.getMotion();
    float mx=motion.getX();
    float my=motion.getY();
    float mz=motion.getZ();
    if (internal == EnumParticleTypes.WATER_SPLASH) {
      my=0f;
    }
    if (mx == 0f && my == 0f && mz == 0f) {
      return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
    }
 else {
      f0=mx;
      f1=my;
      f2=mz;
    }
  }
  if (f0 == 0f && f1 == 0f && f2 == 0f) {
    return Lists.<Packet>newArrayList(new S2APacketParticles(internal,true,px,py,pz,ox,oy,oz,0f,count,extra));
  }
  List<Packet> packets=Lists.newArrayList();
  if (ox == 0f && oy == 0f && oz == 0f) {
    for (int i=0; i < count; i++) {
      packets.add(new S2APacketParticles(internal,true,px,py,pz,f0,f1,f2,1f,0,extra));
    }
  }
 else {
    Random random=new Random();
    for (int i=0; i < count; i++) {
      float px0=(px + (random.nextFloat() * 2f - 1f) * ox);
      float py0=(py + (random.nextFloat() * 2f - 1f) * oy);
      float pz0=(pz + (random.nextFloat() * 2f - 1f) * oz);
      packets.add(new S2APacketParticles(internal,true,px0,py0,pz0,f0,f1,f2,1f,0,extra));
    }
  }
  return packets;
}"
27627,"@Override public boolean setLocationAndRotation(Location location,Vector3f rotation,EnumSet<RelativePositions> relativePositions){
  if (relativePositions.isEmpty()) {
    if (setLocation(location)) {
      setRotation(rotation);
      return true;
    }
    return false;
  }
 else {
    if (((Entity)this) instanceof EntityPlayerMP) {
      EnumSet<S08PacketPlayerPosLook.EnumFlags> relativeFlags=EnumSet.noneOf(S08PacketPlayerPosLook.EnumFlags.class);
      if (relativePositions.contains(RelativePositions.X)) {
        relativeFlags.add(S08PacketPlayerPosLook.EnumFlags.X);
      }
      if (relativePositions.contains(RelativePositions.Y)) {
        relativeFlags.add(S08PacketPlayerPosLook.EnumFlags.Y);
      }
      if (relativePositions.contains(RelativePositions.Z)) {
        relativeFlags.add(S08PacketPlayerPosLook.EnumFlags.Z);
      }
      if (relativePositions.contains(RelativePositions.PITCH)) {
        relativeFlags.add(S08PacketPlayerPosLook.EnumFlags.Y_ROT);
      }
      if (relativePositions.contains(RelativePositions.YAW)) {
        relativeFlags.add(S08PacketPlayerPosLook.EnumFlags.X_ROT);
      }
      ((EntityPlayerMP)(Entity)this).playerNetServerHandler.func_175089_a(location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ(),rotation.getX(),rotation.getY(),relativeFlags);
      return true;
    }
 else {
      Location resultant=getLocation();
      Vector3f resultantRotation=getRotation();
      if (relativePositions.contains(RelativePositions.X)) {
        resultant.add(location.getPosition().getX(),0,0);
      }
      if (relativePositions.contains(RelativePositions.Y)) {
        resultant.add(0,location.getPosition().getY(),0);
      }
      if (relativePositions.contains(RelativePositions.Z)) {
        resultant.add(0,0,location.getPosition().getZ());
      }
      if (relativePositions.contains(RelativePositions.PITCH)) {
        resultantRotation.add(rotation.getX(),0,0);
      }
      if (relativePositions.contains(RelativePositions.YAW)) {
        resultantRotation.add(0,rotation.getY(),0);
      }
      if (setLocation(resultant)) {
        setRotation(resultantRotation);
        return true;
      }
      return false;
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public boolean setLocationAndRotation(Location location,Vector3f rotation,EnumSet<RelativePositions> relativePositions){
  if (relativePositions.isEmpty()) {
    if (setLocation(location)) {
      setRotation(rotation);
      return true;
    }
    return false;
  }
 else {
    if (((Entity)this) instanceof EntityPlayerMP) {
      EnumSet relativeFlags=EnumSet.noneOf(EnumFlags.class);
      if (relativePositions.contains(RelativePositions.X)) {
        relativeFlags.add(EnumFlags.X);
      }
      if (relativePositions.contains(RelativePositions.Y)) {
        relativeFlags.add(EnumFlags.Y);
      }
      if (relativePositions.contains(RelativePositions.Z)) {
        relativeFlags.add(EnumFlags.Z);
      }
      if (relativePositions.contains(RelativePositions.PITCH)) {
        relativeFlags.add(EnumFlags.Y_ROT);
      }
      if (relativePositions.contains(RelativePositions.YAW)) {
        relativeFlags.add(EnumFlags.X_ROT);
      }
      ((EntityPlayerMP)(Entity)this).playerNetServerHandler.func_175089_a(location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ(),rotation.getX(),rotation.getY(),relativeFlags);
      return true;
    }
 else {
      Location resultant=getLocation();
      Vector3f resultantRotation=getRotation();
      if (relativePositions.contains(RelativePositions.X)) {
        resultant.add(location.getPosition().getX(),0,0);
      }
      if (relativePositions.contains(RelativePositions.Y)) {
        resultant.add(0,location.getPosition().getY(),0);
      }
      if (relativePositions.contains(RelativePositions.Z)) {
        resultant.add(0,0,location.getPosition().getZ());
      }
      if (relativePositions.contains(RelativePositions.PITCH)) {
        resultantRotation.add(rotation.getX(),0,0);
      }
      if (relativePositions.contains(RelativePositions.YAW)) {
        resultantRotation.add(0,rotation.getY(),0);
      }
      if (setLocation(resultant)) {
        setRotation(resultantRotation);
        return true;
      }
      return false;
    }
  }
}"
27628,@Shadow public abstract Collection getActivePotionEffects();,"@SuppressWarnings(""String_Node_Str"") @Shadow public abstract Collection getActivePotionEffects();"
27629,"@Override public ProjectileSource getShooter(){
  if (this.projectileSource != null && this.projectileSource instanceof ProjectileSource) {
    return (ProjectileSource)this.projectileSource;
  }
 else   if (this.shootingEntity != null && this.shootingEntity instanceof ProjectileSource) {
    return (ProjectileSource)this.shootingEntity;
  }
  return new UnknownProjectileSource();
}","@Override public ProjectileSource getShooter(){
  if (this.projectileSource != null && this.projectileSource instanceof ProjectileSource) {
    return this.projectileSource;
  }
 else   if (this.shootingEntity != null && this.shootingEntity instanceof ProjectileSource) {
    return (ProjectileSource)this.shootingEntity;
  }
  return new UnknownProjectileSource();
}"
27630,"@Override public BlockLoc getBlock(){
  return new BlockWrapper((World)this.world,(int)this.pos.getX(),(int)this.pos.getY(),(int)this.pos.getZ());
}","@Override public BlockLoc getBlock(){
  return new BlockWrapper((World)this.world,this.pos.getX(),this.pos.getY(),this.pos.getZ());
}"
27631,"@Override public void broadcastMessage(Message message){
  getConfigurationManager().sendChatMsg(((SpongeMessage)message).getHandle());
}","@SuppressWarnings(""String_Node_Str"") @Override public void broadcastMessage(Message message){
  getConfigurationManager().sendChatMsg(((SpongeMessage)message).getHandle());
}"
27632,"@Override public Optional<ParticleType> getParticleType(String name){
  return Optional.fromNullable((ParticleType)this.particleByName.get(name));
}","@Override public Optional<ParticleType> getParticleType(String name){
  return Optional.fromNullable(this.particleByName.get(name));
}"
27633,"public List<S45PacketTitle> getPackets(){
  List<S45PacketTitle> packets=Lists.newArrayList();
  if (this.isReset) {
    packets.add(new S45PacketTitle(S45PacketTitle.Type.RESET,null));
  }
 else   if (this.isClear) {
    packets.add(new S45PacketTitle(S45PacketTitle.Type.CLEAR,null));
  }
  if (this.fadeIn.isPresent() && this.stay.isPresent() && this.fadeOut.isPresent()) {
    packets.add(new S45PacketTitle(this.fadeIn.get(),this.stay.get(),this.fadeOut.get()));
  }
  if (this.titleMessage.isPresent()) {
    SpongeMessage message=(SpongeMessage)this.titleMessage.get();
    packets.add(new S45PacketTitle(S45PacketTitle.Type.TITLE,message.getHandle()));
  }
  if (this.subtitleMessage.isPresent()) {
    SpongeMessage message=(SpongeMessage)this.subtitleMessage.get();
    packets.add(new S45PacketTitle(S45PacketTitle.Type.SUBTITLE,message.getHandle()));
  }
  return packets;
}","@SuppressWarnings(""String_Node_Str"") public List<S45PacketTitle> getPackets(){
  List<S45PacketTitle> packets=Lists.newArrayList();
  if (this.isReset) {
    packets.add(new S45PacketTitle(S45PacketTitle.Type.RESET,null));
  }
 else   if (this.isClear) {
    packets.add(new S45PacketTitle(S45PacketTitle.Type.CLEAR,null));
  }
  if (this.fadeIn.isPresent() && this.stay.isPresent() && this.fadeOut.isPresent()) {
    packets.add(new S45PacketTitle(this.fadeIn.get(),this.stay.get(),this.fadeOut.get()));
  }
  if (this.titleMessage.isPresent()) {
    SpongeMessage message=(SpongeMessage)this.titleMessage.get();
    packets.add(new S45PacketTitle(S45PacketTitle.Type.TITLE,message.getHandle()));
  }
  if (this.subtitleMessage.isPresent()) {
    SpongeMessage message=(SpongeMessage)this.subtitleMessage.get();
    packets.add(new S45PacketTitle(S45PacketTitle.Type.SUBTITLE,message.getHandle()));
  }
  return packets;
}"
27634,"private static void logChunkLoadOverride(ChunkProviderServer provider,int x,int z){
  logInfo(""String_Node_Str"",provider.chunkLoadOverride,provider.worldObj.provider.getDimensionId());
}","@SuppressWarnings(""String_Node_Str"") private static void logChunkLoadOverride(ChunkProviderServer provider,int x,int z){
  logInfo(""String_Node_Str"",provider.chunkLoadOverride,provider.worldObj.provider.getDimensionId());
}"
27635,"public static void logEntitySize(Entity entity,List list){
  SpongeConfig config=getActiveConfig(entity.worldObj);
  if (!config.logEntityCollisionChecks.getProperty().getBoolean()) {
    return;
  }
  int largeCountLogSize=config.largeCollisionLogSize.getProperty().getInt();
  if (list == null) {
    return;
  }
  int largeCollisionLogSize=config.largeCollisionLogSize.getProperty().getInt();
  if (largeCollisionLogSize > 0 && (MinecraftServer.getServer().getTickCounter() % 10) == 0 && list.size() >= largeCollisionLogSize) {
    SpongeHooks.CollisionWarning warning=new SpongeHooks.CollisionWarning(entity.worldObj,entity);
    if (recentWarnings.contains(warning)) {
      long lastWarned=recentWarnings.get(warning);
      if ((MinecraftServer.getCurrentTimeMillis() - lastWarned) < 30000) {
        return;
      }
    }
    recentWarnings.put(warning,System.currentTimeMillis());
    logWarning(""String_Node_Str"",largeCollisionLogSize,entity);
  }
}","@SuppressWarnings(""String_Node_Str"") public static void logEntitySize(Entity entity,List list){
  SpongeConfig config=getActiveConfig(entity.worldObj);
  if (!config.logEntityCollisionChecks.getProperty().getBoolean()) {
    return;
  }
  int largeCountLogSize=config.largeCollisionLogSize.getProperty().getInt();
  if (list == null) {
    return;
  }
  int largeCollisionLogSize=config.largeCollisionLogSize.getProperty().getInt();
  if (largeCollisionLogSize > 0 && (MinecraftServer.getServer().getTickCounter() % 10) == 0 && list.size() >= largeCollisionLogSize) {
    SpongeHooks.CollisionWarning warning=new SpongeHooks.CollisionWarning(entity.worldObj,entity);
    if (recentWarnings.contains(warning)) {
      long lastWarned=recentWarnings.get(warning);
      if ((MinecraftServer.getCurrentTimeMillis() - lastWarned) < 30000) {
        return;
      }
    }
    recentWarnings.put(warning,System.currentTimeMillis());
    logWarning(""String_Node_Str"",largeCollisionLogSize,entity);
  }
}"
27636,"@Overwrite public int handleHookRetraction(){
  ItemStack itemStack=null;
  int exp=0;
  if (this.ticksCatchable > 0) {
    itemStack=this.func_146033_f();
    exp=this.rand.nextInt(6) + 1;
  }
  PlayerRetractFishingLineEvent event=SpongeEventFactory.createPlayerRetractFishingLineEvent(SpongeMod.instance.getGame(),(Player)this.angler,this,(org.spongepowered.api.item.inventory.ItemStack)itemStack,(org.spongepowered.api.entity.Entity)this.caughtEntity,exp);
  byte b0=0;
  if (!SpongeMod.instance.getGame().getEventManager().post(event)) {
    exp=(int)event.getExp();
    if (event.getCaughtEntity().isPresent()) {
      this.caughtEntity=(Entity)event.getCaughtEntity().get();
      double entityitem=this.angler.posX - this.posX;
      double d2=this.angler.posY - this.posY;
      double d4=this.angler.posZ - this.posZ;
      double d6=MathHelper.sqrt_double(entityitem * entityitem + d2 * d2 + d4 * d4);
      double d8=0.1D;
      this.caughtEntity.motionX+=entityitem * d8;
      this.caughtEntity.motionY+=d2 * d8 + MathHelper.sqrt_double(d6) * 0.08D;
      this.caughtEntity.motionZ+=d4 * d8;
      b0=3;
    }
    if (event.getCaughtItem().isPresent()) {
      EntityItem entityitem1=new EntityItem(this.worldObj,this.posX,this.posY,this.posZ,(ItemStack)event.getCaughtItem().get());
      double d1=this.angler.posX - this.posX;
      double d3=this.angler.posY - this.posY;
      double d5=this.angler.posZ - this.posZ;
      double d7=MathHelper.sqrt_double(d1 * d1 + d3 * d3 + d5 * d5);
      double d9=0.1D;
      entityitem1.motionX=d1 * d9;
      entityitem1.motionY=d3 * d9 + MathHelper.sqrt_double(d7) * 0.08D;
      entityitem1.motionZ=d5 * d9;
      this.worldObj.spawnEntityInWorld(entityitem1);
      this.angler.worldObj.spawnEntityInWorld(new EntityXPOrb(this.angler.worldObj,this.angler.posX,this.angler.posY + 0.5D,this.angler.posZ + 0.5D,this.rand.nextInt(6) + 1));
      b0=1;
    }
    if (this.inGround) {
      b0=2;
    }
    this.setDead();
    this.angler.fishEntity=null;
    if (this.fishingRod != null) {
      this.fishingRod.damageItem(b0,this.angler);
      this.angler.swingItem();
      this.fishingRod=null;
    }
  }
  return b0;
}","@Overwrite public int handleHookRetraction(){
  ItemStack itemStack=null;
  int exp=0;
  if (this.ticksCatchable > 0) {
    itemStack=this.func_146033_f();
    exp=this.rand.nextInt(6) + 1;
  }
  PlayerRetractFishingLineEvent event=SpongeEventFactory.createPlayerRetractFishingLineEvent(SpongeMod.instance.getGame(),(Player)this.angler,this,(org.spongepowered.api.item.inventory.ItemStack)itemStack,(org.spongepowered.api.entity.Entity)this.caughtEntity,exp);
  byte b0=0;
  if (!SpongeMod.instance.getGame().getEventManager().post(event)) {
    exp=event.getExp();
    if (event.getCaughtEntity().isPresent()) {
      this.caughtEntity=(Entity)event.getCaughtEntity().get();
      double entityitem=this.angler.posX - this.posX;
      double d2=this.angler.posY - this.posY;
      double d4=this.angler.posZ - this.posZ;
      double d6=MathHelper.sqrt_double(entityitem * entityitem + d2 * d2 + d4 * d4);
      double d8=0.1D;
      this.caughtEntity.motionX+=entityitem * d8;
      this.caughtEntity.motionY+=d2 * d8 + MathHelper.sqrt_double(d6) * 0.08D;
      this.caughtEntity.motionZ+=d4 * d8;
      b0=3;
    }
    if (event.getCaughtItem().isPresent()) {
      EntityItem entityitem1=new EntityItem(this.worldObj,this.posX,this.posY,this.posZ,(ItemStack)event.getCaughtItem().get());
      double d1=this.angler.posX - this.posX;
      double d3=this.angler.posY - this.posY;
      double d5=this.angler.posZ - this.posZ;
      double d7=MathHelper.sqrt_double(d1 * d1 + d3 * d3 + d5 * d5);
      double d9=0.1D;
      entityitem1.motionX=d1 * d9;
      entityitem1.motionY=d3 * d9 + MathHelper.sqrt_double(d7) * 0.08D;
      entityitem1.motionZ=d5 * d9;
      this.worldObj.spawnEntityInWorld(entityitem1);
      this.angler.worldObj.spawnEntityInWorld(new EntityXPOrb(this.angler.worldObj,this.angler.posX,this.angler.posY + 0.5D,this.angler.posZ + 0.5D,this.rand.nextInt(6) + 1));
      b0=1;
    }
    if (this.inGround) {
      b0=2;
    }
    this.setDead();
    this.angler.fishEntity=null;
    if (this.fishingRod != null) {
      this.fishingRod.damageItem(b0,this.angler);
      this.angler.swingItem();
      this.fishingRod=null;
    }
  }
  return b0;
}"
27637,"@Subscribe @SuppressWarnings(""String_Node_Str"") public void handleModStateEvent(FMLStateEvent event){
  Class<? extends FMLEvent> eventClass=event.getClass();
  Class<? extends Event> spongeEvent=(Class<? extends Event>)EventRegistry.getAPIClass(eventClass);
  if (this.stateEventHandlers.containsKey(spongeEvent)) {
    Method method=null;
    try {
      for (      Method m : this.stateEventHandlers.get(spongeEvent)) {
        method=m;
        m.invoke(getMod(),event);
      }
    }
 catch (    Throwable t) {
      SpongeMod.instance.getLogger().error(""String_Node_Str"" + this.pluginClassName + ""String_Node_Str""+ method.getName(),t);
    }
  }
}","@Subscribe @SuppressWarnings(""String_Node_Str"") public void handleModStateEvent(FMLStateEvent event){
  Class<? extends FMLEvent> eventClass=event.getClass();
  Class<? extends Event> spongeEvent=(Class<? extends Event>)EventRegistry.getAPIClass(eventClass);
  if (this.stateEventHandlers.containsKey(spongeEvent)) {
    Method method=null;
    try {
      for (      Method m : this.stateEventHandlers.get(spongeEvent)) {
        method=m;
        m.invoke(getMod(),event);
      }
    }
 catch (    Throwable t) {
      SpongeMod.instance.getLogger().error(""String_Node_Str"" + this.pluginClassName + ""String_Node_Str""+ method.getName()+ ""String_Node_Str"",t);
    }
  }
}"
27638,"/** 
 * This method conflicts with a method in the target class and has precisely the same signature, this is to demonstrate how we deal with a method which would ordinarily fall foul of reobfuscation and thus break our (non-obfuscated) interface in a production environment
 */
public abstract boolean isUsingItem();","/** 
 * This method conflicts with a method in the target class and has precisely the same signature, this is to demonstrate how we deal with a method which would ordinarily fall foul of reobfuscation and thus break our (non-obfuscated) interface in a production environment
 * @return return value
 */
public abstract boolean isUsingItem();"
27639,"/** 
 * Additional method with no conflicts
 */
public abstract int norDoesThisOne();","/** 
 * Additional method with no conflicts
 * @return return value
 */
public abstract int norDoesThisOne();"
27640,"/** 
 * Additional method which doesn't conflict
 */
public abstract int thisMethodDoesNotConflict();","/** 
 * Additional method which doesn't conflict
 * @return return value
 */
public abstract int thisMethodDoesNotConflict();"
27641,"/** 
 * In   {@link EntityLivingBase}, this same method exists but returns a float. Whilst java bytecode would actually allow both methods to exist, the java compiler doesn't support this. This conflict is deliberately here to demostrate the use of the   {@link Implements} annotation in{@link MixinEntityPlayerExample}
 */
public abstract double getHealth();","/** 
 * In   {@link EntityLivingBase}, this same method exists but returns a float. Whilst java bytecode would actually allow both methods to exist, the java compiler doesn't support this. This conflict is deliberately here to demostrate the use of the   {@link Implements} annotation in{@link MixinWorldProviderExample}
 * @return return value
 */
public abstract double getHealth();"
27642,"/** 
 * Contrived example to deliberately create a name clash with World
 * @param x
 * @param y
 * @param z
 * @return
 */
public abstract Object getBlock(int x,int y,int z);","/** 
 * Contrived example to deliberately create a name clash with World
 * @param x The x coordinate
 * @param y The y coordinate
 * @param z The z coordinate
 * @return The block
 */
public abstract Object getBlock(int x,int y,int z);"
27643,"/** 
 * Stupid example
 */
public abstract int getAmbientTickCountdown();","/** 
 * Stupid example
 * @return return value
 */
public abstract int getAmbientTickCountdown();"
27644,"/** 
 * Even more tenuous example
 * @param x
 * @param y
 * @param z
 * @param block
 * @return
 */
public abstract int exampleMethodToComputeLightValue(int x,int y,int z,EnumSkyBlock block);","/** 
 * Even more tenuous example
 * @param x The x coordinate
 * @param y The y coordinate
 * @param z The z coordinate
 * @param block The SkyBlock value
 * @return The calculated light
 */
public abstract int exampleMethodToComputeLightValue(int x,int y,int z,EnumSkyBlock block);"
27645,"/** 
 * ctor, not used
 */
public MixinEntityPlayerExample(World worldIn){
  super(worldIn);
}","/** 
 * ctor, not used
 * @param worldIn The world to spawn the player in
 */
public MixinEntityPlayerExample(World worldIn){
  super(worldIn);
}"
27646,"/** 
 * Conflicting method, now magically safe to implement because the prefix makes it compile
 */
public double entityPlayer$getHealth(){
  return this.getHealth();
}","/** 
 * Conflicting method, now magically safe to implement because the prefix makes it compile
 * @return The player's health
 */
public double entityPlayer$getHealth(){
  return this.getHealth();
}"
27647,"/** 
 * <p>This comes first in the file for a reason, but you should read the javadoc for   {@link #isUsingItem} first, then come back and read this...Go on! Do it!</p> <p>Okay, so you understand why we have the method below, it injects our custom code in the target class's method by overwriting the method body with the new code. However in order to preserve that functionality across the obfuscation boundary we need to tag it with {@link Overwrite}.</p> <p>The magic happens here. Because this method is <b>not</b> tagged with   {@link Overwrite}, it will <b>not</b> be obfuscated at build time, this means it still implements the interface. At dev time, the method below (because it appears <b>after</b> this one) will be injected and will <em>overwrite <b>this</b> method</em>. This is exactly what we want to happen, because otherwise this method (at dev time) would actually end up just calling itself recursively!</p> <p>However, post-obfuscation, this method magically becomes an accessor for the (now renamed) isUsingItem() in the target class, and thus allows <em>both</em> the custom code to be injected into the original method (by the declaration below) <em>and</em> the interface to be implemented all at once.<p> <p>See the example below for where custom code is <b>not</b> required in the accessor</p>.
 */
public boolean entityPlayer$isUsingItem(){
  return this.isUsingItem();
}","/** 
 * <p>This comes first in the file for a reason, but you should read the javadoc for   {@link #isUsingItem} first, then come back and read this...Go on! Do it!</p> <p>Okay, so you understand why we have the method below, it injects our custom code in the target class's method by overwriting the method body with the new code. However in order to preserve that functionality across the obfuscation boundary we need to tag it with {@link Overwrite}.</p> <p>The magic happens here. Because this method is <b>not</b> tagged with   {@link Overwrite}, it will <b>not</b> be obfuscated at build time, this means it still implements the interface. At dev time, the method below (because it appears <b>after</b> this one) will be injected and will <em>overwrite <b>this</b> method</em>. This is exactly what we want to happen, because otherwise this method (at dev time) would actually end up just calling itself recursively!</p> <p>However, post-obfuscation, this method magically becomes an accessor for the (now renamed) isUsingItem() in the target class, and thus allows <em>both</em> the custom code to be injected into the original method (by the declaration below) <em>and</em> the interface to be implemented all at once.</p> <p>See the example below for where custom code is <b>not</b> required in the accessor</p>.
 * @return Whether the player is using the item
 */
public boolean entityPlayer$isUsingItem(){
  return this.isUsingItem();
}"
27648,"/** 
 * <p>It should be pretty obvious that because this method exists in target class   {@link EntityPlayer} <em>and</em> in the interface{@link IEntityPlayerConflict} that we don't <em>actually</em> need an implementation here at dev time, because the underlying method in thetarget class already implicitly 'implements' the method in the interface. We only need to  {@link Overwrite} it if we need to include somecustom functionality as shown here. However of course the problems start when we traverse the obfuscation boundary, since the method ends up actually named ""func_71039_bw"" and thus no longer implements the interface!</p> <p>We need the  {@link Overwrite} annotation in order to have this method renamed, but we don't want to break the interface. So how do we dothat? See  {@link #entityPlayer$isUsingItem} above for how.</p>
 */
@Overwrite public boolean isUsingItem(){
  this.doSomethingCustom();
  return this.itemInUse != null;
}","/** 
 * <p>It should be pretty obvious that because this method exists in target class   {@link EntityPlayer} <em>and</em> in the interface{@link IEntityPlayerConflict} that we don't <em>actually</em> need an implementation here at dev time, because the underlying method in thetarget class already implicitly 'implements' the method in the interface. We only need to  {@link Overwrite} it if we need to include somecustom functionality as shown here. However of course the problems start when we traverse the obfuscation boundary, since the method ends up actually named ""func_71039_bw"" and thus no longer implements the interface!</p> <p>We need the  {@link Overwrite} annotation in order to have this method renamed, but we don't want to break the interface. So how do we dothat? See  {@link #entityPlayer$isUsingItem} above for how.</p>
 * @return Whether the player is using the item
 */
@Overwrite public boolean isUsingItem(){
  this.doSomethingCustom();
  return this.itemInUse != null;
}"
27649,"/** 
 * This non-conflicting method is also prefixed, this is recommended for soft implementations because there is no   {@link Override} annotation andthus if the method in the underlying interface changes, there is no compile-time error which indicates this. By using the prefix even on non-conflicting methods, the transformer can verify that the method exists in the target interface at application time.
 */
public int entityPlayer$thisMethodDoesNotConflict(){
  return 0;
}","/** 
 * This non-conflicting method is also prefixed, this is recommended for soft implementations because there is no   {@link Override} annotation andthus if the method in the underlying interface changes, there is no compile-time error which indicates this. By using the prefix even on non-conflicting methods, the transformer can verify that the method exists in the target interface at application time.
 * @return The number 0
 */
public int entityPlayer$thisMethodDoesNotConflict(){
  return 0;
}"
27650,"/** 
 * This method doesn't conflict, but is not tagged with the prefix. Whilst this is totally legal, it's a bad idea because there is then no way to detect errors when the underlying interface changes, see the notes on   {@link #entityPlayer$thisMethodDoesNotConflict}
 */
public int norDoesThisOne(){
  return 0;
}","/** 
 * This method doesn't conflict, but is not tagged with the prefix. Whilst this is totally legal, it's a bad idea because there is then no way to detect errors when the underlying interface changes, see the notes on   {@link #entityPlayer$thisMethodDoesNotConflict}
 * @return The number 0
 */
public int norDoesThisOne(){
  return 0;
}"
27651,"/** 
 * <p>  {@link Redirect} annotations allow a method call to be proxied or even completely suppressed by redirecting the original method call to theannotated method.</p> <p>In this example, the  {@link MobSpawnerBaseLogic#resetTimer} method is hooked and redirected to this handler. The signature of the hookmethod must match the redirected method precisely with the addition of a new first argument which must match the type of the invocation's target, in this case  {@link MobSpawnerBaseLogic}. This first variable accepts the reference that the method was going to be invoked upon prior to being redirected.</p> <p>The benefit with   {@link Redirect} versus ordinary method call injections, is that the call to the method can be conditionally suppressed ifrequired, and also allows a more sophisticated version of  {@link ModifyArg} to be enacted since all parameters are available to the hook methodand can be altered as required.</p> <p>For <em>static</em> methods the handler must also be <em>static</em>, and the first argument can be omitted.</p> 
 */
@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) private void onResetTimer(MobSpawnerBaseLogic this$0){
  System.err.println(""String_Node_Str"" + this + ""String_Node_Str"");
  boolean someCondition=true;
  if (someCondition) {
    this.resetTimer();
  }
}","/** 
 * <p>  {@link Redirect} annotations allow a method call to be proxied or even completely suppressed by redirecting the original method call to theannotated method.</p> <p>In this example, the  {@link MobSpawnerBaseLogic#resetTimer} method is hooked and redirected to this handler. The signature of the hookmethod must match the redirected method precisely with the addition of a new first argument which must match the type of the invocation's target, in this case  {@link MobSpawnerBaseLogic}. This first variable accepts the reference that the method was going to be invoked upon prior to being redirected.</p> <p>The benefit with   {@link Redirect} versus ordinary method call injections, is that the call to the method can be conditionally suppressed ifrequired, and also allows a more sophisticated version of  {@link ModifyArg} to be enacted since all parameters are available to the hook methodand can be altered as required.</p> <p>For <em>static</em> methods the handler must also be <em>static</em>, and the first argument can be omitted.</p>
 * @param this$0 this$0
 */
@Redirect(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) private void onResetTimer(MobSpawnerBaseLogic this$0){
  System.err.println(""String_Node_Str"" + this + ""String_Node_Str"");
  boolean someCondition=true;
  if (someCondition) {
    this.resetTimer();
  }
}"
27652,"/** 
 * <p>If you pay a brief visit to   {@link MobSpawnerBaseLogic#updateSpawner} you'll notice the following calls in the method body:</p> <blockquote><pre> this.getSpawnerWorld().spawnParticle(EnumParticleTypes.SMOKE_NORMAL, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]); this.getSpawnerWorld().spawnParticle(EnumParticleTypes.FLAME, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]);</pre> </blockquote> <p>The purpose of the  {@link ModifyArg} annotation is to modify <b>exactly one<b> argument from a method invokation. Specifically by havingthe annotated callback method <em>receive</em> and then <em>return</em> the value in question. This allows the method call to be ""proxied"" in a limited way, modifying a single argument.</p> <p>Two variations of this hook are available:</p> <ul> <li>The single-argument hook simply accepts <b>only</b> the argument in question. If there is only a single argument of that type then no further information is required and the hook will receive and then return the modified value. In our example this would be leveraged by a method with the signature <code>private EnumParticleTypes onSpawnParticle(EnumParticleTypes pt)</code> because there is only a single argument with the <em>EnumParticleTypes</em> type in the method signature. For methods with multiple args of the same type, the <em>index </em> property must be specified to identify the target argument.</li> <li>The multi-argument hook accepts <b>all</b> the original arguments to the method (as in this example) but can only modify the argument specified by the <em>return type</em> of the hook method. If multiple args of the same type exist, then the <em>index</em> property must likewise be specified.</li> </ul> <p>This hook does not interrupt the normal execution of the method, it only allows a single parameter to be modified.</p> 
 */
@ModifyArg(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) private EnumParticleTypes onSpawnParticle(EnumParticleTypes pt,double x,double y,double z,double a,double b,double c,int... params){
  if (pt == EnumParticleTypes.SMOKE_NORMAL) {
    return EnumParticleTypes.SPELL;
  }
 else   if (pt == EnumParticleTypes.FLAME) {
    return EnumParticleTypes.HEART;
  }
  return pt;
}","/** 
 * <p>If you pay a brief visit to   {@link MobSpawnerBaseLogic#updateSpawner} you'll notice the following calls in the method body:</p> <blockquote><pre> this.getSpawnerWorld().spawnParticle(EnumParticleTypes.SMOKE_NORMAL, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]); this.getSpawnerWorld().spawnParticle(EnumParticleTypes.FLAME, d0, d1, d2, 0.0D, 0.0D, 0.0D, new int[0]);</pre> </blockquote> <p>The purpose of the  {@link ModifyArg} annotation is to modify <b>exactly one<b> argument from a method invokation. Specifically by havingthe annotated callback method <em>receive</em> and then <em>return</em> the value in question. This allows the method call to be ""proxied"" in a limited way, modifying a single argument.</p> <p>Two variations of this hook are available:</p> <ul> <li>The single-argument hook simply accepts <b>only</b> the argument in question. If there is only a single argument of that type then no further information is required and the hook will receive and then return the modified value. In our example this would be leveraged by a method with the signature <code>private EnumParticleTypes onSpawnParticle(EnumParticleTypes pt)</code> because there is only a single argument with the <em>EnumParticleTypes</em> type in the method signature. For methods with multiple args of the same type, the <em>index </em> property must be specified to identify the target argument.</li> <li>The multi-argument hook accepts <b>all</b> the original arguments to the method (as in this example) but can only modify the argument specified by the <em>return type</em> of the hook method. If multiple args of the same type exist, then the <em>index</em> property must likewise be specified.</li> </ul> <p>This hook does not interrupt the normal execution of the method, it only allows a single parameter to be modified.</p>
 * @param x The x coordinate
 * @param y The y coordinate
 * @param z The z coordinate
 * @param a a
 * @param b b
 * @param c c
 * @param params params
 */
@ModifyArg(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) private EnumParticleTypes onSpawnParticle(EnumParticleTypes pt,double x,double y,double z,double a,double b,double c,int... params){
  if (pt == EnumParticleTypes.SMOKE_NORMAL) {
    return EnumParticleTypes.SPELL;
  }
 else   if (pt == EnumParticleTypes.FLAME) {
    return EnumParticleTypes.HEART;
  }
  return pt;
}"
27653,"/** 
 * This method implements getBlock from the   {@link IWorld} interface. However since the method signature overlaps with the ""getBlock"" methodabove, it is necessary to use the  {@link Shadow#prefix} functionality in the {@link Shadow} annotation to prevent a name clash at compiletime.
 * @see org.spongepowered.exampleinterfaces.IWorld#getBlock(int,int,int)
 */
@Override public Object getBlock(int x,int y,int z){
  return this.shadow$getBlockState(new BlockPos(x,y,z)).getBlock();
}","/** 
 * This method implements getBlock from the   {@link IWorld} interface. However since the method signature overlaps with the ""getBlock"" methodabove, it is necessary to use the  {@link Shadow#prefix} functionality in the {@link Shadow} annotation to prevent a name clash at compiletime.
 * @see org.spongepowered.exampleinterfaces.IWorld#getBlock(int,int,int)
 * @param x The x coordinate
 * @param y The y coordinate
 * @param z The z coordinate
 * @return The block
 */
@Override public Object getBlock(int x,int y,int z){
  return this.shadow$getBlockState(new BlockPos(x,y,z)).getBlock();
}"
27654,"/** 
 * <b>Overwrites</b> the <em>NotifyBlockChange</em> method in the target class
 * @param pos
 * @param block
 */
@Overwrite public void func_175722_b(BlockPos pos,Block block){
  this.notifyNeighborsOfStateChange(pos,block);
}","/** 
 * <b>Overwrites</b> the <em>NotifyBlockChange</em> method in the target class
 * @param pos The block location
 * @param block The block
 */
@Overwrite public void func_175722_b(BlockPos pos,Block block){
  this.notifyNeighborsOfStateChange(pos,block);
}"
27655,"/** 
 * This shadow method demonstrates use of the ""prefix"" option in the   {@link Shadow} annotation. Since it is not possible to have two methods in aa class which differ only on return type, this can create problems when a shadow method overlaps with a method in an interface being implemented by a mixin. Luckily, the JVM itself actually supports such overlaps, and thus we can work around the problem by renaming the overlapping methods at runtime. Using the ""prefix"" option allows this behaviour to be leveraged. For more details see  {@link Shadow#prefix}.
 * @param pos
 * @return
 */
@Shadow(prefix=""String_Node_Str"") abstract IBlockState shadow$getBlockState(BlockPos pos);","/** 
 * This shadow method demonstrates use of the ""prefix"" option in the   {@link Shadow} annotation. Since it is not possible to have two methods in aa class which differ only on return type, this can create problems when a shadow method overlaps with a method in an interface being implemented by a mixin. Luckily, the JVM itself actually supports such overlaps, and thus we can work around the problem by renaming the overlapping methods at runtime. Using the ""prefix"" option allows this behaviour to be leveraged. For more details see  {@link Shadow#prefix}.
 * @param pos The position
 * @return The blockstate
 */
@Shadow(prefix=""String_Node_Str"") abstract IBlockState shadow$getBlockState(BlockPos pos);"
27656,"/** 
 * <p>What's this? A parameterised   {@link At}? Surely not!</p> <p>  {@link org.spongepowered.asm.mixin.injection.points.MethodHead HEAD} and{@link org.spongepowered.asm.mixin.injection.points.BeforeReturn RETURN} are only two of the available values for {@link At} types and are themost straightforward to understand. HEAD only ever makes a single injection (at the head of the method) and RETURN injects before <em>every RETURN opcode</em> in a method. Other injection types are available however:<p> <dl> <dt> {@link org.spongepowered.asm.mixin.injection.points.BeforeInvoke INVOKE}</dt> <dd>searches for method invocations matching its parameters and injects immediately prior to any matching invocations</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.BeforeFieldAccess FIELD}</dt> <dd>searches for field accesses (get or set) matching its parameters and injects immediately prior to any matching access</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.BeforeNew NEW}</dt> <dd>searches for object instantiation (<b>new</b> keywords) matching its parameters and injects prior to the NEW opcode</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.BeforeStringInvoke INVOKE_STRING}</dt> <dd>is a specialised version of INVOKE which searches for a method invocation of a method which accepts a single String argument and also matches the specified string literal. This is very useful for finding calls to Profiler::startSection() with a particular argument.</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.JumpInsnPoint JUMP}</dt> <dd>searches for specific JUMP opcodes</dd> <dt><em>Fully-qualified class name</em></dt> <dd>Allows you to specify a custom class which extends   {@link org.spongepowered.asm.mixin.injection.InjectionPoint} to implement any customlogic you wish</dd> </dl> <p>The specific arguments accepted by each type of invokation are described in each class's javadoc. This example shows a simple use of the INVOKE type.</p> <p>This is what the code in the target method looks like: <blockquote><pre> this.worldObj = worldIn; this.terrainType = worldIn.getWorldInfo().getTerrainType(); this.generatorSettings = worldIn.getWorldInfo().getGeneratorOptions(); // we want to inject a callback to our method here, immediately prior to calling registerWorldChunkManager this.registerWorldChunkManager(); this.generateLightBrightnessTable(); </pre></blockquote> Having identified the target method, we simply supply the method name as the <em>target</em> argument to the  {@link At} annotation. Note thatunlike the <em>method</em> parameter (which <b>must</b> refer to a method in the target class) the <em>target</em> parameter for the  {@link At}<b>must</b> be a <em>fully-qualified</em> member reference (include both the owner and signature) because the obfuscation processor requires this information in order to look up the target member in the obfuscation tables.</p>
 */
@Inject(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) public void onRegisterWorld(World worldIn,CallbackInfo ci){
}","/** 
 * <p>What's this? A parameterised   {@link At}? Surely not!</p> <p>  {@link org.spongepowered.asm.mixin.injection.points.MethodHead HEAD} and{@link org.spongepowered.asm.mixin.injection.points.BeforeReturn RETURN} are only two of the available values for {@link At} types and are themost straightforward to understand. HEAD only ever makes a single injection (at the head of the method) and RETURN injects before <em>every RETURN opcode</em> in a method. Other injection types are available however:</p> <dl> <dt> {@link org.spongepowered.asm.mixin.injection.points.BeforeInvoke INVOKE}</dt> <dd>searches for method invocations matching its parameters and injects immediately prior to any matching invocations</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.BeforeFieldAccess FIELD}</dt> <dd>searches for field accesses (get or set) matching its parameters and injects immediately prior to any matching access</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.BeforeNew NEW}</dt> <dd>searches for object instantiation (<b>new</b> keywords) matching its parameters and injects prior to the NEW opcode</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.BeforeStringInvoke INVOKE_STRING}</dt> <dd>is a specialised version of INVOKE which searches for a method invocation of a method which accepts a single String argument and also matches the specified string literal. This is very useful for finding calls to Profiler::startSection() with a particular argument.</dd> <dt>  {@link org.spongepowered.asm.mixin.injection.points.JumpInsnPoint JUMP}</dt> <dd>searches for specific JUMP opcodes</dd> <dt><em>Fully-qualified class name</em></dt> <dd>Allows you to specify a custom class which extends   {@link org.spongepowered.asm.mixin.injection.InjectionPoint} to implement any customlogic you wish</dd> </dl> <p>The specific arguments accepted by each type of invokation are described in each class's javadoc. This example shows a simple use of the INVOKE type.</p> <p>This is what the code in the target method looks like:</p> <blockquote><pre> this.worldObj = worldIn; this.terrainType = worldIn.getWorldInfo().getTerrainType(); this.generatorSettings = worldIn.getWorldInfo().getGeneratorOptions(); // we want to inject a callback to our method here, immediately prior to calling registerWorldChunkManager this.registerWorldChunkManager(); this.generateLightBrightnessTable(); </pre></blockquote> <p>Having identified the target method, we simply supply the method name as the <em>target</em> argument to the  {@link At} annotation. Note thatunlike the <em>method</em> parameter (which <b>must</b> refer to a method in the target class) the <em>target</em> parameter for the  {@link At}<b>must</b> be a <em>fully-qualified</em> member reference (include both the owner and signature) because the obfuscation processor requires this information in order to look up the target member in the obfuscation tables.</p>
 * @param worldIn The world to register
 * @param ci The callback on register
 */
@Inject(method=""String_Node_Str"",at=@At(value=""String_Node_Str"",target=""String_Node_Str"")) public void onRegisterWorld(World worldIn,CallbackInfo ci){
}"
27657,"/** 
 * <p>This method demonstrates injecting into a method with a return value. Notice that we take the original method, change the return type to <b>void</b> and add a   {@link CallbackInfoReturnable} with the original return type ({@link Vec3}) as the type parameter.</p> <p>This method also demonstrates a more precise syntax for identifying the target method. This is useful if there are several methods in the target class with the same name. We simply append the bytecode descriptor of the target method to the method name. For more details on this syntax see the javadoc in   {@link org.spongepowered.asm.mixin.injection.struct.MemberInfo}.</p> <p>The   {@link At} specified HEAD will inject the callback at the top of the method (before all other code).</p>
 */
@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str"")) @SideOnly(Side.CLIENT) public void onGetFogColor(float celestialAngle,float partialTicks,CallbackInfoReturnable<Vec3> cir){
}","/** 
 * <p>This method demonstrates injecting into a method with a return value. Notice that we take the original method, change the return type to <b>void</b> and add a   {@link CallbackInfoReturnable} with the original return type ({@link Vec3}) as the type parameter.</p> <p>This method also demonstrates a more precise syntax for identifying the target method. This is useful if there are several methods in the target class with the same name. We simply append the bytecode descriptor of the target method to the method name. For more details on this syntax see the javadoc in   {@link org.spongepowered.asm.mixin.injection.struct.MemberInfo}.</p> <p>The   {@link At} specified HEAD will inject the callback at the top of the method (before all other code).</p>
 * @param celestialAngle The celestial angle
 * @param partialTicks The partial ticks
 * @param cir The callback
 */
@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str"")) @SideOnly(Side.CLIENT) public void onGetFogColor(float celestialAngle,float partialTicks,CallbackInfoReturnable<Vec3> cir){
}"
27658,"/** 
 * <p>This method demonstrates the use of the <em>cancellable</em> argument for an injection. Specifying that an injection is <em>cancellable</em> allows us to supply our own return values and short-circuit the target method's normal logic.</p> <p>Choosing the appropriate   {@link At} is very important when dealing with cancellable callbacks. For example you may with to be able to""short-circuit"" a method by injecting at the HEAD and cancelling it if you don't want the method to be executed. However if you want the method to execute but be able to change the result, then injecting at RETURN makes more sense. Injecting at RETURN also allows you to see the value the method was going to return and optionally change it. The  {@link CallbackInfoReturnable#getReturnValue} method can be used to get the returnvalue from the stack, but <b>only</b> when using the RETURN injection point.</p> <p>It should be noted that it's perfectly possible to specify <em>cancellable</em> when injecting into a method which returns void, but with the key difference being that it's not possible to fetch the return value (because there isn't one) or set a return value (because there isn't one!) but it is still perfectly possible to short-circuit a method in this way.</p> 
 */
@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str""),cancellable=true) public void onCanCoordinateBeSpawn(int x,int z,CallbackInfoReturnable<Boolean> cir){
  int coordinateWeDontLike=666;
  if (x == coordinateWeDontLike || z == coordinateWeDontLike) {
    if (cir.getReturnValue()) {
      System.err.println(""String_Node_Str"" + this + ""String_Node_Str""+ x+ ""String_Node_Str""+ z+ ""String_Node_Str"");
    }
    cir.setReturnValue(false);
  }
}","/** 
 * <p>This method demonstrates the use of the <em>cancellable</em> argument for an injection. Specifying that an injection is <em>cancellable</em> allows us to supply our own return values and short-circuit the target method's normal logic.</p> <p>Choosing the appropriate   {@link At} is very important when dealing with cancellable callbacks. For example you may with to be able to""short-circuit"" a method by injecting at the HEAD and cancelling it if you don't want the method to be executed. However if you want the method to execute but be able to change the result, then injecting at RETURN makes more sense. Injecting at RETURN also allows you to see the value the method was going to return and optionally change it. The  {@link CallbackInfoReturnable#getReturnValue} method can be used to get the returnvalue from the stack, but <b>only</b> when using the RETURN injection point.</p> <p>It should be noted that it's perfectly possible to specify <em>cancellable</em> when injecting into a method which returns void, but with the key difference being that it's not possible to fetch the return value (because there isn't one) or set a return value (because there isn't one!) but it is still perfectly possible to short-circuit a method in this way.</p>
 * @param x The x coordinate
 * @param z The z coordinate
 * @param cir The callback
 */
@Inject(method=""String_Node_Str"",at=@At(""String_Node_Str""),cancellable=true) public void onCanCoordinateBeSpawn(int x,int z,CallbackInfoReturnable<Boolean> cir){
  int coordinateWeDontLike=666;
  if (x == coordinateWeDontLike || z == coordinateWeDontLike) {
    if (cir.getReturnValue()) {
      System.err.println(""String_Node_Str"" + this + ""String_Node_Str""+ x+ ""String_Node_Str""+ z+ ""String_Node_Str"");
    }
    cir.setReturnValue(false);
  }
}"
27659,"@Override public boolean setLocation(Location location){
  if (isRemoved()) {
    return false;
  }
  Entity spongeEntity=(Entity)this;
  net.minecraft.entity.Entity thisEntity=(net.minecraft.entity.Entity)spongeEntity;
  net.minecraft.entity.Entity passenger=thisEntity.riddenByEntity;
  ArrayDeque<net.minecraft.entity.Entity> passengers=new ArrayDeque<net.minecraft.entity.Entity>();
  while (passenger != null) {
    if (passenger instanceof EntityPlayerMP && !this.worldObj.isRemote) {
      ((EntityPlayerMP)passenger).mountEntity(null);
    }
    net.minecraft.entity.Entity nextPassenger=null;
    if (passenger.riddenByEntity != null) {
      nextPassenger=passenger.riddenByEntity;
      this.riddenByEntity.mountEntity(null);
    }
    passengers.add(passenger);
    passenger=nextPassenger;
  }
  net.minecraft.world.World nmsWorld=null;
  if (location.getExtent() instanceof World && ((net.minecraft.world.World)location.getExtent() != this.worldObj)) {
    if (!(thisEntity instanceof EntityPlayer)) {
      nmsWorld=(net.minecraft.world.World)location.getExtent();
      teleportEntity(thisEntity,location,thisEntity.dimension,nmsWorld.provider.getDimensionId());
    }
  }
 else {
    setPosition(location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ());
  }
  net.minecraft.entity.Entity lastPassenger=thisEntity;
  while (!passengers.isEmpty()) {
    net.minecraft.entity.Entity passengerEntity=passengers.remove();
    if (nmsWorld != null) {
      teleportEntity(passengerEntity,location,passengerEntity.dimension,nmsWorld.provider.getDimensionId());
    }
    if (passengerEntity instanceof EntityPlayerMP && !this.worldObj.isRemote) {
      ((ISpongeEntity)passengerEntity).setIsTeleporting(true);
      ((ISpongeEntity)passengerEntity).setTeleportVehicle(lastPassenger);
    }
 else {
      passengerEntity.mountEntity(lastPassenger);
    }
    lastPassenger=passengerEntity;
  }
  return true;
}","@Override public boolean setLocation(Location location){
  if (isRemoved()) {
    return false;
  }
  Entity spongeEntity=(Entity)this;
  net.minecraft.entity.Entity thisEntity=(net.minecraft.entity.Entity)spongeEntity;
  net.minecraft.entity.Entity passenger=thisEntity.riddenByEntity;
  ArrayDeque<net.minecraft.entity.Entity> passengers=new ArrayDeque<net.minecraft.entity.Entity>();
  while (passenger != null) {
    if (passenger instanceof EntityPlayerMP && !this.worldObj.isRemote) {
      ((EntityPlayerMP)passenger).mountEntity(null);
    }
    net.minecraft.entity.Entity nextPassenger=null;
    if (passenger.riddenByEntity != null) {
      nextPassenger=passenger.riddenByEntity;
      this.riddenByEntity.mountEntity(null);
    }
    passengers.add(passenger);
    passenger=nextPassenger;
  }
  net.minecraft.world.World nmsWorld=null;
  if (location.getExtent() instanceof World && ((net.minecraft.world.World)location.getExtent() != this.worldObj)) {
    if (!(thisEntity instanceof EntityPlayer)) {
      nmsWorld=(net.minecraft.world.World)location.getExtent();
      teleportEntity(thisEntity,location,thisEntity.dimension,nmsWorld.provider.getDimensionId());
    }
  }
 else {
    setPosition(location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ());
    if (thisEntity instanceof EntityPlayerMP) {
      ((EntityPlayerMP)thisEntity).playerNetServerHandler.setPlayerLocation(location.getPosition().getX(),location.getPosition().getY(),location.getPosition().getZ(),thisEntity.rotationYaw,thisEntity.rotationPitch);
    }
  }
  net.minecraft.entity.Entity lastPassenger=thisEntity;
  while (!passengers.isEmpty()) {
    net.minecraft.entity.Entity passengerEntity=passengers.remove();
    if (nmsWorld != null) {
      teleportEntity(passengerEntity,location,passengerEntity.dimension,nmsWorld.provider.getDimensionId());
    }
    if (passengerEntity instanceof EntityPlayerMP && !this.worldObj.isRemote) {
      ((ISpongeEntity)passengerEntity).setIsTeleporting(true);
      ((ISpongeEntity)passengerEntity).setTeleportVehicle(lastPassenger);
    }
 else {
      passengerEntity.mountEntity(lastPassenger);
    }
    lastPassenger=passengerEntity;
  }
  return true;
}"
27660,"@SuppressWarnings(""String_Node_Str"") @Overwrite private void doModEntityRegistration(Class<? extends Entity> entityClass,String entityName,int id,Object mod,int trackingRange,int updateFrequency,boolean sendsVelocityUpdates){
  ModContainer mc=FMLCommonHandler.instance().findContainerFor(mod);
  EntityRegistration er=EntityRegistry.instance().new EntityRegistration(mc,entityClass,entityName,id,trackingRange,updateFrequency,sendsVelocityUpdates);
  try {
    this.entityClassRegistrations.put(entityClass,er);
    this.entityNames.put(entityName,mc);
    if (!EntityList.classToStringMapping.containsKey(entityClass)) {
      String entityModName=String.format(""String_Node_Str"",mc.getModId(),entityName);
      EntityList.classToStringMapping.put(entityClass,entityModName);
      EntityList.stringToClassMapping.put(entityModName,entityClass);
      FMLLog.finer(""String_Node_Str"",mc.getModId(),entityName,entityModName);
    }
 else {
      FMLLog.fine(""String_Node_Str"",mc.getModId(),entityClass.getName());
    }
  }
 catch (  IllegalArgumentException e) {
    FMLLog.log(Level.WARN,e,""String_Node_Str"",mc.getModId(),entityName,entityClass.getName());
    return;
  }
  this.entityRegistrations.put(mc,er);
  registerCustomEntity(entityClass,entityName,id,mod,trackingRange,updateFrequency,sendsVelocityUpdates);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void doModEntityRegistration(Class<? extends Entity> entityClass,String entityName,int id,Object mod,int trackingRange,int updateFrequency,boolean sendsVelocityUpdates){
  ModContainer mc=FMLCommonHandler.instance().findContainerFor(mod);
  EntityRegistration er=EntityRegistry.instance().new EntityRegistration(mc,entityClass,entityName,id,trackingRange,updateFrequency,sendsVelocityUpdates);
  try {
    this.entityClassRegistrations.put(entityClass,er);
    this.entityNames.put(entityName,mc);
    if (!EntityList.classToStringMapping.containsKey(entityClass)) {
      String entityModName=String.format(""String_Node_Str"",mc.getModId(),entityName);
      EntityList.classToStringMapping.put(entityClass,entityModName);
      EntityList.stringToClassMapping.put(entityModName,entityClass);
      FMLLog.finer(""String_Node_Str"",mc.getModId(),entityName,entityModName);
    }
 else {
      FMLLog.fine(""String_Node_Str"",mc.getModId(),entityClass.getName());
    }
  }
 catch (  IllegalArgumentException e) {
    FMLLog.log(Level.WARN,e,""String_Node_Str"",mc.getModId(),entityName,entityClass.getName());
    return;
  }
  this.entityRegistrations.put(mc,er);
  registerCustomEntity(entityClass,entityName,id,mod,trackingRange,updateFrequency,sendsVelocityUpdates);
}"
27661,"@Overwrite public static boolean registerProviderType(int id,Class<? extends WorldProvider> provider,boolean keepLoaded){
  if (providers.containsKey(id)) {
    return false;
  }
  String worldType=""String_Node_Str"";
switch (id) {
case -1:
    worldType=""String_Node_Str"";
  break;
case 0:
worldType=""String_Node_Str"";
break;
case 1:
worldType=""String_Node_Str"";
break;
default :
worldType=provider.getSimpleName().toLowerCase();
worldType=worldType.replace(""String_Node_Str"",""String_Node_Str"");
worldType=worldType.replace(""String_Node_Str"",""String_Node_Str"");
}
((SpongeGameRegistry)SpongeMod.instance.getGame().getRegistry()).registerEnvironment(new SpongeDimensionType(worldType,keepLoaded,provider));
providers.put(id,provider);
spawnSettings.put(id,keepLoaded);
return true;
}","public static boolean registerProviderType(int id,Class<? extends WorldProvider> provider,boolean keepLoaded){
  if (providers.containsKey(id)) {
    return false;
  }
  String worldType=""String_Node_Str"";
switch (id) {
case -1:
    worldType=""String_Node_Str"";
  break;
case 0:
worldType=""String_Node_Str"";
break;
case 1:
worldType=""String_Node_Str"";
break;
default :
worldType=provider.getSimpleName().toLowerCase();
worldType=worldType.replace(""String_Node_Str"",""String_Node_Str"");
worldType=worldType.replace(""String_Node_Str"",""String_Node_Str"");
}
((SpongeGameRegistry)SpongeMod.instance.getGame().getRegistry()).registerEnvironment(new SpongeDimensionType(worldType,keepLoaded,provider));
providers.put(id,provider);
spawnSettings.put(id,keepLoaded);
return true;
}"
27662,@Shadow public abstract boolean isAllowedOnBooks();,@Shadow(remap=false) public abstract boolean isAllowedOnBooks();
27663,"@Inject(method=""String_Node_Str"",at={@At(value=""String_Node_Str"",target=""String_Node_Str""),@At(value=""String_Node_Str"",target=""String_Node_Str"")}) private void onUpdateWeatherBody(CallbackInfo ci){
  this.weatherStartTime=this.worldInfo.getWorldTotalTime();
}","@Inject(method=""String_Node_Str"",remap=false,at={@At(value=""String_Node_Str"",target=""String_Node_Str""),@At(value=""String_Node_Str"",target=""String_Node_Str"")}) private void onUpdateWeatherBody(CallbackInfo ci){
  this.weatherStartTime=this.worldInfo.getWorldTotalTime();
}"
27664,"@Override public int getMinimumEnchantabilityForLevel(int level){
  return shadow$getMinEnchantability(level);
}","@Override public int getMinimumEnchantabilityForLevel(int level){
  return getMinEnchantability(level);
}"
27665,"@Override public String getId(){
  return ids.get(this).toString();
}","@Override public String getId(){
  for (  Entry<ResourceLocation,net.minecraft.enchantment.Enchantment> entry : field_180307_E.entrySet()) {
    if (entry.getValue().equals(this)) {
      return entry.getKey().toString();
    }
  }
  return null;
}"
27666,"@Override public boolean isCompatibleWith(Enchantment ench){
  return shadow$canApplyTogether((net.minecraft.enchantment.Enchantment)ench);
}","@Override public boolean isCompatibleWith(Enchantment ench){
  return canApplyTogether((net.minecraft.enchantment.Enchantment)ench);
}"
27667,"@Override public int getMaximumLevel(){
  return shadow$getMaxLevel();
}","@Override public int getMaximumLevel(){
  return getMaxLevel();
}"
27668,"@Override public boolean canBeAppliedByTable(ItemStack stack){
  return shadow$canApplyAtEnchantingTable((net.minecraft.item.ItemStack)stack);
}","@Override public boolean canBeAppliedByTable(ItemStack stack){
  return canApplyAtEnchantingTable((net.minecraft.item.ItemStack)stack);
}"
27669,"@Override public int getMaximumEnchantabilityForLevel(int level){
  return shadow$getMaxEnchantability(level);
}","@Override public int getMaximumEnchantabilityForLevel(int level){
  return getMaxEnchantability(level);
}"
27670,"@Override public int getMinimumLevel(){
  return shadow$getMinLevel();
}","@Override public int getMinimumLevel(){
  return getMinLevel();
}"
27671,"@Override public boolean canBeAppliedToStack(ItemStack stack){
  return (stack.getItem() == ItemTypes.BOOK) ? shadow$isAllowedOnBooks() : shadow$canApply((net.minecraft.item.ItemStack)stack);
}","@Override public boolean canBeAppliedToStack(ItemStack stack){
  return (stack.getItem() == ItemTypes.BOOK) ? isAllowedOnBooks() : canApply((net.minecraft.item.ItemStack)stack);
}"
27672,@Shadow public abstract String getServerHostname();,@Shadow @SideOnly(Side.SERVER) public abstract String getServerHostname();
27673,@Shadow public abstract int getPort();,@Shadow @SideOnly(Side.SERVER) public abstract int getPort();
27674,"public boolean pig$isSaddled(){
  return this.getSaddled();
}","public boolean pig$isSaddled(){
  return (this.dataWatcher.getWatchableObjectByte(16) & 1) != 0;
}"
27675,"public void pig$setSaddled(boolean saddled){
  this.setSaddled(saddled);
}","public void pig$setSaddled(boolean saddled){
  if (saddled) {
    this.dataWatcher.updateObject(16,Byte.valueOf((byte)1));
  }
 else {
    this.dataWatcher.updateObject(16,Byte.valueOf((byte)0));
  }
}"
27676,"public void sheep$setSheared(boolean sheared){
  this.setSheared(sheared);
}","public void sheep$setSheared(boolean sheared){
  byte b0=this.dataWatcher.getWatchableObjectByte(16);
  if (sheared) {
    this.dataWatcher.updateObject(16,Byte.valueOf((byte)(b0 | 16)));
  }
 else {
    this.dataWatcher.updateObject(16,Byte.valueOf((byte)(b0 & -17)));
  }
}"
27677,"public void enderman$setScreaming(boolean screaming){
  this.setScreaming(screaming);
}","public void enderman$setScreaming(boolean screaming){
  this.dataWatcher.updateObject(18,Byte.valueOf((byte)(screaming ? 1 : 0)));
}"
27678,"public boolean enderman$isScreaming(){
  return this.isScreaming();
}","public boolean enderman$isScreaming(){
  return this.dataWatcher.getWatchableObjectByte(18) > 0;
}"
27679,"public boolean guardian$isElder(){
  return this.isElder();
}","public boolean guardian$isElder(){
  return (this.dataWatcher.getWatchableObjectInt(16) & 4) != 0;
}"
27680,"public void witch$setAggressive(boolean aggressive){
  this.setAggressive(aggressive);
}","public void witch$setAggressive(boolean aggressive){
  this.getDataWatcher().updateObject(21,Byte.valueOf((byte)(aggressive ? 1 : 0)));
}"
27681,"@Override public PotionEffectType getType(){
  return (PotionEffectType)Potion.potionTypes[getPotionId()];
}","@Override public PotionEffectType getType(){
  return (PotionEffectType)Potion.potionTypes[getPotionID()];
}"
27682,"@Override protected void configure(){
  PluginScope pluginScope=new PluginScope();
  Config pluginConfig=new ConfigFileAnnotation(true);
  ConfigDir sharedDir=new ConfigDirAnnotation(true);
  ConfigDir pluginDir=new ConfigDirAnnotation(false);
  bindScope(PluginScoped.class,pluginScope);
  bind(PluginScope.class).toInstance(pluginScope);
  bind(Game.class).to(SpongeGame.class).in(Scopes.SINGLETON);
  bind(PluginManager.class).to(SpongePluginManager.class).in(Scopes.SINGLETON);
  bind(EventManager.class).to(SpongeEventManager.class).in(Scopes.SINGLETON);
  bind(GameRegistry.class).to(SpongeGameRegistry.class).in(Scopes.SINGLETON);
  bind(File.class).annotatedWith(sharedDir).toProvider(GeneralConfigDirProvider.class).in(Scopes.SINGLETON);
  bind(PluginContainer.class).toProvider(PluginContainerProvider.class).in(PluginScoped.class);
  bind(Logger.class).toProvider(PluginLogProvider.class).in(PluginScoped.class);
  bind(File.class).annotatedWith(pluginConfig).toProvider(PluginConfigFileProvider.class).in(PluginScoped.class);
  bind(File.class).annotatedWith(pluginDir).toProvider(PluginConfigDirProvider.class).in(PluginScoped.class);
  bind(ConfigFile.class).annotatedWith(pluginConfig).toProvider(PluginHoconConfigProvider.class).in(PluginScoped.class);
}","@Override protected void configure(){
  PluginScope pluginScope=new PluginScope();
  DefaultConfig pluginConfig=new ConfigFileAnnotation(true);
  ConfigDir sharedDir=new ConfigDirAnnotation(true);
  ConfigDir pluginDir=new ConfigDirAnnotation(false);
  bindScope(PluginScoped.class,pluginScope);
  bind(PluginScope.class).toInstance(pluginScope);
  bind(Game.class).to(SpongeGame.class).in(Scopes.SINGLETON);
  bind(PluginManager.class).to(SpongePluginManager.class).in(Scopes.SINGLETON);
  bind(EventManager.class).to(SpongeEventManager.class).in(Scopes.SINGLETON);
  bind(GameRegistry.class).to(SpongeGameRegistry.class).in(Scopes.SINGLETON);
  bind(File.class).annotatedWith(sharedDir).toProvider(GeneralConfigDirProvider.class).in(Scopes.SINGLETON);
  bind(PluginContainer.class).toProvider(PluginContainerProvider.class).in(PluginScoped.class);
  bind(Logger.class).toProvider(PluginLogProvider.class).in(PluginScoped.class);
  bind(File.class).annotatedWith(pluginConfig).toProvider(PluginConfigFileProvider.class).in(PluginScoped.class);
  bind(File.class).annotatedWith(pluginDir).toProvider(PluginConfigDirProvider.class).in(PluginScoped.class);
  bind(ConfigFile.class).annotatedWith(pluginConfig).toProvider(PluginHoconConfigProvider.class).in(PluginScoped.class);
}"
27683,"@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || !(o instanceof Config)) {
    return false;
  }
  Config that=(Config)o;
  return sharedRoot() == that.sharedRoot();
}","@Override public boolean equals(Object o){
  if (this == o) {
    return true;
  }
  if (o == null || !(o instanceof ConfigDir)) {
    return false;
  }
  ConfigDir that=(ConfigDir)o;
  return sharedRoot() == that.sharedRoot();
}"
27684,"/** 
 * Apply the mixin described by mixin to the supplied classNode
 * @param targetClass
 * @param mixinInfo
 */
protected void applyMixin(ClassNode targetClass,MixinData mixin){
  try {
    this.verifyClasses(targetClass,mixin);
    this.applyMixinInterfaces(targetClass,mixin);
    this.applyMixinAttributes(targetClass,mixin);
    this.applyMixinFields(targetClass,mixin);
    this.applyMixinMethods(targetClass,mixin);
  }
 catch (  Exception ex) {
    throw new InvalidMixinException(""String_Node_Str"",ex);
  }
}","/** 
 * Apply the mixin described by mixin to the supplied classNode
 * @param targetClass
 * @param mixin
 */
protected void applyMixin(ClassNode targetClass,MixinData mixin){
  try {
    this.verifyClasses(targetClass,mixin);
    this.applyMixinInterfaces(targetClass,mixin);
    this.applyMixinAttributes(targetClass,mixin);
    this.applyMixinFields(targetClass,mixin);
    this.applyMixinMethods(targetClass,mixin);
  }
 catch (  Exception ex) {
    throw new InvalidMixinException(""String_Node_Str"",ex);
  }
}"
27685,"@Override public String getId(){
  return Block.blockRegistry.getNameForObject(this);
}","@Override public String getId(){
  return (String)Block.blockRegistry.getNameForObject(this);
}"
27686,"@Override public Collection<World> getWorlds(){
  List<World> worlds=new ArrayList<World>();
  for (  WorldServer worldServer : DimensionManager.getWorlds()) {
    worlds.add((World)worldServer);
  }
  return worlds;
}","@Override public Collection<World> getWorlds(){
  throw new UnsupportedOperationException();
}"
27687,"public BlockWrapper(World world,int x,int y,int z){
  if (!(world instanceof net.minecraft.world.World)) {
    System.err.println(""String_Node_Str"");
    handle=(net.minecraft.world.World)world;
    throw new RuntimeException(""String_Node_Str"");
  }
  handle=(net.minecraft.world.World)world;
  extent=world;
  this.x=x;
  this.y=y;
  this.z=z;
  this.blockType=(BlockType)handle.getBlock(x,y,z);
}","public BlockWrapper(World world,int x,int y,int z){
  if (!(world instanceof net.minecraft.world.World)) {
    System.err.println(""String_Node_Str"");
    handle=(net.minecraft.world.World)world;
    throw new RuntimeException(""String_Node_Str"");
  }
  handle=(net.minecraft.world.World)world;
  extent=world;
  pos=new BlockPos(x,y,z);
  this.blockType=(BlockType)handle.getBlockState(new BlockPos(x,y,z)).getBlock();
}"
27688,"@Override public Location getLocation(){
  return new Location(extent,Vectors.create3d(x,y,z));
}","@Override public Location getLocation(){
  return new Location(extent,Vectors.create3d(pos.getX(),pos.getY(),pos.getZ()));
}"
27689,"@Override public void replaceData(byte data){
  handle.setBlockMetadataWithNotify(x,y,z,data,0);
}","@Override public void replaceData(byte data){
  handle.setBlockState(pos,((net.minecraft.block.Block)blockType).getStateFromMeta(data),0);
}"
27690,"@Override public byte getLuminance(){
  return (byte)handle.getBlockLightValue(x,y,z);
}","@Override public byte getLuminance(){
  return (byte)handle.getLight(pos);
}"
27691,"@Override public boolean isPowered(){
  return handle.getBlockPowerInput(x,y,z) > 0;
}","@Override public boolean isPowered(){
  return handle.getStrongPower(pos) > 0;
}"
27692,"@Override public byte getDataValue(){
  return (byte)handle.getBlockMetadata(x,y,z);
}","@Override public byte getDataValue(){
  IBlockState state=handle.getBlockState(pos);
  return (byte)state.getBlock().getMetaFromState(state);
}"
27693,"@Override public byte getLuminanceFromSky(){
  return (byte)handle.getSkyBlockTypeBrightness(EnumSkyBlock.Sky,x,y,z);
}","@Override public byte getLuminanceFromSky(){
  return (byte)handle.getLightFor(EnumSkyBlock.SKY,pos);
}"
27694,"private static int getNotchDirection(Direction dir){
switch (dir) {
case DOWN:
    return 0;
case UP:
  return 1;
case NORTH:
return 2;
case SOUTH:
return 3;
case WEST:
return 4;
case EAST:
return 5;
default :
return 7;
}
}","private static EnumFacing getNotchDirection(Direction dir){
switch (dir) {
case DOWN:
    return EnumFacing.DOWN;
case UP:
  return EnumFacing.UP;
case NORTH:
return EnumFacing.NORTH;
case SOUTH:
return EnumFacing.SOUTH;
case WEST:
return EnumFacing.WEST;
case EAST:
return EnumFacing.EAST;
default :
return EnumFacing.DOWN;
}
}"
27695,"@Override public int getX(){
  return x;
}","@Override public int getX(){
  return pos.getX();
}"
27696,"@Override public Vector3i getPosition(){
  return Vectors.create3i(x,y,z);
}","@Override public Vector3i getPosition(){
  return Vectors.create3i(pos.getX(),pos.getY(),pos.getZ());
}"
27697,"@Override public int getY(){
  return y;
}","@Override public int getY(){
  return pos.getY();
}"
27698,"@Override public boolean isFacePowered(Direction direction){
  return handle.getIndirectPowerLevelTo(x,y,z,getNotchDirection(direction)) > 0;
}","@Override public boolean isFacePowered(Direction direction){
  return handle.getStrongPower(pos,getNotchDirection(direction)) > 0;
}"
27699,"@Override public int getZ(){
  return z;
}","@Override public int getZ(){
  return pos.getZ();
}"
27700,"@Override public BlockType getType(){
  return (BlockType)handle.getBlock(x,y,z);
}","@Override public BlockType getType(){
  return blockType;
}"
27701,"@Override public byte getLuminanceFromGround(){
  return (byte)handle.getSkyBlockTypeBrightness(EnumSkyBlock.Block,x,y,z);
}","@Override public byte getLuminanceFromGround(){
  return (byte)handle.getLightFor(EnumSkyBlock.BLOCK,pos);
}"
27702,"@Override public boolean isFaceIndirectlyPowered(Direction direction){
  return handle.getIndirectPowerLevelTo(x,y,z,getNotchDirection(direction)) > 0;
}","@Override public boolean isFaceIndirectlyPowered(Direction direction){
  return handle.getRedstonePower(pos,getNotchDirection(direction)) > 0;
}"
27703,"@Override public boolean isIndirectlyPowered(){
  return handle.isBlockIndirectlyGettingPowered(x,y,z);
}","@Override public boolean isIndirectlyPowered(){
  return handle.isBlockPowered(pos);
}"
27704,"@Override public void replaceWith(BlockSnapshot snapshot){
  replaceData(snapshot.getDataValue());
  replaceWith(snapshot.getType());
}","@Override public void replaceWith(BlockSnapshot snapshot){
  replaceWith(snapshot.getType());
  replaceData(snapshot.getDataValue());
}"
27705,"/** 
 * This method implements getBlock from the   {@link IWorld} interface. However since the method signature overlaps with the ""getBlock"" methodabove, it is necessary to use the  {@link Shadow#prefix} functionality in the {@link Shadow} annotation to prevent a name clash at compiletime.
 * @see org.spongepowered.mixin.interfaces.IWorld#getBlock(int,int,int)
 */
@Override public Object getBlock(int x,int y,int z){
  return this.shadow$getBlock(x,y,z);
}","/** 
 * This method implements getBlock from the   {@link IWorld} interface. However since the method signature overlaps with the ""getBlock"" methodabove, it is necessary to use the  {@link Shadow#prefix} functionality in the {@link Shadow} annotation to prevent a name clash at compiletime.
 * @see org.spongepowered.mixin.interfaces.IWorld#getBlock(int,int,int)
 */
@Override public Object getBlock(int x,int y,int z){
  return this.shadow$getBlockState(new BlockPos(x,y,z)).getBlock();
}"
27706,"@Override public int exampleMethodToComputeLightValue(int x,int y,int z,EnumSkyBlock block){
  return this.computeLightValue(x,y,z,block);
}","@Override public int exampleMethodToComputeLightValue(int x,int y,int z,EnumSkyBlock block){
  return this.func_175638_a(new BlockPos(x,y,z),block);
}"
27707,"/** 
 * Apply the mixin described by mixin to the supplied classNode
 * @param targetClass
 * @param mixin
 */
protected void applyMixin(ClassNode targetClass,MixinInfo mixin){
  ClassNode mixinClass=mixin.getClassNode(ClassReader.EXPAND_FRAMES);
  try {
    this.verifyClasses(targetClass,mixinClass);
    this.applyMixinInterfaces(targetClass,mixinClass);
    this.applyMixinAttributes(targetClass,mixinClass);
    this.applyMixinFields(targetClass,mixinClass);
    this.applyMixinMethods(targetClass,mixinClass);
  }
 catch (  Exception ex) {
    throw new InvalidMixinException(""String_Node_Str"",ex);
  }
}","/** 
 * Apply the mixin described by mixin to the supplied classNode
 * @param targetClass
 * @param mixinInfo
 */
protected void applyMixin(ClassNode targetClass,MixinData mixin){
  try {
    this.verifyClasses(targetClass,mixin);
    this.applyMixinInterfaces(targetClass,mixin);
    this.applyMixinAttributes(targetClass,mixin);
    this.applyMixinFields(targetClass,mixin);
    this.applyMixinMethods(targetClass,mixin);
  }
 catch (  Exception ex) {
    throw new InvalidMixinException(""String_Node_Str"",ex);
  }
}"
27708,"/** 
 * Mixin misc attributes from mixin class onto the target class
 * @param targetClass
 * @param mixinClass
 */
private void applyMixinAttributes(ClassNode targetClass,ClassNode mixinClass){
  if (this.config.shouldSetSourceFile()) {
    targetClass.sourceFile=mixinClass.sourceFile;
  }
}","/** 
 * Mixin misc attributes from mixin class onto the target class
 * @param targetClass
 * @param mixin
 */
private void applyMixinAttributes(ClassNode targetClass,MixinData mixin){
  if (this.config.shouldSetSourceFile()) {
    targetClass.sourceFile=mixin.getClassNode().sourceFile;
  }
}"
27709,"/** 
 * Mixin methods from the mixin class into the target class
 * @param targetClass
 * @param mixinClass
 */
private void applyMixinMethods(ClassNode targetClass,ClassNode mixinClass){
  for (  MethodNode mixinMethod : mixinClass.methods) {
    this.transformMethod(mixinMethod,mixinClass.name,targetClass.name);
    boolean isShadow=ASMHelper.getVisibleAnnotation(mixinMethod,Shadow.class) != null;
    boolean isOverwrite=ASMHelper.getVisibleAnnotation(mixinMethod,Overwrite.class) != null;
    boolean isAbstract=MixinTransformer.hasFlag(mixinMethod,Opcodes.ACC_ABSTRACT);
    if (isShadow || isAbstract) {
      MethodNode target=this.findTargetMethod(targetClass,mixinMethod);
      if (target == null) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",mixinMethod.name));
      }
    }
 else     if (!mixinMethod.name.startsWith(""String_Node_Str"")) {
      if (MixinTransformer.hasFlag(mixinMethod,Opcodes.ACC_STATIC) && !MixinTransformer.hasFlag(mixinMethod,Opcodes.ACC_PRIVATE) && !isOverwrite) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",mixinMethod.name));
      }
      MethodNode target=this.findTargetMethod(targetClass,mixinMethod);
      if (target != null) {
        targetClass.methods.remove(target);
      }
 else       if (isOverwrite) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",mixinMethod.name));
      }
      targetClass.methods.add(mixinMethod);
    }
 else     if (""String_Node_Str"".equals(mixinMethod.name)) {
      this.appendInsns(targetClass,mixinMethod.name,mixinMethod);
    }
  }
}","/** 
 * Mixin methods from the mixin class into the target class
 * @param targetClass
 * @param mixin
 */
private void applyMixinMethods(ClassNode targetClass,MixinData mixin){
  for (  MethodNode mixinMethod : mixin.getClassNode().methods) {
    this.transformMethod(mixinMethod,mixin.getClassNode().name,targetClass.name);
    boolean isShadow=ASMHelper.getVisibleAnnotation(mixinMethod,Shadow.class) != null;
    boolean isOverwrite=ASMHelper.getVisibleAnnotation(mixinMethod,Overwrite.class) != null;
    boolean isAbstract=MixinTransformer.hasFlag(mixinMethod,Opcodes.ACC_ABSTRACT);
    if (isShadow || isAbstract) {
      MethodNode target=this.findTargetMethod(targetClass,mixinMethod);
      if (target == null) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",mixinMethod.name));
      }
    }
 else     if (!mixinMethod.name.startsWith(""String_Node_Str"")) {
      if (MixinTransformer.hasFlag(mixinMethod,Opcodes.ACC_STATIC) && !MixinTransformer.hasFlag(mixinMethod,Opcodes.ACC_PRIVATE) && !isOverwrite) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",mixinMethod.name));
      }
      MethodNode target=this.findTargetMethod(targetClass,mixinMethod);
      if (target != null) {
        targetClass.methods.remove(target);
      }
 else       if (isOverwrite) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",mixinMethod.name));
      }
      targetClass.methods.add(mixinMethod);
    }
 else     if (""String_Node_Str"".equals(mixinMethod.name)) {
      this.appendInsns(targetClass,mixinMethod.name,mixinMethod);
    }
  }
}"
27710,"/** 
 * Apply mixins for specified target class to the class described by the supplied byte array
 * @param transformedName 
 * @param basicClass
 * @return
 */
private byte[] applyMixins(String transformedName,byte[] basicClass){
  ClassNode targetClass=this.readClass(basicClass,true);
  List<MixinInfo> mixins=this.config.getMixinsFor(transformedName);
  Collections.sort(mixins);
  for (  MixinInfo mixin : mixins) {
    this.logger.info(""String_Node_Str"",mixin.getClassName(),transformedName);
    this.applyMixin(targetClass,mixin);
  }
  this.postTransform(transformedName,targetClass,mixins);
  return this.writeClass(targetClass);
}","/** 
 * Apply mixins for specified target class to the class described by the supplied byte array
 * @param transformedName 
 * @param basicClass
 * @return
 */
private byte[] applyMixins(String transformedName,byte[] basicClass){
  ClassNode targetClass=this.readClass(basicClass,true);
  List<MixinInfo> mixins=this.config.getMixinsFor(transformedName);
  Collections.sort(mixins);
  for (  MixinInfo mixin : mixins) {
    this.logger.info(""String_Node_Str"",mixin.getClassName(),transformedName);
    this.applyMixin(targetClass,mixin.getData());
  }
  this.postTransform(transformedName,targetClass,mixins);
  return this.writeClass(targetClass);
}"
27711,"/** 
 * Perform pre-flight checks on the mixin and target classes
 * @param targetClass
 * @param mixinClass
 */
protected void verifyClasses(ClassNode targetClass,ClassNode mixinClass){
  if (targetClass.superName == null || mixinClass.superName == null || !targetClass.superName.equals(mixinClass.superName)) {
    throw new InvalidMixinException(""String_Node_Str"");
  }
}","/** 
 * Perform pre-flight checks on the mixin and target classes
 * @param targetClass
 * @param mixin
 */
protected void verifyClasses(ClassNode targetClass,MixinData mixin){
  String superName=mixin.getClassNode().superName;
  if (targetClass.superName == null || superName == null || !targetClass.superName.equals(superName)) {
    throw new InvalidMixinException(""String_Node_Str"");
  }
}"
27712,"/** 
 * Mixin interfaces implemented by the mixin class onto the target class
 * @param targetClass
 * @param mixinClass
 */
private void applyMixinInterfaces(ClassNode targetClass,ClassNode mixinClass){
  for (  String interfaceName : mixinClass.interfaces) {
    if (!targetClass.interfaces.contains(interfaceName)) {
      targetClass.interfaces.add(interfaceName);
    }
  }
}","/** 
 * Mixin interfaces implemented by the mixin class onto the target class
 * @param targetClass
 * @param mixin
 */
private void applyMixinInterfaces(ClassNode targetClass,MixinData mixin){
  for (  String interfaceName : mixin.getClassNode().interfaces) {
    if (!targetClass.interfaces.contains(interfaceName)) {
      targetClass.interfaces.add(interfaceName);
    }
  }
}"
27713,"/** 
 * Mixin fields from mixin class into the target class. It is vital that this is done before mixinMethods because we need to compute renamed fields so that transformMethod can rename field references in the method body
 * @param targetClass
 * @param mixinClass
 */
private void applyMixinFields(ClassNode targetClass,ClassNode mixinClass){
  for (  FieldNode field : mixinClass.fields) {
    if (MixinTransformer.hasFlag(field,Opcodes.ACC_STATIC) && !MixinTransformer.hasFlag(field,Opcodes.ACC_PRIVATE)) {
      throw new InvalidMixinException(String.format(""String_Node_Str"",field.name));
    }
    FieldNode target=this.findTargetField(targetClass,field);
    if (target == null) {
      boolean isShadow=ASMHelper.getVisibleAnnotation(field,Shadow.class) != null;
      if (isShadow) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",field.name));
      }
      targetClass.fields.add(field);
    }
 else {
      if (!target.desc.equals(field.desc)) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",field.name));
      }
    }
  }
}","/** 
 * Mixin fields from mixin class into the target class. It is vital that this is done before mixinMethods because we need to compute renamed fields so that transformMethod can rename field references in the method body
 * @param targetClass
 * @param mixin
 */
private void applyMixinFields(ClassNode targetClass,MixinData mixin){
  for (  FieldNode field : mixin.getClassNode().fields) {
    if (MixinTransformer.hasFlag(field,Opcodes.ACC_STATIC) && !MixinTransformer.hasFlag(field,Opcodes.ACC_PRIVATE)) {
      throw new InvalidMixinException(String.format(""String_Node_Str"",field.name));
    }
    FieldNode target=this.findTargetField(targetClass,field);
    if (target == null) {
      boolean isShadow=ASMHelper.getVisibleAnnotation(field,Shadow.class) != null;
      if (isShadow) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",field.name));
      }
      targetClass.fields.add(field);
    }
 else {
      if (!target.desc.equals(field.desc)) {
        throw new InvalidMixinException(String.format(""String_Node_Str"",field.name));
      }
    }
  }
}"
27714,"/** 
 * Gets the permission id this description belongs to. <p>The permission id must be of the specified format as specified using EBNF: <ul> <li>CHARACTER  = ""A"" - ""Z"" | ""a"" - ""z"" | ""0"" - ""9"" | ""_"" | ""-""</li> <li>NAME       = CHARACTER , { CHARACTER }</li> <li>TEMPLATE   = ""&lt"" , NAME , ""&gt""</li> <li>PART       = NAME | TEMPLATE</li> <li>PERMISSION = NAME , { ""."" , PART }</li> </ul> </p> <p>The following examples shall help you to structure your permissions well: <ul> <li>""myplugin"" - Grants everything in myPlugin</li> <li>""myplugin.give"" - Grants everything related to give including all ItemTypes and Enchantments</li> <li>""myplugin.give.execute"" - Allows the execution of give</li> <li>""myplugin.give.type"" - Grants all ItemTypes</li> <li>""myplugin.give.type.&ltItemType&gt"" - A template should not be granted to anybody</li> <li>""myplugin.give.type.DIAMOND"" - Only grants DIAMOND</li> <li>""myplugin.give.enchantment"" - Grants all Enchantments</li> <li>""myplugin.give.others"" - Allow giving to other players</li> </ul> The addition of the ""execute"" permission instead of just ""myPlugin.give"" permission is useful to prevent unauthorized access to sub-permissions that are not documented or have been added lately. </p> <p> So if you want to allow someone to give themself only DIAMONDs, you would assign them the following permissions: <ul> <li>""myPlugin.give.execute""</li> <li>""myPlugin.give.type.DIAMOND""</li> </ul> </p> <p><b>Note:</b> Permission ids are case insensitive! Permission ids should start with the owning plugin's id.</p>
 * @return The permission id
 */
String getId();","/** 
 * Gets the permission id this description belongs to. <p>The permission id must be of the specified format as specified using EBNF: <ul> <li>CHARACTER  = ""A"" - ""Z"" | ""a"" - ""z"" | ""0"" - ""9"" | ""_"" | ""-""</li> <li>NAME       = CHARACTER , { CHARACTER }</li> <li>TEMPLATE   = ""&lt"" , NAME , ""&gt""</li> <li>PART       = NAME | TEMPLATE</li> <li>PERMISSION = NAME , { ""."" , PART }</li> </ul> </p> <p>The following examples shall help you to structure your permissions well: <ul> <li>""myplugin"" - Grants everything in myPlugin</li> <li>""myplugin.give"" - Grants everything related to give including all ItemTypes and Enchantments</li> <li>""myplugin.give.execute"" - Allows the execution of give</li> <li>""myplugin.give.type"" - Grants all ItemTypes</li> <li>""myplugin.give.type.&ltItemType&gt"" - A template should not be granted to anybody</li> <li>""myplugin.give.type.minecraft.diamond"" - Only grants minecraft:diamond</li> <li>""myplugin.give.enchantment"" - Grants all Enchantments</li> <li>""myplugin.give.others"" - Allow giving to other players</li> </ul> The addition of the ""execute"" permission instead of just ""myPlugin.give"" permission is useful to prevent unauthorized access to sub-permissions that are not documented or have been added lately. </p> <p> So if you want to allow someone to give themself only DIAMONDs, you would assign them the following permissions: <ul> <li>""myPlugin.give.execute""</li> <li>""myPlugin.give.type.DIAMOND""</li> </ul> </p> <p><b>Note:</b> Permission ids are case insensitive! Permission ids should start with the owning plugin's id.</p>
 * @return The permission id
 */
String getId();"
27715,"/** 
 * Similar to   {@link #spawnEntity(Entity)} except where multiple entitiescan be attempted to be spawned.
 * @param entities The entities which spawned correctly, or empty if none
 * @return True if any of the entities were successfully spawned
 */
Collection<Entity> spawnEntities(Iterable<? extends Entity> entities);","/** 
 * Similar to   {@link #spawnEntity(Entity)} except where multiple entitiescan be attempted to be spawned.
 * @param entities The created entities you wish to spawn
 * @return The entities which spawned correctly, or empty if none
 */
Collection<Entity> spawnEntities(Iterable<? extends Entity> entities);"
27716,"/** 
 * Create a new   {@link CommandSpec} based on the data provided in thisbuilder.
 * @return the new spec
 */
public CommandSpec build(){
  if (this.childCommandMap == null || this.childCommandMap.isEmpty()) {
    checkNotNull(this.executor,""String_Node_Str"");
  }
 else   if (this.executor == null) {
    arguments(this.args,registerInDispatcher(new ChildCommandElementExecutor(null,null,false)));
  }
 else {
    arguments(registerInDispatcher(new ChildCommandElementExecutor(this.executor,this.args,this.childCommandFallback)));
  }
  return new CommandSpec(this.args,this.executor,this.description,this.extendedDescription,this.permission,this.argumentParser);
}","/** 
 * Create a new   {@link CommandSpec} based on the data provided in thisbuilder.
 * @return the new spec
 */
public CommandSpec build(){
  if (this.childCommandMap == null || this.childCommandMap.isEmpty()) {
    checkNotNull(this.executor,""String_Node_Str"");
  }
 else   if (this.executor == null) {
    ChildCommandElementExecutor childCommandElementExecutor=registerInDispatcher(new ChildCommandElementExecutor(null,null,false));
    if (this.args == DEFAULT_ARG) {
      arguments(childCommandElementExecutor);
    }
 else {
      arguments(this.args,childCommandElementExecutor);
    }
  }
 else {
    arguments(registerInDispatcher(new ChildCommandElementExecutor(this.executor,this.args,this.childCommandFallback)));
  }
  return new CommandSpec(this.args,this.executor,this.description,this.extendedDescription,this.permission,this.argumentParser);
}"
27717,"/** 
 * Create a new   {@link CommandSpec} based on the data provided in thisbuilder.
 * @return the new spec
 */
public CommandSpec build(){
  if (this.childCommandMap == null) {
    checkNotNull(this.executor,""String_Node_Str"");
  }
 else {
    if (this.args == DEFAULT_ARG) {
      ChildCommandElementExecutor childDispatcher=registerInDispatcher(new ChildCommandElementExecutor(this.executor,null,false));
      arguments(this.executor == null ? childDispatcher : optional(childDispatcher));
    }
 else {
      if (this.executor == null) {
        arguments(this.args,registerInDispatcher(new ChildCommandElementExecutor(null,null,false)));
      }
 else {
        arguments(registerInDispatcher(new ChildCommandElementExecutor(this.executor,this.args,this.childCommandFallback)));
      }
    }
  }
  return new CommandSpec(this.args,this.executor,this.description,this.extendedDescription,this.permission,this.argumentParser);
}","/** 
 * Create a new   {@link CommandSpec} based on the data provided in thisbuilder.
 * @return the new spec
 */
public CommandSpec build(){
  if (this.childCommandMap == null) {
    checkNotNull(this.executor,""String_Node_Str"");
  }
 else {
    if (this.args == DEFAULT_ARG) {
      CommandExecutor baseExecutor=this.executor;
      ChildCommandElementExecutor childDispatcher=registerInDispatcher(new ChildCommandElementExecutor(baseExecutor,null,false));
      arguments(baseExecutor == null ? childDispatcher : optional(childDispatcher));
    }
 else {
      if (this.executor == null) {
        arguments(this.args,registerInDispatcher(new ChildCommandElementExecutor(null,null,false)));
      }
 else {
        arguments(registerInDispatcher(new ChildCommandElementExecutor(this.executor,this.args,this.childCommandFallback)));
      }
    }
  }
  return new CommandSpec(this.args,this.executor,this.description,this.extendedDescription,this.permission,this.argumentParser);
}"
27718,"/** 
 * Gets the pitch used when playing sounds.
 * @return The pitch
 */
double getVolume();","/** 
 * Gets the volume used when playing sounds.
 * @return The volume
 */
double getVolume();"
27719,"/** 
 * Gets the volume used when playing sounds.
 * @return The volume
 */
double getPitch();","/** 
 * Gets the pitch used when playing sounds.
 * @return The pitch
 */
double getPitch();"
27720,"/** 
 * Removes the element at the specified position in this list (optional operation).  Shifts any subsequent elements to the left, subtracts one from their indices.
 * @param index The index of the element to remove
 * @return This value, for chaining
 */
ListValue<E> remove(int index);","/** 
 * Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left, subtracts one from their indices.
 * @param index The index of the element to remove
 * @return This value, for chaining
 */
ListValue<E> remove(int index);"
27721,"/** 
 * Return the next sibling inventory, allows traversing the inventory hierarchy without using an iterator. If no more children, returns an  {@link EmptyInventory}.
 * @param < T > expected inventory type, specified as generic to allow easypseudo-duck-typing
 * @return the next sibiling inventory, or an {@link EmptyInventory} ifthere are no further siblings
 */
<T extends Inventory>T next();","/** 
 * Return the next sibling inventory, allows traversing the inventory hierarchy without using an iterator. If no more siblings, returns an  {@link EmptyInventory}.
 * @param < T > expected inventory type, specified as generic to allow easypseudo-duck-typing
 * @return the next sibiling inventory, or an {@link EmptyInventory} ifthere are no further siblings
 */
<T extends Inventory>T next();"
27722,"/** 
 * Removes the   {@link Score} with the specified name from this objectie, if present.
 * @param name The name of the {@link Score} to remove.
 * @return Whether the score existed on this objective
 */
boolean removeScore(Text name);","/** 
 * Removes the   {@link Score} with the specified name from this objective, if present.
 * @param name The name of the {@link Score} to remove.
 * @return Whether the score existed on this objective
 */
boolean removeScore(Text name);"
27723,"@SuppressWarnings(""String_Node_Str"") @Override public MatcherBuilder from(StateMatcher value){
  reset();
  type(value.type);
  for (int i=0; i < value.traits.length; i++) {
    trait(value.traits[i],(Comparable)value.values[i]);
  }
  return this;
}","@SuppressWarnings(""String_Node_Str"") @Override public MatcherBuilder from(StateMatcher value){
  reset();
  type(value.type);
  for (int i=0; i < value.traits.length; i++) {
    trait((BlockTrait)value.traits[i],(Comparable)value.values[i]);
  }
  return this;
}"
27724,"/** 
 * Consumes a series of arguments. Usage is the elements concated
 * @param elements The series of arguments to expect
 * @return the element to match the input
 */
public static CommandElement seq(CommandElement... elements){
  return new SequenceCommandElement(ImmutableList.copyOf(elements));
}","/** 
 * Consumes a series of arguments. Usage is the elements concencated
 * @param elements The series of arguments to expect
 * @return the element to match the input
 */
public static CommandElement seq(CommandElement... elements){
  return new SequenceCommandElement(ImmutableList.copyOf(elements));
}"
27725,"/** 
 * Gets the active input tokenizer used for this commmand.
 * @return This command's input tokenizer
 */
public InputTokenizer getInputTokenizer(){
  return this.argumentParser;
}","/** 
 * Gets the active input tokenizer used for this command.
 * @return This command's input tokenizer
 */
public InputTokenizer getInputTokenizer(){
  return this.argumentParser;
}"
27726,"/** 
 * Gets the content version of this   {@link DataSerializable}. The version may differ between instances of plugins and implementations such that the   {@link DataView} from {@link #toContainer()} may include differentinformation, or remove other information as they are no longer deemend necessary. The version goes hand in hand with  {@link DataContentUpdater}as it is required when there exists any   {@link DataView} of this{@link DataSerializable} with an ""older"" version.
 * @return The version of the content being serialized
 */
int getContentVersion();","/** 
 * Gets the content version of this   {@link DataSerializable}. The version may differ between instances of plugins and implementations such that the   {@link DataView} from {@link #toContainer()} may include differentinformation, or remove other information as they are no longer deemed necessary. The version goes hand in hand with  {@link DataContentUpdater}as it is required when there exists any   {@link DataView} of this{@link DataSerializable} with an ""older"" version.
 * @return The version of the content being serialized
 */
int getContentVersion();"
27727,"/** 
 * Gets the map of custom keys and values to respond with. <p>If settings any of the keys or values causes the message to go oer the maximum size, the message will be automatically truncated.</p>
 * @return The map of custom keys and values to respond with
 */
Map<String,String> getCustomValuesMap();","/** 
 * Gets the map of custom keys and values to respond with. <p>If settings any of the keys or values causes the message to go over the maximum size, the message will be automatically truncated.</p>
 * @return The map of custom keys and values to respond with
 */
Map<String,String> getCustomValuesMap();"
27728,"/** 
 * Returns true if <em>other</em> is also an   {@link AcceptsItems} propertyand <b>any</b> item appearing in the other property's collecion appears in this property's collection. In formal terms, the method returns true if the size of the intersection between the two item type collections is greater than zero.
 */
@Override public boolean equals(Object obj){
  if (!(obj instanceof InventoryProperty)) {
    return false;
  }
  InventoryProperty<?,?> other=(InventoryProperty<?,?>)obj;
  if (!other.getKey().equals(this.getKey())) {
    return false;
  }
  List<ItemType> otherTypes=Coerce.toListOf(other.getValue(),ItemType.class);
  for (  ItemType t : this.value) {
    if (otherTypes.contains(t)) {
      return true;
    }
  }
  return false;
}","/** 
 * Returns true if <em>other</em> is also an   {@link AcceptsItems} propertyand <b>any</b> item appearing in the other property's collection appears in this property's collection. In formal terms, the method returns true if the size of the intersection between the two item type collections is greater than zero.
 */
@Override public boolean equals(Object obj){
  if (!(obj instanceof InventoryProperty)) {
    return false;
  }
  InventoryProperty<?,?> other=(InventoryProperty<?,?>)obj;
  if (!other.getKey().equals(this.getKey())) {
    return false;
  }
  List<ItemType> otherTypes=Coerce.toListOf(other.getValue(),ItemType.class);
  for (  ItemType t : this.value) {
    if (otherTypes.contains(t)) {
      return true;
    }
  }
  return false;
}"
27729,"/** 
 * Sets the specified   {@link DataView} at the current writerIndex andincreases the writerIndex according to the lenght of the data view in this buffer.
 * @param data The data view data
 * @return This stream for chaining
 */
ChannelBuf writeDataView(DataView data);","/** 
 * Sets the specified   {@link DataView} at the current writerIndex andincreases the writerIndex according to the length of the data view in this buffer.
 * @param data The data view data
 * @return This stream for chaining
 */
ChannelBuf writeDataView(DataView data);"
27730,"/** 
 * Formats the given value from the statistic to a human readable form.
 * @param value The value to format
 * @return The formated value
 */
String format(long value);","/** 
 * Formats the given value from the statistic to a human readable form.
 * @param value The value to format
 * @return The formatted value
 */
String format(long value);"
27731,"/** 
 * Sets the number of chunks this ticket will load at once.
 * @param numChunks The number of chunks this ticket can load at once
 * @return True if sucessful, false if the number of chunks is above themaximum allowed for this ticket
 */
boolean setNumChunks(int numChunks);","/** 
 * Sets the number of chunks this ticket will load at once.
 * @param numChunks The number of chunks this ticket can load at once
 * @return True if successful, false if the number of chunks is above themaximum allowed for this ticket
 */
boolean setNumChunks(int numChunks);"
27732,"/** 
 * Gets a   {@link DataContainer} including all data related to a{@link Chunk}. <p>The container is a read only instance of the data, and therefor should not be considered as mutable data. Changes are NOT saved, and the data may not be in synch with the server if the chunk is currently loaded.</p> <p>This may not return a   {@link DataContainer} in the event there is nochunk data generated at the desired coordinates.</p> <p>It is imperative to understand that the  {@link CompletableFuture} taskis blocking, and should avoid using  {@link CompletableFuture#get()} whileon the main thread.</p>
 * @param chunkCoords The chunk coordinates
 * @return The data container representing the chunk data, if available
 */
CompletableFuture<Optional<DataContainer>> getChunkData(Vector3i chunkCoords);","/** 
 * Gets a   {@link DataContainer} including all data related to a{@link Chunk}. <p>The container is a read only instance of the data, and therefor should not be considered as mutable data. Changes are NOT saved, and the data may not be in sync with the server if the chunk is currently loaded.</p> <p>This may not return a   {@link DataContainer} in the event there is nochunk data generated at the desired coordinates.</p> <p>It is imperative to understand that the  {@link CompletableFuture} taskis blocking, and should avoid using  {@link CompletableFuture#get()} whileon the main thread.</p>
 * @param chunkCoords The chunk coordinates
 * @return The data container representing the chunk data, if available
 */
CompletableFuture<Optional<DataContainer>> getChunkData(Vector3i chunkCoords);"
27733,"/** 
 * Checks if the given chunk coordinates represented by   {@link Vector3i}exist in the world. <p>Note that this is an asynchronous check as the storage of chunks can not be guaranteed to remain in synch with the server, let alone on the server thread.</p> <p>It is imperative to understand that the   {@link CompletableFuture} taskis blocking, and should avoid using  {@link CompletableFuture#get()} whileon the main thread.</p>
 * @param chunkCoords The chunk coordinates
 * @return Whether the chunk exists or not
 */
CompletableFuture<Boolean> doesChunkExist(Vector3i chunkCoords);","/** 
 * Checks if the given chunk coordinates represented by   {@link Vector3i}exist in the world. <p>Note that this is an asynchronous check as the storage of chunks can not be guaranteed to remain in sync with the server, let alone on the server thread.</p> <p>It is imperative to understand that the   {@link CompletableFuture} taskis blocking, and should avoid using  {@link CompletableFuture#get()} whileon the main thread.</p>
 * @param chunkCoords The chunk coordinates
 * @return Whether the chunk exists or not
 */
CompletableFuture<Boolean> doesChunkExist(Vector3i chunkCoords);"
27734,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void setCollection(String key,Collection<?> value){
  ImmutableList.Builder<Object> builder=ImmutableList.builder();
  @Nullable DataManager manager;
  try {
    manager=Sponge.getDataManager();
  }
 catch (  Exception e) {
    manager=null;
  }
  for (  Object object : value) {
    if (object instanceof DataSerializable) {
      builder.add(((DataSerializable)object).toContainer());
    }
 else     if (object instanceof DataView) {
      if (this.safety == SafetyMode.ALL_DATA_CLONED || this.safety == SafetyMode.CLONED_ON_SET) {
        MemoryDataView view=new MemoryDataContainer(this.safety);
        DataView internalView=(DataView)object;
        for (        Map.Entry<DataQuery,Object> entry : internalView.getValues(false).entrySet()) {
          view.set(entry.getKey(),entry.getValue());
        }
        builder.add(view);
      }
 else {
        builder.add(object);
      }
    }
 else     if (object instanceof Map) {
      builder.add(ensureSerialization((Map)object));
    }
 else     if (object instanceof Collection) {
      builder.add(ensureSerialization((Collection)object));
    }
 else {
      if (manager != null) {
        final Optional<? extends DataTranslator<?>> translatorOptional=manager.getTranslator(object.getClass());
        if (translatorOptional.isPresent()) {
          DataTranslator translator=translatorOptional.get();
          final DataContainer container=translator.translate(value);
          checkArgument(!container.equals(this),""String_Node_Str"");
          builder.add(container);
        }
 else {
          builder.add(object);
        }
      }
 else {
        builder.add(object);
      }
    }
  }
  this.map.put(key,builder.build());
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void setCollection(String key,Collection<?> value){
  ImmutableList.Builder<Object> builder=ImmutableList.builder();
  @Nullable DataManager manager;
  try {
    manager=Sponge.getDataManager();
  }
 catch (  Exception e) {
    manager=null;
  }
  for (  Object object : value) {
    if (object instanceof DataSerializable) {
      builder.add(((DataSerializable)object).toContainer());
    }
 else     if (object instanceof DataView) {
      if (this.safety == SafetyMode.ALL_DATA_CLONED || this.safety == SafetyMode.CLONED_ON_SET) {
        MemoryDataView view=new MemoryDataContainer(this.safety);
        DataView internalView=(DataView)object;
        for (        Map.Entry<DataQuery,Object> entry : internalView.getValues(false).entrySet()) {
          view.set(entry.getKey(),entry.getValue());
        }
        builder.add(view);
      }
 else {
        builder.add(object);
      }
    }
 else     if (object instanceof Map) {
      builder.add(ensureSerialization((Map)object));
    }
 else     if (object instanceof Collection) {
      builder.add(ensureSerialization((Collection)object));
    }
 else {
      if (manager != null) {
        final Optional<? extends DataTranslator<?>> translatorOptional=manager.getTranslator(object.getClass());
        if (translatorOptional.isPresent()) {
          DataTranslator translator=translatorOptional.get();
          final DataContainer container=translator.translate(object);
          checkArgument(!container.equals(this),""String_Node_Str"");
          builder.add(container);
        }
 else {
          builder.add(object);
        }
      }
 else {
        builder.add(object);
      }
    }
  }
  this.map.put(key,builder.build());
}"
27735,"/** 
 * Tests for intersection between the box and a ray defined by a starting point and a direction.
 * @param start The starting point of the ray
 * @param direction The direction of the ray
 * @return An intersection point its normal, if any
 */
public Optional<Tuple<Vector3d,Vector3d>> intersects(Vector3d start,Vector3d direction){
  final double txMin;
  final double txMax;
  final Vector3d xNormal;
  if (direction.getX() >= 0) {
    txMin=(this.min.getX() - start.getX()) / direction.getX();
    txMax=(this.max.getX() - start.getX()) / direction.getX();
    xNormal=Vector3d.UNIT_X;
  }
 else {
    txMin=(this.max.getX() - start.getX()) / direction.getX();
    txMax=(this.min.getX() - start.getX()) / direction.getX();
    xNormal=Vector3d.UNIT_X.negate();
  }
  final double tyMin;
  final double tyMax;
  final Vector3d yNormal;
  if (direction.getY() >= 0) {
    tyMin=(this.min.getY() - start.getY()) / direction.getY();
    tyMax=(this.max.getY() - start.getY()) / direction.getY();
    yNormal=Vector3d.UNIT_Y;
  }
 else {
    tyMin=(this.max.getY() - start.getY()) / direction.getY();
    tyMax=(this.min.getY() - start.getY()) / direction.getY();
    yNormal=Vector3d.UNIT_Y.negate();
  }
  if (txMin > tyMax || txMax < tyMin) {
    return Optional.empty();
  }
  Vector3d normalMax;
  Vector3d normalMin;
  double tMin;
  if (tyMin == txMin) {
    tMin=tyMin;
    normalMin=xNormal.negate().sub(yNormal);
  }
 else   if (tyMin > txMin) {
    tMin=tyMin;
    normalMin=yNormal.negate();
  }
 else {
    tMin=txMin;
    normalMin=xNormal.negate();
  }
  double tMax;
  if (tyMax == txMax) {
    tMax=tyMax;
    normalMax=xNormal.add(yNormal);
  }
 else   if (tyMax < txMax) {
    tMax=tyMax;
    normalMax=yNormal;
  }
 else {
    tMax=txMax;
    normalMax=xNormal;
  }
  final double tzMin;
  final double tzMax;
  final Vector3d zNormal;
  if (direction.getZ() >= 0) {
    tzMin=(this.min.getZ() - start.getZ()) / direction.getZ();
    tzMax=(this.max.getZ() - start.getZ()) / direction.getZ();
    zNormal=Vector3d.UNIT_Z;
  }
 else {
    tzMin=(this.max.getZ() - start.getZ()) / direction.getZ();
    tzMax=(this.min.getZ() - start.getZ()) / direction.getZ();
    zNormal=Vector3d.UNIT_Z.negate();
  }
  if (tMin > tzMax || tMax < tzMin) {
    return Optional.empty();
  }
  if (tzMin == tMin) {
    normalMin=normalMin.sub(zNormal);
  }
 else   if (tzMin > tMin) {
    tMin=tzMin;
    normalMin=zNormal.negate();
  }
  if (tzMax == tMax) {
    normalMax=normalMax.add(zNormal);
  }
 else   if (tzMax < tMax) {
    tMax=tzMax;
    normalMax=zNormal;
  }
  if (tMax < 0) {
    return Optional.empty();
  }
  final double t;
  Vector3d normal;
  if (tMin < 0) {
    t=tMax;
    normal=normalMax;
  }
 else {
    t=tMin;
    normal=normalMin;
  }
  normal=normal.normalize();
  final double x;
  final double y;
  final double z;
  if (normal.getX() > 0) {
    x=max.getX();
  }
 else   if (normal.getX() < 0) {
    x=min.getX();
  }
 else {
    x=direction.getX() * t + start.getX();
  }
  if (normal.getY() > 0) {
    y=max.getY();
  }
 else   if (normal.getY() < 0) {
    y=min.getY();
  }
 else {
    y=direction.getY() * t + start.getY();
  }
  if (normal.getZ() > 0) {
    z=max.getZ();
  }
 else   if (normal.getZ() < 0) {
    z=min.getZ();
  }
 else {
    z=direction.getZ() * t + start.getZ();
  }
  return Optional.of(new Tuple<>(new Vector3d(x,y,z),normal));
}","/** 
 * Tests for intersection between the box and a ray defined by a starting point and a direction.
 * @param start The starting point of the ray
 * @param direction The direction of the ray
 * @return An intersection point its normal, if any
 */
public Optional<Tuple<Vector3d,Vector3d>> intersects(Vector3d start,Vector3d direction){
  final double txMin;
  final double txMax;
  final Vector3d xNormal;
  if (Math.copySign(1,direction.getX()) > 0) {
    txMin=(this.min.getX() - start.getX()) / direction.getX();
    txMax=(this.max.getX() - start.getX()) / direction.getX();
    xNormal=Vector3d.UNIT_X;
  }
 else {
    txMin=(this.max.getX() - start.getX()) / direction.getX();
    txMax=(this.min.getX() - start.getX()) / direction.getX();
    xNormal=Vector3d.UNIT_X.negate();
  }
  final double tyMin;
  final double tyMax;
  final Vector3d yNormal;
  if (Math.copySign(1,direction.getY()) > 0) {
    tyMin=(this.min.getY() - start.getY()) / direction.getY();
    tyMax=(this.max.getY() - start.getY()) / direction.getY();
    yNormal=Vector3d.UNIT_Y;
  }
 else {
    tyMin=(this.max.getY() - start.getY()) / direction.getY();
    tyMax=(this.min.getY() - start.getY()) / direction.getY();
    yNormal=Vector3d.UNIT_Y.negate();
  }
  if (txMin > tyMax || txMax < tyMin) {
    return Optional.empty();
  }
  Vector3d normalMax;
  Vector3d normalMin;
  double tMin;
  if (tyMin == txMin) {
    tMin=tyMin;
    normalMin=xNormal.negate().sub(yNormal);
  }
 else   if (tyMin > txMin) {
    tMin=tyMin;
    normalMin=yNormal.negate();
  }
 else {
    tMin=txMin;
    normalMin=xNormal.negate();
  }
  double tMax;
  if (tyMax == txMax) {
    tMax=tyMax;
    normalMax=xNormal.add(yNormal);
  }
 else   if (tyMax < txMax) {
    tMax=tyMax;
    normalMax=yNormal;
  }
 else {
    tMax=txMax;
    normalMax=xNormal;
  }
  final double tzMin;
  final double tzMax;
  final Vector3d zNormal;
  if (Math.copySign(1,direction.getZ()) > 0) {
    tzMin=(this.min.getZ() - start.getZ()) / direction.getZ();
    tzMax=(this.max.getZ() - start.getZ()) / direction.getZ();
    zNormal=Vector3d.UNIT_Z;
  }
 else {
    tzMin=(this.max.getZ() - start.getZ()) / direction.getZ();
    tzMax=(this.min.getZ() - start.getZ()) / direction.getZ();
    zNormal=Vector3d.UNIT_Z.negate();
  }
  if (tMin > tzMax || tMax < tzMin) {
    return Optional.empty();
  }
  if (tzMin == tMin) {
    normalMin=normalMin.sub(zNormal);
  }
 else   if (tzMin > tMin) {
    tMin=tzMin;
    normalMin=zNormal.negate();
  }
  if (tzMax == tMax) {
    normalMax=normalMax.add(zNormal);
  }
 else   if (tzMax < tMax) {
    tMax=tzMax;
    normalMax=zNormal;
  }
  if (tMax < 0) {
    return Optional.empty();
  }
  final double t;
  Vector3d normal;
  if (tMin < 0) {
    t=tMax;
    normal=normalMax;
  }
 else {
    t=tMin;
    normal=normalMin;
  }
  normal=normal.normalize();
  final double x;
  final double y;
  final double z;
  if (normal.getX() > 0) {
    x=max.getX();
  }
 else   if (normal.getX() < 0) {
    x=min.getX();
  }
 else {
    x=direction.getX() * t + start.getX();
  }
  if (normal.getY() > 0) {
    y=max.getY();
  }
 else   if (normal.getY() < 0) {
    y=min.getY();
  }
 else {
    y=direction.getY() * t + start.getY();
  }
  if (normal.getZ() > 0) {
    z=max.getZ();
  }
 else   if (normal.getZ() < 0) {
    z=min.getZ();
  }
 else {
    z=direction.getZ() * t + start.getZ();
  }
  return Optional.of(new Tuple<>(new Vector3d(x,y,z),normal));
}"
27736,"@Override protected Optional<Text> buildContent(DataView container) throws InvalidDataException {
  Optional<Object> json=container.get(Queries.JSON);
  if (json.isPresent()) {
    try {
      return Optional.of(TextSerializers.JSON.deserialize(json.get().toString()));
    }
 catch (    TextParseException e) {
      throw new InvalidDataException(e);
    }
  }
  return Optional.empty();
}","@Override protected Optional<Text> buildContent(DataView container) throws InvalidDataException {
  try {
    return container.get(Queries.JSON).map(json -> TextSerializers.JSON.deserialize(json.toString()));
  }
 catch (  TextParseException e) {
    throw new InvalidDataException(e);
  }
}"
27737,"@Override public Text deserialize(TypeToken<?> type,ConfigurationNode value) throws ObjectMappingException {
  StringWriter writer=new StringWriter();
  GsonConfigurationLoader gsonLoader=GsonConfigurationLoader.builder().setSink(() -> new BufferedWriter(writer)).build();
  try {
    gsonLoader.save(value);
  }
 catch (  IOException e) {
    throw new ObjectMappingException(e);
  }
  return Sponge.getDataManager().deserialize(Text.class,new MemoryDataContainer().set(Queries.JSON,writer.getBuffer().toString())).get();
}","@Override public Text deserialize(TypeToken<?> type,ConfigurationNode value) throws ObjectMappingException {
  StringWriter writer=new StringWriter();
  GsonConfigurationLoader gsonLoader=GsonConfigurationLoader.builder().setIndent(0).setSink(() -> new BufferedWriter(writer)).build();
  value=gsonLoader.createEmptyNode().setValue(value);
  try {
    gsonLoader.save(value);
  }
 catch (  IOException e) {
    throw new ObjectMappingException(e);
  }
  return Sponge.getDataManager().deserialize(Text.class,new MemoryDataContainer().set(Queries.JSON,writer.toString())).get();
}"
27738,"private Pattern getFormattedPattern(String input){
  if (!input.startsWith(""String_Node_Str"")) {
    input=""String_Node_Str"" + input;
  }
  return Pattern.compile(input,Pattern.CASE_INSENSITIVE);
}","Pattern getFormattedPattern(String input){
  if (!input.startsWith(""String_Node_Str"")) {
    input=""String_Node_Str"" + input;
  }
  return Pattern.compile(input,Pattern.CASE_INSENSITIVE);
}"
27739,"private Text.Builder applyArg(TextElement param,Arg arg,@Nullable Text.Builder builder){
  Text.Builder wrapper=Text.builder().format(arg.format);
  param.applyTo(wrapper);
  if (builder == null) {
    builder=wrapper;
  }
 else {
    builder.append(wrapper.build());
  }
  return builder;
}","private Text.Builder applyArg(TextElement param,Arg arg,@Nullable Text.Builder builder){
  if (builder == null) {
    builder=Text.builder();
  }
  Text.Builder wrapper=Text.builder().format(arg.format);
  param.applyTo(wrapper);
  builder.append(wrapper.build());
  return builder;
}"
27740,"/** 
 * Gets the   {@link Value} for the targeted {@link Location}.
 * @return The value for the targeted location
 */
default Value<Location<World>> target(){
  return getValue(Keys.TARGETED_LOCATION).get();
}","/** 
 * Gets the   {@link Value} for the targeted {@link Location}.
 * @return The value for the targeted location
 */
default Value<Vector3d> target(){
  return getValue(Keys.TARGETED_LOCATION).get();
}"
27741,"/** 
 * Adds the specified   {@link Text} to this team.<p>While any  {@link Text} may be added, the {@link Text}to use should normally be obtained by calling   {@link TeamMember#getTeamRepresentation()}on a   {@link TeamMember}, such as a   {@link Player}.</p>
 * @param member the {@link Text} to add
 */
void addMember(Text member);","/** 
 * Adds the specified   {@link Text} to this team.<p>While any  {@link Text} may be added, the {@link Text} to use shouldnormally be obtained by calling {@link TeamMember#getTeamRepresentation()} on a {@link TeamMember}, such as a   {@link Player}.</p>
 * @param member the {@link Text} to add
 */
void addMember(Text member);"
27742,"/** 
 * Removes the specified   {@link Text} from this team.<p>While any  {@link Text} may be removed, the {@link Text}to use should normally be obtained by calling   {@link TeamMember#getTeamRepresentation()}on a   {@link TeamMember}, such as a   {@link Player}.</p
 * @param member The {@link Text} to remove
 * @return Whether the {@link Text} was on this team
 */
boolean removeMember(Text member);","/** 
 * Removes the specified   {@link Text} from this team.<p>While any  {@link Text} may be removed, the {@link Text}to use should normally be obtained by calling   {@link TeamMember#getTeamRepresentation()}on a   {@link TeamMember}, such as a   {@link Player}.</p>
 * @param member The {@link Text} to remove
 * @return Whether the {@link Text} was on this team
 */
boolean removeMember(Text member);"
27743,"/** 
 * Gets an   {@link Text} representing this team member, suitable foradding to an  {@link Team} with {@link Team#addMember(Text).}
 * @return an {@link Text} representing this team member
 */
Text getTeamRepresentation();","/** 
 * Gets a   {@link Text} representing this team member, suitable for addingto an  {@link Team} with {@link Team#addMember(Text)}.
 * @return an {@link Text} representing this team member
 */
Text getTeamRepresentation();"
27744,"<T extends DataSerializable>void registerContentUpdater(Class<T> clazz,DataContentUpdater updater);","/** 
 * Registers a   {@link DataContentUpdater} for the desired{@link DataSerializable} such that any versioned data may be updated tonewer versions for the most up to date  {@link DataBuilder}.
 * @param clazz The data serializable class
 * @param updater The updater
 * @param < T > The type of DataSerializable
 */
<T extends DataSerializable>void registerContentUpdater(Class<T> clazz,DataContentUpdater updater);"
27745,"<T extends DataSerializable>Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz,int fromVersion,int toVersion);","/** 
 * Gets a wrapped fake   {@link DataContentUpdater} that may wrap several{@link DataContentUpdater}s to translate versioned data from the desired  {@code fromVersion} to the {@code toVersion}. If the version jump is too great or a   {@link DataContentUpdater} has not been registered to coverthe complete jump,  {@link Optional#empty()} may be returned.
 * @param clazz The data serializable class
 * @param fromVersion The version converting from
 * @param toVersion The version converting to
 * @param < T > The type of data serializable
 * @return The content updater, if available
 */
<T extends DataSerializable>Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz,int fromVersion,int toVersion);"
27746,"/** 
 * Registers the given   {@link DataManipulator} class with it's associated{@link DataManipulatorBuilder}. The builder can be used to create new instances of the given   {@link DataManipulator} for data retrieval,data representation, and mass application of a  {@link DataManipulator}to multiple   {@link DataHolder}s.
 * @param manipulatorClass The class of the data manipulator
 * @param immutableManipulatorClass The class of the immutable datamanipulator
 * @param builder The builder instance of the data manipulator
 * @param < T > The type of data manipulator
 * @param < I > The type of immutable datamanipulator
 */
<T extends DataManipulator<T,I>,I extends ImmutableDataManipulator<I,T>>void register(Class<? extends T> manipulatorClass,Class<? extends I> immutableManipulatorClass,DataManipulatorBuilder<T,I> builder);","/** 
 * Registers the given   {@link DataManipulator} class with it's associated{@link DataManipulatorBuilder}. The builder can be used to create new instances of the given   {@link DataManipulator} for data retrieval,data representation, and mass application of a  {@link DataManipulator}to multiple   {@link DataHolder}s.
 * @param manipulatorClass The class of the data manipulator
 * @param immutableManipulatorClass The class of the immutabledatamanipulator
 * @param builder The builder instance of the data manipulator
 * @param < T > The type of data manipulator
 * @param < I > The type of immutable datamanipulator
 */
<T extends DataManipulator<T,I>,I extends ImmutableDataManipulator<I,T>>void register(Class<? extends T> manipulatorClass,Class<? extends I> immutableManipulatorClass,DataManipulatorBuilder<T,I> builder);"
27747,"/** 
 * Constructs a query using the given parts.
 * @param parts The parts
 */
public DataQuery(List<String> parts){
  this.parts=ImmutableList.copyOf(parts);
}","/** 
 * Constructs a query using the given parts.
 * @param parts The parts
 */
private DataQuery(List<String> parts){
  this.parts=ImmutableList.copyOf(parts);
}"
27748,"/** 
 * Creates a new   {@link Key} based on a {@link ListValue} of a type<code>E</code> element along with the provided  {@link DataQuery}.
 * @param elementClass The element class
 * @param query The query to access the data
 * @param < E > The type of element
 * @return The generated key
 */
public static <E>Key<ListValue<E>> makeListKey(final Class<E> elementClass,final DataQuery query){
  return new Key<ListValue<E>>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<ListValue<E>> getValueClass(){
      return (Class<ListValue<E>>)(Class)ListValue.class;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(elementClass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + ""String_Node_Str"" + elementClass + ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}","/** 
 * Creates a new   {@link Key} based on a {@link ListValue} of a type<code>E</code> element along with the provided  {@link DataQuery}.
 * @param elementClass The element class
 * @param query The query to access the data
 * @param < E > The type of element
 * @return The generated key
 */
public static <E>Key<ListValue<E>> makeListKey(final Class<E> elementClass,final DataQuery query){
  return new Key<ListValue<E>>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<ListValue<E>> getValueClass(){
      return (Class<ListValue<E>>)(Class)ListValue.class;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(elementClass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + ""String_Node_Str"" + elementClass.getSimpleName() + ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}"
27749,"/** 
 * Creates a new   {@link Key} based on a {@link SetValue} of a type<code>E</code> element along with the provided  {@link DataQuery}.
 * @param elementClass The element class
 * @param query The query to access the data
 * @param < E > The type of element
 * @return The generated key
 */
public static <E>Key<SetValue<E>> makeSetKey(final Class<E> elementClass,final DataQuery query){
  return new Key<SetValue<E>>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<SetValue<E>> getValueClass(){
      return (Class<SetValue<E>>)(Class)SetValue.class;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(elementClass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + ""String_Node_Str"" + elementClass + ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}","/** 
 * Creates a new   {@link Key} based on a {@link SetValue} of a type<code>E</code> element along with the provided  {@link DataQuery}.
 * @param elementClass The element class
 * @param query The query to access the data
 * @param < E > The type of element
 * @return The generated key
 */
public static <E>Key<SetValue<E>> makeSetKey(final Class<E> elementClass,final DataQuery query){
  return new Key<SetValue<E>>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<SetValue<E>> getValueClass(){
      return (Class<SetValue<E>>)(Class)SetValue.class;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(elementClass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + ""String_Node_Str"" + elementClass.getSimpleName() + ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}"
27750,"/** 
 * Creates a new   {@link Key} based on a {@link MapValue} of the types<code>K</code> keys and <code>V</code> values with the provided {@link DataQuery} for accessing the {@link Map} in {@link DataView}s.
 * @param keyClass The key class of the map
 * @param valueclass The value class of the map
 * @param query The query
 * @param < K > The type of keys
 * @param < V > The type of values
 * @return The generated key
 */
public static <K,V>Key<MapValue<K,V>> makeMapKey(final Class<K> keyClass,final Class<V> valueclass,final DataQuery query){
  return new Key<MapValue<K,V>>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<MapValue<K,V>> getValueClass(){
      return (Class<MapValue<K,V>>)(Class)MapValue.class;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(keyClass,valueclass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + ""String_Node_Str"" + keyClass + ""String_Node_Str""+ valueclass+ ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}","/** 
 * Creates a new   {@link Key} based on a {@link MapValue} of the types<code>K</code> keys and <code>V</code> values with the provided {@link DataQuery} for accessing the {@link Map} in {@link DataView}s.
 * @param keyClass The key class of the map
 * @param valueclass The value class of the map
 * @param query The query
 * @param < K > The type of keys
 * @param < V > The type of values
 * @return The generated key
 */
public static <K,V>Key<MapValue<K,V>> makeMapKey(final Class<K> keyClass,final Class<V> valueclass,final DataQuery query){
  return new Key<MapValue<K,V>>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<MapValue<K,V>> getValueClass(){
      return (Class<MapValue<K,V>>)(Class)MapValue.class;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(keyClass,valueclass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + ""String_Node_Str"" + keyClass.getSimpleName() + ""String_Node_Str""+ valueclass.getSimpleName()+ ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}"
27751,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + keyClass + ""String_Node_Str""+ valueclass+ ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + keyClass.getSimpleName() + ""String_Node_Str""+ valueclass.getSimpleName()+ ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
}"
27752,"/** 
 * Creates a new   {@link Key} with the provided <code>E</code> elementclass and <code>V</code>  {@link Value} class along with the provideddefault  {@link DataQuery} to be used with the generated {@link Key}. <p>Note that   {@link Key}s are not registered, but it is recommended to avoid generating   {@link Key}s of potentially conflicting  {@link DataQuery}(s).</p>
 * @param elementClass The element class
 * @param valueClass The value class
 * @param query The query
 * @param < E > The type of element
 * @param < T > The type of base value class
 * @param < V > The inferred return type
 * @return The generated key
 */
public static <E,T extends BaseValue,V extends BaseValue<E>>Key<V> makeSingleKey(final Class<E> elementClass,final Class<T> valueClass,final DataQuery query){
  return new Key<V>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<V> getValueClass(){
      return (Class<V>)(Class)valueClass;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(elementClass,valueClass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + valueClass.getName() + ""String_Node_Str""+ elementClass+ ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}","/** 
 * Creates a new   {@link Key} with the provided <code>E</code> elementclass and <code>V</code>  {@link Value} class along with the provideddefault  {@link DataQuery} to be used with the generated {@link Key}. <p>Note that   {@link Key}s are not registered, but it is recommended to avoid generating   {@link Key}s of potentially conflicting  {@link DataQuery}(s).</p>
 * @param elementClass The element class
 * @param valueClass The value class
 * @param query The query
 * @param < E > The type of element
 * @param < T > The type of base value class
 * @param < V > The inferred return type
 * @return The generated key
 */
public static <E,T extends BaseValue,V extends BaseValue<E>>Key<V> makeSingleKey(final Class<E> elementClass,final Class<T> valueClass,final DataQuery query){
  return new Key<V>(){
    @SuppressWarnings(""String_Node_Str"") @Override public Class<V> getValueClass(){
      return (Class<V>)(Class)valueClass;
    }
    @Override public DataQuery getQuery(){
      return query;
    }
    @Override public int hashCode(){
      return Objects.hashCode(elementClass,valueClass,query);
    }
    @Override public String toString(){
      return ""String_Node_Str"" + valueClass.getSimpleName() + ""String_Node_Str""+ elementClass.getSimpleName()+ ""String_Node_Str""+ query.toString()+ ""String_Node_Str"";
    }
  }
;
}"
27753,"/** 
 * Gets the   {@link ImmutableWeightedEntityCollectionValue} of all possible{@link Entity} instances that can be spawned by the spawner. As theyare all  {@link WeightedSerializableObject} instances, their weight is defined asa  {@link Random} to determine the next {@link Entity} that will bespawned, unless overriden by  {@link #nextEntityToSpawn()}.
 * @return The immutable weighted entity collection value of entities
 */
ImmutableWeightedCollectionValue<EntitySnapshot> possibleEntitiesToSpawn();","/** 
 * Gets the   {@link ImmutableWeightedCollectionValue} of all possible{@link Entity} instances that can be spawned by the spawner. As theyare all  {@link WeightedSerializableObject} instances, their weight isdefined as a  {@link Random} to determine the next {@link Entity} thatwill be spawned, unless overriden by  {@link #nextEntityToSpawn()}.
 * @return The immutable weighted entity collection value of entities
 */
ImmutableWeightedCollectionValue<EntitySnapshot> possibleEntitiesToSpawn();"
27754,"/** 
 * Gets the   {@link ImmutableBoundedValue} for the minimum range a{@link Player} must remain in proximity of the spawner, such that if a{@link Player} is NOT within the provided range, no attempts to spawn an{@link Entity} is made.
 * @return The immutable value of the required player range to spawn entities
 */
ImmutableBoundedValue<Short> requiredPlayerRange();","/** 
 * Gets the   {@link ImmutableBoundedValue} for the minimum range a{@link Player} must remain in proximity of the spawner, such that if a{@link Player} is NOT within the provided range, no attempts to spawn an{@link Entity} is made.
 * @return The immutable value of the required player range to spawnentities
 */
ImmutableBoundedValue<Short> requiredPlayerRange();"
27755,Builder proxySource(Entity projectile);,B proxySource(Entity proxy);
27756,"protected AbstractDamageSource(AbstractBuilder builder){
  this.apiDamageType=checkNotNull(builder.damageType,""String_Node_Str"");
  this.absolute=builder.absolute;
  this.bypassesArmor=builder.bypasses;
  this.scales=builder.scales;
  this.explosive=builder.explosion;
  this.magic=builder.magical;
  this.creative=builder.creative;
}","protected AbstractDamageSource(AbstractDamageSourceBuilder<?,?> builder){
  this.apiDamageType=checkNotNull(builder.damageType,""String_Node_Str"");
  this.absolute=builder.absolute;
  this.bypassesArmor=builder.bypasses;
  this.scales=builder.scales;
  this.explosive=builder.explosion;
  this.magic=builder.magical;
  this.creative=builder.creative;
}"
27757,"protected AbstractEntityDamageSource(AbstractEntityDamageSourceBuilder builder){
  this.apiDamageType=checkNotNull(builder.damageType,""String_Node_Str"");
  this.absolute=builder.absolute;
  this.bypassesArmor=builder.bypasses;
  this.scales=builder.scales;
  this.explosive=builder.explosion;
  this.magic=builder.magical;
  this.creative=builder.creative;
  this.source=checkNotNull(builder.source,""String_Node_Str"");
}","protected AbstractEntityDamageSource(AbstractEntityDamageSourceBuilder<?,?> builder){
  this.apiDamageType=checkNotNull(builder.damageType,""String_Node_Str"");
  this.absolute=builder.absolute;
  this.bypassesArmor=builder.bypasses;
  this.scales=builder.scales;
  this.explosive=builder.explosion;
  this.magic=builder.magical;
  this.creative=builder.creative;
  this.source=checkNotNull(builder.source,""String_Node_Str"");
}"
27758,"@Override public Builder reset(){
  super.reset();
  this.damageType=null;
  return this;
}","@Override public B reset(){
  super.reset();
  this.damageType=null;
  return (B)this;
}"
27759,"@Override public EntityDamageSource.Builder entity(Entity entity){
  this.source=checkNotNull(entity,""String_Node_Str"");
  return this;
}","@Override public B entity(Entity entity){
  this.source=checkNotNull(entity,""String_Node_Str"");
  return (B)this;
}"
27760,"@Override public Builder proxySource(Entity projectile){
  this.indirect=checkNotNull(projectile);
  return this;
}","@Override public B proxySource(Entity projectile){
  this.indirect=checkNotNull(projectile);
  return (B)this;
}"
27761,"protected AbstractIndirectEntityDamageSource(AbstractEntityDamageSourceBuilder builder){
  this.apiDamageType=checkNotNull(builder.damageType,""String_Node_Str"");
  this.absolute=builder.absolute;
  this.bypassesArmor=builder.bypasses;
  this.scales=builder.scales;
  this.explosive=builder.explosion;
  this.magic=builder.magical;
  this.creative=builder.creative;
  this.source=checkNotNull(builder.source,""String_Node_Str"");
  this.indirect=checkNotNull(builder.indirect,""String_Node_Str"");
}","protected AbstractIndirectEntityDamageSource(AbstractIndirectEntityDamageSourceBuilder<?,?> builder){
  this.apiDamageType=checkNotNull(builder.damageType,""String_Node_Str"");
  this.absolute=builder.absolute;
  this.bypassesArmor=builder.bypasses;
  this.scales=builder.scales;
  this.explosive=builder.explosion;
  this.magic=builder.magical;
  this.creative=builder.creative;
  this.source=checkNotNull(builder.source,""String_Node_Str"");
  this.indirect=checkNotNull(builder.indirect,""String_Node_Str"");
}"
27762,"@Override public Builder reset(){
  super.reset();
  this.source=null;
  this.indirect=null;
  return this;
}","@Override public B reset(){
  super.reset();
  this.source=null;
  this.indirect=null;
  return (B)this;
}"
27763,"@Override public Builder entity(Entity entity){
  this.source=checkNotNull(entity,""String_Node_Str"");
  return this;
}","@Override public B entity(Entity entity){
  this.source=checkNotNull(entity,""String_Node_Str"");
  return (B)this;
}"
27764,"/** 
 * Creates a placeholder   {@link Text} with the specified key and fallback.The created message won't have any formatting or events configured.
 * @param key The key of the placeholder
 * @param fallback The fallback of the text if it is not replaced
 * @return The created text
 * @see Text.Placeholder
 */
public static Text.Placeholder placeholder(String key,Text fallback){
  checkArgument(!checkNotNull(key,""String_Node_Str"").isEmpty(),""String_Node_Str"");
  checkNotNull(fallback,""String_Node_Str"");
  return new Text.Placeholder(key,fallback);
}","/** 
 * Creates a placeholder   {@link Text} with the specified key and fallback.The created message won't have any formatting or events configured.
 * @param key The key of the placeholder
 * @param fallback The fallback of the text if it is not replaced
 * @return The created text
 * @see Text.Placeholder
 */
public static Text.Placeholder placeholder(String key,@Nullable Text fallback){
  return new Text.Placeholder(key,fallback);
}"
27765,"@Override public int hashCode(){
  return Objects.hashCode(style,color);
}","@Override public int hashCode(){
  return Objects.hashCode(this.style,this.color);
}"
27766,"@Override public String toString(){
  return Objects.toStringHelper(this).add(""String_Node_Str"",style).add(""String_Node_Str"",color).toString();
}","@Override public String toString(){
  return Objects.toStringHelper(this).add(""String_Node_Str"",this.style).add(""String_Node_Str"",this.color).toString();
}"
27767,"@Override public String toString(){
  if (this.bold.isPresent() || this.italic.isPresent() || this.underline.isPresent()|| this.strikethrough.isPresent()|| this.obfuscated.isPresent()) {
    return Objects.toStringHelper(this).add(""String_Node_Str"",this.bold).add(""String_Node_Str"",this.italic).add(""String_Node_Str"",this.underline).add(""String_Node_Str"",this.strikethrough).add(""String_Node_Str"",this.obfuscated).toString();
  }
 else {
    return Objects.toStringHelper(this).addValue(""String_Node_Str"").toString();
  }
}","@Override public String toString(){
  return Objects.toStringHelper(this).omitNullValues().add(""String_Node_Str"",this.bold.orElse(null)).add(""String_Node_Str"",this.italic.orElse(null)).add(""String_Node_Str"",this.underline.orElse(null)).add(""String_Node_Str"",this.strikethrough.orElse(null)).add(""String_Node_Str"",this.obfuscated.orElse(null)).toString();
}"
27768,"private static Text formatNoChecks(Text template,Map<String,?> replacements){
  if (template instanceof Placeholder) {
    Object replacement=replacements.get(((Placeholder)template).getKey());
    if (replacement != null) {
      List<Object> formats=new ArrayList<Object>();
      formats.add(template.getColor());
      formats.add(template.getStyle());
      Optional<HoverAction<?>> hoverAction=template.getHoverAction();
      if (hoverAction.isPresent()) {
        formats.add(hoverAction.get());
      }
      Optional<ClickAction<?>> clickAction=template.getClickAction();
      if (clickAction.isPresent()) {
        formats.add(clickAction.get());
      }
      Optional<ShiftClickAction<?>> shiftClickAction=template.getShiftClickAction();
      if (shiftClickAction.isPresent()) {
        formats.add(shiftClickAction.get());
      }
      formats.add(replacement);
      return Texts.of(formats.toArray());
    }
  }
  TextBuilder builder=null;
  for (  Text child : template.getChildren()) {
    Text formatted=formatNoChecks(child,replacements);
    if (builder == null) {
      if (formatted == child) {
        continue;
      }
      builder=template.builder();
      builder.removeAll();
    }
    builder.append(formatted);
  }
  return builder == null ? template : builder.build();
}","private static Text formatNoChecks(Text template,Map<String,?> replacements){
  if (template instanceof Placeholder) {
    Object replacement=replacements.get(((Placeholder)template).getKey());
    if (replacement != null) {
      List<Object> formats=new ArrayList<Object>();
      formats.add(template.getColor());
      formats.add(template.getStyle());
      Optional<HoverAction<?>> hoverAction=template.getHoverAction();
      if (hoverAction.isPresent()) {
        formats.add(hoverAction.get());
      }
      Optional<ClickAction<?>> clickAction=template.getClickAction();
      if (clickAction.isPresent()) {
        formats.add(clickAction.get());
      }
      Optional<ShiftClickAction<?>> shiftClickAction=template.getShiftClickAction();
      if (shiftClickAction.isPresent()) {
        formats.add(shiftClickAction.get());
      }
      formats.add(replacement);
      return Texts.of(formats.toArray());
    }
  }
  TextBuilder builder=null;
  List<Text> children=template.getChildren();
  for (int i=0; i < children.size(); ++i) {
    final Text child=children.get(i);
    Text formatted=formatNoChecks(child,replacements);
    if (builder == null) {
      if (formatted == child) {
        continue;
      }
      builder=template.builder();
      builder.remove(children.subList(i,children.size()));
    }
    builder.append(formatted);
  }
  return builder == null ? template : builder.build();
}"
27769,"/** 
 * Creates a   {@link HarvestingProperty} with a specific set of {@link BlockType}s.
 * @param value The harvestable block types
 * @param op The operator to use when comparing against other properties
 */
public DisplacementProperty(@Nullable Set<BlockType> value,Operator op){
  super(value == null ? ImmutableSet.<BlockType>of() : ImmutableSet.copyOf(value),op);
}","/** 
 * Creates a   {@link DisplacementProperty} with a specific set of{@link BlockType}s.
 * @param value The displaceable block types
 * @param op The operator to use when comparing against other properties
 */
public DisplacementProperty(@Nullable Set<BlockType> value,Operator op){
  super(value == null ? ImmutableSet.<BlockType>of() : ImmutableSet.copyOf(value),op);
}"
27770,"/** 
 * Launches a   {@link Projectile} from this projectile source.
 * @param projectileClass The class of the projectile
 * @param velocity The velocity to launch the projectile
 * @param < T > The Type of Projectile
 * @return The projectile instance that was launched
 */
<T extends Projectile>T launchProjectile(Class<T> projectileClass,Vector3d velocity);","/** 
 * Launches a   {@link Projectile} from this projectile source.
 * @param projectileClass The class of the projectile
 * @param velocity The velocity to launch the projectile
 * @param < T > The Type of Projectile
 * @return The projectile instance if it was launched, or absent
 */
<T extends Projectile>Optional<T> launchProjectile(Class<T> projectileClass,Vector3d velocity);"
27771,"@Override public <T extends Projectile>T launchProjectile(Class<T> projectileClass,Vector3d velocity){
  return null;
}","@Override public <T extends Projectile>Optional<T> launchProjectile(Class<T> projectileClass,Vector3d velocity){
  return Optional.absent();
}"
27772,"/** 
 * Create a new   {@link RconQuitEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param source The {@link RconSource} that caused this event
 * @return A new instance of the event
 */
public static RconQuitEvent createRconQuit(Game game,RconSource source){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",source);
  return createEvent(RconQuitEvent.class,values);
}","/** 
 * Creates a new   {@link RconQuitEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param source The {@link RconSource} that caused this event
 * @return A new instance of the event
 */
public static RconQuitEvent createRconQuit(Game game,RconSource source){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",source);
  return createEvent(RconQuitEvent.class,values);
}"
27773,"/** 
 * Create a new   {@link RconLoginEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param source The {@link RconSource} that caused this event
 * @return A new instance of the event
 */
public static RconLoginEvent createRconLogin(Game game,RconSource source){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",source);
  return createEvent(RconLoginEvent.class,values);
}","/** 
 * Creates a new   {@link RconLoginEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param source The {@link RconSource} that caused this event
 * @return A new instance of the event
 */
public static RconLoginEvent createRconLogin(Game game,RconSource source){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",source);
  return createEvent(RconLoginEvent.class,values);
}"
27774,"/** 
 * Gets the next air block in the buffer, starting from the given y coordinate and going down until yEnd. Returns yEnd if none is found.
 * @param buffer The buffer to iterate
 * @param x The x coordinate of the starting point
 * @param y The y coordinate of the starting point
 * @param z The z coordinate of the starting point
 * @param yEnd The lowest y coordinate to check
 * @return The y coordinate of the next air block or yEnd if none found.
 */
@SuppressWarnings(""String_Node_Str"") static int getNextAir(MutableBlockVolume buffer,int x,int y,int z,int yEnd){
  for (; y >= yEnd && !buffer.getBlockType(x,y,z).equals(BlockTypes.AIR); y--) {
  }
  return y;
}","/** 
 * Gets the next air block in the buffer, starting from the given y coordinate and going down until yEnd. Returns yEnd if none is found.
 * @param buffer The buffer to iterate
 * @param x The x coordinate of the starting point
 * @param y The y coordinate of the starting point
 * @param z The z coordinate of the starting point
 * @param yEnd The lowest y coordinate to check
 * @return The y coordinate of the next air block or yEnd if none found.
 */
static int getNextAir(MutableBlockVolume buffer,int x,int y,int z,int yEnd){
  for (; y >= yEnd && !buffer.getBlockType(x,y,z).equals(BlockTypes.AIR); y--) {
  }
  return y;
}"
27775,"/** 
 * Gets the next non-air block in the buffer, starting from the given y coordinate and going down until yEnd. Returns yEnd if none is found.
 * @param buffer The buffer to iterate
 * @param x The x coordinate of the starting point
 * @param y The y coordinate of the starting point
 * @param z The z coordinate of the starting point
 * @param yEnd The lowest y coordinate to check
 * @return The y coordinate of the next non-air block or yEnd if nonefound.
 */
@SuppressWarnings(""String_Node_Str"") static int getNextSolid(MutableBlockVolume buffer,int x,int y,int z,int yEnd){
  for (; y >= yEnd && buffer.getBlockType(x,y,z).equals(BlockTypes.AIR); y--) {
  }
  return y;
}","/** 
 * Gets the next non-air block in the buffer, starting from the given y coordinate and going down until yEnd. Returns yEnd if none is found.
 * @param buffer The buffer to iterate
 * @param x The x coordinate of the starting point
 * @param y The y coordinate of the starting point
 * @param z The z coordinate of the starting point
 * @param yEnd The lowest y coordinate to check
 * @return The y coordinate of the next non-air block or yEnd if nonefound.
 */
static int getNextSolid(MutableBlockVolume buffer,int x,int y,int z,int yEnd){
  for (; y >= yEnd && buffer.getBlockType(x,y,z).equals(BlockTypes.AIR); y--) {
  }
  return y;
}"
27776,"/** 
 * Creates a new builder with the given ItemStack as a blueprint with all the defaults.
 * @param itemStack The item stack to copy
 * @return This builder, for chaining
 */
ItemStackBuilder fromItemStack(ItemStack itemStack);","/** 
 * Sets all the settings in this builder from the item stack blueprint.
 * @param itemStack The item stack to copy
 * @return This builder, for chaining
 */
ItemStackBuilder fromItemStack(ItemStack itemStack);"
27777,"/** 
 * A message sink that targets all subjects contained within the given sinks and applies the message transformations of each sink in order (so with n sinks,   {@code sinks[n-1].transform(sinks[n-2].transform(sink[...].transform(sink[0].transform(input))))} would occur)
 * @param sinks The sinks to combine
 * @return The sink
 */
MessageSink combined(MessageSink... sinks);","/** 
 * A message sink that targets all subjects contained within the given sinks and applies the message transformations of each sink in order (so with n sinks,  {@code sinks[n-1].transformMessage(sinks[n-2].transformMessage(sinks[...].transformMessage(sinks[0].transformMessage(input))))} would occur)
 * @param sinks The sinks to combine
 * @return The sink
 */
MessageSink combined(MessageSink... sinks);"
27778,"/** 
 * A message sink that targets all subjects contained within the given sinks and applies the message transformations of each sink in order (so with n sinks,   {@code sinks[n-1].transform(sinks[n-2].transform(sink[...].transform(sink[0].transform(input))))} would occur)
 * @param sinks The sinks to combine
 * @return The sink
 */
public static MessageSink combined(MessageSink... sinks){
  return factory.combined(sinks);
}","/** 
 * A message sink that targets all subjects contained within the given sinks and applies the message transformations of each sink in order (so with n sinks,  {@code sinks[n-1].transformMessage(sinks[n-2].transformMessage(sinks[...].transformMessage(sinks[0].transformMessage(input))))} would occur)
 * @param sinks The sinks to combine
 * @return The sink
 */
public static MessageSink combined(MessageSink... sinks){
  return factory.combined(sinks);
}"
27779,"/** 
 * Gets the user this ban applies to.
 * @return The user
 */
User getUser();","/** 
 * Gets the user this ban applies to.
 * @return The user
 */
org.spongepowered.api.entity.player.User getUser();"
27780,"/** 
 * Initializes a block ray builder for the entity's eye. If the eye location isn't defined for the entity, the regular location is used. This sets both the starting point and direction.
 * @param entity The entity
 * @return A new block ray builder
 */
public static BlockRayBuilder from(Entity entity){
  Preconditions.checkNotNull(entity,""String_Node_Str"");
  final Vector3d rotation=entity.getRotation();
  final Vector3d direction=Quaterniond.fromAxesAnglesDeg(rotation.getY(),360 - rotation.getX(),rotation.getZ()).getDirection();
  final Location location=entity.getLocation();
  final Vector3d position;
  final Optional<EyeLocationData> data=entity.getData(EyeLocationData.class);
  if (data.isPresent()) {
    position=data.get().getEyeLocation();
  }
 else {
    position=location.getPosition();
  }
  return from(location.getExtent(),position).direction(direction);
}","/** 
 * Initializes a block ray builder for the entity's eye. If the eye location isn't defined for the entity, the regular location is used. This sets both the starting point and direction.
 * @param entity The entity
 * @return A new block ray builder
 */
public static BlockRayBuilder from(Entity entity){
  checkNotNull(entity,""String_Node_Str"");
  final Vector3d rotation=entity.getRotation();
  final Vector3d direction=Quaterniond.fromAxesAnglesDeg(rotation.getY(),360 - rotation.getX(),rotation.getZ()).getDirection();
  final Location location=entity.getLocation();
  final Vector3d position;
  final Optional<EyeLocationData> data=entity.getData(EyeLocationData.class);
  if (data.isPresent()) {
    position=data.get().getEyeLocation();
  }
 else {
    position=location.getPosition();
  }
  return from(location.getExtent(),position).direction(direction);
}"
27781,"/** 
 * Sets the direction. This or setting the ending location is required and can only be done once.
 * @param direction The direction
 * @return This for chained calls
 */
public BlockRayBuilder direction(Vector3d direction){
  Preconditions.checkState(this.direction == null,""String_Node_Str"");
  Preconditions.checkNotNull(direction,""String_Node_Str"");
  Preconditions.checkArgument(direction.lengthSquared() != 0,""String_Node_Str"");
  this.direction=direction.normalize();
  return this;
}","/** 
 * Sets the direction. This or setting the ending location is required and can only be done once.
 * @param direction The direction
 * @return This for chained calls
 */
public BlockRayBuilder direction(Vector3d direction){
  checkState(this.direction == null,""String_Node_Str"");
  checkNotNull(direction,""String_Node_Str"");
  checkArgument(direction.lengthSquared() != 0,""String_Node_Str"");
  this.direction=direction.normalize();
  return this;
}"
27782,"/** 
 * Adds filters to the block ray. This is optional. Multiple filters will be ANDed together.
 * @param filters The filters to add
 * @return This for chained calls
 */
public BlockRayBuilder filter(final Predicate<BlockRayHit>... filters){
  Preconditions.checkNotNull(filters,""String_Node_Str"");
  final Predicate<BlockRayHit> filter=filters.length == 1 ? filters[0] : Predicates.<BlockRayHit>and(filters);
  if (this.filter == ALL_FILTER) {
    this.filter=filter;
  }
 else {
    this.filter=Predicates.and(this.filter,filter);
  }
  return this;
}","/** 
 * Adds filters to the block ray. This is optional. Multiple filters will be ANDed together.
 * @param filters The filters to add
 * @return This for chained calls
 */
public BlockRayBuilder filter(final Predicate<BlockRayHit>... filters){
  checkNotNull(filters,""String_Node_Str"");
  final Predicate<BlockRayHit> filter=filters.length == 1 ? filters[0] : Predicates.<BlockRayHit>and(filters);
  if (this.filter == ALL_FILTER) {
    this.filter=filter;
  }
 else {
    this.filter=Predicates.and(this.filter,filter);
  }
  return this;
}"
27783,"/** 
 * Returns a block ray build from the settings. An ending location or direction needs to have been set.
 * @return A block ray
 */
public BlockRay build(){
  Preconditions.checkState(this.direction != null,""String_Node_Str"");
  final BlockRay blockRay=new BlockRay(this.filter,this.extent,this.position,this.direction);
  blockRay.setBlockLimit(this.blockLimit);
  return blockRay;
}","/** 
 * Returns a block ray build from the settings. An ending location or direction needs to have been set.
 * @return A block ray
 */
public BlockRay build(){
  checkState(this.direction != null,""String_Node_Str"");
  final BlockRay blockRay=new BlockRay(this.filter,this.extent,this.position,this.direction);
  blockRay.setBlockLimit(this.blockLimit);
  return blockRay;
}"
27784,"/** 
 * Sets the direction and ending location. This or setting the direction is required and can only be done once.
 * @param end The ending location
 * @return This for chained calls
 */
public BlockRayBuilder to(Vector3d end){
  Preconditions.checkState(this.direction == null,""String_Node_Str"");
  Preconditions.checkNotNull(end,""String_Node_Str"");
  Preconditions.checkArgument(!this.position.equals(end),""String_Node_Str"");
  this.direction=end.sub(this.position).normalize();
  return filter(new TargetBlockFilter(end));
}","/** 
 * Sets the direction and ending location. This or setting the direction is required and can only be done once.
 * @param end The ending location
 * @return This for chained calls
 */
public BlockRayBuilder to(Vector3d end){
  checkState(this.direction == null,""String_Node_Str"");
  checkNotNull(end,""String_Node_Str"");
  checkArgument(!this.position.equals(end),""String_Node_Str"");
  this.direction=end.sub(this.position).normalize();
  return filter(new TargetBlockFilter(end));
}"
27785,"@Override public Optional<CommandResult> process(CommandSource source,String commandLine){
  final String[] argSplit=commandLine.split(""String_Node_Str"",2);
  final CommandEvent event=SpongeEventFactory.createCommand(this.game,argSplit.length > 1 ? argSplit[1] : ""String_Node_Str"",source,argSplit[0],null);
  this.game.getEventManager().post(event);
  if (event.isCancelled()) {
    return event.getResult();
  }
  try {
    try {
      return this.dispatcher.process(source,commandLine);
    }
 catch (    InvocationCommandException ex) {
      if (ex.getCause() != null) {
        throw ex.getCause();
      }
    }
catch (    CommandPermissionException ex) {
      Text text=ex.getText();
      if (text != null) {
        source.sendMessage(error(text));
      }
    }
catch (    CommandException ex) {
      Text text=ex.getText();
      if (text != null) {
        source.sendMessage(error(text));
      }
      final Optional<CommandMapping> mapping=this.dispatcher.get(argSplit[0],source);
      if (mapping.isPresent()) {
        source.sendMessage(error(t(""String_Node_Str"",argSplit[0],mapping.get().getCallable().getUsage(source))));
      }
    }
  }
 catch (  Throwable thr) {
    TextBuilder excBuilder=Texts.builder(thr.getMessage());
    if (source.hasPermission(""String_Node_Str"")) {
      final StringWriter writer=new StringWriter();
      thr.printStackTrace(new PrintWriter(writer));
      excBuilder.onHover(TextActions.showText(Texts.of(writer.toString().replaceAll(""String_Node_Str"",""String_Node_Str""))));
    }
    source.sendMessage(error(t(""String_Node_Str"",excBuilder.build())));
    this.log.error(Texts.toPlain(t(""String_Node_Str"",commandLine,source.toString(),thr.getMessage())),thr);
  }
  return Optional.of(CommandResult.empty());
}","@Override public Optional<CommandResult> process(CommandSource source,String commandLine){
  final String[] argSplit=commandLine.split(""String_Node_Str"",2);
  final CommandEvent event=SpongeEventFactory.createCommand(this.game,argSplit.length > 1 ? argSplit[1] : ""String_Node_Str"",source,argSplit[0],null);
  this.game.getEventManager().post(event);
  if (event.isCancelled()) {
    return event.getResult();
  }
  try {
    try {
      return this.dispatcher.process(source,commandLine);
    }
 catch (    InvocationCommandException ex) {
      if (ex.getCause() != null) {
        throw ex.getCause();
      }
    }
catch (    CommandPermissionException ex) {
      Text text=ex.getText();
      if (text != null) {
        source.sendMessage(error(text));
      }
    }
catch (    CommandException ex) {
      Text text=ex.getText();
      if (text != null) {
        source.sendMessage(error(text));
      }
      final Optional<CommandMapping> mapping=this.dispatcher.get(argSplit[0],source);
      if (mapping.isPresent()) {
        source.sendMessage(error(t(""String_Node_Str"",argSplit[0],mapping.get().getCallable().getUsage(source))));
      }
    }
  }
 catch (  Throwable thr) {
    TextBuilder excBuilder;
    if (thr instanceof TextMessageException) {
      Text text=((TextMessageException)thr).getText();
      excBuilder=text == null ? Texts.builder(""String_Node_Str"") : text.builder();
    }
 else {
      excBuilder=Texts.builder(String.valueOf(thr.getMessage()));
    }
    if (source.hasPermission(""String_Node_Str"")) {
      final StringWriter writer=new StringWriter();
      thr.printStackTrace(new PrintWriter(writer));
      excBuilder.onHover(TextActions.showText(Texts.of(writer.toString().replaceAll(""String_Node_Str"",""String_Node_Str""))));
    }
    source.sendMessage(error(t(""String_Node_Str"",excBuilder.build())));
    this.log.error(Texts.toPlain(t(""String_Node_Str"",commandLine,source.toString(),thr.getMessage())),thr);
  }
  return Optional.of(CommandResult.empty());
}"
27786,"@Override public List<String> getSuggestions(CommandSource src,String arguments){
  try {
    final String[] argSplit=arguments.split(""String_Node_Str"",2);
    List<String> suggestions=new ArrayList<String>(this.dispatcher.getSuggestions(src,arguments));
    final CommandSuggestionsEvent event=SpongeEventFactory.createCommandSuggestions(this.game,argSplit.length > 1 ? argSplit[1] : ""String_Node_Str"",src,argSplit[0],suggestions);
    game.getEventManager().post(event);
    if (event.isCancelled()) {
      return ImmutableList.of();
    }
 else {
      return ImmutableList.copyOf(event.getSuggestions());
    }
  }
 catch (  CommandException e) {
    src.sendMessage(error(t(""String_Node_Str"",e.getText())));
    return Collections.emptyList();
  }
}","@Override public List<String> getSuggestions(CommandSource src,String arguments){
  try {
    final String[] argSplit=arguments.split(""String_Node_Str"",2);
    List<String> suggestions=new ArrayList<String>(this.dispatcher.getSuggestions(src,arguments));
    final CommandSuggestionsEvent event=SpongeEventFactory.createCommandSuggestions(this.game,argSplit.length > 1 ? argSplit[1] : ""String_Node_Str"",src,argSplit[0],suggestions);
    this.game.getEventManager().post(event);
    if (event.isCancelled()) {
      return ImmutableList.of();
    }
 else {
      return ImmutableList.copyOf(event.getSuggestions());
    }
  }
 catch (  CommandException e) {
    src.sendMessage(error(t(""String_Node_Str"",e.getText())));
    return Collections.emptyList();
  }
}"
27787,"/** 
 * Gets the unique human-readable name of this individual   {@link CatalogType}.
 * @return The uniquely identifiable name of this catalog type
 */
String getName();","/** 
 * Gets the unique human-readable name of this individual  {@link CatalogType}.
 * @return The uniquely identifiable name of this catalog type
 */
String getName();"
27788,"/** 
 * Gets a collection of all available found specific types of   {@link CatalogType} requested.<p>The presented  {@link CatalogType}s may not exist in default catalogs due to various reasons including but not restricted to: mods, plugins, game changes.</p>
 * @param typeClass The class of {@link CatalogType}
 * @param < T > The type of {@link CatalogType}
 * @return A collection of all known types of the requested catalog type
 */
<T extends CatalogType>Collection<? extends T> getAllOf(Class<T> typeClass);","/** 
 * Gets a collection of all available found specific types of  {@link CatalogType} requested.<p>The presented  {@link CatalogType}s may not exist in default catalogs due to various reasons including but not restricted to: mods, plugins, game changes.</p>
 * @param typeClass The class of {@link CatalogType}
 * @param < T > The type of {@link CatalogType}
 * @return A collection of all known types of the requested catalog type
 */
<T extends CatalogType>Collection<? extends T> getAllOf(Class<T> typeClass);"
27789,"/** 
 * Return the internal ID for the block. <p>The format of the internal ID may vary between implementations but in Minecraft, it follows the format of   {@code domain:type}, an example being   {@code minecraft:stone}.</p>
 * @return The id
 */
String getName();","/** 
 * Return the internal ID for the block. <p>The format of the internal ID may vary between implementations but in Minecraft, it follows the format of   {@code domain:type}, an example being   {@code minecraft:stone}.</p>
 * @return The id
 */
@Override String getName();"
27790,"/** 
 * Offers the given   {@link DataManipulator} to this {@link DataHolder}. <p>If any data is rejected or existing data is replaced, the   {@link DataTransactionResult} will retain the rejected and replaced data.</p>
 * @param manipulatorData The manipulator data to offer
 * @param < T > The type of manipulator data
 * @param priority The data priority to use
 * @return The transaction result
 */
<T extends DataManipulator<T>>DataTransactionResult offer(T manipulatorData,DataPriority priority);","/** 
 * Offers the given   {@link DataManipulator} to this {@link DataHolder}. <p>If any data is rejected or existing data is replaced, the  {@link DataTransactionResult} will retain the rejected and replaceddata.</p>
 * @param manipulatorData The manipulator data to offer
 * @param < T > The type of manipulator data
 * @param priority The data priority to use
 * @return The transaction result
 */
<T extends DataManipulator<T>>DataTransactionResult offer(T manipulatorData,DataPriority priority);"
27791,"/** 
 * Attempts to retrieve a specific   {@link Property} type of this {@link DataHolder}. If the property is not applicable,   {@link Optional#absent()}is returned. <p>  {@link Property}s can define various immutable information about a  {@link DataHolder} that is dependent on the instance of the holder.As  {@link Property}s cannot be changed, the   {@link DataHolder} cannot change the information about it's own properties either.</p>
 * @param propertyClass The property class
 * @param < T > The type of property
 * @return The property, if available
 */
<T extends Property<?,?>>Optional<T> getProperty(Class<T> propertyClass);","/** 
 * Attempts to retrieve a specific   {@link Property} type of this{@link DataHolder}. If the property is not applicable,  {@link Optional#absent()} is returned.<p> {@link Property}s can define various immutable information about a  {@link DataHolder} that is dependent on the instance of the holder.As  {@link Property}s cannot be changed, the   {@link DataHolder} cannot change the information about it's own properties either.</p>
 * @param propertyClass The property class
 * @param < T > The type of property
 * @return The property, if available
 */
<T extends Property<?,?>>Optional<T> getProperty(Class<T> propertyClass);"
27792,"/** 
 * Gets or creates a new   {@link DataManipulator} that can be accepted bythis  {@link DataHolder}. In the event that there is no data that can be represented by the given   {@link DataManipulator}, a new   {@link DataManipulator} object is created with default values.<p>In the event the  {@link DataManipulator} can not represent any datapertaining to this  {@link DataHolder},   {@link Optional#absent()} isreturned.</p>
 * @param manipulatorClass The data class
 * @param < T > The type of data
 * @return An instance of the class, if not available
 */
<T extends DataManipulator<T>>Optional<T> getOrCreate(Class<T> manipulatorClass);","/** 
 * Gets or creates a new   {@link DataManipulator} that can be accepted bythis  {@link DataHolder}. In the event that there is no data that can be represented by the given   {@link DataManipulator}, a new  {@link DataManipulator} object is created with default values.<p>In the event the  {@link DataManipulator} can not represent any datapertaining to this  {@link DataHolder},   {@link Optional#absent()} isreturned.</p>
 * @param manipulatorClass The data class
 * @param < T > The type of data
 * @return An instance of the class, if not available
 */
<T extends DataManipulator<T>>Optional<T> getOrCreate(Class<T> manipulatorClass);"
27793,"/** 
 * Gets an copied collection of all known   {@link DataManipulator}s belonging to this   {@link DataHolder}. An individual   {@link DataManipulator} can be used for creating new data to replace on this{@link DataHolder}.
 * @return A collection of copied data manipulators belonging to thisdata holder
 */
Collection<? extends DataManipulator<?>> getManipulators();","/** 
 * Gets an copied collection of all known   {@link DataManipulator}s belonging to this   {@link DataHolder}. An individual  {@link DataManipulator} can be used for creating new data to replace onthis  {@link DataHolder}.
 * @return A collection of copied data manipulators belonging to thisdata holder
 */
Collection<? extends DataManipulator<?>> getManipulators();"
27794,"/** 
 * Checks if the given   {@link DataManipulator} class is able to representdata within this  {@link DataHolder}.
 * @param manipulatorClass The data class
 * @param < T > The type of data
 * @return True if this {@link DataHolder} can accept the {@link DataManipulator} object
 */
<T extends DataManipulator<T>>boolean isCompatible(Class<T> manipulatorClass);","/** 
 * Checks if the given   {@link DataManipulator} class is able to representdata within this  {@link DataHolder}.
 * @param manipulatorClass The data class
 * @param < T > The type of data
 * @return True if this {@link DataHolder} can accept the{@link DataManipulator} object
 */
<T extends DataManipulator<T>>boolean isCompatible(Class<T> manipulatorClass);"
27795,"/** 
 * Attempts to read data from the given   {@link DataHolder} and constructsa new copy of this  {@link DataManipulator} as an instance of<code>T</code>. Any data overlap that exists in both the  {@link DataHolder} and this {@link DataManipulator} will be resolved using thegiven  {@link DataPriority}. <p>Any data that overlaps existing data from the   {@link DataHolder} willtake priority and be overwriten from the pre-existing data from the {@link DataHolder}. It is recommended that a call from   {@link DataHolder#isCompatible(Class)} is checked prior to using this method onany  {@link DataHolder}.</p>
 * @param dataHolder The {@link DataHolder} to extract data
 * @param overlap The overlap resolver to decide which data to retain
 * @return A new instance of this {@link DataManipulator} with relevant datafilled from the given  {@link DataHolder}
 */
Optional<T> fill(DataHolder dataHolder,DataPriority overlap);","/** 
 * Attempts to read data from the given   {@link DataHolder} and constructsa new copy of this  {@link DataManipulator} as an instance of<code>T</code>. Any data that overlaps between this and the given {@link DataHolder} will be resolved using the given{@link DataPriority}. <p>Any data that overlaps existing data from the   {@link DataHolder} willtake priority and be overwriten from the pre-existing data from the {@link DataHolder}. It is recommended that a call from  {@link DataHolder#isCompatible(Class)} is checked prior to using thismethod on any  {@link DataHolder}.</p>
 * @param dataHolder The {@link DataHolder} to extract data
 * @param overlap The overlap resolver to decide which data to retain
 * @return A new instance of this {@link DataManipulator} with relevantdata filled from the given  {@link DataHolder}
 */
Optional<T> fill(DataHolder dataHolder,DataPriority overlap);"
27796,"/** 
 * Sets the location using a safe one from  {@link TeleportHelper#getSafeLocation(Location)} and the rotation of thisentity.  {@link RelativePositions} listed inside the EnumSet areconsidered relative. <p>The format of the rotation is represented by:</p> <ul><code>x -> yaw</code>, <code>y -> pitch</code>, <code>z -> roll </code></ul>
 * @param location The location to set
 * @param rotation The rotation to set
 * @param relativePositions The coordinates to set relatively
 * @return True if location was set successfully, false if location couldn'tbe set as no safe location was found
 */
boolean setLocationAndRotationSafely(Location location,Vector3d rotation,EnumSet<RelativePositions> relativePositions);","/** 
 * Sets the location using a safe one from  {@link TeleportHelper#getSafeLocation(Location)} and the rotation of thisentity.  {@link RelativePositions} listed inside the EnumSet areconsidered relative. <p>The format of the rotation is represented by:</p> <ul><code>x -> yaw</code>, <code>y -> pitch</code>, <code>z -> roll </code></ul>
 * @param location The location to set
 * @param rotation The rotation to set
 * @param relativePositions The coordinates to set relatively
 * @return True if location was set successfully, false if locationcouldn't be set as no safe location was found
 */
boolean setLocationAndRotationSafely(Location location,Vector3d rotation,EnumSet<RelativePositions> relativePositions);"
27797,"/** 
 * Sets the location of this entity to a new position in a world which does not have to be loaded (but must at least be enabled). <p>If the target world is loaded then this is equivalent to setting the location via   {@link TargetedLocationData}.</p> <p>If the target world is unloaded but is enabled according to its  {@link org.spongepowered.api.world.storage.WorldProperties#isEnabled()}then this will first load the world before transferring the entity to that world.</p> <p>If the target world is unloaded and not enabled then the transfer will fail.</p>
 * @param uuid The UUID of the target world to transfer to
 * @param position The position in the target world
 * @return True if the teleport was successful
 */
boolean transferToWorld(UUID uuid,Vector3d position);","/** 
 * Sets the location of this entity to a new position in a world which does not have to be loaded (but must at least be enabled). <p>If the target world is loaded then this is equivalent to setting the location via   {@link TargetedLocationData}.</p> <p>If the target world is unloaded but is enabled according to its  {@link WorldProperties#isEnabled()} then this will first load the worldbefore transferring the entity to that world.</p> <p>If the target world is unloaded and not enabled then the transfer will fail.</p>
 * @param uuid The UUID of the target world to transfer to
 * @param position The position in the target world
 * @return True if the teleport was successful
 */
boolean transferToWorld(UUID uuid,Vector3d position);"
27798,"/** 
 * Gets the id of this enchantment. <p>Ex. Minecraft registers Efficiency as ""minecraft:efficiency"".</p>
 * @return The id
 */
String getName();","/** 
 * Gets the id of this enchantment. <p>Ex. Minecraft registers Efficiency as ""minecraft:efficiency"".</p>
 * @return The id
 */
@Override String getName();"
27799,"/** 
 * Gets the id of this item. <p>Ex. Minecraft registers a golden carrot as ""minecraft:golden_carrot"".</p>
 * @return The id
 */
String getName();","/** 
 * Gets the id of this item. <p>Ex. Minecraft registers a golden carrot as ""minecraft:golden_carrot"".</p>
 * @return The id
 */
@Override String getName();"
27800,"/** 
 * Gets the name of this criterion.
 * @return The name of this criterion
 */
String getName();","/** 
 * Gets the name of this criterion.
 * @return The name of this criterion
 */
@Override String getName();"
27801,"/** 
 * Create a new combined argument element and executor to handle the parsing and execution of child commands.
 * @param fallbackExecutor The executor to execute if the child command has been marked optional (Generally when this is wrapped in a {@link GenericArguments#optional(CommandElement)}
 */
public ChildCommandElementExecutor(@Nullable CommandExecutor fallbackExecutor){
  super(Texts.of(""String_Node_Str"" + COUNTER.getAndIncrement()));
  this.fallbackExecutor=fallbackExecutor;
}","/** 
 * Create a new combined argument element and executor to handle the parsing and execution of child commands.
 * @param fallbackExecutor The executor to execute if the child commandhas been marked optional (Generally when this is wrapped in a {@link GenericArguments#optional(CommandElement)}
 */
public ChildCommandElementExecutor(@Nullable CommandExecutor fallbackExecutor){
  super(Texts.of(""String_Node_Str"" + COUNTER.getAndIncrement()));
  this.fallbackExecutor=fallbackExecutor;
}"
27802,"/** 
 * Requests this   {@link Hopper} to transfer an item to the next carrier.<p>Since  {@link Hopper}s normally send items to other   {@link TileEntityCarrier}s adjacent to themselves, if there is no available carrier to send an item to, this will perform nothing.</p>
 */
void transferItem();","/** 
 * Requests this   {@link Hopper} to transfer an item to the next carrier.<p>Since  {@link Hopper}s normally send items to other  {@link TileEntityCarrier}s adjacent to themselves, if there is no available carrier to send an item to, this will perform nothing.</p>
 */
void transferItem();"
27803,"/** 
 * Sets the location using a safe one from   {@link TeleportHelper#getSafeLocation(Location)} and the rotation of this entity. {@link RelativePositions} listed inside the EnumSet are considered relative.<p>The format of the rotation is represented by:</p> <ul><code>x -> yaw</code>, <code>y -> pitch</code>, <code>z -> roll </code></ul>
 * @param location The location to set
 * @param rotation The rotation to set
 * @param relativePositions The coordinates to set relatively
 * @return True if location was set successfully, false if location couldn't be set as no safe location was found
 */
boolean setLocationAndRotationSafely(Location location,Vector3d rotation,EnumSet<RelativePositions> relativePositions);","/** 
 * Sets the location using a safe one from  {@link TeleportHelper#getSafeLocation(Location)} and the rotation of thisentity.  {@link RelativePositions} listed inside the EnumSet areconsidered relative. <p>The format of the rotation is represented by:</p> <ul><code>x -> yaw</code>, <code>y -> pitch</code>, <code>z -> roll </code></ul>
 * @param location The location to set
 * @param rotation The rotation to set
 * @param relativePositions The coordinates to set relatively
 * @return True if location was set successfully, false if location couldn'tbe set as no safe location was found
 */
boolean setLocationAndRotationSafely(Location location,Vector3d rotation,EnumSet<RelativePositions> relativePositions);"
27804,"/** 
 * Sets the damage this projectile will deal to the specified   {@link EntityType} if hit.<p>Note that in events, the damage defined for the provided  {@link EntityType} will take priority over the ""default"" damage as definedfrom  {@link #getDamage()}.</p>
 * @param entityType The {@link EntityType} to set the damage amount for
 * @param damage The damage to deal to the specified {@link EntityType}
 */
void setDamageForEntity(EntityType entityType,double damage);","/** 
 * Sets the damage this projectile will deal to the specified  {@link EntityType} if hit.<p>Note that in events, the damage defined for the provided {@link EntityType} will take priority over the ""default"" damage asdefined from  {@link #getDamage()}.</p>
 * @param entityType The {@link EntityType} to set the damage amount for
 * @param damage The damage to deal to the specified {@link EntityType}
 */
void setDamageForEntity(EntityType entityType,double damage);"
27805,"/** 
 * Gets the damage this projectile will deal to the specified   {@link EntityType} if hit.<p>Note that in events, the damage defined for the provided  {@link EntityType} will take priority over the ""default"" damage as definedfrom  {@link #getDamage()}.</p>
 * @param entityType The {@link EntityType} to set the damage amount for
 * @return The damage to deal to the specified {@link EntityType}
 */
double getDamageForEntity(EntityType entityType);","/** 
 * Gets the damage this projectile will deal to the specified  {@link EntityType} if hit.<p>Note that in events, the damage defined for the provided {@link EntityType} will take priority over the ""default"" damage asdefined from  {@link #getDamage()}.</p>
 * @param entityType The {@link EntityType} to set the damage amount for
 * @return The damage to deal to the specified {@link EntityType}
 */
double getDamageForEntity(EntityType entityType);"
27806,"/** 
 * Creates a new   {@link PlayerPickUpItemEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param player The player involved in this event
 * @param items The items that will be picked up
 * @return A new instance of the event
 */
public static PlayerPickUpItemEvent createPlayerPickUpItem(Game game,Player player,Collection<Entity> items,Inventory inventory){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",items);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",inventory);
  return createEvent(PlayerPickUpItemEvent.class,values);
}","/** 
 * Creates a new   {@link PlayerPickUpItemEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param player The player involved in this event
 * @param items The items that will be picked up
 * @param inventory The inventory involved with the event
 * @return A new instance of the event
 */
public static PlayerPickUpItemEvent createPlayerPickUpItem(Game game,Player player,Collection<Entity> items,Inventory inventory){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",items);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",player);
  values.put(""String_Node_Str"",inventory);
  return createEvent(PlayerPickUpItemEvent.class,values);
}"
27807,"/** 
 * Creates a new   {@link EntityPickUpItemEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param entity The entity involved in this event
 * @param items The items that will be picked up
 * @return A new instance of the event
 */
public static EntityPickUpItemEvent createEntityPickUpItem(Game game,Entity entity,Collection<Entity> items,Inventory inventory){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",entity);
  values.put(""String_Node_Str"",items);
  values.put(""String_Node_Str"",inventory);
  return createEvent(EntityPickUpItemEvent.class,values);
}","/** 
 * Creates a new   {@link EntityPickUpItemEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param entity The entity involved in this event
 * @param items The items that will be picked up
 * @param inventory The inventory involved with the event
 * @return A new instance of the event
 */
public static EntityPickUpItemEvent createEntityPickUpItem(Game game,Entity entity,Collection<Entity> items,Inventory inventory){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",entity);
  values.put(""String_Node_Str"",items);
  values.put(""String_Node_Str"",inventory);
  return createEvent(EntityPickUpItemEvent.class,values);
}"
27808,"/** 
 * Create a new cause instance.
 * @param parent An optional parent
 * @param cause The causing object (may be a block, entity, etc.)
 * @param reason An optional reason
 */
public Cause(@Nullable Cause parent,Object cause,@Nullable Reason reason){
  checkNotNull(cause);
  this.parent=Optional.fromNullable(parent);
  this.cause=cause;
  this.reason=Optional.fromNullable(reason);
}","/** 
 * Create a new cause instance.
 * @param parent An optional parent
 * @param cause The causing object (may be a block, entity, etc.)
 * @param reason An optional reason
 */
public Cause(@Nullable Cause parent,Object cause,@Nullable Reason reason){
  checkNotNull(cause,""String_Node_Str"");
  this.parent=Optional.fromNullable(parent);
  this.cause=cause;
  this.reason=Optional.fromNullable(reason);
}"
27809,"/** 
 * {@inheritDoc}
 */
@Override Player getUser();",@Override Player getUser();
27810,"/** 
 * Gets the name of this score
 * @return The name of this score
 */
Text getName();","/** 
 * Gets the name of this score.
 * @return The name of this score
 */
Text getName();"
27811,"/** 
 * Adds the specified   {@link Objective} to this scoreboard.
 * @param team The {@link Objective} add
 * @throws IllegalArgumentException if an {@link Objective} with the same {@link Objective#getName() name} already exists,or if the specified  {@link Objective} has already been added.
 */
void addObjective(Objective team) throws IllegalArgumentException ;","/** 
 * Adds the specified   {@link Objective} to this scoreboard.
 * @param team The {@link Objective} add
 * @throws IllegalArgumentException if an {@link Objective} with the same{@link Objective#getName() name} already exists, or if thespecified  {@link Objective} has already been added.
 */
void addObjective(Objective team) throws IllegalArgumentException ;"
27812,"/** 
 * Gets a   {@link User}'s   {@link Team}s on this scoreboard.
 * @param user The {@link User} to search for
 * @return The {@link User}'s   {@link Team}s, if the user has any   {@link Team}s
 */
Set<Team> getPlayerTeams(User user);","/** 
 * Gets a   {@link User}'s   {@link Team}s on this scoreboard.
 * @param user The {@link User} to search for
 * @return The {@link User}'s   {@link Team}s, if the user has any  {@link Team}s
 */
Set<Team> getPlayerTeams(User user);"
27813,"/** 
 * Adds the specified   {@link Team} to this scoreboard.
 * @param team The {@link Team} to add
 * @throws IllegalArgumentException if a team with the same {@link Team#getName() name} already exists, or the specified {@link Team} has been added
 */
void addTeam(Team team) throws IllegalArgumentException ;","/** 
 * Adds the specified   {@link Team} to this scoreboard.
 * @param team The {@link Team} to add
 * @throws IllegalArgumentException if a team with the same{@link Team#getName() name} already exists, or the specified{@link Team} has been added
 */
void addTeam(Team team) throws IllegalArgumentException ;"
27814,"/** 
 * Sets the color of the   {@link Team}. <p>The team's color is a distinct concept from its prefix or suffix. It is only used for colored sidebar display slots, and certain statistic criteria.</p>
 * @param color The color to set
 * @throws IllegalArgumentException If color is {@link org.spongepowered.api.text.format.TextColors#RESET}
 * @return This builder
 */
TeamBuilder color(TextColor color) throws IllegalArgumentException ;","/** 
 * Sets the color of the   {@link Team}. <p>The team's color is a distinct concept from its prefix or suffix. It is only used for colored sidebar display slots, and certain statistic criteria.</p>
 * @param color The color to set
 * @return This builder
 * @throws IllegalArgumentException If color is {@link org.spongepowered.api.text.format.TextColors#RESET}
 */
TeamBuilder color(TextColor color) throws IllegalArgumentException ;"
27815,"/** 
 * Sets the name displayed to users for the   {@link Team}. <p>Display names may be truncated in order to meet an implementation-defined length limit. In Vanilla, this is sixteen characters.</p>
 * @param displayName The {@link Text} to set
 * @return This builder
 */
TeamBuilder displayName(Text displayName) throws IllegalArgumentException ;","/** 
 * Sets the name displayed to users for the   {@link Team}. <p>Display names may be truncated in order to meet an implementation-defined length limit. In Vanilla, this is sixteen characters.</p>
 * @param displayName The {@link Text} to set
 * @return This builder
 * @throws IllegalArgumentException If the name is invalid
 */
TeamBuilder displayName(Text displayName) throws IllegalArgumentException ;"
27816,"/** 
 * Gets an entry's   {@link Score} for this Objective.<p>If the  {@link Score} does not exist, it will be created.<x/p>
 * @param name The name of the {@link Score} to get
 * @return The {@link Score} for the specified {@link Text}
 */
Score getScore(Text name);","/** 
 * Gets an entry's   {@link Score} for this Objective.<p>If the  {@link Score} does not exist, it will be created.</p>
 * @param name The name of the {@link Score} to get
 * @return The {@link Score} for the specified {@link Text}
 */
Score getScore(Text name);"
27817,"/** 
 * Constructs a new   {@link ProvisioningException} for the specified service withthe specified cause and a null message.
 * @param cause The cause of this exception
 * @param service The service requested
 */
public ProvisioningException(Throwable cause,Class<?> service){
  super(cause);
  checkNotNull(service);
  this.service=service;
}","/** 
 * Constructs a new   {@link ProvisioningException} for the specified service withthe specified cause and a null message.
 * @param cause The cause of this exception
 * @param service The service requested
 */
public ProvisioningException(Throwable cause,Class<?> service){
  super(cause);
  checkNotNull(service,""String_Node_Str"");
  this.service=service;
}"
27818,"@Override public Optional<CommandMapping> register(Object plugin,CommandCallable callable,List<String> aliases,Function<List<String>,List<String>> callback){
  checkNotNull(plugin);
  Optional<PluginContainer> containerOptional=this.pluginManager.fromInstance(plugin);
  if (!containerOptional.isPresent()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  PluginContainer container=containerOptional.get();
synchronized (this.lock) {
    List<String> aliasesWithPrefix=new ArrayList<String>(aliases.size() * 2);
    for (    String alias : aliases) {
      aliasesWithPrefix.add(alias);
      aliasesWithPrefix.add(container.getId() + ""String_Node_Str"" + alias);
    }
    Optional<CommandMapping> mapping=this.dispatcher.register(callable,aliasesWithPrefix,callback);
    if (mapping.isPresent()) {
      this.owners.put(container,mapping.get());
    }
    return mapping;
  }
}","@Override public Optional<CommandMapping> register(Object plugin,CommandCallable callable,List<String> aliases,Function<List<String>,List<String>> callback){
  checkNotNull(plugin,""String_Node_Str"");
  Optional<PluginContainer> containerOptional=this.pluginManager.fromInstance(plugin);
  if (!containerOptional.isPresent()) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
  }
  PluginContainer container=containerOptional.get();
synchronized (this.lock) {
    List<String> aliasesWithPrefix=new ArrayList<String>(aliases.size() * 2);
    for (    String alias : aliases) {
      aliasesWithPrefix.add(alias);
      aliasesWithPrefix.add(container.getId() + ""String_Node_Str"" + alias);
    }
    Optional<CommandMapping> mapping=this.dispatcher.register(callable,aliasesWithPrefix,callback);
    if (mapping.isPresent()) {
      this.owners.put(container,mapping.get());
    }
    return mapping;
  }
}"
27819,"/** 
 * Creates a new subject data instance, using the provided service to request instances of permission subjects.
 * @param service The service to request subjects from
 */
public MemorySubjectData(PermissionService service){
  checkNotNull(service);
  this.service=service;
}","/** 
 * Creates a new subject data instance, using the provided service to request instances of permission subjects.
 * @param service The service to request subjects from
 */
public MemorySubjectData(PermissionService service){
  checkNotNull(service,""String_Node_Str"");
  this.service=service;
}"
27820,"/** 
 * Deserializes all data existing in this source into a single   {@link DataContainer}. This can be used for passing around data containers without knowing the contents.
 * @return A data container containing all data from this source
 */
Optional<DataContainer> deserialize();","/** 
 * Deserializes all data existing in this source into a single  {@link DataContainer}. This can be used for passing around data containers without knowing the contents.
 * @return A data container containing all data from this source
 */
Optional<DataContainer> deserialize();"
27821,"/** 
 * Attempts to retrieve the   {@link DataSerializableBuilder} for the desired {@link DataSerializable} class.<p>Builders may not always exist for a given  {@link DataSerializable}, nor is it guaranteed that a provided builder will function with all   {@link DataContainer}s.</p>
 * @param clazz The class of the data serializable
 * @param < T > The type of data serializable
 * @return The builder, if available
 */
<T extends DataSerializable>Optional<DataSerializableBuilder<T>> getBuilder(Class<T> clazz);","/** 
 * Attempts to retrieve the   {@link DataSerializableBuilder} for the desired{@link DataSerializable} class.<p>Builders may not always exist for a given  {@link DataSerializable}, nor is it guaranteed that a provided builder will function with all  {@link DataContainer}s.</p>
 * @param clazz The class of the data serializable
 * @param < T > The type of data serializable
 * @return The builder, if available
 */
<T extends DataSerializable>Optional<DataSerializableBuilder<T>> getBuilder(Class<T> clazz);"
27822,"@Override public boolean call(CommandSource source,String arguments,List<String> parents) throws CommandException {
  String[] parts=arguments.split(""String_Node_Str"",2);
  Optional<CommandMapping> mapping=get(parts[0]);
  if (mapping.isPresent()) {
    List<String> passedParents=new ArrayList<String>(parents.size() + 1);
    passedParents.addAll(parents);
    passedParents.add(parts[0]);
    mapping.get().getCallable().call(source,parts.length > 1 ? parts[1] : ""String_Node_Str"",Collections.unmodifiableList(passedParents));
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean call(CommandSource source,String arguments,List<String> parents) throws CommandException {
  String[] parts=arguments.split(""String_Node_Str"",2);
  Optional<CommandMapping> mapping=get(parts[0]);
  if (mapping.isPresent()) {
    List<String> passedParents=new ArrayList<String>(parents.size() + 1);
    passedParents.addAll(parents);
    passedParents.add(parts[0]);
    try {
      mapping.get().getCallable().call(source,parts.length > 1 ? parts[1] : ""String_Node_Str"",Collections.unmodifiableList(passedParents));
    }
 catch (    CommandException c) {
      throw c;
    }
catch (    Throwable t) {
      throw new InvocationCommandException(t);
    }
    return true;
  }
 else {
    return false;
  }
}"
27823,"@Override public List<String> getSuggestions(CommandSource source,String arguments) throws CommandException {
  String[] parts=arguments.split(""String_Node_Str"",2);
  List<String> suggestions=new ArrayList<String>();
  if (parts.length == 1) {
    String incompleteCommand=parts[0].toLowerCase();
synchronized (this) {
      for (      CommandMapping mapping : this.commands.values()) {
        for (        String alias : mapping.getAllAliases()) {
          if (alias.toLowerCase().startsWith(incompleteCommand)) {
            suggestions.add(alias);
          }
        }
      }
    }
  }
 else {
    Optional<CommandMapping> mapping=get(parts[0]);
    if (mapping.isPresent()) {
      mapping.get().getCallable().getSuggestions(source,parts.length > 1 ? parts[1] : ""String_Node_Str"");
    }
  }
  return Collections.unmodifiableList(suggestions);
}","@Override public List<String> getSuggestions(CommandSource source,String arguments) throws CommandException {
  String[] parts=arguments.split(""String_Node_Str"",2);
  List<String> suggestions=new ArrayList<String>();
  if (parts.length == 1) {
    String incompleteCommand=parts[0].toLowerCase();
synchronized (this) {
      for (      CommandMapping mapping : this.commands.values()) {
        for (        String alias : mapping.getAllAliases()) {
          if (alias.toLowerCase().startsWith(incompleteCommand)) {
            suggestions.add(alias);
          }
        }
      }
    }
  }
 else {
    Optional<CommandMapping> mapping=get(parts[0]);
    if (mapping.isPresent()) {
      suggestions.addAll(mapping.get().getCallable().getSuggestions(source,parts.length > 1 ? parts[1] : ""String_Node_Str""));
    }
  }
  return Collections.unmodifiableList(suggestions);
}"
27824,"@Override public List<String> getSuggestions(CommandSource source,String arguments) throws CommandException {
  String[] parts=arguments.split(""String_Node_Str"",2);
  List<String> suggestions=new ArrayList<String>();
  if (parts.length == 1) {
    String incompleteCommand=parts[0].toLowerCase();
synchronized (this) {
      for (      CommandMapping mapping : this.commands.values()) {
        for (        String alias : mapping.getAllAliases()) {
          if (alias.toLowerCase().startsWith(incompleteCommand)) {
            suggestions.add(alias);
          }
        }
      }
    }
  }
 else {
    Optional<CommandMapping> mapping=get(parts[0]);
    if (mapping.isPresent()) {
      suggestions.addAll(mapping.get().getCallable().getSuggestions(source,parts.length > 1 ? parts[1] : ""String_Node_Str""));
    }
  }
  return Collections.unmodifiableList(suggestions);
}","@Override public List<String> getSuggestions(CommandSource source,String arguments) throws CommandException {
  String[] parts=arguments.split(""String_Node_Str"",2);
  List<String> suggestions=new ArrayList<String>();
  if (parts.length == 1) {
    String incompleteCommand=parts[0].toLowerCase();
synchronized (this) {
      for (      CommandMapping mapping : this.commands.values()) {
        for (        String alias : mapping.getAllAliases()) {
          if (alias.toLowerCase().startsWith(incompleteCommand)) {
            suggestions.add(alias);
          }
        }
      }
    }
  }
 else {
    Optional<CommandMapping> mapping=get(parts[0]);
    if (mapping.isPresent()) {
      List<String> ret=mapping.get().getCallable().getSuggestions(source,parts.length > 1 ? parts[1] : ""String_Node_Str"");
      if (ret == null) {
        suggestions.addAll(ret);
      }
    }
  }
  return Collections.unmodifiableList(suggestions);
}"
27825,"@Override public String getShortDescription(CommandSource source){
  return shortDescription;
}","@Override public String getShortDescription(CommandSource source){
  return this.shortDescription;
}"
27826,"@Override public Text getHelp(CommandSource source){
  return help;
}","@Override public Text getHelp(CommandSource source){
  return this.help;
}"
27827,"/** 
 * Retrieves the RecipeRegistry for this GameRegistry
 * @return The recipe registry
 */
RecipeRegistry getRecipeRegistry();","/** 
 * Retrieves the RecipeRegistry for this GameRegistry.
 * @return The recipe registry
 */
RecipeRegistry getRecipeRegistry();"
27828,"/** 
 * Retrieves the GameDictionary (item dictionary) for this GameRegistry
 * @return The item dictionary
 */
GameDictionary getGameDictionary();","/** 
 * Retrieves the GameDictionary (item dictionary) for this GameRegistry.
 * @return The item dictionary
 */
GameDictionary getGameDictionary();"
27829,"/** 
 * Gets the human-readable name of this object
 * @return The name of this object
 */
Translatable getName();","/** 
 * Gets the human-readable name of this object.
 * @return The name of this object
 */
Translatable getName();"
27830,"/** 
 * Get whether this entity can equip the supplied equipment in its slot of the specified type (eg. whether calling   {@link #equip} with the specifiedslot type and item will succeed)
 * @param type The type of equipment slot to query
 * @param equipment The equipment to check for
 */
boolean canEquip(EquipmentType type,@Nullable ItemStack equipment);","/** 
 * Get whether this entity can equip the supplied equipment in its slot of the specified type (eg. whether calling   {@link #equip} with the specifiedslot type and item will succeed)
 * @param type The type of equipment slot to query
 * @param equipment The equipment to check for
 * @return true if can equip the supplied equipment
 */
boolean canEquip(EquipmentType type,@Nullable ItemStack equipment);"
27831,"/** 
 * No subclasses for you!
 */
private Inventories(){
}","/** 
 * No subclasses for you.
 */
private Inventories(){
}"
27832,"/** 
 * Get a new custom inventory builder
 */
public static CustomInventoryBuilder customInventoryBuilder(){
  return Inventories.factory.builder();
}","/** 
 * Get a new custom inventory builder.
 * @return new CustomInventoryBuilder
 */
public static CustomInventoryBuilder customInventoryBuilder(){
  return Inventories.factory.builder();
}"
27833,@Override public TileInventory<Lockable> getInventory();,@Override TileInventory<Lockable> getInventory();
27834,"/** 
 * Creates a new   {@link BrewingStandBrewEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param brewingStand The {@link BrewingStand} involved in this event
 * @param sourceItems The {@link ItemStack}s being modified
 * @param fuelSource The {@link ItemStack} used as the reagent to modify the source items
 * @param brewedItems The {@link ItemStack}s produced as a result
 * @return A new instance of the event
 */
public static BrewingStandBrewEvent createBrewingStandBrewEvent(Game game,BrewingStand brewingStand,List<ItemStack> sourceItems,ItemStack fuelSource,List<ItemStack> brewedItems){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",brewingStand);
  values.put(""String_Node_Str"",brewingStand);
  values.put(""String_Node_Str"",sourceItems);
  values.put(""String_Node_Str"",fuelSource);
  values.put(""String_Node_Str"",brewedItems);
  return createEvent(BrewingStandBrewEvent.class,values);
}","/** 
 * Creates a new   {@link BrewingStandBrewEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param brewingStand The {@link BrewingStand} involved in this event
 * @param sourceItems The {@link ItemStack}s being modified
 * @param fuelSource The {@link ItemStack} used as the reagent to modify the source items
 * @param brewedItems The {@link ItemStack}s produced as a result
 * @param cause The cause
 * @param inventory The inventory of the brewing stand
 * @param blockLoc The location of the brewing stand
 * @return A new instance of the event
 */
public static BrewingStandBrewEvent createBrewingStandBrewEvent(Game game,BrewingStand brewingStand,List<ItemStack> sourceItems,ItemStack fuelSource,List<ItemStack> brewedItems,Cause cause,TileInventory<Lockable> inventory,BlockLoc blockLoc){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",brewingStand);
  values.put(""String_Node_Str"",brewingStand);
  values.put(""String_Node_Str"",sourceItems);
  values.put(""String_Node_Str"",fuelSource);
  values.put(""String_Node_Str"",brewedItems);
  values.put(""String_Node_Str"",brewedItems);
  values.put(""String_Node_Str"",inventory);
  values.put(""String_Node_Str"",Optional.fromNullable(cause));
  values.put(""String_Node_Str"",blockLoc);
  return createEvent(BrewingStandBrewEvent.class,values);
}"
27835,"/** 
 * Creates a new   {@link FurnaceConsumeFuelEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param furnace The {@link Furnace} involved in this event
 * @param burnedItem The {@link ItemStack} consumed for fuel
 * @param remainingFuel The {@link ItemStack} representing the remaining fuel, can be null
 * @return A new instance of the event
 */
public static FurnaceConsumeFuelEvent createFurnaceConsumeFuelEvent(Game game,Furnace furnace,ItemStack burnedItem,ItemStack remainingFuel){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",furnace);
  values.put(""String_Node_Str"",burnedItem);
  values.put(""String_Node_Str"",Optional.fromNullable(remainingFuel));
  return createEvent(FurnaceConsumeFuelEvent.class,values);
}","/** 
 * Creates a new   {@link FurnaceConsumeFuelEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param furnace The {@link Furnace} involved in this event
 * @param burnedItem The {@link ItemStack} consumed for fuel
 * @param remainingFuel The {@link ItemStack} representing the remaining fuel, can be null
 * @param cause The cause
 * @param inventory The inventory of the furnace
 * @param loc The location of the furnace
 * @return A new instance of the event
 */
public static FurnaceConsumeFuelEvent createFurnaceConsumeFuelEvent(Game game,Furnace furnace,ItemStack burnedItem,ItemStack remainingFuel,Cause cause,TileInventory<Lockable> inventory,BlockLoc loc){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",furnace);
  values.put(""String_Node_Str"",burnedItem);
  values.put(""String_Node_Str"",Optional.fromNullable(remainingFuel));
  values.put(""String_Node_Str"",Optional.fromNullable(remainingFuel));
  values.put(""String_Node_Str"",inventory);
  values.put(""String_Node_Str"",Optional.fromNullable(cause));
  values.put(""String_Node_Str"",loc);
  return createEvent(FurnaceConsumeFuelEvent.class,values);
}"
27836,"/** 
 * Creates a new   {@link FurnaceSmeltItemEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param furnace The {@link Furnace} involved in this event
 * @param cookedItem The {@link ItemStack} resulting from smelting the source item
 * @param sourceItem The {@link ItemStack} smelted to create the cooked item
 * @return A new instance of the event
 */
public static FurnaceSmeltItemEvent createFurnaceSmeltItemEvent(Game game,Furnace furnace,ItemStack cookedItem,ItemStack sourceItem){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",furnace);
  values.put(""String_Node_Str"",cookedItem);
  values.put(""String_Node_Str"",sourceItem);
  return createEvent(FurnaceSmeltItemEvent.class,values);
}","/** 
 * Creates a new   {@link FurnaceSmeltItemEvent}.
 * @param game The game instance for this {@link GameEvent}
 * @param furnace The {@link Furnace} involved in this event
 * @param cookedItem The {@link ItemStack} resulting from smelting the source item
 * @param sourceItem The {@link ItemStack} smelted to create the cooked item
 * @param cause The cause
 * @param inventory The inventory of the furnace
 * @param loc The location of the furnace
 * @return A new instance of the event
 */
public static FurnaceSmeltItemEvent createFurnaceSmeltItemEvent(Game game,Furnace furnace,ItemStack cookedItem,ItemStack sourceItem,Cause cause,TileInventory<Lockable> inventory,BlockLoc loc){
  Map<String,Object> values=Maps.newHashMap();
  values.put(""String_Node_Str"",game);
  values.put(""String_Node_Str"",furnace);
  values.put(""String_Node_Str"",cookedItem);
  values.put(""String_Node_Str"",sourceItem);
  values.put(""String_Node_Str"",Optional.fromNullable(cookedItem));
  values.put(""String_Node_Str"",Optional.fromNullable(cause));
  values.put(""String_Node_Str"",inventory);
  values.put(""String_Node_Str"",loc);
  return createEvent(FurnaceSmeltItemEvent.class,values);
}"
27837,"/** 
 * Convenience method to avoid null-checking. Returns 0 if <em>value</em> is null.
 */
protected int hashCodeOf(Object value){
  return value != null ? value.hashCode() : 0;
}","/** 
 * Convenience method to avoid null-checking. Returns 0 if <em>value</em> is null.
 * @param value The value to get the hashcode of
 * @return The hashcode value
 */
protected int hashCodeOf(Object value){
  return value != null ? value.hashCode() : 0;
}"
27838,"/** 
 * Get whether the specified entity can interact with this object.
 * @param entity the Entity wishing to interact with this Inventory
 * @return true if the Entity is able to interact with this Inventory
 */
public boolean canInteractWith(T entity);","/** 
 * Get whether the specified entity can interact with this object.
 * @param entity the Entity wishing to interact with this Inventory
 * @return true if the Entity is able to interact with this Inventory
 */
boolean canInteractWith(T entity);"
27839,"/** 
 * Get the default maximum quantity for   {@link ItemStack}s of this item.
 * @return Max stack quantity
 */
int getMaxStackQuantity();","/** 
 * Get the default maximum quantity for  {@link org.spongepowered.api.item.inventory.ItemStack}s of this item.
 * @return Max stack quantity
 */
int getMaxStackQuantity();"
27840,"/** 
 * Sends the message(s) with the specified   {@link ChatType} on the client.
 * @param type     The chat type to send the messages to
 * @param messages The message(s) to send
 */
void sendMessage(ChatType type,Iterable<Message> messages);","/** 
 * Sends the message(s) with the specified   {@link ChatType} on the client.
 * @param type The chat type to send the messages to
 * @param messages The message(s) to send
 */
void sendMessage(ChatType type,Iterable<Message> messages);"
27841,"/** 
 * Launches a   {@link Projectile} from this projectile source.
 * @param projectileClass The class of the projectile
 * @param velocity        The velocity to launch the projectile
 * @param < T >             The Type of Projectile
 * @return The projectile instance that was launched
 */
<T extends Projectile>T launchProjectile(Class<T> projectileClass,Vector3f velocity);","/** 
 * Launches a   {@link Projectile} from this projectile source.
 * @param projectileClass The class of the projectile
 * @param velocity The velocity to launch the projectile
 * @param < T > The Type of Projectile
 * @return The projectile instance that was launched
 */
<T extends Projectile>T launchProjectile(Class<T> projectileClass,Vector3f velocity);"
27842,"/** 
 * Retrieves the result for this event.
 * @return The result
 */
ItemStack getResult();","/** 
 * Retrieves the result for this event.
 * @return The result
 */
Optional<ItemStack> getResult();"
27843,"/** 
 * Gets a   {@link Particle} by id.
 * @param id The particle id
 * @return The corresponding particle, if available
 */
Optional<Particle> getParticle(String id);","/** 
 * Gets a   {@link Particle} by id.
 * @param id The particle id
 * @return The corresponding particle or Optional.absent() if not found
 */
Optional<Particle> getParticle(String id);"
27844,"/** 
 * Gets a   {@link BiomeType} by its identifier.
 * @param id The id to look up
 * @return The biome or null if not found
 */
Optional<BiomeType> getBiome(String id);","/** 
 * Gets a   {@link BiomeType} by its identifier.
 * @param id The id to look up
 * @return The biome or Optional.absent() if not found
 */
Optional<BiomeType> getBiome(String id);"
27845,"/** 
 * Gets the villager   {@link Career} with the specified id.
 * @param id The id of the career to return
 * @return The career with the given id, if available
 */
Optional<Career> getCareer(String id);","/** 
 * Gets the villager   {@link Career} with the specified id.
 * @param id The id of the career to return
 * @return The career with the given id or Optional.absent() if not found
 */
Optional<Career> getCareer(String id);"
27846,"/** 
 * Gets the villager   {@link Profession} with the specified id.
 * @param id The id of the profession to return
 * @return The profession with the given id, if available
 */
Optional<Profession> getProfession(String id);","/** 
 * Gets the villager   {@link Profession} with the specified id.
 * @param id The id of the profession to return
 * @return The profession with the given id or Optional.absent() if not found
 */
Optional<Profession> getProfession(String id);"
27847,"/** 
 * Gets a   {@link Player} by their nameThis only works for online players. <b>Note: Do not use names for persistent storage, the Zidane of today may not be the Zidane of yesterday.</b>
 * @param name The name to get the player from
 * @return {@link Player} if available
 */
Optional<Player> getPlayer(String name);","/** 
 * Gets a   {@link Player} by their nameThis only works for online players. <b>Note: Do not use names for persistent storage, the Zidane of today may not be the Zidane of yesterday.</b>
 * @param name The name to get the player from
 * @return {@link Player} or Optional.absent() if not found
 */
Optional<Player> getPlayer(String name);"
27848,"/** 
 * Gets a loaded   {@link World} by name, if any
 * @param worldName Name to lookup
 * @return The world or null if not found
 */
Optional<World> getWorld(String worldName);","/** 
 * Gets a loaded   {@link World} by name, if any.
 * @param worldName Name to lookup
 * @return The world or Optional.absent() if not found
 */
Optional<World> getWorld(String worldName);"
27849,"/** 
 * Gets the bound   {@link InetSocketAddress} this server is accepting connections from.
 * @return The address
 */
Optional<InetSocketAddress> getBoundAddress();","/** 
 * Gets the bound   {@link InetSocketAddress} this server is accepting connections from.
 * @return The address or Optional.absent() if not found
 */
Optional<InetSocketAddress> getBoundAddress();"
27850,"/** 
 * Get the value representation for the given name.
 * @param name A name that represents a valid value for this property
 * @return A valid value for this property
 */
Optional<T> getValueForName(String name);","/** 
 * Get the value representation for the given name.
 * @param name A name that represents a valid value for this property
 * @return A valid value for this property or Optional.absent() if not found
 */
Optional<T> getValueForName(String name);"
27851,"/** 
 * Get the current value of a given property.
 * @param name Property to get value of
 * @return Current value of the property
 */
Optional<? extends Comparable<?>> getPropertyValue(String name);","/** 
 * Get the current value of a given property.
 * @param name Property to get value of
 * @return Current value of the property or Optional.absent() if not found
 */
Optional<? extends Comparable<?>> getPropertyValue(String name);"
27852,"/** 
 * Get a property from its name.
 * @param name The name of the property
 * @return The property with the given name
 */
Optional<BlockProperty<?>> getPropertyByName(String name);","/** 
 * Get a property from its name.
 * @param name The name of the property
 * @return The property with the given name or Optional.absent() if not found
 */
Optional<BlockProperty<?>> getPropertyByName(String name);"
27853,"/** 
 * Gets the   {@link BlockLoc} that the player has clicked, if available.
 * @return The block
 */
Optional<BlockLoc> getBlock();","/** 
 * Gets the   {@link BlockLoc} that the player has clicked.
 * @return The block
 */
BlockLoc getBlock();"
27854,"/** 
 * Returns a list of all currently scheduled tasks owned by a certain plugin.
 * @param plugin The plugin to return tasks created by
 * @return A list of scheduled tasks
 */
Collection<Task> getScheduledTasks(Object plugin);","/** 
 * Returns a collection of all currently scheduled tasks owned by a certain plugin.
 * @param plugin The plugin to return tasks created by
 * @return A collection of scheduled tasks
 */
Collection<Task> getScheduledTasks(Object plugin);"
27855,"/** 
 * Constructs a new exception with the specified cause and a detail message of.
 * @param cause The cause
 */
public CommandException(@Nullable Throwable cause){
  super(cause);
}","/** 
 * Constructs a new exception with the specified cause.
 * @param cause The cause
 */
public CommandException(@Nullable Throwable cause){
  super(cause);
}"
27856,"/** 
 * Get the block that will replace the block.
 */
BlockSnapshot getReplacementBlock();","/** 
 * Get the block that will replace the block.
 * @return The block that will replace
 */
BlockSnapshot getReplacementBlock();"
27857,"/** 
 * Sends the formatted text message(s) to source when possible. If text formatting is not supported in the implementation it will be displayed as plain text.
 * @param messages The message(s)
 */
void sendMessage(Iterable<Message<?>>... messages);","/** 
 * Sends the formatted text message(s) to source when possible. If text formatting is not supported in the implementation it will be displayed as plain text.
 * @param messages The messages
 */
void sendMessage(Iterable<Message<?>>... messages);"
27858,"/** 
 * Gets the   {@link Player}s currently online
 * @return a {@link Collection} of online players
 */
Collection<Player> getOnlinePlayers();","/** 
 * Gets the   {@link Player}s currently online
 * @return A {@link Collection} of online players
 */
Collection<Player> getOnlinePlayers();"
27859,"/** 
 * Creates a new clean   {@link Title} configuration that will reset thecurrently displayed title before displaying the new one.
 * @return A new clean {@link Title} configuration.
 */
Title createTitle();","/** 
 * Creates a new clean   {@link Title} configuration that will reset thecurrently displayed title before displaying the new one.
 * @return A new clean {@link Title} configuration
 */
Title createTitle();"
27860,"/** 
 * Creates a new empty   {@link Title} configuration that will just updatethe currently displayed title on the client.
 * @return A new empty {@link Title} configuration.
 */
Title updateTitle();","/** 
 * Creates a new empty   {@link Title} configuration that will just updatethe currently displayed title on the client.
 * @return A new empty {@link Title} configuration
 */
Title updateTitle();"
27861,"/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @param itemStack The item to pretend-dig with
 * @return The time in ticks.
 */
int getDigTimeWith(ItemStack itemStack);","/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @param itemStack The item to pretend-dig with
 * @return The time in ticks
 */
int getDigTimeWith(ItemStack itemStack);"
27862,"/** 
 * Gets the time it takes to dig this block with a fist in ticks.
 * @return The time in ticks.
 */
int getDigTime();","/** 
 * Gets the time it takes to dig this block with a fist in ticks.
 * @return The time in ticks
 */
int getDigTime();"
27863,"/** 
 * Gets the rate at which unoccupied boats decelerate.
 * @return The unoccupied deceleration rate.
 */
double getUnoccupiedDeceleration();","/** 
 * Gets the rate at which unoccupied boats decelerate.
 * @return The unoccupied deceleration rate
 */
double getUnoccupiedDeceleration();"
27864,"/** 
 * Gets the rate at which occupied boats decelerate.
 * @return The occupied deceleration rate.
 */
double getOccupiedDeceleration();","/** 
 * Gets the rate at which occupied boats decelerate.
 * @return The occupied deceleration rate
 */
double getOccupiedDeceleration();"
27865,"/** 
 * Gets whether or not the boat is able to move freely on land.
 * @return If the boat can move on land.
 */
boolean getMoveOnLand();","/** 
 * Gets whether or not the boat is able to move freely on land.
 * @return If the boat can move on land
 */
boolean getMoveOnLand();"
27866,"/** 
 * Gets whether this boat is currently in water.
 * @return If the boat is in water.
 */
boolean isInWater();","/** 
 * Gets whether this boat is currently in water.
 * @return If the boat is in water
 */
boolean isInWater();"
27867,"/** 
 * Sets the rate at which unoccupied boats decelerate.
 * @param unoccupiedDeceleration The new unoccupied deceleration rate.
 */
void setUnoccupiedDeceleration(double unoccupiedDeceleration);","/** 
 * Sets the rate at which unoccupied boats decelerate.
 * @param unoccupiedDeceleration The new unoccupied deceleration rate
 */
void setUnoccupiedDeceleration(double unoccupiedDeceleration);"
27868,"/** 
 * Gets whether or not the boat is able to move freely on land.
 * @param moveOnLand If the boat can move on land.
 */
void setMoveOnLand(boolean moveOnLand);","/** 
 * Gets whether or not the boat is able to move freely on land.
 * @param moveOnLand If the boat can move on land
 */
void setMoveOnLand(boolean moveOnLand);"
27869,"/** 
 * Sets the rate at which occupied boats decelerate.
 * @param occupiedDeceleration The new occupied deceleration rate.
 */
void setOccupiedDeceleration(double occupiedDeceleration);","/** 
 * Sets the rate at which occupied boats decelerate.
 * @param occupiedDeceleration The new occupied deceleration rate
 */
void setOccupiedDeceleration(double occupiedDeceleration);"
27870,"/** 
 * Gets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @return The maximum speed.
 */
double getMaxSpeed();","/** 
 * Gets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @return The maximum speed
 */
double getMaxSpeed();"
27871,"/** 
 * Sets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed.
 */
void setMaxSpeed(double maxSpeed);","/** 
 * Sets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed
 */
void setMaxSpeed(double maxSpeed);"
27872,"/** 
 * Gets the rotation as a EulerDirection.
 * @return rotation The rotation as a EulerDirection
 */
EulerDirection getRotation();","/** 
 * Gets the rotation as a EulerDirection.
 * @return The rotation as a EulerDirection
 */
EulerDirection getRotation();"
27873,"/** 
 * Gets the rotation as a vector. This does not support the roll component of the entity's rotation.
 * @return rotation A possibly, but not necessarily, unit vector
 */
Vector3f getVectorRotation();","/** 
 * Gets the rotation as a vector. This does not support the roll component of the entity's rotation.
 * @return A possibly, but not necessarily, unit vector
 */
Vector3f getVectorRotation();"
27874,"/** 
 * Mount the entity provided.
 * @param entity The entity to mount.
 */
void mount(Entity entity);","/** 
 * Mount the entity provided.
 * @param entity The entity to mount
 */
void mount(Entity entity);"
27875,"/** 
 * Gets the entity that is riding this entity.
 * @return The riding entity, if it exists.
 */
Optional<Entity> getRider();","/** 
 * Gets the entity that is riding this entity.
 * @return The riding entity, if it exists
 */
Optional<Entity> getRider();"
27876,"/** 
 * Gets the position.
 * @return position The position
 */
Vector3d getPosition();","/** 
 * Gets the position.
 * @return The position
 */
Vector3d getPosition();"
27877,"/** 
 * Simulates the interaction with this object using the given item as if the player had done so.
 * @param itemStack The item
 * @param interactionType The type of interaction performed on this entity
 */
void interactWith(ItemStack itemStack,EntityInteractionType interactionType);","/** 
 * Simulates the interaction with this object using the given item as if the player had done so.
 * @param itemStack       The item
 * @param interactionType The type of interaction performed on this entity
 */
void interactWith(ItemStack itemStack,EntityInteractionType interactionType);"
27878,"/** 
 * Gets the entity that this entity is riding.
 * @return The entity being ridden, if it exists.
 */
Optional<Entity> getRiding();","/** 
 * Gets the entity that this entity is riding.
 * @return The entity being ridden, if it exists
 */
Optional<Entity> getRiding();"
27879,"/** 
 * Gets whether or not the minecart is currently on a valid rail block.
 * @return If the cart is on a rail.
 */
boolean isOnRail();","/** 
 * Gets whether or not the minecart is currently on a valid rail block.
 * @return If the cart is on a rail
 */
boolean isOnRail();"
27880,"/** 
 * Sets the velocity modifier applied when the minecart is not on rails.
 * @param derailedVelocityMod The new derailed velocity modifier.
 */
void setDerailedVelocityMod(Vector3d derailedVelocityMod);","/** 
 * Sets the velocity modifier applied when the minecart is not on rails.
 * @param derailedVelocityMod The new derailed velocity modifier
 */
void setDerailedVelocityMod(Vector3d derailedVelocityMod);"
27881,"/** 
 * Gets the velocity modifier applied when the minecart is airborne.
 * @return Airborne velocity modifier.
 */
Vector3d getAirborneVelocityMod();","/** 
 * Gets the velocity modifier applied when the minecart is airborne.
 * @return Airborne velocity modifier
 */
Vector3d getAirborneVelocityMod();"
27882,"/** 
 * Gets whether or not the minecart slows down faster without a passenger.
 * @return If the cart slows when empty.
 */
boolean doesSlowWhenEmpty();","/** 
 * Gets whether or not the minecart slows down faster without a passenger.
 * @return If the cart slows when empty
 */
boolean doesSlowWhenEmpty();"
27883,"/** 
 * Sets whether or not the minecart slows down faster without a passenger.
 * @param slowWhenEmpty If the cart should slow when emoty.
 */
void setSlowWhenEmpty(boolean slowWhenEmpty);","/** 
 * Sets whether or not the minecart slows down faster without a passenger.
 * @param slowWhenEmpty If the cart should slow when emoty
 */
void setSlowWhenEmpty(boolean slowWhenEmpty);"
27884,"/** 
 * Gets the velocity modifier applied when the minecart is not on rails.
 * @return Derailed velocity modifier.
 */
Vector3d getDerailedVelocityMod();","/** 
 * Gets the velocity modifier applied when the minecart is not on rails.
 * @return Derailed velocity modifier
 */
Vector3d getDerailedVelocityMod();"
27885,"/** 
 * Gets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @return The maximum speed.
 */
double getMaxSpeed();","/** 
 * Gets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @return The maximum speed
 */
double getMaxSpeed();"
27886,"/** 
 * Sets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed.
 */
void setMaxSpeed(double maxSpeed);","/** 
 * Sets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed
 */
void setMaxSpeed(double maxSpeed);"
27887,"/** 
 * Sets the velocity modifier applied when the minecart is airborne.
 * @param airborneVelocityMod The new airborne velocity modifier.
 */
void setAirborneVelocityMod(Vector3d airborneVelocityMod);","/** 
 * Sets the velocity modifier applied when the minecart is airborne.
 * @param airborneVelocityMod The new airborne velocity modifier
 */
void setAirborneVelocityMod(Vector3d airborneVelocityMod);"
27888,"/** 
 * Sends a   {@link Title} to this player. This is the same as calling{@link Title#send(Player)}.
 * @param title The {@link Title} to send to the player.
 */
void sendTitle(Title title);","/** 
 * Sends a   {@link Title} to this player. This is the same as calling{@link Title#send(Player)}.
 * @param title The {@link Title} to send to the player
 */
void sendTitle(Title title);"
27889,"/** 
 * Sets the cancelled state of the   {@link Event}.
 * @param cancel the new cancelled state
 */
void setCancelled(boolean cancel);","/** 
 * Sets the cancelled state of the   {@link Event}.
 * @param cancel The new cancelled state
 */
void setCancelled(boolean cancel);"
27890,"/** 
 * Gets the entity that is being dismounted from.
 * @return The entity that is being dismounted from.
 */
Entity getDismounted();","/** 
 * Gets the entity that is being dismounted from.
 * @return The entity that is being dismounted from
 */
Entity getDismounted();"
27891,"/** 
 * Gets the entity that is being mounted.
 * @return The entity that is being mounted.
 */
Entity getMounted();","/** 
 * Gets the entity that is being mounted.
 * @return The entity that is being mounted
 */
Entity getMounted();"
27892,"/** 
 * @return the config folder
 */
public File getConfigurationDirectory();","/** 
 * @return The config folder
 */
public File getConfigurationDirectory();"
27893,"/** 
 * Returns the yaw component.
 * @return the yaw component
 */
float getYaw();","/** 
 * Returns the yaw component.
 * @return The yaw component
 */
float getYaw();"
27894,"/** 
 * Returns the pitch component.
 * @return the pitch component
 */
float getPitch();","/** 
 * Returns the pitch component.
 * @return The pitch component
 */
float getPitch();"
27895,"/** 
 * Converts this Euler Direction into a   {@link Vector3f}. The vector will represent the directions that this direction is facing in x, y, z coordinates, with a length of 1. Roll will be ignored, as it does not contribute to the facing direction.
 * @return the vector representation of this direction
 */
Vector3f toVector();","/** 
 * Converts this Euler Direction into a   {@link Vector3f}. The vector will represent the directions that this direction is facing in x, y, z coordinates, with a length of 1. Roll will be ignored, as it does not contribute to the facing direction.
 * @return The vector representation of this direction
 */
Vector3f toVector();"
27896,"/** 
 * Returns the roll component.
 * @return the roll component
 */
float getRoll();","/** 
 * Returns the roll component.
 * @return The roll component
 */
float getRoll();"
27897,"/** 
 * Returns this vector as an array.
 * @return This vector as an array.
 */
double[] toArray();","/** 
 * Returns this vector as an array.
 * @return This vector as an array
 */
double[] toArray();"
27898,"/** 
 * Returns this vector as an array.
 * @return This vector as an array.
 */
float[] toArray();","/** 
 * Returns this vector as an array.
 * @return This vector as an array
 */
float[] toArray();"
27899,"/** 
 * Returns this vector as an array.
 * @return This vector as an array.
 */
int[] toArray();","/** 
 * Returns this vector as an array.
 * @return This vector as an array
 */
int[] toArray();"
27900,"/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @return The time in ticks.
 */
int getDigTimeWith(ItemStack itemStack);","/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @param itemStack The item to pretend-dig with
 * @return The time in ticks.
 */
int getDigTimeWith(ItemStack itemStack);"
27901,"/** 
 * Return the default state for this block.
 */
BlockState getDefaultState();","/** 
 * Return the default state for this block.
 * @return The default state
 */
BlockState getDefaultState();"
27902,"/** 
 * Sets the helmet currently being worn by this entity.
 * @param helmet The helmet to put on the entity
 */
void setHelmet(ItemStack helmet);","/** 
 * Sets the helmet currently being worn by this entity.
 * @param helmet The helmet to put on the entity
 */
void setHelmet(@Nullable ItemStack helmet);"
27903,"/** 
 * Sets the leggings currently being worn by this entity.
 * @param leggings The leggings to put on the entity
 */
void setLeggings(ItemStack leggings);","/** 
 * Sets the leggings currently being worn by this entity.
 * @param leggings The leggings to put on the entity
 */
void setLeggings(@Nullable ItemStack leggings);"
27904,"/** 
 * Sets the boots currently being worn by this entity.
 * @param boots The boots to put on the entity
 */
void setBoots(ItemStack boots);","/** 
 * Sets the boots currently being worn by this entity.
 * @param boots The boots to put on the entity
 */
void setBoots(@Nullable ItemStack boots);"
27905,"/** 
 * Sets the chestplate currently being worn by this entity.
 * @param chestplate The chestplate to put on the entity
 */
void setChestplate(ItemStack chestplate);","/** 
 * Sets the chestplate currently being worn by this entity.
 * @param chestplate The chestplate to put on the entity
 */
void setChestplate(@Nullable ItemStack chestplate);"
27906,"/** 
 * Sets whether this entity can breed a new child.
 * @param breeding
 */
void setBreeding(boolean breeding);","/** 
 * Sets whether this entity can breed a new child.
 * @param breeding whether this entity can breed
 */
void setBreeding(boolean breeding);"
27907,"/** 
 * Sets whether or not this blaze is currently on fire.
 * @param onFire Whether the blaze should be on fire or not.
 */
void setOnFire(boolean onFire);","/** 
 * Sets whether or not this blaze is currently on fire.
 * @param onFire Whether the blaze should be on fire or not
 */
void setOnFire(boolean onFire);"
27908,"/** 
 * Gets whether or not this blaze is currently on fire.
 * @return Whether or not the blaze is on fire.
 */
boolean isOnFire();","/** 
 * Gets whether or not this blaze is currently on fire.
 * @return Whether or not the blaze is on fire
 */
boolean isOnFire();"
27909,"/** 
 * Gets whether or not the creeper has been struck by lightning.
 * @return If the creeper is powered.
 */
boolean isPowered();","/** 
 * Gets whether or not the creeper has been struck by lightning.
 * @return If the creeper is powered
 */
boolean isPowered();"
27910,"/** 
 * Sets whether or not the creeper has been struck by lightning.
 * @param powered If the creeper should be powered.
 */
void setPowered(boolean powered);","/** 
 * Sets whether or not the creeper has been struck by lightning.
 * @param powered If the creeper should be powered
 */
void setPowered(boolean powered);"
27911,"/** 
 * Gets if the enderman is currently screaming. <p>This behaviour generally occurs when a player has been targeted due to staring too long.</p>
 * @return If the enderman is screaming.
 */
boolean isScreaming();","/** 
 * Gets if the enderman is currently screaming. <p>This behaviour generally occurs when a player has been targeted due to staring too long.</p>
 * @return If the enderman is screaming
 */
boolean isScreaming();"
27912,"/** 
 * Sets the   {@link ItemBlock} currently carried by the enderman.
 * @param carriedBlock The carried {@link ItemBlock}.
 */
void setCarriedBlock(ItemBlock carriedBlock);","/** 
 * Sets the   {@link ItemBlock} currently carried by the enderman.
 * @param carriedBlock The carried {@link ItemBlock}
 */
void setCarriedBlock(ItemBlock carriedBlock);"
27913,"/** 
 * Gets the   {@link ItemBlock} currently carried by the enderman.
 * @return The {@link ItemBlock}, if available.
 */
Optional<ItemBlock> getCarriedBlock();","/** 
 * Gets the   {@link ItemBlock} currently carried by the enderman.
 * @return The {@link ItemBlock}, if available
 */
Optional<ItemBlock> getCarriedBlock();"
27914,"/** 
 * Sets if the enderman is currently screaming. <p>This behaviour generally occurs when a player has been targeted due to staring too long.</p>
 * @param screaming If the enderman should be screaming.
 */
void setScreaming(boolean screaming);","/** 
 * Sets if the enderman is currently screaming. <p>This behaviour generally occurs when a player has been targeted due to staring too long.</p>
 * @param screaming If the enderman should be screaming
 */
void setScreaming(boolean screaming);"
27915,"/** 
 * Gets whether or not the spider is currently climbing a wall.
 * @return Whether or not the spider is climbing a wall.
 */
boolean isClimbing();","/** 
 * Gets whether or not the spider is currently climbing a wall.
 * @return Whether or not the spider is climbing a wall
 */
boolean isClimbing();"
27916,"/** 
 * Sets if this Witch should be aggressive.
 * @param aggressive If the Witch should be aggressive.
 */
void setAggressive(boolean aggressive);","/** 
 * Sets if this Witch should be aggressive.
 * @param aggressive If the Witch should be aggressive
 */
void setAggressive(boolean aggressive);"
27917,"/** 
 * Gets if this Witch is currently aggressive.
 * @return If the Witch is aggressive.
 */
boolean isAggressive();","/** 
 * Gets if this Witch is currently aggressive.
 * @return If the Witch is aggressive
 */
boolean isAggressive();"
27918,"/** 
 * Gets the entities currently being targetted by this wither. <p>This list should contain a maximum of 3 entities.</p>
 * @return The Wither's targets.
 */
List<LivingEntity> getTargets();","/** 
 * Gets the entities currently being targetted by this wither. <p>This list should contain a maximum of 3 entities.</p>
 * @return The Wither's targets
 */
List<LivingEntity> getTargets();"
27919,"/** 
 * Gets the amount of ticks that the Wither should stay invulnerable for.
 * @return The invulnerable time in ticks.
 */
long getInvulnerableTicks();","/** 
 * Gets the amount of ticks that the Wither should stay invulnerable for.
 * @return The invulnerable time in ticks
 */
long getInvulnerableTicks();"
27920,"/** 
 * Sets the amount of ticks that the Wither should stay invulnerable for.
 * @param invulnerableTicks The invulnerable time in ticks.
 */
void setInvulnerableTicks(long invulnerableTicks);","/** 
 * Sets the amount of ticks that the Wither should stay invulnerable for.
 * @param invulnerableTicks The invulnerable time in ticks
 */
void setInvulnerableTicks(long invulnerableTicks);"
27921,"/** 
 * Gets if this Zombie is a villager Zombie.
 * @return If the Zombie is a villager Zombie.
 */
boolean isVillagerZombie();","/** 
 * Gets if this Zombie is a villager Zombie.
 * @return If the Zombie is a villager Zombie
 */
boolean isVillagerZombie();"
27922,"/** 
 * Sets if this Zombie should be a villager Zombie.
 * @param villagerZombie If the Zombie should be a villager Zombie.
 */
void setVillagerZombie(boolean villagerZombie);","/** 
 * Sets if this Zombie should be a villager Zombie.
 * @param villagerZombie If the Zombie should be a villager Zombie
 */
void setVillagerZombie(boolean villagerZombie);"
27923,"/** 
 * Gets the   {@link Player}s currently online
 * @return a {@link Collection} of online players
 */
Collection<Player> getOnlinePlayers();","/** 
 * Gets the   {@link Player}s currently online
 * @return A {@link Collection} of online players
 */
Collection<Player> getOnlinePlayers();"
27924,"/** 
 * Creates a new clean   {@link Title} configuration that will reset thecurrently displayed title before displaying the new one.
 * @return A new clean {@link Title} configuration.
 */
Title createTitle();","/** 
 * Creates a new clean   {@link Title} configuration that will reset thecurrently displayed title before displaying the new one.
 * @return A new clean {@link Title} configuration
 */
Title createTitle();"
27925,"/** 
 * Creates a new empty   {@link Title} configuration that will just updatethe currently displayed title on the client.
 * @return A new empty {@link Title} configuration.
 */
Title updateTitle();","/** 
 * Creates a new empty   {@link Title} configuration that will just updatethe currently displayed title on the client.
 * @return A new empty {@link Title} configuration
 */
Title updateTitle();"
27926,"/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @param itemStack The item to pretend-dig with
 * @return The time in ticks.
 */
int getDigTimeWith(ItemStack itemStack);","/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @param itemStack The item to pretend-dig with
 * @return The time in ticks
 */
int getDigTimeWith(ItemStack itemStack);"
27927,"/** 
 * Gets the time it takes to dig this block with a fist in ticks.
 * @return The time in ticks.
 */
int getDigTime();","/** 
 * Gets the time it takes to dig this block with a fist in ticks.
 * @return The time in ticks
 */
int getDigTime();"
27928,"/** 
 * Gets the rate at which unoccupied boats decelerate.
 * @return The unoccupied deceleration rate.
 */
double getUnoccupiedDeceleration();","/** 
 * Gets the rate at which unoccupied boats decelerate.
 * @return The unoccupied deceleration rate
 */
double getUnoccupiedDeceleration();"
27929,"/** 
 * Gets the rate at which occupied boats decelerate.
 * @return The occupied deceleration rate.
 */
double getOccupiedDeceleration();","/** 
 * Gets the rate at which occupied boats decelerate.
 * @return The occupied deceleration rate
 */
double getOccupiedDeceleration();"
27930,"/** 
 * Gets whether or not the boat is able to move freely on land.
 * @return If the boat can move on land.
 */
boolean getMoveOnLand();","/** 
 * Gets whether or not the boat is able to move freely on land.
 * @return If the boat can move on land
 */
boolean getMoveOnLand();"
27931,"/** 
 * Gets whether this boat is currently in water.
 * @return If the boat is in water.
 */
boolean isInWater();","/** 
 * Gets whether this boat is currently in water.
 * @return If the boat is in water
 */
boolean isInWater();"
27932,"/** 
 * Sets the rate at which unoccupied boats decelerate.
 * @param unoccupiedDeceleration The new unoccupied deceleration rate.
 */
void setUnoccupiedDeceleration(double unoccupiedDeceleration);","/** 
 * Sets the rate at which unoccupied boats decelerate.
 * @param unoccupiedDeceleration The new unoccupied deceleration rate
 */
void setUnoccupiedDeceleration(double unoccupiedDeceleration);"
27933,"/** 
 * Gets whether or not the boat is able to move freely on land.
 * @param moveOnLand If the boat can move on land.
 */
void setMoveOnLand(boolean moveOnLand);","/** 
 * Gets whether or not the boat is able to move freely on land.
 * @param moveOnLand If the boat can move on land
 */
void setMoveOnLand(boolean moveOnLand);"
27934,"/** 
 * Sets the rate at which occupied boats decelerate.
 * @param occupiedDeceleration The new occupied deceleration rate.
 */
void setOccupiedDeceleration(double occupiedDeceleration);","/** 
 * Sets the rate at which occupied boats decelerate.
 * @param occupiedDeceleration The new occupied deceleration rate
 */
void setOccupiedDeceleration(double occupiedDeceleration);"
27935,"/** 
 * Gets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @return The maximum speed.
 */
double getMaxSpeed();","/** 
 * Gets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @return The maximum speed
 */
double getMaxSpeed();"
27936,"/** 
 * Sets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed.
 */
void setMaxSpeed(double maxSpeed);","/** 
 * Sets the maximum speed that this boat is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed
 */
void setMaxSpeed(double maxSpeed);"
27937,"/** 
 * Gets the rotation as a EulerDirection.
 * @return rotation The rotation as a EulerDirection
 */
EulerDirection getRotation();","/** 
 * Gets the rotation as a EulerDirection.
 * @return The rotation as a EulerDirection
 */
EulerDirection getRotation();"
27938,"/** 
 * Gets the rotation as a vector. This does not support the roll component of the entity's rotation.
 * @return rotation A possibly, but not necessarily, unit vector
 */
Vector3f getVectorRotation();","/** 
 * Gets the rotation as a vector. This does not support the roll component of the entity's rotation.
 * @return A possibly, but not necessarily, unit vector
 */
Vector3f getVectorRotation();"
27939,"/** 
 * Mount the entity provided.
 * @param entity The entity to mount.
 */
void mount(Entity entity);","/** 
 * Mount the entity provided.
 * @param entity The entity to mount
 */
void mount(Entity entity);"
27940,"/** 
 * Gets the entity that is riding this entity.
 * @return The riding entity, if it exists.
 */
Optional<Entity> getRider();","/** 
 * Gets the entity that is riding this entity.
 * @return The riding entity, if it exists
 */
Optional<Entity> getRider();"
27941,"/** 
 * Gets the position.
 * @return position The position
 */
Vector3d getPosition();","/** 
 * Gets the position.
 * @return The position
 */
Vector3d getPosition();"
27942,"/** 
 * Simulates the interaction with this object using the given item as if the player had done so.
 * @param itemStack The item
 * @param interactionType The type of interaction performed on this entity
 */
void interactWith(ItemStack itemStack,EntityInteractionType interactionType);","/** 
 * Simulates the interaction with this object using the given item as if the player had done so.
 * @param itemStack       The item
 * @param interactionType The type of interaction performed on this entity
 */
void interactWith(ItemStack itemStack,EntityInteractionType interactionType);"
27943,"/** 
 * Gets the entity that this entity is riding.
 * @return The entity being ridden, if it exists.
 */
Optional<Entity> getRiding();","/** 
 * Gets the entity that this entity is riding.
 * @return The entity being ridden, if it exists
 */
Optional<Entity> getRiding();"
27944,"/** 
 * Gets whether or not the minecart is currently on a valid rail block.
 * @return If the cart is on a rail.
 */
boolean isOnRail();","/** 
 * Gets whether or not the minecart is currently on a valid rail block.
 * @return If the cart is on a rail
 */
boolean isOnRail();"
27945,"/** 
 * Sets the velocity modifier applied when the minecart is not on rails.
 * @param derailedVelocityMod The new derailed velocity modifier.
 */
void setDerailedVelocityMod(Vector3d derailedVelocityMod);","/** 
 * Sets the velocity modifier applied when the minecart is not on rails.
 * @param derailedVelocityMod The new derailed velocity modifier
 */
void setDerailedVelocityMod(Vector3d derailedVelocityMod);"
27946,"/** 
 * Gets the velocity modifier applied when the minecart is airborne.
 * @return Airborne velocity modifier.
 */
Vector3d getAirborneVelocityMod();","/** 
 * Gets the velocity modifier applied when the minecart is airborne.
 * @return Airborne velocity modifier
 */
Vector3d getAirborneVelocityMod();"
27947,"/** 
 * Gets whether or not the minecart slows down faster without a passenger.
 * @return If the cart slows when empty.
 */
boolean doesSlowWhenEmpty();","/** 
 * Gets whether or not the minecart slows down faster without a passenger.
 * @return If the cart slows when empty
 */
boolean doesSlowWhenEmpty();"
27948,"/** 
 * Sets whether or not the minecart slows down faster without a passenger.
 * @param slowWhenEmpty If the cart should slow when emoty.
 */
void setSlowWhenEmpty(boolean slowWhenEmpty);","/** 
 * Sets whether or not the minecart slows down faster without a passenger.
 * @param slowWhenEmpty If the cart should slow when emoty
 */
void setSlowWhenEmpty(boolean slowWhenEmpty);"
27949,"/** 
 * Gets the velocity modifier applied when the minecart is not on rails.
 * @return Derailed velocity modifier.
 */
Vector3d getDerailedVelocityMod();","/** 
 * Gets the velocity modifier applied when the minecart is not on rails.
 * @return Derailed velocity modifier
 */
Vector3d getDerailedVelocityMod();"
27950,"/** 
 * Gets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @return The maximum speed.
 */
double getMaxSpeed();","/** 
 * Gets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @return The maximum speed
 */
double getMaxSpeed();"
27951,"/** 
 * Sets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed.
 */
void setMaxSpeed(double maxSpeed);","/** 
 * Sets the maximum speed that this cart is allowed to travel at. Default value is 0.4
 * @param maxSpeed The new max speed
 */
void setMaxSpeed(double maxSpeed);"
27952,"/** 
 * Sets the velocity modifier applied when the minecart is airborne.
 * @param airborneVelocityMod The new airborne velocity modifier.
 */
void setAirborneVelocityMod(Vector3d airborneVelocityMod);","/** 
 * Sets the velocity modifier applied when the minecart is airborne.
 * @param airborneVelocityMod The new airborne velocity modifier
 */
void setAirborneVelocityMod(Vector3d airborneVelocityMod);"
27953,"/** 
 * Sends a   {@link Title} to this player. This is the same as calling{@link Title#send(Player)}.
 * @param title The {@link Title} to send to the player.
 */
void sendTitle(Title title);","/** 
 * Sends a   {@link Title} to this player. This is the same as calling{@link Title#send(Player)}.
 * @param title The {@link Title} to send to the player
 */
void sendTitle(Title title);"
27954,"/** 
 * Sets the cancelled state of the   {@link Event}.
 * @param cancel the new cancelled state
 */
void setCancelled(boolean cancel);","/** 
 * Sets the cancelled state of the   {@link Event}.
 * @param cancel The new cancelled state
 */
void setCancelled(boolean cancel);"
27955,"/** 
 * Gets the entity that is being dismounted from.
 * @return The entity that is being dismounted from.
 */
Entity getDismounted();","/** 
 * Gets the entity that is being dismounted from.
 * @return The entity that is being dismounted from
 */
Entity getDismounted();"
27956,"/** 
 * Gets the entity that is being mounted.
 * @return The entity that is being mounted.
 */
Entity getMounted();","/** 
 * Gets the entity that is being mounted.
 * @return The entity that is being mounted
 */
Entity getMounted();"
27957,"/** 
 * @return the config folder
 */
public File getConfigurationDirectory();","/** 
 * @return The config folder
 */
public File getConfigurationDirectory();"
27958,"/** 
 * Returns the yaw component.
 * @return the yaw component
 */
float getYaw();","/** 
 * Returns the yaw component.
 * @return The yaw component
 */
float getYaw();"
27959,"/** 
 * Returns the pitch component.
 * @return the pitch component
 */
float getPitch();","/** 
 * Returns the pitch component.
 * @return The pitch component
 */
float getPitch();"
27960,"/** 
 * Converts this Euler Direction into a   {@link Vector3f}. The vector will represent the directions that this direction is facing in x, y, z coordinates, with a length of 1. Roll will be ignored, as it does not contribute to the facing direction.
 * @return the vector representation of this direction
 */
Vector3f toVector();","/** 
 * Converts this Euler Direction into a   {@link Vector3f}. The vector will represent the directions that this direction is facing in x, y, z coordinates, with a length of 1. Roll will be ignored, as it does not contribute to the facing direction.
 * @return The vector representation of this direction
 */
Vector3f toVector();"
27961,"/** 
 * Returns the roll component.
 * @return the roll component
 */
float getRoll();","/** 
 * Returns the roll component.
 * @return The roll component
 */
float getRoll();"
27962,"/** 
 * Returns this vector as an array.
 * @return This vector as an array.
 */
double[] toArray();","/** 
 * Returns this vector as an array.
 * @return This vector as an array
 */
double[] toArray();"
27963,"/** 
 * Returns this vector as an array.
 * @return This vector as an array.
 */
float[] toArray();","/** 
 * Returns this vector as an array.
 * @return This vector as an array
 */
float[] toArray();"
27964,"/** 
 * Returns this vector as an array.
 * @return This vector as an array.
 */
int[] toArray();","/** 
 * Returns this vector as an array.
 * @return This vector as an array
 */
int[] toArray();"
27965,"/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @return The time in ticks.
 */
int getDigTimeWith(ItemStack itemStack);","/** 
 * Gets the time it takes to dig this block the specified item in ticks.
 * @param itemStack The item to pretend-dig with
 * @return The time in ticks.
 */
int getDigTimeWith(ItemStack itemStack);"
27966,"/** 
 * Return the default state for this block.
 */
BlockState getDefaultState();","/** 
 * Return the default state for this block.
 * @return The default state
 */
BlockState getDefaultState();"
27967,"/** 
 * Gets the helmet currently being worn by this entity.
 * @return The helmet, if available.
 */
Optional<ItemStack> getHelmet();","/** 
 * Gets the helmet currently being worn by this entity.
 * @return The helmet, if available
 */
Optional<ItemStack> getHelmet();"
27968,"/** 
 * Sets the helmet currently being worn by this entity.
 * @param helmet The helmet to put on the entity.
 */
void setHelmet(ItemStack helmet);","/** 
 * Sets the helmet currently being worn by this entity.
 * @param helmet The helmet to put on the entity
 */
void setHelmet(ItemStack helmet);"
27969,"/** 
 * Sets the leggings currently being worn by this entity.
 * @param leggings The leggings to put on the entity.
 */
void setLeggings(ItemStack leggings);","/** 
 * Sets the leggings currently being worn by this entity.
 * @param leggings The leggings to put on the entity
 */
void setLeggings(ItemStack leggings);"
27970,"/** 
 * Sets the boots currently being worn by this entity.
 * @param boots The boots to put on the entity.
 */
void setBoots(ItemStack boots);","/** 
 * Sets the boots currently being worn by this entity.
 * @param boots The boots to put on the entity
 */
void setBoots(ItemStack boots);"
27971,"/** 
 * Sets the chestplate currently being worn by this entity.
 * @param chestplate The chestplate to put on the entity.
 */
void setChestplate(ItemStack chestplate);","/** 
 * Sets the chestplate currently being worn by this entity.
 * @param chestplate The chestplate to put on the entity
 */
void setChestplate(ItemStack chestplate);"
27972,"/** 
 * Gets the chestplate currently being worn by this entity.
 * @return The chestplate, if available.
 */
Optional<ItemStack> getChestplate();","/** 
 * Gets the chestplate currently being worn by this entity.
 * @return The chestplate, if available
 */
Optional<ItemStack> getChestplate();"
27973,"/** 
 * Gets the boots currently being worn by this entity.
 * @return The boots, if available.
 */
Optional<ItemStack> getBoots();","/** 
 * Gets the boots currently being worn by this entity.
 * @return The boots, if available
 */
Optional<ItemStack> getBoots();"
27974,"/** 
 * Gets the leggings currently being worn by this entity.
 * @return The leggings, if available.
 */
Optional<ItemStack> getLeggings();","/** 
 * Gets the leggings currently being worn by this entity.
 * @return The leggings, if available
 */
Optional<ItemStack> getLeggings();"
27975,"/** 
 * Gets block associated with this cause.
 * @return Block, if available
 */
Optional<Block> getBlock(){
  return Optional.of(block);
}","/** 
 * Gets block associated with this cause.
 * @return Block, if available
 */
public Optional<Block> getBlock(){
  return Optional.of(block);
}"
27976,"/** 
 * Gets world associated with this cause. If world isn't directly specified, world of entity or block will returned.
 * @return World, if available
 */
Optional<World> getWorld(){
  if (world != null) {
    return Optional.of(this.world);
  }
 else {
    if (entity != null) {
      return entity.getWorld();
    }
 else     if (block != null) {
      return Optional.of((World)block.getLocation().getExtent());
    }
  }
  return Optional.of(world);
}","/** 
 * Gets world associated with this cause. If world isn't directly specified, world of entity or block will returned.
 * @return World, if available
 */
public Optional<World> getWorld(){
  if (world != null) {
    return Optional.of(this.world);
  }
 else {
    if (entity != null) {
      return entity.getWorld();
    }
 else     if (block != null) {
      return Optional.of((World)block.getLocation().getExtent());
    }
  }
  return Optional.of(world);
}"
27977,"/** 
 * Gets reason for cause.
 */
Reason getReason(){
  return this.reason;
}","/** 
 * Gets reason for cause.
 */
public Reason getReason(){
  return this.reason;
}"
27978,"/** 
 * Gets entity associated with this cause.
 * @return Entity, if available
 */
Optional<Entity> getEntity(){
  return Optional.of(entity);
}","/** 
 * Gets entity associated with this cause.
 * @return Entity, if available
 */
public Optional<Entity> getEntity(){
  return Optional.of(entity);
}"
27979,"/** 
 * Gets the   {@link Block} that the player has clicked, returns null if theplayer clicks the air.
 * @return The block
 */
Optional<Block> getBlock();","/** 
 * Gets the   {@link Block} that the player has clicked, if available.
 * @return The block
 */
Optional<Block> getBlock();"
27980,"public String getClockTime(){
  return getSharedPrefs().getString(getString(R.string.key_clock_time),TimePreference.DEFAULT_TIME_VALUE);
}","public String getClockTime(){
  String[] time=getSharedPrefs().getString(getString(R.string.key_clock_time),TimePreference.DEFAULT_TIME_VALUE).split(""String_Node_Str"");
  if (!getSharedPrefs().getBoolean(getString(R.string.key_use_24_hour_format),false)) {
    if (Integer.parseInt(time[0]) > 12) {
      time[0]=String.format(""String_Node_Str"",String.valueOf(Integer.parseInt(time[0]) - 12));
    }
  }
  return String.format(""String_Node_Str"",time[0],time[1]);
}"
27981,"protected void updatePrefsSummary(Preference pref){
  if (pref == null) {
    return;
  }
  if (pref instanceof ListPreference) {
    ListPreference lst=(ListPreference)pref;
    String currentValue=lst.getValue();
    int index=lst.findIndexOfValue(currentValue);
    CharSequence[] entries=lst.getEntries();
    CharSequence[] entryValues=lst.getEntryValues();
    if (index >= 0 && index < entries.length) {
      boolean currentValueIsOffOrEmpty=currentValue.equals(entryValues[0]) || currentValue.equals(entryValues[1]);
      if (pref.getKey().equals(getString(R.string.key_signal_3g)) && !currentValueIsOffOrEmpty) {
        pref.setSummary(entries[index] + ""String_Node_Str"" + getString(R.string.network_icon_info));
      }
 else {
        pref.setSummary(entries[index]);
      }
    }
  }
 else   if (pref instanceof TimePreference) {
    if (pref.getKey().equals(getString(R.string.key_clock_time))) {
      String time=getPreferenceManager().getSharedPreferences().getString(getString(R.string.key_clock_time),TimePreference.DEFAULT_TIME_VALUE);
      pref.setSummary(time);
    }
  }
}","protected void updatePrefsSummary(Preference pref){
  if (pref == null) {
    return;
  }
  if (pref instanceof ListPreference) {
    ListPreference lst=(ListPreference)pref;
    String currentValue=lst.getValue();
    int index=lst.findIndexOfValue(currentValue);
    CharSequence[] entries=lst.getEntries();
    CharSequence[] entryValues=lst.getEntryValues();
    if (index >= 0 && index < entries.length) {
      boolean currentValueIsOffOrEmpty=currentValue.equals(entryValues[0]) || currentValue.equals(entryValues[1]);
      if (pref.getKey().equals(getString(R.string.key_signal_3g)) && !currentValueIsOffOrEmpty) {
        pref.setSummary(entries[index] + ""String_Node_Str"" + getString(R.string.network_icon_info));
      }
 else {
        pref.setSummary(entries[index]);
      }
    }
  }
 else   if (pref instanceof TimePreference) {
    if (pref.getKey().equals(getString(R.string.key_clock_time))) {
      String time=((TimePreference)pref).getTime();
      pref.setSummary(time);
    }
  }
}"
27982,"private String toTimeDigits(int i){
  String digit=String.valueOf(i);
  if (i < 10) {
    digit=""String_Node_Str"" + digit;
  }
  return digit;
}","private String toTimeDigits(String digit){
  if (digit.length() == 1) {
    digit=""String_Node_Str"" + digit;
  }
  return digit;
}"
27983,"private void updateTime(){
  if (mTimePicker != null) {
    mLastHour=mTimePicker.getCurrentHour();
    mLastMinute=mTimePicker.getCurrentMinute();
  }
 else {
    String time=getPersistedString(DEFAULT_TIME_VALUE);
    mLastHour=getHour(time);
    mLastMinute=getMinute(time);
  }
  String hourValue=String.valueOf(mLastHour);
  if (mIs24HourFormat) {
    hourValue=toTimeDigits(mLastHour);
  }
 else {
    if (mLastHour > 12) {
      hourValue=String.valueOf(mLastHour - 12);
    }
  }
  String time=hourValue + ""String_Node_Str"" + toTimeDigits(mLastMinute);
  if (callChangeListener(time)) {
    persistString(time);
  }
}","private void updateTime(){
  if (mTimePicker != null) {
    mLastHour=mTimePicker.getCurrentHour();
    mLastMinute=mTimePicker.getCurrentMinute();
  }
 else {
    String time=getPersistedString(DEFAULT_TIME_VALUE);
    mLastHour=getHour(time);
    mLastMinute=getMinute(time);
  }
  String hourValue=String.valueOf(mLastHour);
  if (mIs24HourFormat) {
    hourValue=toTimeDigits(mLastHour);
  }
 else {
    if (mLastHour > 12) {
      hourValue=toTimeDigits(String.valueOf(mLastHour - 12));
    }
  }
  mTime=hourValue + ""String_Node_Str"" + toTimeDigits(mLastMinute);
  if (callChangeListener(mTime)) {
    persistString(String.format(""String_Node_Str"",String.valueOf(mLastHour),toTimeDigits(mLastMinute)));
  }
}"
27984,"@Override protected void onBindView(View view){
  super.onBindView(view);
  String json=getSharedPreferences().getString(getUserColoursKey(),""String_Node_Str"");
  mColours=new Gson().fromJson(json,new TypeToken<ArrayList<Colour>>(){
  }
.getType());
  if (mColours == null) {
    mColours=new ArrayList<Colour>();
    String[] defaultColourNames=getContext().getResources().getStringArray(R.array.default_colour_choices);
    String[] defaultColourValues=getContext().getResources().getStringArray(R.array.default_colour_choice_values);
    for (int i=0; i < defaultColourValues.length; i++) {
      mColours.add(new Colour(defaultColourNames[i],Color.parseColor(defaultColourValues[i])));
    }
  }
  Collections.sort(mColours);
  int value=getPersistedInt(0);
  if (value == 0) {
    value=mColours.get(0).mColourValue;
    setValue(value);
  }
  setColourValue((ImageView)view.findViewById(R.id.colour_view),value);
  ((TextView)view.findViewById(R.id.colour_name)).setText(getTitle());
}","@Override protected void onBindView(View view){
  super.onBindView(view);
  String json=getSharedPreferences().getString(getUserColoursKey(),""String_Node_Str"");
  mColours=new Gson().fromJson(json,new TypeToken<ArrayList<Colour>>(){
  }
.getType());
  if (mColours == null) {
    mColours=new ArrayList<Colour>();
    String[] defaultColourNames=getContext().getResources().getStringArray(R.array.default_colour_choices);
    String[] defaultColourValues=getContext().getResources().getStringArray(R.array.default_colour_choice_values);
    for (int i=0; i < defaultColourValues.length; i++) {
      mColours.add(new Colour(defaultColourNames[i],Color.parseColor(defaultColourValues[i])));
    }
  }
  Collections.sort(mColours);
  int value=getPersistedInt(0);
  if (value == 0) {
    value=mColours.get(0).mColourValue;
    setValue(value);
  }
  setColourValue((ImageView)view.findViewById(R.id.colour_view),value);
}"
27985,"private void init(){
  setWidgetLayoutResource(R.layout.colour_preference_row);
}","private void init(){
  setWidgetLayoutResource(R.layout.colour_preference);
}"
27986,"@Override protected void onBindView(View view){
  super.onBindView(view);
  String json=getSharedPreferences().getString(getUserColoursKey(),""String_Node_Str"");
  mColours=new Gson().fromJson(json,new TypeToken<ArrayList<Colour>>(){
  }
.getType());
  if (mColours == null) {
    mColours=new ArrayList<Colour>();
    String[] defaultColourNames=getContext().getResources().getStringArray(R.array.default_colour_choices);
    String[] defaultColourValues=getContext().getResources().getStringArray(R.array.default_colour_choice_values);
    for (int i=0; i < defaultColourValues.length; i++) {
      mColours.add(new Colour(defaultColourNames[i],Color.parseColor(defaultColourValues[i])));
    }
  }
  Collections.sort(mColours);
  int value=getPersistedInt(0);
  if (value == 0) {
    value=mColours.get(0).mColourValue;
    setValue(value);
  }
  setColourValue((ImageView)view.findViewById(R.id.colour_view),value);
  ((TextView)view.findViewById(R.id.colour_name)).setText(getTitle());
}","@Override protected void onBindView(View view){
  super.onBindView(view);
  String json=getSharedPreferences().getString(getUserColoursKey(),""String_Node_Str"");
  mColours=new Gson().fromJson(json,new TypeToken<ArrayList<Colour>>(){
  }
.getType());
  if (mColours == null) {
    mColours=new ArrayList<Colour>();
    String[] defaultColourNames=getContext().getResources().getStringArray(R.array.default_colour_choices);
    String[] defaultColourValues=getContext().getResources().getStringArray(R.array.default_colour_choice_values);
    for (int i=0; i < defaultColourValues.length; i++) {
      mColours.add(new Colour(defaultColourNames[i],Color.parseColor(defaultColourValues[i])));
    }
  }
  Collections.sort(mColours);
  int value=getPersistedInt(0);
  if (value == 0) {
    value=mColours.get(0).mColourValue;
    setValue(value);
  }
  setColourValue((ImageView)view.findViewById(R.id.colour_view),value);
}"
27987,"private void init(){
  setWidgetLayoutResource(R.layout.colour_preference_row);
}","private void init(){
  setWidgetLayoutResource(R.layout.colour_preference);
}"
27988,"private void addAnimator(AnimatorBundle... animators){
  boolean added=true;
  for (  AnimatorBundle animator : animators) {
    added&=mSetAnimatorBundles.add(animator);
  }
  if (!added) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","private void addAnimator(AnimatorBundle... animators){
  for (  AnimatorBundle animator : animators) {
    if (!mSetAnimatorBundles.add(animator)) {
      throw new IllegalArgumentException(""String_Node_Str"" + animator.mTypeAnimation + ""String_Node_Str"");
    }
  }
}"
27989,"protected void animateOnScroll(float boundedRatioTranslationY,float translationY){
  if (mLastTranslationApplied == boundedRatioTranslationY) {
    return;
  }
  mLastTranslationApplied=boundedRatioTranslationY;
  for (  AnimatorBuilder.AnimatorBundle animatorBundle : mSetAnimatorBundles) {
    float interpolatedTranslation=animatorBundle.mInterpolator == null ? boundedRatioTranslationY : animatorBundle.mInterpolator.getInterpolation(boundedRatioTranslationY);
    float valueAnimation=animatorBundle.mFromValue + (animatorBundle.mDelta * interpolatedTranslation);
switch (animatorBundle.mTypeAnimation) {
case SCALEX:
      StikkyCompat.setScaleX(animatorBundle.mView,valueAnimation);
    break;
case SCALEY:
  StikkyCompat.setScaleY(animatorBundle.mView,valueAnimation);
break;
case SCALEXY:
StikkyCompat.setScaleX(animatorBundle.mView,valueAnimation);
StikkyCompat.setScaleY(animatorBundle.mView,valueAnimation);
break;
case FADE:
StikkyCompat.setAlpha(animatorBundle.mView,valueAnimation);
break;
case TRANSLATIONX:
StikkyCompat.setTranslationX(animatorBundle.mView,valueAnimation);
break;
case TRANSLATIONY:
StikkyCompat.setTranslationY(animatorBundle.mView,valueAnimation);
break;
case PARALLAX:
StikkyCompat.setTranslationY(animatorBundle.mView,animatorBundle.mDelta * translationY);
break;
}
}
}","protected void animateOnScroll(float boundedRatioTranslationY,float translationY){
  if (mLastTranslationApplied == boundedRatioTranslationY) {
    return;
  }
  mLastTranslationApplied=boundedRatioTranslationY;
  for (  AnimatorBuilder.AnimatorBundle animatorBundle : mSetAnimatorBundles) {
    float interpolatedTranslation=animatorBundle.mInterpolator == null ? boundedRatioTranslationY : animatorBundle.mInterpolator.getInterpolation(boundedRatioTranslationY);
    float valueAnimation=animatorBundle.mFromValue + (animatorBundle.mDelta * interpolatedTranslation);
switch (animatorBundle.mTypeAnimation) {
case SCALEX:
      StikkyCompat.setScaleX(animatorBundle.mView,valueAnimation);
    break;
case SCALEY:
  StikkyCompat.setScaleY(animatorBundle.mView,valueAnimation);
break;
case SCALEXY:
StikkyCompat.setScaleX(animatorBundle.mView,valueAnimation);
StikkyCompat.setScaleY(animatorBundle.mView,valueAnimation);
break;
case FADE:
StikkyCompat.setAlpha(animatorBundle.mView,valueAnimation);
break;
case TRANSLATIONX:
StikkyCompat.setTranslationX(animatorBundle.mView,valueAnimation);
break;
case TRANSLATIONY:
StikkyCompat.setTranslationY(animatorBundle.mView,valueAnimation - translationY);
break;
case PARALLAX:
StikkyCompat.setTranslationY(animatorBundle.mView,animatorBundle.mDelta * translationY);
break;
}
}
}"
27990,"@Override public void onScroll(int scrolledY){
  StikkyCompat.setTranslationY(getHeader(),Math.max(scrolledY,getMaxTranslation()));
  mTranslationRatio=calculateTranslationRatio(scrolledY);
}","@Override public void onScroll(int scrolledY){
  StikkyCompat.setTranslationY(mHeader,Math.max(scrolledY,getMaxTranslation()));
  mTranslationRatio=calculateTranslationRatio(scrolledY);
}"
27991,"/** 
 * Called by the   {@link it.carlom.stikkyheader.core.StikkyHeader} to set the {@link HeaderAnimator} up
 */
void setupAnimator(final View header,final int minHeightHeader,final int heightHeader,final int maxTranslation){
  this.mHeader=header;
  this.mMinHeightHeader=minHeightHeader;
  this.mHeightHeader=heightHeader;
  this.mMaxTranslation=maxTranslation;
  onAnimatorAttached();
  mHeader.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      mHeader.getViewTreeObserver().removeGlobalOnLayoutListener(this);
      onAnimatorReady();
    }
  }
);
}","/** 
 * Called by the   {@link it.carlom.stikkyheader.core.StikkyHeader} to set the {@link HeaderAnimator} up
 */
void setupAnimator(final View header,final int minHeightHeader){
  this.mHeader=header;
  this.mMinHeightHeader=minHeightHeader;
  onAnimatorAttached();
  mHeader.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
    @Override public void onGlobalLayout(){
      mHeader.getViewTreeObserver().removeGlobalOnLayoutListener(this);
      onAnimatorReady();
    }
  }
);
}"
27992,"protected void measureHeaderHeight(){
  int height=mHeader.getHeight();
  if (height == 0) {
    mHeader.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
      @Override public void onGlobalLayout(){
        mHeader.getViewTreeObserver().removeGlobalOnLayoutListener(this);
        int height=mHeader.getHeight();
        setHeightHeader(height);
      }
    }
);
  }
 else {
    setHeightHeader(height);
  }
}","protected void measureHeaderHeight(){
  int height=mHeader.getHeight();
  if (height == 0) {
    final ViewGroup.LayoutParams lp=mHeader.getLayoutParams();
    if (lp != null) {
      height=lp.height;
    }
    if (height <= 0) {
      mHeader.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener(){
        @Override public void onGlobalLayout(){
          mHeader.getViewTreeObserver().removeGlobalOnLayoutListener(this);
          int height=mHeader.getHeight();
          setHeightHeader(height);
        }
      }
);
      return;
    }
  }
  setHeightHeader(height);
}"
27993,"protected void setupAnimator(){
  mHeaderAnimator.setupAnimator(mHeader,mMinHeightHeader,mHeightHeader,mMaxHeaderTranslation);
}","protected void setupAnimator(){
  mHeaderAnimator.setupAnimator(mHeader,mMinHeightHeader);
}"
27994,"private int calculateScrollYList(){
  View c=mListView.getChildAt(0);
  if (c == null) {
    return 0;
  }
  int firstVisiblePosition=mListView.getFirstVisiblePosition();
  int top=c.getTop();
  int headerHeight=0;
  if (firstVisiblePosition >= 1) {
    headerHeight=mHeightHeader;
  }
  return -top + firstVisiblePosition * c.getHeight() + headerHeight;
}","private int calculateScrollYList(){
  View c=mListView.getChildAt(0);
  if (c == null) {
    return 0;
  }
  int firstVisiblePosition=mListView.getFirstVisiblePosition();
  int headerHeight=0;
  if (firstVisiblePosition >= 1) {
    headerHeight=mHeightHeader;
  }
  return -c.getTop() + firstVisiblePosition * c.getHeight() + headerHeight;
}"
27995,"private void init(){
  measureHeaderHeight();
  setupAnimator();
  setupOnScrollListener();
}","private void init(){
  setupAnimator();
  measureHeaderHeight();
}"
27996,"@Override protected void setHeightHeader(int heightHeader){
  super.setHeightHeader(heightHeader);
  setupItemDecorator();
}","@Override protected void setHeightHeader(int heightHeader){
  super.setHeightHeader(heightHeader);
  setupItemDecorator();
  setupOnScrollListener();
}"
27997,"private void setupItemDecorator(){
  final RecyclerView.LayoutManager layoutManager=mRecyclerView.getLayoutManager();
  if (layoutManager instanceof GridLayoutManager) {
    int orientation=((GridLayoutManager)layoutManager).getOrientation();
switch (orientation) {
case LinearLayoutManager.VERTICAL:
      mRecyclerView.addItemDecoration(new RecyclerView.ItemDecoration(){
        @Override public void getItemOffsets(        Rect outRect,        View view,        RecyclerView parent,        RecyclerView.State state){
          super.getItemOffsets(outRect,view,parent,state);
          int position=parent.getChildLayoutPosition(view);
          if (position < ((GridLayoutManager)layoutManager).getSpanCount()) {
            outRect.top=mHeightHeader;
          }
        }
      }
);
    break;
case LinearLayoutManager.HORIZONTAL:
  break;
}
}
 else if (layoutManager instanceof LinearLayoutManager) {
int orientation=((LinearLayoutManager)layoutManager).getOrientation();
switch (orientation) {
case LinearLayoutManager.VERTICAL:
mRecyclerView.addItemDecoration(new RecyclerView.ItemDecoration(){
  @Override public void getItemOffsets(  Rect outRect,  View view,  RecyclerView parent,  RecyclerView.State state){
    super.getItemOffsets(outRect,view,parent,state);
    int position=parent.getChildLayoutPosition(view);
    if (position == 0) {
      outRect.top=mHeightHeader;
    }
  }
}
);
break;
case LinearLayoutManager.HORIZONTAL:
break;
}
}
}","private void setupItemDecorator(){
  final RecyclerView.LayoutManager layoutManager=mRecyclerView.getLayoutManager();
  if (layoutManager instanceof GridLayoutManager) {
    int orientation=((GridLayoutManager)layoutManager).getOrientation();
switch (orientation) {
case LinearLayoutManager.VERTICAL:
      mRecyclerView.addItemDecoration(new RecyclerView.ItemDecoration(){
        @Override public void getItemOffsets(        Rect outRect,        View view,        RecyclerView parent,        RecyclerView.State state){
          super.getItemOffsets(outRect,view,parent,state);
          int position=parent.getChildAdapterPosition(view);
          if (position < ((GridLayoutManager)layoutManager).getSpanCount()) {
            outRect.top=mHeightHeader;
          }
        }
      }
);
    break;
case LinearLayoutManager.HORIZONTAL:
  throw new IllegalStateException(""String_Node_Str"");
}
}
 else if (layoutManager instanceof LinearLayoutManager) {
int orientation=((LinearLayoutManager)layoutManager).getOrientation();
switch (orientation) {
case LinearLayoutManager.VERTICAL:
mRecyclerView.addItemDecoration(new RecyclerView.ItemDecoration(){
  @Override public void getItemOffsets(  Rect outRect,  View view,  RecyclerView parent,  RecyclerView.State state){
    super.getItemOffsets(outRect,view,parent,state);
    if (parent.getChildAdapterPosition(view) == 0) {
      outRect.top=mHeightHeader;
    }
  }
}
);
break;
case LinearLayoutManager.HORIZONTAL:
throw new IllegalStateException(""String_Node_Str"");
}
}
}"
27998,"private void setupOnScrollListener(){
  mRecyclerView.setOnScrollListener(new OnScrollListenerRecycler());
}","private void setupOnScrollListener(){
  if (mOnScrollerListenerStikky != null) {
    mRecyclerView.removeOnScrollListener(mOnScrollerListenerStikky);
  }
  mScrolledY=Integer.MIN_VALUE;
  mOnScrollerListenerStikky=new OnScrollListenerStikky();
  mRecyclerView.addOnScrollListener(mOnScrollerListenerStikky);
}"
27999,"@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  mScrolledY+=dy;
  mHeaderAnimator.onScroll(-mScrolledY);
}","@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  if (mScrolledY == Integer.MIN_VALUE) {
    mScrolledY=calculateScrollRecyclerView();
  }
 else {
    mScrolledY+=dy;
  }
  mHeaderAnimator.onScroll(-mScrolledY);
}"
28000,"@Override public void getItemOffsets(Rect outRect,View view,RecyclerView parent,RecyclerView.State state){
  super.getItemOffsets(outRect,view,parent,state);
  int position=parent.getChildLayoutPosition(view);
  if (position == 0) {
    outRect.top=mHeightHeader;
  }
}","@Override public void getItemOffsets(Rect outRect,View view,RecyclerView parent,RecyclerView.State state){
  super.getItemOffsets(outRect,view,parent,state);
  if (parent.getChildAdapterPosition(view) == 0) {
    outRect.top=mHeightHeader;
  }
}"
